{
  "language": "scala",
  "name": "HumanEval_103_rounded_avg",
  "results": [
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val sum = n to m\n        val average = sum.sum / sum.size\n        val binary = average.toBinaryString\n        val rounded = binary.toLong\n        val result = if (rounded == average) Right(rounded) else Left(s\"$rounded is not an integer.\")\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpgh6cqo31.scala:22)\n\tat Problem.main(tmpgh6cqo31.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798144
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val sum = n to m\n        val avg = sum.sum / sum.size\n        val bin = Integer.toBinaryString(avg)\n        if (bin.length < m) Left(bin)\n        else Right(bin)\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp4f3kkrbd.scala:16:41 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbin\u001b[0m = Integer.toBinaryString(avg)\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                         Found:    (avg : Long)\n\u001b[31m   |\u001b[0m                                         Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp4f3kkrbd.scala:18:19 --------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33melse\u001b[0m Right(bin)\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Found:    (bin : String)\n\u001b[31m   |\u001b[0m                   Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659798144
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val avg = ((n+m)/2).toInt\n        val binary = avg.toBinaryString\n        val result = Right(binary)\n        if (n >= m) Left(-1)\n        else result\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp617b2f9l.scala:17:25 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mif\u001b[0m (n >= m) Left(-\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Found:    (\u001b[31m-1\u001b[0m : Int)\n\u001b[31m   |\u001b[0m                         Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp617b2f9l.scala:18:13 --------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33melse\u001b[0m result\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m             Found:    (result : Right[Nothing, String])\n\u001b[31m   |\u001b[0m             Required: Either[String, Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659798143
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val avg = n to m by -1\n        val binary = avg.map(_.toBinaryString).mkString\n        val rounded = binary.reverse.tail.foldLeft(0)(_ + _)\n        val result = if (rounded == 0) Right(rounded) else Left(s\"$rounded != 0\")\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpxv67wxg6.scala:18:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        result\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    \u001b[1m\u001b[31m(\u001b[0m\u001b[1m\u001b[31mresult\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31m:\u001b[0m\u001b[1m\u001b[31m \u001b[0mEither[String, \u001b[1m\u001b[31mInt\u001b[0m]\u001b[1m\u001b[31m)\u001b[0m\n\u001b[31m   |\u001b[0m        Required: Either[String, \u001b[1m\u001b[32mLong\u001b[0m]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659798143
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val n = math.max(math.min(n, m), -1)\n        val m = math.max(math.min(m, n), -1)\n        val sum = (n to m).sum\n        val avg = sum / math.max(m - n, 1)\n        val bin = math.round(avg).toBinaryString\n        val result = if (bin == \"\") -1 else bin\n        Left(result)\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpnolx8vpu.scala:14:34 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mn\u001b[0m = math.max(math.min(n, m), -\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Recursive \u001b[33mvalue\u001b[0m \u001b[35mn\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpnolx8vpu.scala:15:34 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mm\u001b[0m = math.max(math.min(m, n), -\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Recursive \u001b[33mvalue\u001b[0m \u001b[35mm\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpnolx8vpu.scala:15:37 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mm\u001b[0m = math.max(math.min(m, n), -\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Recursive \u001b[33mvalue\u001b[0m \u001b[35mn\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpnolx8vpu.scala:20:13 --------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        Left(result)\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m             Found:    (result : Int)\n\u001b[31m   |\u001b[0m             Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659798142
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val avg = n to m by -1\n        val sum = n to m by -1\n        val avg = sum.sum / sum.size\n        val binary = avg.toBinaryString\n        val result = binary.reverse\n        val left = binary.takeWhile(_ != '0').mkString\n        val right = binary.dropWhile(_ == '0').mkString\n        val result = left + right\n        val result = if (result == \"0\") -1 else result\n        val result = if (result < \"0\") \"0b\" + result else result\n        val result = if (result < \"0\") \"0b\" + result else result\n        val result = if (result < \"0\") \"0b\" + result else result\n        val result = if (result < \"0\") \"0b\" + result else result\n        val result = if (result < \"0\") \"0b\" + result else result\n        val result = if (result < \"0\") \"0b\" + result else result\n        val result = if (result < \"0\") \"0b\" + result else result\n        val result = if (result < \"0\") \"0b\" + result else result\n        val result = if (result < \"0\") \"0b\" + result else result\n        val result = if (result < \"0\") \"0b\" + result else result\n        val result = if (result < \"0\") \"0b\" + result else result\n        val result = if (result < \"0\") \"0b\" + result else result\n        val result = if (result < \"0\") \"0b\" + result else result\n        val result = if (result < \"0\") \"0b\" + result else result\n        val result = if (result < \"0\") \"0b\" + result else result\n        val result = if (result < \"0\") \"0b\" + result else result\n        val result = if (result < \"0\") \"0b\" + result else result\n        val result = if (result < \"0\") \"0b\" + result else result\n        val result = if (result < \"0\") \"0b\" + result else result\n        val result = if (result < \"0\") \"0b\" + result else result\n        val result = if (result < \"0\") \"0b\" + result else result\n        val result = if (result < \"0\") \"0b\" + result else result\n        val result = if (result < \"0\") \"0b\" + result else result\n        val result = if (result < \"0\") \"0b\" + result else result\n        val result = if (result < \"0\") \"0b\" + result else result\n        val result = if (result < \"0\") \"0b\" + result else result\n        val \n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpe3a_6448.scala:49:11 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m49 |\u001b[0m        \u001b[33mval\u001b[0m \n\u001b[31m\u001b[31m   |\u001b[0m           ^\u001b[0m\n\u001b[31m   |\u001b[0m           pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpe3a_6448.scala:16:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mavg\u001b[0m = sum.sum / sum.size\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mavg is already defined as \u001b[33mvalue\u001b[0m \u001b[35mavg\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpe3a_6448.scala:21:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = left + right\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mresult is already defined as \u001b[33mvalue\u001b[0m \u001b[35mresult\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpe3a_6448.scala:22:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mif\u001b[0m (result == \u001b[31m\"0\"\u001b[0m) -\u001b[31m1\u001b[0m \u001b[33melse\u001b[0m result\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mresult is already defined as \u001b[33mvalue\u001b[0m \u001b[35mresult\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpe3a_6448.scala:23:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mif\u001b[0m (result < \u001b[31m\"0\"\u001b[0m) \u001b[31m\"0b\"\u001b[0m + result \u001b[33melse\u001b[0m result\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mresult is already defined as \u001b[33mvalue\u001b[0m \u001b[35mresult\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded ",
      "stdout": "",
      "timestamp": 1659798143
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val n = math.max(math.min(n, m), -1L)\n        val m = math.max(math.min(m, n), -1L)\n        val sum = (n to m).foldLeft(0L)(_ + _)\n        val avg = math.round(sum / m.toDouble).toBinaryString\n        val result = if (avg == 0) Left(-1) else Right(avg)\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpq6j8i86m.scala:14:34 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mn\u001b[0m = math.max(math.min(n, m), -\u001b[31m1L\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Recursive \u001b[33mvalue\u001b[0m \u001b[35mn\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpq6j8i86m.scala:15:34 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mm\u001b[0m = math.max(math.min(m, n), -\u001b[31m1L\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Recursive \u001b[33mvalue\u001b[0m \u001b[35mm\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpq6j8i86m.scala:15:37 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mm\u001b[0m = math.max(math.min(m, n), -\u001b[31m1L\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Recursive \u001b[33mvalue\u001b[0m \u001b[35mn\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpq6j8i86m.scala:19:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        result\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    (result : Either[Int, Nothing])\n\u001b[31m   |\u001b[0m        Required: Either[String, Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659798142
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val avg = ((n+m)/2)\n        val binary = avg.toBinaryString\n        val result = binary.substring(binary.length-1, binary.length)\n        val result = result.charAt(0).toLong + result.substring(1)\n        val result = if (result > m) -1 else result\n        val result = if (result < n) -1 else result\n        val result = if (result > 0) \"0b\" + result else result\n        val result = if (result > 0) result else -1\n        Left(result)\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpxq10gr4m.scala:17:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = result.charAt(\u001b[31m0\u001b[0m).toLong + result.substring(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mresult is already defined as \u001b[33mvalue\u001b[0m \u001b[35mresult\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpxq10gr4m.scala:18:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mif\u001b[0m (result > m) -\u001b[31m1\u001b[0m \u001b[33melse\u001b[0m result\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mresult is already defined as \u001b[33mvalue\u001b[0m \u001b[35mresult\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpxq10gr4m.scala:19:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mif\u001b[0m (result < n) -\u001b[31m1\u001b[0m \u001b[33melse\u001b[0m result\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mresult is already defined as \u001b[33mvalue\u001b[0m \u001b[35mresult\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpxq10gr4m.scala:20:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mif\u001b[0m (result > \u001b[31m0\u001b[0m) \u001b[31m\"0b\"\u001b[0m + result \u001b[33melse\u001b[0m result\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mresult is already defined as \u001b[33mvalue\u001b[0m \u001b[35mresult\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpxq10gr4m.scala:21:12 ---------------------------\u001b[0m\u001b[0m\n\u001b",
      "stdout": "",
      "timestamp": 1659798139
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val avg = ((n + m) / 2).round\n        val binary = avg.toBinaryString\n        if (binary.length < 2) Right(binary)\n        else Left(s\"$binary\")\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp66s3ws4n.scala:16:37 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mif\u001b[0m (binary.length < \u001b[31m2\u001b[0m) Right(binary)\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Found:    (binary : String)\n\u001b[31m   |\u001b[0m                                     Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659798143
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val avg = n / (m - n + 1) // average of n through m\n        val bin = math.ceil(avg).toBinaryString\n        val result = if (bin == bin.dropRight(bin.length)) -1 else bin\n        Right(result)\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpk5xwsqy4.scala:15:33 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbin\u001b[0m = math.ceil(avg).toBinaryString\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value toBinaryString is not a member of Double\n1 error found\n",
      "stdout": "",
      "timestamp": 1659798143
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val avg = n / (m + 1)\n        val bin = math.round(avg).toBinaryString\n        val result = if (bin == \"\") -1 else bin\n        Right(result)\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpqaomlklk.scala:17:14 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        Right(result)\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              Found:    (result : Matchable)\n\u001b[31m   |\u001b[0m              Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659798142
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val avg = ((n + m) / 2).round\n        val binary = avg.toBinaryString\n        val result = if (binary == \"\") -1 else binary.toLong\n        Right(result)\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpqtruaa0t.scala:20)\n\tat Problem.main(tmpqtruaa0t.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798144
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val avg = n to m by -1\n        val sum = 0L\n        val binary = \"\"\n        val bin = mutable.BitSet(math.max(m, n))\n        val n = math.max(m, n)\n        for (i <- 0 until n) {\n            val bit = bin(i)\n            val bits = math.max(m, i)\n            val bitMask = math.max(bit, bits)\n            val bitMask2 = math.max(bitMask, bits)\n            val bitMask3 = math.max(bitMask2, bits)\n            val bitMask4 = math.max(bitMask3, bits)\n            val bitMask5 = math.max(bitMask4, bits)\n            val bitMask6 = math.max(bitMask5, bits)\n            val bitMask7 = math.max(bitMask6, bits)\n            val bitMask8 = math.max(bitMask7, bits)\n            val bitMask9 = math.max(bitMask8, bits)\n            val bitMask10 = math.max(bitMask9, bits)\n            val bitMask11 = math.max(bitMask10, bits)\n            val bitMask12 = math.max(bitMask11, bits)\n            val bitMask13 = math.max(bitMask12, bits)\n            val bitMask14 = math.max(bitMask13, bits)\n            val bitMask15 = math.max(bitMask14, bits)\n            val bitMask16 = math.max(bitMask15, bits)\n            val bitMask17 = math.max(bitMask16, bits)\n            val bitMask18 = math.max(bitMask17, bits)\n            val bitMask19 = math.max(bitMask18, bits)\n            val bitMask20 = math.max(bitMask19, bits)\n            val bitMask21 = math.max(bitMask20, bits)\n            val bitMask22 = math.max(bitMask21, bits)\n            val bitMask23 = math.max(bitMask22, bits)\n            val bitMask24 = math.max(bitMask23, bits)\n            val bitMask25 = math.max(bitMask24, bits)\n            val bitMask26 = math.max(bitMask25, bits)\n            val bitMask27 = math.max(bitMask26, bits)\n            val bitMask28 = math.max(bitMask27, bits)\n            val bitMask29 = math.max(bitMask28, bits)\n            val bitMask30 = math.max(bitMask29, bits)\n            val bitMask31 = math.max(bitMask30, bits)\n            val bitMask32 = math.max(bitMask31, bits)\n            val bitMask33 = math.max(bitMask32, \n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmptutakqtf.scala:55:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m55 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmptutakqtf.scala:72:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m72 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmptutakqtf.scala:18:28 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mn\u001b[0m = math.max(m, n)\n\u001b[31m\u001b[31m   |\u001b[0m                            ^\u001b[0m\n\u001b[31m   |\u001b[0m                            Recursive \u001b[33mvalue\u001b[0m \u001b[35mn\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmptutakqtf.scala:17:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbin\u001b[0m = mutable.BitSet(math.max(m, n))\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmptutakqtf.scala:71:1 ---------------------\u001b[0m\u001b[0m\n\u001b[31m71 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m ^\u001b[0m\n\u001b[31m   |\u001b[0m Found:    Unit\n\u001b[31m   |\u001b[0m Required: Either[String, Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[33m\u001b[33m-- Warning: /tmp/tmptutakqtf.scala:56:4 ----------------------------------------\u001b[0m\u001b[0m\n\u001b[33m56 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[33m\u001b[33m   |\u001b[0m    ^\u001b[0m\n\u001b[33m   |\u001b[0m    Line is indented too far to the left, or a `}` is missing\n1 warning found\n5 errors found\n",
      "stdout": "",
      "timestamp": 1659798144
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val n = math.max(math.min(n, m), -1L)\n        val m = math.max(math.min(m, n), -1L)\n        val sum = n to m by -1\n        val avg = sum.sum / sum.size\n        val bin = math.ceil(avg).toBinaryString\n        val result = if (bin == \"\") -1 else bin\n        Right(result)\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp8rtnr0pv.scala:14:34 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mn\u001b[0m = math.max(math.min(n, m), -\u001b[31m1L\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Recursive \u001b[33mvalue\u001b[0m \u001b[35mn\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp8rtnr0pv.scala:15:34 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mm\u001b[0m = math.max(math.min(m, n), -\u001b[31m1L\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Recursive \u001b[33mvalue\u001b[0m \u001b[35mm\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp8rtnr0pv.scala:15:37 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mm\u001b[0m = math.max(math.min(m, n), -\u001b[31m1L\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Recursive \u001b[33mvalue\u001b[0m \u001b[35mn\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp8rtnr0pv.scala:18:33 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbin\u001b[0m = math.ceil(avg).toBinaryString\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value toBinaryString is not a member of Double\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659798142
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val avg = n to m by -1\n        val sum = 0\n        val binary = \"\"\n        for(i <- 0 until avg.length) {\n            val n = avg(i)\n            val m = avg(i + 1)\n            val sum = sum + n\n            val bin = sum.toBinaryString\n            val binary = binary + bin\n        }\n        if(n < m) Left(binary) else Right(sum.toLong)\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp3gjd5rbi.scala:20:22 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36msum\u001b[0m = sum + n\n\u001b[31m\u001b[31m   |\u001b[0m                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                      Recursive \u001b[33mvalue\u001b[0m \u001b[35msum\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659798139
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val avg = n / m\n        val binary = avg.toBinaryString\n        val result = binary.reverse.dropRight(binary.length).reverse\n        val result = Right(result.sum.toLong)\n        val result = Left(result)\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpdcrg686s.scala:17:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = Right(result.sum.toLong)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mresult is already defined as \u001b[33mvalue\u001b[0m \u001b[35mresult\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpdcrg686s.scala:18:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = Left(result)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mresult is already defined as \u001b[33mvalue\u001b[0m \u001b[35mresult\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpdcrg686s.scala:19:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        result\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    (result : String)\n\u001b[31m   |\u001b[0m        Required: Either[String, Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659798142
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val sum = n to m\n        val avg = sum.sum / sum.length\n        val bin = math.ceil(avg).toBinaryString\n        val result = Right(bin)\n        val error = if (bin.length != m.toBinaryString.length) Left(s\"$bin != $m\")\n        else Right(bin)\n        result match {\n            case Left(err) => Left(err)\n            case Right(bin) => Right(bin)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmppl10tcl2.scala:16:33 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbin\u001b[0m = math.ceil(avg).toBinaryString\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value toBinaryString is not a member of Double\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmppl10tcl2.scala:21:35 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            \u001b[33mcase\u001b[0m Left(err) => Left(err)\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                   Found:    (err : Any)\n\u001b[31m   |\u001b[0m                                   Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659798144
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val avg = n/m\n        val binary = avg.toBinaryString\n        val result = binary.reverse.foldLeft(0)((sum, digit) => sum + digit.asDigit)\n        val rounded = result + math.pow(2,binary.length)\n        val result = math.round(rounded)\n        val result = if (result < 0) -1 else result\n        val result = if (result < 10) \"0b\" + result else result\n        Right(result)\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpwvapw8e6.scala:18:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = math.round(rounded)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mresult is already defined as \u001b[33mvalue\u001b[0m \u001b[35mresult\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpwvapw8e6.scala:19:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mif\u001b[0m (result < \u001b[31m0\u001b[0m) -\u001b[31m1\u001b[0m \u001b[33melse\u001b[0m result\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mresult is already defined as \u001b[33mvalue\u001b[0m \u001b[35mresult\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpwvapw8e6.scala:20:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mif\u001b[0m (result < \u001b[31m10\u001b[0m) \u001b[31m\"0b\"\u001b[0m + result \u001b[33melse\u001b[0m result\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mresult is already defined as \u001b[33mvalue\u001b[0m \u001b[35mresult\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659798139
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val sum = 0L\n        val count = m\n        val binary = \"\"\n        while(n >= m){\n            sum += n\n            n -= m\n            count += 1\n        }\n        if(n >= m){\n            binary = binary.reverse\n            binary = binary.dropRight(1)\n            binary = binary.reverse\n        }\n        val avg = sum / count\n        val bin = Integer.toBinaryString(avg)\n        val binary = bin.dropRight(bin.length - 1)\n        val result = binary.reverse\n        val result = result.dropRight(1)\n        val result = result.reverse\n        val result = Right(result)\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpmu07aclu.scala:29:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = bin.dropRight(bin.length - \u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpmu07aclu.scala:31:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = result.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mresult is already defined as \u001b[33mvalue\u001b[0m \u001b[35mresult\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpmu07aclu.scala:32:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = result.reverse\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mresult is already defined as \u001b[33mvalue\u001b[0m \u001b[35mresult\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpmu07aclu.scala:33:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = Right(result)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mresult is already defined as \u001b[33mvalue\u001b[0m \u001b[35mresult\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpmu07aclu.scala:18:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m            sum += n\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of Long - did you mean sum.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpmu07aclu.scala:19:14 -----------",
      "stdout": "",
      "timestamp": 1659798143
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val avg = n to m by -1\n        val binary = avg.map(x => x.toBinaryString).mkString\n        val result = if (n >= m) Left(binary) else Right(binary)\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp6vzo2hc4.scala:17:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        result\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    \u001b[1m\u001b[31m(\u001b[0m\u001b[1m\u001b[31mresult\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31m:\u001b[0m\u001b[1m\u001b[31m \u001b[0mEither[String, \u001b[1m\u001b[31mString\u001b[0m]\u001b[1m\u001b[31m)\u001b[0m\n\u001b[31m   |\u001b[0m        Required: Either[String, \u001b[1m\u001b[32mLong\u001b[0m]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659798142
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val avg = n to m by -1\n        val sum = 0\n        val binary = \"\"\n        val bin = mutable.ArrayBuffer.empty[String]\n        for(i <- 0 until avg.length) {\n            sum += avg(i)\n            bin.append(sum.toBinaryString).append(\"0\")\n        }\n        val binary = bin.mkString\n        val binary = binary.substring(binary.length - 1)\n        val result = if (sum < 0) Left(binary.toLong) else Right(binary.toLong)\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpyq59nknz.scala:22:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = bin.mkString\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpyq59nknz.scala:23:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.substring(binary.length - \u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpyq59nknz.scala:17:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbin\u001b[0m = mutable.ArrayBuffer.empty[\u001b[35mString\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpyq59nknz.scala:19:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m            sum += avg(i)\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of Int - did you mean sum.!=?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpyq59nknz.scala:25:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        result\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    \u001b[1m\u001b[31m(\u001b[0m\u001b[1m\u001b[31mresult\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31m:\u001b[0m\u001b[1m\u001b[31m \u001b[0mEither[\u001b[1m\u001b[31mLong\u001b[0m, Long]\u001b[1m\u001b[31m)\u001b[0m\n\u001b[31m   |\u001b[0m        Required: Either[\u001b[1m\u001b[32mString\u001b[0m, Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n5 errors found\n",
      "stdout": "",
      "timestamp": 1659798143
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val nBits = n.toBinaryString\n        val mBits = m.toBinaryString\n        val nBitsLen = nBits.length\n        val mBitsLen = mBits.length\n        val nBitsSum = n.toInt\n        val mBitsSum = m.toInt\n        val nBitsSumLen = nBitsSum.toBinaryString.length\n        val mBitsSumLen = mBitsSum.toBinaryString.length\n        val nBitsSumLen = nBitsSumLen.toBinaryString\n        val mBitsSumLen = mBitsSumLen.toBinaryString\n        val nBitsSumBits = nBitsSum.toBinaryString\n        val mBitsSumBits = mBitsSum.toBinaryString\n        val nBitsSumBitsLen = nBitsSumBits.length\n        val mBitsSumBitsLen = mBitsSumBits.length\n        val nBitsSumBitsSum = n.toInt\n        val mBitsSumBitsSum = m.toInt\n        val nBitsSumBitsSumLen = nBitsSumBitsSum.toBinaryString.length\n        val mBitsSumBitsSumLen = mBitsSumBitsSum.toBinaryString.length\n        val nBitsSumBitsSumLen = nBitsSumBitsSumLen.toBinaryString\n        val mBitsSumBitsSumLen = mBitsSumBitsSumLen.toBinaryString\n        val nBitsSumBitsSumBits = nBitsSumBitsSum.toBinaryString\n        val mBitsSumBitsSumBits = mBitsSumBitsSum.toBinaryString\n        val nBitsSumBitsSumBitsLen = nBitsSumBitsSumBits.length\n        val mBitsSumBitsSumBitsLen = mBitsSumBitsSumBits.length\n        val nBitsSumBitsSumBitsSum = n.toInt\n        val mBitsSumBitsSumBitsSum = m.toInt\n        val nBitsSumBitsSumBitsSumLen = nBitsSumBitsSumBitsSum.toBinaryString.length\n        val mBitsSumBitsSumBitsSumLen = mBitsSumBitsSumBitsSum.toBinaryString.length\n        val nBitsSumBitsSumBitsSumLen = nBitsSumBitsSumBitsSumLen.toBinaryString\n\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpn3zc8cml.scala:22:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnBitsSumLen\u001b[0m = nBitsSumLen.toBinaryString\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnBitsSumLen is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnBitsSumLen\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpn3zc8cml.scala:23:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmBitsSumLen\u001b[0m = mBitsSumLen.toBinaryString\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmBitsSumLen is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmBitsSumLen\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpn3zc8cml.scala:32:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnBitsSumBitsSumLen\u001b[0m = nBitsSumBitsSumLen.toBinaryString\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnBitsSumBitsSumLen is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnBitsSumBitsSumLen\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpn3zc8cml.scala:33:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmBitsSumBitsSumLen\u001b[0m = mBitsSumBitsSumLen.toBinaryString\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmBitsSumBitsSumLen is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmBitsSumBitsSumLen\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpn3zc8cml.scala:42:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m        \u001b[33mval",
      "stdout": "",
      "timestamp": 1659798143
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val sum = n to m by -1\n        val avg = sum.sum / sum.size\n        val binary = binary(avg)\n        val result = if (sum.size < 2) -1 else binary\n        Right(result)\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmptkvrwbtb.scala:16:21 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary(avg)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                     Recursive \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659798140
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val avg = ((n + m) / 2).round\n        val binary = avg.toBinaryString\n        val result = if (n <= m) Right(binary) else Left(s\"$n to $m is $binary\")\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpg_rijs2a.scala:17:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        result\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    \u001b[1m\u001b[31m(\u001b[0m\u001b[1m\u001b[31mresult\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31m:\u001b[0m\u001b[1m\u001b[31m \u001b[0mEither[String, \u001b[1m\u001b[31mString\u001b[0m]\u001b[1m\u001b[31m)\u001b[0m\n\u001b[31m   |\u001b[0m        Required: Either[String, \u001b[1m\u001b[32mLong\u001b[0m]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659798150
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val avg = n to m by -1\n        val binary = avg.map(x => Integer.toBinaryString(x)).mkString\n        val len = binary.length\n        val result = if (len < 2) \"0b\" + binary else binary.substring(len - 2, len)\n        Right(result)\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmphzv0u04v.scala:15:57 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = avg.map(\u001b[36mx\u001b[0m => Integer.toBinaryString(x)).mkString\n\u001b[31m\u001b[31m   |\u001b[0m                                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                    Found:    (x : Long)\n\u001b[31m   |\u001b[0m                                                    Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmphzv0u04v.scala:18:14 --------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        Right(result)\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              Found:    (result : String)\n\u001b[31m   |\u001b[0m              Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659798152
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val sum : Long = n to m by -1\n        val avg = sum.sum / sum.size\n        val bin = Integer.toBinaryString(avg)\n        val result = if (bin == bin.dropRight(bin.length)) Right(avg) else Left(bin)\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp0tmyrnku.scala:14:25 --------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36msum\u001b[0m : \u001b[35mLong\u001b[0m = n to m by -\u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                 Found:    scala.collection.immutable.NumericRange[Long]\n\u001b[31m   |\u001b[0m                 Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp0tmyrnku.scala:15:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mavg\u001b[0m = sum.sum / sum.size\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value sum is not a member of Long\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659798152
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val n = math.abs(n)\n        val m = math.abs(m)\n        val sum = n + m\n        val avg = sum / 2\n        val bin = math.pow(10, math.ceil(math.log10(avg)))\n        val result = math.round(avg * bin)\n        val binString = bin.toString(2)\n        val result = binString.reverse.dropRight(binString.length - 1).toString + result\n        val result = if (result < \"0\") \"-\" else \"\" + result\n        val result = if (result < \"0\") \"0b\" + result else result\n        val result = if (result < \"0\") \"0b\" + result else result\n        val result = if (result < \"0\") \"0b\" + result else result\n        val result = if (result < \"0\") \"0b\" + result else result\n        val result = if (result < \"0\") \"0b\" + result else result\n        val result = if (result < \"0\") \"0b\" + result else result\n        val result = if (result < \"0\") \"0b\" + result else result\n        val result = if (result < \"0\") \"0b\" + result else result\n        val result = if (result < \"0\") \"0b\" + result else result\n        val result = if (result < \"0\") \"0b\" + result else result\n        val result = if (result < \"0\") \"0b\" + result else result\n        val result = if (result < \"0\") \"0b\" + result else result\n        val result = if (result < \"0\") \"0b\" + result else result\n        val result = if (result < \"0\") \"0b\" + result else result\n        val result = if (result < \"0\") \"0b\" + result else result\n        val result = if (result < \"0\") \"0b\" + result else result\n        val result = if (result < \"0\") \"0b\" + result else result\n        val result = if (result < \"0\") \"0b\" + result else result\n        val result = if (result < \"0\") \"0b\" + result else result\n        val result = if (result < \"0\") \"0b\" + result else result\n        val result = if (result < \"0\") \"0b\" + result else result\n        val result = if (result < \"0\") \"0b\" + result else result\n        val result = if (result < \"0\") \"0b\" + result else result\n        val result = if (result < \"0\") \"0b\" + result else result\n        val result = if (result < \"0\") \"0b\" + result else result\n        val result = if (result < \"0\") \"0b\" + result else \n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpimmqpg2p.scala:48:57 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m48 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mif\u001b[0m (result < \u001b[31m\"0\"\u001b[0m) \u001b[31m\"0b\"\u001b[0m + result \u001b[33melse\u001b[0m \n\u001b[31m\u001b[31m   |\u001b[0m                                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                       expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpimmqpg2p.scala:21:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = binString.reverse.dropRight(binString.length - \u001b[31m1\u001b[0m).toString + result\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mresult is already defined as \u001b[33mvalue\u001b[0m \u001b[35mresult\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpimmqpg2p.scala:22:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mif\u001b[0m (result < \u001b[31m\"0\"\u001b[0m) \u001b[31m\"-\"\u001b[0m \u001b[33melse\u001b[0m \u001b[31m\"\"\u001b[0m + result\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mresult is already defined as \u001b[33mvalue\u001b[0m \u001b[35mresult\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpimmqpg2p.scala:23:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mif\u001b[0m (result < \u001b[31m\"0\"\u001b[0m) \u001b[31m\"0b\"\u001b[0m + result \u001b[33melse\u001b[0m result\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mresult is already defined as \u001b[33mvalue\u001b[0m \u001b[35mresult\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m--",
      "stdout": "",
      "timestamp": 1659798152
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val avg = n to m by -1\n        val binary = avg.map(x => x.toBinaryString).mkString\n        val result = if (n <= m) Right(binary) else Left(s\"$n to $m is out of range\")\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpkhih1fn6.scala:17:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        result\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    \u001b[1m\u001b[31m(\u001b[0m\u001b[1m\u001b[31mresult\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31m:\u001b[0m\u001b[1m\u001b[31m \u001b[0mEither[String, \u001b[1m\u001b[31mString\u001b[0m]\u001b[1m\u001b[31m)\u001b[0m\n\u001b[31m   |\u001b[0m        Required: Either[String, \u001b[1m\u001b[32mLong\u001b[0m]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659798153
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val n = n.toInt\n        val m = m.toInt\n        if (n > m) Left(-1)\n        else {\n            val avg = n + (m - n) / 2\n            val binary = scala.math.pow(10, avg).toBinaryString\n            Right(binary.reverse)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpcnbjnxnk.scala:14:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mn\u001b[0m = n.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                ^\u001b[0m\n\u001b[31m   |\u001b[0m                Recursive \u001b[33mvalue\u001b[0m \u001b[35mn\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpcnbjnxnk.scala:15:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mm\u001b[0m = m.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                ^\u001b[0m\n\u001b[31m   |\u001b[0m                Recursive \u001b[33mvalue\u001b[0m \u001b[35mm\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpcnbjnxnk.scala:16:24 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mif\u001b[0m (n > m) Left(-\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Found:    (\u001b[31m-1\u001b[0m : Int)\n\u001b[31m   |\u001b[0m                        Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpcnbjnxnk.scala:19:49 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = scala.math.pow(\u001b[31m10\u001b[0m, avg).toBinaryString\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         value toBinaryString is not a member of Double\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659798155
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val n = n.toInt\n        val m = m.toInt\n        if (n <= m) Right(n to m)\n        else Left(s\"$n is greater than $m\")\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp8vntzotu.scala:14:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mn\u001b[0m = n.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                ^\u001b[0m\n\u001b[31m   |\u001b[0m                Recursive \u001b[33mvalue\u001b[0m \u001b[35mn\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp8vntzotu.scala:15:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mm\u001b[0m = m.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                ^\u001b[0m\n\u001b[31m   |\u001b[0m                Recursive \u001b[33mvalue\u001b[0m \u001b[35mm\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659798149
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val sum = (n to m).sum\n        val avg = sum / 2\n        val bin = Integer.toBinaryString(avg)\n        val result = if (bin == bin.dropRight(bin.length)) Right(avg) else Left(bin)\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp3aykeamb.scala:16:41 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbin\u001b[0m = Integer.toBinaryString(avg)\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                         Found:    (avg : Long)\n\u001b[31m   |\u001b[0m                                         Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659798154
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val avg = n to m by -1\n        val sum = 0L\n        val binary = \"\"\n        for(i <- 0 until avg.length) {\n            val x = avg(i)\n            val y = math.pow(2, i)\n            val z = math.pow(x, 2)\n            val w = math.pow(y, 2)\n            val t = math.pow(z, 2)\n            val u = math.pow(w, 2)\n            val v = math.pow(u, 2)\n            val w = math.pow(v, 2)\n            val x = math.pow(x, 3)\n            val y = math.pow(y, 3)\n            val z = math.pow(z, 3)\n            val w = math.pow(w, 3)\n            val t = math.pow(t, 3)\n            val u = math.pow(u, 3)\n            val v = math.pow(v, 3)\n            val w = math.pow(w, 3)\n            val x = math.pow(x, 4)\n            val y = math.pow(y, 4)\n            val z = math.pow(z, 4)\n            val w = math.pow(w, 4)\n            val t = math.pow(t, 4)\n            val u = math.pow(u, 4)\n            val v = math.pow(v, 4)\n            val w = math.pow(w, 4)\n            val x = math.pow(x, 5)\n            val y = math.pow(y, 5)\n            val z = math.pow(z, 5)\n            val w = math.pow(w, 5)\n            val t = math.pow(t, 5)\n            val u = math.pow(u, 5)\n            val v = math.pow(v, 5)\n            val w = math.pow(w, 5)\n            val x = math.pow(x, 6)\n            val y = math.pow(y, 6)\n            val z = math.pow(z, 6)\n            val w = math.pow(w, 6)\n            val t = math.pow(t, 6)\n            val u = math.pow(u, 6)\n            val v = math.pow(v, 6)\n            val w = math.pow(w, 6)\n            val x = math.pow(x, 7)\n            val y = math.pow(y, 7)\n            val z = math.pow(z, 7)\n            val w = math.pow(w, 7)\n            val t = math.pow(t, 7)\n            val u = math.pow(u, 7)\n            val v = math.pow(v, 7)\n            val w = math.pow(w, 7)\n            val x = math.pow(x, 8)\n            val y = math.pow(y, 8)\n            val z = math.pow(z, 8)\n            val w = math.pow(w, 8)\n            val t = math.pow(t, 8)\n            val u = math.pow(u, 8)\n            val v = math.pow(v, 8)\n            val w = math.pow(w, 8)\n            val x = math.pow(x, 9)\n            val y = math.pow(y, 9)\n            val z = math.pow(z, 9)\n            val w = math.pow(w, 9)\n            val \n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmp3y1ae065.scala:78:15 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m78 |\u001b[0m            \u001b[33mval\u001b[0m \n\u001b[31m\u001b[31m   |\u001b[0m               ^\u001b[0m\n\u001b[31m   |\u001b[0m               pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp3y1ae065.scala:96:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m96 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp3y1ae065.scala:25:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mw\u001b[0m = math.pow(v, \u001b[31m2\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mw is already defined as \u001b[33mvalue\u001b[0m \u001b[35mw\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp3y1ae065.scala:26:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mx\u001b[0m = math.pow(x, \u001b[31m3\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mx is already defined as \u001b[33mvalue\u001b[0m \u001b[35mx\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp3y1ae065.scala:27:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36my\u001b[0m = math.pow(y, \u001b[31m3\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0my is already defined as \u001b[33mvalue\u001b[0m \u001b[35my\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp3y1ae065.scala:28:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mz\u001b[0m = math.pow(z, \u001b[31m3\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mz is already defined as \u001b[33mvalue\u001b[0m \u001b[35mz\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNot",
      "stdout": "",
      "timestamp": 1659798155
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val avg = n / m\n        val bin = math.ceil(avg).toBinaryString\n        val result = bin.take(bin.length - 1).reverse.mkString\n        Right(result)\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpamtr80d_.scala:15:33 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbin\u001b[0m = math.ceil(avg).toBinaryString\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value toBinaryString is not a member of Double\n1 error found\n",
      "stdout": "",
      "timestamp": 1659798152
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val avg = n to m by -1\n        val binary = avg.map(x => Integer.toBinaryString(x)).mkString\n        val result = if (binary.length == 0) \"0b0\" else binary\n        Right(result)\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp56j7cnwy.scala:15:57 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = avg.map(\u001b[36mx\u001b[0m => Integer.toBinaryString(x)).mkString\n\u001b[31m\u001b[31m   |\u001b[0m                                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                    Found:    (x : Long)\n\u001b[31m   |\u001b[0m                                                    Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp56j7cnwy.scala:17:14 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        Right(result)\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              Found:    (result : String)\n\u001b[31m   |\u001b[0m              Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659798155
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val n = math.max(math.min(n, m), -1)\n        val m = math.max(math.min(m, n), -1)\n        val sum = math.max(m, n) + math.min(n, m)\n        val avg = sum / 2\n        val bin = math.pow(10, math.ceil(math.log10(avg)))\n        val result = bin.toString(2)\n        val right = result.length\n        val left = result.length - right\n        val zeros = math.max(0, left)\n        val ones = math.max(0, right)\n        val result = zeros + result\n        val result = result.substring(0, ones)\n        val result = result + ones\n        val result = result.substring(0, zeros)\n        val result = result + zeros\n        val result = result.substring(0, result.length - 1)\n        val result = result + result.substring(1)\n        val result = result + result.substring(0, result.length - 1)\n        val result = result + result.substring(0, result.length - 1)\n        val result = result + result.substring(0, result.length - 1)\n        val result = result + result.substring(0, result.length - 1)\n        val result = result + result.substring(0, result.length - 1)\n        val result = result + result.substring(0, result.length - 1)\n        val result = result + result.substring(0, result.length - 1)\n        val result = result + result.substring(0, result.length - 1)\n        val result = result + result.substring(0, result.length - 1)\n        val result = result + result.substring(0, result.length - 1)\n        val result = result + result.substring(0, result.length - 1)\n        val result = result + result.substring(0, result.length - 1)\n        val result = result + result.substring(0, result.length - 1)\n        val result = result + result.substring(0, result.length - 1)\n        val result = result + result.substring(0, result.length - 1)\n        val result = result + result.substring(0, result.length - 1)\n        val result = result + result.substring(0, result.length - 1)\n        val result = result + result.substring(0, result.length - 1)\n        val result = result + result.substring(0, result.length - 1)\n        val result = result + result.substring(0, result.length - 1)\n        val result = result + result.substring(0, result.length - 1)\n        val result = result + result.substring(0, result.length - 1)\n        val result = result + result.substring(0, result.length - 1)\n        val result = result + result.substring(0, result.length - 1)\n        val result = result + result.substring(0, result.length - 1)\n        val result = result + result.substring(0, result.length - 1)\n        val result = result + result.substring(0, result.length - 1)\n        val result = result + result.substring(0, result.length - 1)\n        val result = result + result.substring(0, result.length - 1)\n        val result = result + result.substring(0, result.length - 1)\n        val result = result + result.substring(0, result.length - 1)\n        val result = result + result.substring(0, result.length - 1)\n        val result = result + result.substring(0, \n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpq_2rtuhw.scala:64:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m64 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpq_2rtuhw.scala:24:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = zeros + result\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mresult is already defined as \u001b[33mvalue\u001b[0m \u001b[35mresult\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpq_2rtuhw.scala:25:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = result.substring(\u001b[31m0\u001b[0m, ones)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mresult is already defined as \u001b[33mvalue\u001b[0m \u001b[35mresult\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpq_2rtuhw.scala:26:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = result + ones\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mresult is already defined as \u001b[33mvalue\u001b[0m \u001b[35mresult\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpq_2rtuhw.scala:27:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = result.substring(\u001b[31m0\u001b[0m, zeros)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mresult is already defined as \u001b[33mvalue\u001b[0m \u001b[35mresult\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpq_2rtuhw.scala:28:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[",
      "stdout": "",
      "timestamp": 1659798154
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val avg = n to m by -1\n        val binary = avg.map(_.toBinaryString).mkString\n        val rounded = binary.toLong\n        val result = if (rounded == 0) Right(rounded) else Left(s\"$rounded is not a valid binary number\")\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.NumberFormatException: For input string: \"\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\tat java.base/java.lang.Long.parseLong(Long.java:721)\n\tat java.base/java.lang.Long.parseLong(Long.java:836)\n\tat scala.collection.StringOps$.toLong$extension(StringOps.scala:928)\n\tat Problem$.roundedAvg(tmpdsc2su3b.scala:16)\n\tat Problem$.main(tmpdsc2su3b.scala:21)\n\tat Problem.main(tmpdsc2su3b.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798155
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val sum = n to m\n        val avg = sum.sum.toDouble / sum.size\n        val rounded = math.round(avg).toBinaryString\n        val result = Right(rounded)\n        if (rounded > \"1\") {\n            Left(s\"$rounded is greater than 1\")\n        } else {\n            result\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpuemd6253.scala:21:12 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            result\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Found:    (result : Right[Nothing, String])\n\u001b[31m   |\u001b[0m            Required: Either[String, Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659798154
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val sum = (n to m).sum\n        val avg = sum / 2\n        val bin = math.ceil(avg).toBinaryString\n        val result = if (bin == bin.dropRight(bin.length)) -1 else bin\n        Left(result)\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpwd2re0_6.scala:16:33 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbin\u001b[0m = math.ceil(avg).toBinaryString\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value toBinaryString is not a member of Double\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpwd2re0_6.scala:18:13 --------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        Left(result)\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m             Found:    (result : Int)\n\u001b[31m   |\u001b[0m             Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659798155
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val avg = n to m by -1\n        val sum = 0\n        val binary = \"\"\n        for(i <- 0 until avg.length) {\n            val value = avg(i)\n            val bin = math.pow(2, i)\n            val binary = binary.dropRight(bin.length).padTo(\"0\", bin.length)\n            val binary = binary.dropRight(bin.length).padTo(\"0\", bin.length)\n            val binary = binary.dropRight(bin.length).padTo(\"0\", bin.length)\n            val binary = binary.dropRight(bin.length).padTo(\"0\", bin.length)\n            val binary = binary.dropRight(bin.length).padTo(\"0\", bin.length)\n            val binary = binary.dropRight(bin.length).padTo(\"0\", bin.length)\n            val binary = binary.dropRight(bin.length).padTo(\"0\", bin.length)\n            val binary = binary.dropRight(bin.length).padTo(\"0\", bin.length)\n            val binary = binary.dropRight(bin.length).padTo(\"0\", bin.length)\n            val binary = binary.dropRight(bin.length).padTo(\"0\", bin.length)\n            val binary = binary.dropRight(bin.length).padTo(\"0\", bin.length)\n            val binary = binary.dropRight(bin.length).padTo(\"0\", bin.length)\n            val binary = binary.dropRight(bin.length).padTo(\"0\", bin.length)\n            val binary = binary.dropRight(bin.length).padTo(\"0\", bin.length)\n            val binary = binary.dropRight(bin.length).padTo(\"0\", bin.length)\n            val binary = binary.dropRight(bin.length).padTo(\"0\", bin.length)\n            val binary = binary.dropRight(bin.length).padTo(\"0\", bin.length)\n            val binary = binary.dropRight(bin.length).padTo(\"0\", bin.length)\n            val binary = binary.dropRight(bin.length).padTo(\"0\", bin.length)\n            val binary = binary.dropRight(bin.length).padTo(\"0\", bin.length)\n            val binary = binary.dropRight(bin.length).padTo(\"0\", bin.length)\n            val binary = binary.dropRight(bin.length).padTo(\"0\", bin.length)\n            val binary = \n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpjg124lz5.scala:42:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = \n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpjg124lz5.scala:60:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m60 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpjg124lz5.scala:59:1 ---------------------\u001b[0m\u001b[0m\n\u001b[31m59 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m ^\u001b[0m\n\u001b[31m   |\u001b[0m Found:    Unit\n\u001b[31m   |\u001b[0m Required: Either[String, Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[33m\u001b[33m-- Warning: /tmp/tmpjg124lz5.scala:44:4 ----------------------------------------\u001b[0m\u001b[0m\n\u001b[33m44 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[33m\u001b[33m   |\u001b[0m    ^\u001b[0m\n\u001b[33m   |\u001b[0m    Line is indented too far to the left, or a `}` is missing\n1 warning found\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659798155
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val sum = n to m by -1\n        val avg = sum.sum / sum.size\n        val bin = math.ceil(avg).toBinaryString\n        val result = if (bin.size == 0) \"0b0\" else bin\n        Right(result)\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp0dvan_cv.scala:16:33 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbin\u001b[0m = math.ceil(avg).toBinaryString\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value toBinaryString is not a member of Double\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp0dvan_cv.scala:18:14 --------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        Right(result)\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              Found:    (result : String)\n\u001b[31m   |\u001b[0m              Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659798155
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val avg = n to m by -1\n        val binary = avg.map(x => x.toBinaryString).mkString\n        val result = if (n >= m) Right(binary.toLong) else Left(s\"$n to $m doesn't include $n\")\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp1kysmatg.scala:20)\n\tat Problem.main(tmp1kysmatg.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798156
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val nToM = (n to m).toList\n        val nToM2 = nToM.filter(_ > 0)\n        val nToM3 = nToM2.filter(_ > 1)\n        val nToM4 = nToM3.filter(_ > 2)\n        val nToM5 = nToM4.filter(_ > 3)\n        val nToM6 = nToM5.filter(_ > 4)\n        val nToM7 = nToM6.filter(_ > 5)\n        val nToM8 = nToM7.filter(_ > 6)\n        val nToM9 = nToM8.filter(_ > 7)\n        val nToM10 = nToM9.filter(_ > 8)\n        val nToM11 = nToM10.filter(_ > 9)\n        val nToM12 = nToM11.filter(_ > 10)\n        val nToM13 = nToM12.filter(_ > 11)\n        val nToM14 = nToM13.filter(_ > 12)\n        val nToM15 = nToM14.filter(_ > 13)\n        val nToM16 = nToM15.filter(_ > 14)\n        val nToM17 = nToM16.filter(_ > 15)\n        val nToM18 = nToM17.filter(_ > 16)\n        val nToM19 = nToM18.filter(_ > 17)\n        val nToM20 = nToM19.filter(_ > 18)\n        val nToM21 = nToM20.filter(_ > 19)\n        val nToM22 = nToM21.filter(_ > 20)\n        val nToM23 = nToM22.filter(_ > 21)\n        val nToM24 = nToM23.filter(_ > 22)\n        val nToM25 = nToM24.filter(_ > 23)\n        val nToM26 = nToM25.filter(_ > 24)\n        val nToM27 = nToM26.filter(_ > 25)\n        val nToM28 = nToM27.filter(_ > 26)\n        val nToM29 = nToM28.filter(_ > 27)\n        val nToM30 = nToM29.filter(_ > 28)\n        val nToM31 = nToM30.filter(_ > 29)\n        val nToM32 = nToM31.filter(_ > 30)\n        val nToM33 = nToM32.filter(_ > 31)\n        val nToM34 = nToM33.filter(_ > \n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmp94itwmhd.scala:47:38 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m47 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnToM34\u001b[0m = nToM33.filter(_ > \n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                      expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp94itwmhd.scala:48:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m48 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Either[String, Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659798155
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val avg = ((n + m) / 2).round\n        val binary = avg.toBinaryString\n        val result = if (n <= m) Right(binary) else Left(s\"$n to $m is $binary\")\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpg_rijs2a.scala:17:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        result\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    \u001b[1m\u001b[31m(\u001b[0m\u001b[1m\u001b[31mresult\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31m:\u001b[0m\u001b[1m\u001b[31m \u001b[0mEither[String, \u001b[1m\u001b[31mString\u001b[0m]\u001b[1m\u001b[31m)\u001b[0m\n\u001b[31m   |\u001b[0m        Required: Either[String, \u001b[1m\u001b[32mLong\u001b[0m]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659798150
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val n = math.max(math.min(m, n), n)\n        val m = math.max(math.min(m, n), n)\n        val sum = n to m\n        val avg = sum.sum / sum.size\n        val bin = math.round(avg).toBinaryString\n        val result = if (bin.length == 1) \"0b\" + bin else bin\n        Right(result)\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpa8vcauiq.scala:15:34 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mm\u001b[0m = math.max(math.min(m, n), n)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Recursive \u001b[33mvalue\u001b[0m \u001b[35mm\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpa8vcauiq.scala:15:37 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mm\u001b[0m = math.max(math.min(m, n), n)\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Recursive \u001b[33mvalue\u001b[0m \u001b[35mn\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpa8vcauiq.scala:15:41 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mm\u001b[0m = math.max(math.min(m, n), n)\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                         Recursive \u001b[33mvalue\u001b[0m \u001b[35mn\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpa8vcauiq.scala:14:37 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mn\u001b[0m = math.max(math.min(m, n), n)\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Recursive \u001b[33mvalue\u001b[0m \u001b[35mn\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpa8vcauiq.scala:14:41 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mn\u001b[0m = math.max(math.min(m, n), n)\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                         Recursive \u001b[33mvalue\u001b[0m \u001b[35mn\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0",
      "stdout": "",
      "timestamp": 1659798155
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val n = math.abs(n)\n        val m = math.abs(m)\n        val sum = n + m\n        val avg = sum / 2\n        val binary = if (n == m) s\"0b$avg\" else -1\n        val result = if (binary == -1) s\"$n through $m\" else s\"$n through $m (including $n and $m)\"\n        Right(result)\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpiegw02m9.scala:14:25 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mn\u001b[0m = math.abs(n)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                         Recursive \u001b[33mvalue\u001b[0m \u001b[35mn\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpiegw02m9.scala:15:25 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mm\u001b[0m = math.abs(m)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                         Recursive \u001b[33mvalue\u001b[0m \u001b[35mm\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpiegw02m9.scala:20:14 --------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        Right(result)\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              Found:    (result : String)\n\u001b[31m   |\u001b[0m              Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659798155
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val avg = n + (m / 2)\n        val binary = avg.toBinaryString\n        val left = (binary.length - m.toBinaryString.length)\n        val right = binary.length - left\n        val result = binary.substring(0, left) + binary.substring(left, right) + binary.substring(right)\n        val result = result.reverse\n        val result = result.substring(0, result.length - m.toBinaryString.length)\n        val result = result.substring(0, result.length - m.toBinaryString.length + 1) + result.substring(result.length - m.toBinaryString.length)\n        val result = result.substring(0, result.length - m.toBinaryString.length + 1) + result.substring(result.length - m.toBinaryString.length + 1)\n        val result = result.substring(0, result.length - m.toBinaryString.length + 1) + result.substring(result.length - m.toBinaryString.length + 1)\n        val result = result.substring(0, result.length - m.toBinaryString.length + 1) + result.substring(result.length - m.toBinaryString.length + 1)\n        val result = result.substring(0, result.length - m.toBinaryString.length + 1) + result.substring(result.length - m.toBinaryString.length + 1)\n        val result = result.substring(0, result.length - m.toBinaryString.length + 1) + result.substring(result.length - m.toBinaryString.length + 1)\n        val result = result.substring(0, result.length - m.toBinaryString.length + 1) + result.substring(result.length - m.toBinaryString.length + 1)\n        val result = result.substring(0, result.length - m.toBinaryString.length + 1) + result.substring(result.length - m.toBinaryString.length + 1)\n        val result = result.substring(0, result.length - m.toBinaryString.length + 1) + result.substring(result.length - m.toBinaryString.length + 1)\n        val result = result.substring(0, result.length - m.toBinaryString.length + 1) + result.substring(result.length - m.toBinaryString.length + 1)\n        val result = result.substring(0, result.length - m.toBinaryString.length + 1) + result.substring(result.length - m.toBinaryString.length + 1)\n        val result = result.substring(0, result.length - m.toBinaryString.length + 1) + result.substring(result.length - m.toBinaryString.length + 1)\n        val result = result.substring(0, result.length - m.toBinaryString.length + 1) + result.substring(result.length - m.toBinaryString.length + 1)\n        val result = result.substring(0, result.length - m.toBinaryString.length + 1) + result.substring(result.length - m.toBinaryString.length + 1)\n        val result = result.substring(0, result.length - m.toBinaryString.length + 1) + result.substring(result.length - m.toBinaryString.length + 1)\n        val result = result.substring(0, result.length - m.toBinaryString.length + 1) + result.substring(result.length - m.toBinaryString.length + 1)\n        val result = result.substring(0, result.length - m.toBinaryString.length + 1) + result.substring(result.length - m.toBinaryString.length + 1)\n        val result = result.substring(0, result.length - m.to\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpcvs5hknq.scala:39:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpcvs5hknq.scala:19:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = result.reverse\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mresult is already defined as \u001b[33mvalue\u001b[0m \u001b[35mresult\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpcvs5hknq.scala:20:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = result.substring(\u001b[31m0\u001b[0m, result.length - m.toBinaryString.length)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mresult is already defined as \u001b[33mvalue\u001b[0m \u001b[35mresult\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpcvs5hknq.scala:21:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = result.substring(\u001b[31m0\u001b[0m, result.length - m.toBinaryString.length + \u001b[31m1\u001b[0m) + result.substring(result.length - m.toBinaryString.length)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mresult is already defined as \u001b[33mvalue\u001b[0m \u001b[35mresult\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpcvs5hknq.scala:22:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = result.substring(\u001b[31m0\u001b[0m, result.length - m.toBinaryString.length + \u001b[31m1\u001b[0m) + result.substring(result.length - m.to",
      "stdout": "",
      "timestamp": 1659798155
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val n = math.max(math.min(n, m), -1)\n        val m = math.max(math.min(m, n), -1)\n        val sum = n + m\n        val avg = sum / 2\n        val binary = math.round(avg).toBinaryString\n        val result = if (binary == \"\") -1 else binary\n        Right(result)\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpbrjknkwh.scala:14:34 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mn\u001b[0m = math.max(math.min(n, m), -\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Recursive \u001b[33mvalue\u001b[0m \u001b[35mn\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpbrjknkwh.scala:15:34 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mm\u001b[0m = math.max(math.min(m, n), -\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Recursive \u001b[33mvalue\u001b[0m \u001b[35mm\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpbrjknkwh.scala:15:37 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mm\u001b[0m = math.max(math.min(m, n), -\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Recursive \u001b[33mvalue\u001b[0m \u001b[35mn\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659798153
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val avg = n to m by -1\n        val binary = avg.map(x => x.toBinaryString).mkString\n        val result = if (n == m) Right(binary) else Left(s\"$n to $m not possible\")\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpaz_baatp.scala:17:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        result\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    \u001b[1m\u001b[31m(\u001b[0m\u001b[1m\u001b[31mresult\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31m:\u001b[0m\u001b[1m\u001b[31m \u001b[0mEither[String, \u001b[1m\u001b[31mString\u001b[0m]\u001b[1m\u001b[31m)\u001b[0m\n\u001b[31m   |\u001b[0m        Required: Either[String, \u001b[1m\u001b[32mLong\u001b[0m]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659798161
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val avg = n/m\n        val binary = avg.toBinaryString\n        val result = binary.reverse.foldLeft(0)((sum, digit) => sum + digit.asInstanceOf[Int])\n        if (result > 0) Right(result)\n        else Left(s\"$n cannot be divided by $m\")\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp5_0jws5t.scala:21)\n\tat Problem.main(tmp5_0jws5t.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798164
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val avg = n + (m - 1) / 2\n        if (avg > m) Left(-1)\n        else Right(avg)\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpin_rb5o7.scala:15:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mif\u001b[0m (avg > m) Left(-\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (\u001b[31m-1\u001b[0m : Int)\n\u001b[31m   |\u001b[0m                          Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659798163
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val sum = n to m\n        val avg = sum.sum / sum.size\n        val binary = avg.toBinaryString\n        val result = if (n >= m) -1 else binary\n        Right(result)\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp7c6d8k0v.scala:18:14 --------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        Right(result)\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              Found:    (result : Matchable)\n\u001b[31m   |\u001b[0m              Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659798164
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val sum = n to m by -1\n        val avg = sum.sum / sum.size\n        val binary = avg.toBinaryString\n        val result = if (binary.length == 1) \"0b\" + binary else binary\n        Right(result)\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp6vbjvx5k.scala:18:14 --------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        Right(result)\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              Found:    (result : String)\n\u001b[31m   |\u001b[0m              Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659798163
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val n = n.toInt\n        val m = m.toInt\n        val sum = n + m\n        val avg = sum / 2\n        val binary = binary(avg)\n        val result = if (n == m) Right(binary) else Left(s\"$n through $m is $binary\")\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpyybfbmb3.scala:14:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mn\u001b[0m = n.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                ^\u001b[0m\n\u001b[31m   |\u001b[0m                Recursive \u001b[33mvalue\u001b[0m \u001b[35mn\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpyybfbmb3.scala:15:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mm\u001b[0m = m.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                ^\u001b[0m\n\u001b[31m   |\u001b[0m                Recursive \u001b[33mvalue\u001b[0m \u001b[35mm\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpyybfbmb3.scala:18:21 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary(avg)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                     Recursive \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659798160
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val sum = n to m\n        val avg = sum.sum / sum.size\n        val bin = math.round(avg).toBinaryString\n        val result = if (bin.size == 0) \"0b0\" else bin\n        val right = if (bin.size == 0) -1 else bin.size - 1\n        Right(bin.substring(0, right) + result)\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpdncue9dm.scala:19:14 --------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        Right(bin.substring(\u001b[31m0\u001b[0m, right) + result)\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              Found:    String\n\u001b[31m   |\u001b[0m              Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659798165
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val avg = n to m by -1\n        val sum = avg.sum\n        val avg = sum / avg.length\n        val bin = Integer.toBinaryString(avg)\n        val right = (bin.length + 1) * \"0\"\n        val left = bin.dropRight(bin.length)\n        val result = if (right == left) Right(bin) else Left(right)\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpdaknql4y.scala:16:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mavg\u001b[0m = sum / avg.length\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mavg is already defined as \u001b[33mvalue\u001b[0m \u001b[35mavg\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpdaknql4y.scala:17:41 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbin\u001b[0m = Integer.toBinaryString(avg)\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^^^\u001b[0m\n\u001b[31m   |\u001b[0m         Found:    (avg : scala.collection.immutable.NumericRange[Long])\n\u001b[31m   |\u001b[0m         Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E134] Type Error: /tmp/tmpdaknql4y.scala:18:37 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mright\u001b[0m = (bin.length + \u001b[31m1\u001b[0m) * \u001b[31m\"0\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m None of the overloaded alternatives of \u001b[33mmethod\u001b[0m \u001b[35m*\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mInt\u001b[0m with types\n\u001b[31m   |\u001b[0m  (x: Double): Double\n\u001b[31m   |\u001b[0m  (x: Float): Float\n\u001b[31m   |\u001b[0m  (x: Long): Long\n\u001b[31m   |\u001b[0m  (x: Int): Int\n\u001b[31m   |\u001b[0m  (x: Char): Int\n\u001b[31m   |\u001b[0m  (x: Short): Int\n\u001b[31m   |\u001b[0m  (x: Byte): Int\n\u001b[31m   |\u001b[0m match arguments ((\u001b[32m\"0\"\u001b[0m : String))\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpdaknql4y.scala:21:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        result\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    (result : Either[Nothing, String])\n\u001b[31m   |\u001b[0m        Required: Either[String, Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659798166
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val avg = n to m by -1\n        val binary = avg.map(x => Integer.toBinaryString(x)).mkString\n        val result = if (binary.length == 0) \"0b0\" else binary\n        Right(result)\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp56j7cnwy.scala:15:57 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = avg.map(\u001b[36mx\u001b[0m => Integer.toBinaryString(x)).mkString\n\u001b[31m\u001b[31m   |\u001b[0m                                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                    Found:    (x : Long)\n\u001b[31m   |\u001b[0m                                                    Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp56j7cnwy.scala:17:14 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        Right(result)\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              Found:    (result : String)\n\u001b[31m   |\u001b[0m              Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659798155
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val sum = n to m by -1\n        val avg = sum.sum / sum.size\n        val bin = math.ceil(avg).toBinaryString\n        val result = if (bin.length < m) -1 else bin\n        Right(result)\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpagmu0uey.scala:16:33 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbin\u001b[0m = math.ceil(avg).toBinaryString\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value toBinaryString is not a member of Double\n1 error found\n",
      "stdout": "",
      "timestamp": 1659798165
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val avg = n to m by -1\n        val sum = 0\n        val binary = \"\"\n        for(i <- 0 until avg.length) {\n            val x = avg(i)\n            val y = math.pow(2,i)\n            val z = math.pow(2,i+1)\n            val sum = sum + x\n            val binary = binary + y.toBinaryString\n            val binary = binary + z.toBinaryString\n        }\n        if(sum < 0) Left(s\"$sum\")\n        else Right(binary.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpxm6h7bnp.scala:23:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary + z.toBinaryString\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n1 error found\n",
      "stdout": "",
      "timestamp": 1659798162
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val sum = (n to m).foldLeft(0L) { (sum, num) =>\n            sum + num\n        }\n        val avg = sum / m\n        val binary = avg.toBinaryString\n        val result = if (binary == \"\") -1 else binary.toLong\n        val right = if (result < 0) -1 else result\n        Left(s\"$n to $m is $avg. Convert to binary: $binary. Result: $result. Right: $right\")\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpbhhz1vxh.scala:24)\n\tat Problem.main(tmpbhhz1vxh.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798167
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val sum = n to m\n        val avg = sum.sum / sum.size\n        val bin = math.ceil(avg).toBinaryString\n        val result = if (bin == bin.drop(bin.length-1)) bin else bin.dropRight(1)\n        Right(result)\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpz9by72_o.scala:16:33 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbin\u001b[0m = math.ceil(avg).toBinaryString\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value toBinaryString is not a member of Double\n1 error found\n",
      "stdout": "",
      "timestamp": 1659798166
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val avg = n to m by -1\n        val binary = avg.map(x => x.toBinaryString).mkString\n        val result = if (binary.length == 0) \"0b0\" else binary\n        Right(result)\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpene7oib1.scala:17:14 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        Right(result)\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              Found:    (result : String)\n\u001b[31m   |\u001b[0m              Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659798165
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val sum = n to m by -1\n        val avg = sum.sum / sum.length\n        val bin = math.ceil(avg).toBinaryString\n        val result = if (bin == bin.drop(bin.length)) Right(bin) else Left(s\"$n to $m is $avg\")\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpu81796h5.scala:16:33 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbin\u001b[0m = math.ceil(avg).toBinaryString\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value toBinaryString is not a member of Double\n1 error found\n",
      "stdout": "",
      "timestamp": 1659798165
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val avg = n / m\n        val bin = math.ceil(avg).toBinaryString\n        val result = bin.substring(0, bin.length - 1) + bin.substring(bin.length - 1)\n        if (n >= m) Right(result)\n        else Left(s\"$n / $m -> $result\")\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpuh723_u1.scala:15:33 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbin\u001b[0m = math.ceil(avg).toBinaryString\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value toBinaryString is not a member of Double\n1 error found\n",
      "stdout": "",
      "timestamp": 1659798165
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val avg = n to m by -1\n        val binary = avg.map(x => x.toBinaryString).mkString\n        val rounded = binary.toLong\n        val result = if (rounded == 0) Right(rounded) else Left(s\"${rounded}b${binary}\")\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.NumberFormatException: For input string: \"\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\tat java.base/java.lang.Long.parseLong(Long.java:721)\n\tat java.base/java.lang.Long.parseLong(Long.java:836)\n\tat scala.collection.StringOps$.toLong$extension(StringOps.scala:928)\n\tat Problem$.roundedAvg(tmpjibjnoz_.scala:16)\n\tat Problem$.main(tmpjibjnoz_.scala:21)\n\tat Problem.main(tmpjibjnoz_.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798167
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val n = math.max(math.min(n, m), -1)\n        val m = math.max(math.min(m, n), -1)\n        val sum = n to m\n        val sums = sum.map(x => math.pow(2, x))\n        val avg = sums.sum / sums.length\n        val bin = math.round(avg).toBinaryString\n        val result = if (bin == \"\") -1 else bin\n        Left(result)\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp66zv4j17.scala:14:34 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mn\u001b[0m = math.max(math.min(n, m), -\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Recursive \u001b[33mvalue\u001b[0m \u001b[35mn\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp66zv4j17.scala:15:34 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mm\u001b[0m = math.max(math.min(m, n), -\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Recursive \u001b[33mvalue\u001b[0m \u001b[35mm\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp66zv4j17.scala:15:37 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mm\u001b[0m = math.max(math.min(m, n), -\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Recursive \u001b[33mvalue\u001b[0m \u001b[35mn\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp66zv4j17.scala:21:13 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        Left(result)\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m             Found:    (result : Int)\n\u001b[31m   |\u001b[0m             Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659798167
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val sum = n to m by -1\n        val avg = sum.sum / sum.size\n        val binary = avg.toBinaryString\n        val result = if (binary.length < 8) -1 else binary\n        Right(result)\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp8vqbgjgn.scala:18:14 --------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        Right(result)\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              Found:    (result : Matchable)\n\u001b[31m   |\u001b[0m              Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659798166
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val n1 = n / 2\n        val m1 = m / 2\n        val n2 = n - n1\n        val m2 = m - m1\n        val n3 = n1 + n2\n        val m3 = m1 + m2\n        val n4 = n1 + n3\n        val m4 = m1 + m3\n        val n5 = n1 + n4\n        val m5 = m1 + m4\n        val n6 = n1 + n5\n        val m6 = m1 + m5\n        val n7 = n1 + n6\n        val m7 = m1 + m6\n        val n8 = n1 + n7\n        val m8 = m1 + m7\n        val n9 = n1 + n8\n        val m9 = m1 + m8\n        val n10 = n1 + n9\n        val m10 = m1 + m9\n        val n11 = n1 + n10\n        val m11 = m1 + m10\n        val n12 = n1 + n11\n        val m12 = m1 + m11\n        val n13 = n1 + n12\n        val m13 = m1 + m12\n        val n14 = n1 + n13\n        val m14 = m1 + m13\n        val n15 = n1 + n14\n        val m15 = m1 + m14\n        val n16 = n1 + n15\n        val m16 = m1 + m15\n        val n17 = n1 + n16\n        val m17 = m1 + m16\n        val n18 = n1 + n17\n        val m18 = m1 + m17\n        val n19 = n1 + n18\n        val m19 = m1 + m18\n        val n20 = n1 + n19\n        val m20 = m1 + m19\n        val n21 = n1 + n20\n        val m21 = m1 + m20\n        val n22 = n1 + n21\n        val m22 = m1 + m21\n        val n23 = n1 + n22\n        val m23 = m1 + m22\n        val n24 = n1 + n23\n        val m24 = m1 + m23\n        val n25 = n1 + n24\n        val m25 = m1 + m24\n        val n26 = n1 + n25\n        val m26 = m1 + m25\n        val n27 = n1 + n26\n        val m27 = m1 + m26\n        val n28 = n1 + n27\n        val m28 = m1 + m27\n        val n29 = n1 + n28\n        val m29 = m1 + m28\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpia54pg9d.scala:72:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m72 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Either[String, Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659798167
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val n = math.abs(n)\n        val m = math.abs(m)\n        val sum = mutable.ArrayBuffer.empty[Long]\n        val avg = mutable.ArrayBuffer.empty[Long]\n        val n = math.min(n, m)\n        val m = math.max(m, n)\n        for(i <- n until m) {\n            sum += i\n            avg += i\n        }\n        val avg = sum.toDouble / avg.length\n        val bin = Integer.toBinaryString(avg)\n        if(bin.length < m) Left(bin)\n        else Right(bin)\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpjpxghqln.scala:18:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mn\u001b[0m = math.min(n, m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mn is already defined as \u001b[33mvalue\u001b[0m \u001b[35mn\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpjpxghqln.scala:19:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mm\u001b[0m = math.max(m, n)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mm is already defined as \u001b[33mvalue\u001b[0m \u001b[35mm\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpjpxghqln.scala:24:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mavg\u001b[0m = sum.toDouble / avg.length\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mavg is already defined as \u001b[33mvalue\u001b[0m \u001b[35mavg\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpjpxghqln.scala:14:25 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mn\u001b[0m = math.abs(n)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                         Recursive \u001b[33mvalue\u001b[0m \u001b[35mn\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpjpxghqln.scala:15:25 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mm\u001b[0m = math.abs(m)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                         Recursive \u001b[33mvalue\u001b[0m \u001b[35mm\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpjpxghqln.scala:16:18 -------",
      "stdout": "",
      "timestamp": 1659798167
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val sum = n to m by -1\n        val avg = sum.sum / sum.size\n        val bin = math.ceil(avg).toBinaryString\n        val result = if (bin.length == 1) \"0b\" + bin else bin\n        Right(result)\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp6aza92j6.scala:16:33 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbin\u001b[0m = math.ceil(avg).toBinaryString\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value toBinaryString is not a member of Double\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp6aza92j6.scala:18:14 --------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        Right(result)\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              Found:    (result : String)\n\u001b[31m   |\u001b[0m              Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659798167
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val sum = n to m\n        val avg = sum.foldLeft(0L) { (sum, curr) => sum + curr }\n        val rounded = math.round(avg).toBinaryString\n        val result = if (rounded == sum.toBinaryString) Right(rounded) else Left(rounded)\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpcpfl87tf.scala:17:40 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mif\u001b[0m (rounded == sum.toBinaryString) Right(rounded) \u001b[33melse\u001b[0m Left(rounded)\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue toBinaryString is not a member of scala.collection.immutable.NumericRange.Inclusive[Long]\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpcpfl87tf.scala:18:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        result\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    \u001b[1m\u001b[31m(\u001b[0m\u001b[1m\u001b[31mresult\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31m:\u001b[0m\u001b[1m\u001b[31m \u001b[0mEither[String, \u001b[1m\u001b[31mString\u001b[0m]\u001b[1m\u001b[31m)\u001b[0m\n\u001b[31m   |\u001b[0m        Required: Either[String, \u001b[1m\u001b[32mLong\u001b[0m]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659798167
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val n = math.abs(n)\n        val m = math.abs(m)\n        if (n <= m) {\n            Right(math.round(n))\n        } else {\n            Left(s\"$n is greater than $m\")\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpgabqrewp.scala:14:25 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mn\u001b[0m = math.abs(n)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                         Recursive \u001b[33mvalue\u001b[0m \u001b[35mn\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpgabqrewp.scala:15:25 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mm\u001b[0m = math.abs(m)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                         Recursive \u001b[33mvalue\u001b[0m \u001b[35mm\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659798164
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val n = math.max(math.min(n, m), -1L)\n        val m = math.max(math.min(m, n), -1L)\n        val sum = n + m\n        val avg = sum / 2\n        val bin = math.pow(10, math.ceil(math.log10(avg)))\n        val result = math.round(avg * bin)\n        val binString = bin.toString(2)\n        val result = binString.reverse.mkString(\"\")\n        val result = binString.reverse.mkString(\"\")\n        val result = binString.reverse.mkString(\"\")\n        val result = binString.reverse.mkString(\"\")\n        val result = binString.reverse.mkString(\"\")\n        val result = binString.reverse.mkString(\"\")\n        val result = binString.reverse.mkString(\"\")\n        val result = binString.reverse.mkString(\"\")\n        val result = binString.reverse.mkString(\"\")\n        val result = binString.reverse.mkString(\"\")\n        val result = binString.reverse.mkString(\"\")\n        val result = binString.reverse.mkString(\"\")\n        val result = binString.reverse.mkString(\"\")\n        val result = binString.reverse.mkString(\"\")\n        val result = binString.reverse.mkString(\"\")\n        val result = binString.reverse.mkString(\"\")\n        val result = binString.reverse.mkString(\"\")\n        val result = binString.reverse.mkString(\"\")\n        val result = binString.reverse.mkString(\"\")\n        val result = binString.reverse.mkString(\"\")\n        val result = binString.reverse.mkString(\"\")\n        val result = binString.reverse.mkString(\"\")\n        val result = binString.reverse.mkString(\"\")\n        val result = binString.reverse.mkString(\"\")\n        val result = binString.reverse.mkString(\"\")\n        val result = binString.reverse.mkString(\"\")\n        val result = binString.reverse.mkString(\"\")\n        val result = binString.reverse.mkString(\"\")\n        val result = binString.reverse.mkString(\"\")\n        val result = binString.reverse.mkString(\"\")\n        val result = binString.reverse.mkString(\"\")\n        val result = binString.reverse.mkString(\"\")\n        val result = binString.reverse.mkString(\"\")\n        val result = binString.reverse.mkString(\"\")\n        val result = binString.reverse.mkString(\"\")\n        val result = binString.reverse.mkString(\"\")\n        val result = binString.reverse.mkString(\"\")\n        val result = binString.reverse.mkString(\"\")\n        val result = binString.reverse.mkString(\"\")\n        val result = binString.reverse.mkString(\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmp5qgws35i.scala:60:48 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m60 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = binString.reverse.mkString(\n\u001b[31m\u001b[31m   |\u001b[0m                                                ^\u001b[0m\n\u001b[31m   |\u001b[0m                                       expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp5qgws35i.scala:21:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = binString.reverse.mkString(\u001b[31m\"\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mresult is already defined as \u001b[33mvalue\u001b[0m \u001b[35mresult\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp5qgws35i.scala:22:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = binString.reverse.mkString(\u001b[31m\"\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mresult is already defined as \u001b[33mvalue\u001b[0m \u001b[35mresult\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp5qgws35i.scala:23:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = binString.reverse.mkString(\u001b[31m\"\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mresult is already defined as \u001b[33mvalue\u001b[0m \u001b[35mresult\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp5qgws35i.scala:24:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = binString.reverse.mkString(\u001b[31m\"\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^",
      "stdout": "",
      "timestamp": 1659798173
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val avg = ((n + m) / 2).round\n        val binary = avg.toBinaryString\n        if (binary.length < m) Left(s\"$n to $m is $binary\")\n        else if (binary.length > m) Right(-1)\n        else Right(binary)\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpdhy4df84.scala:18:19 --------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33melse\u001b[0m Right(binary)\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Found:    (binary : String)\n\u001b[31m   |\u001b[0m                   Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659798172
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val nBits = n.toString.length\n        val mBits = m.toString.length\n        val nBitsDiff = mBits - nBits\n        val mBitsDiff = nBits - mBits\n        val nBitsDiffToM = mBits - nBits\n        val mBitsDiffToN = nBits - mBits\n        val nBitsDiffToMToN = nBits - mBits\n        val mBitsDiffToNToM = mBits - nBits\n        val nBitsDiffToMToNToM = mBits - nBits\n        val mBitsDiffToNToMToN = nBits - mBits\n        val nBitsDiffToMToNToMToN = nBits - mBits\n        val mBitsDiffToNToMToNToM = mBits - nBits\n        val nBitsDiffToMToNToMToNToM = mBits - nBits\n        val mBitsDiffToNToMToNToMToN = mBits - nBits\n        val nBitsDiffToMToNToMToNToMToN = mBits - nBits\n        val mBitsDiffToNToMToNToMToNToM = mBits - nBits\n        val nBitsDiffToMToNToMToNToMToNToM = mBits - nBits\n        val mBitsDiffToNToMToNToMToNToMToNToM = mBits - nBits\n        val nBitsDiffToMToNToMToNToMToNToMToNToM = mBits - nBits\n        val mBitsDiffToNToMToNToMToNToMToNToMToNToM = mBits - nBits\n        val nBitsDiffToMToNToMToNToMToNToMToNToMToNToM = mBits - nBits\n        val mBitsDiffToNToMToNToMToNToMToNToMToNToMToNToM = mBits - nBits\n        val nBitsDiffToMToNToMToNToMToNToMToNToMToNToMToNToM = mBits \n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp9n_759b6.scala:37:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Either[String, Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659798174
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val nToM : Long = n - m\n        val nToMInt : Long = math.ceil(nToM.toDouble)\n        val nToMBin = math.pow(2, math.ceil(nToM.toDouble)).toBinaryString\n        val nToMBinLen = nToMBin.length\n        val nToMBinLenMinusOne = nToMBinLen - 1\n        val nToMBinLenMinusOneInt = math.pow(2, nToMBinLenMinusOne).toInt\n        val nToMBinLenMinusOneIntInt = math.pow(2, nToMBinLenMinusOneInt).toInt\n        val nToMBinLenMinusOneIntIntInt = math.pow(2, nToMBinLenMinusOneIntInt).toInt\n        val nToMBinLenMinusOneIntIntIntInt = math.pow(2, nToMBinLenMinusOneIntIntInt).toInt\n        val nToMBinLenMinusOneIntIntIntIntInt = math.pow(2, nToMBinLenMinusOneIntIntIntInt).toInt\n        val nToMBinLenMinusOneIntIntIntIntIntInt = math.pow(2, nToMBinLenMinusOneIntIntIntIntInt).toInt\n        val nToMBinLenMinusOneIntIntIntIntIntIntInt = math.pow(2, nToMBinLenMinusOneIntIntIntIntIntInt).toInt\n        val nToMBinLenMinusOneIntIntIntIntIntIntIntIntInt = math.pow(2, nToMBinLenMinusOneIntIntIntIntIntIntIntInt).toInt\n        val nToMBinLenMinusOneIntIntIntIntIntIntIntIntIntIntInt = math.pow(2, nToMBinLenMinusOneIntIntIntIntIntIntIntIntIntInt).toInt\n        val nToMBinLenMinusOneIntIntIntIntIntIntIntIntIntIntIntInt = math.pow(2, nToMBinLenMinusOneIntIntIntIntIntIntIntIntIntIntIntInt).toInt\n        val nToMBinLenMinusOneIntIntIntIntIntIntIntIntIntIntIntIntIntInt = math.pow(2, nToMBinLenMinusOneIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt).toInt\n        val nToMBinLenMinusOneIntIntIntIntIntInt\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp72m3zfj4.scala:31:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp72m3zfj4.scala:15:38 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnToMInt\u001b[0m : \u001b[35mLong\u001b[0m = math.ceil(nToM.toDouble)\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                             Found:    Double\n\u001b[31m   |\u001b[0m                             Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp72m3zfj4.scala:16:60 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnToMBin\u001b[0m = math.pow(\u001b[31m2\u001b[0m, math.ceil(nToM.toDouble)).toBinaryString\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      value toBinaryString is not a member of Double\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp72m3zfj4.scala:26:72 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnToMBinLenMinusOneIntIntIntIntIntIntIntIntInt\u001b[0m = math.pow(\u001b[31m2\u001b[0m, nToMBinLenMinusOneIntIntIntIntIntIntIntInt).toInt\n\u001b[31m\u001b[31m   |\u001b[0m                                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: nToMBinLenMinusOneIntIntIntIntIntIntIntInt\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp72m3zfj4.scala:27:78 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnToMBinLenMinusOneIntIntIntIntIntIntIntIntIntIntInt\u001b[0m = math.pow(\u001b[31m2\u001b[0m, nToMBinLenMinusOneIntIntIntIntIntIntIntIntIntInt).toInt\n\u001b[31m\u001b[31m   |\u001b[0m                                                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[",
      "stdout": "",
      "timestamp": 1659798175
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val avg = n to m by -1\n        val binary = avg.map(x => Integer.toBinaryString(x)).mkString\n        val rounded = binary.toLong\n        val result = if (rounded == 0) Right(rounded) else Left(s\"$rounded is not a binary number\")\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpe04mczkf.scala:15:57 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = avg.map(\u001b[36mx\u001b[0m => Integer.toBinaryString(x)).mkString\n\u001b[31m\u001b[31m   |\u001b[0m                                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                    Found:    (x : Long)\n\u001b[31m   |\u001b[0m                                                    Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659798176
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val sum = n to m\n        val avg = sum.sum / sum.size\n        val bin = math.ceil(avg).toBinaryString\n        val result = if (bin.size == 0) \"0b0\" else bin\n        Right(result)\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpk3d4p99e.scala:16:33 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbin\u001b[0m = math.ceil(avg).toBinaryString\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value toBinaryString is not a member of Double\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpk3d4p99e.scala:18:14 --------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        Right(result)\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              Found:    (result : String)\n\u001b[31m   |\u001b[0m              Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659798177
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val n = math.max(math.min(n, m), -1)\n        val m = math.max(math.min(m, n), -1)\n        val sum = math.max(m, n) - math.min(n, m)\n        val avg = sum / 2\n        val binary = math.pow(10, math.ceil(math.log10(avg)))\n        val result = math.round(avg * binary)\n        val result = math.min(math.max(result, 0), binary)\n        val result = math.max(result, 0)\n        val result = math.min(result, binary)\n        val result = math.max(result, 0)\n        val result = math.min(result, binary)\n        val result = math.max(result, 0)\n        val result = math.min(result, binary)\n        val result = math.max(result, 0)\n        val result = math.min(result, binary)\n        val result = math.max(result, 0)\n        val result = math.min(result, binary)\n        val result = math.max(result, 0)\n        val result = math.min(result, binary)\n        val result = math.max(result, 0)\n        val result = math.min(result, binary)\n        val result = math.max(result, 0)\n        val result = math.min(result, binary)\n        val result = math.max(result, 0)\n        val result = math.min(result, binary)\n        val result = math.max(result, 0)\n        val result = math.min(result, binary)\n        val result = math.max(result, 0)\n        val result = math.min(result, binary)\n        val result = math.max(result, 0)\n        val result = math.min(result, binary)\n        val result = math.max(result, 0)\n        val result = math.min(result, binary)\n        val result = math.max(result, 0)\n        val result = math.min(result, binary)\n        val result = math.max(result, 0)\n        val result = math.min(result, binary)\n        val result = math.max(result, 0)\n        val result = math.min(result, binary)\n        val result = math.max(result, 0)\n        val result = math.min(result, binary)\n        val result = math.max(result, 0)\n        val result = math.min(result, binary)\n        val result = math.max(result, 0)\n        val result = math.min(result, binary)\n        val result = math.max(result, 0)\n        val result = math.min(result, binary)\n        val result = math.max(result, 0)\n        val result = math.min(result, binary)\n        val result = math.max(result, 0)\n        val result = math.min(result, binary)\n        val result = math.max(result, 0)\n        val result = math.min(result, binary)\n        val result = math.max(result, 0)\n        val result = math.min(result, binary)\n        val result = math.max(result, 0)\n        val result = math.min(result, binary)\n        val result = math.max(\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmp8tf0_aj0.scala:71:30 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m71 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = math.max(\n\u001b[31m\u001b[31m   |\u001b[0m                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                              expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp8tf0_aj0.scala:20:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = math.min(math.max(result, \u001b[31m0\u001b[0m), binary)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mresult is already defined as \u001b[33mvalue\u001b[0m \u001b[35mresult\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp8tf0_aj0.scala:21:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = math.max(result, \u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mresult is already defined as \u001b[33mvalue\u001b[0m \u001b[35mresult\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp8tf0_aj0.scala:22:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = math.min(result, binary)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mresult is already defined as \u001b[33mvalue\u001b[0m \u001b[35mresult\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp8tf0_aj0.scala:23:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = math.max(result, \u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mresult is already defined as \u001b[33mvalue\u001b[0m \u001b[35mresult\u001b[0m\n\u001b[31",
      "stdout": "",
      "timestamp": 1659798176
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val n = math.abs(n)\n        val m = math.abs(m)\n        if (n > m) {\n            Left(-1)\n        } else {\n            val sum = (n to m).map(x => math.pow(x, 2)).sum\n            val avg = math.round(sum / 2)\n            Right(math.pow(10, math.ceil(math.log10(avg))).toBinaryString)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpmblqu3zw.scala:14:25 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mn\u001b[0m = math.abs(n)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                         Recursive \u001b[33mvalue\u001b[0m \u001b[35mn\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpmblqu3zw.scala:15:25 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mm\u001b[0m = math.abs(m)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                         Recursive \u001b[33mvalue\u001b[0m \u001b[35mm\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpmblqu3zw.scala:17:17 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            Left(-\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^\u001b[0m\n\u001b[31m   |\u001b[0m                 Found:    (\u001b[31m-1\u001b[0m : Int)\n\u001b[31m   |\u001b[0m                 Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpmblqu3zw.scala:21:59 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            Right(math.pow(\u001b[31m10\u001b[0m, math.ceil(math.log10(avg))).toBinaryString)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value toBinaryString is not a member of Double\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659798177
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val avg = n to m by -1\n        val binary = avg.map(x => Integer.toBinaryString(x)).mkString\n        val result = if (n <= m) Right(binary) else Left(\"-1\")\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp6ghu9kdo.scala:15:57 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = avg.map(\u001b[36mx\u001b[0m => Integer.toBinaryString(x)).mkString\n\u001b[31m\u001b[31m   |\u001b[0m                                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                    Found:    (x : Long)\n\u001b[31m   |\u001b[0m                                                    Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp6ghu9kdo.scala:17:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        result\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    \u001b[1m\u001b[31m(\u001b[0m\u001b[1m\u001b[31mresult\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31m:\u001b[0m\u001b[1m\u001b[31m \u001b[0mEither[String, \u001b[1m\u001b[31mString\u001b[0m]\u001b[1m\u001b[31m)\u001b[0m\n\u001b[31m   |\u001b[0m        Required: Either[String, \u001b[1m\u001b[32mLong\u001b[0m]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659798178
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val avg = n + (m - 1) / 2\n        val bin = Integer.toBinaryString(avg)\n        if (bin.size == m) Right(avg)\n        else Left(s\"$n through $m average is $avg, but should be $bin\")\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpescxfdxe.scala:15:41 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbin\u001b[0m = Integer.toBinaryString(avg)\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                         Found:    (avg : Long)\n\u001b[31m   |\u001b[0m                                         Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659798177
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val avg = n to m by -1\n        val sum = 0L\n        val binary = \"\"\n        for(i <- 0 until avg.length) {\n            val bin = math.pow(2,i)\n            val val = avg(i).toBinaryString\n            val binVal = bin.pow(val.length)\n            val binValStr = binVal.toString(2)\n            val binValStr = binValStr.substring(0, binValStr.length-1)\n            val binValStr = binValStr.substring(binValStr.length-val.length)\n            val binValStr = binValStr.substring(0, binValStr.length-1)\n            val binValStr = binValStr.substring(binValStr.length-val.length)\n            val binValStr = binValStr.substring(0, binValStr.length-1)\n            val binValStr = binValStr.substring(binValStr.length-val.length)\n            val binValStr = binValStr.substring(0, binValStr.length-1)\n            val binValStr = binValStr.substring(binValStr.length-val.length)\n            val binValStr = binValStr.substring(0, binValStr.length-1)\n            val binValStr = binValStr.substring(binValStr.length-val.length)\n            val binValStr = binValStr.substring(0, binValStr.length-1)\n            val binValStr = binValStr.substring(binValStr.length-val.length)\n            val binValStr = binValStr.substring(0, binValStr.length-1)\n            val binValStr = binValStr.substring(binValStr.length-val.length)\n            val binValStr = binValStr.substring(0, binValStr.length-1)\n            val binValStr = binValStr.substring(binValStr.length-val.length)\n            val binValStr = binValStr.substring(0, binValStr.length-1)\n            val binValStr = binValStr.substring(binValStr.length-val.length)\n            val binValStr = binValStr.substring(0, binValStr.length-1)\n            val binValStr = binValStr.substring(binValStr.length-val.length)\n            val binValStr = binValStr.substring(0, binValStr.length-1)\n            val binValStr = binValStr.substring(binValStr.length-val.length)\n            val binValStr = binValStr.substring(0, binValStr.length-1)\n            val binValStr = binValStr.substring(binValStr.length-val.length)\n            val binValStr = binValStr.substring(0, binValStr.length-1)\n            val bin\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpsadlnpv4.scala:19:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[33mval\u001b[0m = avg(i).toBinaryString\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpsadlnpv4.scala:20:33 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mbinVal\u001b[0m = bin.pow(\u001b[33mval\u001b[0m.length)\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 expression expected but \u001b[31mval\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpsadlnpv4.scala:23:65 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mbinValStr\u001b[0m = binValStr.substring(binValStr.length-\u001b[33mval\u001b[0m.length)\n\u001b[31m\u001b[31m   |\u001b[0m                                                                 ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                       expression expected but \u001b[31mval\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpsadlnpv4.scala:25:65 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mbinValStr\u001b[0m = binValStr.substring(binValStr.length-\u001b[33mval\u001b[0m.length)\n\u001b[31m\u001b[31m   |\u001b[0m                                                                 ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                       expression expected but \u001b[31mval\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpsadlnpv4.scala:27:65 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mbinValStr\u001b[0m = binValStr.substring(binValStr.length-\u001b[33mval\u001b[0m.length)\n\u001b[31m\u001b[31m   |\u001b[0m                                                                ",
      "stdout": "",
      "timestamp": 1659798179
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val avg = n to m by -1\n        val binary = avg.map(x => Integer.toBinaryString(x))\n        val binary = binary.map(x => x.padToLength(4, '0'))\n        val sum = binary.sum\n        val avg = sum / binary.length\n        val result = if (avg < 0) Left(s\"$avg cannot be represented as a binary number\") else Right(avg)\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmppko7gh9_.scala:16:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.map(\u001b[36mx\u001b[0m => x.padToLength(\u001b[31m4\u001b[0m, \u001b[31m'0'\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmppko7gh9_.scala:18:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mavg\u001b[0m = sum / binary.length\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mavg is already defined as \u001b[33mvalue\u001b[0m \u001b[35mavg\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmppko7gh9_.scala:15:57 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = avg.map(\u001b[36mx\u001b[0m => Integer.toBinaryString(x))\n\u001b[31m\u001b[31m   |\u001b[0m                                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                    Found:    (x : Long)\n\u001b[31m   |\u001b[0m                                                    Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmppko7gh9_.scala:17:28 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36msum\u001b[0m = binary.sum\n\u001b[31m\u001b[31m   |\u001b[0m                            ^\u001b[0m\n\u001b[31m   |\u001b[0m                No implicit Ordering defined for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                where:    B is a type variable with constraint >: String\n\u001b[31m   |\u001b[0m                .\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmppko7gh9_.scala:19:29 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mif\u001b[0m (avg < \u001b[31m0\u001b[0m) Left(\u001b[31ms\"\u001b[0m$avg\u001b[3",
      "stdout": "",
      "timestamp": 1659798179
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val avg = ((n + m) / 2).round\n        val bin = Integer.toBinaryString(avg)\n        if (bin.length < m) Left(s\"$n through $m is too small to round up to $avg\")\n        else if (bin.length > m) Right(-1)\n        else Right(bin)\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpdyzn_est.scala:15:41 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbin\u001b[0m = Integer.toBinaryString(avg)\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                         Found:    (avg : Long)\n\u001b[31m   |\u001b[0m                                         Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpdyzn_est.scala:18:19 --------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33melse\u001b[0m Right(bin)\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Found:    (bin : String)\n\u001b[31m   |\u001b[0m                   Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659798178
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val avg = n to m by -1\n        val sum = 0L\n        val num = 0L\n        val binary = \"\"\n        val bin = mutable.BitSet(math.max(m, n))\n        for(i <- 0 until avg.length) {\n            sum += avg(i)\n            num += 1L\n            bin.set(i)\n        }\n        if(num > 0) {\n            val avg = sum / num\n            val binary = bin.toBinaryString\n            val len = binary.length\n            val right = math.min(len, m)\n            val left = math.max(len - 1, n)\n            val right = binary.substring(right, right)\n            val left = binary.substring(left, left)\n            val result = if (right == \"\") -1 else left.concat(right)\n            Right(result)\n        } else {\n            Left(-1)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpvgw__3z3.scala:18:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbin\u001b[0m = mutable.BitSet(math.max(m, n))\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpvgw__3z3.scala:20:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m            sum += avg(i)\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of Long - did you mean sum.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpvgw__3z3.scala:21:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            num += \u001b[31m1L\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of Long - did you mean num.!=?\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpvgw__3z3.scala:30:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mright\u001b[0m = binary.substring(right, right)\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mright is already defined as \u001b[33mvalue\u001b[0m \u001b[35mright\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpvgw__3z3.scala:31:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mleft\u001b[0m = binary.substring(left, left)\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mleft is already defined as \u001b[33mvalue\u001b[0m \u001b[35mleft\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpvgw__3z3.scala:35:17 --------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m            Left(-\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^\u001b[0m\n\u001b[31m   |\u001b[0m                 Found:    (\u001b[31m-1\u001b[0m : Int)\n\u001b[31m   |\u001b[0m       ",
      "stdout": "",
      "timestamp": 1659798179
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val sum = n to m\n        val avg = sum.sum / sum.size\n        val bin = math.ceil(avg).toBinaryString\n        val result = if (bin.length < m) -1 else bin\n        Right(result)\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpl7f_tk6y.scala:16:33 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbin\u001b[0m = math.ceil(avg).toBinaryString\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value toBinaryString is not a member of Double\n1 error found\n",
      "stdout": "",
      "timestamp": 1659798178
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val n = n.toInt\n        val m = m.toInt\n        if (n > m) {\n            Left(-1)\n        } else {\n            val sum = n.toLong + m.toLong\n            val avg = sum / 2\n            val binary = binary(avg)\n            Right(binary.toInt)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp1ktdpfdc.scala:14:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mn\u001b[0m = n.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                ^\u001b[0m\n\u001b[31m   |\u001b[0m                Recursive \u001b[33mvalue\u001b[0m \u001b[35mn\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp1ktdpfdc.scala:15:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mm\u001b[0m = m.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                ^\u001b[0m\n\u001b[31m   |\u001b[0m                Recursive \u001b[33mvalue\u001b[0m \u001b[35mm\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp1ktdpfdc.scala:17:17 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            Left(-\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^\u001b[0m\n\u001b[31m   |\u001b[0m                 Found:    (\u001b[31m-1\u001b[0m : Int)\n\u001b[31m   |\u001b[0m                 Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp1ktdpfdc.scala:21:25 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary(avg)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                         Recursive \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659798178
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val avg = n to m by -1\n        val sum = 0L\n        val count = 0L\n        val binary = new mutable.HashSet[String]()\n        for(i <- 0 until avg.length) {\n            val x = avg(i)\n            sum += x\n            count += if (x == 0) 1 else 0\n            binary.add(x.toBinaryString())\n        }\n        if (count > 0) Right(sum / count)\n        else Left(s\"The average of $n to $m is $sum / $count\")\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpohpj4qum.scala:21:21 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            count += \u001b[33mif\u001b[0m (x == \u001b[31m0\u001b[0m) \u001b[31m1\u001b[0m \u001b[33melse\u001b[0m \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^\u001b[0m\n\u001b[31m   |\u001b[0m                     expression expected but \u001b[31mif\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpohpj4qum.scala:17:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashSet[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpohpj4qum.scala:20:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m            sum += x\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of Long - did you mean sum.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpohpj4qum.scala:21:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            count += \u001b[33mif\u001b[0m (x == \u001b[31m0\u001b[0m) \u001b[31m1\u001b[0m \u001b[33melse\u001b[0m \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of Long - did you mean count.!=?\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659798179
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val avg = n/m\n        val bin = Integer.toBinaryString(avg)\n        if (bin.length < m) Left(s\"$n / $m is not an integer, $bin is too short\")\n        else if (bin.length > m) Right(-1)\n        else Right(bin)\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpigf1lh03.scala:15:41 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbin\u001b[0m = Integer.toBinaryString(avg)\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                         Found:    (avg : Long)\n\u001b[31m   |\u001b[0m                                         Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpigf1lh03.scala:18:19 --------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33melse\u001b[0m Right(bin)\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Found:    (bin : String)\n\u001b[31m   |\u001b[0m                   Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659798179
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val n = math.max(math.min(n, m), -1)\n        val m = math.max(math.min(m, n), -1)\n        val sum = n + m\n        val avg = sum / 2\n        val binary = binary(avg)\n        val result = if (n == m) Right(binary) else Left(s\"$n to $m is $binary\")\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpyzjzgmpy.scala:14:34 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mn\u001b[0m = math.max(math.min(n, m), -\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Recursive \u001b[33mvalue\u001b[0m \u001b[35mn\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpyzjzgmpy.scala:15:34 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mm\u001b[0m = math.max(math.min(m, n), -\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Recursive \u001b[33mvalue\u001b[0m \u001b[35mm\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpyzjzgmpy.scala:15:37 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mm\u001b[0m = math.max(math.min(m, n), -\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Recursive \u001b[33mvalue\u001b[0m \u001b[35mn\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpyzjzgmpy.scala:18:21 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary(avg)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                     Recursive \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659798175
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val avg = n to m by -1\n        val sum = n to m by -1\n        val avg = avg.toList\n        val sum = sum.toList\n        val avg = avg.map(_.toBinaryString).mkString\n        val sum = sum.map(_.toBinaryString).mkString\n        val avg = avg.toBinaryString\n        val sum = sum.toBinaryString\n        if (sum.equals(avg)) {\n            Right(avg)\n        } else {\n            Left(s\"$avg does not equal $sum\")\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp86wnkgis.scala:16:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mavg\u001b[0m = avg.toList\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mavg is already defined as \u001b[33mvalue\u001b[0m \u001b[35mavg\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp86wnkgis.scala:17:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36msum\u001b[0m = sum.toList\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0msum is already defined as \u001b[33mvalue\u001b[0m \u001b[35msum\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp86wnkgis.scala:18:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mavg\u001b[0m = avg.map(_.toBinaryString).mkString\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mavg is already defined as \u001b[33mvalue\u001b[0m \u001b[35mavg\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp86wnkgis.scala:19:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36msum\u001b[0m = sum.map(_.toBinaryString).mkString\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0msum is already defined as \u001b[33mvalue\u001b[0m \u001b[35msum\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp86wnkgis.scala:20:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mavg\u001b[0m = avg.toBinaryString\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mavg is already defined as \u001b[33mvalue\u001b[0m \u001b[35mavg\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in ",
      "stdout": "",
      "timestamp": 1659798179
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val avg = n to m by -1\n        val binary = avg.map(_.toBinaryString).mkString\n        val bin = binary.length\n        val result = if (bin == 0) \"0b\" + binary else binary.padTo(bin, \"0\")\n        Right(result)\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp248nu7up.scala:18:14 --------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        Right(result)\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              Found:    (result : Object)\n\u001b[31m   |\u001b[0m              Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659798179
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val sum = mutable.ListBuffer[Long]()\n        val avg = mutable.ListBuffer[Long]()\n        val n = math.max(m, n)\n        val m = math.min(n, m)\n        for (i <- n until m) {\n            sum += i\n            avg += i\n        }\n        val avg = sum.sum / avg.length\n        val binary = avg.toBinaryString\n        val result = if (binary == \"\") -1 else binary.toLong\n        Right(result)\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp4nonblsx.scala:22:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mavg\u001b[0m = sum.sum / avg.length\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mavg is already defined as \u001b[33mvalue\u001b[0m \u001b[35mavg\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp4nonblsx.scala:14:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36msum\u001b[0m = mutable.ListBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp4nonblsx.scala:15:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mavg\u001b[0m = mutable.ListBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp4nonblsx.scala:17:25 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mm\u001b[0m = math.min(n, m)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                         Recursive \u001b[33mvalue\u001b[0m \u001b[35mn\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp4nonblsx.scala:17:28 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mm\u001b[0m = math.min(n, m)\n\u001b[31m\u001b[31m   |\u001b[0m                            ^\u001b[0m\n\u001b[31m   |\u001b[0m                            Recursive \u001b[33mvalue\u001b[0m \u001b[35mm\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp4nonblsx.scala:16:28 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b",
      "stdout": "",
      "timestamp": 1659798175
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val avg = n to m by -1\n        val binary = avg.map(_.toBinaryString).mkString\n        val result = if (n >= m) Right(binary) else Left(s\"$n to $m is out of range\")\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpjtsw8vf_.scala:17:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        result\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    \u001b[1m\u001b[31m(\u001b[0m\u001b[1m\u001b[31mresult\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31m:\u001b[0m\u001b[1m\u001b[31m \u001b[0mEither[String, \u001b[1m\u001b[31mString\u001b[0m]\u001b[1m\u001b[31m)\u001b[0m\n\u001b[31m   |\u001b[0m        Required: Either[String, \u001b[1m\u001b[32mLong\u001b[0m]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659798180
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val avg = n to m by -1\n        val binary = avg.map(x => Integer.toBinaryString(x)).mkString\n        val result = if (n >= m) Left(binary) else Right(binary)\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpb40xw6pm.scala:15:57 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = avg.map(\u001b[36mx\u001b[0m => Integer.toBinaryString(x)).mkString\n\u001b[31m\u001b[31m   |\u001b[0m                                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                    Found:    (x : Long)\n\u001b[31m   |\u001b[0m                                                    Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpb40xw6pm.scala:17:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        result\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    \u001b[1m\u001b[31m(\u001b[0m\u001b[1m\u001b[31mresult\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31m:\u001b[0m\u001b[1m\u001b[31m \u001b[0mEither[String, \u001b[1m\u001b[31mString\u001b[0m]\u001b[1m\u001b[31m)\u001b[0m\n\u001b[31m   |\u001b[0m        Required: Either[String, \u001b[1m\u001b[32mLong\u001b[0m]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659798185
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val sum : Long = n to m by -1\n        val avg : Long = sum.toDouble / sum.size\n        val result : Long = math.round(avg).toBinaryString\n        val result : Either[String, Long] = if (result == \"0\") Left(result) else Right(result)\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp7zdps0l2.scala:17:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m : \u001b[35mEither\u001b[0m[\u001b[35mString\u001b[0m, \u001b[35mLong\u001b[0m] = \u001b[33mif\u001b[0m (result == \u001b[31m\"0\"\u001b[0m) Left(result) \u001b[33melse\u001b[0m Right(result)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mresult is already defined as \u001b[33mvalue\u001b[0m \u001b[35mresult\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp7zdps0l2.scala:14:25 --------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36msum\u001b[0m : \u001b[35mLong\u001b[0m = n to m by -\u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                 Found:    scala.collection.immutable.NumericRange[Long]\n\u001b[31m   |\u001b[0m                 Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp7zdps0l2.scala:15:44 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mavg\u001b[0m : \u001b[35mLong\u001b[0m = sum.toDouble / sum.size\n\u001b[31m\u001b[31m   |\u001b[0m                                        ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                      value size is not a member of Long\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp7zdps0l2.scala:16:44 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m : \u001b[35mLong\u001b[0m = math.round(avg).toBinaryString\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Found:    String\n\u001b[31m   |\u001b[0m                            Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp7zdps0l2.scala:18:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        result\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^\u001b[0m\n\u001b[31m ",
      "stdout": "",
      "timestamp": 1659798186
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val avg = n to m by -1\n        val sum = 0L\n        val binary = \"\"\n        for(i <- 0 until avg.length) {\n            val value = avg(i)\n            sum += value\n            binary += if(value >= 0) \"1\" + if(value < 0) \"0\" + value else value.toString else value.toString.reverse\n        }\n        val result = if(sum > 0) sum.toString else -1\n        val right = binary.reverse\n        val left = binary.dropRight(1)\n        val result = if(right == \"\") Left(result) else Right(result)\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmp_oc_9syn.scala:20:22 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m            binary += \u001b[33mif\u001b[0m(value >= \u001b[31m0\u001b[0m) \u001b[31m\"1\"\u001b[0m + \u001b[33mif\u001b[0m(value < \u001b[31m0\u001b[0m) \u001b[31m\"0\"\u001b[0m + value \u001b[33melse\u001b[0m value.toString \u001b[33melse\u001b[0m value.toString.reverse\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^\u001b[0m\n\u001b[31m   |\u001b[0m                      expression expected but \u001b[31mif\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp_oc_9syn.scala:25:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mif\u001b[0m(right == \u001b[31m\"\"\u001b[0m) Left(result) \u001b[33melse\u001b[0m Right(result)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mresult is already defined as \u001b[33mvalue\u001b[0m \u001b[35mresult\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp_oc_9syn.scala:19:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m            sum += value\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of Long - did you mean sum.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp_oc_9syn.scala:20:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m            binary += \u001b[33mif\u001b[0m(value >= \u001b[31m0\u001b[0m) \u001b[31m\"1\"\u001b[0m + \u001b[33mif\u001b[0m(value < \u001b[31m0\u001b[0m) \u001b[31m\"0\"\u001b[0m + value \u001b[33melse\u001b[0m value.toString \u001b[33melse\u001b[0m value.toString.reverse\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of String - did you mean binary.!=?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp_oc_9syn.scala:26:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        result\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    (result : Matchable)\n\u001b[31m   |\u001b[0m        Required: Either[String, Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compili",
      "stdout": "",
      "timestamp": 1659798188
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val nToM = (n to m).toList\n        val nToMSum = nToM.sum\n        val nToMCount = nToM.size\n        val nToMSumAsString = nToMSum.toBinaryString\n        val nToMCountAsString = nToMCount.toBinaryString\n        val nToMSumAsLong = Long(nToMSumAsString)\n        val nToMCountAsLong = Long(nToMCountAsString)\n        val nToMSumAsEither = Right(nToMSumAsLong)\n        val nToMCountAsEither = Right(nToMCountAsLong)\n        val nToMSumAsEitherString = nToMSumAsEither.toString\n        val nToMCountAsEitherString = nToMCountAsEither.toString\n        val nToMSumAsEitherLong = nToMSumAsEitherString.toLong\n        val nToMCountAsEitherLong = nToMCountAsEitherString.toLong\n        val nToMSumAsEitherLongAsString = nToMSumAsEitherLong.toBinaryString\n        val nToMCountAsEitherLongAsString = nToMCountAsEitherLong.toBinaryString\n        val nToMSumAsEitherLongAsLong = nToMSumAsEitherLongAsString.toLong\n        val nToMCountAsEitherLongAsLong = nToMCountAsEitherLongAsString.toLong\n        val nToMSumAsEitherLongAsLongAsString = nToMSumAsEitherLongAsLong.toBinaryString\n        val nToMCountAsEitherLongAsLongAsString = nToMCountAsEitherLongAsLong.toBinaryString\n        val nToMSumAsEitherLongAsLongAsLong = nToMSumAsEitherLongAsLongAsString.toLong\n        val nToMCountAsEitherLongAsLongAsLong = nToMCountAsEitherLongAsLongAsString.toLong\n        val nToMSumAsEitherLongAsLongAsLongAsString = nToMSumAsEitherLongAsLongAsLongAsString.toBinaryString\n        val nToMCountAsEitherLongAsLongAsLongAsString = nToM\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpg6fopn1a.scala:19:28 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnToMSumAsLong\u001b[0m = Long(nToMSumAsString)\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   \u001b[33mobject\u001b[0m \u001b[35mLong\u001b[0m in \u001b[33mpackage\u001b[0m \u001b[35mscala\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpg6fopn1a.scala:20:30 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnToMCountAsLong\u001b[0m = Long(nToMCountAsString)\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   \u001b[33mobject\u001b[0m \u001b[35mLong\u001b[0m in \u001b[33mpackage\u001b[0m \u001b[35mscala\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpg6fopn1a.scala:35:54 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnToMSumAsEitherLongAsLongAsLongAsString\u001b[0m = nToMSumAsEitherLongAsLongAsLongAsString.toBinaryString\n\u001b[31m\u001b[31m   |\u001b[0m                                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m      Recursive \u001b[33mvalue\u001b[0m \u001b[35mnToMSumAsEitherLongAsLongAsLongAsString\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpg6fopn1a.scala:37:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Either[String, Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659798188
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val avg = n to m by -1\n        val sum = 0L\n        val count = m\n        val binary = \"\"\n        for(i <- 0 until count) {\n            val value = avg(i).right.toLong\n            sum += value\n            binary += value.toString + \" \"\n        }\n        val result = if (sum > 0) sum.toString else -1\n        val bin = binary.substring(binary.length - count)\n        val binary = bin.substring(0, bin.length - 1)\n        val right = binary.toLong\n        val left = binary.toLong - right\n        val result = if (right > 0) right else -1\n        Left(binary, result)\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpgqtwaub4.scala:25:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = bin.substring(\u001b[31m0\u001b[0m, bin.length - \u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpgqtwaub4.scala:28:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mif\u001b[0m (right > \u001b[31m0\u001b[0m) right \u001b[33melse\u001b[0m -\u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mresult is already defined as \u001b[33mvalue\u001b[0m \u001b[35mresult\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpgqtwaub4.scala:18:25 --------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mfor\u001b[0m(i <- \u001b[31m0\u001b[0m until count) {\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Found:    (count : Long)\n\u001b[31m   |\u001b[0m                         Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpgqtwaub4.scala:19:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mvalue\u001b[0m = avg(i).right.toLong\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        value right is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpgqtwaub4.scala:20:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m            sum += value\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of Long - did you mean sum.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpgqtwaub4.scala:21:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m   ",
      "stdout": "",
      "timestamp": 1659798190
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val avg = ((n + m) / 2.0).toLong\n        val bin = Integer.toBinaryString(avg)\n        if (bin.length < m) Left(s\"$bin is too short\")\n        else if (bin.length > m) Right(-1)\n        else Right(bin)\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpc49agyc0.scala:15:41 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbin\u001b[0m = Integer.toBinaryString(avg)\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                         Found:    (avg : Long)\n\u001b[31m   |\u001b[0m                                         Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpc49agyc0.scala:18:19 --------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33melse\u001b[0m Right(bin)\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Found:    (bin : String)\n\u001b[31m   |\u001b[0m                   Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659798190
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val n = math.max(math.min(n, m), -1L)\n        val m = math.max(math.min(m, n), -1L)\n        val nm = n to m\n        val sum = nm.foldLeft(0L)(_ + _)\n        val avg = sum / nm.length\n        val bin = math.round(avg).toBinaryString\n        val result = if (bin == \"\") -1 else bin\n        Left(result)\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp3c_8b28f.scala:14:34 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mn\u001b[0m = math.max(math.min(n, m), -\u001b[31m1L\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Recursive \u001b[33mvalue\u001b[0m \u001b[35mn\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp3c_8b28f.scala:15:34 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mm\u001b[0m = math.max(math.min(m, n), -\u001b[31m1L\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Recursive \u001b[33mvalue\u001b[0m \u001b[35mm\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp3c_8b28f.scala:15:37 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mm\u001b[0m = math.max(math.min(m, n), -\u001b[31m1L\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Recursive \u001b[33mvalue\u001b[0m \u001b[35mn\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp3c_8b28f.scala:21:13 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        Left(result)\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m             Found:    (result : Int)\n\u001b[31m   |\u001b[0m             Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659798188
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val avg = n + (m / 2)\n        val bin = math.pow(10, math.ceil(math.log(avg) / math.log(10)))\n        val binString = bin.toString(2)\n        val binString = binString.reverse\n        val binString = binString.dropRight(1)\n        val binString = binString.reverse\n        val binString = binString.dropRight(1)\n        val binString = binString.reverse\n        val binString = binString.dropRight(1)\n        val binString = binString.reverse\n        val binString = binString.dropRight(1)\n        val binString = binString.reverse\n        val binString = binString.dropRight(1)\n        val binString = binString.reverse\n        val binString = binString.dropRight(1)\n        val binString = binString.reverse\n        val binString = binString.dropRight(1)\n        val binString = binString.reverse\n        val binString = binString.dropRight(1)\n        val binString = binString.reverse\n        val binString = binString.dropRight(1)\n        val binString = binString.reverse\n        val binString = binString.dropRight(1)\n        val binString = binString.reverse\n        val binString = binString.dropRight(1)\n        val binString = binString.reverse\n        val binString = binString.dropRight(1)\n        val binString = binString.reverse\n        val binString = binString.dropRight(1)\n        val binString = binString.reverse\n        val binString = binString.dropRight(1)\n        val binString = binString.reverse\n        val binString = binString.dropRight(1)\n        val binString = binString.reverse\n        val binString = binString.dropRight(1)\n        val binString = binString.reverse\n        val binString = binString.dropRight(1)\n        val binString = binString.reverse\n        val binString = binString.dropRight(1)\n        val binString = binString.reverse\n        val binString = binString.dropRight(1)\n        val binString = binString.reverse\n        val binString = binString.dropRight(1)\n        val binString = binString.reverse\n        val binString = binString.dropRight(1)\n        val binString = binString.reverse\n        val binString = binString.dropRight(1)\n        val binString = binString.reverse\n        val binString = binString.dropRight(1)\n        val binString = binString.reverse\n        val binString = binString.dropRight(1)\n        val binString = binString.reverse\n        val binString = binString.dropRight(1)\n        val binString = binString.reverse\n        val binString = binString.dropRight(1)\n        val binString = binString.reverse\n        \n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpwiy743eo.scala:17:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinString\u001b[0m = binString.reverse\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinString is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinString\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpwiy743eo.scala:18:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinString\u001b[0m = binString.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinString is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinString\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpwiy743eo.scala:19:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinString\u001b[0m = binString.reverse\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinString is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinString\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpwiy743eo.scala:20:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinString\u001b[0m = binString.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinString is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinString\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpwiy743eo.scala:21:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinString\u001b[0m = binString.reverse\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinString is already defined ",
      "stdout": "",
      "timestamp": 1659798189
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val avg = ((n + m) / 2).round\n        val bin = Integer.toBinaryString(avg)\n        if (bin.length < m) Left(s\"$bin is too short\")\n        else if (bin.length > m) Right(s\"$bin is too long\")\n        else Right(bin)\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpfjohh7lv.scala:15:41 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbin\u001b[0m = Integer.toBinaryString(avg)\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                         Found:    (avg : Long)\n\u001b[31m   |\u001b[0m                                         Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpfjohh7lv.scala:17:39 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (bin.length > m) Right(\u001b[31ms\"\u001b[0m$bin\u001b[31m is too long\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                       Found:    String\n\u001b[31m   |\u001b[0m                                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpfjohh7lv.scala:18:19 --------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33melse\u001b[0m Right(bin)\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Found:    (bin : String)\n\u001b[31m   |\u001b[0m                   Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659798190
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val avg = ((n + m) / 2).round\n        val binary = avg.toBinaryString\n        if (binary.length < m) Left(s\"$binary is too short\")\n        else if (binary.length > m) Right(-1)\n        else Right(binary)\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp1ac59s7l.scala:18:19 --------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33melse\u001b[0m Right(binary)\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Found:    (binary : String)\n\u001b[31m   |\u001b[0m                   Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659798190
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val avg = n to m by -1\n        val binary = avg.map(x => Integer.toBinaryString(x)).mkString\n        val result = if (binary.length < m) -1 else binary\n        Right(result)\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpw_g4kqtj.scala:15:57 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = avg.map(\u001b[36mx\u001b[0m => Integer.toBinaryString(x)).mkString\n\u001b[31m\u001b[31m   |\u001b[0m                                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                    Found:    (x : Long)\n\u001b[31m   |\u001b[0m                                                    Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpw_g4kqtj.scala:17:14 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        Right(result)\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              Found:    (result : Matchable)\n\u001b[31m   |\u001b[0m              Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659798190
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val avg = n + (m - 1) / 2\n        val bin = math.pow(10, math.ceil(math.log10(avg)))\n        val binStr = bin.toString(2)\n        val binStrLen = binStr.length\n        val binStr = binStr.substring(0, binStrLen - 1)\n        val binStrLen = binStr.length\n        val binStr = binStr.substring(0, binStrLen - 1)\n        val binStrLen = binStr.length\n        val binStr = binStr.substring(0, binStrLen - 1)\n        val binStrLen = binStr.length\n        val binStr = binStr.substring(0, binStrLen - 1)\n        val binStrLen = binStr.length\n        val binStr = binStr.substring(0, binStrLen - 1)\n        val binStrLen = binStr.length\n        val binStr = binStr.substring(0, binStrLen - 1)\n        val binStrLen = binStr.length\n        val binStr = binStr.substring(0, binStrLen - 1)\n        val binStrLen = binStr.length\n        val binStr = binStr.substring(0, binStrLen - 1)\n        val binStrLen = binStr.length\n        val binStr = binStr.substring(0, binStrLen - 1)\n        val binStrLen = binStr.length\n        val binStr = binStr.substring(0, binStrLen - 1)\n        val binStrLen = binStr.length\n        val binStr = binStr.substring(0, binStrLen - 1)\n        val binStrLen = binStr.length\n        val binStr = binStr.substring(0, binStrLen - 1)\n        val binStrLen = binStr.length\n        val binStr = binStr.substring(0, binStrLen - 1)\n        val binStrLen = binStr.length\n        val binStr = binStr.substring(0, binStrLen - 1)\n        val binStrLen = binStr.length\n        val binStr = binStr.substring(0, binStrLen - 1)\n        val binStrLen = binStr.length\n        val binStr = binStr.substring(0, binStrLen - 1)\n        val binStrLen = binStr.length\n        val binStr = binStr.substring(0, binStrLen - 1)\n        val binStrLen = binStr.length\n        val binStr = binStr.substring(0, binStrLen - 1)\n        val binStrLen = binStr.length\n        val binStr = binStr.substring(0, binStrLen - 1)\n        val binStrLen = binStr.length\n        val binStr = binStr.substring(0, binStrLen - \n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmp3l8tql9u.scala:56:52 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m56 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinStr\u001b[0m = binStr.substring(\u001b[31m0\u001b[0m, binStrLen - \n\u001b[31m\u001b[31m   |\u001b[0m                                                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                                       expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp3l8tql9u.scala:18:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinStr\u001b[0m = binStr.substring(\u001b[31m0\u001b[0m, binStrLen - \u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinStr is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinStr\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp3l8tql9u.scala:19:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinStrLen\u001b[0m = binStr.length\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinStrLen is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinStrLen\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp3l8tql9u.scala:20:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinStr\u001b[0m = binStr.substring(\u001b[31m0\u001b[0m, binStrLen - \u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinStr is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinStr\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp3l8tql9u.scala:21:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinStrLen\u001b[0m = binStr.length\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[",
      "stdout": "",
      "timestamp": 1659798191
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val avg = ((n + m) / 2).round\n        val binary = avg.toBinaryString\n        val result = if (n >= m) Right(binary) else Left(s\"$n to $m is $binary\")\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpjue5ebp0.scala:17:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        result\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    \u001b[1m\u001b[31m(\u001b[0m\u001b[1m\u001b[31mresult\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31m:\u001b[0m\u001b[1m\u001b[31m \u001b[0mEither[String, \u001b[1m\u001b[31mString\u001b[0m]\u001b[1m\u001b[31m)\u001b[0m\n\u001b[31m   |\u001b[0m        Required: Either[String, \u001b[1m\u001b[32mLong\u001b[0m]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659798190
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val avg = n to m by -1\n        val binary = avg.map(x => x.toBinaryString).mkString\n        val result = if (n <= m) Right(binary) else Left(\"-1\")\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpz88rz0ic.scala:17:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        result\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    \u001b[1m\u001b[31m(\u001b[0m\u001b[1m\u001b[31mresult\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31m:\u001b[0m\u001b[1m\u001b[31m \u001b[0mEither[String, \u001b[1m\u001b[31mString\u001b[0m]\u001b[1m\u001b[31m)\u001b[0m\n\u001b[31m   |\u001b[0m        Required: Either[String, \u001b[1m\u001b[32mLong\u001b[0m]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659798190
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val sum = (n to m).sum\n        val avg = sum / m\n        val bin = math.round(avg).toBinaryString\n        val result = if (bin == \"\") -1 else bin\n        Right(result)\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmplq77v1ri.scala:18:14 --------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        Right(result)\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              Found:    (result : Matchable)\n\u001b[31m   |\u001b[0m              Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659798190
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val n = n.toInt\n        val m = m.toInt\n        if (n > m) {\n            Left(-1)\n        } else {\n            val sum = n.toLong + m.toLong\n            val avg = sum / 2\n            val binary = avg.toBinaryString\n            Right(binary.padToLength(binary.length, \"0\"))\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpwwpasdsy.scala:14:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mn\u001b[0m = n.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                ^\u001b[0m\n\u001b[31m   |\u001b[0m                Recursive \u001b[33mvalue\u001b[0m \u001b[35mn\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpwwpasdsy.scala:15:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mm\u001b[0m = m.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                ^\u001b[0m\n\u001b[31m   |\u001b[0m                Recursive \u001b[33mvalue\u001b[0m \u001b[35mm\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpwwpasdsy.scala:17:17 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            Left(-\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^\u001b[0m\n\u001b[31m   |\u001b[0m                 Found:    (\u001b[31m-1\u001b[0m : Int)\n\u001b[31m   |\u001b[0m                 Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659798191
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val sum = n to m\n        val avg = sum.sum / sum.size\n        val bin = math.ceil(avg).toBinaryString\n        val result = if (bin.size == 0) \"0b0\" else bin\n        val right = if (bin.size == 0) -1 else bin.dropRight(1)\n        Right(result + right)\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp0y3h8pag.scala:16:33 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbin\u001b[0m = math.ceil(avg).toBinaryString\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value toBinaryString is not a member of Double\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp0y3h8pag.scala:19:14 --------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        Right(result + right)\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              Found:    String\n\u001b[31m   |\u001b[0m              Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659798192
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val avg = n to m by -1\n        val binary = avg.map(x => x.toBinaryString).mkString\n        val result = if (n <= m) Right(binary) else Left(s\"$n to $m is out of range\")\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpkhih1fn6.scala:17:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        result\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    \u001b[1m\u001b[31m(\u001b[0m\u001b[1m\u001b[31mresult\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31m:\u001b[0m\u001b[1m\u001b[31m \u001b[0mEither[String, \u001b[1m\u001b[31mString\u001b[0m]\u001b[1m\u001b[31m)\u001b[0m\n\u001b[31m   |\u001b[0m        Required: Either[String, \u001b[1m\u001b[32mLong\u001b[0m]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659798153
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val avg = n to m by -1\n        val sum = n to m by -1\n        val avg = avg.toList.sum / sum.toList.size\n        val binary = avg.toBinaryString\n        val result = if (binary.length == 1) \"0b\" + binary else binary\n        val right = result.dropRight(1)\n        val left = result.drop(1)\n        val leftRight = left ++ right\n        val leftRightString = leftRight.toString.toUpperCase\n        val result = if (leftRightString.length == 1) \"0b\" + leftRightString else leftRightString\n        val right = result.dropRight(1)\n        val left = result.drop(1)\n        val leftRight = left ++ right\n        val leftRightString = leftRight.toString.toUpperCase\n        val result = if (leftRightString.length == 1) \"0b\" + leftRightString else leftRightString\n        val right = result.dropRight(1)\n        val left = result.drop(1)\n        val leftRight = left ++ right\n        val leftRightString = leftRight.toString.toUpperCase\n        val result = if (leftRightString.length == 1) \"0b\" + leftRightString else leftRightString\n        val right = result.dropRight(1)\n        val left = result.drop(1)\n        val leftRight = left ++ right\n        val leftRightString = leftRight.toString.toUpperCase\n        val result = if (leftRightString.length == 1) \"0b\" + leftRightString else leftRightString\n        val right = result.dropRight(1)\n        val left = result.drop(1)\n        val leftRight = left ++ right\n        val leftRightString = leftRight.toString.toUpperCase\n        val result = if (leftRightString.length == 1) \"0b\" + leftRightString else leftRightString\n        val right = result.dropRight(1)\n        val left = result.drop(1)\n        val leftRight = left ++ right\n        val leftRightString = leftRight.toString.toUpperCase\n        val result = if (leftRightString.length == 1) \"0b\" + leftRightString else leftRightString\n        val right = result.dropRight(1)\n        val left = result.drop(1)\n        val leftRight = left ++ right\n        val leftRightString = leftRight.toString.toUpperCase\n        val result = if (leftRightString.length == 1) \"0b\" + leftRightString else leftRightString\n        val right = result.dropRight(1)\n        val left = result.drop(1)\n        val leftRight = left ++ right\n        val leftRightString = leftRight.toString.toUpperCase\n        val result = if (leftRightString.length == 1) \"0b\" + leftRightString else \n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpecg1ydz1.scala:58:81 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m58 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mif\u001b[0m (leftRightString.length == \u001b[31m1\u001b[0m) \u001b[31m\"0b\"\u001b[0m + leftRightString \u001b[33melse\u001b[0m \n\u001b[31m\u001b[31m   |\u001b[0m                                                                                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                                       expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpecg1ydz1.scala:16:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mavg\u001b[0m = avg.toList.sum / sum.toList.size\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mavg is already defined as \u001b[33mvalue\u001b[0m \u001b[35mavg\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpecg1ydz1.scala:23:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mif\u001b[0m (leftRightString.length == \u001b[31m1\u001b[0m) \u001b[31m\"0b\"\u001b[0m + leftRightString \u001b[33melse\u001b[0m leftRightString\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mresult is already defined as \u001b[33mvalue\u001b[0m \u001b[35mresult\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpecg1ydz1.scala:24:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mright\u001b[0m = result.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mright is already defined as \u001b[33mvalue\u001b[0m \u001b[35mright\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpecg1ydz1.scala:25:12 ----",
      "stdout": "",
      "timestamp": 1659798192
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val ns = List(n, m).sorted\n        val nm = ns zip ns drop 1\n        val nm = nm.filter(_._2 > _._1).map(_._1).sum / 2\n        val nm = nm.toBinaryString\n        val nm = nm.dropRight(1)\n        val nm = nm.reverse\n        val nm = nm.dropRight(1)\n        val nm = nm.reverse\n        val nm = nm.dropRight(1)\n        val nm = nm.reverse\n        val nm = nm.dropRight(1)\n        val nm = nm.reverse\n        val nm = nm.dropRight(1)\n        val nm = nm.reverse\n        val nm = nm.dropRight(1)\n        val nm = nm.reverse\n        val nm = nm.dropRight(1)\n        val nm = nm.reverse\n        val nm = nm.dropRight(1)\n        val nm = nm.reverse\n        val nm = nm.dropRight(1)\n        val nm = nm.reverse\n        val nm = nm.dropRight(1)\n        val nm = nm.reverse\n        val nm = nm.dropRight(1)\n        val nm = nm.reverse\n        val nm = nm.dropRight(1)\n        val nm = nm.reverse\n        val nm = nm.dropRight(1)\n        val nm = nm.reverse\n        val nm = nm.dropRight(1)\n        val nm = nm.reverse\n        val nm = nm.dropRight(1)\n        val nm = nm.reverse\n        val nm = nm.dropRight(1)\n        val nm = nm.reverse\n        val nm = nm.dropRight(1)\n        val nm = nm.reverse\n        val nm = nm.dropRight(1)\n        val nm = nm.reverse\n        val nm = nm.dropRight(1)\n        val nm = nm.reverse\n        val nm = nm.dropRight(1)\n        val nm = nm.reverse\n        val nm = nm.dropRight(1)\n        val nm = nm.reverse\n        val nm = nm.dropRight(1)\n        val nm = nm.reverse\n        val nm = nm.dropRight(1)\n        val nm = nm.reverse\n        val nm = nm.dropRight(1)\n        val nm = nm.reverse\n        val nm = nm.dropRight(1)\n        val nm = nm.reverse\n        val nm = nm.dropRight\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp9o8wxxs6.scala:16:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnm\u001b[0m = nm.filter(_._2 > _._1).map(_._1).sum / \u001b[31m2\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnm is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnm\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp9o8wxxs6.scala:17:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnm\u001b[0m = nm.toBinaryString\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnm is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnm\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp9o8wxxs6.scala:18:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnm\u001b[0m = nm.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnm is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnm\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp9o8wxxs6.scala:19:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnm\u001b[0m = nm.reverse\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnm is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnm\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp9o8wxxs6.scala:20:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnm\u001b[0m = nm.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnm is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnm\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same gr",
      "stdout": "",
      "timestamp": 1659798192
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val avg = n/m\n        val bin = Integer.toBinaryString(avg)\n        val result = bin.take(bin.length-m.toInt)\n        val right = bin.drop(bin.length-m.toInt)\n        val left = bin.take(bin.length-n.toInt)\n        val leftRight = left.dropRight(left.length-n.toInt)\n        val leftLeftRight = left.drop(left.length-n.toInt)\n        val leftLeftLeftRight = left.drop(left.length-m.toInt)\n        val leftLeftLeftLeftRight = left.drop(left.length-m.toInt)\n        val leftLeftLeftLeftLeftRight = left.drop(left.length-m.toInt)\n        val leftLeftLeftLeftLeftLeftRight = left.drop(left.length-m.toInt)\n        val leftLeftLeftLeftLeftLeftLeftRight = left.drop(left.length-m.toInt)\n        val leftLeftLeftLeftLeftLeftLeftLeftRight = left.drop(left.length-m.toInt)\n        val leftLeftLeftLeftLeftLeftLeftLeftRight = left.drop(left.length-m.toInt)\n        val leftLeftLeftLeftLeftLeftLeftLeftRight = left.drop(left.length-m.toInt)\n        val leftLeftLeftLeftLeftLeftLeftLeftRight = left.drop(left.length-m.toInt)\n        val leftLeftLeftLeftLeftLeftLeftLeftRight = left.drop(left.length-m.toInt)\n        val leftLeftLeftLeftLeftLeftLeftLeftRight = left.drop(left.length-m.toInt)\n        val leftLeftLeftLeftLeftLeftLeftLeftRight = left.drop(left.length-m.toInt)\n        val leftLeftLeftLeftLeftLeftLeftLeftRight = left.drop(left.length-m.toInt)\n        val leftLeftLeftLeftLeftLeftLeftLeftRight = left.drop(left.length-m.toInt)\n        val leftLeftLeftLeftLeftLeftLeftLeftRight = left.drop(left.length-m.toInt)\n        val leftLeftLeftLeftLeftLeftLeftLeftRight = left.drop(left.length-m.toInt)\n        val leftLeftLeftLeftLeftLeftLeftLeftRight = left.drop(left.length-m.toInt)\n        val leftLeftLeftLeftLeftLeftLeftLeftRight = left.drop(left.length-m.toInt)\n        val leftLeftLeftLeftLeftLeftLeftLeftRight = left.drop(left.\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpdvmiyz6d.scala:40:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    an identifier expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpdvmiyz6d.scala:27:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mleftLeftLeftLeftLeftLeftLeftLeftRight\u001b[0m = left.drop(left.length-m.toInt)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mleftLeftLeftLeftLeftLeftLeftLeftRight is already defined as \u001b[33mvalue\u001b[0m \u001b[35mleftLeftLeftLeftLeftLeftLeftLeftRight\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpdvmiyz6d.scala:28:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mleftLeftLeftLeftLeftLeftLeftLeftRight\u001b[0m = left.drop(left.length-m.toInt)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mleftLeftLeftLeftLeftLeftLeftLeftRight is already defined as \u001b[33mvalue\u001b[0m \u001b[35mleftLeftLeftLeftLeftLeftLeftLeftRight\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpdvmiyz6d.scala:29:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mleftLeftLeftLeftLeftLeftLeftLeftRight\u001b[0m = left.drop(left.length-m.toInt)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mleftLeftLeftLeftLeftLeftLeftLeftRight is already defined as \u001b[33mvalue\u001b[0m \u001b[35mleftLeftLeftLeftLeftLeftLeftLeftRight\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpdvmiyz6d.scala:30:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b",
      "stdout": "",
      "timestamp": 1659798192
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val sum : Long = n to m by -1\n        val avg = sum.sum / sum.size\n        val bin = Integer.toBinaryString(avg)\n        if (bin.length < m) Left(bin)\n        else Right(bin)\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpzd67iffd.scala:14:25 --------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36msum\u001b[0m : \u001b[35mLong\u001b[0m = n to m by -\u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                 Found:    scala.collection.immutable.NumericRange[Long]\n\u001b[31m   |\u001b[0m                 Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpzd67iffd.scala:15:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mavg\u001b[0m = sum.sum / sum.size\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value sum is not a member of Long\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpzd67iffd.scala:18:19 --------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33melse\u001b[0m Right(bin)\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Found:    (bin : String)\n\u001b[31m   |\u001b[0m                   Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659798191
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val avg = n to m by -1\n        val binary = avg.map(x => Integer.toBinaryString(x)).mkString\n        val result = if (n >= m) Left(binary) else Right(binary)\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpb40xw6pm.scala:15:57 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = avg.map(\u001b[36mx\u001b[0m => Integer.toBinaryString(x)).mkString\n\u001b[31m\u001b[31m   |\u001b[0m                                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                    Found:    (x : Long)\n\u001b[31m   |\u001b[0m                                                    Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpb40xw6pm.scala:17:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        result\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    \u001b[1m\u001b[31m(\u001b[0m\u001b[1m\u001b[31mresult\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31m:\u001b[0m\u001b[1m\u001b[31m \u001b[0mEither[String, \u001b[1m\u001b[31mString\u001b[0m]\u001b[1m\u001b[31m)\u001b[0m\n\u001b[31m   |\u001b[0m        Required: Either[String, \u001b[1m\u001b[32mLong\u001b[0m]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659798185
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val n = math.max(math.min(m, n), n)\n        val m = math.max(math.min(m, n), n)\n        val sum = n to m by -1\n        val avg = sum.sum / sum.size\n        val binary = math.round(avg).toBinaryString\n        val result = if (binary == \"\") -1 else binary\n        Right(result)\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmplgingkra.scala:15:34 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mm\u001b[0m = math.max(math.min(m, n), n)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Recursive \u001b[33mvalue\u001b[0m \u001b[35mm\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmplgingkra.scala:15:37 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mm\u001b[0m = math.max(math.min(m, n), n)\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Recursive \u001b[33mvalue\u001b[0m \u001b[35mn\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmplgingkra.scala:15:41 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mm\u001b[0m = math.max(math.min(m, n), n)\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                         Recursive \u001b[33mvalue\u001b[0m \u001b[35mn\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmplgingkra.scala:14:37 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mn\u001b[0m = math.max(math.min(m, n), n)\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Recursive \u001b[33mvalue\u001b[0m \u001b[35mn\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmplgingkra.scala:14:41 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mn\u001b[0m = math.max(math.min(m, n), n)\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                         Recursive \u001b[33mvalue\u001b[0m \u001b[35mn\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0",
      "stdout": "",
      "timestamp": 1659798188
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val n = math.abs(n)\n        val m = math.abs(m)\n        val sum = n + m\n        val avg = sum / 2\n        val binary = math.round(avg).toBinaryString\n        val result = if (binary == \"\") -1 else binary\n        Right(result)\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpsenq3ws6.scala:14:25 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mn\u001b[0m = math.abs(n)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                         Recursive \u001b[33mvalue\u001b[0m \u001b[35mn\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpsenq3ws6.scala:15:25 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mm\u001b[0m = math.abs(m)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                         Recursive \u001b[33mvalue\u001b[0m \u001b[35mm\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659798190
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val n = math.max(math.min(n, m), -1)\n        val m = math.max(math.min(m, n), -1)\n        val sum = (n+m)/2\n        val binary = sum.toBinaryString\n        val result = if (binary == binary.reverse) Right(sum) else Left(s\"$sum is not an average of $n and $m\")\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpdjygqh3r.scala:14:34 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mn\u001b[0m = math.max(math.min(n, m), -\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Recursive \u001b[33mvalue\u001b[0m \u001b[35mn\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpdjygqh3r.scala:15:34 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mm\u001b[0m = math.max(math.min(m, n), -\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Recursive \u001b[33mvalue\u001b[0m \u001b[35mm\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpdjygqh3r.scala:15:37 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mm\u001b[0m = math.max(math.min(m, n), -\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Recursive \u001b[33mvalue\u001b[0m \u001b[35mn\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659798194
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val avg = n + (m / 2)\n        val binary = avg.toBinaryString\n        val len = binary.length\n        val right = binary.substring(len - 1, len)\n        val left = binary.substring(0, len - 1)\n        val result = if (right == left) Right(avg) else Left(-1)\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpnw2523uc.scala:20:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        result\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    \u001b[1m\u001b[31m(\u001b[0m\u001b[1m\u001b[31mresult\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31m:\u001b[0m\u001b[1m\u001b[31m \u001b[0mEither[\u001b[1m\u001b[31mInt\u001b[0m, Long]\u001b[1m\u001b[31m)\u001b[0m\n\u001b[31m   |\u001b[0m        Required: Either[\u001b[1m\u001b[32mString\u001b[0m, Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659798198
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val n = math.max(math.min(n, m), 1L)\n        val m = math.max(math.min(m, n), 1L)\n        val sum = math.min(m, n) - math.max(m, n)\n        val avg = sum / 2\n        val binary = binary(avg)\n        val result = if (binary == \"\") -1 else binary\n        Left(result)\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp9xzloztt.scala:14:34 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mn\u001b[0m = math.max(math.min(n, m), \u001b[31m1L\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Recursive \u001b[33mvalue\u001b[0m \u001b[35mn\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp9xzloztt.scala:15:34 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mm\u001b[0m = math.max(math.min(m, n), \u001b[31m1L\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Recursive \u001b[33mvalue\u001b[0m \u001b[35mm\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp9xzloztt.scala:15:37 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mm\u001b[0m = math.max(math.min(m, n), \u001b[31m1L\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Recursive \u001b[33mvalue\u001b[0m \u001b[35mn\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp9xzloztt.scala:18:21 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary(avg)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                     Recursive \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp9xzloztt.scala:20:13 --------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        Left(result)\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m             Found:    (result : Int)\n\u001b[31m   |\u001b[0m             Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n5 errors found\n",
      "stdout": "",
      "timestamp": 1659798199
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val avg = n to m by -1\n        val sum = 0\n        val count = 0\n        for(i <- 0 until avg.length) {\n            sum += avg(i)\n            count += 1\n        }\n        if(count > 0) Right(sum.toString(2))\n        else Left(s\"$n is greater than $m\")\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpi1rx2nmd.scala:18:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m            sum += avg(i)\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of Int - did you mean sum.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpi1rx2nmd.scala:19:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m            count += \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of Int - did you mean count.!=?\n\u001b[31m\u001b[31m-- Error: /tmp/tmpi1rx2nmd.scala:21:41 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mif\u001b[0m(count > \u001b[31m0\u001b[0m) Right(sum.toString(\u001b[31m2\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m         too many arguments for \u001b[33mmethod\u001b[0m \u001b[35mtoString\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mAny\u001b[0m: (): String\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659798200
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val nBits = n.toBinaryString\n        val mBits = m.toBinaryString\n        val nBitsLength = nBits.length\n        val mBitsLength = mBits.length\n        val nBitsSum = sum(nBits.dropRight(mBitsLength))\n        val mBitsSum = sum(mBits.takeRight(nBitsLength))\n        val nBitsSumLength = nBitsSum.length\n        val mBitsSumLength = mBitsSum.length\n        val nBitsSumBits = nBitsSum.dropRight(mBitsSumLength)\n        val mBitsSumBits = mBitsSum.takeRight(nBitsSumLength)\n        val nBitsSumBitsLength = nBitsSumBits.length\n        val mBitsSumBitsLength = mBitsSumBits.length\n        val nBitsSumBitsSum = sum(nBitsSumBits)\n        val mBitsSumBitsSum = sum(mBitsSumBits)\n        val nBitsSumBitsSumLength = nBitsSumBitsSum.length\n        val mBitsSumBitsSumLength = mBitsSumBitsSum.length\n        val nBitsSumBitsSumBits = nBitsSumBitsSum.dropRight(mBitsSumBitsSumLength)\n        val mBitsSumBitsSumBits = mBitsSumBitsSum.takeRight(nBitsSumBitsSumLength)\n        val nBitsSumBitsSumBitsLength = nBitsSumBitsSumBits.length\n        val mBitsSumBitsSumBitsLength = mBitsSumBitsSumBits.length\n        val nBitsSumBitsSumBitsSum = sum(nBitsSumBitsSumBits)\n        val mBitsSumBitsSumBitsSum = sum(mBitsSumBitsSumBits)\n        val nBitsSumBitsSumBitsSumLength = nBitsSumBitsSumBitsSum.length\n        val mBitsSumBitsSumBitsSumLength = mBitsSumBitsSumBitsSum.length\n        val nBitsSumBitsSumBitsSumBits = nBitsSumBitsSumBitsSum.dropRight(mBitsSumBitsSumBitsSumLength)\n        val mBitsSumBitsSumBitsSumBits = \n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpja6j3ydr.scala:39:40 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmBitsSumBitsSumBitsSumBits\u001b[0m = \n\u001b[31m\u001b[31m   |\u001b[0m                                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                                       expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpja6j3ydr.scala:18:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnBitsSum\u001b[0m = sum(nBits.dropRight(mBitsLength))\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Not found: sum\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpja6j3ydr.scala:19:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmBitsSum\u001b[0m = sum(mBits.takeRight(nBitsLength))\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Not found: sum\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpja6j3ydr.scala:26:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnBitsSumBitsSum\u001b[0m = sum(nBitsSumBits)\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: sum\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpja6j3ydr.scala:27:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmBitsSumBitsSum\u001b[0m = sum(mBitsSumBits)\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: sum\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpja6j3ydr.scala:34:37 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m       ",
      "stdout": "",
      "timestamp": 1659798200
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val avg = n / m\n        val bin = math.round(avg).toBinaryString\n        val result = if (bin.length == 1) \"0b\" + bin else bin\n        Right(result)\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp4806uild.scala:17:14 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        Right(result)\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              Found:    (result : String)\n\u001b[31m   |\u001b[0m              Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659798200
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val avg = n to m by -1\n        val binary = avg.map(x => Integer.toBinaryString(x)).mkString\n        val result = if (binary.length == 0) \"0b0\" else binary\n        Right(result)\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp56j7cnwy.scala:15:57 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = avg.map(\u001b[36mx\u001b[0m => Integer.toBinaryString(x)).mkString\n\u001b[31m\u001b[31m   |\u001b[0m                                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                    Found:    (x : Long)\n\u001b[31m   |\u001b[0m                                                    Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp56j7cnwy.scala:17:14 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        Right(result)\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              Found:    (result : String)\n\u001b[31m   |\u001b[0m              Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659798155
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val n = math.max(math.min(n, m), 1L)\n        val m = math.max(math.min(m, n), 1L)\n        val sum = math.min(m, n) + math.max(m, n) + 1\n        val avg = sum / 2\n        val bin = math.pow(10, math.ceil(math.log10(avg)))\n        val result = math.round(avg * bin).toLong / bin\n        val binString = bin.toString(2)\n        if (binString.length < 2) Right(binString)\n        else Left(binString)\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp8y46ozxh.scala:14:34 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mn\u001b[0m = math.max(math.min(n, m), \u001b[31m1L\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Recursive \u001b[33mvalue\u001b[0m \u001b[35mn\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp8y46ozxh.scala:15:34 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mm\u001b[0m = math.max(math.min(m, n), \u001b[31m1L\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Recursive \u001b[33mvalue\u001b[0m \u001b[35mm\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp8y46ozxh.scala:15:37 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mm\u001b[0m = math.max(math.min(m, n), \u001b[31m1L\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Recursive \u001b[33mvalue\u001b[0m \u001b[35mn\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmp8y46ozxh.scala:20:37 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinString\u001b[0m = bin.toString(\u001b[31m2\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m         too many arguments for \u001b[33mmethod\u001b[0m \u001b[35mtoString\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mAny\u001b[0m: (): String\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659798198
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val avg = n / m\n        val binary = avg.toBinaryString\n        val result = binary.reverse.dropWhile(_ == '0').mkString\n        val right = (binary.reverse.takeWhile(_ == '1').length + binary.reverse.length) / 2\n        val left = (binary.reverse.length + binary.length) / 2\n        val result = if (right == left) result else -1\n        Right(result)\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpjaravthw.scala:19:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mif\u001b[0m (right == left) result \u001b[33melse\u001b[0m -\u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mresult is already defined as \u001b[33mvalue\u001b[0m \u001b[35mresult\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpjaravthw.scala:20:14 --------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        Right(result)\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              Found:    (result : String)\n\u001b[31m   |\u001b[0m              Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659798201
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val n = n.toInt\n        val m = m.toInt\n        if (n > m) {\n            Left(-1)\n        } else {\n            val sum = n.toLong + m.toLong\n            val avg = sum / 2\n            val binary = avg.toBinaryString\n            Right(binary.length)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmptn77y75l.scala:14:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mn\u001b[0m = n.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                ^\u001b[0m\n\u001b[31m   |\u001b[0m                Recursive \u001b[33mvalue\u001b[0m \u001b[35mn\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmptn77y75l.scala:15:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mm\u001b[0m = m.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                ^\u001b[0m\n\u001b[31m   |\u001b[0m                Recursive \u001b[33mvalue\u001b[0m \u001b[35mm\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmptn77y75l.scala:17:17 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            Left(-\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^\u001b[0m\n\u001b[31m   |\u001b[0m                 Found:    (\u001b[31m-1\u001b[0m : Int)\n\u001b[31m   |\u001b[0m                 Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659798201
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val sum = n to m by -1\n        val avg = sum.sum / sum.size\n        val bin = math.round(avg).toBinaryString\n        val result = if (bin.size == 0) \"0b0\" else bin\n        Right(result)\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpacor52eq.scala:18:14 --------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        Right(result)\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              Found:    (result : String)\n\u001b[31m   |\u001b[0m              Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659798202
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val avg = n to m by -1\n        val sum = avg.reduceLeft(_ + _)\n        val result = sum / avg.length\n        val bin = result.toBinaryString\n        val right = bin.dropRight(1)\n        val left = bin.take(1)\n        val result = if (right == left) Right result else Left(s\"$result is not an average\")\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpkr4lxs92.scala:20:53 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mif\u001b[0m (right == left) Right result \u001b[33melse\u001b[0m Left(\u001b[31ms\"\u001b[0m$result\u001b[31m is not an average\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                                     ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                      expression expected but \u001b[31melse\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpkr4lxs92.scala:20:46 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mif\u001b[0m (right == left) Right result \u001b[33melse\u001b[0m Left(\u001b[31ms\"\u001b[0m$result\u001b[31m is not an average\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                        ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                 value result is not a member of object scala.util.Right\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpkr4lxs92.scala:21:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        result\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    (result : Long)\n\u001b[31m   |\u001b[0m        Required: Either[String, Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659798203
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val n = n.toInt\n        val m = m.toInt\n        val sum = n to m\n        val avg = sum.sum / sum.size\n        val bin = Integer.toBinaryString(avg)\n        if (bin.length < m) Left(bin)\n        else Right(bin)\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpjqrmx9dt.scala:14:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mn\u001b[0m = n.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                ^\u001b[0m\n\u001b[31m   |\u001b[0m                Recursive \u001b[33mvalue\u001b[0m \u001b[35mn\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpjqrmx9dt.scala:15:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mm\u001b[0m = m.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                ^\u001b[0m\n\u001b[31m   |\u001b[0m                Recursive \u001b[33mvalue\u001b[0m \u001b[35mm\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpjqrmx9dt.scala:20:19 --------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33melse\u001b[0m Right(bin)\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Found:    (bin : String)\n\u001b[31m   |\u001b[0m                   Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659798202
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val n = math.max(math.min(n, m), 1L)\n        val m = math.max(math.min(m, n), 1L)\n        val sum = n + m\n        val avg = sum / 2\n        val bin = math.pow(10, math.ceil(math.log10(avg)))\n        val rounded = math.round(avg * bin) / bin\n        val str = bin.toString(2)\n        val right = str.dropRight(1)\n        val left = str.dropLeft(1)\n        val result = if (right == \"\") left else right\n        Right(rounded)\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp_bubbp_4.scala:14:34 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mn\u001b[0m = math.max(math.min(n, m), \u001b[31m1L\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Recursive \u001b[33mvalue\u001b[0m \u001b[35mn\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp_bubbp_4.scala:15:34 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mm\u001b[0m = math.max(math.min(m, n), \u001b[31m1L\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Recursive \u001b[33mvalue\u001b[0m \u001b[35mm\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp_bubbp_4.scala:15:37 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mm\u001b[0m = math.max(math.min(m, n), \u001b[31m1L\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Recursive \u001b[33mvalue\u001b[0m \u001b[35mn\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmp_bubbp_4.scala:20:31 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstr\u001b[0m = bin.toString(\u001b[31m2\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                               ^\u001b[0m\n\u001b[31m   |\u001b[0m         too many arguments for \u001b[33mmethod\u001b[0m \u001b[35mtoString\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mAny\u001b[0m: (): String\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659798198
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val n = math.max(math.min(n, m), 0).toInt\n        val m = math.max(math.min(m, n), 0).toInt\n        val sum = n + m\n        val avg = sum / 2\n        val binary = binary(sum)\n        val result = if (binary == 0) Right(avg) else Left(s\"$sum is not a power of 2\")\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpigeumwc0.scala:14:34 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mn\u001b[0m = math.max(math.min(n, m), \u001b[31m0\u001b[0m).toInt\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Recursive \u001b[33mvalue\u001b[0m \u001b[35mn\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpigeumwc0.scala:15:34 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mm\u001b[0m = math.max(math.min(m, n), \u001b[31m0\u001b[0m).toInt\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Recursive \u001b[33mvalue\u001b[0m \u001b[35mm\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpigeumwc0.scala:15:37 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mm\u001b[0m = math.max(math.min(m, n), \u001b[31m0\u001b[0m).toInt\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Recursive \u001b[33mvalue\u001b[0m \u001b[35mn\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpigeumwc0.scala:18:21 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary(sum)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                     Recursive \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659798199
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val avg = n + (m / 2)\n        val bin = math.pow(10, math.ceil(math.log10(avg)))\n        val binString = bin.toString(2)\n        val result = binString.substring(0, binString.length - 1)\n        val right = binString.substring(binString.length - 1)\n        val left = binString.substring(0, binString.length - 1)\n        if (right == \"0\") Right(result)\n        else Left(s\"$result $left\")\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmpcr58amz1.scala:16:37 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinString\u001b[0m = bin.toString(\u001b[31m2\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m         too many arguments for \u001b[33mmethod\u001b[0m \u001b[35mtoString\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mAny\u001b[0m: (): String\n1 error found\n",
      "stdout": "",
      "timestamp": 1659798199
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val sum = n to m\n        val avg = sum.sum / sum.size\n        val bin = math.ceil(avg).toBinaryString\n        val result = if (bin.length < 2) \"0b\" + bin else bin\n        Right(result)\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpylmvtxss.scala:16:33 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbin\u001b[0m = math.ceil(avg).toBinaryString\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value toBinaryString is not a member of Double\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpylmvtxss.scala:18:14 --------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        Right(result)\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              Found:    (result : String)\n\u001b[31m   |\u001b[0m              Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659798202
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val sum = n to m\n        val avg = sum.sum / sum.size\n        val binary = avg + \"\"\n        val result = if (binary == binary.reverse) Right(binary.reverse) else Left(s\"$binary is not a binary number\")\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpg7sd4zv5.scala:18:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        result\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    \u001b[1m\u001b[31m(\u001b[0m\u001b[1m\u001b[31mresult\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31m:\u001b[0m\u001b[1m\u001b[31m \u001b[0mEither[String, \u001b[1m\u001b[31mString\u001b[0m]\u001b[1m\u001b[31m)\u001b[0m\n\u001b[31m   |\u001b[0m        Required: Either[String, \u001b[1m\u001b[32mLong\u001b[0m]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659798203
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val avg = n / (m + 1)\n        val bin = math.ceil(avg).toBinaryString\n        val result = Right(bin)\n        if (n > m) Left(-1)\n        else result\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpmj7a9zuc.scala:15:33 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbin\u001b[0m = math.ceil(avg).toBinaryString\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value toBinaryString is not a member of Double\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpmj7a9zuc.scala:17:24 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mif\u001b[0m (n > m) Left(-\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Found:    (\u001b[31m-1\u001b[0m : Int)\n\u001b[31m   |\u001b[0m                        Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659798203
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val avg = n to m by -1\n        val binary = avg.map(_.toBinaryString).mkString\n        val result = if (n >= m) -1 else binary\n        Right(result)\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpq_0w92g7.scala:17:14 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        Right(result)\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              Found:    (result : Matchable)\n\u001b[31m   |\u001b[0m              Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659798203
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val nBits = n.toBinaryString\n        val mBits = m.toBinaryString\n        val nBitsLen = nBits.length\n        val mBitsLen = mBits.length\n        val nBitsSum = sum(nBits.dropRight(mBitsLen))\n        val mBitsSum = sum(mBits.takeRight(nBitsLen))\n        val nBitsSumLen = nBitsSum.length\n        val mBitsSumLen = mBitsSum.length\n        val nBitsSumInt = nBitsSum.toInt\n        val mBitsSumInt = mBitsSum.toInt\n        val nBitsSumBin = nBitsSum.toBinaryString\n        val mBitsSumBin = mBitsSum.toBinaryString\n        val nBitsSumBinLen = nBitsSumBin.length\n        val mBitsSumBinLen = mBitsSumBin.length\n        val nBitsSumBinInt = nBitsSumBin.toInt\n        val mBitsSumBinInt = mBitsSumBin.toInt\n        val nBitsSumBinBin = nBitsSumBin.toBinaryString\n        val mBitsSumBinBin = mBitsSumBin.toBinaryString\n        val nBitsSumBinBinLen = nBitsSumBinBin.length\n        val mBitsSumBinBinLen = mBitsSumBinBin.length\n        val nBitsSumBinBinInt = nBitsSumBinBin.toInt\n        val mBitsSumBinBinInt = mBitsSumBinBin.toInt\n        val nBitsSumBinBinBinLen = nBitsSumBinBinLen\n        val mBitsSumBinBinLen = mBitsSumBinBinLen\n        val nBitsSumBinBinBinInt = nBitsSumBinBinInt.toInt\n        val mBitsSumBinBinInt = mBitsSumBinBinInt.toInt\n        val nBitsSumBinBinBinLen = nBitsSumBinBinLen\n        val mBitsSumBinBinLen = mBitsSumBinBinLen\n        val nBitsSumBinBinBinBinInt = nBitsSumBinBinBinInt.toInt\n        val mBitsSumBinBinInt = mBitsSumBinBinInt.toInt\n        val nBitsSumBinBinBinLen = nBitsSumBinBinLen\n        val \n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpe0cvjf09.scala:45:11 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m45 |\u001b[0m        \u001b[33mval\u001b[0m \n\u001b[31m\u001b[31m   |\u001b[0m           ^\u001b[0m\n\u001b[31m   |\u001b[0m           pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpe0cvjf09.scala:37:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmBitsSumBinBinLen\u001b[0m = mBitsSumBinBinLen\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmBitsSumBinBinLen is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmBitsSumBinBinLen\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpe0cvjf09.scala:39:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmBitsSumBinBinInt\u001b[0m = mBitsSumBinBinInt.toInt\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmBitsSumBinBinInt is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmBitsSumBinBinInt\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpe0cvjf09.scala:40:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnBitsSumBinBinBinLen\u001b[0m = nBitsSumBinBinLen\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnBitsSumBinBinBinLen is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnBitsSumBinBinBinLen\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpe0cvjf09.scala:41:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmBitsSumBinBinLen\u001b[0m = mBitsSumBinBinLen\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmBitsSumBinBinLen is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmBitsS",
      "stdout": "",
      "timestamp": 1659798203
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val avg = n to m by -1\n        val binary = avg.map(_.toBinaryString).mkString\n        val result = if (binary.length < m) -1 else binary.substring(0, m)\n        Right(result)\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpyqffd022.scala:16:72 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mif\u001b[0m (binary.length < m) -\u001b[31m1\u001b[0m \u001b[33melse\u001b[0m binary.substring(\u001b[31m0\u001b[0m, m)\n\u001b[31m\u001b[31m   |\u001b[0m                                                                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                    Found:    (m : Long)\n\u001b[31m   |\u001b[0m                                                    Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpyqffd022.scala:17:14 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        Right(result)\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              Found:    (result : Matchable)\n\u001b[31m   |\u001b[0m              Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659798205
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val sum = n to m\n        val avg = sum.sum / sum.size\n        val bin = Integer.toBinaryString(avg)\n        val result = if (sum.size == 1) bin\n        else bin.substring(0, bin.length - 1)\n        val right = if (sum.size == 1) \"0b0\"\n        else bin.substring(bin.length - 1)\n        val left = if (sum.size == 1) \"0b0\"\n        else bin.substring(0, bin.length - 1)\n        val result = if (sum.size == 1) bin\n        else bin.substring(0, bin.length - 1)\n        val right = if (sum.size == 1) \"0b0\"\n        else bin.substring(bin.length - 1)\n        val left = if (sum.size == 1) \"0b0\"\n        else bin.substring(0, bin.length - 1)\n        val result = if (sum.size == 1) bin\n        else bin.substring(0, bin.length - 1)\n        val right = if (sum.size == 1) \"0b0\"\n        else bin.substring(bin.length - 1)\n        val left = if (sum.size == 1) \"0b0\"\n        else bin.substring(0, bin.length - 1)\n        val result = if (sum.size == 1) bin\n        else bin.substring(0, bin.length - 1)\n        val right = if (sum.size == 1) \"0b0\"\n        else bin.substring(bin.length - 1)\n        val left = if (sum.size == 1) \"0b0\"\n        else bin.substring(0, bin.length - 1)\n        val result = if (sum.size == 1) bin\n        else bin.substring(0, bin.length - 1)\n        val right = if (sum.size == 1) \"0b0\"\n        else bin.substring(bin.length - 1)\n        val left = if (sum.size == 1) \"0b0\"\n        else bin.substring(0, bin.length - 1)\n        val result = if (sum.size == 1) bin\n        else bin.substring(0, bin.length - 1)\n        val right = if (sum.size == 1) \"0b0\"\n        else bin.substring(bin.length - 1)\n        val left = if (sum.size == 1) \"0b0\"\n        else bin.substring(0, bin.length - 1)\n        val result = if (sum.size == 1) bin\n        else bin.substring(0, bin.length - 1)\n        val right = if (sum.size == 1) \"0b0\"\n        else bin.substring(bin.length - 1)\n        val left = if (sum.size == 1) \"0b0\"\n        else bin.substring(0, bin.length - 1)\n        val result = if (sum.size == 1) bin\n        else bin.substring(0, bin.length - 1)\n        val right = if (sum.size == 1) \"0b0\"\n        else bin.substring(bin.length - 1)\n        val left = if (sum.size == 1) \"0b0\"\n        else bin.substring(0, bin.length - 1)\n        val result = if (sum.size == 1) bin\n        else bin.substring(0, bin.length - 1)\n        \n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp2fh42um8.scala:23:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mif\u001b[0m (sum.size == \u001b[31m1\u001b[0m) bin\n\u001b[31m\u001b[31m   |\u001b[0m        ^\u001b[0m\n\u001b[31m   |\u001b[0mresult is already defined as \u001b[33mvalue\u001b[0m \u001b[35mresult\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m24 |\u001b[0m        \u001b[33melse\u001b[0m bin.substring(\u001b[31m0\u001b[0m, bin.length - \u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp2fh42um8.scala:25:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mright\u001b[0m = \u001b[33mif\u001b[0m (sum.size == \u001b[31m1\u001b[0m) \u001b[31m\"0b0\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^\u001b[0m\n\u001b[31m   |\u001b[0mright is already defined as \u001b[33mvalue\u001b[0m \u001b[35mright\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m26 |\u001b[0m        \u001b[33melse\u001b[0m bin.substring(bin.length - \u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp2fh42um8.scala:27:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mleft\u001b[0m = \u001b[33mif\u001b[0m (sum.size == \u001b[31m1\u001b[0m) \u001b[31m\"0b0\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^\u001b[0m\n\u001b[31m   |\u001b[0mleft is already defined as \u001b[33mvalue\u001b[0m \u001b[35mleft\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m28 |\u001b[0m        \u001b[33melse\u001b[0m bin.substring(\u001b[31m0\u001b[0m, bin.length - \u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp2fh42um8.scala:29:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mif\u001b[0m (sum.size == \u001b[31m1\u001b[0m) bin\n\u001b[31m\u001b[31m   |\u001b[0m        ^\u001b[0m\n\u001b[31m   |\u001b[0mresult is already defined as \u001b[33mvalue\u001b[0m \u001b[35mresult\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m30 |\u001b[0m        \u001b[33melse\u001b[0m bin.substring(\u001b[31m0\u001b[0m, bin.length - \u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp2",
      "stdout": "",
      "timestamp": 1659798204
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val avg = n / (m+1)\n        val binary = avg.toBinaryString\n        val result = binary.reverse.dropWhile(_ == '0').drop(1).reverse\n        val result = result.dropRight(1)\n        val result = result.takeRight(binary.length)\n        val result = result.dropWhile(_ == '0').drop(1).reverse\n        val result = result.dropRight(1)\n        val result = result.takeRight(binary.length)\n        val result = result.dropWhile(_ == '0').drop(1).reverse\n        val result = result.dropRight(1)\n        val result = result.takeRight(binary.length)\n        val result = result.dropWhile(_ == '0').drop(1).reverse\n        val result = result.dropRight(1)\n        val result = result.takeRight(binary.length)\n        val result = result.dropWhile(_ == '0').drop(1).reverse\n        val result = result.dropRight(1)\n        val result = result.takeRight(binary.length)\n        val result = result.dropWhile(_ == '0').drop(1).reverse\n        val result = result.dropRight(1)\n        val result = result.takeRight(binary.length)\n        val result = result.dropWhile(_ == '0').drop(1).reverse\n        val result = result.dropRight(1)\n        val result = result.takeRight(binary.length)\n        val result = result.dropWhile(_ == '0').drop(1).reverse\n        val result = result.dropRight(1)\n        val result = result.takeRight(binary.length)\n        val result = result.dropWhile(_ == '0').drop(1).reverse\n        val result = result.dropRight(1)\n        val result = result.takeRight(binary.length)\n        val result = result.dropWhile(_ == '0').drop(1).reverse\n        val result = result.dropRight(1)\n        val result = result.takeRight(binary.length)\n        val result = result.dropWhile(_ == '0').drop(1).reverse\n        val result = result.dropRight(1)\n        val result = result.takeRight(binary.length)\n        val result = result.dropWhile(_ == '0').drop(1).reverse\n        val result = result.dropRight(1)\n        val result = result.takeRight(binary.length)\n        val result = result.dropWhile(_ == '0').drop(1).reverse\n        val result = result.dropRight(1)\n        val result = result.takeRight(binary.length)\n        val result = result.dropWhile(_ == '0').drop(1).reverse\n        val result = result.dropRight(1)\n        val result = result.takeRight(binary.length)\n        val result = result.dropWhile(_ == '0').drop(1).reverse\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp6v_0wbxq.scala:17:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = result.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mresult is already defined as \u001b[33mvalue\u001b[0m \u001b[35mresult\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp6v_0wbxq.scala:18:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = result.takeRight(binary.length)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mresult is already defined as \u001b[33mvalue\u001b[0m \u001b[35mresult\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp6v_0wbxq.scala:19:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = result.dropWhile(_ == \u001b[31m'0'\u001b[0m).drop(\u001b[31m1\u001b[0m).reverse\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mresult is already defined as \u001b[33mvalue\u001b[0m \u001b[35mresult\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp6v_0wbxq.scala:20:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = result.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mresult is already defined as \u001b[33mvalue\u001b[0m \u001b[35mresult\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp6v_0wbxq.scala:21:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = result.takeRight(binary.length)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^",
      "stdout": "",
      "timestamp": 1659798204
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val avg = n to m by -1\n        val sum = 0L\n        val binary = \"\"\n        for(i <- 0 until avg.length) {\n            val n = avg(i)\n            val m = avg(i+1)\n            val sum = sum + n\n            val bin = sum.toString + m.toString\n            binary = binary + bin.charAt(bin.length-1)\n        }\n        if(n >= m) {\n            Left(binary)\n        } else {\n            Right(sum.toLong)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpllgce2t1.scala:20:22 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36msum\u001b[0m = sum + n\n\u001b[31m\u001b[31m   |\u001b[0m                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                      Recursive \u001b[33mvalue\u001b[0m \u001b[35msum\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpllgce2t1.scala:22:19 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            binary = binary + bin.charAt(bin.length-\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Reassignment to val binary\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659798204
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val n = math.max(math.min(m, n), n)\n        val m = math.max(math.min(m, n), n)\n        val binary = n.toBinaryString\n        val binary = binary.padToLength(binary.length + m.toBinaryString.length, \"0\")\n        val binary = binary.drop(binary.length - m.toBinaryString.length)\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        \n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpzh6l5h68.scala:17:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.padToLength(binary.length + m.toBinaryString.length, \u001b[31m\"0\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpzh6l5h68.scala:18:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.drop(binary.length - m.toBinaryString.length)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpzh6l5h68.scala:19:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.reverse\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpzh6l5h68.scala:20:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.reverse\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpzh6l5h68.scala:21:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.reverse\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^",
      "stdout": "",
      "timestamp": 1659798210
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val avg = n/m\n        val binary = avg.toBinaryString\n        val result = binary.reverse.dropWhile(x => x == '0').mkString\n        val right = new Right(result)\n        if (n > m) right\n        else Left(s\"$n $m $result\")\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp4d239v14.scala:18:19 --------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (n > m) right\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Found:    (right : Right[Nothing, String])\n\u001b[31m   |\u001b[0m                   Required: Either[String, Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659798209
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val sum = n to m\n        val avg = sum.sum / sum.size\n        val bin = math.ceil(avg).toBinaryString\n        val result = if (bin.size == m) Right(bin) else Left(s\"$n to $m is $avg\")\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp327w0136.scala:16:33 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbin\u001b[0m = math.ceil(avg).toBinaryString\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value toBinaryString is not a member of Double\n1 error found\n",
      "stdout": "",
      "timestamp": 1659798210
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val n = math.abs(n)\n        val m = math.abs(m)\n        if (n > m) {\n            Left(-1)\n        } else {\n            val avg = math.round((n + m) / 2)\n            Right(math.pow(2,avg).toInt)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpbo8l7zt9.scala:14:25 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mn\u001b[0m = math.abs(n)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                         Recursive \u001b[33mvalue\u001b[0m \u001b[35mn\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpbo8l7zt9.scala:15:25 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mm\u001b[0m = math.abs(m)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                         Recursive \u001b[33mvalue\u001b[0m \u001b[35mm\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpbo8l7zt9.scala:17:17 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            Left(-\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^\u001b[0m\n\u001b[31m   |\u001b[0m                 Found:    (\u001b[31m-1\u001b[0m : Int)\n\u001b[31m   |\u001b[0m                 Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659798210
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val avg = n to m by -1\n        val sum = 0\n        val binary = \"\"\n        for(i <- 0 until avg.length) {\n            sum += avg(i)\n            binary += if(sum > 0) \"1\" else \"0\"\n        }\n        val result = if(sum > 0) binary.toLong else -1\n        Right(result)\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpt70ud2gx.scala:19:22 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m            binary += \u001b[33mif\u001b[0m(sum > \u001b[31m0\u001b[0m) \u001b[31m\"1\"\u001b[0m \u001b[33melse\u001b[0m \u001b[31m\"0\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^\u001b[0m\n\u001b[31m   |\u001b[0m                      expression expected but \u001b[31mif\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpt70ud2gx.scala:18:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m            sum += avg(i)\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of Int - did you mean sum.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpt70ud2gx.scala:19:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m            binary += \u001b[33mif\u001b[0m(sum > \u001b[31m0\u001b[0m) \u001b[31m\"1\"\u001b[0m \u001b[33melse\u001b[0m \u001b[31m\"0\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of String - did you mean binary.!=?\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659798212
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val sum = n to m\n        val avg = sum.sum / sum.size\n        val bin = math.ceil(avg).toBinaryString\n        val result = if (bin.length == 1) \"0b\" + bin else bin\n        Right(result)\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpsf119fje.scala:16:33 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbin\u001b[0m = math.ceil(avg).toBinaryString\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value toBinaryString is not a member of Double\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpsf119fje.scala:18:14 --------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        Right(result)\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              Found:    (result : String)\n\u001b[31m   |\u001b[0m              Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659798213
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val avg = n to m by -1\n        val binary = avg.map(_.toBinaryString).mkString\n        val bin = binary.length\n        val len = binary.length\n        val binary = binary.padTo(len, 0)\n        val binary = binary.reverse\n        val binary = binary.drop(binary.length - 1)\n        val binary = binary.reverse\n        val binary = binary.drop(binary.length - 1)\n        val binary = binary.reverse\n        val binary = binary.drop(binary.length - 1)\n        val binary = binary.reverse\n        val binary = binary.drop(binary.length - 1)\n        val binary = binary.reverse\n        val binary = binary.drop(binary.length - 1)\n        val binary = binary.reverse\n        val binary = binary.drop(binary.length - 1)\n        val binary = binary.reverse\n        val binary = binary.drop(binary.length - 1)\n        val binary = binary.reverse\n        val binary = binary.drop(binary.length - 1)\n        val binary = binary.reverse\n        val binary = binary.drop(binary.length - 1)\n        val binary = binary.reverse\n        val binary = binary.drop(binary.length - 1)\n        val binary = binary.reverse\n        val binary = binary.drop(binary.length - 1)\n        val binary = binary.reverse\n        val binary = binary.drop(binary.length - 1)\n        val binary = binary.reverse\n        val binary = binary.drop(binary.length - 1)\n        val binary = binary.reverse\n        val binary = binary.drop(binary.length - 1)\n        val binary = binary.reverse\n        val binary = binary.drop(binary.length - 1)\n        val binary = binary.reverse\n        val binary = binary.drop(binary.length - 1)\n        val binary = binary.reverse\n        val binary = binary.drop(binary.length - 1)\n        val binary = binary.reverse\n        val binary = binary.drop(binary.length - 1)\n        val binary = binary.reverse\n        val binary = binary.drop(binary.length - 1)\n        val binary = binary.reverse\n        val binary = binary.drop(binary.length - 1)\n        val binary = binary.reverse\n        val binary = binary.drop(binary.length - 1)\n        val binary = binary.reverse\n        val binary = binary.drop(binary.length - 1)\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp4yivk_yq.scala:18:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.padTo(len, \u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp4yivk_yq.scala:19:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.reverse\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp4yivk_yq.scala:20:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.drop(binary.length - \u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp4yivk_yq.scala:21:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.reverse\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp4yivk_yq.scala:22:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.drop(binary.length - \u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35",
      "stdout": "",
      "timestamp": 1659798212
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val avg = n + (m / 2)\n        val bin = math.pow(2,math.ceil(math.log2(avg)))\n        val binStr = bin.toString(2)\n        val binStrLen = binStr.length\n        val n = binStr.substring(0, binStrLen - 1)\n        val m = binStr.substring(binStrLen - 1)\n        val result = if (n == m) Right(avg) else Left(s\"$n $m\")\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpd25um947.scala:15:44 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbin\u001b[0m = math.pow(\u001b[31m2\u001b[0m,math.ceil(math.log2(avg)))\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                      value log2 is not a member of math\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpd25um947.scala:15:49 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbin\u001b[0m = math.pow(\u001b[31m2\u001b[0m,math.ceil(math.log2(avg)))\n\u001b[31m\u001b[31m   |\u001b[0m                                                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          Recursive \u001b[33mvalue\u001b[0m \u001b[35mavg\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmpd25um947.scala:16:34 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinStr\u001b[0m = bin.toString(\u001b[31m2\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m         too many arguments for \u001b[33mmethod\u001b[0m \u001b[35mtoString\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mAny\u001b[0m: (): String\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659798213
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val nBits = n.toBinaryString\n        val mBits = m.toBinaryString\n        val nBitsLength = nBits.length\n        val mBitsLength = mBits.length\n        val nBitsSum = n.toInt\n        val mBitsSum = m.toInt\n        val nBitsSumLength = nBitsSum.length\n        val mBitsSumLength = mBitsSum.length\n        val nBitsSumBits = nBitsSum.dropRight(nBitsSumLength)\n        val mBitsSumBits = mBitsSum.dropRight(mBitsSumLength)\n        val nBitsSumBitsLength = nBitsSumBits.length\n        val mBitsSumBitsLength = mBitsSumBits.length\n        val nBitsSumBitsSum = nBitsSumBits.dropRight(nBitsSumBitsLength)\n        val mBitsSumBitsSum = mBitsSumBits.dropRight(mBitsSumBitsLength)\n        val nBitsSumBitsSumLength = nBitsSumBitsSum.length\n        val mBitsSumBitsSumLength = mBitsSumBitsSum.length\n        val nBitsSumBitsSumBits = nBitsSumBitsSum.dropRight(nBitsSumBitsSumLength)\n        val mBitsSumBitsSumBits = mBitsSumBitsSum.dropRight(mBitsSumBitsSumLength)\n        val nBitsSumBitsSumBitsLength = nBitsSumBitsSumBits.length\n        val mBitsSumBitsSumBitsLength = mBitsSumBitsSumBits.length\n        val nBitsSumBitsSumBitsSum = nBitsSumBitsSumBits.dropRight(nBitsSumBitsSumBitsLength)\n        val mBitsSumBitsSumBitsSum = mBitsSumBitsSumBits.dropRight(mBitsSumBitsSumBitsLength)\n        val nBitsSumBitsSumBitsSumLength = nBitsSumBitsSumBitsSum.length\n        val mBitsSumBitsSumBitsSumLength = mBitsSumBitsSumBitsSum.length\n        val nBitsSumBitsSumBitsSumBits = nBitsSumBitsSumBitsSum.dropRight(nBitsSumBit\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmprhnda9c5.scala:39:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmprhnda9c5.scala:20:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnBitsSumLength\u001b[0m = nBitsSum.length\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                             value length is not a member of Int\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmprhnda9c5.scala:21:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmBitsSumLength\u001b[0m = mBitsSum.length\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                             value length is not a member of Int\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmprhnda9c5.scala:22:36 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnBitsSumBits\u001b[0m = nBitsSum.dropRight(nBitsSumLength)\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                           value dropRight is not a member of Int\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmprhnda9c5.scala:23:36 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmBitsSumBits\u001b[0m = mBitsSum.dropRight(mBitsSumLength)\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                           value dropRight is not a member of Int\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmprhnda9c5.scala:39:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Either[String, Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n6 errors found\n",
      "stdout": "",
      "timestamp": 1659798214
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val avg = ((n + m) / 2).round\n        val binary = avg.toBinaryString\n        if (binary.length < m) Left(s\"$n to $m is $avg\")\n        else Right(binary.substring(0, m))\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpjwhpaqm7.scala:17:39 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33melse\u001b[0m Right(binary.substring(\u001b[31m0\u001b[0m, m))\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                                       Found:    (m : Long)\n\u001b[31m   |\u001b[0m                                       Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659798212
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val n = math.abs(n)\n        val m = math.abs(m)\n        val avg = ((n + m) / 2.0).toLong\n        val binary = avg.toBinaryString\n        if (binary.length < 2) Right(binary.padToLength(2, \"0\"))\n        else Left(s\"$binary\")\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpkkr7hyoy.scala:14:25 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mn\u001b[0m = math.abs(n)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                         Recursive \u001b[33mvalue\u001b[0m \u001b[35mn\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpkkr7hyoy.scala:15:25 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mm\u001b[0m = math.abs(m)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                         Recursive \u001b[33mvalue\u001b[0m \u001b[35mm\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659798209
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val n = math.ceil(n)\n        val m = math.ceil(m)\n        val sum = (n to m).foldLeft(0L){ (sum, v) => sum + v }\n        val avg = sum / m\n        val binary = avg.toBinaryString\n        val result = if (binary == \"\") -1 else binary.toLong\n        Left(s\"$sum / $m = $result\")\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmplk_vsees.scala:14:26 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mn\u001b[0m = math.ceil(n)\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Recursive \u001b[33mvalue\u001b[0m \u001b[35mn\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmplk_vsees.scala:15:26 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mm\u001b[0m = math.ceil(m)\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Recursive \u001b[33mvalue\u001b[0m \u001b[35mm\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmplk_vsees.scala:16:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36msum\u001b[0m = (n to m).foldLeft(\u001b[31m0L\u001b[0m){ (\u001b[36msum\u001b[0m, \u001b[36mv\u001b[0m) => sum + v }\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue to is not a member of Double, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mThe following import might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.BigDecimal.double2bigDecimal\n\u001b[31m   |\u001b[0m\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659798214
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val sum = n to m\n        val avg = sum.sum / sum.length\n        val bin = math.ceil(avg).toBinaryString\n        val right = bin.dropRight(1)\n        val left = bin.dropLeft(1)\n        val result = if (right == left) Right(bin) else Left(s\"$left $right\")\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpe7so3edd.scala:16:33 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbin\u001b[0m = math.ceil(avg).toBinaryString\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value toBinaryString is not a member of Double\n1 error found\n",
      "stdout": "",
      "timestamp": 1659798214
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val n = math.abs(n)\n        val m = math.abs(m)\n        val sum = n + m\n        val avg = sum / 2\n        val binary = math.round(avg).toBinaryString\n        val result = if (binary == \"\") -1 else binary\n        Right(result)\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpsenq3ws6.scala:14:25 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mn\u001b[0m = math.abs(n)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                         Recursive \u001b[33mvalue\u001b[0m \u001b[35mn\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpsenq3ws6.scala:15:25 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mm\u001b[0m = math.abs(m)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                         Recursive \u001b[33mvalue\u001b[0m \u001b[35mm\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659798190
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val sum = n to m\n        val sums = sum.map(x => x.toBinaryString).map(x => x.padToLength(8, \"0\"))\n        val sumsSum = sums.sum\n        val sumsSum2 = sumsSum * sumsSum\n        val sumsSum3 = sumsSum2 * sumsSum\n        val sumsSum4 = sumsSum3 * sumsSum\n        val sumsSum5 = sumsSum4 * sumsSum\n        val sumsSum6 = sumsSum5 * sumsSum\n        val sumsSum7 = sumsSum6 * sumsSum\n        val sumsSum8 = sumsSum7 * sumsSum\n        val sumsSum9 = sumsSum8 * sumsSum\n        val sumsSum10 = sumsSum9 * sumsSum\n        val sumsSum11 = sumsSum10 * sumsSum\n        val sumsSum12 = sumsSum11 * sumsSum\n        val sumsSum13 = sumsSum12 * sumsSum\n        val sumsSum14 = sumsSum13 * sumsSum\n        val sumsSum15 = sumsSum14 * sumsSum\n        val sumsSum16 = sumsSum15 * sumsSum\n        val sumsSum17 = sumsSum16 * sumsSum\n        val sumsSum18 = sumsSum17 * sumsSum\n        val sumsSum19 = sumsSum18 * sumsSum\n        val sumsSum20 = sumsSum19 * sumsSum\n        val sumsSum21 = sumsSum20 * sumsSum\n        val sumsSum22 = sumsSum21 * sumsSum\n        val sumsSum23 = sumsSum22 * sumsSum\n        val sumsSum24 = sumsSum23 * sumsSum\n        val sumsSum25 = sumsSum24 * sumsSum\n        val sumsSum26 = sumsSum25 * sumsSum\n        val sumsSum27 = sumsSum26 * sumsSum\n        val sumsSum28 = sumsSum27 * sumsSum\n        val sumsSum29 = sumsSum28 * sumsSum\n        val sumsSum30 = sumsSum29 * sumsSum\n        val sumsSum31 = sumsSum30 * sumsSum\n        val sumsSum32 = \n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpctaiktsx.scala:47:23 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m47 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36msumsSum32\u001b[0m = \n\u001b[31m\u001b[31m   |\u001b[0m                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                       expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpctaiktsx.scala:15:61 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36msums\u001b[0m = sum.map(\u001b[36mx\u001b[0m => x.toBinaryString).map(\u001b[36mx\u001b[0m => x.padToLength(\u001b[31m8\u001b[0m, \u001b[31m\"0\"\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                                                           ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                             value padToLength is not a member of String\n\u001b[31m\u001b[31m-- Error: /tmp/tmpctaiktsx.scala:16:30 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36msumsSum\u001b[0m = sums.sum\n\u001b[31m\u001b[31m   |\u001b[0m                              ^\u001b[0m\n\u001b[31m   |\u001b[0mambiguous given instances: both \u001b[33mobject\u001b[0m \u001b[35mLongIsIntegral\u001b[0m in \u001b[33mobject\u001b[0m \u001b[35mNumeric\u001b[0m and \u001b[33mobject\u001b[0m \u001b[35mBigDecimalIsFractional\u001b[0m in \u001b[33mobject\u001b[0m \u001b[35mNumeric\u001b[0m match type Numeric[B] of parameter num of \u001b[33mmethod\u001b[0m \u001b[35msum\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mIterableOnceOps\u001b[0m\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpctaiktsx.scala:48:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m48 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Either[String, Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659798214
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val avg = n to m by -1\n        val binary = avg.map(x => x.toBinaryString).mkString\n        val result = if (n == m) Right(binary) else Left(s\"$n to $m is $binary\")\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpgjpvuesx.scala:17:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        result\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    \u001b[1m\u001b[31m(\u001b[0m\u001b[1m\u001b[31mresult\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31m:\u001b[0m\u001b[1m\u001b[31m \u001b[0mEither[String, \u001b[1m\u001b[31mString\u001b[0m]\u001b[1m\u001b[31m)\u001b[0m\n\u001b[31m   |\u001b[0m        Required: Either[String, \u001b[1m\u001b[32mLong\u001b[0m]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659798213
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val avg = n to m by -1\n        val binary = avg.map(_.toBinaryString).mkString\n        val result = if (n <= m) Right(binary.toLong) else Left(\"-1\")\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.NumberFormatException: For input string: \"\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\tat java.base/java.lang.Long.parseLong(Long.java:721)\n\tat java.base/java.lang.Long.parseLong(Long.java:836)\n\tat scala.collection.StringOps$.toLong$extension(StringOps.scala:928)\n\tat Problem$.roundedAvg(tmprz8u7hxr.scala:16)\n\tat Problem$.main(tmprz8u7hxr.scala:20)\n\tat Problem.main(tmprz8u7hxr.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798216
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val avg = n to m by -1\n        val binary = avg.map(_.toBinaryString).mkString(\"\")\n        val result = binary.toLong\n        Right(result)\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.NumberFormatException: For input string: \"\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\tat java.base/java.lang.Long.parseLong(Long.java:721)\n\tat java.base/java.lang.Long.parseLong(Long.java:836)\n\tat scala.collection.StringOps$.toLong$extension(StringOps.scala:928)\n\tat Problem$.roundedAvg(tmp8y66agk0.scala:16)\n\tat Problem$.main(tmp8y66agk0.scala:20)\n\tat Problem.main(tmp8y66agk0.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798216
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val nToM = (n to m).toList\n        val nToMSum = nToM.sum\n        val nToMCount = nToM.size\n        val nToMSumInt = nToMSum.toInt\n        val nToMSumBin = Integer.toBinaryString(nToMSumInt)\n        val nToMCountBin = Integer.toBinaryString(nToMCount)\n        val nToMSumBin = Integer.toBinaryString(nToMSumInt)\n        val nToMCountBin = Integer.toBinaryString(nToMCount)\n        val nToMSumBin = Integer.toBinaryString(nToMSumInt)\n        val nToMCountBin = Integer.toBinaryString(nToMCount)\n        val nToMSumBin = Integer.toBinaryString(nToMSumInt)\n        val nToMCountBin = Integer.toBinaryString(nToMCount)\n        val nToMSumBin = Integer.toBinaryString(nToMSumInt)\n        val nToMCountBin = Integer.toBinaryString(nToMCount)\n        val nToMSumBin = Integer.toBinaryString(nToMSumInt)\n        val nToMCountBin = Integer.toBinaryString(nToMCount)\n        val nToMSumBin = Integer.toBinaryString(nToMSumInt)\n        val nToMCountBin = Integer.toBinaryString(nToMCount)\n        val nToMSumBin = Integer.toBinaryString(nToMSumInt)\n        val nToMCountBin = Integer.toBinaryString(nToMCount)\n        val nToMSumBin = Integer.toBinaryString(nToMSumInt)\n        val nToMCountBin = Integer.toBinaryString(nToMCount)\n        val nToMSumBin = Integer.toBinaryString(nToMSumInt)\n        val nToMCountBin = Integer.toBinaryString(nToMCount)\n        val nToMSumBin = Integer.toBinaryString(nToMSumInt)\n        val nToMCountBin = Integer.toBinaryString(nToMCount)\n        val nToMSumBin = Integer.toBinaryString(nToMSumInt)\n        val nToMCountBin = Integer.toBinaryString(nToMCount)\n        val nToMSumBin = Integer.toBinaryString(nToMSumInt)\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp_fw5nill.scala:20:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnToMSumBin\u001b[0m = Integer.toBinaryString(nToMSumInt)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnToMSumBin is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnToMSumBin\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp_fw5nill.scala:21:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnToMCountBin\u001b[0m = Integer.toBinaryString(nToMCount)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnToMCountBin is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnToMCountBin\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp_fw5nill.scala:22:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnToMSumBin\u001b[0m = Integer.toBinaryString(nToMSumInt)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnToMSumBin is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnToMSumBin\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp_fw5nill.scala:23:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnToMCountBin\u001b[0m = Integer.toBinaryString(nToMCount)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnToMCountBin is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnToMCountBin\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp_fw5nill.scala:24:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnToMSumBin\u001b[0m",
      "stdout": "",
      "timestamp": 1659798215
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val nBits = n.toBinaryString\n        val mBits = m.toBinaryString\n        val nBitsLength = nBits.length\n        val mBitsLength = mBits.length\n        val nBitsSum = n.toInt\n        val mBitsSum = m.toInt\n        val nBitsSumLength = nBitsSum.toBinaryString.length\n        val mBitsSumLength = mBitsSum.toBinaryString.length\n        val nBitsSumBits = nBitsSum.toBinaryString\n        val mBitsSumBits = mBitsSum.toBinaryString\n        val nBitsSumBitsLength = nBitsSumBits.length\n        val mBitsSumBitsLength = mBitsSumBits.length\n        val nBitsSumBitsSum = nBitsSumBits.toInt\n        val mBitsSumBitsSum = mBitsSumBits.toInt\n        val nBitsSumBitsSumLength = nBitsSumBitsSum.toBinaryString.length\n        val mBitsSumBitsSumLength = mBitsSumBitsSum.toBinaryString.length\n        val nBitsSumBitsSumBits = nBitsSumBitsSum.toBinaryString\n        val mBitsSumBitsSumBits = mBitsSumBitsSum.toBinaryString\n        val nBitsSumBitsSumBitsLength = nBitsSumBitsSumBits.length\n        val mBitsSumBitsSumBitsLength = mBitsSumBitsSumBits.length\n        val nBitsSumBitsSumBitsSum = nBitsSumBitsSumBits.toInt\n        val mBitsSumBitsSumBitsSum = mBitsSumBitsSumBits.toInt\n        val nBitsSumBitsSumBitsSumLength = nBitsSumBitsSumBitsSum.toBinaryString.length\n        val mBitsSumBitsSumBitsSumLength = mBitsSumBitsSumBitsSum.toBinaryString.length\n        val nBitsSumBitsSumBitsSumBits = nBitsSumBitsSumBitsSum.toBinaryString\n        val mBitsSumBitsSumBitsSumBits = mBitsSumBitsSumBitsSum.toBinaryString\n        val nBitsSumBitsSumBitsSumBitsLength = nBitsSumBitsSumBitsSumBit\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp1wmpuauo.scala:40:47 ------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnBitsSumBitsSumBitsSumBitsLength\u001b[0m = nBitsSumBitsSumBitsSumBit\n\u001b[31m\u001b[31m   |\u001b[0m                                               ^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                    Not found: nBitsSumBitsSumBitsSumBit\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp1wmpuauo.scala:41:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Either[String, Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659798215
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val n = math.max(math.min(n, m), -1)\n        val m = math.max(math.min(m, n), -1)\n        val sum = n + m\n        val avg = sum / 2\n        val bin = math.pow(10, math.ceil(math.log10(avg)))\n        val result = math.round(avg * bin)\n        val str = result.toBinaryString\n        val right = str.dropRight(1)\n        val left = str.dropLeft(1)\n        val right = right.reverse\n        val left = left.reverse\n        val result = if (right == left) Right(result) else Left(s\"$result is not an average\")\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpsdtjnb9i.scala:23:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mright\u001b[0m = right.reverse\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mright is already defined as \u001b[33mvalue\u001b[0m \u001b[35mright\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpsdtjnb9i.scala:24:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mleft\u001b[0m = left.reverse\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mleft is already defined as \u001b[33mvalue\u001b[0m \u001b[35mleft\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpsdtjnb9i.scala:25:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mif\u001b[0m (right == left) Right(result) \u001b[33melse\u001b[0m Left(\u001b[31ms\"\u001b[0m$result\u001b[31m is not an average\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mresult is already defined as \u001b[33mvalue\u001b[0m \u001b[35mresult\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpsdtjnb9i.scala:14:34 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mn\u001b[0m = math.max(math.min(n, m), -\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Recursive \u001b[33mvalue\u001b[0m \u001b[35mn\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpsdtjnb9i.scala:15:34 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mm\u001b[0m = math.max(math.min(m, n), -\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[3",
      "stdout": "",
      "timestamp": 1659798213
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val n = math.max(math.min(n, m), -1)\n        val m = math.max(math.min(m, n), -1)\n        val sum = n to m\n        val avg = sum.sum / sum.size\n        val bin = math.round(avg).toBinaryString\n        val result = if (bin == \"\") -1 else bin\n        Left(result)\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpdyyc_2m4.scala:14:34 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mn\u001b[0m = math.max(math.min(n, m), -\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Recursive \u001b[33mvalue\u001b[0m \u001b[35mn\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpdyyc_2m4.scala:15:34 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mm\u001b[0m = math.max(math.min(m, n), -\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Recursive \u001b[33mvalue\u001b[0m \u001b[35mm\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpdyyc_2m4.scala:15:37 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mm\u001b[0m = math.max(math.min(m, n), -\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Recursive \u001b[33mvalue\u001b[0m \u001b[35mn\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpdyyc_2m4.scala:20:13 --------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        Left(result)\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m             Found:    (result : Int)\n\u001b[31m   |\u001b[0m             Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659798216
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val avg = n / m\n        val binary = avg.toBinaryString\n        val result = binary.reverse.dropRight(1)\n        val resultString = result.reverse\n        val resultLong = resultString.toLong\n        val resultLeft = Right(resultLong)\n        if (n < m) resultLeft\n        else Left(resultString)\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.NumberFormatException: For input string: \"\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\tat java.base/java.lang.Long.parseLong(Long.java:721)\n\tat java.base/java.lang.Long.parseLong(Long.java:836)\n\tat scala.collection.StringOps$.toLong$extension(StringOps.scala:928)\n\tat Problem$.roundedAvg(tmps_26qvdu.scala:18)\n\tat Problem$.main(tmps_26qvdu.scala:24)\n\tat Problem.main(tmps_26qvdu.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798216
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val n = math.max(math.min(m, n), n)\n        val m = math.max(math.min(m, n), n)\n        val sum = n until m\n        val avg = sum.sum / sum.length\n        val bin = math.round(avg).toBinaryString\n        val result = if (bin.length == 1) \"0b\" + bin else bin\n        Right(result)\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpua5kuc9f.scala:15:34 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mm\u001b[0m = math.max(math.min(m, n), n)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Recursive \u001b[33mvalue\u001b[0m \u001b[35mm\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpua5kuc9f.scala:15:37 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mm\u001b[0m = math.max(math.min(m, n), n)\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Recursive \u001b[33mvalue\u001b[0m \u001b[35mn\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpua5kuc9f.scala:15:41 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mm\u001b[0m = math.max(math.min(m, n), n)\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                         Recursive \u001b[33mvalue\u001b[0m \u001b[35mn\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpua5kuc9f.scala:14:37 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mn\u001b[0m = math.max(math.min(m, n), n)\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Recursive \u001b[33mvalue\u001b[0m \u001b[35mn\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpua5kuc9f.scala:14:41 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mn\u001b[0m = math.max(math.min(m, n), n)\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                         Recursive \u001b[33mvalue\u001b[0m \u001b[35mn\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0",
      "stdout": "",
      "timestamp": 1659798216
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val sum = n to m\n        val avg = sum.sum / sum.length\n        val binary = binary(avg)\n        val result = if (n == m) Right(binary) else Left(s\"$n to $m is $binary\")\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp0dk0offb.scala:16:21 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary(avg)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                     Recursive \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659798217
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val avg = n to m by -1\n        val binary = avg.map(x => Integer.toBinaryString(x)).mkString\n        val result = if (binary.length == 0) \"0b0\" else binary\n        Right(result)\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp56j7cnwy.scala:15:57 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = avg.map(\u001b[36mx\u001b[0m => Integer.toBinaryString(x)).mkString\n\u001b[31m\u001b[31m   |\u001b[0m                                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                    Found:    (x : Long)\n\u001b[31m   |\u001b[0m                                                    Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp56j7cnwy.scala:17:14 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        Right(result)\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              Found:    (result : String)\n\u001b[31m   |\u001b[0m              Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659798155
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val avg = n to m by -1\n        val sum = 0L\n        val binary = \"\"\n        for(i <- 0 until avg.length) {\n            val bin = math.pow(2,i)\n            val val = avg(i).toBinaryString\n            val len = val.length\n            val binLen = bin.length\n            val binVal = bin.charAt(len-1)\n            val binValLen = binVal.length\n            val binValVal = binVal.charAt(binValLen-1)\n            val binValValLen = binValVal.length\n            val binValValVal = binValVal.charAt(binValValLen-1)\n            val binValValValLen = binValValVal.length\n            val binValValValVal = binValValVal.charAt(binValValValLen-1)\n            val binValValValValLen = binValValValVal.length\n            val binValValValValVal = binValValValVal.charAt(binValValValValLen-1)\n            val binValValValValValLen = binValValValValVal.length\n            val binValValValValValVal = binValValValValVal.charAt(binValValValValValLen-1)\n            val binValValValValValValLen = binValValValValValVal.length\n            val binValValValValValValVal = binValValValValValVal.charAt(binValValValValValValLen-1)\n            val binValValValValValValValLen = binValValValValValValVal.length\n            val binValValValValValValValVal = binValValValValValValVal.charAt(binValValValValValValValLen-1)\n            val binValValValValValValValValLen = binValValValValValValValValVal.length\n            val binValValValValValValValValVal = binValValValValValValValVal.charAt(binValValValValValValValValLen-1)\n            val binValValValValValValValValLen = binValValValValValValValValVal.length\n            val binValValValValValValValValVal = binValValValValValValValValVal.charAt(binValValValValValValValValValLen-1)\n            val binValValValValValValValValValLen = binValValValValValValValValValValVal.length\n            val binValVal\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpxen4x1lk.scala:19:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[33mval\u001b[0m = avg(i).toBinaryString\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpxen4x1lk.scala:20:22 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mlen\u001b[0m = \u001b[33mval\u001b[0m.length\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      expression expected but \u001b[31mval\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpxen4x1lk.scala:43:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpxen4x1lk.scala:60:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m60 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpxen4x1lk.scala:21:29 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mbinLen\u001b[0m = bin.length\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         value length is not a member of Double\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpxen4x1lk.scala:22:29 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mbinVal\u001b[0m = bin.charAt(len-\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         value charAt is not a member of Double\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpxen4x1lk.scala:22:39 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mbinVal\u001b[0m = bin.charAt(len-\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue - is not a member of Null, but could be made available as an ",
      "stdout": "",
      "timestamp": 1659798225
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val avg = n + (m - 1) / 2\n        val binary = avg.toBinaryString\n        val result = binary.reverse.dropWhile(_ == '0').mkString\n        val right = (binary.reverse.takeWhile(_ == '1').length).max(0)\n        val left = binary.reverse.takeWhile(_ == '0').length\n        val final = if (right == 0) \"0b\" + binary.reverse.dropWhile(_ == '0').mkString else -1\n        Left(result)\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmp3khc_qbh.scala:19:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[33mfinal\u001b[0m = \u001b[33mif\u001b[0m (right == \u001b[31m0\u001b[0m) \u001b[31m\"0b\"\u001b[0m + binary.reverse.dropWhile(_ == \u001b[31m'0'\u001b[0m).mkString \u001b[33melse\u001b[0m -\u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659798218
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val avg = n / m\n        val bin = math.round(avg).toBinaryString\n        if (bin.length < 2) Right(bin)\n        else Left(s\"$bin is not a valid binary number\")\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmphtgquomg.scala:16:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mif\u001b[0m (bin.length < \u001b[31m2\u001b[0m) Right(bin)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    (bin : String)\n\u001b[31m   |\u001b[0m                                  Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659798221
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val n = n.toInt\n        val m = m.toInt\n        if (n > m) {\n            Left(-1)\n        } else {\n            val sum = n.toLong + m.toLong\n            val avg = sum / 2\n            val binary = avg.toBinaryString\n            Right(binary.length)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmptn77y75l.scala:14:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mn\u001b[0m = n.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                ^\u001b[0m\n\u001b[31m   |\u001b[0m                Recursive \u001b[33mvalue\u001b[0m \u001b[35mn\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmptn77y75l.scala:15:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mm\u001b[0m = m.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                ^\u001b[0m\n\u001b[31m   |\u001b[0m                Recursive \u001b[33mvalue\u001b[0m \u001b[35mm\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmptn77y75l.scala:17:17 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            Left(-\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^\u001b[0m\n\u001b[31m   |\u001b[0m                 Found:    (\u001b[31m-1\u001b[0m : Int)\n\u001b[31m   |\u001b[0m                 Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659798201
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val n = math.max(math.min(n, m), 1L)\n        val m = math.max(math.min(m, n), 1L)\n        val sum = n + m\n        val avg = sum / 2\n        val bin = math.pow(10, math.ceil(math.log10(avg)))\n        val result = math.round(avg * bin).toLong\n        val str = if (result < 0) \"-\" else \"\"\n        Right(s\"0b${str}${result}\")\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp2nv2g8ur.scala:14:34 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mn\u001b[0m = math.max(math.min(n, m), \u001b[31m1L\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Recursive \u001b[33mvalue\u001b[0m \u001b[35mn\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp2nv2g8ur.scala:15:34 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mm\u001b[0m = math.max(math.min(m, n), \u001b[31m1L\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Recursive \u001b[33mvalue\u001b[0m \u001b[35mm\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp2nv2g8ur.scala:15:37 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mm\u001b[0m = math.max(math.min(m, n), \u001b[31m1L\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Recursive \u001b[33mvalue\u001b[0m \u001b[35mn\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp2nv2g8ur.scala:21:14 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        Right(\u001b[31ms\"0b\u001b[0m${str}${result}\u001b[31m\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              Found:    String\n\u001b[31m   |\u001b[0m              Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659798221
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val sum = n to m by -1\n        val avg = sum.sum / sum.length\n        val bin = math.round(avg).toBinaryString\n        val result = if (bin == \"\") -1 else bin\n        Left(result)\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpha60wptq.scala:18:13 --------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        Left(result)\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m             Found:    (result : Matchable)\n\u001b[31m   |\u001b[0m             Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659798223
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val nToM = (n to m).toList\n        val nToM2 = nToM.filter(_ > 0)\n        val nToM3 = nToM2.filter(_ > 1)\n        val nToM4 = nToM3.filter(_ > 2)\n        val nToM5 = nToM4.filter(_ > 3)\n        val nToM6 = nToM5.filter(_ > 4)\n        val nToM7 = nToM6.filter(_ > 5)\n        val nToM8 = nToM7.filter(_ > 6)\n        val nToM9 = nToM8.filter(_ > 7)\n        val nToM10 = nToM9.filter(_ > 8)\n        val nToM11 = nToM10.filter(_ > 9)\n        val nToM12 = nToM11.filter(_ > 10)\n        val nToM13 = nToM12.filter(_ > 11)\n        val nToM14 = nToM13.filter(_ > 12)\n        val nToM15 = nToM14.filter(_ > 13)\n        val nToM16 = nToM15.filter(_ > 14)\n        val nToM17 = nToM16.filter(_ > 15)\n        val nToM18 = nToM17.filter(_ > 16)\n        val nToM19 = nToM18.filter(_ > 17)\n        val nToM20 = nToM19.filter(_ > 18)\n        val nToM21 = nToM20.filter(_ > 19)\n        val nToM22 = nToM21.filter(_ > 20)\n        val nToM23 = nToM22.filter(_ > 21)\n        val nToM24 = nToM23.filter(_ > 22)\n        val nToM25 = nToM24.filter(_ > 23)\n        val nToM26 = nToM25.filter(_ > 24)\n        val nToM27 = nToM26.filter(_ > 25)\n        val nToM28 = nToM27.filter(_ > 26)\n        val nToM29 = nToM28.filter(_ > 27)\n        val nToM30 = nToM29.filter(_ > 28)\n        val nToM31 = nToM30.filter(_ > 29)\n        val nToM32 = nToM31.filter(_ > 30)\n        val nToM33 = nToM32.filter(_ > 31)\n        val nToM34 = nToM33.filter(_ > \n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmp94itwmhd.scala:47:38 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m47 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnToM34\u001b[0m = nToM33.filter(_ > \n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                      expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp94itwmhd.scala:48:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m48 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Either[String, Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659798155
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val nBits = n.toBinaryString\n        val mBits = m.toBinaryString\n        val nBitsLen = nBits.length\n        val mBitsLen = mBits.length\n        val nBitsSum = sum(nBits.dropRight(mBitsLen))\n        val mBitsSum = sum(mBits.takeRight(nBitsLen))\n        val nBitsSumInt = nBitsSum.toInt\n        val mBitsSumInt = mBitsSum.toInt\n        val nBitsSumBin = Integer.toBinaryString(nBitsSumInt)\n        val mBitsSumBin = Integer.toBinaryString(mBitsSumInt)\n        val nBitsSumBinLen = nBitsSumBin.length\n        val mBitsSumBinLen = mBitsSumBin.length\n        val nBitsSumBinSum = sum(nBitsSumBin.dropRight(mBitsSumBinLen))\n        val mBitsSumBinSum = sum(mBitsSumBin.takeRight(nBitsSumBinLen))\n        val nBitsSumBinSumInt = nBitsSumBinSum.toInt\n        val mBitsSumBinSumInt = mBitsSumBinSum.toInt\n        val nBitsSumBinSumBin = Integer.toBinaryString(nBitsSumBinSumInt)\n        val mBitsSumBinSumBin = Integer.toBinaryString(mBitsSumBinSumInt)\n        val nBitsSumBinSumBinLen = nBitsSumBinSumBin.length\n        val mBitsSumBinSumBinLen = mBitsSumBinSumBin.length\n        val nBitsSumBinSumBinSum = sum(nBitsSumBinSumBin.dropRight(mBitsSumBinSumBinLen))\n        val mBitsSumBinSumBinSum = sum(mBitsSumBinSumBin.takeRight(nBitsSumBinSumBinLen))\n        val nBitsSumBinSumBinSumInt = nBitsSumBinSumBinSum.toInt\n        val mBitsSumBinSumBinSumInt = mBitsSumBinSumBinSum.toInt\n        val nBitsSumBinSumBinSumBin = Integer.toBinaryString(nBitsSumBinSumBinSumInt)\n        val mBitsSumBinSumBinSumBin = Integer.toBinaryString(mBitsSumBinSumBinSumInt\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpfjlp1zb8.scala:40:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpfjlp1zb8.scala:18:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnBitsSum\u001b[0m = sum(nBits.dropRight(mBitsLen))\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Not found: sum\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpfjlp1zb8.scala:19:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmBitsSum\u001b[0m = sum(mBits.takeRight(nBitsLen))\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Not found: sum\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpfjlp1zb8.scala:26:29 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnBitsSumBinSum\u001b[0m = sum(nBitsSumBin.dropRight(mBitsSumBinLen))\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                             Not found: sum\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpfjlp1zb8.scala:27:29 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmBitsSumBinSum\u001b[0m = sum(mBitsSumBin.takeRight(nBitsSumBinLen))\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                             Not found: sum\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpfjlp1zb8.scala:34:35 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnBitsSumBinSumBinSum\u001b[0m = sum(nBitsSumBinSumBin.dropRight(mBitsSumBinSumBinLen))\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^^^\u001b[0m\n\u001b[31m   |\u001b[0m               ",
      "stdout": "",
      "timestamp": 1659798223
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val avg = ((n + m) / 2).round\n        val binary = avg.toBinaryString\n        if (binary.length < 2) Right(binary.padToLength(2, \"0\"))\n        else Left(s\"$binary\")\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpx5kvplpj.scala:16:44 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mif\u001b[0m (binary.length < \u001b[31m2\u001b[0m) Right(binary.padToLength(\u001b[31m2\u001b[0m, \u001b[31m\"0\"\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                             value padToLength is not a member of String\n1 error found\n",
      "stdout": "",
      "timestamp": 1659798222
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val avg = ((n + m) / 2).round\n        val binary = avg.toBinaryString\n        val result = if (n == m) Right(binary) else Left(s\"$n through $m average is $binary\")\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp2cmlqk44.scala:17:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        result\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    \u001b[1m\u001b[31m(\u001b[0m\u001b[1m\u001b[31mresult\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31m:\u001b[0m\u001b[1m\u001b[31m \u001b[0mEither[String, \u001b[1m\u001b[31mString\u001b[0m]\u001b[1m\u001b[31m)\u001b[0m\n\u001b[31m   |\u001b[0m        Required: Either[String, \u001b[1m\u001b[32mLong\u001b[0m]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659798224
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val sum = n to m by -1\n        val avg = sum.sum / sum.size\n        val binary = avg.toBinaryString\n        val result = if (binary.length == 1) \"0b\" + binary else binary\n        Right(result)\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp6vbjvx5k.scala:18:14 --------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        Right(result)\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              Found:    (result : String)\n\u001b[31m   |\u001b[0m              Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659798163
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val sum = n to m\n        val avg = sum.sum / sum.size\n        val binary = math.round(avg).toBinaryString\n        val result = if (binary == \"\") -1 else binary\n        val right = binary.reverse\n        val left = binary.reverse.dropRight(1)\n        val result = if (right == \"\") -1 else right\n        val result = if (left == \"\") -1 else left\n        val result = if (result == \"\") -1 else result\n        val result = if (result == \"\") -1 else result\n        val result = if (result == \"\") -1 else result\n        val result = if (result == \"\") -1 else result\n        val result = if (result == \"\") -1 else result\n        val result = if (result == \"\") -1 else result\n        val result = if (result == \"\") -1 else result\n        val result = if (result == \"\") -1 else result\n        val result = if (result == \"\") -1 else result\n        val result = if (result == \"\") -1 else result\n        val result = if (result == \"\") -1 else result\n        val result = if (result == \"\") -1 else result\n        val result = if (result == \"\") -1 else result\n        val result = if (result == \"\") -1 else result\n        val result = if (result == \"\") -1 else result\n        val result = if (result == \"\") -1 else result\n        val result = if (result == \"\") -1 else result\n        val result = if (result == \"\") -1 else result\n        val result = if (result == \"\") -1 else result\n        val result = if (result == \"\") -1 else result\n        val result = if (result == \"\") -1 else result\n        val result = if (result == \"\") -1 else result\n        val result = if (result == \"\") -1 else result\n        val result = if (result == \"\") -1 else result\n        val result = if (result == \"\") -1 else result\n        val result = if (result == \"\") -1 else result\n        val result = if (result == \"\") -1 else result\n        val result = if (result == \"\") -1 else result\n        val result = if (result == \"\") -1 else result\n        val result = if (result == \"\") -1 else result\n        val result = if (result == \"\") -1 else result\n        val result = if (result == \"\") -1 else result\n        val result = if (result == \"\") -1 else result\n        val result = if (result == \"\") -1 else result\n        val result = if (result == \"\") -1 else result\n        val result = if (result == \"\") -1 else result\n        val result = if (result == \"\") -1 else result\n        val result = if (result == \"\") -1 else result\n        val result = if (result == \"\") -1 else result\n\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmptc35mfbk.scala:20:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mif\u001b[0m (right == \u001b[31m\"\"\u001b[0m) -\u001b[31m1\u001b[0m \u001b[33melse\u001b[0m right\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mresult is already defined as \u001b[33mvalue\u001b[0m \u001b[35mresult\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmptc35mfbk.scala:21:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mif\u001b[0m (left == \u001b[31m\"\"\u001b[0m) -\u001b[31m1\u001b[0m \u001b[33melse\u001b[0m left\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mresult is already defined as \u001b[33mvalue\u001b[0m \u001b[35mresult\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmptc35mfbk.scala:22:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mif\u001b[0m (result == \u001b[31m\"\"\u001b[0m) -\u001b[31m1\u001b[0m \u001b[33melse\u001b[0m result\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mresult is already defined as \u001b[33mvalue\u001b[0m \u001b[35mresult\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmptc35mfbk.scala:23:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mif\u001b[0m (result == \u001b[31m\"\"\u001b[0m) -\u001b[31m1\u001b[0m \u001b[33melse\u001b[0m result\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mresult is already defined as \u001b[33mvalue\u001b[0m \u001b[35mresult\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmptc35mfbk.scala:24:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m",
      "stdout": "",
      "timestamp": 1659798224
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val n = math.abs(n)\n        val m = math.abs(m)\n        val sum = n + m\n        val avg = sum / 2\n        val bin = math.pow(10, math.ceil(math.log10(avg)))\n        val rounded = math.round(avg * bin) / bin\n        val result = if (rounded == avg) Right(rounded) else Left(s\"$rounded is not an exact integer in binary\")\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp2db9ag0k.scala:14:25 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mn\u001b[0m = math.abs(n)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                         Recursive \u001b[33mvalue\u001b[0m \u001b[35mn\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp2db9ag0k.scala:15:25 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mm\u001b[0m = math.abs(m)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                         Recursive \u001b[33mvalue\u001b[0m \u001b[35mm\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659798220
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val n = math.max(math.min(n, m), -1)\n        val m = math.max(math.min(m, n), -1)\n        val sum = (n to m).map(i => math.pow(2, i).toLong).sum\n        val avg = math.round(sum / 2).toLong\n        val bin = Integer.toBinaryString(avg)\n        val result = if (n == m) Right(bin) else Left(s\"$n to $m is $bin\")\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpgckbjo4e.scala:14:34 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mn\u001b[0m = math.max(math.min(n, m), -\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Recursive \u001b[33mvalue\u001b[0m \u001b[35mn\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpgckbjo4e.scala:15:34 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mm\u001b[0m = math.max(math.min(m, n), -\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Recursive \u001b[33mvalue\u001b[0m \u001b[35mm\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpgckbjo4e.scala:15:37 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mm\u001b[0m = math.max(math.min(m, n), -\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Recursive \u001b[33mvalue\u001b[0m \u001b[35mn\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpgckbjo4e.scala:20:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        result\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    \u001b[1m\u001b[31m(\u001b[0m\u001b[1m\u001b[31mresult\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31m:\u001b[0m\u001b[1m\u001b[31m \u001b[0mEither[String, \u001b[1m\u001b[31mString\u001b[0m]\u001b[1m\u001b[31m)\u001b[0m\n\u001b[31m   |\u001b[0m        Required: Either[String, \u001b[1m\u001b[32mLong\u001b[0m]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659798224
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val sum = (n to m).foldLeft(0L){ (sum, num) =>\n            val result = sum + num\n            val rounded = math.round(result * 2) / 2.0\n            val binary = Integer.toBinaryString(rounded)\n            val result = if (rounded == 0) \"0b\" + binary else binary\n            Right(result)\n        }\n        val avg = sum.right.getOrElse(\"0b0\")\n        val result = if (n == m) Right(avg) else Left(\"0b\" + avg)\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpf7y9txe_.scala:18:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mif\u001b[0m (rounded == \u001b[31m0\u001b[0m) \u001b[31m\"0b\"\u001b[0m + binary \u001b[33melse\u001b[0m binary\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mresult is already defined as \u001b[33mvalue\u001b[0m \u001b[35mresult\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpf7y9txe_.scala:17:48 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = Integer.toBinaryString(rounded)\n\u001b[31m\u001b[31m   |\u001b[0m                                                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                            Found:    (rounded : Double)\n\u001b[31m   |\u001b[0m                                            Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpf7y9txe_.scala:19:17 --------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m            Right(result)\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Found:    Right[Nothing, (result : Long)]\n\u001b[31m   |\u001b[0m            Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpf7y9txe_.scala:21:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mavg\u001b[0m = sum.right.getOrElse(\u001b[31m\"0b0\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value right is not a member of Long\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659798226
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val nMinusM = (n - m).toInt\n        if(nMinusM < 0) Left(s\"$n is greater than $m\")\n        else Right(nMinusM.toBinary)\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpvmuom407.scala:16:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33melse\u001b[0m Right(nMinusM.toBinary)\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   value toBinary is not a member of Int\n1 error found\n",
      "stdout": "",
      "timestamp": 1659798225
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val ns = List(n, m).sorted\n        val nm = ns zip ns drop 1 map (_ / 2)\n        val nn = ns zip nm map (_ / 2)\n        val nn = nn zip nn map (_ / 2)\n        val nn = nn zip nn map (_ / 2)\n        val nn = nn zip nn map (_ / 2)\n        val nn = nn zip nn map (_ / 2)\n        val nn = nn zip nn map (_ / 2)\n        val nn = nn zip nn map (_ / 2)\n        val nn = nn zip nn map (_ / 2)\n        val nn = nn zip nn map (_ / 2)\n        val nn = nn zip nn map (_ / 2)\n        val nn = nn zip nn map (_ / 2)\n        val nn = nn zip nn map (_ / 2)\n        val nn = nn zip nn map (_ / 2)\n        val nn = nn zip nn map (_ / 2)\n        val nn = nn zip nn map (_ / 2)\n        val nn = nn zip nn map (_ / 2)\n        val nn = nn zip nn map (_ / 2)\n        val nn = nn zip nn map (_ / 2)\n        val nn = nn zip nn map (_ / 2)\n        val nn = nn zip nn map (_ / 2)\n        val nn = nn zip nn map (_ / 2)\n        val nn = nn zip nn map (_ / 2)\n        val nn = nn zip nn map (_ / 2)\n        val nn = nn zip nn map (_ / 2)\n        val nn = nn zip nn map (_ / 2)\n        val nn = nn zip nn map (_ / 2)\n        val nn = nn zip nn map (_ / 2)\n        val nn = nn zip nn map (_ / 2)\n        val nn = nn zip nn map (_ / 2)\n        val nn = nn zip nn map (_ / 2)\n        val nn = nn zip nn map (_ / 2)\n        val nn = nn zip nn map (_ / 2)\n        val nn = nn zip nn map (_ / 2)\n        val nn = nn zip nn map (_ / 2)\n        val nn = nn zip nn map (_ / 2)\n        val nn = nn zip nn map (_ / 2)\n        val nn = nn zip nn map (_ / 2)\n        val \n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpbhqvkarp.scala:53:11 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m53 |\u001b[0m        \u001b[33mval\u001b[0m \n\u001b[31m\u001b[31m   |\u001b[0m           ^\u001b[0m\n\u001b[31m   |\u001b[0m           pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbhqvkarp.scala:17:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnn\u001b[0m = nn zip nn map (_ / \u001b[31m2\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnn is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnn\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbhqvkarp.scala:18:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnn\u001b[0m = nn zip nn map (_ / \u001b[31m2\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnn is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnn\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbhqvkarp.scala:19:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnn\u001b[0m = nn zip nn map (_ / \u001b[31m2\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnn is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnn\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbhqvkarp.scala:20:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnn\u001b[0m = nn zip nn map (_ / \u001b[31m2\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnn is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnn\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbhqvkarp.scala:21:12",
      "stdout": "",
      "timestamp": 1659798227
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val avg = n / (m - n + 1) // average of n through m\n        val bin = math.ceil(avg).toBinaryString\n        val result = if (bin == bin.dropRight(1)) bin else bin + bin.dropRight(1)\n        Right(result)\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpppursguk.scala:15:33 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbin\u001b[0m = math.ceil(avg).toBinaryString\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value toBinaryString is not a member of Double\n1 error found\n",
      "stdout": "",
      "timestamp": 1659798225
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val avg = ((n + m) / 2).round\n        val binary = avg.toBinaryString\n        if (binary.length < m) Left(s\"$n to $m is $binary\")\n        else Right(binary)\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpca349nh6.scala:17:19 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33melse\u001b[0m Right(binary)\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Found:    (binary : String)\n\u001b[31m   |\u001b[0m                   Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659798226
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val avg = ((n + m) / 2).round\n        val bin = Integer.toBinaryString(avg)\n        if (bin.length < m) Left(s\"$bin is too short\")\n        else if (bin.length > m) Right(-1)\n        else Right(bin)\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpqg7xv12b.scala:15:41 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbin\u001b[0m = Integer.toBinaryString(avg)\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                         Found:    (avg : Long)\n\u001b[31m   |\u001b[0m                                         Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpqg7xv12b.scala:18:19 --------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33melse\u001b[0m Right(bin)\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Found:    (bin : String)\n\u001b[31m   |\u001b[0m                   Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659798226
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val sum = 0L\n        val count = 0L\n        for(i <- n until m){\n            sum += i\n            count += 1\n        }\n        if(count > 0){\n            val avg = sum / count\n            val binary = Integer.toBinaryString(avg)\n            val result = Right(binary.length + binary.reverse)\n        } else {\n            val result = Left(-1)\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpnzc31mh8.scala:17:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            sum += i\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of Long - did you mean sum.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpnzc31mh8.scala:18:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m            count += \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of Long - did you mean count.!=?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpnzc31mh8.scala:22:48 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = Integer.toBinaryString(avg)\n\u001b[31m\u001b[31m   |\u001b[0m                                                ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                Found:    (avg : Long)\n\u001b[31m   |\u001b[0m                                                Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpnzc31mh8.scala:27:15 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mreturn\u001b[0m result\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m               Not found: result\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659798227
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val avg = n to m by -1\n        val binary = avg.map(x => x.toBinaryString).mkString\n        val result = if (n == m) Right(binary) else Left(s\"$n to $m is $binary\")\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpgjpvuesx.scala:17:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        result\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    \u001b[1m\u001b[31m(\u001b[0m\u001b[1m\u001b[31mresult\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31m:\u001b[0m\u001b[1m\u001b[31m \u001b[0mEither[String, \u001b[1m\u001b[31mString\u001b[0m]\u001b[1m\u001b[31m)\u001b[0m\n\u001b[31m   |\u001b[0m        Required: Either[String, \u001b[1m\u001b[32mLong\u001b[0m]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659798213
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val sum = n to m\n        val avg = sum.sum / sum.size\n        val bin = math.ceil(avg).toBinaryString\n        val result = if (bin.size == 1) \"0b\" + bin else bin\n        Right(result)\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp3ndj5qaa.scala:16:33 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbin\u001b[0m = math.ceil(avg).toBinaryString\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value toBinaryString is not a member of Double\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp3ndj5qaa.scala:18:14 --------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        Right(result)\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              Found:    (result : String)\n\u001b[31m   |\u001b[0m              Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659798227
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val avg = n to m by -1\n        val sum = 0\n        val binary = \"\"\n        for(i <- 0 until avg.length) {\n            val bin = math.pow(2,i)\n            val val = avg(i).toBinaryString\n            val binVal = bin.toInt\n            val binVal2 = binVal + binVal\n            val binVal3 = binVal2 + binVal2\n            val binVal4 = binVal3 + binVal3\n            val binVal5 = binVal4 + binVal4\n            val binVal6 = binVal5 + binVal5\n            val binVal7 = binVal6 + binVal6\n            val binVal8 = binVal7 + binVal7\n            val binVal9 = binVal8 + binVal8\n            val binVal10 = binVal9 + binVal9\n            val binVal11 = binVal10 + binVal10\n            val binVal12 = binVal11 + binVal11\n            val binVal13 = binVal12 + binVal12\n            val binVal14 = binVal13 + binVal13\n            val binVal15 = binVal14 + binVal14\n            val binVal16 = binVal15 + binVal15\n            val binVal17 = binVal16 + binVal16\n            val binVal18 = binVal17 + binVal17\n            val binVal19 = binVal18 + binVal18\n            val binVal20 = binVal19 + binVal19\n            val binVal21 = binVal20 + binVal20\n            val binVal22 = binVal21 + binVal21\n            val binVal23 = binVal22 + binVal22\n            val binVal24 = binVal23 + binVal23\n            val binVal25 = binVal24 + binVal24\n            val binVal26 = binVal25 + binVal25\n            val binVal27 = binVal26 + binVal26\n            val binVal28 = binVal27 + binVal27\n            val binVal29 = binVal28 + binVal28\n            val binVal30 = binVal29 + binVal29\n            val binVal31 = binVal30 + binVal30\n            val binVal32 = binVal31 + binVal31\n            val binVal33 = binVal32 + binVal32\n            val binVal34 = binVal33 + binVal33\n            val binVal35 = binVal\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpxtjbihhq.scala:19:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[33mval\u001b[0m = avg(i).toBinaryString\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpxtjbihhq.scala:72:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m72 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpxtjbihhq.scala:71:1 ---------------------\u001b[0m\u001b[0m\n\u001b[31m71 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m ^\u001b[0m\n\u001b[31m   |\u001b[0m Found:    Unit\n\u001b[31m   |\u001b[0m Required: Either[String, Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[33m\u001b[33m-- Warning: /tmp/tmpxtjbihhq.scala:56:4 ----------------------------------------\u001b[0m\u001b[0m\n\u001b[33m56 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[33m\u001b[33m   |\u001b[0m    ^\u001b[0m\n\u001b[33m   |\u001b[0m    Line is indented too far to the left, or a `}` is missing\n1 warning found\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659798227
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val sum = n to m by -1\n        val avg = sum.sum / sum.size\n        val binary = avg + binary(avg)\n        binary.toString.toLong\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp7xyn0voe.scala:16:27 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = avg + binary(avg)\n\u001b[31m\u001b[31m   |\u001b[0m                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                           Recursive \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659798225
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val sum = n to m\n        val avg = sum.sum / sum.size\n        val bin = math.ceil(avg).toBinaryString\n        val right = bin.dropRight(1)\n        val left = bin.dropLeft(1)\n        val result = if (right == left) Right(bin) else Left(s\"$left $right\")\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpvy1q19ii.scala:16:33 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbin\u001b[0m = math.ceil(avg).toBinaryString\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value toBinaryString is not a member of Double\n1 error found\n",
      "stdout": "",
      "timestamp": 1659798227
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val sum = n to m\n        val avg = sum.sum / sum.size\n        val binary = binary(avg)\n        val result = if (n == m) -1 else binary\n        Left(result)\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpghaytjnz.scala:16:21 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary(avg)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                     Recursive \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpghaytjnz.scala:18:13 --------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        Left(result)\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m             Found:    (result : Int)\n\u001b[31m   |\u001b[0m             Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659798227
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val n = math.abs(n)\n        val m = math.abs(m)\n        val sum = (n to m).sum\n        val avg = sum / m\n        val bin = math.round(avg).toBinaryString\n        if (bin.length < m) Left(bin)\n        else Right(bin)\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp3pk88p69.scala:14:25 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mn\u001b[0m = math.abs(n)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                         Recursive \u001b[33mvalue\u001b[0m \u001b[35mn\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp3pk88p69.scala:15:25 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mm\u001b[0m = math.abs(m)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                         Recursive \u001b[33mvalue\u001b[0m \u001b[35mm\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659798226
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val n = n.toInt\n        val m = m.toInt\n        if (n > m) {\n            Left(-1)\n        } else {\n            val sum = n.toLong + m.toLong\n            val avg = sum / 2\n            val binary = binary(avg)\n            Right(binary.toLong)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp7mvbgt76.scala:14:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mn\u001b[0m = n.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                ^\u001b[0m\n\u001b[31m   |\u001b[0m                Recursive \u001b[33mvalue\u001b[0m \u001b[35mn\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp7mvbgt76.scala:15:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mm\u001b[0m = m.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                ^\u001b[0m\n\u001b[31m   |\u001b[0m                Recursive \u001b[33mvalue\u001b[0m \u001b[35mm\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp7mvbgt76.scala:17:17 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            Left(-\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^\u001b[0m\n\u001b[31m   |\u001b[0m                 Found:    (\u001b[31m-1\u001b[0m : Int)\n\u001b[31m   |\u001b[0m                 Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp7mvbgt76.scala:21:25 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary(avg)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                         Recursive \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659798228
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given two positive integers n and m, and your task is to compute the\n    // average of the integers from n through m (including n and m). \n    // Round the answer to the nearest integer and convert that to binary.\n    // If n is greater than m, return -1.\n    // Example:\n    // rounded_avg(1, 5) => \"0b11\"\n    // rounded_avg(7, 5) => -1\n    // rounded_avg(10, 20) => \"0b1111\"\n    // rounded_avg(20, 33) => \"0b11010\"\n    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {\n        val avg = ((n + m) / 2).round\n        val binary = avg.toBinaryString\n        if (binary.length < m) Left(s\"$binary is too short\")\n        else if (binary.length > m) Right(-1)\n        else Right(binary)\n    }\n    def main(args: Array[String]) = {\n    assert(roundedAvg((1l), (5l)).equals(\"0b11\"));\n    assert(roundedAvg((7l), (13l)).equals(\"0b1010\"));\n    assert(roundedAvg((964l), (977l)).equals(\"0b1111001010\"));\n    assert(roundedAvg((996l), (997l)).equals(\"0b1111100100\"));\n    assert(roundedAvg((560l), (851l)).equals(\"0b1011000010\"));\n    assert(roundedAvg((185l), (546l)).equals(\"0b101101110\"));\n    assert(roundedAvg((362l), (496l)).equals(\"0b110101101\"));\n    assert(roundedAvg((350l), (902l)).equals(\"0b1001110010\"));\n    assert(roundedAvg((197l), (233l)).equals(\"0b11010111\"));\n    assert(roundedAvg((7l), (5l)).equals(-1l));\n    assert(roundedAvg((5l), (1l)).equals(-1l));\n    assert(roundedAvg((5l), (5l)).equals(\"0b101\"));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp1ac59s7l.scala:18:19 --------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33melse\u001b[0m Right(binary)\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Found:    (binary : String)\n\u001b[31m   |\u001b[0m                   Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659798190
    }
  ]
}