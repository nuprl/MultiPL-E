language: rkt
name: HumanEval_118_get_closest_vowel
results:
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (cons\
    \ (first word) (get_closest_vowel (rest word)))]))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 1
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (define (vowel-check word)\n    (cond\n  \
    \    [(empty? word) \"\"]\n      [(char-equal? (char-after (char-before (char-after\
    \ word) 'a) 'a) 'a) 'a]\n      [(char-equal? (char-after (char-before (char-after\
    \ word) 'a) 'a) 'e) 'e]\n      [(char-equal? (char-after (char-before (char-after\
    \ word) 'a) 'a) 'i) 'i]\n      [(char-equal? (char-after (char-before (char-after\
    \ word) 'a) 'a) 'o) 'o]\n      [(char-equal? (char-after (char-before (char-after\
    \ word) 'a) 'a) 'u) 'u]\n      [(char-equal? (char-after (char-before (char-after\
    \ word) 'a) 'a) 'A) 'A]\n      [(char-equal? (char-after (char-before (char-after\
    \ word) 'a) 'a) 'E) 'E]\n      [(char-equal? (char-after (char-before (char-after\
    \ word) 'a) 'a) 'I) 'I]\n      [(char-equal? (char-after (char-before (char-after\
    \ word) 'a) 'a) 'O) 'O]\n      [(char-equal? (char-after (char-before (char-after\
    \ word) 'a) 'a) 'U) 'U]\n      [(char-equal? (char-after (char-before (char-after\
    \ word) 'a) 'a) 'Y) 'Y]\n      [(char-equal? (char-after (char-before (char-after\
    \ word) 'a) 'a) 'Y) 'Y]\n      [(char-equal? (char-after (char-before (char-after\
    \ word) 'a) 'a) 'a) 'a]\n      [(char-equal? (char-after (char-before (char-after\
    \ word) 'a) 'a) 'a) 'a]\n      [(char-equal? (char-after (char-before (char-after\
    \ word) 'a) 'a) 'a) 'a]\n      [(char-equal? (char-after (char-before (\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n\
    \    (check-equal? (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate\
    \ \"full\") \"u\")\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal?\
    \ (candidate \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n  \
    \  (check-equal? (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\"\
    ) \"o\")\n    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate\
    \ \"ba\") \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal?\
    \ (candidate \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n\
    \    (check-equal? (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: SyntaxError
  stderr: "/tmp/tmpxb1r6t1r.rkt:28:45: read-syntax: expected a `)` to close `(`\n\
    \  possible cause: indentation suggests a missing `)` before line 29\n  context...:\n\
    \   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /work/arjunguha-research-group/software/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (get_closest_vowel\
    \ (rest word))]\n  )\n)\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\"\
    ) \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:26:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:34:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:35:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:36:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond [(empty? word) \"\"]\n        [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n        [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n        [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n        [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \        [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n        [else\
    \ (get_closest_vowel (rest word))]))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"\
    yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal?\
    \ (candidate \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n \
    \   (check-equal? (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\"\
    ) \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate\
    \ \"ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal?\
    \ (candidate \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n\
    \    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"\
    Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpvcx8pfax.rkt:23:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpvcx8pfax.rkt:24:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpvcx8pfax.rkt:25:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpvcx8pfax.rkt:26:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpvcx8pfax.rkt:27:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpvcx8pfax.rkt:28:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpvcx8pfax.rkt:29:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpvcx8pfax.rkt:30:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpvcx8pfax.rkt:31:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpvcx8pfax.rkt:32:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpvcx8pfax.rkt:33:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (get_closest_vowel\
    \ (rest word))]\n  )\n)\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\"\
    ) \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:26:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:34:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:35:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:36:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (cons\
    \ (first word) (get_closest_vowel (rest word)))]))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (get_closest_vowel\
    \ (rest word))]\n  )\n)\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\"\
    ) \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:26:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:34:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:35:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:36:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (cons\
    \ (first word) (get_closest_vowel (rest word)))]))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (get_closest_vowel\
    \ (rest word))]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\") \"\
    u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (get_closest_vowel\
    \ (rest word))]\n  )\n)\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\"\
    ) \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:26:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:34:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:35:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:36:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 1
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond [(empty? word) \"\"]\n        [(vowel?\
    \ (car word)) (car word)]\n        [else (get_closest_vowel (cdr word))]))\n\n\
    (require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n\
    \    (check-equal? (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate\
    \ \"full\") \"u\")\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal?\
    \ (candidate \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n  \
    \  (check-equal? (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\"\
    ) \"o\")\n    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate\
    \ \"ba\") \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal?\
    \ (candidate \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n\
    \    (check-equal? (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "/tmp/tmp3zg2c54z.rkt:11:10: vowel?: unbound identifier\n  in: vowel?\n\
    \  location...:\n   /tmp/tmp3zg2c54z.rkt:11:10\n"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (cons\
    \ (first word) (get_closest_vowel (rest word)))]))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (define (helper word vowel)\n    (cond\n \
    \     [(empty? word) \"\"]\n      [(equal? (first word) vowel) (helper (rest word)\
    \ vowel)]\n      [else (helper (rest word) (cons (first word) vowel))]))\n  (helper\
    \ (reverse word) 'a))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n \
    \ (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\"\
    ) \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp8k29iw8l.rkt:22:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"yogurt\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp8k29iw8l.rkt:23:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"full\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp8k29iw8l.rkt:24:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"easy\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp8k29iw8l.rkt:25:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"eAsy\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp8k29iw8l.rkt:26:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"ali\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp8k29iw8l.rkt:27:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"bad\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp8k29iw8l.rkt:28:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"most\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp8k29iw8l.rkt:29:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"ab\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp8k29iw8l.rkt:30:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"ba\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp8k29iw8l.rkt:31:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"quick\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp8k29iw8l.rkt:32:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"anime\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp8k29iw8l.rkt:33:4\n\
    \nreverse: contract violation\n  expected: list?"
  stdout: ''
  timestamp: 1660040255
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond [(empty? word) \"\"]\n        [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n        [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n        [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n        [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \        [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n        [else\
    \ (get_closest_vowel (rest word))]))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"\
    yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal?\
    \ (candidate \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n \
    \   (check-equal? (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\"\
    ) \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate\
    \ \"ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal?\
    \ (candidate \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n\
    \    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"\
    Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpvcx8pfax.rkt:23:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpvcx8pfax.rkt:24:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpvcx8pfax.rkt:25:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpvcx8pfax.rkt:26:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpvcx8pfax.rkt:27:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpvcx8pfax.rkt:28:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpvcx8pfax.rkt:29:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpvcx8pfax.rkt:30:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpvcx8pfax.rkt:31:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpvcx8pfax.rkt:32:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpvcx8pfax.rkt:33:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (get_closest_vowel\
    \ (rest word))]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\") \"\
    u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (get_closest_vowel\
    \ (rest word))]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\") \"\
    u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 1
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (define (vowel-check vowel)\n    (cond\n \
    \     [(string=? (vowel-char vowel) 'a) (vowel-check 'b)]\n      [(string=? (vowel-char\
    \ vowel) 'e) (vowel-check 'f)]\n      [(string=? (vowel-char vowel) 'i) (vowel-check\
    \ 'g)]\n      [(string=? (vowel-char vowel) 'o) (vowel-check 'h)]\n      [(string=?\
    \ (vowel-char vowel) 'u) (vowel-check 'j)]\n      [(string=? (vowel-char vowel)\
    \ 'y) (vowel-check 'k)]\n      [(string=? (vowel-char vowel) 'A) (vowel-check\
    \ 'B)]\n      [(string=? (vowel-char vowel) 'E) (vowel-check 'F)]\n      [(string=?\
    \ (vowel-char vowel) 'I) (vowel-check 'G)]\n      [(string=? (vowel-char vowel)\
    \ 'O) (vowel-check 'H)]\n      [(string=? (vowel-char vowel) 'U) (vowel-check\
    \ 'J)]\n      [(string=? (vowel-char vowel) 'Y) (vowel-check 'K)]\n      [else\
    \ (vowel-check 'L)]\n    )\n  )\n  (define (vowel-char vowel)\n    (string->char\
    \ (string->string vowel)))\n  (define (vowel-check vowel)\n    (cond\n      [(string=?\
    \ (vowel-char vowel) 'a) (vowel-check 'b)]\n      [(string=? (vowel-char vowel)\
    \ 'e) (vowel-check 'f)]\n      [(string=? (vowel-char vowel) 'i) (vowel-check\
    \ 'g)]\n      [(string=? (vowel-char vowel) 'o) (vowel-check 'h)]\n      [(string=?\
    \ (vowel-char vowel) 'u) (vowel-check 'j)]\n      [(string=? (vowel-char vowel)\
    \ 'y) (vowel-check 'k)]\n      [(string=? (vowel-char vowel) 'A) (vowel-check\
    \ 'B)]\n      [(string=? (vowel-char vowel) 'E) (vowel-check 'F)]\n      [(string=?\
    \ (vowel-char vowel) 'I) (vowel-check 'G)]\n      [(string=? (vowel-char vowel)\
    \ 'O) (vowel-check 'H)]\n      [(string=? (vowel-char vowel) 'U) (vowel\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n\
    \    (check-equal? (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate\
    \ \"full\") \"u\")\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal?\
    \ (candidate \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n  \
    \  (check-equal? (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\"\
    ) \"o\")\n    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate\
    \ \"ba\") \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal?\
    \ (candidate \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n\
    \    (check-equal? (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: SyntaxError
  stderr: "/tmp/tmpe6asjlh8.rkt:41:40: read-syntax: expected a `)` to close `(`\n\
    \  possible cause: indentation suggests a missing `)` before line 42\n  context...:\n\
    \   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /work/arjunguha-research-group/software/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (get_closest_vowel\
    \ (rest word))]\n  )\n)\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\"\
    ) \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:26:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:34:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:35:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:36:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (cons\
    \ (first word) (get_closest_vowel (rest word)))]))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (cons\
    \ (first word) (get_closest_vowel (rest word)))]))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (define (helper word vowel)\n    (cond\n \
    \     [(empty? word) \"\"]\n      [(equal? vowel (first word)) (second word)]\n\
    \      [(equal? (first word) vowel) (second word)]\n      [else (helper (rest\
    \ word) (first vowel))]))\n  (helper (reverse word) 'a))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpyzuyygo5.rkt:23:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"yogurt\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpyzuyygo5.rkt:24:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"full\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpyzuyygo5.rkt:25:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"easy\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpyzuyygo5.rkt:26:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"eAsy\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpyzuyygo5.rkt:27:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"ali\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpyzuyygo5.rkt:28:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"bad\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpyzuyygo5.rkt:29:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"most\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpyzuyygo5.rkt:30:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"ab\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpyzuyygo5.rkt:31:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"ba\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpyzuyygo5.rkt:32:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"quick\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpyzuyygo5.rkt:33:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"anime\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpyzuyygo5.rkt:34:4\n\
    \nreverse: contract violation\n  expected: list?"
  stdout: ''
  timestamp: 1660040255
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (cons\
    \ (first word) (get_closest_vowel (rest word)))]))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (get_closest_vowel\
    \ (rest word))]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\") \"\
    u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond [(empty? word) \"\"]\n        [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n        [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n        [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n        [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \        [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n        [else\
    \ (cons (first word) (get_closest_vowel (rest word)))]))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmph8j7mhux.rkt:23:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmph8j7mhux.rkt:24:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmph8j7mhux.rkt:25:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmph8j7mhux.rkt:26:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmph8j7mhux.rkt:27:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmph8j7mhux.rkt:28:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmph8j7mhux.rkt:29:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmph8j7mhux.rkt:30:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmph8j7mhux.rkt:31:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmph8j7mhux.rkt:32:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmph8j7mhux.rkt:33:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (get_closest_vowel\
    \ (rest word))]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\") \"\
    u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (cons\
    \ (first word) (get_closest_vowel (rest word)))]))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (cons\
    \ (first word) (get_closest_vowel (rest word)))]))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (cons\
    \ (first word) (get_closest_vowel (rest word)))]))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (cons\
    \ (first word) (get_closest_vowel (rest word)))]))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 1
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (define (vowel-test c)\n    (cond\n      [(char=?\
    \ (char-code c) 97) (char=? (char-code c) 65)]\n      [(char=? (char-code c) 65)\
    \ (char=? (char-code c) 90)]\n      [(char=? (char-code c) 48) (char=? (char-code\
    \ c) 57)]\n      [else #f]))\n  (define (vowel-test c)\n    (cond\n      [(char=?\
    \ (char-code c) 97) (char=? (char-code c) 65)]\n      [(char=? (char-code c) 65)\
    \ (char=? (char-code c) 90)]\n      [(char=? (char-code c) 48) (char=? (char-code\
    \ c) 57)]\n      [else #f]))\n  (define (vowel-test c)\n    (cond\n      [(char=?\
    \ (char-code c) 97) (char=? (char-code c) 65)]\n      [(char=? (char-code c) 65)\
    \ (char=? (char-code c) 90)]\n      [(char=? (char-code c) 48) (char=? (char-code\
    \ c) 57)]\n      [else #f]))\n  (define (vowel-test c)\n    (cond\n      [(char=?\
    \ (char-code c) 97) (char=? (char-code c) 65)]\n      [(char=? (char-code c) 65)\
    \ (char=? (char-code c) 90)]\n      [(char=? (char-code c) 48) (char=? (char-code\
    \ c) 57)]\n      [else #f]))\n  (define (vowel-test c)\n    (cond\n      [(char=?\
    \ (char-code c) 97) (char=? (char-code c) 65)]\n      [(char=? (char-code c) 65)\
    \ (char=? (char-code c) 90)]\n      [(char=? (char-code c) 48) (char=? (char-code\
    \ c) 57)]\n      [else #f]))\n  (define (vowel-test c)\n    (cond\n      [(char=?\
    \ (char-code c) 97) (char=? (char-code c) 65)]\n      [(char=? (char-code c) 65)\
    \ (char=? (char-code c) 90)]\n      [(char=? (char-code c) 48) (char=? (char-code\
    \ c) 57)]\n      [else #f]))\n  (define \n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"\
    yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal?\
    \ (candidate \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n \
    \   (check-equal? (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\"\
    ) \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate\
    \ \"ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal?\
    \ (candidate \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n\
    \    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"\
    Above\") \"o\")\n))\n\n(test-humaneval)"
  status: SyntaxError
  stderr: "/tmp/tmpccdm94an.rkt:46:2: read-syntax: expected a `)` to close `(`\n \
    \ possible cause: indentation suggests a missing `)` before line 47\n  context...:\n\
    \   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /work/arjunguha-research-group/software/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (define (helper word vowel index count)\n\
    \    (cond [(null? word) \"\"]\n          [(equal? vowel (first word)) (helper\
    \ (rest word) vowel (+ index 1) count)]\n          [(equal? (first word) vowel)\
    \ (helper (rest word) vowel (+ index 1) (+ count 1))]\n          [else (helper\
    \ (rest word) vowel (+ index 1) count)]))\n  (helper word 'a '0 0))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n\
    \    (check-equal? (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate\
    \ \"full\") \"u\")\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal?\
    \ (candidate \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n  \
    \  (check-equal? (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\"\
    ) \"o\")\n    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate\
    \ \"ba\") \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal?\
    \ (candidate \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n\
    \    (check-equal? (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp5145tp1f.rkt:22:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp5145tp1f.rkt:23:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp5145tp1f.rkt:24:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp5145tp1f.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp5145tp1f.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp5145tp1f.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp5145tp1f.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp5145tp1f.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp5145tp1f.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp5145tp1f.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp5145tp1f.rkt:32:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040255
- exit_code: 1
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (define (helper word vowel)\n    (cond\n \
    \     [(empty? word) \"\"]\n      [(equal? (first word) vowel) (helper (rest word)\
    \ vowel)]\n      [else (helper (rest word) (cons (first word) vowel))]))\n  (helper\
    \ (reverse word) 'a'))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\"\
    ) \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  status: SyntaxError
  stderr: "/tmp/tmp988e3mok.rkt:15:28: read-syntax: unexpected `)`\n  context...:\n\
    \   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /work/arjunguha-research-group/software/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (cons\
    \ (first word) (get_closest_vowel (rest word)))]))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (cons\
    \ (first word) (get_closest_vowel (rest word)))]))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (get_closest_vowel\
    \ (rest word))]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\") \"\
    u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond [(empty? word) \"\"]\n        [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n        [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n        [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n        [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \        [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n        [else\
    \ (cons (first word) (get_closest_vowel (rest word)))]))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmph8j7mhux.rkt:23:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmph8j7mhux.rkt:24:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmph8j7mhux.rkt:25:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmph8j7mhux.rkt:26:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmph8j7mhux.rkt:27:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmph8j7mhux.rkt:28:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmph8j7mhux.rkt:29:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmph8j7mhux.rkt:30:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmph8j7mhux.rkt:31:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmph8j7mhux.rkt:32:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmph8j7mhux.rkt:33:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (cons\
    \ (first word) (get_closest_vowel (rest word)))]))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (define (helper word vowel index)\n    (cond\n\
    \      [(null? word) \"\"]\n      [(equal? vowel (first word)) (helper rest (first\
    \ word) index)]\n      [else (helper (rest word) (first word) (+ index 1))]))\n\
    \  (helper word 'a 0))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\"\
    ) \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpikc5svgp.rkt:22:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpikc5svgp.rkt:23:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpikc5svgp.rkt:24:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpikc5svgp.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpikc5svgp.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpikc5svgp.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpikc5svgp.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpikc5svgp.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpikc5svgp.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpikc5svgp.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpikc5svgp.rkt:32:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040255
- exit_code: 1
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (define (vowel-check word)\n    (cond\n  \
    \    [(empty? word) \"\"]\n      [(char-equal? (char-after (char-before (char-after\
    \ word) 'a) 'a) 'a) 'a]\n      [(char-equal? (char-after (char-before (char-after\
    \ word) 'a) 'a) 'e) 'e]\n      [(char-equal? (char-after (char-before (char-after\
    \ word) 'a) 'a) 'i) 'i]\n      [(char-equal? (char-after (char-before (char-after\
    \ word) 'a) 'a) 'o) 'o]\n      [(char-equal? (char-after (char-before (char-after\
    \ word) 'a) 'a) 'u) 'u]\n      [(char-equal? (char-after (char-before (char-after\
    \ word) 'a) 'a) 'A) 'A]\n      [(char-equal? (char-after (char-before (char-after\
    \ word) 'a) 'a) 'E) 'E]\n      [(char-equal? (char-after (char-before (char-after\
    \ word) 'a) 'a) 'I) 'I]\n      [(char-equal? (char-after (char-before (char-after\
    \ word) 'a) 'a) 'O) 'O]\n      [(char-equal? (char-after (char-before (char-after\
    \ word) 'a) 'a) 'U) 'U]\n      [(char-equal? (char-after (char-before (char-after\
    \ word) 'a) 'a) 'Y) 'Y]\n      [(char-equal? (char-after (char-before (char-after\
    \ word) 'a) 'a) 'Y) 'Y]\n      [(char-equal? (char-after (char-before (char-after\
    \ word) 'a) 'a) 'a) 'a]\n      [(char-equal? (char-after (char-before (char-after\
    \ word) 'a) 'a) 'e) 'e]\n      [(char-equal? (char-after (char-before (char-after\
    \ word) 'a) 'a) 'i) 'i]\n      [(char-equal? (char-after (char-before (char-\n\
    (require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n\
    \    (check-equal? (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate\
    \ \"full\") \"u\")\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal?\
    \ (candidate \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n  \
    \  (check-equal? (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\"\
    ) \"o\")\n    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate\
    \ \"ba\") \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal?\
    \ (candidate \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n\
    \    (check-equal? (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: SyntaxError
  stderr: "/tmp/tmp4kngfdu4.rkt:28:45: read-syntax: expected a `)` to close `(`\n\
    \  possible cause: indentation suggests a missing `)` before line 29\n  context...:\n\
    \   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /work/arjunguha-research-group/software/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (cons\
    \ (first word) (get_closest_vowel (rest word)))]))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 1
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (define (helper word vowel)\n    (cond\n \
    \     [(empty? word) \"\"]\n      [(equal? vowel (first word)) (helper (rest word)\
    \ vowel)]\n      [else (helper (rest word) (first vowel))]))\n  (helper (reverse\
    \ word) 'a'))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let ((\
    \ candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\") \"u\"\
    )\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  status: SyntaxError
  stderr: "/tmp/tmpl876rb_w.rkt:15:28: read-syntax: unexpected `)`\n  context...:\n\
    \   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /work/arjunguha-research-group/software/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (cons\
    \ (first word) (get_closest_vowel (rest word)))]))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (cons\
    \ (first word) (get_closest_vowel (rest word)))]))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (cons\
    \ (first word) (get_closest_vowel (rest word)))]))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (get_closest_vowel\
    \ (rest word))]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\") \"\
    u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (cons\
    \ (first word) (get_closest_vowel (rest word)))]))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond [(empty? word) \"\"]\n        [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n        [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n        [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n        [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \        [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n        [else\
    \ (get_closest_vowel (rest word))]))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"\
    yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal?\
    \ (candidate \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n \
    \   (check-equal? (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\"\
    ) \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate\
    \ \"ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal?\
    \ (candidate \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n\
    \    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"\
    Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpvcx8pfax.rkt:23:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpvcx8pfax.rkt:24:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpvcx8pfax.rkt:25:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpvcx8pfax.rkt:26:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpvcx8pfax.rkt:27:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpvcx8pfax.rkt:28:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpvcx8pfax.rkt:29:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpvcx8pfax.rkt:30:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpvcx8pfax.rkt:31:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpvcx8pfax.rkt:32:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpvcx8pfax.rkt:33:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (cons\
    \ (first word) (get_closest_vowel (rest word)))]))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 1
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (define (vowel-between-consonants word start\
    \ end)\n    (cond\n      [(char=? (char-code (substring word start)) #\\a) (substring\
    \ word (+ start 1))]\n      [(char=? (char-code (substring word end)) #\\a) (substring\
    \ word (+ end 1))]\n      [else (substring word (+ start 1))]))\n  (cond\n   \
    \ [(empty? word) \"\"]\n    [(equal? (char-code (char-code (first word)) #\\a)\
    \ (char-code (char-code (first word)) #\\o)) (vowel-between-consonants word 0\
    \ (- (length word) 1))]\n    [else (vowel-between-consonants word 0 (- (length\
    \ word) 1))]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let ((\
    \ candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\") \"u\"\
    )\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  status: Exception
  stderr: "/tmp/tmpdvt5misf.rkt:12:16: char-code: unbound identifier\n  in: char-code\n\
    \  location...:\n   /tmp/tmpdvt5misf.rkt:12:16\n"
  stdout: ''
  timestamp: 1660040255
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (get_closest_vowel\
    \ (rest word))]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\") \"\
    u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (define (vowel-search vowel word)\n    (cond\
    \ [(empty? word) empty]\n          [(equal? (first word) vowel) (vowel-search\
    \ vowel (rest word))]\n          [else (vowel-search (first word) (cons (first\
    \ word) (rest word)))]))\n  (vowel-search 'a '(a b c d e f g h i j k l m n o p\
    \ q r s t u v w x y z))\n)\n\n(require rackunit)\n\n(define (test-humaneval) \n\
    \n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\"\
    ) \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmppoupexar.rkt:22:4

    actual:     ''()

    expected:   "u"

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmppoupexar.rkt:23:4

    actual:     ''()

    expected:   "u"

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmppoupexar.rkt:24:4

    actual:     ''()

    expected:   ""

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmppoupexar.rkt:25:4

    actual:     ''()

    expected:   ""

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmppoupexar.rkt:26:4

    actual:     ''()

    expected:   ""

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmppoupexar.rkt:27:4

    actual:     ''()

    expected:   "a"

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmppoupexar.rkt:28:4

    actual:     ''()

    expected:   "o"

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmppoupexar.rkt:29:4

    actual:     ''()

    expected:   ""

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmppoupexar.rkt:30:4

    actual:     ''()

    expected:   ""

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmppoupexar.rkt:31:4

    actual:     ''()

    expected:   ""

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmppoupexar.rkt:32:4

    actual:     ''()

    expected:   "i"

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmppoupexar.rkt:33:4

    actual:     ''()

    expected:   ""

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmppoupexar.rkt:34:4

    actual:     ''()

    expected:   "o"

    --------------------

    '
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (cons\
    \ (first word) (get_closest_vowel (rest word)))]))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (cons\
    \ (first word) (get_closest_vowel (rest word)))]))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (define (helper word vowel start end)\n  \
    \  (cond\n      [(empty? word) \"\"]\n      [(equal? start end) \"\"]\n      [(equal?\
    \ start vowel) (helper word vowel (cdr start) end)]\n      [(equal? (cdr start)\
    \ vowel) (helper word vowel (cdr start) (cdr end))]\n      [else (helper word\
    \ vowel (cdr start) (cdr end))]))\n  (helper word 'a 0 (string-length word)))\n\
    \n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n\
    \    (check-equal? (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate\
    \ \"full\") \"u\")\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal?\
    \ (candidate \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n  \
    \  (check-equal? (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\"\
    ) \"o\")\n    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate\
    \ \"ba\") \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal?\
    \ (candidate \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n\
    \    (check-equal? (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpv21i21af.rkt:24:4\n\
    \ncdr: contract violation\n  expected: pair?\n  given: 0\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpv21i21af.rkt:25:4\n\
    \ncdr: contract violation\n  expected: pair?\n  given: 0\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpv21i21af.rkt:26:4\n\
    \ncdr: contract violation\n  expected: pair?\n  given: 0\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpv21i21af.rkt:27:4\n\
    \ncdr: contract violation\n  expected: pair?\n  given: 0\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpv21i21af.rkt:28:4\n\
    \ncdr: contract violation\n  expected: pair?\n  given: 0\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpv21i21af.rkt:29:4\n\
    \ncdr: contract violation\n  expected: pair?\n  given: 0\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpv21i21af.rkt:30:4\n\
    \ncdr: contract violation\n  expected: pair?\n  given: 0\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpv21i21af.rkt:31:4\n\
    \ncdr: contract violation\n  expected: pair?\n  given: 0\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpv21i21af.rkt:32:4\n\
    \ncdr: contract violation\n  expected: pair?\n  given: 0\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpv21i21af.rkt:33:4\n\
    \ncdr: contract violation\n  expected: pair?\n  given: 0\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpv21i21af.rkt:34:4\n\
    \ncdr: contract violation\n  expected: pair?\n  given: 0\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpv21i21af.rkt:35:4\n\
    \ncdr: contract violation\n  expected: pair?\n  given: 0\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp"
  stdout: ''
  timestamp: 1660040255
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (get_closest_vowel\
    \ (rest word))]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\") \"\
    u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (get_closest_vowel\
    \ (rest word))]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\") \"\
    u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (get_closest_vowel\
    \ (rest word))]\n  )\n)\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\"\
    ) \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:26:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:34:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:35:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:36:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (get_closest_vowel\
    \ (rest word))]\n  )\n)\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\"\
    ) \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:26:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:34:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:35:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:36:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (get_closest_vowel\
    \ (rest word))]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\") \"\
    u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (cons\
    \ (first word) (get_closest_vowel (rest word)))]))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (define (helper word vowel i j)\n    (cond\n\
    \      [(empty? word) \"\"]\n      [(equal? vowel (car word)) (helper (cdr word)\
    \ vowel (+ i 1) j)]\n      [(equal? (car word) vowel) (helper (cdr word) vowel\
    \ (+ i 1) (+ j 1))]\n      [else (helper (cdr word) vowel (+ i 1) j)]))\n  (helper\
    \ word 'a '(length word) '(length word)))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"\
    yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal?\
    \ (candidate \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n \
    \   (check-equal? (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\"\
    ) \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate\
    \ \"ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal?\
    \ (candidate \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n\
    \    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"\
    Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpu_pcnvq_.rkt:23:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"yogurt\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpu_pcnvq_.rkt:24:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"full\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpu_pcnvq_.rkt:25:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"easy\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpu_pcnvq_.rkt:26:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"eAsy\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpu_pcnvq_.rkt:27:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"ali\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpu_pcnvq_.rkt:28:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"bad\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpu_pcnvq_.rkt:29:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"most\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpu_pcnvq_.rkt:30:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"ab\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpu_pcnvq_.rkt:31:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"ba\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpu_pcnvq_.rkt:32:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"quick\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpu_pcnvq_.rkt:33:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"anime\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpu_pcnvq_.rkt:34:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"Asia\"\n--------------------\n\
    ----------"
  stdout: ''
  timestamp: 1660040255
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (cons\
    \ (first word) (get_closest_vowel (rest word)))]))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (define (vowel-check word)\n    (cond\n  \
    \    [(empty? word) \"\"]\n      [(equal? (first word) 'a) (cons (first word)\
    \ (vowel-check (rest word)))]\n      [(equal? (first word) 'e) (cons (first word)\
    \ (vowel-check (rest word)))]\n      [(equal? (first word) 'i) (cons (first word)\
    \ (vowel-check (rest word)))]\n      [(equal? (first word) 'o) (cons (first word)\
    \ (vowel-check (rest word)))]\n      [(equal? (first word) 'u) (cons (first word)\
    \ (vowel-check (rest word)))]\n      [else (vowel-check (rest word))]\n      ))\n\
    \  (vowel-check word))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\"\
    ) \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpw36jek2c.rkt:27:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpw36jek2c.rkt:28:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpw36jek2c.rkt:29:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpw36jek2c.rkt:30:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpw36jek2c.rkt:31:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpw36jek2c.rkt:32:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpw36jek2c.rkt:33:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpw36jek2c.rkt:34:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpw36jek2c.rkt:35:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpw36jek2c.rkt:36:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpw36jek2c.rkt:37:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040255
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (define (vowel-check word)\n    (cond [(empty?\
    \ word) empty]\n          [(char=? (first word) 'a) (cons (first word) (vowel-check\
    \ (rest word)))]\n          [(char=? (first word) 'e) (cons (first word) (vowel-check\
    \ (rest word)))]\n          [(char=? (first word) 'i) (cons (first word) (vowel-check\
    \ (rest word)))]\n          [(char=? (first word) 'o) (cons (first word) (vowel-check\
    \ (rest word)))]\n          [(char=? (first word) 'u) (cons (first word) (vowel-check\
    \ (rest word)))]\n          [else (vowel-check (rest word))]))\n  (vowel-check\
    \ word))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ get_closest_vowel))\n    (check-equal? (candidate \"yogurt\") \"u\")\n    (check-equal?\
    \ (candidate \"full\") \"u\")\n    (check-equal? (candidate \"easy\") \"\")\n\
    \    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal? (candidate \"\
    ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n    (check-equal?\
    \ (candidate \"most\") \"o\")\n    (check-equal? (candidate \"ab\") \"\")\n  \
    \  (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate \"quick\"\
    ) \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal? (candidate\
    \ \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp67i1ql28.rkt:25:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp67i1ql28.rkt:26:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp67i1ql28.rkt:27:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp67i1ql28.rkt:28:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp67i1ql28.rkt:29:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp67i1ql28.rkt:30:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp67i1ql28.rkt:31:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp67i1ql28.rkt:32:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp67i1ql28.rkt:33:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp67i1ql28.rkt:34:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp67i1ql28.rkt:35:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040255
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (get_closest_vowel\
    \ (rest word))]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\") \"\
    u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (define (vowel-check vowel word)\n    (cond\n\
    \      [(string=? vowel word) vowel]\n      [else (vowel-check vowel (substring\
    \ word (+ 0 (string-length word))))]))\n  (vowel-check 'a (substring word (+ 0\
    \ (string-length word))))\n  )\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"\
    yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal?\
    \ (candidate \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n \
    \   (check-equal? (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\"\
    ) \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate\
    \ \"ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal?\
    \ (candidate \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n\
    \    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"\
    Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpuiu0trr4.rkt:22:4\n\
    \nstring=?: contract violation\n  expected: string?\n  given: 'a\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpuiu0trr4.rkt:23:4\n\
    \nstring=?: contract violation\n  expected: string?\n  given: 'a\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpuiu0trr4.rkt:24:4\n\
    \nstring=?: contract violation\n  expected: string?\n  given: 'a\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpuiu0trr4.rkt:25:4\n\
    \nstring=?: contract violation\n  expected: string?\n  given: 'a\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpuiu0trr4.rkt:26:4\n\
    \nstring=?: contract violation\n  expected: string?\n  given: 'a\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpuiu0trr4.rkt:27:4\n\
    \nstring=?: contract violation\n  expected: string?\n  given: 'a\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpuiu0trr4.rkt:28:4\n\
    \nstring=?: contract violation\n  expected: string?\n  given: 'a\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpuiu0trr4.rkt:29:4\n\
    \nstring=?: contract violation\n  expected: string?\n  given: 'a\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpuiu0trr4.rkt:30:4\n\
    \nstring=?: contract violation\n  expected: string?\n  given: 'a\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpuiu0trr4.rkt:31:4\n\
    \nstring=?: contract violation\n  expected: string?\n  given: 'a\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpuiu0trr4.rkt:32:4\n\
    \nstring=?: contract violation\n  expected: string?\n  given: 'a\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpuiu0trr4.rkt:33:4\n\
    \nstring=?: contract violation\n  expected: string?\n  giv"
  stdout: ''
  timestamp: 1660040255
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond [(empty? word) \"\"]\n        [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n        [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n        [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n        [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \        [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n        [else\
    \ (get_closest_vowel (rest word))]))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"\
    yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal?\
    \ (candidate \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n \
    \   (check-equal? (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\"\
    ) \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate\
    \ \"ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal?\
    \ (candidate \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n\
    \    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"\
    Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpvcx8pfax.rkt:23:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpvcx8pfax.rkt:24:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpvcx8pfax.rkt:25:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpvcx8pfax.rkt:26:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpvcx8pfax.rkt:27:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpvcx8pfax.rkt:28:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpvcx8pfax.rkt:29:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpvcx8pfax.rkt:30:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpvcx8pfax.rkt:31:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpvcx8pfax.rkt:32:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpvcx8pfax.rkt:33:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (get_closest_vowel\
    \ (rest word))]\n  )\n)\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\"\
    ) \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:26:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:34:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:35:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:36:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (cons\
    \ (first word) (get_closest_vowel (rest word)))]))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (cons\
    \ (first word) (get_closest_vowel (rest word)))]))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 1
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (define (helper word vowel start end)\n  \
    \  (cond ((null? word) \"\")\n          ((equal? (char-code (first word)) (char\
    \ vowel)) (helper (rest word) vowel (+ start 1) end))\n          ((equal? (char-code\
    \ (first word)) (char vowel)) (helper (rest word) vowel (+ start 1) end))\n  \
    \        ((equal? (char-code (first word)) (char vowel)) (helper (rest word) vowel\
    \ (+ start 1) end))\n          ((equal? (char-code (first word)) (char vowel))\
    \ (helper (rest word) vowel (+ start 1) end))\n          ((equal? (char-code (first\
    \ word)) (char vowel)) (helper (rest word) vowel (+ start 1) end))\n         \
    \ ((equal? (char-code (first word)) (char vowel)) (helper (rest word) vowel (+\
    \ start 1) end))\n          ((equal? (char-code (first word)) (char vowel)) (helper\
    \ (rest word) vowel (+ start 1) end))\n          ((equal? (char-code (first word))\
    \ (char vowel)) (helper (rest word) vowel (+ start 1) end))\n          ((equal?\
    \ (char-code (first word)) (char vowel)) (helper (rest word) vowel (+ start 1)\
    \ end))\n          ((equal? (char-code (first word)) (char vowel)) (helper (rest\
    \ word) vowel (+ start 1) end))\n          ((equal? (char-code (first word)) (char\
    \ vowel)) (helper (rest word) vowel (+ start 1) end))\n          ((equal? (char-code\
    \ (first word)) (char vowel)) (helper (rest word) vowel (+ start 1) end))\n  \
    \        ((equal? (char-code (first word)) (char vowel)) (helper (rest word) vowel\
    \ (+ start 1) end))\n          ((equal? (char-code (first word)) (char vowel))\
    \ (helper (rest word) vowel (+ start 1) end))\n          ((equal? (char-code (first\
    \ word)) (char vowel)) (helper (rest word) vowel (+ start 1) end))\n         \
    \ ((equal? (char-code (first word)) (char vowel)) (helper (rest word) vowel (+\
    \ start 1) end))\n          ((equal? (char-code (first word)) (char vowel)) (helper\
    \ (rest word) vowel (+ start 1) end))\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"\
    yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal?\
    \ (candidate \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n \
    \   (check-equal? (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\"\
    ) \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate\
    \ \"ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal?\
    \ (candidate \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n\
    \    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"\
    Above\") \"o\")\n))\n\n(test-humaneval)"
  status: SyntaxError
  stderr: "/tmp/tmp34eslr2_.rkt:11:4: read-syntax: expected a `)` to close `(`\n \
    \ possible cause: indentation suggests a missing `)` before line 29\n  context...:\n\
    \   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /work/arjunguha-research-group/software/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  stdout: ''
  timestamp: 1660040254
- exit_code: 1
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (define (helper word vowel start end)\n  \
    \  (cond ((null? word) \"\")\n          ((equal? (char-code (car word)) (char-code\
    \ vowel)) vowel)\n          ((char-code (car word)) (helper (cdr word) vowel (+\
    \ start 1) end))\n          ((char-code (cdr word)) (helper (cdr word) vowel (+\
    \ start 1) end))\n          (else (helper (cdr word) vowel (+ start 1) end))))\n\
    \  (helper (reverse word) 'a '0 (length word)))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "/tmp/tmpo9nzs9en.rkt:12:20: char-code: unbound identifier\n  in: char-code\n\
    \  location...:\n   /tmp/tmpo9nzs9en.rkt:12:20\n"
  stdout: ''
  timestamp: 1660040255
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (cons\
    \ (first word) (get_closest_vowel (rest word)))]))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (get_closest_vowel\
    \ (rest word))]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\") \"\
    u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond [(empty? word) \"\"]\n        [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n        [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n        [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n        [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \        [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n        [else\
    \ (cons (first word) (get_closest_vowel (rest word)))]))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmph8j7mhux.rkt:23:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmph8j7mhux.rkt:24:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmph8j7mhux.rkt:25:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmph8j7mhux.rkt:26:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmph8j7mhux.rkt:27:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmph8j7mhux.rkt:28:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmph8j7mhux.rkt:29:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmph8j7mhux.rkt:30:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmph8j7mhux.rkt:31:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmph8j7mhux.rkt:32:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmph8j7mhux.rkt:33:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (cons\
    \ (first word) (get_closest_vowel (rest word)))]))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (get_closest_vowel\
    \ (rest word))]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\") \"\
    u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 1
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (define (helper word vowel vowel-index vowel-count)\n\
    \    (cond [(null? word) \"\"]\n          [(vowel? (car word)) (cons (car word)\
    \ (helper (cdr word) vowel (+ 1 vowel-index) vowel-count))]\n          [else (helper\
    \ (cdr word) vowel (+ 1 vowel-index) vowel-count)]))\n  (helper (reverse word)\
    \ 'a 0 0))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ get_closest_vowel))\n    (check-equal? (candidate \"yogurt\") \"u\")\n    (check-equal?\
    \ (candidate \"full\") \"u\")\n    (check-equal? (candidate \"easy\") \"\")\n\
    \    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal? (candidate \"\
    ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n    (check-equal?\
    \ (candidate \"most\") \"o\")\n    (check-equal? (candidate \"ab\") \"\")\n  \
    \  (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate \"quick\"\
    ) \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal? (candidate\
    \ \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "/tmp/tmpmuod98ow.rkt:12:12: vowel?: unbound identifier\n  in: vowel?\n\
    \  location...:\n   /tmp/tmpmuod98ow.rkt:12:12\n"
  stdout: ''
  timestamp: 1660040255
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (cons\
    \ (first word) (get_closest_vowel (rest word)))]))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (get_closest_vowel\
    \ (rest word))]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\") \"\
    u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (cons\
    \ (first word) (get_closest_vowel (rest word)))]))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (cons\
    \ (first word) (get_closest_vowel (rest word)))]))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (get_closest_vowel\
    \ (rest word))]\n  )\n)\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\"\
    ) \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:26:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:34:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:35:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:36:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 1
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (define (vowel-search word vowel)\n    (cond\
    \ [(empty? word) empty]\n          [(equal? (first word) vowel) (vowel-search\
    \ rest (first word))]\n          [else (vowel-search (rest word) (first word))]))\n\
    \  (vowel-search word 'a'))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"\
    yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal?\
    \ (candidate \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n \
    \   (check-equal? (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\"\
    ) \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate\
    \ \"ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal?\
    \ (candidate \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n\
    \    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"\
    Above\") \"o\")\n))\n\n(test-humaneval)"
  status: SyntaxError
  stderr: "/tmp/tmpjc59kw3o.rkt:14:24: read-syntax: unexpected `)`\n  context...:\n\
    \   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /work/arjunguha-research-group/software/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (get_closest_vowel\
    \ (rest word))]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\") \"\
    u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (get_closest_vowel\
    \ (rest word))]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\") \"\
    u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (cons\
    \ (first word) (get_closest_vowel (rest word)))]))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (cons\
    \ (first word) (get_closest_vowel (rest word)))]))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (cons\
    \ (first word) (get_closest_vowel (rest word)))]))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (cons\
    \ (first word) (get_closest_vowel (rest word)))]))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (define (vowel-search vowel word)\n    (cond\n\
    \      [(empty? word) \"\"]\n      [(equal? vowel (first word)) (vowel-search\
    \ vowel (rest word))]\n      [else (vowel-search (first word) (append (list (first\
    \ vowel)) (rest word)))]))\n  (vowel-search 'a word))\n\n(require rackunit)\n\n\
    (define (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpbueyzggw.rkt:22:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbueyzggw.rkt:23:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbueyzggw.rkt:24:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbueyzggw.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbueyzggw.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbueyzggw.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbueyzggw.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbueyzggw.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbueyzggw.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbueyzggw.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbueyzggw.rkt:32:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040255
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (cons\
    \ (first word) (get_closest_vowel (rest word)))]))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (get_closest_vowel\
    \ (rest word))]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\") \"\
    u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (cons\
    \ (first word) (get_closest_vowel (rest word)))]))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (cons\
    \ (first word) (get_closest_vowel (rest word)))]))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (define (helper word vowel index count)\n\
    \    (cond\n      [(empty? word) \"\"]\n      [(equal? vowel (first word)) (helper\
    \ (rest word) vowel (+ index 1) count)]\n      [(equal? (first word) vowel) (helper\
    \ (rest word) vowel (+ index 1) (+ count 1))]\n      [else (helper (rest word)\
    \ vowel (+ index 1) count)]))\n  (helper word 'a 0 0))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpjg4qv56a.rkt:23:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpjg4qv56a.rkt:24:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpjg4qv56a.rkt:25:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpjg4qv56a.rkt:26:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpjg4qv56a.rkt:27:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpjg4qv56a.rkt:28:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpjg4qv56a.rkt:29:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpjg4qv56a.rkt:30:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpjg4qv56a.rkt:31:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpjg4qv56a.rkt:32:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpjg4qv56a.rkt:33:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040255
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (get_closest_vowel\
    \ (rest word))]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\") \"\
    u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (get_closest_vowel\
    \ (rest word))]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\") \"\
    u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (cons\
    \ (first word) (get_closest_vowel (rest word)))]))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (define (helper word vowel start end)\n  \
    \  (cond [(null? word) \"\"]\n          [(equal? start end) \"\"]\n          [(equal?\
    \ start vowel) (helper word vowel (+ start 1) end)]\n          [(equal? end vowel)\
    \ (helper word vowel (+ start 1) (+ end 1))]\n          [else (helper (cdr word)\
    \ vowel (+ start 1) (+ end 1))]))\n  (helper word 'a '(length word) '(length word)))\n\
    \n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n\
    \    (check-equal? (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate\
    \ \"full\") \"u\")\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal?\
    \ (candidate \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n  \
    \  (check-equal? (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\"\
    ) \"o\")\n    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate\
    \ \"ba\") \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal?\
    \ (candidate \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n\
    \    (check-equal? (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpt90ryktu.rkt:23:4

    actual:     ""

    expected:   "u"

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpt90ryktu.rkt:24:4

    actual:     ""

    expected:   "u"

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpt90ryktu.rkt:28:4

    actual:     ""

    expected:   "a"

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpt90ryktu.rkt:29:4

    actual:     ""

    expected:   "o"

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpt90ryktu.rkt:33:4

    actual:     ""

    expected:   "i"

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpt90ryktu.rkt:35:4

    actual:     ""

    expected:   "o"

    --------------------

    '
  stdout: ''
  timestamp: 1660040255
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (get_closest_vowel\
    \ (rest word))]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\") \"\
    u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (get_closest_vowel\
    \ (rest word))]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\") \"\
    u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (cons\
    \ (first word) (get_closest_vowel (rest word)))]))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 1
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (define (helper word vowel start end)\n  \
    \  (cond [(empty? word) \"\"]\n          [(equal? start end) (cons vowel word)]\n\
    \          [(equal? (char-code (first word)) start) (cons vowel (helper word vowel\
    \ (first word) (first word)))]\n          [(equal? (char-code (first word)) end)\
    \ (cons vowel (helper word vowel (first word) (first word)))]\n          [else\
    \ (cons (first word) (helper (rest word) vowel (first word) (first word)))]))\n\
    \  (helper word 'a 'a 'z'))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"\
    yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal?\
    \ (candidate \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n \
    \   (check-equal? (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\"\
    ) \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate\
    \ \"ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal?\
    \ (candidate \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n\
    \    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"\
    Above\") \"o\")\n))\n\n(test-humaneval)"
  status: SyntaxError
  stderr: "/tmp/tmp8io2lmd2.rkt:16:24: read-syntax: unexpected `)`\n  context...:\n\
    \   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /work/arjunguha-research-group/software/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (cons\
    \ (first word) (get_closest_vowel (rest word)))]))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (get_closest_vowel\
    \ (rest word))]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\") \"\
    u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (cons\
    \ (first word) (get_closest_vowel (rest word)))]))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (cons\
    \ (first word) (get_closest_vowel (rest word)))]))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (define (helper word vowel)\n    (cond [(empty?\
    \ word) \"\"]\n          [(equal? vowel (first word)) (helper rest (first word))]\n\
    \          [else (helper (rest word) (first vowel))]))\n  (helper word 'a))\n\n\
    (require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n\
    \    (check-equal? (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate\
    \ \"full\") \"u\")\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal?\
    \ (candidate \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n  \
    \  (check-equal? (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\"\
    ) \"o\")\n    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate\
    \ \"ba\") \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal?\
    \ (candidate \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n\
    \    (check-equal? (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp74rns8yi.rkt:21:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp74rns8yi.rkt:22:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp74rns8yi.rkt:23:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp74rns8yi.rkt:24:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp74rns8yi.rkt:25:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp74rns8yi.rkt:26:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp74rns8yi.rkt:27:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp74rns8yi.rkt:28:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp74rns8yi.rkt:29:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp74rns8yi.rkt:30:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp74rns8yi.rkt:31:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040255
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (define (vowel-search vowel word)\n    (cond\
    \ [(empty? word) empty]\n          [(equal? vowel (first word)) (vowel-search\
    \ vowel (rest word))]\n          [else (vowel-search (first word) (append (rest\
    \ word) (list vowel)))]))\n  (vowel-search 'a (reverse word)))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpvzp9wqqi.rkt:21:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"yogurt\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpvzp9wqqi.rkt:22:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"full\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpvzp9wqqi.rkt:23:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"easy\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpvzp9wqqi.rkt:24:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"eAsy\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpvzp9wqqi.rkt:25:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"ali\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpvzp9wqqi.rkt:26:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"bad\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpvzp9wqqi.rkt:27:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"most\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpvzp9wqqi.rkt:28:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"ab\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpvzp9wqqi.rkt:29:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"ba\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpvzp9wqqi.rkt:30:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"quick\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpvzp9wqqi.rkt:31:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"anime\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpvzp9wqqi.rkt:32:4\n\
    \nreverse: contract violation\n  expected: list?"
  stdout: ''
  timestamp: 1660040255
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (define (helper word vowel)\n    (cond [(empty?\
    \ word) \"\"]\n          [(equal? vowel (first word)) (helper rest (first word))]\n\
    \          [else (helper (rest word) (first vowel))]))\n  (helper word 'a))\n\n\
    (require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n\
    \    (check-equal? (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate\
    \ \"full\") \"u\")\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal?\
    \ (candidate \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n  \
    \  (check-equal? (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\"\
    ) \"o\")\n    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate\
    \ \"ba\") \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal?\
    \ (candidate \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n\
    \    (check-equal? (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp74rns8yi.rkt:21:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp74rns8yi.rkt:22:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp74rns8yi.rkt:23:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp74rns8yi.rkt:24:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp74rns8yi.rkt:25:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp74rns8yi.rkt:26:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp74rns8yi.rkt:27:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp74rns8yi.rkt:28:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp74rns8yi.rkt:29:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp74rns8yi.rkt:30:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp74rns8yi.rkt:31:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040255
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (cons\
    \ (first word) (get_closest_vowel (rest word)))]))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (cons\
    \ (first word) (get_closest_vowel (rest word)))]))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (get_closest_vowel\
    \ (rest word))]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\") \"\
    u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (get_closest_vowel\
    \ (rest word))]\n  )\n)\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\"\
    ) \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:26:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:34:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:35:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:36:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (cons\
    \ (first word) (get_closest_vowel (rest word)))]))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (cons\
    \ (first word) (get_closest_vowel (rest word)))]))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (get_closest_vowel\
    \ (rest word))]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\") \"\
    u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (define (helper word vowel index count)\n\
    \    (cond\n      [(null? word) \"\"]\n      [(equal? vowel (car word)) (helper\
    \ (cdr word) vowel (+ index 1) count)]\n      [else (helper (cdr word) vowel (+\
    \ index 1) count)]))\n  (helper (reverse word) (car word) 0 0))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpc6cozqlg.rkt:22:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"yogurt\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpc6cozqlg.rkt:23:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"full\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpc6cozqlg.rkt:24:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"easy\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpc6cozqlg.rkt:25:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"eAsy\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpc6cozqlg.rkt:26:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"ali\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpc6cozqlg.rkt:27:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"bad\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpc6cozqlg.rkt:28:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"most\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpc6cozqlg.rkt:29:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"ab\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpc6cozqlg.rkt:30:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"ba\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpc6cozqlg.rkt:31:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"quick\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpc6cozqlg.rkt:32:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"anime\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpc6cozqlg.rkt:33:4\n\
    \nreverse: contract violation\n  expected: list?"
  stdout: ''
  timestamp: 1660040255
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (get_closest_vowel\
    \ (rest word))]\n  )\n)\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\"\
    ) \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:26:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:34:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:35:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:36:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond [(empty? word) \"\"]\n        [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n        [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n        [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n        [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \        [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n        [else\
    \ (cons (first word) (get_closest_vowel (rest word)))]))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmph8j7mhux.rkt:23:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmph8j7mhux.rkt:24:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmph8j7mhux.rkt:25:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmph8j7mhux.rkt:26:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmph8j7mhux.rkt:27:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmph8j7mhux.rkt:28:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmph8j7mhux.rkt:29:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmph8j7mhux.rkt:30:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmph8j7mhux.rkt:31:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmph8j7mhux.rkt:32:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmph8j7mhux.rkt:33:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (get_closest_vowel\
    \ (rest word))]\n  ))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n \
    \ (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\"\
    ) \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpimsbc159.rkt:25:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpimsbc159.rkt:26:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpimsbc159.rkt:27:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpimsbc159.rkt:28:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpimsbc159.rkt:29:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpimsbc159.rkt:30:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpimsbc159.rkt:31:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpimsbc159.rkt:32:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpimsbc159.rkt:33:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpimsbc159.rkt:34:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpimsbc159.rkt:35:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040255
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (cons\
    \ (first word) (get_closest_vowel (rest word)))]))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (get_closest_vowel\
    \ (rest word))]\n  )\n)\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\"\
    ) \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:26:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:34:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:35:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:36:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (get_closest_vowel\
    \ (rest word))]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\") \"\
    u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (get_closest_vowel\
    \ (rest word))]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\") \"\
    u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (get_closest_vowel\
    \ (rest word))]\n  )\n)\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\"\
    ) \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:26:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:34:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:35:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:36:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (get_closest_vowel\
    \ (rest word))]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\") \"\
    u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (cons\
    \ (first word) (get_closest_vowel (rest word)))]))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (cons\
    \ (first word) (get_closest_vowel (rest word)))]))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (get_closest_vowel\
    \ (rest word))]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\") \"\
    u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (define (vowel-check vowel cons)\n    (cond\n\
    \      [(string=? (substring word (- cons vowel)) vowel) vowel]\n      [else (vowel-check\
    \ (+ vowel 1) cons)]))\n  (vowel-check 0 0))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmphh1l_s68.rkt:21:4\n\
    \nstring=?: contract violation\n  expected: string?\n  given: 0\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmphh1l_s68.rkt:22:4\n\
    \nstring=?: contract violation\n  expected: string?\n  given: 0\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmphh1l_s68.rkt:23:4\n\
    \nstring=?: contract violation\n  expected: string?\n  given: 0\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmphh1l_s68.rkt:24:4\n\
    \nstring=?: contract violation\n  expected: string?\n  given: 0\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmphh1l_s68.rkt:25:4\n\
    \nstring=?: contract violation\n  expected: string?\n  given: 0\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmphh1l_s68.rkt:26:4\n\
    \nstring=?: contract violation\n  expected: string?\n  given: 0\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmphh1l_s68.rkt:27:4\n\
    \nstring=?: contract violation\n  expected: string?\n  given: 0\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmphh1l_s68.rkt:28:4\n\
    \nstring=?: contract violation\n  expected: string?\n  given: 0\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmphh1l_s68.rkt:29:4\n\
    \nstring=?: contract violation\n  expected: string?\n  given: 0\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmphh1l_s68.rkt:30:4\n\
    \nstring=?: contract violation\n  expected: string?\n  given: 0\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmphh1l_s68.rkt:31:4\n\
    \nstring=?: contract violation\n  expected: string?\n  given: 0\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmphh1l_s68.rkt:32:4\n\
    \nstring=?: contract violation\n  expected: string?\n  given: 0\n-----"
  stdout: ''
  timestamp: 1660040255
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (define (helper word vowel)\n    (cond [(empty?\
    \ word) \"\"]\n          [(equal? (first word) vowel) (helper (rest word) vowel)]\n\
    \          [else (helper (rest word) (first vowel))]))\n  (helper word 'a))\n\n\
    (require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n\
    \    (check-equal? (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate\
    \ \"full\") \"u\")\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal?\
    \ (candidate \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n  \
    \  (check-equal? (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\"\
    ) \"o\")\n    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate\
    \ \"ba\") \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal?\
    \ (candidate \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n\
    \    (check-equal? (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpzfscxq60.rkt:21:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpzfscxq60.rkt:22:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpzfscxq60.rkt:23:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpzfscxq60.rkt:24:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpzfscxq60.rkt:25:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpzfscxq60.rkt:26:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpzfscxq60.rkt:27:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpzfscxq60.rkt:28:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpzfscxq60.rkt:29:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpzfscxq60.rkt:30:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpzfscxq60.rkt:31:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040255
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (get_closest_vowel\
    \ (rest word))]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\") \"\
    u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 1
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (define (vowel-check vowel)\n    (cond\n \
    \     [(string=? vowel word) vowel]\n      [else \"\"]))\n  (define (consonant-check\
    \ consonant)\n    (cond\n      [(string=? consonant word) consonant]\n      [else\
    \ \"\"]))\n  (define (vowel-check vowel)\n    (cond\n      [(string=? vowel word)\
    \ vowel]\n      [else \"\"]))\n  (define (consonant-check consonant)\n    (cond\n\
    \      [(string=? consonant word) consonant]\n      [else \"\"]))\n  (define (vowel-check\
    \ vowel)\n    (cond\n      [(string=? vowel word) vowel]\n      [else \"\"]))\n\
    \  (define (consonant-check consonant)\n    (cond\n      [(string=? consonant\
    \ word) consonant]\n      [else \"\"]))\n  (define (vowel-check vowel)\n    (cond\n\
    \      [(string=? vowel word) vowel]\n      [else \"\"]))\n  (define (consonant-check\
    \ consonant)\n    (cond\n      [(string=? consonant word) consonant]\n      [else\
    \ \"\"]))\n  (define (vowel-check vowel)\n    (cond\n      [(string=? vowel word)\
    \ vowel]\n      [else \"\"]))\n  (define (consonant-check consonant)\n    (cond\n\
    \      [(string=? consonant word) consonant]\n      [else \"\"]))\n  (define (vowel-check\
    \ vowel)\n    (cond\n      [(string=? vowel word) vowel]\n      [else \"\"]))\n\
    \  (define (consonant-check consonant)\n    (cond\n      [(string=? consonant\
    \ word) consonant]\n      [else \"\"]))\n  (define (vowel-check vowel)\n    (cond\n\
    \      [(string=? vowel word) vowel]\n      [else \"\"]))\n  (define (consonant-check\
    \ consonant)\n    (cond\n      [(string=? consonant word) consonant]\n      [else\
    \ \"\"]))\n  (define (vowel-check vowel)\n    (cond\n      [(string=? vowel word)\
    \ vowel]\n      [else \"\"]))\n  (define (consonant-check consonant)\n    (cond\n\
    \      [(string=? consonant word) conson\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"\
    yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal?\
    \ (candidate \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n \
    \   (check-equal? (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\"\
    ) \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate\
    \ \"ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal?\
    \ (candidate \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n\
    \    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"\
    Above\") \"o\")\n))\n\n(test-humaneval)"
  status: SyntaxError
  stderr: "/tmp/tmpvppi63s3.rkt:72:6: read-syntax: expected a `]` to close `[`\n \
    \ possible cause: indentation suggests a missing `]` before line 73\n  context...:\n\
    \   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /work/arjunguha-research-group/software/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  stdout: ''
  timestamp: 1660040255
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (get_closest_vowel\
    \ (rest word))]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\") \"\
    u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (get_closest_vowel\
    \ (rest word))]\n  )\n)\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\"\
    ) \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:26:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:34:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:35:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:36:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (get_closest_vowel\
    \ (rest word))]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\") \"\
    u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (get_closest_vowel\
    \ (rest word))]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\") \"\
    u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (get_closest_vowel\
    \ (rest word))]\n  )\n)\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\"\
    ) \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:26:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:34:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:35:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:36:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (get_closest_vowel\
    \ (rest word))]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\") \"\
    u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (define (helper word vowel vowels)\n    (cond\
    \ [(empty? vowels) \"\"]\n          [(equal? (first vowels) vowel) (helper (rest\
    \ word) vowel (rest vowels))]\n          [else (helper (rest word) vowel (append\
    \ vowels (first vowels)))]))\n  (helper word 'a '(a e i o u)))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpy67upcay.rkt:21:4\n\
    \nrest: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpy67upcay.rkt:22:4\n\nrest: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpy67upcay.rkt:23:4\n\nrest:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpy67upcay.rkt:24:4\n\nrest: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpy67upcay.rkt:25:4\n\nrest:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpy67upcay.rkt:26:4\n\nrest: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpy67upcay.rkt:27:4\n\nrest:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpy67upcay.rkt:28:4\n\nrest: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpy67upcay.rkt:29:4\n\nrest:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpy67upcay.rkt:30:4\n\nrest: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpy67upcay.rkt:31:4\n\nrest:\
    \ contract viola"
  stdout: ''
  timestamp: 1660040255
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (cons\
    \ (first word) (get_closest_vowel (rest word)))]))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (cons\
    \ (first word) (get_closest_vowel (rest word)))]))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (get_closest_vowel\
    \ (rest word))]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\") \"\
    u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (cons\
    \ (first word) (get_closest_vowel (rest word)))]))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (get_closest_vowel\
    \ (rest word))]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\") \"\
    u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (define (helper word vowel vowel-index vowel-count)\n\
    \    (cond\n      [(empty? word) \"\"]\n      [(equal? vowel (first word)) (helper\
    \ (rest word) vowel (+ vowel-index 1) vowel-count)]\n      [else (helper (rest\
    \ word) vowel (+ vowel-index 1) vowel-count)]))\n  (helper (reverse word) 'a 0\
    \ 0))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ get_closest_vowel))\n    (check-equal? (candidate \"yogurt\") \"u\")\n    (check-equal?\
    \ (candidate \"full\") \"u\")\n    (check-equal? (candidate \"easy\") \"\")\n\
    \    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal? (candidate \"\
    ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n    (check-equal?\
    \ (candidate \"most\") \"o\")\n    (check-equal? (candidate \"ab\") \"\")\n  \
    \  (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate \"quick\"\
    ) \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal? (candidate\
    \ \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpis3_j7ai.rkt:22:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"yogurt\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpis3_j7ai.rkt:23:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"full\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpis3_j7ai.rkt:24:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"easy\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpis3_j7ai.rkt:25:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"eAsy\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpis3_j7ai.rkt:26:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"ali\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpis3_j7ai.rkt:27:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"bad\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpis3_j7ai.rkt:28:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"most\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpis3_j7ai.rkt:29:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"ab\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpis3_j7ai.rkt:30:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"ba\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpis3_j7ai.rkt:31:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"quick\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpis3_j7ai.rkt:32:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"anime\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpis3_j7ai.rkt:33:4\n\
    \nreverse: contract violation\n  expected: list?"
  stdout: ''
  timestamp: 1660040255
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (cons\
    \ (first word) (get_closest_vowel (rest word)))]))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (get_closest_vowel\
    \ (rest word))]\n  )\n)\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\"\
    ) \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:26:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:34:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:35:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:36:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (cons\
    \ (first word) (get_closest_vowel (rest word)))]))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (cons\
    \ (first word) (get_closest_vowel (rest word)))]))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (get_closest_vowel\
    \ (rest word))]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\") \"\
    u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond [(empty? word) \"\"]\n        [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n        [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n        [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n        [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \        [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n        [else\
    \ (cons (first word) (get_closest_vowel (rest word)))]))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmph8j7mhux.rkt:23:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmph8j7mhux.rkt:24:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmph8j7mhux.rkt:25:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmph8j7mhux.rkt:26:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmph8j7mhux.rkt:27:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmph8j7mhux.rkt:28:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmph8j7mhux.rkt:29:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmph8j7mhux.rkt:30:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmph8j7mhux.rkt:31:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmph8j7mhux.rkt:32:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmph8j7mhux.rkt:33:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (cons\
    \ (first word) (get_closest_vowel (rest word)))]))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (define (helper word vowel)\n    (cond\n \
    \     [(empty? word) \"\"]\n      [(equal? vowel (first word)) (second word)]\n\
    \      [else (helper (rest word) (first vowel))]))\n  (helper (reverse word) 'a))\n\
    \n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n\
    \    (check-equal? (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate\
    \ \"full\") \"u\")\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal?\
    \ (candidate \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n  \
    \  (check-equal? (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\"\
    ) \"o\")\n    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate\
    \ \"ba\") \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal?\
    \ (candidate \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n\
    \    (check-equal? (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpqo3zos1b.rkt:22:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"yogurt\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpqo3zos1b.rkt:23:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"full\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpqo3zos1b.rkt:24:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"easy\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpqo3zos1b.rkt:25:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"eAsy\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpqo3zos1b.rkt:26:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"ali\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpqo3zos1b.rkt:27:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"bad\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpqo3zos1b.rkt:28:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"most\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpqo3zos1b.rkt:29:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"ab\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpqo3zos1b.rkt:30:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"ba\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpqo3zos1b.rkt:31:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"quick\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpqo3zos1b.rkt:32:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"anime\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpqo3zos1b.rkt:33:4\n\
    \nreverse: contract violation\n  expected: list?"
  stdout: ''
  timestamp: 1660040255
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (get_closest_vowel\
    \ (rest word))]\n  ))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n \
    \ (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\"\
    ) \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpimsbc159.rkt:25:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpimsbc159.rkt:26:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpimsbc159.rkt:27:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpimsbc159.rkt:28:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpimsbc159.rkt:29:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpimsbc159.rkt:30:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpimsbc159.rkt:31:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpimsbc159.rkt:32:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpimsbc159.rkt:33:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpimsbc159.rkt:34:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpimsbc159.rkt:35:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040255
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (get_closest_vowel\
    \ (rest word))]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\") \"\
    u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (cons\
    \ (first word) (get_closest_vowel (rest word)))]))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (cons\
    \ (first word) (get_closest_vowel (rest word)))]))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (get_closest_vowel\
    \ (rest word))]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\") \"\
    u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (cons\
    \ (first word) (get_closest_vowel (rest word)))]))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond [(empty? word) \"\"]\n        [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n        [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n        [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n        [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \        [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n        [else\
    \ (cons (first word) (get_closest_vowel (rest word)))]))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmph8j7mhux.rkt:23:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmph8j7mhux.rkt:24:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmph8j7mhux.rkt:25:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmph8j7mhux.rkt:26:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmph8j7mhux.rkt:27:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmph8j7mhux.rkt:28:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmph8j7mhux.rkt:29:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmph8j7mhux.rkt:30:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmph8j7mhux.rkt:31:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmph8j7mhux.rkt:32:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmph8j7mhux.rkt:33:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (get_closest_vowel\
    \ (rest word))]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\") \"\
    u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (cons\
    \ (first word) (get_closest_vowel (rest word)))]))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (get_closest_vowel\
    \ (rest word))]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\") \"\
    u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (cons\
    \ (first word) (get_closest_vowel (rest word)))]))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (cons\
    \ (first word) (get_closest_vowel (rest word)))]))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (get_closest_vowel\
    \ (rest word))]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\") \"\
    u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (get_closest_vowel\
    \ (rest word))]\n  )\n)\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\"\
    ) \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:26:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:34:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:35:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:36:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (get_closest_vowel\
    \ (rest word))]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\") \"\
    u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (cons\
    \ (first word) (get_closest_vowel (rest word)))]))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (get_closest_vowel\
    \ (rest word))]\n  )\n)\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\"\
    ) \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:26:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:34:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:35:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:36:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (cons\
    \ (first word) (get_closest_vowel (rest word)))]))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (get_closest_vowel\
    \ (rest word))]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\") \"\
    u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (cons\
    \ (first word) (get_closest_vowel (rest word)))]))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 1
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (define (vowel-search vowel word)\n    (cond\n\
    \      [(empty? word) empty]\n      [(equal? vowel (first word)) vowel]\n    \
    \  [(vowel-search (first word) (substring (second word) 0 vowel)) (vowel-search\
    \ (first word) (substring (second word) (+ vowel 1) vowel))]\n      [(vowel-search\
    \ (first word) (substring (second word) (+ vowel 1) vowel)) (vowel-search (first\
    \ word) (substring (second word) 0 vowel))]\n      [(vowel-search (first word)\
    \ (substring (second word) 0 vowel)) (vowel-search (first word) (substring (second\
    \ word) (+ vowel 1) vowel))]\n      [(vowel-search (first word) (substring (second\
    \ word) (+ vowel 1) vowel)) (vowel-search (first word) (substring (second word)\
    \ 0 vowel))]\n      [(vowel-search (first word) (substring (second word) (+ vowel\
    \ 1) vowel)) (vowel-search (first word) (substring (second word) (+ vowel 1) vowel))]\n\
    \      [(vowel-search (first word) (substring (second word) (+ vowel 1) vowel))\
    \ (vowel-search (first word) (substring (second word) (+ vowel 1) vowel))]\n \
    \     [(vowel-search (first word) (substring (second word) (+ vowel 1) vowel))\
    \ (vowel-search (first word) (substring (second word) (+ vowel 1) vowel))]\n \
    \     [(vowel-search (first word) (substring (second word) (+ vowel 1) vowel))\
    \ (vowel-search (first word) (substring (second word) (+ vowel 1) vowel))]\n \
    \     [(vowel-search (first word) (substring (second word) (+ vowel 1) vowel))\
    \ (vowel-search (first word) (substring (second word) (+ vowel 1) vowel))]\n \
    \     [(vowel-search (first word) (substring (second word) (+ vowel 1) vowel))\
    \ (vowel-search (first word) (substring (second word) (+ vowel 1) vowel))]\n \
    \     [(vowel-search (first word) (substring (second word) (+ vowel 1) vowel))\
    \ (vowel-search (first word) (substring (second word) (+ vowel 1) vowel))]\n \
    \     [(vowel-search (first word) (substring (second word) (+ vowel 1) vowel))\
    \ (vowel-search (first word) (substring (second word) (+ vowel 1) vowel))]\n \
    \     [(vowel-search (first word) (sub\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"\
    yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal?\
    \ (candidate \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n \
    \   (check-equal? (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\"\
    ) \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate\
    \ \"ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal?\
    \ (candidate \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n\
    \    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"\
    Above\") \"o\")\n))\n\n(test-humaneval)"
  status: SyntaxError
  stderr: "/tmp/tmpitiu3o6u.rkt:26:34: read-syntax: expected a `)` to close `(`\n\
    \  possible cause: indentation suggests a missing `)` before line 27\n  context...:\n\
    \   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /work/arjunguha-research-group/software/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  stdout: ''
  timestamp: 1660040255
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (get_closest_vowel\
    \ (rest word))]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\") \"\
    u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (get_closest_vowel\
    \ (rest word))]\n  )\n)\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\"\
    ) \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:26:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:34:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:35:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:36:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (cons\
    \ (first word) (get_closest_vowel (rest word)))]))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (define (vowel-check vowel word)\n    (cond\n\
    \      [(empty? word) empty]\n      [(equal? vowel (first word)) (cons (first\
    \ word) (vowel-check vowel (rest word)))]\n      [else (vowel-check vowel (rest\
    \ word))]))\n  (vowel-check (first word) word))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpm1vz3_e3.rkt:22:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpm1vz3_e3.rkt:23:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpm1vz3_e3.rkt:24:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpm1vz3_e3.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpm1vz3_e3.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpm1vz3_e3.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpm1vz3_e3.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpm1vz3_e3.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpm1vz3_e3.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpm1vz3_e3.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpm1vz3_e3.rkt:32:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040256
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (define (helper word vowel consonant)\n  \
    \  (cond\n      [(empty? word) \"\"]\n      [(equal? vowel (first word)) (second\
    \ word)]\n      [else (helper (rest word) (first vowel) (consonant (first word)))]))\n\
    \  (helper (reverse word) 'a #\\a))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"\
    yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal?\
    \ (candidate \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n \
    \   (check-equal? (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\"\
    ) \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate\
    \ \"ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal?\
    \ (candidate \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n\
    \    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"\
    Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp619j64m9.rkt:22:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"yogurt\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp619j64m9.rkt:23:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"full\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp619j64m9.rkt:24:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"easy\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp619j64m9.rkt:25:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"eAsy\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp619j64m9.rkt:26:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"ali\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp619j64m9.rkt:27:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"bad\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp619j64m9.rkt:28:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"most\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp619j64m9.rkt:29:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"ab\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp619j64m9.rkt:30:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"ba\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp619j64m9.rkt:31:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"quick\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp619j64m9.rkt:32:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"anime\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp619j64m9.rkt:33:4\n\
    \nreverse: contract violation\n  expected: list?"
  stdout: ''
  timestamp: 1660040256
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (cons\
    \ (first word) (get_closest_vowel (rest word)))]))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (define (vowel-check word)\n    (cond [(empty?\
    \ word) \"\"]\n          [(char=? (first word) 'a) (cons (first word) (vowel-check\
    \ (rest word)))]\n          [(char=? (first word) 'e) (cons (first word) (vowel-check\
    \ (rest word)))]\n          [(char=? (first word) 'i) (cons (first word) (vowel-check\
    \ (rest word)))]\n          [(char=? (first word) 'o) (cons (first word) (vowel-check\
    \ (rest word)))]\n          [(char=? (first word) 'u) (cons (first word) (vowel-check\
    \ (rest word)))]\n          [else (vowel-check (rest word))]))\n  (vowel-check\
    \ word))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ get_closest_vowel))\n    (check-equal? (candidate \"yogurt\") \"u\")\n    (check-equal?\
    \ (candidate \"full\") \"u\")\n    (check-equal? (candidate \"easy\") \"\")\n\
    \    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal? (candidate \"\
    ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n    (check-equal?\
    \ (candidate \"most\") \"o\")\n    (check-equal? (candidate \"ab\") \"\")\n  \
    \  (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate \"quick\"\
    ) \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal? (candidate\
    \ \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp1m81hras.rkt:25:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp1m81hras.rkt:26:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp1m81hras.rkt:27:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp1m81hras.rkt:28:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp1m81hras.rkt:29:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp1m81hras.rkt:30:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp1m81hras.rkt:31:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp1m81hras.rkt:32:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp1m81hras.rkt:33:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp1m81hras.rkt:34:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp1m81hras.rkt:35:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040256
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (get_closest_vowel\
    \ (rest word))]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\") \"\
    u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (get_closest_vowel\
    \ (rest word))]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\") \"\
    u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (get_closest_vowel\
    \ (rest word))]\n  )\n)\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\"\
    ) \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:26:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:34:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:35:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:36:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (define (helper word vowel vowel-index vowel-count)\n\
    \    (cond [(vowel-count > 0)\n           (if (and (vowel-index > 0)\n       \
    \             (vowel-index <= (length word)))\n               (helper (substring\
    \ word 0 vowel-index) (vowel vowel-index) vowel-index (add1 vowel-count))\n  \
    \             (helper (substring word 0 vowel-index) vowel vowel-index vowel-count))\n\
    \           vowel]\n          [(vowel-count = 0)\n           (if (and (vowel-index\
    \ > 0)\n                    (vowel-index <= (length word)))\n               (helper\
    \ (substring word 0 vowel-index) vowel vowel-index vowel-count)\n            \
    \   (helper (substring word 0 vowel-index) vowel vowel-index vowel-count))\n \
    \          \"\"]\n          [else\n           (helper (substring word 0 vowel-index)\
    \ vowel vowel-index vowel-count)\n           \"\"]))\n  (helper word 'a 0 0))\n\
    \n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n\
    \    (check-equal? (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate\
    \ \"full\") \"u\")\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal?\
    \ (candidate \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n  \
    \  (check-equal? (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\"\
    ) \"o\")\n    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate\
    \ \"ba\") \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal?\
    \ (candidate \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n\
    \    (check-equal? (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmppn3tceg_.rkt:33:4\n\
    \napplication: not a procedure;\n expected a procedure that can be applied to\
    \ arguments\n  given: 0\n--------------------\n--------------------\nERROR\nname:\
    \       check-equal?\nlocation:   /tmp/tmppn3tceg_.rkt:34:4\n\napplication: not\
    \ a procedure;\n expected a procedure that can be applied to arguments\n  given:\
    \ 0\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmppn3tceg_.rkt:35:4\n\napplication: not a procedure;\n expected\
    \ a procedure that can be applied to arguments\n  given: 0\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmppn3tceg_.rkt:36:4\n\
    \napplication: not a procedure;\n expected a procedure that can be applied to\
    \ arguments\n  given: 0\n--------------------\n--------------------\nERROR\nname:\
    \       check-equal?\nlocation:   /tmp/tmppn3tceg_.rkt:37:4\n\napplication: not\
    \ a procedure;\n expected a procedure that can be applied to arguments\n  given:\
    \ 0\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmppn3tceg_.rkt:38:4\n\napplication: not a procedure;\n expected\
    \ a procedure that can be applied to arguments\n  given: 0\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmppn3tceg_.rkt:39:4\n\
    \napplication: not a procedure;\n expected a procedure that can be applied to\
    \ arguments\n  given: 0\n--------------------\n--------------------\nERROR\nname:\
    \       check-equal?\nlocation:   /tmp/tmppn3tceg_.rkt:40:4\n\napplication: not\
    \ a procedure;\n expected a procedure that can be applied to arguments\n  given:\
    \ 0\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmppn3tceg_.rkt:41:4\n\napplication: not a procedure;\n expected\
    \ a procedure that can be applied to arguments\n  given: 0\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmppn3tceg_.rkt:42:4\n\
    \napplication: not a procedure;\n expected a procedure that can be applied to\
    \ arguments\n"
  stdout: ''
  timestamp: 1660040256
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (get_closest_vowel\
    \ (rest word))]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\") \"\
    u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (define (vowel-check vowel word)\n    (cond\n\
    \      [(empty? word) empty]\n      [(equal? vowel (first word)) (vowel-check\
    \ vowel (rest word))]\n      [else (vowel-check vowel (rest word))]\n      ))\n\
    \  (vowel-check (first word) (substring (second word) 0 (- (length word) 2))))\n\
    \n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n\
    \    (check-equal? (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate\
    \ \"full\") \"u\")\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal?\
    \ (candidate \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n  \
    \  (check-equal? (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\"\
    ) \"o\")\n    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate\
    \ \"ba\") \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal?\
    \ (candidate \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n\
    \    (check-equal? (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp0t3_3btw.rkt:23:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp0t3_3btw.rkt:24:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp0t3_3btw.rkt:25:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp0t3_3btw.rkt:26:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp0t3_3btw.rkt:27:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp0t3_3btw.rkt:28:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp0t3_3btw.rkt:29:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp0t3_3btw.rkt:30:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp0t3_3btw.rkt:31:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp0t3_3btw.rkt:32:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp0t3_3btw.rkt:33:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040256
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (get_closest_vowel\
    \ (rest word))]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\") \"\
    u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (cons\
    \ (first word) (get_closest_vowel (rest word)))]))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 1
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (define (helper word vowel start end)\n  \
    \  (cond [(null? word) \"\"]\n          [(equal? (char-code (car word)) vowel)\
    \ (helper (cdr word) vowel (+ start 1) end)]\n          [(equal? (char-code (car\
    \ word)) (substring vowel 0 1)) \n           (helper (cdr word) (substring vowel\
    \ 1 end) start (+ end 1))]\n          [else (helper (cdr word) vowel (+ start\
    \ 1) end)]\n          ))\n  (helper word 'a '0 (length word)))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "/tmp/tmpa7ducq3b.rkt:12:20: char-code: unbound identifier\n  in: char-code\n\
    \  location...:\n   /tmp/tmpa7ducq3b.rkt:12:20\n"
  stdout: ''
  timestamp: 1660040256
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (get_closest_vowel\
    \ (rest word))]\n  )\n)\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\"\
    ) \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:26:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:34:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkpl19tfq.rkt:35:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpl19tfq.rkt:36:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (define (vowel-check word)\n    (cond [(empty?\
    \ word) empty]\n          [(equal? (first word) 'a) (cons (first word) (vowel-check\
    \ (rest word)))]\n          [(equal? (first word) 'e) (cons (first word) (vowel-check\
    \ (rest word)))]\n          [(equal? (first word) 'i) (cons (first word) (vowel-check\
    \ (rest word)))]\n          [(equal? (first word) 'o) (cons (first word) (vowel-check\
    \ (rest word)))]\n          [(equal? (first word) 'u) (cons (first word) (vowel-check\
    \ (rest word)))]\n          [else (vowel-check (rest word))]))\n  (vowel-check\
    \ word))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ get_closest_vowel))\n    (check-equal? (candidate \"yogurt\") \"u\")\n    (check-equal?\
    \ (candidate \"full\") \"u\")\n    (check-equal? (candidate \"easy\") \"\")\n\
    \    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal? (candidate \"\
    ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n    (check-equal?\
    \ (candidate \"most\") \"o\")\n    (check-equal? (candidate \"ab\") \"\")\n  \
    \  (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate \"quick\"\
    ) \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal? (candidate\
    \ \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmplpklz6z2.rkt:25:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmplpklz6z2.rkt:26:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmplpklz6z2.rkt:27:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmplpklz6z2.rkt:28:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmplpklz6z2.rkt:29:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmplpklz6z2.rkt:30:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmplpklz6z2.rkt:31:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmplpklz6z2.rkt:32:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmplpklz6z2.rkt:33:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmplpklz6z2.rkt:34:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmplpklz6z2.rkt:35:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040256
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (cons\
    \ (first word) (get_closest_vowel (rest word)))]))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (cons\
    \ (first word) (get_closest_vowel (rest word)))]))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (get_closest_vowel\
    \ (rest word))]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\") \"\
    u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (cons\
    \ (first word) (get_closest_vowel (rest word)))]))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_aguw633.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_aguw633.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
- exit_code: 0
  program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    (define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"]\n    [(equal?\
    \ (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'i) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel (rest word))]\n\
    \    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n    [else (get_closest_vowel\
    \ (rest word))]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\") \"\
    u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbc0nouh0.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbc0nouh0.rkt:34:4\n\nfirst:\
    \ con"
  stdout: ''
  timestamp: 1660040254
