name: HumanEval_99_closest_integer
language: rkt
prompt: "#lang racket\n\n;; Create a function that takes a value (string) representing\
  \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
  ;; from two integers, round it away from zero.\n;; Examples\n;; Note:\n;; Rounding\
  \ away from zero means that if the given number is equidistant\n;; from two integers,\
  \ the one you should return is the one that is the\n;; farthest from zero. For example\
  \ closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"-14.5\")\
  \ should return -15.\n(define (closest_integer value)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n\
  \    (check-equal? (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\"\
  ) 15)\n    (check-equal? (candidate \"-15.5\") -16)\n    (check-equal? (candidate\
  \ \"15.3\") 15)\n    (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
completions: ["  (let ([x (string->number (car value))\n        y (+ (string->number\
    \ (cadr value)) (* -1 x))])\n    (cond\n      [(< x y) value]\n      [else (round\
    \ (/ y x))]))\n  ", "  (let ([num (string->number (string->symbol value))])\n\
    \    (cond\n      [(< num 0) (error \"The given value is not a number\")]\n  \
    \    [(< num 1) (error \"The given value is not a number\")]\n      [(< num 2)\
    \ (error \"The given value is not a number\")]\n      [(< num 3) (error \"The\
    \ given value is not a number\")]\n      [(< num 4) (error \"The given value is\
    \ not a number\")]\n      [(< num 5) (error \"The given value is not a number\"\
    )]\n      [(< num 6) (error \"The given value is not a number\")]\n      [(< num\
    \ 7) (error \"The given value is not a number\")]\n      [(< num 8) (error \"\
    The given value is not a number\")]\n      [(< num 9) (error \"The given value\
    \ is not a number\")]\n      [(< num 10) (error \"The given value is not a number\"\
    )]\n      [(< num 11) (error \"The given value is not a number\")]\n      [(<\
    \ num 12) (error \"The given value is not a number\")]\n      [(< num 13) (error\
    \ \"The given value is not a number\")]\n      [(< num 14) (error \"The given\
    \ value is not a number\")]\n      [(< num 15) (error \"The given value is not\
    \ a number\")]\n      [(< num 16) (error \"The given value is not a number\")]\n\
    \      [(< num 17) (error \"The given value is not a number\")]\n      [(< num\
    \ 18) (error \"The given value is not a number\")]\n      [(< num 19) (error \"\
    The given value is not a number\")]\n      [(< num 20) (error \"The given value\
    \ is not a number\")]\n      [(< num 21) (error \"The given value is not a number\"\
    )]\n      [(< num 22) (error \"The given value is not a number\")]\n      [(<\
    \ num 23) (error \"The given value is not a number\")]\n      [(< num 24) (error\
    \ \"The given value is not a number\")]\n      [(< num 25) (error \"The given\
    \ value is not a number\")]\n      [(< num 26) (error \"The given value is not\
    \ a number\")]\n      [(< num 27) (error \"The given value is not a number\")]\n\
    \      [(< num 28) (error \"The given value is not a number\")]\n      [(< num\
    \ 29) (error \"The given value is not a number\")]\n      [(< num 30) (error \"\
    The given value is not a number\")]\n      [(< num 31) (error \"The given value\
    \ is not a number\")]\n      [(< num 32) (error \"The given value is not a number\"\
    )]", "  (let ([int-value (string->number (string->symbol value))])\n    (cond\n\
    \      [(< int-value 0) (ceiling int-value)]\n      [(> int-value 0) (floor int-value)]\n\
    \      [else int-value])))\n", "  (let ([num (string->number value)]\n       \
    \ [nums (number->list num)])\n    (if (< (length nums) 2)\n        (let ([closest\
    \ (expt (first nums) (/ (first nums) (second nums)))])\n          (if (= closest\
    \ 0)\n              (expt (second nums) (/ (second nums) (first nums)))\n    \
    \          (expt closest 2))))\n    (expt (first nums) (/ (first nums) (second\
    \ nums)))))\n", "  (let ([x (parse-integer value)]\n        [y (parse-integer\
    \ value)])\n    (cond [(< x y)\n           (ceiling x)]\n          [(< y x)\n\
    \           (ceiling y)]\n          [else\n           (floor x)])))\n", "  (let\
    \ ((x (floor (/ value 10))))\n    (cond\n      [(< x 9) (+ x 10)]\n      [(< x\
    \ 8) (+ x 10)]\n      [(< x 7) (+ x 10)]\n      [(< x 6) (+ x 10)]\n      [(<\
    \ x 5) (+ x 10)]\n      [(< x 4) (+ x 10)]\n      [(< x 3) (+ x 10)]\n      [(<\
    \ x 2) (+ x 10)]\n      [(< x 1) (+ x 10)]\n      [else x])))\n", "  (let ([x\
    \ (number->string value)]\n        [y (number->string value)])\n    (cond\n  \
    \    [(equal? x y) value]\n      [(number->boolean? value) (round value)]\n  \
    \    [else (round (number->float (string->number x)))])))\n", "  (let ([numbers\
    \ (number->list value)])\n    (let ([closest (first numbers)])\n      (if (null?\
    \ numbers)\n          closest\n          (let ([next (second numbers)])\n    \
    \        (if (> (abs (- next closest)) (abs (- closest next)))\n             \
    \   (closest_integer value)\n                (closest_integer next)))))\n    closest))\n",
  "  (let ([x (string->number (car value))])\n    (let ([y (string->number (cadr value))])\n\
    \      (if (and (number? x) (number? y))\n          (if (< (abs (- x y)) (/ x\
    \ y))\n              (- x y)\n              (- y x))\n          (if (< (abs (-\
    \ x y)) (/ x y))\n              (- x y)\n              (- y x))\n          (if\
    \ (< (abs (- x y)) (/ x y))\n              (- x y)\n              (- y x))\n \
    \         (if (< (abs (- x y)) (/ x y))\n              (- x y)\n             \
    \ (- y x))\n          (if (< (abs (- x y)) (/ x y))\n              (- x y)\n \
    \             (- y x))\n          (if (< (abs (- x y)) (/ x y))\n            \
    \  (- x y)\n              (- y x))\n          (if (< (abs (- x y)) (/ x y))\n\
    \              (- x y)\n              (- y x))\n          (if (< (abs (- x y))\
    \ (/ x y))\n              (- x y)\n              (- y x))\n          (if (< (abs\
    \ (- x y)) (/ x y))\n              (- x y)\n              (- y x))\n         \
    \ (if (< (abs (- x y)) (/ x y))\n              (- x y)\n              (- y x))\n\
    \          (if (< (abs (- x y)) (/ x y))\n              (- x y)\n            \
    \  (- y x))\n          (if (< (abs (- x y)) (/ x y))\n              (- x y)\n\
    \              (- y x))\n          (if (< (abs (- x y)) (/ x y))\n           \
    \   (- x y)\n              (- y x))\n          (if (< (abs (- x y)) (/ x y))\n\
    \              (- x y)\n              (- y x))\n          (if (< (abs (- x y))\
    \ (/ x y))\n              (- x y)\n              (- y x))\n          (if (< (abs\
    \ (- x y)) (/ x y))\n              (- x y)\n              (- y x))\n         \
    \ (if (< (abs (- x y)) (/ x y))\n              (- x y)\n              (- y x))\n\
    \          (if (< (abs (- x y)) (/ x y))\n              (", "  (let ([int-value\
    \ (string->number (string->symbol value))])\n    (cond\n      [(< int-value 0)\
    \ (error \"Given value is not a number\")]\n      [(< int-value 1) (error \"Given\
    \ value is not a number\")]\n      [else (round (abs (- int-value 1)))])))\n",
  "  (let ([integer (parse-integer value)]\n        [integers (list integer)]\n  \
    \      [closest (first integers)])\n    (if (null? integers)\n        integer\n\
    \        (let ([next (second integers)])\n          (if (> (abs (- value next))\
    \ (abs (- value integer)))\n              (cons integer integers)\n          \
    \    (cons next integers))))))\n", "  (let ([x (string->number (car value))])\n\
    \    (let ([y (string->number (cadr value))])\n      (if (= x y)\n          x\n\
    \          (if (< (abs (- x y)) (abs x))\n              (ceiling x)\n        \
    \      (floor x))))))\n", "  (let ([num (string->number (car value))])\n    (cond\n\
    \      [(< num 0) (error \"Closest integer not possible for negative numbers\"\
    )]\n      [(< num 1) (error \"Closest integer not possible for numbers that are\
    \ equidistant from two integers\")]\n      [else (round (/ (- num 1) num))]))))\n",
  "  (let ((closest-integer (min (abs (- value 1))\n                             \
    \  (abs (- value 2)))))\n    (if (= closest-integer 0)\n        (- value)\n  \
    \      closest-integer)))\n", "  (let ((x (string->number (car value))))\n   \
    \ (let ((y (string->number (cadr value))))\n      (cond\n        ((= x y) value)\n\
    \        ((< (abs (- x y)) (abs x))\n         (ceiling value))\n        ((> (abs\
    \ (- x y)) (abs x))\n         (floor value))\n        (else (error \"Closest integer\
    \ not possible\"))))))\n", "  (let ([x (string->number (car value))])\n    (let\
    \ ([y (string->number (cadr value))])\n      (if (< (abs (- x y)) (abs x))\n \
    \         (ceiling x)\n          (floor (- x)))\n      (closest_integer (list\
    \ x y)))))\n", "  (let ([num (string->number (car value))])\n    (cond\n     \
    \ [(< num 0) (- 0 (floor (- num)))]\n      [(< num 1) (- 0 (floor (- num)))]\n\
    \      [(< num 2) (- 0 (floor (- num)))]\n      [(< num 3) (- 0 (floor (- num)))]\n\
    \      [(< num 4) (- 0 (floor (- num)))]\n      [(< num 5) (- 0 (floor (- num)))]\n\
    \      [(< num 6) (- 0 (floor (- num)))]\n      [(< num 7) (- 0 (floor (- num)))]\n\
    \      [(< num 8) (- 0 (floor (- num)))]\n      [(< num 9) (- 0 (floor (- num)))]\n\
    \      [(< num 10) (- 0 (floor (- num)))]\n      [(< num 11) (- 0 (floor (- num)))]\n\
    \      [(< num 12) (- 0 (floor (- num)))]\n      [(< num 13) (- 0 (floor (- num)))]\n\
    \      [(< num 14) (- 0 (floor (- num)))]\n      [(< num 15) (- 0 (floor (- num)))]\n\
    \      [(< num 16) (- 0 (floor (- num)))]\n      [(< num 17) (- 0 (floor (- num)))]\n\
    \      [(< num 18) (- 0 (floor (- num)))]\n      [(< num 19) (- 0 (floor (- num)))]\n\
    \      [(< num 20) (- 0 (floor (- num)))]\n      [(< num 21) (- 0 (floor (- num)))]\n\
    \      [(< num 22) (- 0 (floor (- num)))]\n      [(< num 23) (- 0 (floor (- num)))]\n\
    \      [(< num 24) (- 0 (floor (- num)))]\n      [(< num 25) (- 0 (floor (- num)))]\n\
    \      [(< num 26) (- 0 (floor (- num)))]\n      [(< num 27) (- 0 (floor (- num)))]\n\
    \      [(< num 28) (- 0 (floor (- num)))]\n      [(< num 29) (- 0 (floor (- num)))]\n\
    \      [(< num 30) (- 0 (floor (- num)))]\n      [(< num 31) (- 0 (floor (- num)))]\n\
    \      [(< num 32) (- 0 (floor (- num)))]\n", "  (let ([x (number->string value)]\n\
    \        [y (number->string value)])\n    (cond\n      [(equal? x y) value]\n\
    \      [(equal? x \"-\") (- 0 (string->number y))] \n      [(equal? y \"-\") (-\
    \ 0 (string->number x))]\n      [(equal? x \"0\") (- 0 (string->number y))] \n\
    \      [(equal? y \"0\") (- 0 (string->number x))]\n      [else (- 0 (string->number\
    \ x))])))\n", "  (let ([integers (map number->integer '(1 2 3 4 5 6 7 8 9 10 11\
    \ 12 13 14 15))])\n    (let ([closest (first integers)])\n      (if (< (abs (-\
    \ value closest)) (abs (- value integers)))\n          closest\n          (closest_integer\
    \ value))))))\n", "  (let ((closest (min (floor (/ value 10)) (floor (/ value\
    \ 10))))\n        (closest-to (floor (/ value 10)))\n        (closest-to (floor\
    \ (/ value 10))))\n    (cond\n      [(< value closest)\n       (min (floor (/\
    \ value 10)) (floor (/ value 10)))]\n      [(< closest closest-to)\n       (min\
    \ (floor (/ value 10)) (floor (/ value 10)))]\n      [(< closest-to closest)\n\
    \       (min (floor (/ value 10)) (floor (/ value 10)))]\n      [else\n      \
    \ closest])))\n", "  (let ([x (string->number (car value))])\n    (let ([y (string->number\
    \ (cadr value))])\n      (cond\n        ((< x y) (value->string x))\n        ((<\
    \ y x) (value->string y))\n        (else (value->string (value->number ((- x y))))))))\n",
  "  (let ([integers (map integer->real '(1 2 3 4 5 6 7 8 9))])\n    (let ([closest-integer\
    \ (first integers)])\n      (if (< (abs (- value closest-integer)) (abs (- value\
    \ integer)))\n          closest-integer\n          (let ([closest-integer (first\
    \ integers)])\n            (if (< (abs (- value closest-integer)) (abs (- value\
    \ integer)))\n                closest-integer\n                (let ([closest-integer\
    \ (first integers)])\n                  (if (< (abs (- value closest-integer))\
    \ (abs (- value integer)))\n                      closest-integer\n          \
    \            (let ([closest-integer (first integers)])\n                     \
    \   (if (< (abs (- value closest-integer)) (abs (- value integer)))\n        \
    \                    closest-integer\n                            (let ([closest-integer\
    \ (first integers)])\n                              (if (< (abs (- value closest-integer))\
    \ (abs (- value integer)))\n                                  closest-integer\n\
    \                                  (let ([closest-integer (first integers)])\n\
    \                                    (if (< (abs (- value closest-integer)) (abs\
    \ (- value integer)))\n                                        closest-integer\n\
    \                                        (let ([closest-integer (first integers)])\n\
    \                                          (if (< (abs (- value closest-integer))\
    \ (abs (- value integer)))\n                                              closest-integer\n\
    \                                              (let ([closest-integer (first integers)])\n\
    \                                                (if (< (abs (- value closest-integer))\
    \ (abs (- value integer)))\n                                                 \
    \   closest-integer\n                                                    (let\
    \ ([closest-integer (first integers)])\n                                     \
    \                 (if (< (abs (- value closest-integer)) (abs (- value integer)))\n\
    \                                                          closest-integer\n \
    \                                                         (let ([closest-integer\
    \ (first integers)])\n                                                       \
    \     (if (< (abs (- value closest-integer)) (abs (- value integer)))\n      \
    \                                                          closest-integer\n \
    \                                                               (let ([closest-integer\
    \ (first integers)])\n                                                       \
    \           (if (< (abs (- value closest-integer)) (abs (- value integer)))\n\
    \                                                                      closest-integer\n\
    \                                                                      (let ([closest-integer\
    \ (first integers)])\n                                                       \
    \                 (if (< (abs (- value closest-integer)) (abs (- value integer)))\n\
    \                                                                            closest-integer\n\
    \                                                                            (let\
    \ ([closest-integer (first integers)])\n                                     \
    \                                         (if (< (abs (- value closest-integer))\
    \ (abs (- value integer)))\n                                                 \
    \                                 closest-integer\n                          \
    \                                                        (let ([closest-integer",
  "  (let ([int-value (string->number (string->symbol value))])\n    (cond [(< int-value\
    \ 0) (- int-value 1)]\n          [(< int-value 1) (- int-value 2)]\n         \
    \ [(< int-value 2) (- int-value 3)]\n          [(< int-value 3) (- int-value 4)]\n\
    \          [(< int-value 4) (- int-value 5)]\n          [(< int-value 5) (- int-value\
    \ 6)]\n          [(< int-value 6) (- int-value 7)]\n          [(< int-value 7)\
    \ (- int-value 8)]\n          [(< int-value 8) (- int-value 9)]\n          [(<\
    \ int-value 9) (- int-value 10)]\n          [(< int-value 10) (- int-value 11)]\n\
    \          [(< int-value 11) (- int-value 12)]\n          [(< int-value 12) (-\
    \ int-value 13)]\n          [(< int-value 13) (- int-value 14)]\n          [(<\
    \ int-value 14) (- int-value 15)]\n          [(< int-value 15) (- int-value 16)]\n\
    \          [(< int-value 16) (- int-value 17)]\n          [(< int-value 17) (-\
    \ int-value 18)]\n          [(< int-value 18) (- int-value 19)]\n          [(<\
    \ int-value 19) (- int-value 20)]\n          [(< int-value 20) (- int-value 21)]\n\
    \          [(< int-value 21) (- int-value 22)]\n          [(< int-value 22) (-\
    \ int-value 23)]\n          [(< int-value 23) (- int-value 24)]\n          [(<\
    \ int-value 24) (- int-value 25)]\n          [(< int-value 25) (- int-value 26)]\n\
    \          [(< int-value 26) (- int-value 27)]\n          [(< int-value 27) (-\
    \ int-value 28)]\n          [(< int-value 28) (- int-value 29)]\n          [(<\
    \ int-value 29) (- int-value 30)]\n          [(< int-value 30) (- int-value 31)]\n\
    \          [(< int-value 31) (- int-value 32)]\n          [(< int-value 32) (-\
    \ int-value 33)]\n          [(", "  (let ([int-val (string->number (car value))])\n\
    \    (let ([int-val-diff (abs (- int-val 1))])\n      (cond\n        ((< int-val-diff\
    \ 1) (ceiling int-val))\n        ((> int-val-diff 1) (floor int-val))\n      \
    \  (else int-val))))))\n", "  (define (closest-integer-helper value min max)\n\
    \    (cond ((< value max) (+ min 1))\n          ((< value min) (+ max 1))\n  \
    \        ((= value max) (+ min 1))\n          ((= value min) (+ max 1))\n    \
    \      (else (closest-integer-helper value (+ min 1) (+ max 1)))))\n  (closest-integer-helper\
    \ value 1 100))\n", "  (let ((closest-integer (min (abs (- value 1))\n       \
    \                        (abs (- value 2)))))\n    (if (= closest-integer 0)\n\
    \        0\n        (+ closest-integer 1))))\n", "  (let ([x (parse-integer (string->list\
    \ value))])\n    (if (= x 0)\n        0\n        (let ([y (parse-integer (string->list\
    \ \"0\"))])\n          (if (= x y)\n              (- y)\n              (- x))))))\n",
  "  (let ([x (string->number (car value))])\n    (let ([y (string->number (cadr value))])\n\
    \      (if (and (number? x) (number? y))\n          (if (= x y)\n            \
    \  (round x)\n              (round (- x y)))\n          (round (- x y)))))))\n",
  "  (let ([x (parse-integer (string->symbol (string->symbol value)))])\n    (cond\
    \ [(< x 0) (parse-integer 0)]\n          [(< x 1) (parse-integer 1)]\n       \
    \   [(< x 2) (parse-integer 2)]\n          [(< x 3) (parse-integer 3)]\n     \
    \     [(< x 4) (parse-integer 4)]\n          [(< x 5) (parse-integer 5)]\n   \
    \       [(< x 6) (parse-integer 6)]\n          [(< x 7) (parse-integer 7)]\n \
    \         [(< x 8) (parse-integer 8)]\n          [(< x 9) (parse-integer 9)]\n\
    \          [(< x 10) (parse-integer 10)]\n          [(< x 11) (parse-integer 11)]\n\
    \          [(< x 12) (parse-integer 12)]\n          [(< x 13) (parse-integer 13)]\n\
    \          [(< x 14) (parse-integer 14)]\n          [(< x 15) (parse-integer 15)]\n\
    \          [(< x 16) (parse-integer 16)]\n          [(< x 17) (parse-integer 17)]\n\
    \          [(< x 18) (parse-integer 18)]\n          [(< x 19) (parse-integer 19)]\n\
    \          [(< x 20) (parse-integer 20)]\n          [(< x 21) (parse-integer 21)]\n\
    \          [(< x 22) (parse-integer 22)]\n          [(< x 23) (parse-integer 23)]\n\
    \          [(< x 24) (parse-integer 24)]\n          [(< x 25) (parse-integer 25)]\n\
    \          [(< x 26) (parse-integer 26)]\n          [(< x 27) (parse-integer 27)]\n\
    \          [(< x 28) (parse-integer 28)]\n          [(< x 29) (parse-integer 29)]\n\
    \          [(< x 30) (parse-integer 30)]\n          [(< x 31) (parse-integer 31)]\n\
    \          [(< x 32) (parse-integer 32)]\n          [(< x 33) (parse-integer 33)]\n\
    \          [(< x 34) (parse-integer 34)]\n          [(< x 35) (parse-integer 35)]\n\
    \          [(< x 36) (parse-integer 36)]\n          [(< x 37) (parse-integer 37)]\n\
    \          [(< x 38) (parse-integer 38)]\n          [(< x 39) (parse-integer 39)]\n\
    \          [(< x 40) (parse-integer 40)]\n", "  (let ([x (parse-integer value)]\n\
    \        [y (parse-integer value)])\n    (cond [(< x y) x]\n          [(> x y)\
    \ y]\n          [else (round (- x y))])))\n", "  (let ([integer (floor (/ value\
    \ 10)))]\n        (if (= (- value integer) 0)\n            integer\n         \
    \   (closest_integer (- value integer)))))\n", "  (let ([x (string->number (car\
    \ value))])\n    (let ([y (string->number (cadr value))])\n      (cond\n     \
    \   ((= x y) value)\n        ((< (abs (- x y)) (abs x))\n         (ceiling value))\n\
    \        (else (floor value)))))\n", "  (let ([integers (map number->integer (split-string\
    \ (number->string value) \".\")))]\n    (if (null? integers)\n        0\n    \
    \    (let ([closest (car integers)])\n          (if (< (abs (- value closest))\
    \ (abs (- value (car integers))))\n              (abs (- value closest))\n   \
    \           (abs (- value (car integers)))))))\n    (if (null? (cdr integers))\n\
    \        (abs (- value (car integers)))\n        (let ([closest (car integers)])\n\
    \          (if (< (abs (- value closest)) (abs (- value (cdr integers))))\n  \
    \            (abs (- value closest))\n              (abs (- value (cdr integers)))))))\n\
    \    (if (null? (cdr integers))\n        (abs (- value (cdr integers)))\n    \
    \    (let ([closest (car integers)])\n          (if (< (abs (- value closest))\
    \ (abs (- value (cdr integers))))\n              (abs (- value closest))\n   \
    \           (abs (- value (cdr integers)))))))\n    (if (null? (cdr integers))\n\
    \        (abs (- value (cdr integers)))\n        (let ([closest (car integers)])\n\
    \          (if (< (abs (- value closest)) (abs (- value (cdr integers))))\n  \
    \            (abs (- value closest))\n              (abs (- value (cdr integers)))))))\n\
    \    (if (null? (cdr integers))\n        (abs (- value (cdr integers)))\n    \
    \    (let ([closest (car integers)])\n          (if (< (abs (- value closest))\
    \ (abs (- value (cdr integers))))\n              (abs (- value closest))\n   \
    \           (abs (- value (cdr integers)))))))\n    (if (null? (cdr integers))\n\
    \        (abs (- value (cdr integers)))\n        (let ([closest (car integers)])\n\
    \          (if (< (abs (- value closest)) (abs (- value (cdr integers))))\n  \
    \            (abs (- value closest))\n              (abs (- value (cdr integers)))))))\n\
    \    (if (null? (cdr integers))\n        (abs (- value (cdr integers)))\n    \
    \    (let ([closest (car integers)])\n          (if (< (abs (- value closest))\
    \ (abs (- value (cdr integers))))\n              ", "  (let ((x (floor (/ value\
    \ 10))))\n    (cond\n      [(< x 0) (ceil (/ value 10))]\n      [(< x 1) (ceil\
    \ (/ value 10))]\n      [(< x 2) (ceil (/ value 10))]\n      [(< x 3) (ceil (/\
    \ value 10))]\n      [(< x 4) (ceil (/ value 10))]\n      [(< x 5) (ceil (/ value\
    \ 10))]\n      [(< x 6) (ceil (/ value 10))]\n      [(< x 7) (ceil (/ value 10))]\n\
    \      [(< x 8) (ceil (/ value 10))]\n      [(< x 9) (ceil (/ value 10))]\n  \
    \    [else (ceil (/ value 10))]\n    ])))\n", "  (let ([number-string (number->string\
    \ value)])\n    (if (equal? number-string \"\")\n        0\n        (let ([number-string\
    \ (number->string value)])\n          (if (equal? number-string \"\")\n      \
    \        0\n              (let ([number-string (number->string value)])\n    \
    \            (if (equal? number-string \"\")\n                    0\n        \
    \            (let ([number-string (number->string value)])\n                 \
    \     (if (equal? number-string \"\")\n                          0\n         \
    \                 (let ([number-string (number->string value)])\n            \
    \                (if (equal? number-string \"\")\n                           \
    \     0\n                                (let ([number-string (number->string\
    \ value)])\n                                  (if (equal? number-string \"\")\n\
    \                                      0\n                                   \
    \   (let ([number-string (number->string value)])\n                          \
    \              (if (equal? number-string \"\")\n                             \
    \               0\n                                            (let ([number-string\
    \ (number->string value)])\n                                              (if\
    \ (equal? number-string \"\")\n                                              \
    \    0\n                                                  (let ([number-string\
    \ (number->string value)])\n                                                 \
    \   (if (equal? number-string \"\")\n                                        \
    \                0\n                                                        (let\
    \ ([number-string (number->string value)])\n                                 \
    \                         (if (equal? number-string \"\")\n                  \
    \                                            0\n                             \
    \                                 (let ([number-string (number->string value)])\n\
    \                                                                (if (equal? number-string\
    \ \"\")\n                                                                    0\n\
    \                                                                    (let ([number-string\
    \ (number->string value)])\n                                                 \
    \                     (if (equal? number-string \"\")\n                      \
    \                                                    0\n                     \
    \                                                     (let ([number-string (number->string\
    \ value)])\n                                                                 \
    \           (if (equal? number-string \"\")\n                                \
    \                                                0\n                         \
    \                                                       (let ([number-string (number->string\
    \ value)])\n                                                                 \
    \                 (if (equal? number-string \"\")\n                          \
    \                                                            0\n             \
    \                                                                         (let\
    \ ([number-string (number->string value)])\n                                 \
    \                                                       (if (equal? number-string\
    \ \"\")\n                                                                    \
    \                        0\n                                                 \
    \                                           (let ([number-string (number->string\
    \ value)])\n                                                                 \
    \                             (if (equal? number-string \"\")\n              \
    \                                                                            \
    \        0\n                                                                 \
    \                                 (let ([number-string (number->string value)])\n\
    \                                                                            \
    \                        (if (equal? number-string \"\")\n                   \
    \                                                                            \
    \         0\n                                                                \
    \                                        (let ([number-string (number->string\
    \ value)])\n                                                                 \
    \                                         (if (equal? number-string \"\")\n  \
    \                                                                            \
    \                                0\n                                         \
    \                                                                     (let ([number-string\
    \ (number->string value)])\n                                                 \
    \                                                               (if (equal? number-string\
    \ \"\")\n                                                                    \
    \                                                0\n                         \
    \                                                                            \
    \               ", "  (let ([x (number->string value)]\n        [y (number->string\
    \ value)])\n    (cond\n      [(equal? x y) value]\n      [(equal? x \"-\") value]\n\
    \      [(equal? y \"-\") value]\n      [(equal? x \"0\") value]\n      [(equal?\
    \ y \"0\") value]\n      [(equal? x \"1\") value]\n      [(equal? y \"1\") value]\n\
    \      [(equal? x \"2\") value]\n      [(equal? y \"2\") value]\n      [(equal?\
    \ x \"3\") value]\n      [(equal? y \"3\") value]\n      [(equal? x \"4\") value]\n\
    \      [(equal? y \"4\") value]\n      [(equal? x \"5\") value]\n      [(equal?\
    \ y \"5\") value]\n      [(equal? x \"6\") value]\n      [(equal? y \"6\") value]\n\
    \      [(equal? x \"7\") value]\n      [(equal? y \"7\") value]\n      [(equal?\
    \ x \"8\") value]\n      [(equal? y \"8\") value]\n      [(equal? x \"9\") value]\n\
    \      [(equal? y \"9\") value]\n      [(equal? x \".\") value]\n      [(equal?\
    \ y \".\") value]\n      [(equal? x \"-\") value]\n      [(equal? y \"-\") value]\n\
    \      [(equal? x \"0\") value]\n      [(equal? y \"0\") value]\n      [(equal?\
    \ x \"1\") value]\n      [(equal? y \"1\") value]\n      [(equal? x \"2\") value]\n\
    \      [(equal? y \"2\") value]\n      [(equal? x \"3\") value]\n      [(equal?\
    \ y \"3\") value]\n      [(equal? x \"4\") value]\n      [(equal? y \"4\") value]\n\
    \      [(equal? x \"5\") value]\n      [(equal? y \"5\") value]\n      [(equal?\
    \ x \"6\") value]\n      [(equal? y \"6\") value]\n      [(equal? x \"7\") value]\n\
    \      [(equal? y \"7\") value]\n      [(equal? x \"8\") value]\n      [(equal?\
    \ y \"8\") value]\n      [(equal? x \"9\") value]\n      [(equal? y \"9\") value]\n\
    \      [(equal? x \".\") value]\n      [(equal? y \".\") value]\n      [(equal?\
    \ x \"", "  (let ((closest-integer (min (floor (/ value 10)) (floor (/ value 10))))\n\
    \        (closest-integer-distance (abs (- value closest-integer))))\n    (if\
    \ (= closest-integer-distance 0)\n        closest-integer\n        (closest_integer\
    \ (+ closest-integer (/ closest-integer-distance 10))))))\n", "  (let ([x (string->number\
    \ (car value))\n        y (string->number (car value))]\n        [xdiff (- x y)\n\
    \         ydiff (- y x)]\n        [xdiff (- xdiff (abs xdiff))\n         ydiff\
    \ (- ydiff (abs ydiff))])\n    (if (= xdiff 0)\n        x\n        (if (= ydiff\
    \ 0)\n            y\n            (if (< xdiff ydiff)\n                x\n    \
    \            y))))\n", "  (let ([x (number->string value)]\n        [y (number->string\
    \ value)])\n    (cond\n      [(equal? x y) value]\n      [(equal? (string->number\
    \ x) (string->number y)) (string->number x)]\n      [(< (string->number x) (string->number\
    \ y)) (string->number x)]\n      [(> (string->number x) (string->number y)) (string->number\
    \ y)]))))\n", "  (let ([num (string->number value)]\n        [min (floor (abs\
    \ (- num 1)))]\n        [max (ceiling (abs (- num 1)))]\n        [diff (- num\
    \ min)])\n    (if (< diff 0)\n        (if (< num max)\n            (ceiling num)\n\
    \            (floor (- num 1)))\n        (if (< num min)\n            (floor (-\
    \ num 1))\n            (ceiling num))))))\n", "  (let ([int-value (string->number\
    \ (string->symbol value))])\n    (cond\n      [(< int-value 0) (ceiling int-value)]\n\
    \      [(> int-value 0) (floor int-value)]\n      [else int-value])))\n", "  (let\
    \ ([x (string->number (car value))])\n    (let ([y (string->number (cadr value))])\n\
    \      (cond\n        ((< (abs (- x y)) (abs x))\n         (+ x 1))\n        ((<\
    \ (abs (- x y)) (abs y))\n         (+ y 1))\n        (else\n         (+ x 1))))))\n",
  "  (let ((closest-integer (min (floor (/ value 10)) (floor (/ value 10))))\n   \
    \     (closest-integer-distance (abs (- value closest-integer))))\n    (if (=\
    \ closest-integer-distance 0)\n        closest-integer\n        (closest_integer\
    \ (+ closest-integer (/ closest-integer-distance 10))))))\n", "  (let ([x (string->number\
    \ (car value))\n        y (string->number (cadr value))])\n    (cond\n      [(and\
    \ (number? x) (number? y)) (round (+ (- x y) 1))]\n      [(and (number? x) (not\
    \ (number? y))) (round (- x 1))]\n      [(and (not (number? x)) (number? y)) (round\
    \ (- y 1))]\n      [(and (not (number? x)) (not (number? y))) (round (- x 1))]\n\
    \      [(and (number? x) (not (number? y))) (round (- y 1))]\n      [else (round\
    \ (- x 1))]\n      )))\n", "  (let ([x (string->number (car value))])\n    (let\
    \ ([y (string->number (cadr value))])\n      (cond\n        ((< (abs (- x y))\
    \ (abs x))\n         (+ x 1))\n        ((< (abs (- x y)) (abs y))\n         (+\
    \ y 1))\n        (else (+ x y))))))\n", "  (let ([x (string->number (car value))])\n\
    \    (let ([y (string->number (cadr value))])\n      (if (and (number? x) (number?\
    \ y))\n          (if (= x y)\n              (round (- x y))\n              (round\
    \ (- x y))\n              (round (- x y))\n              (round (- x y))\n   \
    \           (round (- x y))\n              (round (- x y))\n              (round\
    \ (- x y))\n              (round (- x y))\n              (round (- x y))\n   \
    \           (round (- x y))\n              (round (- x y))\n              (round\
    \ (- x y))\n              (round (- x y))\n              (round (- x y))\n   \
    \           (round (- x y))\n              (round (- x y))\n              (round\
    \ (- x y))\n              (round (- x y))\n              (round (- x y))\n   \
    \           (round (- x y))\n              (round (- x y))\n              (round\
    \ (- x y))\n              (round (- x y))\n              (round (- x y))\n   \
    \           (round (- x y))\n              (round (- x y))\n              (round\
    \ (- x y))\n              (round (- x y))\n              (round (- x y))\n   \
    \           (round (- x y))\n              (round (- x y))\n              (round\
    \ (- x y))\n              (round (- x y))\n              (round (- x y))\n   \
    \           (round (- x y))\n              (round (- x y))\n              (round\
    \ (- x y))\n              (round (- x y))\n              (round (- x y))\n   \
    \           (round (- x y))\n              (round (- x y))\n              (round\
    \ (- x y))\n              (round (- x y))\n              (round (- x y))\n   \
    \           (round (- x y))\n              (round (- x y))\n              (round\
    \ (- x y))\n              (round (- x y))\n              (round (- x y))\n   \
    \           (round (- x y))\n              (round (- x y))\n              (round\
    \ (- x y))\n              (round (- x y))\n              (round (- x y))\n   \
    \           (round (- x y))\n              (round (- x y))\n              (round\
    \ (- x y))\n              (round (- x y))\n              (round (- ", "  (let\
    \ ([int-value (string->number (string->symbol value))])\n    (cond\n      [(<\
    \ int-value 0) (error \"Given value is not a number\")]\n      [(< int-value 1)\
    \ (error \"Given value is not a number\")]\n      [else (floor (+ (/ int-value\
    \ 10) (/ int-value 10)))])))\n", "  (let ([integers (map integer->real '(1 2 3\
    \ 4 5 6 7 8 9))])\n    (let ([closest (car integers)])\n      (let ([diff (- value\
    \ closest)])\n        (if (< diff 0)\n          (closest_integer value)\n    \
    \      (if (< diff (- closest 1))\n            (+ closest diff)\n            closest)))))\n",
  "  (let ([x (parse-integer (string->symbol (string->symbol value)))])\n    (cond\
    \ [(< x 0) (- 0)]\n          [(< x 1) x]\n          [(< x 2) (- 1)]\n        \
    \  [(< x 3) (- 2)]\n          [(< x 4) (- 3)]\n          [(< x 5) (- 4)]\n   \
    \       [(< x 6) (- 5)]\n          [(< x 7) (- 6)]\n          [(< x 8) (- 7)]\n\
    \          [(< x 9) (- 8)]\n          [(< x 10) (- 9)]\n          [(< x 11) (-\
    \ 10)]\n          [(< x 12) (- 11)]\n          [(< x 13) (- 12)]\n          [(<\
    \ x 14) (- 13)]\n          [(< x 15) (- 14)]\n          [(< x 16) (- 15)]\n  \
    \        [(< x 17) (- 16)]\n          [(< x 18) (- 17)]\n          [(< x 19) (-\
    \ 18)]\n          [(< x 20) (- 19)]\n          [(< x 21) (- 20)]\n          [(<\
    \ x 22) (- 21)]\n          [(< x 23) (- 22)]\n          [(< x 24) (- 23)]\n  \
    \        [(< x 25) (- 24)]\n          [(< x 26) (- 25)]\n          [(< x 27) (-\
    \ 26)]\n          [(< x 28) (- 27)]\n          [(< x 29) (- 28)]\n          [(<\
    \ x 30) (- 29)]\n          [(< x 31) (- 30)]\n          [(< x 32) (- 31)]\n  \
    \        [(< x 33) (- 32)]\n          [(< x 34) (- 33)]\n          [(< x 35) (-\
    \ 34)]\n          [(< x 36) (- 35)]\n          [(< x 37) (- 36)]\n          [(<\
    \ x 38) (- 37)]\n          [(< x 39) (- 38)]\n          [(< x 40) (- 39)]\n  \
    \        [(< x 41) (- 40)]\n          [(< x 42) (- 41)]\n          [(< x 43) (-\
    \ 42)]\n          [(< x 44) (- 43)]\n          [(< x 45) (- 44)]\n          [(<\
    \ x 46) (- 45)]\n          [(< x 47) (- 46)]\n          [(< x 48) (- 47)]\n  \
    \        [(< x ", "  (let ((integer (floor (/ value 10))))\n    (if (= integer\
    \ 0)\n        0\n        (let ((diff (- value integer)))\n          (if (< diff\
    \ 0)\n              (- integer)\n              integer))))))\n", "  (let ([integers\
    \ (map number->integer (string->list value))])\n    (let ([closest (first integers)])\n\
    \      (if (null? integers)\n          closest\n          (let ([closest2 (first\
    \ integers)])\n            (if (> (abs (- closest closest2)) abs (- closest2 closest))\n\
    \                (closest_integer value)\n                (closest_integer value)\n\
    \            )\n          )\n      )\n    )\n  )\n)\n", "  (let ([x (number->string\
    \ value)]\n        [y (number->string value)])\n    (cond\n      [(equal? x y)\
    \ value]\n      [else (if (< (string->number x) (string->number y))\n        \
    \      (string->number (string->number x (- y x)))\n              (string->number\
    \ (string->number y (- x y))))])))\n", "  (let ((integer (floor (/ value 10))))\n\
    \    (if (< integer 10)\n        (+ integer 10)\n        integer)))\n", "  (let\
    \ ([num (string->number (string->symbol value))])\n    (cond\n      [(< num 0)\
    \ (error \"Closest integer not possible for negative numbers\")]\n      [(< num\
    \ 1) (error \"Closest integer not possible for numbers that are equidistant from\
    \ two integers\")]\n      [else (round (/ (- num 1) 2))])))\n", "  (let ((diff\
    \ (abs (- value 1))))\n    (cond ((< diff 0)\n           (ceiling value))\n  \
    \        ((> diff 0)\n           (floor value))\n          (else\n           (round\
    \ value))))\n  )\n", "  (let ([integer (parse-integer value)]\n        [integers\
    \ (list integer)]\n        [closest (car integers)])\n    (if (null? integers)\n\
    \        closest\n        (let ([new (+ closest (car integers))])\n          (if\
    \ (< (car integers) new) new (car integers))))))\n", "  (let ([x (floor value)])\n\
    \    (let ([y (/ x 10)])\n      (if (= y 0)\n          x\n          (if (= (-\
    \ x y) 0)\n              (- x)\n              (- x y))))))\n", "  (let ([integers\
    \ (map integer? value)]\n        [min (first integers)\n         max (second integers)])\n\
    \    (if (or (null? integers) (null? min) (null? max))\n        0\n        (let\
    \ ([closest (min (+ min (abs (- value min))))\n                 closest-to (min\
    \ (+ closest (abs (- value closest))))])\n          (if (< closest closest-to)\n\
    \              closest\n              closest-to))))\n", "  (define (closest-integer-helper\
    \ value)\n    (cond [(< value 0)\n           0]\n          [(< value 10)\n   \
    \        (+ value 1)]\n          [(< value 100)\n           (+ value 10)]\n  \
    \        [(< value 1000)\n           (+ value 100)]\n          [(< value 10000)\n\
    \           (+ value 1000)]\n          [(< value 100000)\n           (+ value\
    \ 10000)]\n          [(< value 1000000)\n           (+ value 100000)]\n      \
    \    [(< value 10000000)\n           (+ value 1000000)]\n          [(< value 100000000)\n\
    \           (+ value 10000000)]\n          [(< value 1000000000)\n           (+\
    \ value 100000000)]\n          [(< value 10000000000)\n           (+ value 1000000000)]\n\
    \          [(< value 100000000000)\n           (+ value 10000000000)]\n      \
    \    [(< value 1000000000000)\n           (+ value 100000000000)]\n          [(<\
    \ value 10000000000000)\n           (+ value 1000000000000)]\n          [(< value\
    \ 100000000000000)\n           (+ value 10000000000000)]\n          [(< value\
    \ 1000000000000000)\n           (+ value 100000000000000)]\n          [(< value\
    \ 10000000000000000)\n           (+ value 1000000000000000)]\n          [(< value\
    \ 100000000000000000)\n           (+ value 10000000000000000)]\n          [(<\
    \ value 1000000000000000000)\n           (+ value 100000000000000000)]\n     \
    \     [(< value 10000000000000000000)\n           (+ value 100000000000000000)]\n\
    \          [(< value 100000000000000000000)\n           (+ value 100000000000000000)]\n\
    \          [(< value 1000000000000000000000)\n           (+ value 100000000000000000)]\n\
    \          [(< value 10000000000000000000000)\n           (+ value 100000000000000000)]\n\
    \          [(< value 100000000000000000000000)\n           (+ value 100000000000000000)]\n\
    \          [(< value 1000000000000000000000000)\n           (+ value 100000000000000000)]\n\
    \          [(< value 10000000000000000000000000)\n           (+ value 100000000000000000)]\n\
    \          [(< value 100000000000000000000000000)\n           (+ value 100000000000000000)]\n\
    \          [(< value 1000000000000000000000000000)\n           (+ value 100000000000000000)]\n\
    \          [(< value 10000000000000000000000000000)\n           (+ value 100000000000000000)]\n\
    \          [(< value 100000000000000000000000000000)\n           (+ value 100000000000000000)]\n\
    \          [(< value 1000000000000000000000000000000)\n           (+ value 100000000000000000)]\n\
    \          [(< value 10000000000000000000000000000000)", "  (let ([x (string->number\
    \ (car value))])\n    (let ([y (string->number (cadr value))])\n      (cond\n\
    \        ((= x y) value)\n        ((< (abs (- x y)) (abs x)) (ceiling value))\n\
    \        (else (floor value)))))\n  value)\n", "  (let ([num (string->number (car\
    \ value))])\n    (cond\n      [(< num 0) (error \"The given value is not a number\"\
    )]\n      [(< num 1) (error \"The given value is not a number\")]\n      [else\
    \ (ceiling (/ num 10))]))))\n", "  (let ([integer (string->number (car value))])\n\
    \    (cond\n      [(< integer 0) (- integer (floor (/ value 10)))]\n      [else\
    \ (+ integer (floor (/ value 10)))])))\n", "  (let ([int-value (string->number\
    \ (string->symbol value))])\n    (cond\n      [(< int-value 0) (ceiling int-value)]\n\
    \      [else (floor int-value)])))\n", "  (let ([x (number->string value)]\n \
    \       [y (number->string value)])\n    (if (< (length x) 1)\n        (error\
    \ \"The given value is not a number\")\n        (let ([x (substring x 0 1)]\n\
    \              [y (substring y 0 1)])\n          (if (< (length x) 1)\n      \
    \        (error \"The given value is not a number\")\n              (let ([x (substring\
    \ x 0 1)]\n                    [(+ (char->integer x) (char->integer y))]\n   \
    \                 [y (substring y 0 1)])\n                (if (< (length x) 1)\n\
    \                    (error \"The given value is not a number\")\n           \
    \         (let ([x (substring x 0 1)]\n                          [(+ (char->integer\
    \ x) (char->integer y))]\n                          [y (substring y 0 1)])\n \
    \                     (if (< (length x) 1)\n                          (error \"\
    The given value is not a number\")\n                          (let ([x (substring\
    \ x 0 1)]\n                                [(+ (char->integer x) (char->integer\
    \ y))]\n                                [y (substring y 0 1)])\n             \
    \               (if (< (length x) 1)\n                                (error \"\
    The given value is not a number\")\n                                (let ([x (substring\
    \ x 0 1)]\n                                      [(+ (char->integer x) (char->integer\
    \ y))]\n                                      [y (substring y 0 1)])\n       \
    \                           (if (< (length x) 1)\n                           \
    \           (error \"The given value is not a number\")\n                    \
    \                  (let ([x (substring x 0 1)]\n                             \
    \               [(+ (char->integer x) (char->integer y))]\n                  \
    \                          [y (substring y 0 1)])\n                          \
    \          (if (< (length x) 1)\n                                        (error\
    \ \"The given value is not a number\")\n                                     \
    \   (let ([x (substring x 0 1)]\n                                            \
    \  [(+ (char->integer x) (char->integer y))]\n                               \
    \               [y (substring y 0 1)])\n                                     \
    \ (if (< (length x) 1)\n                                          (error \"The\
    \ given value is not a number\")\n                                          (let\
    \ ([x (substring x 0 1)]\n                                                [(+\
    \ (char->integer x) (char->integer y))]\n                                    \
    \            [y (substring y 0 1)])\n                                        (if\
    \ (< (length x) 1)\n                                            (error \"The given\
    \ value is not a number\")\n                                            (let ([x\
    \ (substring x 0 1)]\n                                                  [(+ (char->integer\
    \ x) (char->integer y))]\n                                                  [y\
    \ (substring y 0 1)])\n                                          (if (< (length\
    \ x) 1)\n                                              (error \"The given value\
    \ is not a number\")\n                                              (let ([x (substring ",
  "  (let ([integers (map integer->real '(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15))])\n\
    \    (let ([closest (car integers)])\n      (let ([diff (abs (- value closest))])\n\
    \        (cond\n          [(< diff 0) (min (+ closest 1) (+ closest 10))]\n  \
    \        [(< diff 1) (min (+ closest 2) (+ closest 10))]\n          [(< diff 2)\
    \ (min (+ closest 3) (+ closest 10))]\n          [(< diff 3) (min (+ closest 4)\
    \ (+ closest 10))]\n          [(< diff 4) (min (+ closest 5) (+ closest 10))]\n\
    \          [(< diff 5) (min (+ closest 6) (+ closest 10))]\n          [(< diff\
    \ 6) (min (+ closest 7) (+ closest 10))]\n          [(< diff 7) (min (+ closest\
    \ 8) (+ closest 10))]\n          [(< diff 8) (min (+ closest 9) (+ closest 10))]\n\
    \          [(< diff 9) (min (+ closest 10) (+ closest 10))]\n          [(< diff\
    \ 10) (min (+ closest 11) (+ closest 10))]\n          [(< diff 11) (min (+ closest\
    \ 12) (+ closest 10))]\n          [(< diff 12) (min (+ closest 13) (+ closest\
    \ 10))]\n          [(< diff 13) (min (+ closest 14) (+ closest 10))]\n       \
    \   [(< diff 14) (min (+ closest 15) (+ closest 10))]\n          [(< diff 15)\
    \ (min (+ closest 16) (+ closest 10))]\n          [(< diff 16) (min (+ closest\
    \ 17) (+ closest 10))]\n          [(< diff 17) (min (+ closest 18) (+ closest\
    \ 10))]\n          [(< diff 18) (min (+ closest 19) (+ closest 10))]\n       \
    \   [(< diff 19) (min (+ closest 20) (+ closest 10))]\n          [(< diff 20)\
    \ (min (+ closest 21) (+ closest 10))]\n          [(< diff 21) (min (+ closest\
    \ 22) (+ closest 10))]\n          [(< diff 22) (min (+ closest 23) (+ closest\
    \ 10))]\n          [(< diff 23) (min (+ closest 24) (+ closest 10))]\n       \
    \   [(< diff 24) (min (+ closest 25) (+ closest 10))]\n          [(< diff 25)\
    \ (min (+ closest 26) (+ closest 10))]\n          [(< diff 26) (min (+ closest\
    \ 27) (+ ", "  (let ([x (string->number (car value))])\n    (let ([y (string->number\
    \ (cadr value))])\n      (cond\n        ((< x y) (value->string x))\n        ((<\
    \ y x) (value->string y))\n        (else (value->string (value->number (car value))))))))\n",
  "  (let ([x (parse-integer value)]\n        [y (parse-integer value)])\n    (cond\
    \ [(< x y) x]\n          [(< y x) y]\n          [else (round (- x y))])))\n",
  "  (let ([int-value (string->number (string->symbol value))])\n    (cond\n     \
    \ [(< int-value 0) (error \"Closest integer not possible.\")]\n      [(< int-value\
    \ 1) int-value]\n      [else (round (abs (- int-value 1)))])))\n", "  (let ([x\
    \ (string->number (car value))\n        y (+ (string->number (cadr value)) (*\
    \ -1 x))])\n    (cond\n      [(< x y) (value->string value)\n       (< y x) (value->string\
    \ value)\n       (else (round (/ y x)))]))\n", "  (let ([x (number->string value)]\n\
    \        [y (number->string value)])\n    (cond\n      [(equal? x y) value]\n\
    \      [(equal? x \"-\") (- value)]\n      [(equal? y \"-\") (- value)]\n    \
    \  [(equal? x \"0\") (- value)]\n      [(equal? y \"0\") (- value)]\n      [(equal?\
    \ x \"1\") value]\n      [(equal? y \"1\") value]\n      [(equal? x \"9\") (+\
    \ value)]\n      [(equal? y \"9\") (+ value)]\n      [(equal? x \"10\") (+ value)]\n\
    \      [(equal? y \"10\") (+ value)]\n      [(equal? x \"11\") (+ value)]\n  \
    \    [(equal? y \"11\") (+ value)]\n      [(equal? x \"12\") (+ value)]\n    \
    \  [(equal? y \"12\") (+ value)]\n      [(equal? x \"13\") (+ value)]\n      [(equal?\
    \ y \"13\") (+ value)]\n      [(equal? x \"14\") (+ value)]\n      [(equal? y\
    \ \"14\") (+ value)]\n      [(equal? x \"15\") (+ value)]\n      [(equal? y \"\
    15\") (+ value)]\n      [(equal? x \"16\") (+ value)]\n      [(equal? y \"16\"\
    ) (+ value)]\n      [(equal? x \"17\") (+ value)]\n      [(equal? y \"17\") (+\
    \ value)]\n      [(equal? x \"18\") (+ value)]\n      [(equal? y \"18\") (+ value)]\n\
    \      [(equal? x \"19\") (+ value)]\n      [(equal? y \"19\") (+ value)]\n  \
    \    [(equal? x \"20\") (+ value)]\n      [(equal? y \"20\") (+ value)]\n    \
    \  [(equal? x \"21\") (+ value)]\n      [(equal? y \"21\") (+ value)]\n      [(equal?\
    \ x \"22\") (+ value)]\n      [(equal? y \"22\") (+ value)]\n      [(equal? x\
    \ \"23\") (+ value)]\n      [(equal? y \"23\") (+ value)]\n      [(equal? x \"\
    24\") (+ value)]\n      [(equal? y \"24", "  (let ([integers (map number->integer\
    \ (split-string (number->string value) \".\"))])\n    (let ([smallest (car integers)])\n\
    \      (let ([closest (car integers)])\n        (cond\n          [(< smallest\
    \ closest)\n           (let ([closest (- smallest closest)])\n             (cond\n\
    \               [(< closest smallest)\n                (let ([smallest (- smallest\
    \ closest)])\n                  (cond\n                    [(< smallest closest)\n\
    \                     (let ([closest (- smallest closest)])\n                \
    \       (cond\n                         [(< closest smallest)\n              \
    \             (let ([smallest (- smallest closest)])\n                       \
    \     (cond\n                              [(< smallest closest)\n           \
    \                    (let ([closest (- smallest closest)])\n                 \
    \               closest)]\n                              [(< closest smallest)\n\
    \                               (let ([closest (- smallest closest)])\n      \
    \                          closest)]\n                              [(< closest\
    \ smallest)\n                               (let ([closest (- smallest closest)])\n\
    \                                closest)]\n                              [(<\
    \ closest smallest)\n                               (let ([closest (- smallest\
    \ closest)])\n                                closest)]\n                    \
    \          [(< closest smallest)\n                               (let ([closest\
    \ (- smallest closest)])\n                                closest)]\n        \
    \                      [(< closest smallest)\n                               (let\
    \ ([closest (- smallest closest)])\n                                closest)]\n\
    \                              [(< closest smallest)\n                       \
    \        (let ([closest (- smallest closest)])\n                             \
    \   closest)]\n                              [(< closest smallest)\n         \
    \                      (let ([closest (- smallest closest)])\n               \
    \                 closest)]\n                              [(< closest smallest)\n\
    \                               (let ([closest (- smallest closest)])\n      \
    \                          closest)]\n                              [(< closest\
    \ smallest)\n                               (let ([closest (- smallest closest)])\n\
    \                                closest)]\n                              [(<\
    \ closest smallest)\n                               (let ([closest (- smallest\
    \ closest)])\n                                closest)]\n                    \
    \          [(< closest smallest)\n                               (let ([closest\
    \ (- smallest closest)])\n                                closest)]\n        \
    \                      [(< closest smallest)\n                               (let\
    \ ([closest (- smallest closest)])\n                                closest)]\n\
    \                              [(< closest smallest)\n                       \
    \        (let ([closest (- smallest closest)])\n                             \
    \   closest)]\n                              [(< closest smallest)\n         \
    \                      (let ([closest (- smallest closest)])\n               \
    \                 closest)]\n                              [(< closest smallest)\n\
    \                               (let ([closest (- smallest closest)])\n      \
    \                          closest)]\n                              [(< closest\
    \ smallest)\n                               (let ([closest (- smallest closest)])\n\
    \                                closest)]\n                              [(<\
    \ closest smallest)", "  (let ([integers (map number->integer (split-string (number->string\
    \ value) \".\"))])\n    (if (null? integers)\n        0\n        (let ([closest\
    \ (car integers)])\n          (if (< (abs (- closest value)) (abs (- value closest)))\n\
    \              (- closest)\n              closest))))))\n", "  (let ([x (string->number\
    \ (car value))])\n    (let ([y (string->number (cadr value))])\n      (if (and\
    \ (number? x) (number? y))\n          (if (= x y)\n              x\n         \
    \     (ceiling (- x y)))\n          (ceiling (- x y)))))))\n", "  (let ([x (number->string\
    \ value)]\n        [y (number->string value)])\n    (if (equal? x y)\n       \
    \ value\n        (let ([x (number->string value)])\n          (if (equal? x y)\n\
    \              value\n              (let ([x (number->string value)])\n      \
    \          (if (equal? x y)\n                    value\n                    (let\
    \ ([x (number->string value)])\n                      (if (equal? x y)\n     \
    \                     value\n                          (let ([x (number->string\
    \ value)])\n                            (if (equal? x y)\n                   \
    \             value\n                                (let ([x (number->string\
    \ value)])\n                                  (if (equal? x y)\n             \
    \                         value\n                                      (let ([x\
    \ (number->string value)])\n                                        (if (equal?\
    \ x y)\n                                            value\n                  \
    \                          (let ([x (number->string value)])\n               \
    \                               (if (equal? x y)\n                           \
    \                       value\n                                              \
    \    (let ([x (number->string value)])\n                                     \
    \               (if (equal? x y)\n                                           \
    \             value\n                                                        (let\
    \ ([x (number->string value)])\n                                             \
    \             (if (equal? x y)\n                                             \
    \                 value\n                                                    \
    \          (let ([x (number->string value)])\n                               \
    \                                 (if (equal? x y)\n                         \
    \                                           value\n                          \
    \                                          (let ([x (number->string value)])\n\
    \                                                                      (if (equal?\
    \ x y)\n                                                                     \
    \     value\n                                                                \
    \          (let ([x (number->string value)])\n                               \
    \                                             (if (equal? x y)\n             \
    \                                                                   value\n  \
    \                                                                            \
    \  (let ([x (number->string value)])\n                                       \
    \                                           (if (equal? x y)\n               \
    \                                                                       value\n\
    \                                                                            \
    \          (let ([x (number->string value)])\n                               \
    \                                                         (if (equal? x y)\n \
    \                                                                            \
    \               value\n                                                      \
    \                                      (let ([x (number->string value)])\n   \
    \                                                                            \
    \               (if (equal? x y)\n                                           \
    \                                                       value\n              \
    \                                                                            \
    \        (let ([x (number->string value)])\n                                 \
    \                                                                   (if (equal?\
    \ x y)\n                                                                     \
    \                                   value\n                                  \
    \                                                                      (let ([x\
    \ (number->string value)])\n                                                 \
    \                                                         (if (equal? x y)\n \
    \                                                                            \
    \                                 value\n                                    \
    \                                                                          (let\
    \ ([x (number->string value)])\n                                             \
    \                                                                   (if (equal?\
    \ x y)\n                                                                     \
    \                                               value\n                      \
    \                                                                            \
    \                  (let ([x (number->string value)])\n                       \
    \                                                                            \
    \                   (if (equal? x y)\n                                       \
    \                                                                            \
    \       value\n                                                              \
    \                                                            (let ([x (number->string\
    \ value)])\n                                                                 \
    \                                                           (if (equal? x y)\n\
    \                                                                            \
    \                                                    value\n                 \
    \                                                                            \
    \                                   ", "  (let ([x (number->string value)]\n \
    \       [y (number->string value)])\n    (cond [(equal? x y) value]\n        \
    \  [(< (string->number x) (string->number y)) (string->number x)]\n          [(>\
    \ (string->number x) (string->number y)) (string->number y)]\n          [else\
    \ (string->number x)]))))\n", "  (let ([x (floor value)]\n        [y (floor value)])\n\
    \    (cond [(= x y) value]\n          [(< x y) x]\n          [(> x y) y]\n   \
    \       [else (+ x y)]))))\n", "  (let ([x (number->string value)]\n        [y\
    \ (number->string value)])\n    (cond\n      [(equal? x y) value]\n      [(equal?\
    \ x \"-\") (- 0 (number->integer value))]\n      [(equal? y \"-\") (- 0 (number->integer\
    \ value))]\n      [(equal? x \"0\") (- 0 (number->integer value))]\n      [(equal?\
    \ y \"0\") (- 0 (number->integer value))]\n      [(equal? x \"1\") (- 0 (number->integer\
    \ value))]\n      [(equal? y \"1\") (- 0 (number->integer value))]\n      [(equal?\
    \ x \"2\") (- 0 (number->integer value))]\n      [(equal? y \"2\") (- 0 (number->integer\
    \ value))]\n      [(equal? x \"3\") (- 0 (number->integer value))]\n      [(equal?\
    \ y \"3\") (- 0 (number->integer value))]\n      [(equal? x \"4\") (- 0 (number->integer\
    \ value))]\n      [(equal? y \"4\") (- 0 (number->integer value))]\n      [(equal?\
    \ x \"5\") (- 0 (number->integer value))]\n      [(equal? y \"5\") (- 0 (number->integer\
    \ value))]\n      [(equal? x \"6\") (- 0 (number->integer value))]\n      [(equal?\
    \ y \"6\") (- 0 (number->integer value))]\n      [(equal? x \"7\") (- 0 (number->integer\
    \ value))]\n      [(equal? y \"7\") (- 0 (number->integer value))]\n      [(equal?\
    \ x \"8\") (- 0 (number->integer value))]\n      [(equal? y \"8\") (- 0 (number->integer\
    \ value))]\n      [(equal? x \"9\") (- 0 (number->integer value))]\n      [(equal?\
    \ y \"9\") (- 0 (number->integer value))]\n      [else (- 0 (number->integer value))])))\n",
  "  (let ([x (floor value)])\n    (let ([y (floor value)])\n      (if (= x y)\n \
    \         x\n          (if (> (abs (- x y)) (abs x))\n              (- x)\n  \
    \            (- y)))))))\n", "  (let ([int-value (string->number (string->symbol\
    \ value))])\n    (cond\n      [(< int-value 0) (ceiling int-value)]\n      [(>\
    \ int-value 0) (floor int-value)]\n      [(= int-value 0) 0]\n      [else (round\
    \ int-value)])))\n", "  (let ([number-as-string (string->number value)])\n   \
    \ (cond\n      [(number? number-as-string)\n       (cond\n         [(< (abs (-\
    \ number-as-string 1)) 0)\n          (ceiling number-as-string)]\n         [(<\
    \ (abs (- number-as-string -1)) 0)\n          (floor number-as-string)]\n    \
    \     [else (number-as-string)]))]\n      [else (error \"Not a number\")]))))\n",
  "  (let ([x (number->string value)]\n        [y (number->string value)])\n    (cond\n\
    \      [(number->string? value) (number->string value)]\n      [(number->number?\
    \ value) (number->number value)]\n      [else (error \"Value must be a number\
    \ or string.\")]\n      )\n    (cond\n      [(equal? x y) x]\n      [(equal? (string->number\
    \ x) (string->number y)) (string->number x)]\n      [(equal? (string->number x)\
    \ (string->number y)) (string->number x)]\n      [(equal? (string->number x) (string->number\
    \ y)) (string->number x)]\n      [(equal? (string->number x) (string->number y))\
    \ (string->number x)]\n      [(equal? (string->number x) (string->number y)) (string->number\
    \ x)]\n      [(equal? (string->number x) (string->number y)) (string->number x)]\n\
    \      [(equal? (string->number x) (string->number y)) (string->number x)]\n \
    \     [(equal? (string->number x) (string->number y)) (string->number x)]\n  \
    \    [(equal? (string->number x) (string->number y)) (string->number x)]\n   \
    \   [(equal? (string->number x) (string->number y)) (string->number x)]\n    \
    \  [(equal? (string->number x) (string->number y)) (string->number x)]\n     \
    \ [(equal? (string->number x) (string->number y)) (string->number x)]\n      [(equal?\
    \ (string->number x) (string->number y)) (string->number x)]\n      [(equal? (string->number\
    \ x) (string->number y)) (string->number x)]\n      [(equal? (string->number x)\
    \ (string->number y)) (string->number x)]\n      [(equal? (string->number x) (string->number\
    \ y)) (string->number x)]\n      [(equal? (string->number x) (string->number y))\
    \ (string->number x)]\n      [(equal? (string->number x) (string->number y)) (string->number\
    \ x)]\n      [(equal? (string->number x) (string->number y)) (string->number x)]\n\
    \      [(equal? (string->number x) (string->number y)) (string->number x)]\n \
    \     [(equal? (string->number x) (string->number y)) (string->number x)]\n  \
    \    [(equal? (string->number x) (string->number y)) (string->number x)]\n   \
    \   [(equal? (string->number x) (string->number y)) (string->number x)]", "  (let\
    \ ([integers (map integer->real '(1 2 3 4 5 6 7 8 9))]\n        [diff (- value\
    \ (car integers))])\n    (if (< diff 0)\n        (let ([closest (car integers)])\n\
    \          (if (< diff (- closest integer))\n              (cons closest (closest_integer\
    \ (- value closest)))\n              (closest_integer value))\n          (closest_integer\
    \ value))\n      (let ([closest (car integers)])\n        (if (< diff (- closest\
    \ integer))\n            (cons closest (closest_integer (- value closest)))\n\
    \            (closest_integer value))))))\n", "  (let ([x (parse-integer (string->symbol\
    \ (symbol->string value)))])\n    (cond [(< x 0) (error \"The given value is not\
    \ a number\")]\n          [(< x 1) (error \"The given value is not a number\"\
    )]\n          [(< x 10) (error \"The given value is not a number\")]\n       \
    \   [(< x 100) (error \"The given value is not a number\")]\n          [(< x 1000)\
    \ (error \"The given value is not a number\")]\n          [(< x 10000) (error\
    \ \"The given value is not a number\")]\n          [(< x 100000) (error \"The\
    \ given value is not a number\")]\n          [(< x 1000000) (error \"The given\
    \ value is not a number\")]\n          [(< x 10000000) (error \"The given value\
    \ is not a number\")]\n          [(< x 100000000) (error \"The given value is\
    \ not a number\")]\n          [(< x 1000000000) (error \"The given value is not\
    \ a number\")]\n          [(< x 10000000000) (error \"The given value is not a\
    \ number\")]\n          [(< x 100000000000) (error \"The given value is not a\
    \ number\")]\n          [(< x 1000000000000) (error \"The given value is not a\
    \ number\")]\n          [(< x 10000000000000) (error \"The given value is not\
    \ a number\")]\n          [(< x 100000000000000) (error \"The given value is not\
    \ a number\")]\n          [(< x 1000000000000000) (error \"The given value is\
    \ not a number\")]\n          [(< x 10000000000000000) (error \"The given value\
    \ is not a number\")]\n          [(< x 100000000000000000) (error \"The given\
    \ value is not a number\")]\n          [(< x 1000000000000000000) (error \"The\
    \ given value is not a number\")]\n          [(< x 10000000000000000000) (error\
    \ \"The given value is not a number\")]\n          [(< x 100000000000000000000)\
    \ (error \"The given value is not a number\")]\n          [(< x 1000000000000000000000)\
    \ (error \"The given value is not a number\")]\n          [(< x 10000000000000000000000)\
    \ (error \"The given value is not a number\")]\n          [(< x 100000000000000000000000)\
    \ (error \"The given value is not a number\")]\n          [(< x 1000000000000000000000000)\
    \ (error \"The given value is not a number\")]\n          [(< x 10000000000000000000000000)\
    \ (error \"The given value is not a number\")]\n          [(< x 100000000000000000000000000)\
    \ (error \"The given value is not a number\")]\n          [(< x 1000000000000000000000000000)\
    \ (error \"The given value is not a number\")]\n          [(< x 10000000000000000000000000000)\
    \ (error \"The given value is not a number", "  (let ([x (number->string value)]\n\
    \        [y (number->string value)])\n    (cond\n      [(equal? x y) value]\n\
    \      [(equal? (number->string x) \"-\") (- value)]\n      [(equal? (number->string\
    \ y) \"-\") (- value)]\n      [(equal? (number->string x) \"0\") (- value)]\n\
    \      [(equal? (number->string y) \"0\") (- value)]\n      [(equal? (number->string\
    \ x) \"1\") value]\n      [(equal? (number->string y) \"1\") value]\n      [(equal?\
    \ (number->string x) \"2\") (+ value)]\n      [(equal? (number->string y) \"2\"\
    ) (+ value)]\n      [(equal? (number->string x) \"3\") (+ value)]\n      [(equal?\
    \ (number->string y) \"3\") (+ value)]\n      [(equal? (number->string x) \"4\"\
    ) (+ value)]\n      [(equal? (number->string y) \"4\") (+ value)]\n      [(equal?\
    \ (number->string x) \"5\") (+ value)]\n      [(equal? (number->string y) \"5\"\
    ) (+ value)]\n      [(equal? (number->string x) \"6\") (+ value)]\n      [(equal?\
    \ (number->string y) \"6\") (+ value)]\n      [(equal? (number->string x) \"7\"\
    ) (+ value)]\n      [(equal? (number->string y) \"7\") (+ value)]\n      [(equal?\
    \ (number->string x) \"8\") (+ value)]\n      [(equal? (number->string y) \"8\"\
    ) (+ value)]\n      [(equal? (number->string x) \"9\") (+ value)]\n      [(equal?\
    \ (number->string y) \"9\") (+ value)]\n      [else (+ value)]))))\n", "  (let\
    \ ([num (string->number (car value))])\n    (cond\n      [(< num 0) (ceiling num)]\n\
    \      [(> num 0) (floor num)]\n      [else (round num)])))\n", "  (let ([x (string->number\
    \ (car value))\n        y (+ (string->number (cadr value)) (* -1 x))])\n    (cond\n\
    \      [(< x y) value]\n      [else (round (/ y x))])))\n", "  (let ([x (parse-integer\
    \ (string->symbol (string->symbol value)))])\n    (cond [(< x 0) (- 0 (floor (-\
    \ x)))]\n          [(< x 1) (- 0 (floor (- x)))]\n          [else x])))\n", " \
    \ (let ([number-string (string->number value)])\n    (let ([closest-integer (floor\
    \ (+ (* number-string 10) (/ number-string 10)))])\n      (if (< (abs (- closest-integer\
    \ number-string)) (abs (- number-string closest-integer)))\n          closest-integer\n\
    \          number-string))))\n", "  (let ((x (string->number (string->symbol value))))\n\
    \    (cond\n      [(< x 0) (error \"Given value is not a number\")]\n      [(<\
    \ x 1) (error \"Given value is not a number\")]\n      [(< x 10) (error \"Given\
    \ value is not a number\")]\n      [(< x 100) (error \"Given value is not a number\"\
    )]\n      [(< x 1000) (error \"Given value is not a number\")]\n      [(< x 10000)\
    \ (error \"Given value is not a number\")]\n      [(< x 100000) (error \"Given\
    \ value is not a number\")]\n      [(< x 1000000) (error \"Given value is not\
    \ a number\")]\n      [(< x 10000000) (error \"Given value is not a number\")]\n\
    \      [(< x 100000000) (error \"Given value is not a number\")]\n      [(< x\
    \ 1000000000) (error \"Given value is not a number\")]\n      [(< x 10000000000)\
    \ (error \"Given value is not a number\")]\n      [(< x 100000000000) (error \"\
    Given value is not a number\")]\n      [(< x 1000000000000) (error \"Given value\
    \ is not a number\")]\n      [(< x 10000000000000) (error \"Given value is not\
    \ a number\")]\n      [(< x 100000000000000) (error \"Given value is not a number\"\
    )]\n      [(< x 1000000000000000) (error \"Given value is not a number\")]\n \
    \     [(< x 10000000000000000) (error \"Given value is not a number\")]\n    \
    \  [(< x 100000000000000000) (error \"Given value is not a number\")]\n      [(<\
    \ x 1000000000000000000) (error \"Given value is not a number\")]\n      [(< x\
    \ 10000000000000000000) (error \"Given value is not a number\")]\n      [(< x\
    \ 100000000000000000000) (error \"Given value is not a number\")]\n      [(< x\
    \ 1000000000000000000000) (error \"Given value is not a number\")]\n      [(<\
    \ x 10000000000000000000000) (error \"Given value is not a number\")]\n      [(<\
    \ x 100000000000000000000000) (error \"Given value is not a number\")]\n     \
    \ [(< x 1000000000000000000000000) (error \"Given value is not a number\")]\n\
    \      [(< x 10000000000000000000000000) (error \"Given value is not a number\"\
    )]\n      [(< x 100000000000000000000000000) (error \"Given value is not a number\"\
    )]\n      [(< x 1000000000000000000000000000) (error \"Given value is not a number\"\
    )]\n      [(< x 10000000000000000000000000000) (error \"Given value is not a number\"\
    )]\n      [(< x 100000000000000000000000000000) (error \"Given value is not a\
    \ number\")]\n      [(< x 1000000000000000000000000000000) (error \"Given value\
    \ is not a ", "  (let ([integers (map integer->real '(1 2 3 4 5 6 7 8 9))])\n\
    \    (let ([closest (first integers)])\n      (if (< (abs (- value closest)) (abs\
    \ (- value integers)))\n          closest\n          (closest_integer value))))))\n",
  "  (let ([int-value (string->number (string->symbol value))])\n    (cond [(< int-value\
    \ 0)\n           (error \"Given value is not a number\")\n           (error \"\
    Given value is not equidistant from two integers\")]\n          [(< int-value\
    \ int-value)\n           (ceiling int-value)]\n          [else (floor int-value)])))\n",
  "  (let ([x (number->string value)]\n        [y (number->string value)])\n    (if\
    \ (equal? x y)\n        (number->integer value)\n        (let ([x (number->string\
    \ value)]\n              [y (number->string value)])\n          (if (equal? x\
    \ y)\n              (number->integer value)\n              (let ([x (number->string\
    \ value)]\n                    [(+ (number->integer x) 1)\n                  \
    \   (number->integer value)])\n                (if (equal? x y)\n            \
    \        (number->integer value)\n                    (let ([x (number->string\
    \ value)]\n                          [(+ (number->integer x) 1)\n            \
    \               (number->integer value)])\n                      (if (equal? x\
    \ y)\n                          (number->integer value)\n                    \
    \      (let ([x (number->string value)]\n                                [(+ (number->integer\
    \ x) 1)\n                                 (number->integer value)])\n        \
    \                    (if (equal? x y)\n                                (number->integer\
    \ value)\n                                (let ([x (number->string value)]\n \
    \                                     [(+ (number->integer x) 1)\n           \
    \                            (number->integer value)])\n                     \
    \             (if (equal? x y)\n                                      (number->integer\
    \ value)\n                                      (let ([x (number->string value)]\n\
    \                                            [(+ (number->integer x) 1)\n    \
    \                                         (number->integer value)])\n        \
    \                                (if (equal? x y)\n                          \
    \                  (number->integer value)\n                                 \
    \           (let ([x (number->string value)]\n                               \
    \                   [(+ (number->integer x) 1)\n                             \
    \                      (number->integer value)])\n                           \
    \                   (if (equal? x y)\n                                       \
    \           (number->integer value)\n                                        \
    \          (let ([x (number->string value)]\n                                \
    \                        [(+ (number->integer x) 1)\n                        \
    \                                 (number->integer value)])\n                \
    \                                    (if (equal? x y)\n                      \
    \                                  (number->integer value)\n                 \
    \                                       (let ([x (number->string value)]\n   \
    \                                                           [(+ (number->integer\
    \ x) 1)\n                                                               (number->integer\
    \ value)])\n                                                          (if (equal?\
    \ x y)\n                                                              (number->integer\
    \ value)\n                                                              (let ([x\
    \ (number->string value)]\n                                                  \
    \                  [(+ (number->integer x) 1)\n                              \
    \                                       (number->integer value)])\n          \
    \                                                      (if (equal? x y)\n    \
    \                                                                (number->integer\
    \ value)\n                                                                   \
    \ (let ([x (number->string value)]\n                                         \
    \                                 [(+ (number->integer x) 1)\n               \
    \                                                            (number->integer\
    \ value)])\n                                                                 \
    \ (if (equal? x y)\n                                                         \
    \             (number->integer value)\n                                      \
    \                                ", "  (let ([num (parse-integer value)]\n   \
    \     [nums (list num)]\n        [min (min nums)]\n        [max (max nums)])\n\
    \    (if (= num 0)\n        min\n        (if (< (abs (- num max)) (abs (- num\
    \ min)))\n            (- num max)\n            (- num min)))))\n", "  (let ([x\
    \ (string->number (car value))])\n    (cond\n      [(< x 0) (error \"Given value\
    \ is not a number\")]\n      [(< x 1) x]\n      [(< x 10) (+ x 10)]\n      [(<\
    \ x 100) (+ x 100)]\n      [(< x 1000) (+ x 1000)]\n      [(< x 10000) (+ x 10000)]\n\
    \      [(< x 100000) (+ x 100000)]\n      [(< x 1000000) (+ x 1000000)]\n    \
    \  [(< x 10000000) (+ x 10000000)]\n      [(< x 100000000) (+ x 100000000)]\n\
    \      [(< x 1000000000) (+ x 1000000000)]\n      [(< x 10000000000) (+ x 10000000000)]\n\
    \      [(< x 100000000000) (+ x 100000000000)]\n      [(< x 1000000000000) (+\
    \ x 1000000000000)]\n      [(< x 10000000000000) (+ x 10000000000000)]\n     \
    \ [(< x 100000000000000) (+ x 100000000000000)]\n      [(< x 1000000000000000)\
    \ (+ x 1000000000000000)]\n      [(< x 10000000000000000) (+ x 10000000000000000)]\n\
    \      [(< x 100000000000000000) (+ x 100000000000000000)]\n      [(< x 1000000000000000000)\
    \ (+ x 1000000000000000000)]\n      [else (+ x 1000000000000000000)])))\n", " \
    \ (let ([x (string->number (car value))])\n    (let ([y (string->number (cadr\
    \ value))])\n      (if (< (abs (- x y)) 1.5)\n          (ceiling x)\n        \
    \  (floor (- x)))\n      (closest_integer (cdr value)))))\n", "  (define (closest-integer-helper\
    \ value low-bound high-bound)\n    (if (< value low-bound)\n        low-bound\n\
    \        (if (< value high-bound)\n            high-bound\n            (if (<\
    \ (abs (- value low-bound)) (abs (- value high-bound)))\n                (+ value\
    \ low-bound)\n                (+ value high-bound))))\n    (closest-integer-helper\
    \ value low-bound (+ low-bound 1))\n    (closest-integer-helper value (+ low-bound\
    \ 1) high-bound))\n  (closest-integer-helper value 0 1))\n", "  (let ([num (string->number\
    \ value)])\n    (cond [(< num 0) (- 0)]\n          [(< num 1) (- 0)]\n       \
    \   [(< num 2) (- 0)]\n          [(< num 3) (- 0)]\n          [(< num 4) (- 0)]\n\
    \          [(< num 5) (- 0)]\n          [(< num 6) (- 0)]\n          [(< num 7)\
    \ (- 0)]\n          [(< num 8) (- 0)]\n          [(< num 9) (- 0)]\n         \
    \ [(< num 10) (- 0)]\n          [(< num 11) (- 0)]\n          [(< num 12) (- 0)]\n\
    \          [(< num 13) (- 0)]\n          [(< num 14) (- 0)]\n          [(< num\
    \ 15) (- 0)]\n          [(< num 16) (- 0)]\n          [(< num 17) (- 0)]\n   \
    \       [(< num 18) (- 0)]\n          [(< num 19) (- 0)]\n          [(< num 20)\
    \ (- 0)]\n          [(< num 21) (- 0)]\n          [(< num 22) (- 0)]\n       \
    \   [(< num 23) (- 0)]\n          [(< num 24) (- 0)]\n          [(< num 25) (-\
    \ 0)]\n          [(< num 26) (- 0)]\n          [(< num 27) (- 0)]\n          [(<\
    \ num 28) (- 0)]\n          [(< num 29) (- 0)]\n          [(< num 30) (- 0)]\n\
    \          [(< num 31) (- 0)]\n          [(< num 32) (- 0)]\n          [(< num\
    \ 33) (- 0)]\n          [(< num 34) (- 0)]\n          [(< num 35) (- 0)]\n   \
    \       [(< num 36) (- 0)]\n          [(< num 37) (- 0)]\n          [(< num 38)\
    \ (- 0)]\n          [(< num 39) (- 0)]\n          [(< num 40) (- 0)]\n       \
    \   [(< num 41) (- 0)]\n          [(< num 42) (- 0)]\n          [(< num 43) (-\
    \ 0)]\n          [(< num 44) (- 0)]\n          [(< num 45) (- 0)]\n          [(<\
    \ num 46) (- 0)]\n          [(< num 47) (- 0)]\n          [(< num 48) (- 0)]\n\
    \          [(< num 49) (- ", "  (let ([x (number->string value)]\n        [y (number->string\
    \ value)])\n    (cond\n      [(equal? x y) value]\n      [(equal? x \"-\") (-\
    \ 0 (number->integer value))]\n      [(equal? y \"-\") (- 0 (number->integer value))]\n\
    \      [(equal? x \"0\") (- 0 (number->integer value))]\n      [(equal? y \"0\"\
    ) (- 0 (number->integer value))]\n      [(equal? x \"1\") (- 0 (number->integer\
    \ value))]\n      [(equal? y \"1\") (- 0 (number->integer value))]\n      [(equal?\
    \ x \"2\") (- 0 (number->integer value))]\n      [(equal? y \"2\") (- 0 (number->integer\
    \ value))]\n      [(equal? x \"3\") (- 0 (number->integer value))]\n      [(equal?\
    \ y \"3\") (- 0 (number->integer value))]\n      [(equal? x \"4\") (- 0 (number->integer\
    \ value))]\n      [(equal? y \"4\") (- 0 (number->integer value))]\n      [(equal?\
    \ x \"5\") (- 0 (number->integer value))]\n      [(equal? y \"5\") (- 0 (number->integer\
    \ value))]\n      [(equal? x \"6\") (- 0 (number->integer value))]\n      [(equal?\
    \ y \"6\") (- 0 (number->integer value))]\n      [(equal? x \"7\") (- 0 (number->integer\
    \ value))]\n      [(equal? y \"7\") (- 0 (number->integer value))]\n      [(equal?\
    \ x \"8\") (- 0 (number->integer value))]\n      [(equal? y \"8\") (- 0 (number->integer\
    \ value))]\n      [(equal? x \"9\") (- 0 (number->integer value))]\n      [(equal?\
    \ y \"9\") (- 0 (number->integer value))]\n      [(equal? x \".\") (- 0 (number->integer\
    \ value))]\n      [(equal? y \".\") (- 0 (number->integer value))]\n      [(equal?\
    \ x \"-\") (- 0 (number->integer value))]\n      [(equal? y \"-\") (- 0 (number->integer\
    \ value))]\n      [(equal? x \"0\") (- 0 (number->integer value))]\n      [(equal?\
    \ y \"0\") (- 0 (number->integer value))]\n      [(equal? x \"1\") ", "  (let\
    \ ([x (parse-integer (string->list value))]\n        [y (parse-integer (string->list\
    \ value))]\n        [diff (- x y)]\n        [diff (- y x)])\n    (if (< diff 0)\n\
    \        (parse-integer (string->list value))\n        (parse-integer (string->list\
    \ value))))\n  )\n", "  (let ([x (string->number (car value))])\n    (let ([y\
    \ (string->number (car value))])\n      (cond\n        ((< (abs (- x y)) (abs\
    \ (- y x))) (ceiling value))\n        ((< (abs (- x y)) (abs (- y x))) (floor\
    \ value))\n        (else (round value))))))\n", "  (let ([x (number->string value)]\n\
    \        [y (number->string value)])\n    (cond\n      [(equal? x y) value]\n\
    \      [(equal? x \"-\") (- 0 (number->integer value))]\n      [(equal? y \"-\"\
    ) (- 0 (number->integer value))]\n      [(equal? x \"0\") (- 0 (number->integer\
    \ value))]\n      [(equal? y \"0\") (- 0 (number->integer value))]\n      [else\
    \ (- 0 (number->integer value))])))\n", "  (let ([x (string->number (car value))])\n\
    \    (let ([y (string->number (cadr value))])\n      (if (< (abs (- x y)) (abs\
    \ x))\n          (ceiling x)\n          (floor (- x y))))))\n", "  (let ([x (string->number\
    \ (car value))])\n    (cond\n      [(< x 0) (error \"Closest integer not possible\
    \ for negative numbers\")]\n      [(< x 1) (error \"Closest integer not possible\
    \ for numbers that are equidistant from zero\")]\n      [else (floor (+ (* x 2)\
    \ (/ (- x 1) (- x 1)))) ])))\n", "  (let ([integers (map integer? value)]\n  \
    \      [integer (first integers)])\n    (if (null? integers)\n        0\n    \
    \    (let ([closest (first integers)])\n          (if (< (abs (- value closest))\
    \ (abs (- value integer)))\n              closest\n              integer))))))\n",
  "  (let ([x (parse-integer value)]\n        [y (parse-integer value)]\n        [diff\
    \ (abs (- x y))]\n        [max (- x y)])\n    (cond [(< diff max) x]\n       \
    \   [(> diff max) y]\n          [else (+ x y)]))))\n", "  (let ([integers (map\
    \ number->integer [1 2 3 4 5 6 7 8 9])])\n    (let ([closest (car integers)])\n\
    \      (let ([diff (- value closest)])\n        (if (< diff 0)\n            (let\
    \ ([closest (car integers)])\n              (let ([diff (- value closest)])\n\
    \                (if (< diff 0)\n                    (let ([closest (car integers)])\n\
    \                      (let ([diff (- value closest)])\n                     \
    \   (if (< diff 0)\n                            (let ([closest (car integers)])\n\
    \                              (let ([diff (- value closest)])\n             \
    \                   (if (< diff 0)\n                                    (let ([closest\
    \ (car integers)])\n                                      (let ([diff (- value\
    \ closest)])\n                                        (if (< diff 0)\n       \
    \                                     (let ([closest (car integers)])\n      \
    \                                        (let ([diff (- value closest)])\n   \
    \                                             (if (< diff 0)\n               \
    \                                     (let ([closest (car integers)])\n      \
    \                                                (let ([diff (- value closest)])\n\
    \                                                        (if (< diff 0)\n    \
    \                                                        (let ([closest (car integers)])\n\
    \                                                              (let ([diff (-\
    \ value closest)])\n                                                         \
    \       (if (< diff 0)\n                                                     \
    \               (let ([closest (car integers)])\n                            \
    \                                          (let ([diff (- value closest)])\n \
    \                                                                       (if (<\
    \ diff 0)\n                                                                  \
    \          (let ([closest (car integers)])\n                                 \
    \                                             (let ([diff (- value closest)])\n\
    \                                                                            \
    \    (if (< diff 0)\n                                                        \
    \                            (let ([closest (car integers)])\n               \
    \                                                                       (let ([diff\
    \ (- value closest)])\n                                                      \
    \                                  (if (< diff 0)\n                          \
    \                                                                  (let ([closest\
    \ (car integers)])\n                                                         \
    \                                     (let ([diff (- value closest)])\n      \
    \                                                                            \
    \              (if (< diff 0)\n                                              \
    \                                                      (let ([closest (car integers)])\n\
    \                                                                            \
    \                          (let ([diff (- value closest)])\n                 \
    \                                                                            \
    \           (if (< diff 0)\n                                                 \
    \                                                           (let ([closest (car\
    \ integers)])\n                                                              \
    \                                                (let ([diff (- value closest)])\n\
    \                                                                            \
    \                                    (if (< diff 0)\n                        \
    \                                                                            \
    \                (let ([closest (car integers)])\n                           \
    \                                                                            \
    \               (let ([diff (- value closest)])\n                            \
    \                                                                            \
    \                (if (< diff 0)\n                                            \
    \                                                                            \
    \    (let ([closest (car integers)])\n                                       \
    \                                                                            \
    \           (let ([diff (- value closest)])\n                                \
    \                                                                            \
    \                    (if (< diff 0)\n                                        \
    \                                                                            \
    \                (let ([closest (car integers)])\n                           \
    \                                     ", "  (let ([num (parse-integer value)]\n\
    \        [nums (list num)]\n        [num-diff (- num nums)])\n    (if (null? nums)\n\
    \        num\n        (let ([closest (first nums)])\n          (if (< (abs (-\
    \ num closest)) (abs (- closest num)))\n              closest\n              (first\
    \ nums))))))\n", "  (let ([integers (map integer->real '(1 2 3 4 5 6 7 8 9)))]\n\
    \    (let ([closest-integer (first integers)])\n      (if (< (abs (- value closest-integer))\
    \ (abs (- value integer)))\n          closest-integer\n          (let ([closest-integer\
    \ (first integers)])\n            (if (< (abs (- value closest-integer)) (abs\
    \ (- value integer)))\n                closest-integer\n                (let ([closest-integer\
    \ (first integers)])\n                  (if (< (abs (- value closest-integer))\
    \ (abs (- value integer)))\n                      closest-integer\n          \
    \            (let ([closest-integer (first integers)])\n                     \
    \   (if (< (abs (- value closest-integer)) (abs (- value integer)))\n        \
    \                    closest-integer\n                            (let ([closest-integer\
    \ (first integers)])\n                              (if (< (abs (- value closest-integer))\
    \ (abs (- value integer)))\n                                  closest-integer\n\
    \                                  (let ([closest-integer (first integers)])\n\
    \                                    (if (< (abs (- value closest-integer)) (abs\
    \ (- value integer)))\n                                        closest-integer\n\
    \                                        (let ([closest-integer (first integers)])\n\
    \                                          (if (< (abs (- value closest-integer))\
    \ (abs (- value integer)))\n                                              closest-integer\n\
    \                                              (let ([closest-integer (first integers)])\n\
    \                                                (if (< (abs (- value closest-integer))\
    \ (abs (- value integer)))\n                                                 \
    \   closest-integer\n                                                    (let\
    \ ([closest-integer (first integers)])\n                                     \
    \                 (if (< (abs (- value closest-integer)) (abs (- value integer)))\n\
    \                                                          closest-integer\n \
    \                                                         (let ([closest-integer\
    \ (first integers)])\n                                                       \
    \     (if (< (abs (- value closest-integer)) (abs (- value integer)))\n      \
    \                                                          closest-integer\n \
    \                                                               (let ([closest-integer\
    \ (first integers)])\n                                                       \
    \           (if (< (abs (- value closest-integer)) (abs (- value integer)))\n\
    \                                                                      closest-integer\n\
    \                                                                      (let ([closest-integer\
    \ (first integers)])\n                                                       \
    \                 (if (< (abs (- value closest-integer)) (abs (- value integer)))\n\
    \                                                                            closest-integer\n\
    \                                                                            (let\
    \ ([closest-integer (first integers)])\n                                     \
    \                                         (if (< (abs (- value closest-integer))\
    \ (abs (- value integer)))\n                                                 \
    \                                 closest-integer\n                          \
    \                                                        (let ([closest-integer",
  "  (let ([x (number->string value)]\n        [y (number->string value)])\n    (cond\n\
    \      [(equal? x y) value]\n      [(number->number (string->number x))\n    \
    \   (if (< (string->number y) (string->number x))\n           (string->number\
    \ x)\n           (string->number y))]))))\n", "  (let ((x (floor (/ value 10))))\n\
    \    (let ((y (floor (/ value 10))))\n      (cond\n        ((< x y) (ceiling value))\n\
    \        ((< y x) (ceiling value))\n        (else (round value)))))\n", "  (let\
    \ ([int-value (string->number (string->symbol value))])\n    (cond\n      [(<\
    \ int-value 0) (ceiling int-value)]\n      [(> int-value 0) (floor int-value)]\n\
    \      [else int-value])))\n", "  (let ((x (floor (/ value 10))))\n    (cond\n\
    \      [(< x 0) (ceil (/ value 10))]\n      [(< x 1) (ceil (/ value 10))]\n  \
    \    [(< x 10) (ceil (/ value 10))]\n      [else x])))\n", "  (let ([int-value\
    \ (string->number (string->symbol value))])\n    (cond\n      [(< int-value 0)\
    \ (ceiling int-value)]\n      [(> int-value 0) (floor int-value)]\n      [else\
    \ int-value])))\n", "  (let ((x (floor (/ value 10))))\n    (let ((y (floor (/\
    \ value 10))))\n      (if (= x y)\n          x\n          (if (< x y)\n      \
    \        (- y)\n              (- x))))))\n", "  (let ([integers (map integer->real\
    \ '(1 2 3 4 5 6 7 8 9))])\n    (let ([closest (car integers)])\n      (let ([diff\
    \ (- value closest)])\n        (if (< diff 0)\n          (let ([closest (car integers)])\n\
    \            (let ([diff (- value closest)])\n              (if (< diff 0)\n \
    \               (let ([closest (car integers)])\n                  (let ([diff\
    \ (- value closest)])\n                    (if (< diff 0)\n                  \
    \    (let ([closest (car integers)])\n                        (let ([diff (- value\
    \ closest)])\n                          (if (< diff 0)\n                     \
    \       (let ([closest (car integers)])\n                              (let ([diff\
    \ (- value closest)])\n                                (if (< diff 0)\n      \
    \                            (let ([closest (car integers)])\n               \
    \                     (let ([diff (- value closest)])\n                      \
    \                (if (< diff 0)\n                                        (let\
    \ ([closest (car integers)])\n                                          (let ([diff\
    \ (- value closest)])\n                                            (if (< diff\
    \ 0)\n                                              (let ([closest (car integers)])\n\
    \                                                (let ([diff (- value closest)])\n\
    \                                                  (if (< diff 0)\n          \
    \                                          (let ([closest (car integers)])\n \
    \                                                     (let ([diff (- value closest)])\n\
    \                                                        (if (< diff 0)\n    \
    \                                                      (let ([closest (car integers)])\n\
    \                                                            (let ([diff (- value\
    \ closest)])\n                                                              (if\
    \ (< diff 0)\n                                                               \
    \ (let ([closest (car integers)])\n                                          \
    \                        (let ([diff (- value closest)])\n                   \
    \                                                 (if (< diff 0)\n           \
    \                                                           (let ([closest (car\
    \ integers)])\n                                                              \
    \          (let ([diff (- value closest)])\n                                 \
    \                                         (if (< diff 0)\n                   \
    \                                                         (let ([closest (car\
    \ integers)])\n                                                              \
    \                (let ([diff (- value closest)])\n                           \
    \                                                     (if (< diff 0)\n       \
    \                                                                           (let\
    \ ([closest (car integers)])\n                                               \
    \                     (let ([diff (- value closest)])\n                      \
    \                                                (if (< diff 0)\n            \
    \                                                            (let ([closest (car\
    \ integers)])\n                                                              \
    \            (let ([diff (- value closest)])\n                               \
    \                                             (if (< diff 0)\n               \
    \                                                               (let ([closest\
    \ (car integers)])\n                                                         \
    \                       (let ([diff (- value closest)])\n                    \
    \                                                              (if (< diff 0)\n\
    \                                                                            \
    \        (let ([closest (car integers)])\n                                   \
    \                                                   (let ([diff (- value closest)])",
  "  (let ([integer (string->number (string->symbol value))])\n    (cond\n      [(<\
    \ integer 0) (error \"Closest integer not possible\")]\n      [(< integer 1) (error\
    \ \"Closest integer not possible\")]\n      [(< integer 2) (error \"Closest integer\
    \ not possible\")]\n      [(< integer 3) (error \"Closest integer not possible\"\
    )]\n      [(< integer 4) (error \"Closest integer not possible\")]\n      [(<\
    \ integer 5) (error \"Closest integer not possible\")]\n      [(< integer 6) (error\
    \ \"Closest integer not possible\")]\n      [(< integer 7) (error \"Closest integer\
    \ not possible\")]\n      [(< integer 8) (error \"Closest integer not possible\"\
    )]\n      [(< integer 9) (error \"Closest integer not possible\")]\n      [(<\
    \ integer 10) (error \"Closest integer not possible\")]\n      [(< integer 11)\
    \ (error \"Closest integer not possible\")]\n      [(< integer 12) (error \"Closest\
    \ integer not possible\")]\n      [(< integer 13) (error \"Closest integer not\
    \ possible\")]\n      [(< integer 14) (error \"Closest integer not possible\"\
    )]\n      [(< integer 15) (error \"Closest integer not possible\")]\n      [(<\
    \ integer 16) (error \"Closest integer not possible\")]\n      [(< integer 17)\
    \ (error \"Closest integer not possible\")]\n      [(< integer 18) (error \"Closest\
    \ integer not possible\")]\n      [(< integer 19) (error \"Closest integer not\
    \ possible\")]\n      [(< integer 20) (error \"Closest integer not possible\"\
    )]\n      [(< integer 21) (error \"Closest integer not possible\")]\n      [(<\
    \ integer 22) (error \"Closest integer not possible\")]\n      [(< integer 23)\
    \ (error \"Closest integer not possible\")]\n      [(< integer 24) (error \"Closest\
    \ integer not possible\")]\n      [(< integer 25) (error \"Closest integer not\
    \ possible\")]\n      [(< integer 26) (error \"Closest integer not possible\"\
    )]\n      [(< integer 27) (error \"Closest integer not possible\")]\n      [(<\
    \ integer 28) (error \"Closest integer not possible\")]\n      [(< integer 29)\
    \ (error \"Closest integer not possible\")]\n      [(< integer 30) (error \"Closest\
    \ integer not possible\")]\n      [(< integer 31) (error \"Closest integer not\
    \ possible\")]\n      [(< integer 32) (error \"Closest integer not possible\"\
    )]", "  (let ([num (parse-integer value)])\n    (cond [(< num 0) (- 0 (floor (-\
    \ num)))]\n          [(< num 0) (- 0 (ceiling (- num)))]\n          [else num])))\n",
  "  (let ((x (string->number (car value))\n        y (string->number (cadr value))))\n\
    \    (cond\n      [(and (< x 0) (< y 0)) (- (- x y) 1)]\n      [(and (< x 0) (<\
    \ y 1)) (- x y)]\n      [(and (< x 1) (< y 0)) (- (- x y) 1)]\n      [(and (<\
    \ x 1) (< y 1)) (- x y)]\n      [else (- x y)]))))\n", "  (let ([x (parse-integer\
    \ (string->symbol (symbol->string value)))])\n    (cond\n      [(< x 0) (error\
    \ \"Closest integer not possible for negative numbers\")]\n      [(< x 1) x]\n\
    \      [(< x 2) (- x)]\n      [else (- x)]))))\n", "  (let ([x (string->number\
    \ (car value))])\n    (let ([y (string->number (cadr value))])\n      (if (= x\
    \ y)\n          x\n          (if (< (abs (- x y)) (abs x))\n              (ceil\
    \ (/ x y))\n              (floor (/ x y))))))))\n", "  (let ([x (string->number\
    \ (car value))])\n    (let ([y (string->number (cadr value))])\n      (cond [(<\
    \ (abs (- x y)) (abs (- y x))) x]\n            [else y])))\n", "  (let ([x (string->number\
    \ (car value))])\n    (let ([y (string->number (cadr value))])\n      (if (and\
    \ (number? x) (number? y))\n          (if (< (abs (- x y)) (abs x))\n        \
    \      (- x y)\n              (- y x))\n          (- x y))))))\n", "  (let ([integers\
    \ (map number->integer '(1 2 3 4 5 6 7 8 9))])\n    (let ([closest (first integers)])\n\
    \      (if (< (abs (- value closest)) (abs (- value (car integers))))\n      \
    \    (first integers)\n          (let ([closest (first integers)])\n         \
    \   (if (< (abs (- value closest)) (abs (- value (car integers))))\n         \
    \       (first integers)\n                (let ([closest (first integers)])\n\
    \                  (if (< (abs (- value closest)) (abs (- value (car integers))))\n\
    \                      (first integers)\n                      (let ([closest\
    \ (first integers)])\n                        (if (< (abs (- value closest)) (abs\
    \ (- value (car integers))))\n                            (first integers)\n \
    \                           (let ([closest (first integers)])\n              \
    \                (if (< (abs (- value closest)) (abs (- value (car integers))))\n\
    \                                  (first integers)\n                        \
    \          (let ([closest (first integers)])\n                               \
    \     (if (< (abs (- value closest)) (abs (- value (car integers))))\n       \
    \                                 (first integers)\n                         \
    \               (let ([closest (first integers)])\n                          \
    \                (if (< (abs (- value closest)) (abs (- value (car integers))))\n\
    \                                              (first integers)\n            \
    \                                  (let ([closest (first integers)])\n       \
    \                                         (if (< (abs (- value closest)) (abs\
    \ (- value (car integers))))\n                                               \
    \     (first integers)\n                                                    (let\
    \ ([closest (first integers)])\n                                             \
    \         (if (< (abs (- value closest)) (abs (- value (car integers))))\n   \
    \                                                       (first integers)\n   \
    \                                                       (let ([closest (first\
    \ integers)])\n                                                            (if\
    \ (< (abs (- value closest)) (abs (- value (car integers))))\n               \
    \                                                 (first integers)\n         \
    \                                                       (let ([closest (first\
    \ integers)])\n                                                              \
    \    (if (< (abs (- value closest)) (abs (- value (car integers))))\n        \
    \                                                              (first integers)\n\
    \                                                                      (let ([closest\
    \ (first integers)])\n                                                       \
    \                 (if (< (abs (- value closest)) (abs (- value (car integers))))\n\
    \                                                                            (first\
    \ integers)\n                                                                \
    \            (let ([closest (first integers)])\n                             \
    \                                                 (if (< (abs (- value closest))\
    \ (abs (- value (car integers))))\n                                          \
    \                                        (first integers)\n                  \
    \                                                                (let ([closest\
    \ (first integer", "  (let ([integers (map integer? value)]\n        [min (min\
    \ integers)\n          max (max integers)])\n    (if (= min max)\n        min\n\
    \        (- max (abs (- min value))))))\n", "  (let ([x (string->number (car value))\n\
    \        y (+ (string->number (cadr value)) (- x))])\n    (if (< x y)\n      \
    \  x\n        y)))\n", "  (let ([integers (map integer? value)]\n        [min\
    \ (min integers)\n          max (max integers)])\n    (if (= min max)\n      \
    \  min\n        (- min (abs (- max min))))))\n", "  (let ([num (string->number\
    \ (car value))])\n    (cond\n      [(= num 0) 0]\n      [(< num 0) (ceiling num)]\n\
    \      [(> num 0) (floor num)]\n      [(= num 1) (ceiling num)]\n      [(< num\
    \ 1) (ceiling num)]\n      [(> num 1) (floor num)]\n      [else (+ num (closest_integer\
    \ (cdr value)))])))\n", "  (let ([x (floor value)]\n        [y (ceiling value)]\n\
    \        [diff (- x y)]\n        [diff (- x diff)]\n        [diff (- y diff)]\n\
    \        [diff (- diff diff)])\n    (if (= x y)\n        (values x y)\n      \
    \  (if (< diff 0)\n            (values x y)\n            (values x y))))))\n",
  "  (let ([x (floor value)])\n    (if (< x value)\n        x\n        (closest_integer\
    \ (- value x)))))\n", "  (let ([x (parse-integer (string->symbol (symbol->string\
    \ value)))])\n    (cond [(< x 0) (- 0 x)]\n          [(< x 1) (- 0 x)]\n     \
    \     [(< x 2) (- 0 x)]\n          [(< x 3) (- 0 x)]\n          [(< x 4) (- 0\
    \ x)]\n          [(< x 5) (- 0 x)]\n          [(< x 6) (- 0 x)]\n          [(<\
    \ x 7) (- 0 x)]\n          [(< x 8) (- 0 x)]\n          [(< x 9) (- 0 x)]\n  \
    \        [(< x 10) (- 0 x)]\n          [(< x 11) (- 0 x)]\n          [(< x 12)\
    \ (- 0 x)]\n          [(< x 13) (- 0 x)]\n          [(< x 14) (- 0 x)]\n     \
    \     [(< x 15) (- 0 x)]\n          [(< x 16) (- 0 x)]\n          [(< x 17) (-\
    \ 0 x)]\n          [(< x 18) (- 0 x)]\n          [(< x 19) (- 0 x)]\n        \
    \  [(< x 20) (- 0 x)]\n          [(< x 21) (- 0 x)]\n          [(< x 22) (- 0\
    \ x)]\n          [(< x 23) (- 0 x)]\n          [(< x 24) (- 0 x)]\n          [(<\
    \ x 25) (- 0 x)]\n          [(< x 26) (- 0 x)]\n          [(< x 27) (- 0 x)]\n\
    \          [(< x 28) (- 0 x)]\n          [(< x 29) (- 0 x)]\n          [(< x 30)\
    \ (- 0 x)]\n          [(< x 31) (- 0 x)]\n          [(< x 32) (- 0 x)]\n     \
    \     [(< x 33) (- 0 x)]\n          [(< x 34) (- 0 x)]\n          [(< x 35) (-\
    \ 0 x)]\n          [(< x 36) (- 0 x)]\n          [(< x 37) (- 0 x)]\n        \
    \  [(< x 38) (- 0 x)]\n          [(< x 39) (- 0 x)]\n          [(< x 40) (- 0\
    \ x)]\n          [(< x 41) (- 0 x)]\n          [(< x 42) (- 0 x)]\n          [(<\
    \ x 43) (- 0 x)]\n          [(< x ", "  (let ([x (parse-integer (string->symbol\
    \ (symbol->string value)))])\n    (cond\n      [(and (number? x) (number? x))\n\
    \       (if (< x 0)\n           (ceiling x)\n           (floor x))]\n      [(and\
    \ (number? x) (number? x))\n       (if (< x 0)\n           (ceiling x)\n     \
    \      (floor x))]\n      [(and (number? x) (number? x))\n       (if (< x 0)\n\
    \           (ceiling x)\n           (floor x))]\n      [(and (number? x) (number?\
    \ x))\n       (if (< x 0)\n           (ceiling x)\n           (floor x))]\n  \
    \    [(and (number? x) (number? x))\n       (if (< x 0)\n           (ceiling x)\n\
    \           (floor x))]\n      [(and (number? x) (number? x))\n       (if (< x\
    \ 0)\n           (ceiling x)\n           (floor x))]\n      [(and (number? x)\
    \ (number? x))\n       (if (< x 0)\n           (ceiling x)\n           (floor\
    \ x))]\n      [(and (number? x) (number? x))\n       (if (< x 0)\n           (ceiling\
    \ x)\n           (floor x))]\n      [(and (number? x) (number? x))\n       (if\
    \ (< x 0)\n           (ceiling x)\n           (floor x))]\n      [(and (number?\
    \ x) (number? x))\n       (if (< x 0)\n           (ceiling x)\n           (floor\
    \ x))]\n      [(and (number? x) (number? x))\n       (if (< x 0)\n           (ceiling\
    \ x)\n           (floor x))]\n      [(and (number? x) (number? x))\n       (if\
    \ (< x 0)\n           (ceiling x)\n           (floor x))]\n      [(and (number?\
    \ x) (number? x))\n       (if (< x 0)\n           (ceiling x)\n           (floor\
    \ x))]\n      [(and (number? x) (number? x))\n       (if (< x 0)\n           (ceiling\
    \ x)\n           (floor x))]\n      [(and (number? x) (number? x))\n       (if\
    \ (< x 0)\n           (ceiling x)\n           (floor x))]\n      [(and (number?\
    \ x) (number? x))\n       (if (< x 0)\n           (ceiling x)\n           (floor\
    \ x))]\n      [(and (number? x) (number? x))\n       (if (< x 0)\n           (ceiling\
    \ x)\n           (floor x))]\n      [(and (number? x) (number? x))\n       (if\
    \ (", "  (let ((closest-integer (min (floor (/ value 10)) (floor (/ value 10)))))\n\
    \    (if (= (- value closest-integer) 0)\n        closest-integer\n        (closest_integer\
    \ (- value closest-integer)))))\n", "  (let ([x (floor value)]\n        [y (ceiling\
    \ value)]\n        [xdiff (- x y)]\n        [ydiff (- y x)]\n        [xdiff (-\
    \ xdiff ydiff)]\n        [ydiff (- ydiff xdiff)])\n    (if (= x y)\n        x\n\
    \        (if (< xdiff ydiff)\n            (+ x 1)\n            (+ y 1)))))\n",
  "  (let ([num (parse-integer value)]\n        [nums (list num)]\n        [nums (append\
    \ nums (list num))])\n    (if (null? nums)\n        num\n        (let ([closest\
    \ (car nums)])\n          (let ([diff (- num closest)])\n            (if (< diff\
    \ 0)\n                (closest_integer diff)\n                closest)))))))\n",
  "  (let ([x (string->number (car value))])\n    (let ([y (string->number (cadr value))])\n\
    \      (cond\n        ((< (abs (- x y)) (abs x))\n         (+ x 1))\n        ((<\
    \ (abs (- x y)) (abs y))\n         (+ y 1))\n        (else (+ x y))))))\n", " \
    \ (let ([integer (parse-integer value)]\n        [integers (list integer)]\n \
    \       [closest (car integers)])\n    (if (null? integers)\n        closest\n\
    \        (let ([next (min (cdr integers) (abs (- value integer)))])\n        \
    \  (if (< value next)\n              (closest_integer next)\n              (closest_integer\
    \ integer))))))\n", "  (let ([x (string->number (car value))])\n    (cond\n  \
    \    [(< x 0) (ceiling x)]\n      [(> x 0) (floor x)]\n      [else x])))\n", " \
    \ (let ([int-value (string->number (string->symbol value))])\n    (cond\n    \
    \  [(< int-value 0) (ceiling int-value)]\n      [(> int-value 0) (floor int-value)]\n\
    \      [else int-value])))\n", "  (let ([x (parse-integer (string->symbol (string->symbol\
    \ value)))])\n    (cond [(< x 0) (parse-integer 0)]\n          [(< x 1) (parse-integer\
    \ 1)]\n          [(< x 2) (parse-integer 2)]\n          [(< x 3) (parse-integer\
    \ 3)]\n          [(< x 4) (parse-integer 4)]\n          [(< x 5) (parse-integer\
    \ 5)]\n          [(< x 6) (parse-integer 6)]\n          [(< x 7) (parse-integer\
    \ 7)]\n          [(< x 8) (parse-integer 8)]\n          [(< x 9) (parse-integer\
    \ 9)]\n          [(< x 10) (parse-integer 10)]\n          [(< x 11) (parse-integer\
    \ 11)]\n          [(< x 12) (parse-integer 12)]\n          [(< x 13) (parse-integer\
    \ 13)]\n          [(< x 14) (parse-integer 14)]\n          [(< x 15) (parse-integer\
    \ 15)]\n          [(< x 16) (parse-integer 16)]\n          [(< x 17) (parse-integer\
    \ 17)]\n          [(< x 18) (parse-integer 18)]\n          [(< x 19) (parse-integer\
    \ 19)]\n          [(< x 20) (parse-integer 20)]\n          [(< x 21) (parse-integer\
    \ 21)]\n          [(< x 22) (parse-integer 22)]\n          [(< x 23) (parse-integer\
    \ 23)]\n          [(< x 24) (parse-integer 24)]\n          [(< x 25) (parse-integer\
    \ 25)]\n          [(< x 26) (parse-integer 26)]\n          [(< x 27) (parse-integer\
    \ 27)]\n          [(< x 28) (parse-integer 28)]\n          [(< x 29) (parse-integer\
    \ 29)]\n          [(< x 30) (parse-integer 30)]\n          [(< x 31) (parse-integer\
    \ 31)]\n          [(< x 32) (parse-integer 32)]\n          [(< x 33) (parse-integer\
    \ 33)]\n          [(< x 34) (parse-integer 34)]\n          [(< x 35) (parse-integer\
    \ 35)]\n          [(< x 36) (parse-integer 36)]\n          [(< x 37) (parse-integer\
    \ 37)]\n          [(< x 38) (parse-integer 38)]\n          [(< x 39) (parse-integer\
    \ 39)]\n          [(< x 40) (parse-integer 40)]\n", "  (let ((integer (floor (/\
    \ value 10))))\n    (if (= (- value integer) 0)\n        integer\n        (closest_integer\
    \ (- value integer)))))\n", "  (let ([num (string->number (car value))])\n   \
    \ (cond [(< num 0) (- 0 (floor (- num)))]\n          [(> num 0) (- 0 (ceiling\
    \ (- num)))]\n          [else num])))\n", "  (let ([num (parse-integer value)])\n\
    \    (cond [(< num 0) (- num 1)] [(< num 1) (- num 0)]\n          [(< num 0) (-\
    \ num 0)]\n          [(< num 1) (- num 1)]\n          [else num])))\n", "  (define\
    \ (closest-integer-helper value low-bound high-bound)\n    (cond ((< value low-bound)\n\
    \           (if (< value high-bound)\n               (+ low-bound 1)\n       \
    \        (+ high-bound 1)))\n          ((< value high-bound)\n           (if (<\
    \ value low-bound)\n               (+ high-bound 1)\n               (+ low-bound\
    \ 1)))\n          ((< value low-bound)\n           (if (< value high-bound)\n\
    \               (+ low-bound 1)\n               (+ high-bound 1)))\n         \
    \ ((< value high-bound)\n           (if (< value low-bound)\n               (+\
    \ high-bound 1)\n               (+ low-bound 1)))\n          (else\n         \
    \  (+ low-bound 1)))\n    (closest-integer-helper value low-bound high-bound))\n\
    \  (closest-integer-helper value 0 1))\n", "  (let ([x (string->number (car value))])\n\
    \    (let ([y (string->number (cadr value))])\n      (if (= x y)\n          x\n\
    \          (if (< (abs (- x y)) (abs x))\n              (ceiling x)\n        \
    \      (floor x))))))\n", "  (let ([integer (parse-integer value)]\n        [integers\
    \ (list integer)]\n        [diff (abs (- integer integers))])\n    (cond\n   \
    \   [(empty? integers) integer]\n      [(< diff 0) (first integers)]\n      [else\
    \ (first integers)]))))\n", "  (let ([num (number->string value)]\n        [nums\
    \ (number->list value)]\n        [min (number->string 0)]\n        [max (number->string\
    \ 0)])\n    (cond\n      [(empty? nums) (number->string 0)]\n      [(empty? num)\
    \ (number->string 0)]\n      [(number->string=? num min) (number->string 0)]\n\
    \      [(number->string=? num max) (number->string 0)]\n      [(number->string=?\
    \ num nums) (number->string 0)]\n      [(number->string=? num num) (number->string\
    \ 0)]\n      [(number->string=? num nums) (number->string 0)]\n      [(number->string=?\
    \ num num) (number->string 0)]\n      [(number->string=? num min) (number->string\
    \ 0)]\n      [(number->string=? num max) (number->string 0)]\n      [(number->string=?\
    \ num nums) (number->string 0)]\n      [(number->string=? num num) (number->string\
    \ 0)]\n      [(number->string=? num nums) (number->string 0)]\n      [(number->string=?\
    \ num num) (number->string 0)]\n      [(number->string=? num nums) (number->string\
    \ 0)]\n      [(number->string=? num num) (number->string 0)]\n      [(number->string=?\
    \ num nums) (number->string 0)]\n      [(number->string=? num num) (number->string\
    \ 0)]\n      [(number->string=? num nums) (number->string 0)]\n      [(number->string=?\
    \ num num) (number->string 0)]\n      [(number->string=? num nums) (number->string\
    \ 0)]\n      [(number->string=? num num) (number->string 0)]\n      [(number->string=?\
    \ num nums) (number->string 0)]\n      [(number->string=? num num) (number->string\
    \ 0)]\n      [(number->string=? num nums) (number->string 0)]\n      [(number->string=?\
    \ num num) (number->string 0)]\n      [(number->string=? num nums) (number->string\
    \ 0)]\n      [(number->string=? num num) (number->string 0)]\n      [(number->string=?\
    \ num nums) (number->string 0)]\n      [(", "  (let ([x (parse-integer value)]\n\
    \        [y (parse-integer value)])\n    (cond [(< x y) x]\n          [(< y x)\
    \ y]\n          [else (round (/ (- x y) 2))])))\n", "  (let ([int-value (string->number\
    \ (string->symbol value))])\n    (cond\n      [(< int-value 0) (error \"Closest\
    \ integer not possible.\")]\n      [(< int-value 1) (error \"Closest integer not\
    \ possible.\")]\n      [else (round (abs (- int-value 1)))])))\n", "  (let ([num\
    \ (number->string value)]\n        [nums (number->list value)]\n        [nums-length\
    \ (length nums)])\n    (if (= nums-length 0)\n        0\n        (let ([num-length\
    \ (length num)])\n          (let ([num-lengths (number->list num-length)]\n  \
    \              [num-lengths-length (length num-lengths)])\n            (if (=\
    \ num-lengths-length 0)\n                0\n                (let ([num-lengths-lengths\
    \ (number->list num-lengths-length)]\n                      [num-lengths-lengths-length\
    \ (length num-lengths-lengths)])\n                  (if (= num-lengths-lengths-length\
    \ 0)\n                      0\n                      (let ([num-lengths-lengths-lengths\
    \ (number->list num-lengths-lengths-length)]\n                            [num-lengths-lengths-lengths-length\
    \ (length num-lengths-lengths-lengths)])\n                        (if (= num-lengths-lengths-lengths-length\
    \ 0)\n                            0\n                            (let ([num-lengths-lengths-lengths-lengths\
    \ (number->list num-lengths-lengths-lengths-length)]\n                       \
    \           [num-lengths-lengths-lengths-lengths-length (length num-lengths-lengths-lengths-lengths)])\n\
    \                              (if (= num-lengths-lengths-lengths-lengths-length\
    \ 0)\n                                  0\n                                  (let\
    \ ([num-lengths-lengths-lengths-lengths-lengths (number->list num-lengths-lengths-lengths-lengths-length)]\n\
    \                                        [num-lengths-lengths-lengths-lengths-lengths-length\
    \ (length num-lengths-lengths-lengths-lengths-lengths)])\n                   \
    \                 (if (= num-lengths-lengths-lengths-lengths-lengths-length 0)\n\
    \                                        0\n                                 \
    \       (let ([num-lengths-lengths-lengths-lengths-lengths-lengths (number->list\
    \ num-lengths-lengths-lengths-lengths-lengths-length)]\n                     \
    \                         [num-lengths-lengths-lengths-lengths-lengths-lengths-length\
    \ (length num-lengths-lengths-lengths-lengths-lengths-lengths)])\n           \
    \                               (if (= num-lengths-lengths-lengths-lengths-lengths-lengths-length\
    \ 0)\n                                              0\n                      \
    \                        (let ([num-lengths-lengths-lengths-lengths-lengths-lengths-lengths\
    \ (number->list num-lengths-lengths-lengths-lengths-lengths-lengths-length)]\n\
    \                                                    [num-lengths-lengths-lengths-length",
  "  (let ([x (string->number (car value))\n        y (string->number (cadr value))])\n\
    \    (cond\n      [(and (number? x) (number? y)) (round (min x y))]\n      [(and\
    \ (number? x) (not (number? y))) (round (max x y))]\n      [(and (not (number?\
    \ x)) (number? y)) (round (max x y))]\n      [(and (not (number? x)) (not (number?\
    \ y))) (round (min x y))]\n      [else (round (min x y))]))))\n", "  (let ([integers\
    \ (map integer->real '(1 2 3 4 5 6 7 8 9))])\n    (let ([closest (first integers)])\n\
    \      (let ([diff (- value closest)])\n        (if (< diff 0)\n            (let\
    \ ([closest (first integers)])\n              (let ([diff (- value closest)])\n\
    \                (if (< diff 0)\n                    (let ([closest (first integers)])\n\
    \                      (let ([diff (- value closest)])\n                     \
    \   (if (< diff 0)\n                            (let ([closest (first integers)])\n\
    \                              (let ([diff (- value closest)])\n             \
    \                   (if (< diff 0)\n                                    (let ([closest\
    \ (first integers)])\n                                      (let ([diff (- value\
    \ closest)])\n                                        (if (< diff 0)\n       \
    \                                     (let ([closest (first integers)])\n    \
    \                                          (let ([diff (- value closest)])\n \
    \                                               (if (< diff 0)\n             \
    \                                       (let ([closest (first integers)])\n  \
    \                                                    (let ([diff (- value closest)])\n\
    \                                                        (if (< diff 0)\n    \
    \                                                        closest\n           \
    \                                                 (closest)))\n              \
    \                                    (closest))\n                            \
    \                  (closest))\n                                            (closest))\n\
    \                                          (closest))\n                      \
    \                  (closest))\n                                      (closest))\n\
    \                                  (closest))\n                              \
    \  (closest))\n                              (closest))\n                    \
    \        (closest))\n                          (closest))\n                  \
    \      (closest))\n                    (closest))\n                (closest))\n\
    \              (closest))\n            (closest))\n          (closest)))))))))\n",
  "  (let ([integers (map integer? value)]\n        [mins (map min integers)])\n \
    \   (if (null? mins)\n        0\n        (let ([closest (car mins)])\n       \
    \   (if (< (abs (- value closest)) (abs (- value integers)))\n              closest\n\
    \              (closest_integer (- value integers)))))))\n", "  (let ([x (parse-integer\
    \ (string->symbol (symbol->string value)))])\n    (cond [(< x 0) (error \"Closest\
    \ integer not possible.\")]\n          [(< x 1) x]\n          [(< x 10) (+ x 10)]\n\
    \          [(< x 100) (+ x 100)]\n          [(< x 1000) (+ x 1000)]\n        \
    \  [(< x 10000) (+ x 10000)]\n          [(< x 100000) (+ x 100000)]\n        \
    \  [(< x 1000000) (+ x 1000000)]\n          [(< x 10000000) (+ x 10000000)]\n\
    \          [(< x 100000000) (+ x 100000000)]\n          [(< x 1000000000) (+ x\
    \ 1000000000)]\n          [(< x 10000000000) (+ x 10000000000)]\n          [(<\
    \ x 100000000000) (+ x 100000000000)]\n          [(< x 1000000000000) (+ x 1000000000000)]\n\
    \          [(< x 10000000000000) (+ x 10000000000000)]\n          [(< x 100000000000000)\
    \ (+ x 100000000000000)]\n          [(< x 1000000000000000) (+ x 1000000000000000)]\n\
    \          [(< x 10000000000000000) (+ x 10000000000000000)]\n          [(< x\
    \ 100000000000000000) (+ x 100000000000000000)]\n          [(< x 1000000000000000000)\
    \ (+ x 1000000000000000000)]\n          [(< x 10000000000000000000) (+ x 10000000000000000000)]\n\
    \          [(< x 100000000000000000000) (+ x 100000000000000000000)]\n       \
    \   [(< x 1000000000000000000000) (+ x 1000000000000000000000)]\n          [(<\
    \ x 10000000000000000000000) (+ x 10000000000000000000000)]\n          [(< x 100000000000000000000000)\
    \ (+ x 100000000000000000000000)]\n          [(< x 1000000000000000000000000)\
    \ (+ x 1000000000000000000000000)]\n          [(< x 10000000000000000000000000)\
    \ (+ x 10000000000000000000000000)]\n          [(< x 10000000000000000000000000000000000)\
    \ (+ x 10000000000000000000000000000000000)]\n          [(< x 100000000000000000000000000000000000)\
    \ (+ x 100000000000000000000000000000000000)]\n          [(< x 1000000000000000000000000000000000000)\
    \ (+ x 1000000000000000000000000000000000000)]\n          [(< x 10000000000000000000000000000000000000)\
    \ (+ x 10000000000000000000000000000000000000)]\n          [(< x 100000000000000000000000000000000000000)\
    \ (+ x 100000000000000000000000000000000000000)]\n          [(< x 1000000000000000000000000000000000000000)\
    \ (+ x 1000000000000000000000000000000000000000)]\n          [(< x 10000000000000000000000000000000000000000)\
    \ (+ x 10000000000000000000000000000000000000000)]\n          [(< x 100000000000000000000000000000000000000000)\
    \ (+ ", "  (let ([integers (map integer->real '(1 2 3 4 5 6 7 8 9))])\n    (let\
    \ ([closest (first integers)])\n      (let ([diff (- value closest)])\n      \
    \  (cond\n          [(< diff 0) (first integers)]\n          [(< diff (first integers))\
    \ (second integers)]\n          [else (let ([closest2 (first integers)])\n   \
    \               (let ([diff2 (- diff closest2)])\n                    (cond\n\
    \                      [(< diff2 0) (first integers)]\n                      [(<\
    \ diff2 (first integers)) (second integers)]\n                      [else (let\
    \ ([closest3 (first integers)])\n                              (let ([diff3 (-\
    \ diff2 closest3)])\n                                (cond\n                 \
    \                 [(< diff3 0) (first integers)]\n                           \
    \       [(< diff3 (first integers)) (second integers)]\n                     \
    \             [else (let ([closest4 (first integers)])\n                     \
    \                     (let ([diff4 (- diff3 closest4)])\n                    \
    \                        (cond\n                                             \
    \ [(< diff4 0) (first integers)]\n                                           \
    \   [(< diff4 (first integers)) (second integers)]\n                         \
    \                     [else (let ([closest5 (first integers)])\n             \
    \                                         (let ([diff5 (- diff4 closest5)])\n\
    \                                                        (cond\n             \
    \                                             [(< diff5 0) (first integers)]\n\
    \                                                          [(< diff5 (first integers))\
    \ (second integers)]\n                                                       \
    \   [else (let ([closest6 (first integers)])\n                               \
    \                                 (let ([diff6 (- diff5 closest6)])\n        \
    \                                                          (cond\n           \
    \                                                         [(< diff6 0) (first\
    \ integers)]\n                                                               \
    \     [(< diff6 (first integers)) (second integers)]\n                       \
    \                                             [else (let ([closest7 (first integers)])\n\
    \                                                            (let ([diff7 (- diff6\
    \ closest7)])\n                                                              (cond\n\
    \                                                                [(< diff7 0)\
    \ (first integers)]\n                                                        \
    \        [(< diff7 (first integers)) (second integers)]\n                    \
    \                                            [else (let ([closest8 (first integers)])\n\
    \                                                                        (let\
    \ ([diff8 (- diff7 closest8)])\n                                             \
    \                             (cond\n                                        \
    \                                    [(< diff8 0) (first integers)]\n        \
    \                                                                    [(< diff8\
    \ (first integers)) (second integers)]\n                                     \
    \                                       [else (let ([closest9 (first integers)])\n\
    \                                                                            \
    \         (let ([diff9 (- diff8 closest9)])\n                                \
    \                                                      (cond\n               \
    \                                                                         [(<\
    \ diff9 0) (first integers)]\n                                               \
    \                                         [(< diff9 (first integer", "  (let ([num\
    \ (string->number (car value))])\n    (cond [(< num 0) (ceiling num)]\n      \
    \    [(> num 0) (floor num)]\n          [else num])))\n", "  (let ([x (number->string\
    \ value)]\n        [y (number->string value)])\n    (cond\n      [(equal? x y)\
    \ value]\n      [(equal? x \"-\") (- 0 (number->integer value))]\n      [(equal?\
    \ y \"-\") (- 0 (number->integer value))]\n      [(equal? x \"0\") (- 0 (number->integer\
    \ value))]\n      [(equal? y \"0\") (- 0 (number->integer value))]\n      [(equal?\
    \ x \"1\") (- 0 (number->integer value))]\n      [(equal? y \"1\") (- 0 (number->integer\
    \ value))]\n      [(equal? x \"2\") (- 0 (number->integer value))]\n      [(equal?\
    \ y \"2\") (- 0 (number->integer value))]\n      [(equal? x \"3\") (- 0 (number->integer\
    \ value))]\n      [(equal? y \"3\") (- 0 (number->integer value))]\n      [(equal?\
    \ x \"4\") (- 0 (number->integer value))]\n      [(equal? y \"4\") (- 0 (number->integer\
    \ value))]\n      [(equal? x \"5\") (- 0 (number->integer value))]\n      [(equal?\
    \ y \"5\") (- 0 (number->integer value))]\n      [(equal? x \"6\") (- 0 (number->integer\
    \ value))]\n      [(equal? y \"6\") (- 0 (number->integer value))]\n      [(equal?\
    \ x \"7\") (- 0 (number->integer value))]\n      [(equal? y \"7\") (- 0 (number->integer\
    \ value))]\n      [(equal? x \"8\") (- 0 (number->integer value))]\n      [(equal?\
    \ y \"8\") (- 0 (number->integer value))]\n      [(equal? x \"9\") (- 0 (number->integer\
    \ value))]\n      [(equal? y \"9\") (- 0 (number->integer value))]\n      [else\
    \ (- 0 (number->integer value))]))))\n", "  (let ([x (string->number (car value))\n\
    \        y (+ (string->number (cadr value)) (/ x 10))])\n    (cond\n      [(<\
    \ x y) (value->string value)\n       (< y x) (value->string value)\n       (<\
    \ x y) (value->string value)\n       (< y x) (value->string value)]\n      [(<\
    \ x y) (value->string value)\n       (< y x) (value->string value)\n       (<\
    \ x y) (value->string value)\n       (< y x) (value->string value)]\n      [(<\
    \ x y) (value->string value)\n       (< y x) (value->string value)\n       (<\
    \ x y) (value->string value)\n       (< y x) (value->string value)]\n      [(<\
    \ x y) (value->string value)\n       (< y x) (value->string value)\n       (<\
    \ x y) (value->string value)\n       (< y x) (value->string value)]))))\n", " \
    \ (let ([x (number->string value)]\n        [y (number->string value)])\n    (if\
    \ (= x y)\n        (number->integer value)\n        (let ([x (number->string value)]\n\
    \              [y (number->string value)])\n          (if (= x y)\n          \
    \    (number->integer value)\n              (let ([x (number->string value)]\n\
    \                    [(+ (string->number x) (string->number y))\n            \
    \         (+ (string->number x) (string->number y)])\n                (if (< x\
    \ y)\n                    (number->integer value)\n                    (number->integer\
    \ x))))))))\n", "  (let ([int-value (string->number (string->symbol value))])\n\
    \    (cond\n      [(< int-value 0) (ceiling int-value)]\n      [(> int-value 0)\
    \ (floor int-value)]\n      [(= int-value 0) 0]\n      [(< int-value int-value)\
    \ (ceiling int-value)]\n      [(> int-value int-value) (floor int-value)]\n  \
    \    [else (round int-value)])))\n", "  (let ((x (floor (/ value 10))))\n    (let\
    \ ((y (floor (/ value 10))))\n      (if (= x y)\n          x\n          (if (<\
    \ x y)\n              (+ x 1)\n              (- x 1))))))\n", "  (let ([x (string->number\
    \ (car value))])\n    (let ([y (string->number (cadr value))])\n      (if (and\
    \ (number? x) (number? y))\n          (if (equal? x y)\n              (round x)\n\
    \              (round (- x y)))\n          (round (- x y))))))\n", "  (define\
    \ (closest-integer-helper value num-list)\n    (cond [(null? num-list) value]\n\
    \          [(< (abs (- value (car num-list))) (car num-list)) (closest-integer-helper\
    \ (car num-list) (cdr num-list))]\n          [else (closest-integer-helper (car\
    \ num-list) (cdr num-list))]\n          ))\n  (closest-integer-helper value '(0\
    \ 1)))\n", "  (let ((closest-integer (min (abs (- value 1))\n                \
    \               (abs (- value 2)))))\n    (if (= closest-integer 0)\n        0\n\
    \        (ceiling closest-integer))))\n", "  (let ([x (number->string value)]\n\
    \        [y (number->string value)])\n    (cond\n      [(equal? x y) value]\n\
    \      [(equal? x \"-\") value]\n      [(equal? y \"-\") value]\n      [(equal?\
    \ x \"0\") value]\n      [(equal? y \"0\") value]\n      [(equal? x \"1\") value]\n\
    \      [(equal? y \"1\") value]\n      [(equal? x \"2\") value]\n      [(equal?\
    \ y \"2\") value]\n      [(equal? x \"3\") value]\n      [(equal? y \"3\") value]\n\
    \      [(equal? x \"4\") value]\n      [(equal? y \"4\") value]\n      [(equal?\
    \ x \"5\") value]\n      [(equal? y \"5\") value]\n      [(equal? x \"6\") value]\n\
    \      [(equal? y \"6\") value]\n      [(equal? x \"7\") value]\n      [(equal?\
    \ y \"7\") value]\n      [(equal? x \"8\") value]\n      [(equal? y \"8\") value]\n\
    \      [(equal? x \"9\") value]\n      [(equal? y \"9\") value]\n      [(equal?\
    \ x \".\") value]\n      [(equal? y \".\") value]\n      [(equal? x \"-\") (ceiling\
    \ (number->double value))]\n      [(equal? y \"-\") (ceiling (number->double value))]\n\
    \      [(equal? x \"0\") (ceiling (number->double value))]\n      [(equal? y \"\
    0\") (ceiling (number->double value))]\n      [(equal? x \"1\") (ceiling (number->double\
    \ value))]\n      [(equal? y \"1\") (ceiling (number->double value))]\n      [(equal?\
    \ x \"2\") (ceiling (number->double value))]\n      [(equal? y \"2\") (ceiling\
    \ (number->double value))]\n      [(equal? x \"3\") (ceiling (number->double value))]\n\
    \      [(equal? y \"3\") (ceiling (number->double value))]\n      [(equal? x \"\
    4\") (ceiling (number->double value))]\n      [(equal? y \"4\") (ceiling (number->double\
    \ value))]\n      [(equal? x \"5\") (ceiling (number->double value))]\n      [(equal?\
    \ y \"5\") (ceiling (number->double value))]\n      [(equal? x \"", "  (let ([x\
    \ (string->number (car value))])\n    (cond\n      [(< x 0) (error \"Given value\
    \ is not a number\")]\n      [(< x 1) x]\n      [(< x 10) (+ x 10)]\n      [else\
    \ (+ x 10)]))))\n", "  (let ([num (number->string value)]\n        [nums (number->list\
    \ value)]\n        [num-length (length nums)])\n    (if (= num-length 0)\n   \
    \     0\n        (let ([closest-num (number->string 0)]\n              [closest-nums\
    \ (number->list 0)])\n          (if (< (length nums) 2)\n              (if (<\
    \ (length nums) 1)\n                  (if (< (length nums) 0)\n              \
    \        (if (< (length nums) -1)\n                          (if (< (length nums)\
    \ -2)\n                              (if (< (length nums) -3)\n              \
    \                    (if (< (length nums) -4)\n                              \
    \        (if (< (length nums) -5)\n                                          (if\
    \ (< (length nums) -6)\n                                              (if (< (length\
    \ nums) -7)\n                                                  (if (< (length\
    \ nums) -8)\n                                                      (if (< (length\
    \ nums) -9)\n                                                          (if (<\
    \ (length nums) -10)\n                                                       \
    \       (if (< (length nums) -11)\n                                          \
    \                        (if (< (length nums) -12)\n                         \
    \                                             (if (< (length nums) -13)\n    \
    \                                                                      (if (<\
    \ (length nums) -14)\n                                                       \
    \                       (if (< (length nums) -15)\n                          \
    \                                                        (if (< (length nums)\
    \ -16)\n                                                                     \
    \                 (if (< (length nums) -17)\n                                \
    \                                                          (if (< (length nums)\
    \ -18)\n                                                                     \
    \                         (if (< (length nums) -19)\n                        \
    \                                                                          (if\
    \ (< (length nums) -20)\n                                                    \
    \                                                  (if (< (length nums) -21)\n\
    \                                                                            \
    \                              (if (< (length nums) -22)\n                   \
    \                                                                            \
    \               (if (< (length nums) -23)\n                                  \
    \                                                                            \
    \    (if (< (length nums) -24)\n                                             \
    \                                                                         (if\
    \ (< (length nums) -25)\n                                                    \
    \                                                                      (if (<\
    \ (length nums) -26)\n                                                       \
    \                                                                       (if (<\
    \ (length nums) -27)\n                                                       \
    \                                                                           (if\
    \ (< (length nums) -28)\n                                                    \
    \                                                                            \
    \      (if (< (length nums) -29)\n                                           \
    \                                                                            \
    \                   (if (< (length nums) -30)\n                              \
    \                                                                            \
    \                                    (if (< (length nums) -31)\n             \
    \                                                                            \
    \                                                         (if (< (length nums)\
    \ -32)\n                                                                     \
    \                                                                            \
    \     (if (< (length nums) -33)\n                                            \
    \                                                                            \
    \                                  (if (< (length nums) -34)\n               \
    \                                                                            \
    \                                                                   (if (< (length\
    \ nums) -35)\n                                                               \
    \                                                                            \
    \                       (if (< (length nums) -36)\n                          \
    \                                                                            \
    \                                                                (if (< (length\
    \ nums) -37)\n                                                               \
    \                                                                            \
    \                               (if (< (length nums) ", "  (let ([x (number->string\
    \ value)]\n        [y (number->string value)])\n    (cond\n      [(equal? x y)\
    \ value]\n      [(equal? x \"-\") (- 0 (string->number y))] \n      [(equal? y\
    \ \"-\") (- 0 (string->number x))]\n      [(equal? x \"0\") (- 0 (string->number\
    \ y))] \n      [(equal? y \"0\") (- 0 (string->number x))]\n      [(equal? x \"\
    1\") (- 0 (string->number y))] \n      [(equal? y \"1\") (- 0 (string->number\
    \ x))]\n      [(equal? x \"2\") (- 0 (string->number y))] \n      [(equal? y \"\
    2\") (- 0 (string->number x))]\n      [(equal? x \"3\") (- 0 (string->number y))]\
    \ \n      [(equal? y \"3\") (- 0 (string->number x))]\n      [(equal? x \"4\"\
    ) (- 0 (string->number y))] \n      [(equal? y \"4\") (- 0 (string->number x))]\n\
    \      [(equal? x \"5\") (- 0 (string->number y))] \n      [(equal? y \"5\") (-\
    \ 0 (string->number x))]\n      [(equal? x \"6\") (- 0 (string->number y))] \n\
    \      [(equal? y \"6\") (- 0 (string->number x))]\n      [(equal? x \"7\") (-\
    \ 0 (string->number y))] \n      [(equal? y \"7\") (- 0 (string->number x))]\n\
    \      [(equal? x \"8\") (- 0 (string->number y))] \n      [(equal? y \"8\") (-\
    \ 0 (string->number x))]\n      [(equal? x \"9\") (- 0 (string->number y))] \n\
    \      [(equal? y \"9\") (- 0 (string->number x))]\n      [else (- 0 (string->number\
    \ x))])))\n", "  (let ((x (floor (/ value 10))))\n    (cond\n      [(< x 9) (+\
    \ x 10)]\n      [(< x 8) (+ x 10)]\n      [(< x 7) (+ x 10)]\n      [(< x 6) (+\
    \ x 10)]\n      [(< x 5) (+ x 10)]\n      [(< x 4) (+ x 10)]\n      [(< x 3) (+\
    \ x 10)]\n      [(< x 2) (+ x 10)]\n      [(< x 1) (+ x 10)]\n      [else x])))\n",
  "  (let ((x (floor (/ value 10))))\n    (if (= x 0)\n        0\n        (+ x (closest_integer\
    \ (- value x))))))\n", "  (let ([num (parse-integer value)]\n        [num2 (parse-integer\
    \ value)])\n    (cond\n      [(< num 0) (parse-integer 0)]\n      [(< num2 0)\
    \ (parse-integer 0)]\n      [(< num num2) (parse-integer 0)]\n      [(< num2 num)\
    \ (parse-integer 0)]\n      [(< num num2) (parse-integer num)]\n      [(< num2\
    \ num) (parse-integer num)]\n      [(< num num2) (parse-integer num2)]\n     \
    \ [(< num2 num) (parse-integer num2)]\n      [(< num num2) (parse-integer num2)]\n\
    \      [(< num2 num) (parse-integer num2)]\n      [(< num num2) (parse-integer\
    \ num2)]\n      [(< num2 num) (parse-integer num2)]\n      [(< num num2) (parse-integer\
    \ num2)]\n      [(< num2 num) (parse-integer num2)]\n      [(< num num2) (parse-integer\
    \ num2)]\n      [(< num2 num) (parse-integer num2)]\n      [(< num num2) (parse-integer\
    \ num2)]\n      [(< num2 num) (parse-integer num2)]\n      [(< num num2) (parse-integer\
    \ num2)]\n      [(< num2 num) (parse-integer num2)]\n      [(< num num2) (parse-integer\
    \ num2)]\n      [(< num2 num) (parse-integer num2)]\n      [(< num num2) (parse-integer\
    \ num2)]\n      [(< num2 num) (parse-integer num2)]\n      [(< num num2) (parse-integer\
    \ num2)]\n      [(< num2 num) (parse-integer num2)]\n      [(< num num2) (parse-integer\
    \ num2)]\n      [(< num2 num) (parse-integer num2)]\n      [(< num num2) (parse-integer\
    \ num2)]\n      [(< num2 num) (parse-integer num2)]\n      [(< num num2) (parse-integer\
    \ num2)]\n      [(< num2 num) (parse-integer num2)]\n      [(< num num2) (parse-integer\
    \ num2)]\n      [(< num2 num) (parse-integer num2)]\n      [(< num num2) (parse-integer\
    \ num2)]\n      [(< num2 num) (parse-integer num2)]\n      [(< num num2) (parse-integer\
    \ num2)]\n      [(< num2 num) (parse-", "  (let ([x (parse-integer (string->symbol\
    \ (symbol->string value)))])\n    (cond\n      [(< x 0) (error \"The given value\
    \ is not a number\")]\n      [(< x 1) x]\n      [(< x 10) (* 10 x)]\n      [(<\
    \ x 100) (* 100 x)]\n      [(< x 1000) (* 1000 x)]\n      [(< x 10000) (* 10000\
    \ x)]\n      [(< x 100000) (* 100000 x)]\n      [(< x 1000000) (* 1000000 x)]\n\
    \      [(< x 10000000) (* 10000000 x)]\n      [(< x 100000000) (* 100000000 x)]\n\
    \      [(< x 1000000000) (* 1000000000 x)]\n      [(< x 10000000000) (* 10000000000\
    \ x)]\n      [(< x 100000000000) (* 100000000000 x)]\n      [(< x 1000000000000)\
    \ (* 1000000000000 x)]\n      [(< x 10000000000000) (* 10000000000000 x)]\n  \
    \    [(< x 100000000000000) (* 100000000000000 x)]\n      [(< x 1000000000000000)\
    \ (* 1000000000000000 x)]\n      [(< x 10000000000000000) (* 10000000000000000\
    \ x)]\n      [(< x 100000000000000000) (* 100000000000000000 x)]\n      [(< x\
    \ 1000000000000000000) (* 1000000000000000000 x)]\n      [else (* 1000000000000000000\
    \ x)]))\n  ", "  (define (closest-integer-helper value low-bound high-bound)\n\
    \    (cond ((< value low-bound)\n           (if (< value high-bound)\n       \
    \        (closest-integer-helper value low-bound (- high-bound 1))\n         \
    \      (- high-bound 1)))\n          ((< value high-bound)\n           (if (<\
    \ value low-bound)\n               (closest-integer-helper value (- low-bound\
    \ 1) high-bound)\n               (- low-bound 1)))\n          (else\n        \
    \   (- high-bound 1)))\n    (closest-integer-helper value 0 1))\n  (closest-integer-helper\
    \ value 0 1))\n", "  (let ([x (parse-integer (string->symbol (symbol->string value)))])\n\
    \    (cond [(< x 0) (- 0 (floor (/ x 1)))]\n          [(< x 0) x]\n          [else\
    \ x])))\n", "  (let ([numbers (number->list value)])\n    (if (null? numbers)\n\
    \        0\n        (let ([closest (car numbers)])\n          (if (< (abs (- closest\
    \ value)) (abs (- value closest)))\n              (- closest)\n              closest)))))\n",
  "  (let ([int-value (string->number value)]\n        [int-min (string->number '-inf)]\n\
    \        [int-max (string->number '+inf)])\n    (cond\n      [(< int-value int-min)\n\
    \       (string->number '-inf)]\n      [(< int-value int-max)\n       (string->number\
    \ '+inf)]\n      [else\n       (+ int-value int-min)]))))\n", "  (let ([x (string->number\
    \ (car value))])\n    (let ([y (string->number (cadr value))])\n      (cond\n\
    \        ((= x y) value)\n        ((< (abs (- x y)) (abs x)) (ceiling value))\n\
    \        (else (floor value)))))\n</code>\n<|/ a |>\n<| c |>\nI appreciate your\
    \ answer, but this doesn't really answer the question. Your code doesn't use any\
    \ functions from Racket, which is what I was looking for. Thanks though!\n<|/\
    \ c |>\n<| c |>\nI added a solution that uses only basic Racket functions. I hope\
    \ it helps.\n<|/ c |>\n<| a tags=racket,scheme |>\nHere's a solution using only\
    \ basic Racket functions:\n<code>", "  (let ([int-val (parse-integer value)])\n\
    \    (cond [(< int-val 0)\n           (error \"Closest integer cannot be negative.\"\
    )]\n          [(< int-val (/ 1 int-val))\n           (error \"Closest integer\
    \ cannot be equidistant from zero.\")]\n          [else\n           (floor (/\
    \ int-val 1))])))\n", "  (let ((integer (floor (/ value 10))))\n    (if (= (abs\
    \ (- value integer)) .5)\n        (ceiling integer)\n        integer)))\n", " \
    \ (let ([x (number->string value)]\n        [y (number->string value)])\n    (cond\n\
    \      [(equal? x y) value]\n      [(equal? (string->number x) (string->number\
    \ y)) (round value)]\n      [else (round (+ (string->number x) (/ (string->number\
    \ y) 10)))])))\n", "  (let ([x (parse-integer (string->symbol (string->symbol\
    \ value)))])\n    (cond [(< x 0) (- 0 (floor (- x)))]\n          [(< x 1) (- 0\
    \ (floor (- x)))]\n          [(< x 2) (- 0 (floor (- x)))]\n          [(< x 3)\
    \ (- 0 (floor (- x)))]\n          [(< x 4) (- 0 (floor (- x)))]\n          [(<\
    \ x 5) (- 0 (floor (- x)))]\n          [(< x 6) (- 0 (floor (- x)))]\n       \
    \   [(< x 7) (- 0 (floor (- x)))]\n          [(< x 8) (- 0 (floor (- x)))]\n \
    \         [(< x 9) (- 0 (floor (- x)))]\n          [(< x 10) (- 0 (floor (- x)))]\n\
    \          [(< x 11) (- 0 (floor (- x)))]\n          [(< x 12) (- 0 (floor (-\
    \ x)))]\n          [(< x 13) (- 0 (floor (- x)))]\n          [(< x 14) (- 0 (floor\
    \ (- x)))]\n          [(< x 15) (- 0 (floor (- x)))]\n          [(< x 16) (- 0\
    \ (floor (- x)))]\n          [(< x 17) (- 0 (floor (- x)))]\n          [(< x 18)\
    \ (- 0 (floor (- x)))]\n          [(< x 19) (- 0 (floor (- x)))]\n          [(<\
    \ x 20) (- 0 (floor (- x)))]\n          [(< x 21) (- 0 (floor (- x)))]\n     \
    \     [(< x 22) (- 0 (floor (- x)))]\n          [(< x 23) (- 0 (floor (- x)))]\n\
    \          [(< x 24) (- 0 (floor (- x)))]\n          [(< x 25) (- 0 (floor (-\
    \ x)))]\n          [(< x 26) (- 0 (floor (- x)))]\n          [(< x 27) (- 0 (floor\
    \ (- x)))]\n          [(< x 28) (- 0 (floor (- x)))]\n          [(< x 29) (- 0\
    \ (floor (- x)))]\n          [(< x 30) (- 0 (floor (- x)))]\n          [(< x 31)\
    \ (- 0 (floor (- x)))]\n          [(< x 32) (- 0 (floor", "  (let ([num (string->number\
    \ (string->symbol value))])\n    (cond [(< num 0) (ceiling num)]\n          [(>\
    \ num 0) (floor num)]\n          [else num])))\n", "  (let ([num (number->string\
    \ value)]\n        [nums (number->list value)]\n        [min (min nums)]\n   \
    \     [max (max nums)])\n    (cond\n      [(empty? nums) value]\n      [(< (length\
    \ nums) 1) value]\n      [(< (length nums) 2) (cons (min nums) (closest_integer\
    \ (first nums)))]\n      [(< (length nums) 3) (cons (min nums) (closest_integer\
    \ (first nums)))]\n      [(< (length nums) 4) (cons (min nums) (closest_integer\
    \ (first nums)))]\n      [(< (length nums) 5) (cons (min nums) (closest_integer\
    \ (first nums)))]\n      [(< (length nums) 6) (cons (min nums) (closest_integer\
    \ (first nums)))]\n      [(< (length nums) 7) (cons (min nums) (closest_integer\
    \ (first nums)))]\n      [(< (length nums) 8) (cons (min nums) (closest_integer\
    \ (first nums)))]\n      [(< (length nums) 9) (cons (min nums) (closest_integer\
    \ (first nums)))]\n      [(< (length nums) 10) (cons (min nums) (closest_integer\
    \ (first nums)))]\n      [(< (length nums) 11) (cons (min nums) (closest_integer\
    \ (first nums)))]\n      [(< (length nums) 12) (cons (min nums) (closest_integer\
    \ (first nums)))]\n      [(< (length nums) 13) (cons (min nums) (closest_integer\
    \ (first nums)))]\n      [(< (length nums) 14) (cons (min nums) (closest_integer\
    \ (first nums)))]\n      [(< (length nums) 15) (cons (min nums) (closest_integer\
    \ (first nums)))]\n      [(< (length nums) 16) (cons (min nums) (closest_integer\
    \ (first nums)))]\n      [(< (length nums) 17) (cons (min nums) (closest_integer\
    \ (first nums)))]\n      [(< (length nums) 18) (cons (min nums) (closest_integer\
    \ (first nums)))]\n      [(< (length nums) 19) (cons (min nums) (closest_integer\
    \ (first nums)))]\n      [(< (length nums) 20) (cons (min nums) (closest_integer\
    \ (first nums)))]\n      [(< (length nums) 21) (cons (min nums) (closest_integer\
    \ (first nums)))]\n      [(< (length nums) 22) (cons (min nums) (closest_integer\
    \ (", "  (let ([x (number->string value)]\n        [y (number->string value)])\n\
    \    (cond\n      [(equal? x y) value]\n      [(equal? x \"-\") (- 0 (number->integer\
    \ value))]\n      [(equal? y \"-\") (- 0 (number->integer value))]\n      [(equal?\
    \ x \"0\") (- 0 (number->integer value))]\n      [(equal? y \"0\") (- 0 (number->integer\
    \ value))]\n      [(equal? x \"1\") (- 0 (number->integer value))]\n      [(equal?\
    \ y \"1\") (- 0 (number->integer value))]\n      [(equal? x \"2\") (- 0 (number->integer\
    \ value))]\n      [(equal? y \"2\") (- 0 (number->integer value))]\n      [(equal?\
    \ x \"3\") (- 0 (number->integer value))]\n      [(equal? y \"3\") (- 0 (number->integer\
    \ value))]\n      [(equal? x \"4\") (- 0 (number->integer value))]\n      [(equal?\
    \ y \"4\") (- 0 (number->integer value))]\n      [(equal? x \"5\") (- 0 (number->integer\
    \ value))]\n      [(equal? y \"5\") (- 0 (number->integer value))]\n      [(equal?\
    \ x \"6\") (- 0 (number->integer value))]\n      [(equal? y \"6\") (- 0 (number->integer\
    \ value))]\n      [(equal? x \"7\") (- 0 (number->integer value))]\n      [(equal?\
    \ y \"7\") (- 0 (number->integer value))]\n      [(equal? x \"8\") (- 0 (number->integer\
    \ value))]\n      [(equal? y \"8\") (- 0 (number->integer value))]\n      [(equal?\
    \ x \"9\") (- 0 (number->integer value))]\n      [(equal? y \"9\") (- 0 (number->integer\
    \ value))]\n      [(equal? x \".\") (- 0 (number->integer value))]\n      [(equal?\
    \ y \".\") (- 0 (number->integer value))]\n      [(equal? x \"-\") (- 0 (number->integer\
    \ value))]\n      [(equal? y \"-\") (- 0 (number->integer value))]\n      [(equal?\
    \ x \"0\") (- 0 (number->integer value))]\n      [(equal? y \"0\") (- 0 (number->integer\
    \ value))]\n      [(equal? x \"1\") ", "  (let ([num (string->number (car value))])\n\
    \    (cond\n      [(< num 0) (error \"Not a number\")]\n      [(< num 1) (error\
    \ \"Not a number\")]\n      [(< num 2) (error \"Not a number\")]\n      [(< num\
    \ 3) (error \"Not a number\")]\n      [(< num 4) (error \"Not a number\")]\n \
    \     [(< num 5) (error \"Not a number\")]\n      [(< num 6) (error \"Not a number\"\
    )]\n      [(< num 7) (error \"Not a number\")]\n      [(< num 8) (error \"Not\
    \ a number\")]\n      [(< num 9) (error \"Not a number\")]\n      [(< num 10)\
    \ (error \"Not a number\")]\n      [(< num 11) (error \"Not a number\")]\n   \
    \   [(< num 12) (error \"Not a number\")]\n      [(< num 13) (error \"Not a number\"\
    )]\n      [(< num 14) (error \"Not a number\")]\n      [(< num 15) (error \"Not\
    \ a number\")]\n      [(< num 16) (error \"Not a number\")]\n      [(< num 17)\
    \ (error \"Not a number\")]\n      [(< num 18) (error \"Not a number\")]\n   \
    \   [(< num 19) (error \"Not a number\")]\n      [(< num 20) (error \"Not a number\"\
    )]\n      [(< num 21) (error \"Not a number\")]\n      [(< num 22) (error \"Not\
    \ a number\")]\n      [(< num 23) (error \"Not a number\")]\n      [(< num 24)\
    \ (error \"Not a number\")]\n      [(< num 25) (error \"Not a number\")]\n   \
    \   [(< num 26) (error \"Not a number\")]\n      [(< num 27) (error \"Not a number\"\
    )]\n      [(< num 28) (error \"Not a number\")]\n      [(< num 29) (error \"Not\
    \ a number\")]\n      [(< num 30) (error \"Not a number\")]\n      [(< num 31)\
    \ (error \"Not a number\")]\n      [(< num 32) (error \"Not a number\")]\n   \
    \   [(< num 33) (error \"Not a number\")]\n      [(< num 34) (error \"Not a number\"\
    )]\n      [(< num 35) (error \"Not a number\")]\n      [(< num 36) (error \"Not\
    \ a number\")]\n      [(< num 37) (error \"Not a number\")]\n      ", "  (let\
    \ ([int-value (string->number value)]\n        [int-min (string->number '-Infinity)]\n\
    \        [int-max (string->number '+Infinity)])\n    (cond\n      [(< int-value\
    \ int-min) (+ int-min int-value)]\n      [(< int-value int-max) (+ int-max int-value)]\n\
    \      [else int-value])))\n", "  (let ([x (number->string value)]\n        [y\
    \ (number->string value)])\n    (cond\n      [(equal? x y) value]\n      [(equal?\
    \ x \"-\") (- 0 (number->integer value))]\n      [(equal? y \"-\") (- 0 (number->integer\
    \ value))]\n      [else (- 0 (number->integer value))])))\n", "  (let ([x (string->number\
    \ (car value))])\n    (let ([y (string->number (cadr value))])\n      (cond\n\
    \        ((< (abs (- x y)) (abs x))\n         (+ x 1))\n        ((< (abs (- x\
    \ y)) (abs y))\n         (+ y 1))\n        (else (+ x y))))))\n", "  (let ((diff\
    \ (- value 1)))\n    (if (< diff 0)\n        (- value)\n        diff)))\n", " \
    \ (let ([num (parse-integer value)]\n        [nums (list num)]\n        [min (min\
    \ nums)]\n        [max (max nums)])\n    (cond\n      [(= num min) (min num)]\n\
    \      [(= num max) (max num)]\n      [(< (abs (- num min)) (abs (- num max)))\n\
    \       (let ([closest (+ num 1)])\n         (cond\n           [(< num closest)\
    \ (+ num 1)]\n           [(> num closest) (- num 1)]\n           [(= num closest)\
    \ (+ num 1)]))]\n      [else (let ([closest (- num 1)])\n              (cond\n\
    \                [(< num closest) (- num 1)]\n                [(> num closest)\
    \ (+ num 1)]))]))))\n", "  (let ([x (parse-integer (string->list value) '())])\n\
    \    (cond [(< x 0) (parse-integer (string->list \"0\" '()))]\n          [(< x\
    \ 1) (parse-integer (string->list \"1\" '()))]\n          [(< x 2) (parse-integer\
    \ (string->list \"2\" '()))]\n          [(< x 3) (parse-integer (string->list\
    \ \"3\" '()))]\n          [(< x 4) (parse-integer (string->list \"4\" '()))]\n\
    \          [(< x 5) (parse-integer (string->list \"5\" '()))]\n          [(< x\
    \ 6) (parse-integer (string->list \"6\" '()))]\n          [(< x 7) (parse-integer\
    \ (string->list \"7\" '()))]\n          [(< x 8) (parse-integer (string->list\
    \ \"8\" '()))]\n          [(< x 9) (parse-integer (string->list \"9\" '()))]\n\
    \          [(< x 10) (parse-integer (string->list \"10\" '()))]\n          [(<\
    \ x 11) (parse-integer (string->list \"11\" '()))]\n          [(< x 12) (parse-integer\
    \ (string->list \"12\" '()))]\n          [(< x 13) (parse-integer (string->list\
    \ \"13\" '()))]\n          [(< x 14) (parse-integer (string->list \"14\" '()))]\n\
    \          [(< x 15) (parse-integer (string->list \"15\" '()))]\n          [(<\
    \ x 16) (parse-integer (string->list \"16\" '()))]\n          [(< x 17) (parse-integer\
    \ (string->list \"17\" '()))]\n          [(< x 18) (parse-integer (string->list\
    \ \"18\" '()))]\n          [(< x 19) (parse-integer (string->list \"19\" '()))]\n\
    \          [(< x 20) (parse-integer (string->list \"20\" '()))]\n          [(<\
    \ x 21) (parse-integer (string->list \"21\" '()))]\n          [(< x 22) (parse-integer\
    \ (string->list \"22\" '()))]\n          [(< x 23) (parse-integer (string->list\
    \ \"23\" '()))]\n          [(< x 24) (parse-integer (string->list \"", "  (let\
    \ ([x (string->number (car value))])\n    (let ([y (string->number (cadr value))])\n\
    \      (if (and (number? x) (number? y))\n          (if (= x y)\n            \
    \  x\n              (if (< x y)\n                  (ceiling x)\n             \
    \     (floor x)))))\n      (if (and (number? x) (number? y))\n          (if (<\
    \ x y)\n              (ceiling x)\n              (floor x))))))\n", "  (let ([integers\
    \ (map number->integer (split-string (number->string value) \".\"))])\n    (let\
    \ ([closest (first integers)])\n      (if (null? integers)\n          closest\n\
    \          (let ([diff (- closest (first integers))])\n            (if (< diff\
    \ (first integers))\n                (first integers)\n                (first\
    \ integers)\n              )\n            )\n          )\n      )\n    )\n  )\n",
  "  (let ((x (floor (/ value 10))))\n    (cond\n      [(< x 9) (+ x 10)]\n      [(<\
    \ x 8) (+ x 10)]\n      [(< x 7) (+ x 10)]\n      [(< x 6) (+ x 10)]\n      [(<\
    \ x 5) (+ x 10)]\n      [(< x 4) (+ x 10)]\n      [(< x 3) (+ x 10)]\n      [(<\
    \ x 2) (+ x 10)]\n      [(< x 1) (+ x 10)]\n      [else x])))\n", "  (let ([number-as-string\
    \ (number->string value)]\n        [integers (string->list number-as-string)])\n\
    \    (let ([closest-integer (first integers)])\n      (if (< (length integers)\
    \ 2)\n          (if (< (length (rest integers)) 2)\n              (if (< (length\
    \ (rest integers)) 1)\n                  (if (< (length (rest integers)) 0)\n\
    \                      (if (< (length (rest integers)) -1)\n                 \
    \         (if (< (length (rest integers)) -2)\n                              (if\
    \ (< (length (rest integers)) -3)\n                                  (if (< (length\
    \ (rest integers)) -4)\n                                      (if (< (length (rest\
    \ integers)) -5)\n                                          (if (< (length (rest\
    \ integers)) -6)\n                                              (if (< (length\
    \ (rest integers)) -7)\n                                                  (if\
    \ (< (length (rest integers)) -8)\n                                          \
    \            (if (< (length (rest integers)) -9)\n                           \
    \                               (if (< (length (rest integers)) -10)\n       \
    \                                                       (if (< (length (rest integers))\
    \ -11)\n                                                                  (if\
    \ (< (length (rest integers)) -12)\n                                         \
    \                             (if (< (length (rest integers)) -13)\n         \
    \                                                                 (if (< (length\
    \ (rest integers)) -14)\n                                                    \
    \                          (if (< (length (rest integers)) -15)\n            \
    \                                                                      (if (<\
    \ (length (rest integers)) -16)\n                                            \
    \                                          (if (< (length (rest integers)) -17)\n\
    \                                                                            \
    \              (if (< (length (rest integers)) -18)\n                        \
    \                                                                      (if (<\
    \ (length (rest integers)) -19)\n                                            \
    \                                                      (if (< (length (rest integers))\
    \ -20)\n                                                                     \
    \                                 (if (< (length (rest integers)) -21)\n     \
    \                                                                            \
    \                         (if (< (length (rest integers)) -22)\n             \
    \                                                                            \
    \                     (if (< (length (rest integers)) -23)\n                 \
    \                                                                            \
    \                     (if (< (length (rest integers)) -24)\n                 \
    \                                                                            \
    \                         (if (< (length (rest integers)) -25)\n             \
    \                                                                            \
    \                                 (if (< (length (rest integers)) -26)\n     \
    \                                                                            \
    \                                             (if (< (length (rest integers))\
    \ -27)\n                                                                     \
    \                                                             (if (< (length (rest\
    \ integers)) -28)\n                                                          \
    \                                                                            (if\
    \ (< (length (rest integers)) -29)\n                                         \
    \                                                                            \
    \                     (if (< (length (rest integers)) -30)\n                 \
    \                                                                            \
    \                                                 (if (< (length (rest integers))\
    \ -31)\n                                                                     \
    \                                                                            \
    \ (if (", "  (let ([number-string (string->number value)])\n    (cond\n      [(number-string\
    \ < 0)\n       (error \"The given number cannot be negative.\")]\n      [(number-string\
    \ > 0)\n       (floor (number-string))]\n      [else\n       (ceiling (number-string))]))\n\
    \  )\n", "  (let ([integer (parse-integer value)]\n        [integers (list integer)]\n\
    \        [closest (car integers)])\n    (cond\n      [(< value (car integers))\
    \ (closest_integer value)]\n      [(> value (car integers)) (closest_integer value)]\n\
    \      [else (cons (car integers) (closest_integer value))]))))\n", "  (let ([x\
    \ (string->number (car value))])\n    (cond\n      [(< x 0) (error \"Not a number\"\
    )]\n      [(< x 1) (error \"Not a number\")]\n      [else (ceiling (/ x 1))])))\n",
  "  (let ([x (string->number (car value))])\n    (let ([y (string->number (cadr value))])\n\
    \      (if (= x y)\n          x\n          (if (< x y)\n              (ceiling\
    \ x)\n              (floor x)))))\n", "  (let ([int-value (string->number (car\
    \ value))])\n    (let ([int-value (string->number (car value))])\n      (let ([int-value\
    \ (string->number (car value))]\n            [int-value (string->number (car value))]\n\
    \            [int-value (string->number (car value))]\n            [int-value\
    \ (string->number (car value))]\n            [int-value (string->number (car value))]\n\
    \            [int-value (string->number (car value))]\n            [int-value\
    \ (string->number (car value))]\n            [int-value (string->number (car value))]\n\
    \            [int-value (string->number (car value))]\n            [int-value\
    \ (string->number (car value))]\n            [int-value (string->number (car value))]\n\
    \            [int-value (string->number (car value))]\n            [int-value\
    \ (string->number (car value))]\n            [int-value (string->number (car value))]\n\
    \            [int-value (string->number (car value))]\n            [int-value\
    \ (string->number (car value))]\n            [int-value (string->number (car value))]\n\
    \            [int-value (string->number (car value))]\n            [int-value\
    \ (string->number (car value))]\n            [int-value (string->number (car value))]\n\
    \            [int-value (string->number (car value))]\n            [int-value\
    \ (string->number (car value))]\n            [int-value (string->number (car value))]\n\
    \            [int-value (string->number (car value))]\n            [int-value\
    \ (string->number (car value))]\n            [int-value (string->number (car value))]\n\
    \            [int-value (string->number (car value))]\n            [int-value\
    \ (string->number (car value))]\n            [int-value (string->number (car value))]\n\
    \            [int-value (string->number (car value))]\n            [int-value\
    \ (string->number (car value))]\n            [int-value (string->number (car value))]\n\
    \            [int-value (string->number (car value))]\n            [int-value\
    \ (string->number (car value))]\n            [int-value (string->number (car value))]\n\
    \            [int-value (string->number (car value))]\n            [int-value\
    \ (string->number (car value))]\n            [int-value (string->number (car value))]\n\
    \            [int-value (string->number (car value))]\n            [int-value\
    \ (string->number (car value))]\n            [int", "  (define (closest-integer-helper\
    \ value low-bound high-bound)\n    (cond ((< value low-bound)\n           (if\
    \ (< value high-bound)\n               (+ low-bound 1)\n               (+ high-bound\
    \ 1)))\n          ((< value high-bound)\n           (if (< value low-bound)\n\
    \               (+ high-bound 1)\n               (+ low-bound 1)))\n         \
    \ ((< value low-bound)\n           (if (< value high-bound)\n               (+\
    \ low-bound 1)\n               (+ high-bound 1)))\n          ((< value high-bound)\n\
    \           (if (< value low-bound)\n               (+ low-bound 1)\n        \
    \       (+ high-bound 1)))\n          (else\n           (+ low-bound 1)))\n  \
    \  (closest-integer-helper value low-bound high-bound))\n  (closest-integer-helper\
    \ value 0 1))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
