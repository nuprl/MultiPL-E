name: HumanEval_99_closest_integer
language: rkt
prompt: "#lang racket\n\n;; Create a function that takes a value (string) representing\
  \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
  ;; from two integers, round it away from zero.\n;; Examples\n;; Note:\n;; Rounding\
  \ away from zero means that if the given number is equidistant\n;; from two integers,\
  \ the one you should return is the one that is the\n;; farthest from zero. For example\
  \ closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"-14.5\")\
  \ should return -15.\n(define (closest_integer value)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n\
  \    (check-equal? (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\"\
  ) 15)\n    (check-equal? (candidate \"-15.5\") -16)\n    (check-equal? (candidate\
  \ \"15.3\") 15)\n    (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
completions: ["  (let ([x (string->number (car value))\n        y (+ (string->number\
    \ (cadr value)) (* -1 x))])\n    (cond\n      [(< x y) value]\n      [else (round\
    \ (/ y x))]))\n  ", "  (let ([num (string->number (string->symbol value))])\n\
    \    (cond\n      [(< num 0) (error \"The given value is not a number\")]\n  \
    \    [(< num 1) (error \"The given value is not a number\")]\n      [(< num 2)\
    \ (error \"The given value is not a number\")]\n      [(< num 3) (error \"The\
    \ given value is not a number\")]\n      [(< num 4) (error \"The given value is\
    \ not a number\")]\n      [(< num 5) (error \"The given value is not a number\"\
    )]\n      [(< num 6) (error \"The given value is not a number\")]\n      [(< num\
    \ 7) (error \"The given value is not a number\")]\n      [(< num 8) (error \"\
    The given value is not a number\")]\n      [(< num 9) (error \"The given value\
    \ is not a number\")]\n      [(< num 10) (error \"The given value is not a number\"\
    )]\n      [(< num 11) (error \"The given value is not a number\")]\n      [(<\
    \ num 12) (error \"The given value is not a number\")]\n      [(< num 13) (error\
    \ \"The given value is not a number\")]\n      [(< num 14) (error \"The given\
    \ value is not a number\")]\n      [(< num 15) (error \"The given value is not\
    \ a number\")]\n      [(< num 16) (error \"The given value is not a number\")]\n\
    \      [(< num 17) (error \"The given value is not a number\")]\n      [(< num\
    \ 18) (error \"The given value is not a number\")]\n      [(< num 19) (error \"\
    The given value is not a number\")]\n      [(< num 20) (error \"The given value\
    \ is not a number\")]\n      [(< num 21) (error \"The given value is not a number\"\
    )]\n      [(< num 22) (error \"The given value is not a number\")]\n      [(<\
    \ num 23) (error \"The given value is not a number\")]\n      [(< num 24) (error\
    \ \"The given value is not a number\")]\n      [(< num 25) (error \"The given\
    \ value is not a number\")]\n      [(< num 26) (error \"The given value is not\
    \ a number\")]\n      [(< num 27) (error \"The given value is not a number\")]\n\
    \      [(< num 28) (error \"The given value is not a number\")]\n      [(< num\
    \ 29) (error \"The given value is not a number\")]\n      [(< num 30) (error \"\
    The given value is not a number\")]\n      [(< num 31) (error \"The given value\
    \ is not a number\")]\n      [(< num 32) (error \"The given value is not a number\"\
    )]", "  (let ([int-value (string->number (string->symbol value))])\n    (cond\n\
    \      [(< int-value 0) (ceiling int-value)]\n      [(> int-value 0) (floor int-value)]\n\
    \      [else int-value])))\n", "  (let ([num (string->number value)]\n       \
    \ [nums (number->list num)])\n    (if (< (length nums) 2)\n        (let ([closest\
    \ (expt (first nums) (/ (first nums) (second nums)))])\n          (if (= closest\
    \ 0)\n              (expt (second nums) (/ (second nums) (first nums)))\n    \
    \          (expt closest 2))))\n    (expt (first nums) (/ (first nums) (second\
    \ nums)))))\n", "  (let ([x (parse-integer value)]\n        [y (parse-integer\
    \ value)])\n    (cond [(< x y)\n           (ceiling x)]\n          [(< y x)\n\
    \           (ceiling y)]\n          [else\n           (floor x)])))\n", "  (let\
    \ ((x (floor (/ value 10))))\n    (cond\n      [(< x 9) (+ x 10)]\n      [(< x\
    \ 8) (+ x 10)]\n      [(< x 7) (+ x 10)]\n      [(< x 6) (+ x 10)]\n      [(<\
    \ x 5) (+ x 10)]\n      [(< x 4) (+ x 10)]\n      [(< x 3) (+ x 10)]\n      [(<\
    \ x 2) (+ x 10)]\n      [(< x 1) (+ x 10)]\n      [else x])))\n", "  (let ([x\
    \ (number->string value)]\n        [y (number->string value)])\n    (cond\n  \
    \    [(equal? x y) value]\n      [(number->boolean? value) (round value)]\n  \
    \    [else (round (number->float (string->number x)))])))\n", "  (let ([numbers\
    \ (number->list value)])\n    (let ([closest (first numbers)])\n      (if (null?\
    \ numbers)\n          closest\n          (let ([next (second numbers)])\n    \
    \        (if (> (abs (- next closest)) (abs (- closest next)))\n             \
    \   (closest_integer value)\n                (closest_integer next)))))\n    closest))\n",
  "  (let ([x (string->number (car value))])\n    (let ([y (string->number (cadr value))])\n\
    \      (if (and (number? x) (number? y))\n          (if (< (abs (- x y)) (/ x\
    \ y))\n              (- x y)\n              (- y x))\n          (if (< (abs (-\
    \ x y)) (/ x y))\n              (- x y)\n              (- y x))\n          (if\
    \ (< (abs (- x y)) (/ x y))\n              (- x y)\n              (- y x))\n \
    \         (if (< (abs (- x y)) (/ x y))\n              (- x y)\n             \
    \ (- y x))\n          (if (< (abs (- x y)) (/ x y))\n              (- x y)\n \
    \             (- y x))\n          (if (< (abs (- x y)) (/ x y))\n            \
    \  (- x y)\n              (- y x))\n          (if (< (abs (- x y)) (/ x y))\n\
    \              (- x y)\n              (- y x))\n          (if (< (abs (- x y))\
    \ (/ x y))\n              (- x y)\n              (- y x))\n          (if (< (abs\
    \ (- x y)) (/ x y))\n              (- x y)\n              (- y x))\n         \
    \ (if (< (abs (- x y)) (/ x y))\n              (- x y)\n              (- y x))\n\
    \          (if (< (abs (- x y)) (/ x y))\n              (- x y)\n            \
    \  (- y x))\n          (if (< (abs (- x y)) (/ x y))\n              (- x y)\n\
    \              (- y x))\n          (if (< (abs (- x y)) (/ x y))\n           \
    \   (- x y)\n              (- y x))\n          (if (< (abs (- x y)) (/ x y))\n\
    \              (- x y)\n              (- y x))\n          (if (< (abs (- x y))\
    \ (/ x y))\n              (- x y)\n              (- y x))\n          (if (< (abs\
    \ (- x y)) (/ x y))\n              (- x y)\n              (- y x))\n         \
    \ (if (< (abs (- x y)) (/ x y))\n              (- x y)\n              (- y x))\n\
    \          (if (< (abs (- x y)) (/ x y))\n              (", "  (let ([int-value\
    \ (string->number (string->symbol value))])\n    (cond\n      [(< int-value 0)\
    \ (error \"Given value is not a number\")]\n      [(< int-value 1) (error \"Given\
    \ value is not a number\")]\n      [else (round (abs (- int-value 1)))])))\n",
  "  (let ([integer (parse-integer value)]\n        [integers (list integer)]\n  \
    \      [closest (first integers)])\n    (if (null? integers)\n        integer\n\
    \        (let ([next (second integers)])\n          (if (> (abs (- value next))\
    \ (abs (- value integer)))\n              (cons integer integers)\n          \
    \    (cons next integers))))))\n", "  (let ([x (string->number (car value))])\n\
    \    (let ([y (string->number (cadr value))])\n      (if (= x y)\n          x\n\
    \          (if (< (abs (- x y)) (abs x))\n              (ceiling x)\n        \
    \      (floor x))))))\n", "  (let ([num (string->number (car value))])\n    (cond\n\
    \      [(< num 0) (error \"Closest integer not possible for negative numbers\"\
    )]\n      [(< num 1) (error \"Closest integer not possible for numbers that are\
    \ equidistant from two integers\")]\n      [else (round (/ (- num 1) num))]))))\n",
  "  (let ((closest-integer (min (abs (- value 1))\n                             \
    \  (abs (- value 2)))))\n    (if (= closest-integer 0)\n        (- value)\n  \
    \      closest-integer)))\n", "  (let ((x (string->number (car value))))\n   \
    \ (let ((y (string->number (cadr value))))\n      (cond\n        ((= x y) value)\n\
    \        ((< (abs (- x y)) (abs x))\n         (ceiling value))\n        ((> (abs\
    \ (- x y)) (abs x))\n         (floor value))\n        (else (error \"Closest integer\
    \ not possible\"))))))\n", "  (let ([x (string->number (car value))])\n    (let\
    \ ([y (string->number (cadr value))])\n      (if (< (abs (- x y)) (abs x))\n \
    \         (ceiling x)\n          (floor (- x)))\n      (closest_integer (list\
    \ x y)))))\n", "  (let ([num (string->number (car value))])\n    (cond\n     \
    \ [(< num 0) (- 0 (floor (- num)))]\n      [(< num 1) (- 0 (floor (- num)))]\n\
    \      [(< num 2) (- 0 (floor (- num)))]\n      [(< num 3) (- 0 (floor (- num)))]\n\
    \      [(< num 4) (- 0 (floor (- num)))]\n      [(< num 5) (- 0 (floor (- num)))]\n\
    \      [(< num 6) (- 0 (floor (- num)))]\n      [(< num 7) (- 0 (floor (- num)))]\n\
    \      [(< num 8) (- 0 (floor (- num)))]\n      [(< num 9) (- 0 (floor (- num)))]\n\
    \      [(< num 10) (- 0 (floor (- num)))]\n      [(< num 11) (- 0 (floor (- num)))]\n\
    \      [(< num 12) (- 0 (floor (- num)))]\n      [(< num 13) (- 0 (floor (- num)))]\n\
    \      [(< num 14) (- 0 (floor (- num)))]\n      [(< num 15) (- 0 (floor (- num)))]\n\
    \      [(< num 16) (- 0 (floor (- num)))]\n      [(< num 17) (- 0 (floor (- num)))]\n\
    \      [(< num 18) (- 0 (floor (- num)))]\n      [(< num 19) (- 0 (floor (- num)))]\n\
    \      [(< num 20) (- 0 (floor (- num)))]\n      [(< num 21) (- 0 (floor (- num)))]\n\
    \      [(< num 22) (- 0 (floor (- num)))]\n      [(< num 23) (- 0 (floor (- num)))]\n\
    \      [(< num 24) (- 0 (floor (- num)))]\n      [(< num 25) (- 0 (floor (- num)))]\n\
    \      [(< num 26) (- 0 (floor (- num)))]\n      [(< num 27) (- 0 (floor (- num)))]\n\
    \      [(< num 28) (- 0 (floor (- num)))]\n      [(< num 29) (- 0 (floor (- num)))]\n\
    \      [(< num 30) (- 0 (floor (- num)))]\n      [(< num 31) (- 0 (floor (- num)))]\n\
    \      [(< num 32) (- 0 (floor (- num)))]\n", "  (let ([x (number->string value)]\n\
    \        [y (number->string value)])\n    (cond\n      [(equal? x y) value]\n\
    \      [(equal? x \"-\") (- 0 (string->number y))] \n      [(equal? y \"-\") (-\
    \ 0 (string->number x))]\n      [(equal? x \"0\") (- 0 (string->number y))] \n\
    \      [(equal? y \"0\") (- 0 (string->number x))]\n      [else (- 0 (string->number\
    \ x))])))\n", "  (let ([integers (map number->integer '(1 2 3 4 5 6 7 8 9 10 11\
    \ 12 13 14 15))])\n    (let ([closest (first integers)])\n      (if (< (abs (-\
    \ value closest)) (abs (- value integers)))\n          closest\n          (closest_integer\
    \ value))))))\n", "  (let ((closest (min (floor (/ value 10)) (floor (/ value\
    \ 10))))\n        (closest-to (floor (/ value 10)))\n        (closest-to (floor\
    \ (/ value 10))))\n    (cond\n      [(< value closest)\n       (min (floor (/\
    \ value 10)) (floor (/ value 10)))]\n      [(< closest closest-to)\n       (min\
    \ (floor (/ value 10)) (floor (/ value 10)))]\n      [(< closest-to closest)\n\
    \       (min (floor (/ value 10)) (floor (/ value 10)))]\n      [else\n      \
    \ closest])))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
