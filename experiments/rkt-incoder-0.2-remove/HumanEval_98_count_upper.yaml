name: HumanEval_98_count_upper
language: rkt
prompt: "#lang racket\n\n;; Given a string s, count the number of uppercase vowels\
  \ in even indices.\n;; For example:\n(define (count_upper s)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate count_upper))\n\
  \    (check-equal? (candidate \"aBCdEf\") 1)\n    (check-equal? (candidate \"abcdefg\"\
  ) 0)\n    (check-equal? (candidate \"dBBE\") 0)\n    (check-equal? (candidate \"\
  B\") 0)\n    (check-equal? (candidate \"U\") 1)\n    (check-equal? (candidate \"\
  \") 0)\n    (check-equal? (candidate \"EEEE\") 2)\n))\n\n(test-humaneval)"
completions: ["  (cond\n    [(empty? s) 0]\n    [(even? (length s)) 0]\n    [else\
    \ (+ 1 (count_upper (substring s 0 (- (length s) 2))))]))\n", "  (cond\n    [(empty?\
    \ s) 0]\n    [(even? (length s)) (+ 1 (count-upper (rest s)))]\n    [else (+ 1\
    \ (count-upper (rest s))) (+ 1 (count-upper (rest s)))]))\n", "  (define (helper\
    \ i count)\n    (cond [(char=? (char-code (car s)) 65) (helper (cdr i) (inc count))]\n\
    \          [(char=? (char-code (car s)) 97) (helper (cdr i) (inc count))]\n  \
    \        [else (inc count)]))\n  (helper s 0))\n", "  (let loop ((s s)\n     \
    \        (count 0))\n    (cond\n      [(empty? s) count]\n      [(char-upper?\
    \ (car s)) (loop (cdr s) (+ count 1))]\n      [else (loop (cdr s) count)])))\n",
  "  (define (count-vowel i count)\n    (if (even? i)\n        (if (char=? (char-code\
    \ (char s i)) #\\A)\n            (count-vowel (+ i 1) (+ count 1))\n         \
    \   (count-vowel (+ i 1) count))\n        count))\n  (count-vowel 0 0))\n", " \
    \ (define (helper s count)\n    (cond\n      [(empty? s) count]\n      [(char=?\
    \ (car s) #\\A) (incf count)]\n      [else (helper (cdr s) (incf count))]))\n\
    \  (helper s 0))\n", "  (cond\n    [(empty? s) 0]\n    [(even? (car s)) (+ 1 (count_upper\
    \ (cdr s)))]\n    [else (count_upper (cdr s))]))\n", "  (cond\n    [(empty? s)\
    \ 0]\n    [(even? (car s)) (+ 1 (count_upper (cdr s)))]\n    [else (count_upper\
    \ (cdr s))]))\n", "  (let loop ((s s)\n             (count 0))\n    (cond ((or\
    \ (char=? s #\\a) (char=? s #\\e) (char=? s #\\i) (char=? s #\\o))\n         \
    \  (loop (substring s 0 (+ count 1))\n                 (+ count 1)))\n       \
    \   ((char=? s #\\A) (loop (substring s 0 (+ count 1))\n                     \
    \          (+ count 1)))\n          ((char=? s #\\E) (loop (substring s 0 (+ count\
    \ 1))\n                               (+ count 1)))\n          ((char=? s #\\\
    I) (loop (substring s 0 (+ count 1))\n                               (+ count\
    \ 1)))\n          ((char=? s #\\O) (loop (substring s 0 (+ count 1))\n       \
    \                        (+ count 1)))\n          (else (loop (substring s 0 (+\
    \ count 1))\n                     (+ count 1))))))\n", "  (let loop ((s s)\n \
    \            (count 0))\n    (cond ((or (not (eq? s \"\")) (eq? s #\\newline))\n\
    \           count)\n          ((char=? (car s) #\\A)\n           (loop (cdr s)\
    \ (+ count 1)))\n          ((char=? (car s) #\\E)\n           (loop (cdr s) (+\
    \ count 1)))\n          ((char=? (car s) #\\I)\n           (loop (cdr s) (+ count\
    \ 1)))\n          ((char=? (car s) #\\O)\n           (loop (cdr s) (+ count 1)))\n\
    \          ((char=? (car s) #\\U)\n           (loop (cdr s) (+ count 1)))\n  \
    \        (else\n           (loop (cdr s) count))))\n", "  (let loop ((s s)\n \
    \            (count 0))\n    (cond [(empty? s) count]\n          [(char-upper?\
    \ (car s)) (loop (cdr s) (+ count 1))]\n          [else (loop (cdr s) count)])))\n",
  "  (define (helper s count)\n    (if (null? s)\n        count\n        (helper (cdr\
    \ s) (+ count (if (char-upper? (car s)) 1 0)))))\n  (helper s 0))\n", "  (cond\n\
    \    [(empty? s) 0]\n    [(even? (car s)) (+ 1 (count_upper (cdr s)))]\n    [else\
    \ (count_upper (cdr s))]))\n", "  (let loop ((s s)\n             (count 0))\n\
    \    (cond ((string-empty? s) count)\n          ((char-upper? (car s)) (loop (cdr\
    \ s) (+ count 1)))\n          (else (loop (cdr s) count)))))\n", "  (cond\n  \
    \  [(empty? s) 0]\n    [(equal? (first s) 'A) (+ 0 (count_upper (rest s)))]\n\
    \    [else (+ 0 (count_upper (rest s)))]))\n", "  (let loop ((s s)\n         \
    \    (count 0))\n    (cond [(empty? s) count]\n          [(char-upper? (car s))\
    \ (loop (cdr s) (+ count 1))]\n          [else (loop (cdr s) count)])))\n", " \
    \ (let loop ((s s)\n             (count 0))\n    (cond\n      [(empty? s) count]\n\
    \      [(char-upper? (car s)) (loop (cdr s) (+ count 1))]\n      [else (loop (cdr\
    \ s) count)])))\n", "  (define (helper s count)\n    (cond\n      [(empty? s)\
    \ count]\n      [(char-upper? (car s)) (helper (cdr s) (+ count 1))]\n      [else\
    \ (helper (cdr s) count)]\n      ))\n  (helper s 0))\n", "  (cond\n    [(empty?\
    \ s) 0]\n    [(even? (length s)) (+ 1 (count (substring s 0 (- 2 (length s)))))]\n\
    \    [else (+ 1 (count (substring s 0 (- 2 (length s)))))]))\n", "  (define (helper\
    \ i count)\n    (if (zero? i)\n        count\n        (helper (sub1 i) (incf count))))\n\
    \  (helper (length s) 0))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
