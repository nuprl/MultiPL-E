name: HumanEval_30_get_positive
language: rkt
prompt: "#lang racket\n\n;; Return only positive numbers in the list.\n(define (get_positive\
  \ l)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate get_positive))\n\
  \    (check-equal? (candidate (list -1 -2 4 5 6)) (list 4 5 6))\n    (check-equal?\
  \ (candidate (list 5 3 -5 2 3 3 9 0 123 1 -10)) (list 5 3 2 3 3 9 123 1))\n    (check-equal?\
  \ (candidate (list -1 -2)) (list ))\n    (check-equal? (candidate (list )) (list\
  \ ))\n))\n\n(test-humaneval)"
completions: ["  (filter (lambda (x) (> x 0)) l))\n", "  (filter (lambda (x) (> x\
    \ 0)) l))\n", "  (filter (lambda (x) (> x 0)) l))\n", "  (filter (lambda (x) (>\
    \ x 0)) l))\n", "  (filter (lambda (x) (> x 0)) l))\n", "  (filter (lambda (x)\
    \ (> x 0)) l))\n", "  (filter (lambda (x) (> x 0)) l))\n", "  (filter (lambda\
    \ (x) (> x 0)) l))\n", "  (filter (lambda (x) (> x 0)) l))\n", "  (filter (lambda\
    \ (x) (> x 0)) l))\n", "  (filter (lambda (x) (> x 0)) l))\n", "  (filter (lambda\
    \ (x) (> x 0)) l))\n", "  (filter (lambda (x) (> x 0)) l))\n", "  (filter (lambda\
    \ (x) (> x 0)) l))\n", "  (cond\n    [(empty? l) empty]\n    [(number? (first\
    \ l)) (cons (first l) (get_positive (rest l)))]\n    [else (get_positive (rest\
    \ l))]))\n", "  (filter (lambda (x) (> x 0)) l))\n", "  (filter (lambda (x) (>\
    \ x 0)) l))\n", "  (filter (lambda (x) (> x 0)) l))\n", "  (filter (lambda (x)\
    \ (> x 0)) l))\n", "  (filter (lambda (x) (> x 0)) l))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
