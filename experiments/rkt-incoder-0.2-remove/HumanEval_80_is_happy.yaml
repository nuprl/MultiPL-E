name: HumanEval_80_is_happy
language: rkt
prompt: "#lang racket\n\n;; You are given a string s.\n;; Your task is to check if\
  \ the string is happy or not.\n;; A string is happy if its length is at least 3\
  \ and every 3 consecutive letters are distinct\n;; For example:\n(define (is_happy\
  \ s)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate is_happy))\n\
  \    (check-equal? (candidate \"a\") #f)\n    (check-equal? (candidate \"aa\") #f)\n\
  \    (check-equal? (candidate \"abcd\") #t)\n    (check-equal? (candidate \"aabb\"\
  ) #f)\n    (check-equal? (candidate \"adb\") #t)\n    (check-equal? (candidate \"\
  xyy\") #f)\n    (check-equal? (candidate \"iopaxpoi\") #t)\n    (check-equal? (candidate\
  \ \"iopaxioi\") #f)\n))\n\n(test-humaneval)"
completions: ["  (and (>= (length s) 3) (distinct (subseq s 0 3) (subseq s 3 6) (subseq\
    \ s 6 9))))\n", "  (or (= (length s) 3)\n      (and (= (length s) 3)\n       \
    \    (distinct-letters s))))\n", "  (and (>= (length s) 3)\n       (for/fold ((counts\
    \ #{})) ((letter #\\a)) (\n         (if (char=? (char s letter) (char s #\\a))\n\
    \             (add1 (counts letter))\n             (counts #{})))))\n", "  (or\
    \ (= (length s) 3)\n      (and (= (length s) 3)\n           (distinct? s (subseq\
    \ s 0 (- 3 (length s)))))))\n", "  (cond\n    [(empty? s) #t]\n    [(or (empty?\
    \ (rest s)) (empty? (first s))) #f]\n    [else (and (>= (length s) 3) (distinct\
    \ (rest s) (first s))))]))\n", "  (or (= (length s) 3)\n      (and (= (length\
    \ s) 3)\n           (distinct-letters s))))\n", "  (cond\n    [(empty? s) #t]\n\
    \    [(and (>= (length s) 3) (distinct (subseq s 0 3) (subseq s 3 6))) #t]\n \
    \   [else #f]\n  )\n)\n", "  (or (and (>= (length s) 3)\n           (every (lambda\
    \ (c) (member c s)) '(#\\A #\\B #\\C #\\D #\\E #\\F #\\G #\\H #\\I #\\J #\\K #\\\
    L #\\M #\\N #\\O #\\P #\\Q #\\R #\\S #\\T #\\U #\\V #\\W #\\X #\\Y #\\Z)))\n \
    \     (and (>= (length s) 3)\n           (every (lambda (c) (member c s)) '(#\\\
    a #\\b #\\c #\\d #\\e #\\f #\\g #\\h #\\i #\\j #\\k #\\l #\\m #\\n #\\o #\\p #\\\
    q #\\r #\\s #\\t #\\u #\\v #\\w #\\x #\\y #\\z))))\n", "  (and (>= (length s)\
    \ 3)\n       (every (lambda (x) (distinct (subseq s 0 x) (subseq s x (length s))))\n\
    \               (range (length s)))))\n", "  (cond\n    [(empty? s) #t]\n    [(and\
    \ (empty? (rest s)) #f) (and (empty? (rest s)) #f)]\n    [else (and (empty? (rest\
    \ s)) #f) (and (empty? (rest s)) #f) (and (empty? (rest s)) #f)]\n    [else (and\
    \ (empty? (rest s)) #f) (and (empty? (rest s)) #f) (and (empty? (rest s)) #f)\
    \ (and (empty? (rest s)) #f)]\n    [else (and (empty? (rest s)) #f) (and (empty?\
    \ (rest s)) #f) (and (empty? (rest s)) #f) (and (empty? (rest s)) #f) (and (empty?\
    \ (rest s)) #f)]\n    [else (and (empty? (rest s)) #f) (and (empty? (rest s))\
    \ #f) (and (empty? (rest s)) #f) (and (empty? (rest s)) #f) (and (empty? (rest\
    \ s)) #f) (and (empty? (rest s)) #f)]\n    [else (and (empty? (rest s)) #f) (and\
    \ (empty? (rest s)) #f) (and (empty? (rest s)) #f) (and (empty? (rest s)) #f)\
    \ (and (empty? (rest s)) #f) (and (empty? (rest s)) #f) (and (empty? (rest s))\
    \ #f)]\n    [else (and (empty? (rest s)) #f) (and (empty? (rest s)) #f) (and (empty?\
    \ (rest s)) #f) (and (empty? (rest s)) #f) (and (empty? (rest s)) #f) (and (empty?\
    \ (rest s)) #f) (and (empty? (rest s)) #f) (and (empty? (rest s)) #f)]\n    [else\
    \ (and (empty? (rest s)) #f) (and (empty? (rest s)) #f) (and (empty? (rest s))\
    \ #f) (and (empty? (rest s)) #f) (and (empty? (rest s)) #f) (and (empty? (rest\
    \ s)) #f) (and (empty? (rest s)) #f) (and (empty? (rest s)) #f)]\n    [else (and\
    \ (empty? (rest s)) #f) (and (empty? (rest s)) #f) (and (empty? (rest s)) #f)\
    \ (and (empty? (rest s)) #f) (and (empty? (rest s)) #f) (and (empty? (rest s))\
    \ #f) (and (empty? (rest s)) #f) (and (empty? (rest s)) #f)]\n    [else (and (empty?\
    \ (rest s)) #f) (and (empty? (rest s)) #f) (and (empty? (rest s)) #f) (and (empty?\
    \ (rest s)) #f) (and (empty? (rest s)) #f) (and (empty? (rest s)) #f) (and (empty?\
    \ (rest s)) #", "  (or (>= (length s) 3)\n      (for/fold ((count 0) (letter #\\\
    A)) ((i (in-range (length s))))\n        (if (equal? (substring s i i) letter)\n\
    \            (set! count (+ count 1))\n            (set! letter #\\A))))\n", " \
    \ (cond\n    [(empty? s) #t]\n    [(= (length s) 3) #t]\n    [else (and (distinct\
    \ (substring s 0 2)) (distinct (substring s 2 4)))]))\n", "  (cond\n    [(empty?\
    \ s) #t]\n    [(= (length s) 3) #t]\n    [else (and (= (length s) 3)\n       \
    \        (distinct-letters s))]))\n", "  (cond\n    [(empty? s) #t]\n    [(= (length\
    \ s) 3) #t]\n    [else (and (distinct? (substring s 0 2)) (distinct? (substring\
    \ s 2 4)))]))\n", "  (and (>= (length s) 3)\n       (for/fold ([i 0])\n      \
    \            ([j 0])\n                  ([k 0])\n                  ([l 0])\n \
    \                 ([m 0])\n                  ([n 0])\n                  ([o 0])\n\
    \                  ([p 0])\n                  ([q 0])\n                  ([r 0])\n\
    \                  ([s 0])\n                  ([t 0])\n                  ([u 0])\n\
    \                  ([v 0])\n                  ([w 0])\n                  ([x 0])\n\
    \                  ([y 0])\n                  ([z 0])\n                  ([a 0])\n\
    \                  ([b 0])\n                  ([c 0])\n                  ([d 0])\n\
    \                  ([e 0])\n                  ([f 0])\n                  ([g 0])\n\
    \                  ([h 0])\n                  ([i 0]))\n       (for/fold ([j 0])\n\
    \                  ([k 0])\n                  ([l 0])\n                  ([m 0])\n\
    \                  ([n 0])\n                  ([o 0])\n                  ([p 0])\n\
    \                  ([q 0])\n                  ([r 0])\n                  ([s 0])\n\
    \                  ([t 0])\n                  ([u 0])\n                  ([v 0])\n\
    \                  ([w 0])\n                  ([x 0])\n                  ([y 0])\n\
    \                  ([z 0])\n                  ([a 0])\n                  ([b 0])\n\
    \                  ([c 0])\n                  ([d 0])\n                  ([e 0])\n\
    \                  ([f 0])\n                  ([g 0])\n                  ([h 0])\n\
    \                  ([i 0])\n                  ([j 0]))\n       (for/fold ([k 0])\n\
    \                  ([l 0])\n                  ([m 0])\n                  ([n 0])\n\
    \                  ([o 0])\n                  ([p 0])\n                  ([q 0])\n\
    \                  ([r 0])\n                  ([s 0])\n                  ([t 0])\n\
    \                  ([u 0])\n                  ([v 0])\n                  ([w 0])\n\
    \                  ([x 0])\n                  ([y 0])\n                  ([z 0])\n\
    \                  ([a 0])\n                  ([b 0])\n                  ([c 0])\n\
    \                  ([d 0])\n                  ([e 0])\n                  ([f 0])\n\
    \                  ([g 0])\n                  ([h 0])\n                  ([i 0])\n\
    \                  ([j 0])\n                  ([k 0]))\n       (for/fold ([l 0])\n\
    \                  ([m 0])\n                  ([n 0])\n                  ([o 0])\n\
    \                  ([p 0])\n                  ([q 0])\n                  ([r 0])\n\
    \                  ([s 0])\n                  ([t 0])\n                  ([u 0])\n\
    \                  ([v 0])\n                  ([w 0])\n                  ([x 0])\n\
    \                  ([y 0])\n                  ([z 0])\n                  ([a 0])\n",
  "  (or (= (length s) 3)\n      (and (= (modulo s 3) 0)\n           (distinct-letters\
    \ s))))\n", "  (or (= (length s) 3)\n      (and (= (length s) 3)\n           (distinct-letters\
    \ s))))\n", "  (and (>= (length s) 3)\n       (for/fold ([i 0]) ([j 0]) (lambda([x\
    \ y])\n                                (if (and (char=? (char-code x) (char-code\
    \ y))\n                                         (not (equal? (char-code x) (char-code\
    \ y)))\n                                     (set! i (add1 i))\n             \
    \                        (set! j (add1 j))))\n                               \
    \ (if (= i j)\n                                    #f\n                      \
    \              #t))))))\n", "  (or (= (length s) 3)\n      (and (= (length s)\
    \ 3)\n           (distinct-letters s))))\n", "  (or (= (length s) 3)\n      (and\
    \ (= (length s) 3)\n           (every (lambda (x) (distinct (subseq s 0 x)) (subseq\
    \ s 0 3))))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
