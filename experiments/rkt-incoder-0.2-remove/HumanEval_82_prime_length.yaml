name: HumanEval_82_prime_length
language: rkt
prompt: "#lang racket\n\n;; Write a function that takes a string and returns True\
  \ if the string\n;; length is a prime number or False otherwise\n;; Examples\n(define\
  \ (prime_length string)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate prime_length))\n\
  \    (check-equal? (candidate \"Hello\") #t)\n    (check-equal? (candidate \"abcdcba\"\
  ) #t)\n    (check-equal? (candidate \"kittens\") #t)\n    (check-equal? (candidate\
  \ \"orange\") #f)\n    (check-equal? (candidate \"wow\") #t)\n    (check-equal?\
  \ (candidate \"world\") #t)\n    (check-equal? (candidate \"MadaM\") #t)\n    (check-equal?\
  \ (candidate \"Wow\") #t)\n    (check-equal? (candidate \"\") #f)\n    (check-equal?\
  \ (candidate \"HI\") #t)\n    (check-equal? (candidate \"go\") #t)\n    (check-equal?\
  \ (candidate \"gogo\") #f)\n    (check-equal? (candidate \"aaaaaaaaaaaaaaa\") #f)\n\
  \    (check-equal? (candidate \"Madam\") #t)\n    (check-equal? (candidate \"M\"\
  ) #f)\n    (check-equal? (candidate \"0\") #f)\n))\n\n(test-humaneval)"
completions: ["  (prime-length string))\n", "  (cond [(= (string-length string) 1)\
    \ #t]\n        [else (or (prime-number? (string-to-number string))\n         \
    \         (prime-length (substring string 1 string)))]))\n", "  (prime-length\
    \ string))\n", "  (prime-length string))\n", "  (cond [(= (string-length string)\
    \ 1) true]\n        [else (prime-length (substring string 0 (string/length string)))]))\n",
  "  (prime-length? string 2))\n", "  (prime-length? string 2))\n", "  (prime-length\
    \ string 0))\n", "  (define (prime? n)\n    (= (modulo n 2) 1))\n  (or (prime?\
    \ (length string)) (prime? (sub1 string))))\n)\n", "  (prime-length? string 2))\n",
  "  (prime-length string))\n", "  (cond\n    [(empty? string) false]\n    [(equal?\
    \ (first string) (string-ref string 0)) (prime_length (rest string))]\n    [else\
    \ (prime_length (rest string))]))\n", "  (prime-length string))\n", "  (prime-length\
    \ string))\n", "  (cond\n    [(empty? string) false]\n    [(equal? (length string)\
    \ 1) true]\n    [else (prime_length (cdr string))]))\n", "  (cond [(= (length\
    \ string) 1) true]\n        [else (prime_length (cdr string))]))\n", "  (prime-length\
    \ string))\n", "  (prime-length string))\n", "  (cond\n    [(empty? string) false]\n\
    \    [(equal? (first string) '#\\Space) false]\n    [else (prime_length (rest\
    \ string))]))\n", "  (prime-length string))\n", "  (cond [(= (string-length string)\
    \ 2) true]\n        [else (prime_length (substring string 0 (string/length string)))]))\n",
  "  (cond\n    [(empty? string) false]\n    [(equal? (first string) 0) true]\n  \
    \  [else (prime_length (rest string))]))\n", "  (define (prime? n)\n    (= (modulo\
    \ n 2) 0))\n  (or (prime? (length string)) (prime? (sub1 string))))\n)\n", " \
    \ (prime-length string))\n", "  (prime-length? string 2))\n", "  (prime-length\
    \ string))\n", "  (prime-length string))\n", "  (prime-length? string 2))\n",
  "  (define (prime? n)\n    (= (modulo n 2) 1))\n  (or (prime? (length string)) (prime?\
    \ (sub1 (length string)))))\n</code>\n<|/ a tags=racket,scheme |>\n<| a tags=racket,scheme\
    \ |>\n<code>", "  (prime-length string))\n", "  (cond\n    [(empty? string) false]\n\
    \    [(equal? (first string) 1) true]\n    [else (prime_length (rest string))]))\n",
  "  (prime-length? string 2))\n", "  (prime-length string))\n", "  (prime-length\
    \ string))\n", "  (prime-length string))\n", "  (cond [(string? string) (prime-length\
    \ (string-length string))]\n        [else false]))\n", "  (prime-length string))\n",
  "  (prime-length? string 2))\n", "  (cond\n    [(empty? string) false]\n    [(equal?\
    \ (first string) (string-ref string 0)) true]\n    [else (prime_length (rest string))]))\n",
  "  (prime-length? string 2))\n", "  (prime-length string))\n", "  (prime-length\
    \ string))\n", "  (define (prime? n)\n    (= (modulo n 2) 1))\n  (prime? (length\
    \ string)))\n", "  (prime-length string))\n", "  (prime-length? string 2))\n",
  "  (prime-length? string 2))\n", "  (cond\n    [(empty? string) false]\n    [(equal?\
    \ (first string) '#\\0) false]\n    [else (prime_length (rest string))]))\n",
  "  (prime-length string))\n", "  (prime-length string))\n", "  (prime-length string))\n",
  "  (cond\n    [(empty? string) false]\n    [else (prime? (length string))]\n  )\n\
    )\n", "  (cond\n    [(empty? string) false]\n    [(= (length string) 1) true]\n\
    \    [else (prime_length (cdr string))]))\n", "  (prime-length string))\n", " \
    \ (prime-length string))\n", "  (prime-length string))\n", "  (prime-length string))\n",
  "  (prime-length string))\n", "  (cond\n    [(empty? string) false]\n    [(equal?\
    \ (first string) '#\\Space) false]\n    [else (prime_length (rest string))]))\n",
  "  (prime-length string))\n", "  (prime-length string))\n", "  (prime-length string))\n",
  "  (prime-length string))\n", "  (prime-length string))\n", "  (prime-length? string\
    \ 2))\n", "  (prime-check string 2))\n", "  (prime-length? string 2))\n", "  (prime-length?\
    \ string 2))\n", "  (prime-length string))\n", "  (cond\n    [(empty? string)\
    \ false]\n    [(equal? (first string) '#\\0) false]\n    [else (prime_length (rest\
    \ string))]))\n", "  (cond [(= (string-length string) 2)\n         #t]\n     \
    \   [(= (string-length string) 3)\n         #t]\n        [else\n         (let\
    \ ([i (string->list (string->string string))])\n           (cond [(empty? i)\n\
    \                  #f]\n                 [(= (first i) 0)\n                  #f]\n\
    \                 [else\n                  (let ([j (sub1 (rest i))])\n      \
    \              (cond [(empty? j)\n                           #f]\n           \
    \                [(= (first j) 0)\n                            #f]\n         \
    \                  [else\n                             (let ([k (sub1 (rest j))])\n\
    \                               (cond [(empty? k)\n                          \
    \           #f]\n                                     [(= (first k) 0)\n     \
    \                                #f]\n                                     [else\n\
    \                                      (let ([l (sub1 (rest k))])\n          \
    \                              (cond [(empty? l)\n                           \
    \                    #f]\n                                               [(= (first\
    \ l) 0)\n                                               #f]\n                \
    \                               [else\n                                      \
    \          (let ([m (sub1 (rest l))])\n                                      \
    \            (cond [(empty? m)\n                                             \
    \            #f]\n                                                         [(=\
    \ (first m) 0)\n                                                         #f]\n\
    \                                                         [else\n            \
    \                                              (let ([n (sub1 (rest m))])\n  \
    \                                                          (cond [(empty? n)\n\
    \                                                                   #f]\n    \
    \                                                               [(= (first n)\
    \ 0)\n                                                                   #f]\n\
    \                                                                   [else\n  \
    \                                                                  (let ([p (sub1\
    \ (rest n))])\n                                                              \
    \        (cond [(empty? p)\n                                                 \
    \                          #f]\n                                             \
    \                              [(= (first p) 0)\n                            \
    \                                               #f]\n                        \
    \                                                   [else\n                  \
    \                                                          (let ([q (sub1 (rest\
    \ p))])\n                                                                    \
    \          (cond [(empty? q)\n                                               \
    \                                        #f]\n                               \
    \                                                        [(= (first q) 0)\n  \
    \                                                                            \
    \         #f]\n                                                              \
    \                         [else\n                                            \
    \                                             (let ([r (sub1 (rest q))])\n   \
    \                                                                            \
    \           (cond [(empty? r)\n                                              \
    \                                                     #f]\n                  \
    \                                                                            \
    \     [(= (first r) 0)\n                                                     \
    \                                              #f]\n                         \
    \                                                                          [else\n\
    \                                                                            \
    \                        (let ([s (sub1 (rest r))])\n                        \
    \                                                                            \
    \  (cond [(empty? s)\n                                                       \
    \                                                      #f]\n                 \
    \                                                                            \
    \                [(= (first s) 0)\n                                          \
    \                                                                   #f]\n    \
    \                                                                            \
    \                             [else\n                                        \
    \                                                                      (let ([t\
    \ (sub1 (rest s))])\n                                                        \
    \                                                        (cond [(empty? t)\n \
    \                                                                            \
    \                              #f]\n                                         \
    \                                                                  ", "  (prime-length\
    \ string))\n", "  (prime-length? string 2))\n", "  (prime-length string))\n",
  "  (prime-length string 0))\n", "  (define (prime? n)\n    (= (modulo n 2) 0))\n\
    \  (define (primes?)\n    (for/list ([n string])\n      (if (prime? n)\n     \
    \     (return true)\n          (return false))))\n  (primes?))\n", "  (prime-length\
    \ string))\n", "  (prime-length string))\n", "  (prime-length string))\n", " \
    \ (prime-check string 2))\n", "  (cond\n    [(empty? string) false]\n    [(equal?\
    \ (length string) 1) true]\n    [else (prime_length (cdr string))]))\n", "  (prime-length\
    \ string))\n", "  (cond [(= (string-length string) 1) true]\n        [else (prime-length\
    \ (substring string 0 (string/length string)))]))\n", "  (prime-length string))\n",
  "  (prime-length string))\n", "  (prime-length string))\n", "  (prime-length string))\n",
  "  (prime-length string))\n", "  (prime-length? string 2))\n", "  (prime-length\
    \ string))\n", "  (prime-length string 2))\n", "  (prime-length string))\n", " \
    \ (prime-length string))\n", "  (prime-length string 2))\n", "  (prime-length?\
    \ string 2))\n", "  (prime-length? string 2))\n", "  (prime-length string 0))\n",
  "  (cond\n    [(empty? string) false]\n    [else (prime? (length string))]\n  )\n\
    )\n", "  (prime-length string 2))\n", "  (prime-check string 2))\n", "  (prime-length\
    \ string))\n", "  (prime-length string))\n", "  (cond [(= (string-length string)\
    \ 2)\n         #t]\n        [(= (string-length string) 3)\n         #t]\n    \
    \    [else\n         (let ([i (string-length string)])\n           (cond [(= i\
    \ 2)\n                  #t]\n                 [(= i 3)\n                  #t]\n\
    \                 [(= (modulo (string->number string) i) 0)\n                \
    \  #t]\n                 [else\n                  (prime_length (substring string\
    \ 0 (- i 1)))]))]))\n", "  (prime-length string))\n", "  (prime-length? string\
    \ 2))\n", "  (prime-length? string 2))\n", "  (prime-length string))\n", "  (cond\
    \ [(= (string-length string) 2)\n         #t]\n        [(= (string-length string)\
    \ 3)\n         #t]\n        [else\n         (let ([i (string-length string)])\n\
    \           (cond [(= i 2)\n                  #t]\n                 [(= i 3)\n\
    \                  #t]\n                 [(= (mod i 2) 0)\n                  #t]\n\
    \                 [else\n                  (prime_length (substring string 0 (-\
    \ i 1)))]))]))\n", "  (prime-length? string 2))\n", "  (prime-length? string 2))\n",
  "  (prime-length string))\n", "  (prime-length? string 2))\n", "  (prime-length\
    \ string))\n", "  (prime-length? string 2))\n", "  (prime-length string))\n",
  "  (prime-length? string 2))\n", "  (prime-length? string 2))\n", "  (prime-length\
    \ string))\n", "  (prime-length? string 2))\n", "  (cond [(= (string-length string)\
    \ 2) true]\n        [else (prime_length (substring string 0 2))]))\n", "  (prime-length\
    \ string))\n", "  (cond\n    [(empty? string) false]\n    [(equal? (length string)\
    \ 1) true]\n    [else (prime_length (rest string))]))\n", "  (cond [(string? string)\
    \ (prime-length (string-length string))]\n        [else false]))\n", "  (prime-length?\
    \ string 2))\n", "  (prime-length? string 2))\n", "  (prime-length string))\n",
  "  (cond\n    [(empty? string) false]\n    [(= (length string) 1) true]\n    [else\
    \ (prime_length (rest string))]))\n", "  (cond\n    [(empty? string) true]\n \
    \   [else (prime? (length string))]))\n", "  (prime-length string 2))\n", "  (prime-length\
    \ string 2))\n", "  (cond [(= (string-length string) 1) #t]\n        [else (prime-checker\
    \ string (string-length string))]))\n", "  (prime-length? string 2))\n", "  (prime-length\
    \ string))\n", "  (prime-length? string 2))\n", "  (prime-length? string 2))\n",
  "  (cond [(= (string-length string) 1) #t]\n        [else (prime_length (substring\
    \ string 0 (string/length string)))]))\n", "  (define (prime? n)\n    (= (modulo\
    \ n 2) 1))\n  (if (empty? string)\n      true\n      (if (prime? (length string))\n\
    \          true\n          false)))\n", "  (prime-length? string 2))\n", "  (prime-length?\
    \ string 2))\n", "  (cond\n    [(empty? string) false]\n    [(= (string-length\
    \ string) 1) true]\n    [else (prime-length (substring string 0 (string/length\
    \ string)))]))\n", "  (cond [(= (string-length string) 1) #t]\n        [else (prime-length\
    \ (substring string 0 (string-length string))) #f]))\n", "  (prime-length string))\n",
  "  (prime-length string))\n", "  (prime-length? string 2))\n", "  (prime-length\
    \ string))\n", "  (cond [(= (string-length string) 1) #t]\n        [else (prime_length\
    \ (substring string 1 string))]))\n", "  (prime-length string))\n", "  (prime-length\
    \ string))\n", "  (prime-length string))\n", "  (prime-length string))\n", " \
    \ (prime-length? string 2))\n", "  (prime-length? string 2))\n", "  (cond [(=\
    \ (string-length string) 2)\n         #t]\n        [(= (string-length string)\
    \ 3)\n         #t]\n        [else\n         (let ([i (string->number (string->string\
    \ string))])\n           (cond [(= (modulo i 2) 0)\n                  #t]\n  \
    \               [else\n                  (prime_length (substring string 0 (add1\
    \ (string->number (string->string string))))))]))))\n", "  (prime-length string))\n",
  "  (prime-length string))\n", "  (prime-length? string 2))\n", "  (prime-length?\
    \ string 2))\n", "  (prime-check string 2))\n", "  (prime-length string))\n",
  "  (prime-length string))\n", "  (prime-length string 0))\n", "  (cond\n    [(empty?\
    \ string) false]\n    [(= (length string) 1) true]\n    [else (prime? (first string))]))\n",
  "  (prime-length string))\n", "  (prime-length string))\n", "  (cond\n    [(empty?\
    \ string) false]\n    [(= (length string) 1) true]\n    [else (prime? (first string))]))\n",
  "  (prime-length? string 2))\n", "  (prime-length string))\n", "  (prime-length\
    \ string))\n", "  (cond\n    [(empty? string) false]\n    [(equal? (first string)\
    \ '#\\Space) false]\n    [else (prime_length (rest string))]))\n", "  (prime-length\
    \ string))\n", "  (define (prime? n)\n    (if (= n 1)\n        #t\n        (or\
    \ (= (modulo n n) 0)\n            (and (prime? (quotient n 2))))))\n  (prime?\
    \ (length string)))\n", "  (prime-length string))\n", "  (prime-length string))\n",
  "  (cond [(= (string-length string) 2) true]\n        [else (prime_length (substring\
    \ string 0 1))]))\n", "  (prime-length string))\n", "  (prime-length string))\n",
  "  (prime-length string 0))\n", "  (cond\n    [(empty? string) false]\n    [(= (length\
    \ string) 1) true]\n    [else (prime? (substring string 0 (- 1 (length string))))]))\n",
  "  (prime-length string))\n", "  (cond\n    [(empty? string) false]\n    [else (prime?\
    \ (length string))]))\n", "  (prime-length? string 2))\n", "  (prime-length string))\n",
  "  (define (prime? n)\n    (= (modulo n 2) 1))\n  (define (prime-length n)\n   \
    \ (if (prime? n)\n        (+ 1 (prime-length (+ n 1)))))\n  (prime-length string))\n",
  "  (prime-length string))\n", "  (cond [(= (string-length string) 2)\n         #t]\n\
    \        [(= (string-length string) 3)\n         #t]\n        [(= (string-length\
    \ string) 4)\n         #t]\n        [else\n         (let ([i (string->list (string->string\
    \ string))])\n           (cond [(empty? i)\n                  #f]\n          \
    \       [(= (first i) 1)\n                  #t]\n                 [else\n    \
    \              (prime_length (rest i))]))]))\n", "  (prime-length string))\n",
  "  (cond\n    [(empty? string) false]\n    [(equal? (first string) '#\\Space) false]\n\
    \    [else (prime_length (rest string))]))\n", "  (prime-length? string 2))\n",
  "  (prime-length string))\n", "  (prime-length string))\n", "  (prime-length string))\n",
  "  (prime-length string))\n", "  (cond\n    [(empty? string) false]\n    [else (prime?\
    \ (length string))]))\n", "  (prime-length string))\n", "  (cond [(string? string)\
    \ (prime-length (string-length string))]\n        [else false]))\n", "  (prime-length?\
    \ string 2))\n", "  (prime-length string))\n", "  (prime-length string))\n", " \
    \ (prime-length? string 2))\n", "  (prime-length string))\n", "  (prime-length?\
    \ string 2))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
