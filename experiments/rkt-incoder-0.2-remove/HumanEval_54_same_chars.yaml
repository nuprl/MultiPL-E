name: HumanEval_54_same_chars
language: rkt
prompt: "#lang racket\n\n;; Check if two words have the same characters.\n(define\
  \ (same_chars s0 s1)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate same_chars))\n\
  \    (check-equal? (candidate \"eabcdzzzz\" \"dddzzzzzzzddeddabc\") #t)\n    (check-equal?\
  \ (candidate \"abcd\" \"dddddddabc\") #t)\n    (check-equal? (candidate \"dddddddabc\"\
  \ \"abcd\") #t)\n    (check-equal? (candidate \"eabcd\" \"dddddddabc\") #f)\n  \
  \  (check-equal? (candidate \"abcd\" \"dddddddabcf\") #f)\n    (check-equal? (candidate\
  \ \"eabcdzzzz\" \"dddzzzzzzzddddabc\") #f)\n    (check-equal? (candidate \"aabb\"\
  \ \"aaccc\") #f)\n))\n\n(test-humaneval)"
completions: ["  (let ((chars (string->list s0)))\n    (and (equal? (car chars) (car\
    \ s1))\n         (equal? (cdr chars) (cdr s1)))))\n", "  (cond [(empty? s0) #t]\n\
    \        [(empty? s1) #t]\n        [(equal? (first s0) (first s1)) #t]\n     \
    \   [else (same_chars (rest s0) (rest s1))]))\n", "  (cond\n    [(empty? s0) #t]\n\
    \    [(empty? s1) #t]\n    [(equal? (first s0) (first s1)) #t]\n    [else (and\
    \ (same_chars (rest s0) s1)\n               (not (same_chars (rest s1) s0)))]))\n",
  "  (let ((chars (string->list s0)))\n    (and (equal? (length s0) (length s1))\n\
    \         (equal? (car chars) (car s1))\n         (equal? (cdr chars) (cdr s1)))))\n",
  "  (let ((chars (string->list s0)))\n    (and (equal? (car chars) (car s1))\n  \
    \       (equal? (cdr chars) (cdr s1)))))\n", "  (let ([c (char->integer s0)])\n\
    \    (char->integer s1)\n    (= c c)))\n", "  (cond [(empty? s0) #t]\n       \
    \ [(empty? s1) #t]\n        [(equal? (first s0) (first s1)) #t]\n        [else\
    \ (same_chars (rest s0) (rest s1))]))\n", "  (let ((chars (string->list s0)))\n\
    \    (and (equal? (car chars) (car s1))\n         (equal? (cdr chars) (cdr s1)))))\n",
  "  (cond [(empty? s0) #t]\n        [(empty? s1) #t]\n        [(equal? (first s0)\
    \ (first s1)) #t]\n        [else (same_chars (rest s0) (rest s1))]))\n", "  (let\
    \ ((c (char->integer s0)))\n    (char->integer s1) ; force char->integer conversion\n\
    \    (char->integer s0) ; force char->integer conversion\n    (char->integer s1)\
    \ ; force char->integer conversion\n    (char->integer s0) ; force char->integer\
    \ conversion\n    (char->integer s1) ; force char->integer conversion\n    (char->integer\
    \ s0) ; force char->integer conversion\n    (char->integer s1) ; force char->integer\
    \ conversion\n    (char->integer s0) ; force char->integer conversion\n    (char->integer\
    \ s1) ; force char->integer conversion\n    (char->integer s0) ; force char->integer\
    \ conversion\n    (char->integer s1) ; force char->integer conversion\n    (char->integer\
    \ s0) ; force char->integer conversion\n    (char->integer s1) ; force char->integer\
    \ conversion\n    (char->integer s0) ; force char->integer conversion\n    (char->integer\
    \ s1) ; force char->integer conversion\n    (char->integer s0) ; force char->integer\
    \ conversion\n    (char->integer s1) ; force char->integer conversion\n    (char->integer\
    \ s0) ; force char->integer conversion\n    (char->integer s1) ; force char->integer\
    \ conversion\n    (char->integer s0) ; force char->integer conversion\n    (char->integer\
    \ s1) ; force char->integer conversion\n    (char->integer s0) ; force char->integer\
    \ conversion\n    (char->integer s1) ; force char->integer conversion\n    (char->integer\
    \ s0) ; force char->integer conversion\n    (char->integer s1) ; force char->integer\
    \ conversion\n    (char->integer s0) ; force char->integer conversion\n    (char->integer\
    \ s1) ; force char->integer conversion\n    (char->integer s0) ; force char->integer\
    \ conversion\n    (char->integer s1) ; force char->integer conversion\n    (char->integer\
    \ s0) ; force char->integer conversion\n    (char->integer s1) ; force char->integer\
    \ conversion\n    (char->integer s0) ; force char->integer conversion\n    (char->integer\
    \ s1) ; force char->integer conversion\n    (char->integer s0) ; force char->integer\
    \ conversion\n    (char->integer s1) ; force char->integer conversion\n    (char->integer\
    \ s0) ; force char->integer conversion\n    (char->integer s1) ; force char->integer\
    \ conversion\n    (char->integer s0) ; force char->integer conversion\n    (char->integer\
    \ s1) ; ", "  (let ((c (char->integer (first s0))))\n    (and (char->integer (first\
    \ s1)) (char->integer c))))\n", "  (let ((c (char->integer (first s0))\n     \
    \   (dst (char->integer (first s1))))\n    (cond\n      [(< c dst) false]\n  \
    \    [(char->integer (rest s0)) true]\n      [(char->integer (rest s1)) false]\n\
    \      [else (same_chars (rest s0) (rest s1))])))\n", "  (cond [(empty? s0) #t]\n\
    \        [(empty? s1) #t]\n        [(equal? (first s0) (first s1)) #t]\n     \
    \   [else (same_chars (rest s0) (rest s1))]))\n", "  (let ([c (char->integer (first\
    \ s0))])\n    (char->integer (first s1))\n    (char->integer (first s0))\n   \
    \ (char->integer (first s1))\n    (char->integer (first s0))\n    (char->integer\
    \ (first s1))\n    (char->integer (first s0))\n    (char->integer (first s1))\n\
    \    (char->integer (first s0))\n    (char->integer (first s1))\n    (char->integer\
    \ (first s0))\n    (char->integer (first s1))\n    (char->integer (first s0))\n\
    \    (char->integer (first s1))\n    (char->integer (first s0))\n    (char->integer\
    \ (first s1))\n    (char->integer (first s0))\n    (char->integer (first s1))\n\
    \    (char->integer (first s0))\n    (char->integer (first s1))\n    (char->integer\
    \ (first s0))\n    (char->integer (first s1))\n    (char->integer (first s0))\n\
    \    (char->integer (first s1))\n    (char->integer (first s0))\n    (char->integer\
    \ (first s1))\n    (char->integer (first s0))\n    (char->integer (first s1))\n\
    \    (char->integer (first s0))\n    (char->integer (first s1))\n    (char->integer\
    \ (first s0))\n    (char->integer (first s1))\n    (char->integer (first s0))\n\
    \    (char->integer (first s1))\n    (char->integer (first s0))\n    (char->integer\
    \ (first s1))\n    (char->integer (first s0))\n    (char->integer (first s1))\n\
    \    (char->integer (first s0))\n    (char->integer (first s1))\n    (char->integer\
    \ (first s0))\n    (char->integer (first s1))\n    (char->integer (first s0))\n\
    \    (char->integer (first s1))\n    (char->integer (first s0))\n    (char->integer\
    \ (first s1))\n    (char->integer (first s0))\n    (char->integer (first s1))\n\
    \    (char->integer (first s0))\n    (char->integer (first s1))\n    (char->integer\
    \ (first s0))\n    (char->integer (first s1))\n    (char->integer (first s0))\n\
    \    (char->integer (first s1))\n    (char->integer (first s0))\n    (char->integer\
    \ (first s1))\n    (char->", "  (let ((chars (string->list s0)))\n    (let ((chars\
    \ (string->list s1)))\n      (if (null? chars)\n          #t\n          (and (equal?\
    \ (car chars) (car chars))\n               (same_chars (cdr s0) (cdr s1))))))))\n",
  "  (let ((chars (string->list s0)))\n    (and (equal? (first chars) (first s1))\n\
    \         (equal? (rest chars) (rest s1)))))\n", "  (cond [(empty? s0) #t]\n \
    \       [(empty? s1) #t]\n        [(equal? (first s0) (first s1)) #t]\n      \
    \  [else (same_chars (rest s0) (rest s1))]))\n", "  (let ((c (char->integer s0)))\n\
    \    (cond\n      [(char->integer s1) c]\n      [else false]\n    )\n  )\n", " \
    \ (let ((chars (string->list s0)))\n    (and (equal? (car chars) (car s1))\n \
    \        (equal? (cdr chars) (cdr s1)))))\n", "  (cond\n    [(empty? s0) #t]\n\
    \    [(empty? s1) #t]\n    [(equal? (first s0) (first s1)) #t]\n    [else (same_chars\
    \ (rest s0) (rest s1))]))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
