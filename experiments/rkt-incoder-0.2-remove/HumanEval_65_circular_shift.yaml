name: HumanEval_65_circular_shift
language: rkt
prompt: "#lang racket\n\n;; Circular shift the digits of the integer x, shift the\
  \ digits right by shift\n;; and return the result as a string.\n;; If shift > number\
  \ of digits, return digits reversed.\n(define (circular_shift x shift)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate circular_shift))\n\
  \    (check-equal? (candidate 100 2) \"001\")\n    (check-equal? (candidate 12 2)\
  \ \"12\")\n    (check-equal? (candidate 97 8) \"79\")\n    (check-equal? (candidate\
  \ 12 1) \"21\")\n    (check-equal? (candidate 11 101) \"11\")\n))\n\n(test-humaneval)"
completions: ["  (let loop ((x x) (shift shift) (digits '()))\n    (cond\n      [(<\
    \ shift (length x)) (append (subseq x 0 shift) (subseq x shift))\n       (loop\
    \ (subseq x shift) (- shift 1) (cons shift digits))]\n      [else (loop (subseq\
    \ x 0) shift (cons shift digits))]\n      )))\n", "  (if (= shift 0)\n      (list-ref\
    \ x 0)\n      (let ((digits (list-ref x 0)))\n        (let ((result (make-string\
    \ (string-length x)))\n              (shift (- shift 1)))\n          (do ((i 0\
    \ (+ i shift)))\n              ((< i shift))\n            (set! result (append\
    \ (substring result (- i 1) (+ i 1))\n                                 (substring\
    \ digits i shift)))\n            (set! digits (substring digits i shift))\n  \
    \          (set! i (+ i shift))\n            (set! shift (- shift 1)))\n     \
    \     (set! result (append result digits))\n          result))))\n", "  (let loop\
    \ ((x x) (shift shift) (digits '()))\n    (cond ((< shift (length x))\n      \
    \     (reverse digits))\n          ((< shift 0)\n           (reverse digits))\n\
    \          (else\n           (let ((digit (modulo (modulo x 10) (expt 10 shift))))\n\
    \             (cond ((< shift (length digits))\n                    (loop (quotient\
    \ x 10) shift (cons digit digits)))\n                   ((< shift 0)\n       \
    \             (loop (quotient x 10) shift digits))\n                   (else\n\
    \                    (loop (quotient x 10) shift (cons digit digits)))))))))\n",
  "  (let loop ((x x) (shift shift) (result '()))\n    (cond ((< shift (length x))\n\
    \           (reverse result))\n          ((< shift 0)\n           (reverse result))\n\
    \          (else\n           (loop (quotient x 10) (sub1 shift) (cons (quotient\
    \ x 10) result))))))\n", "  (let loop ((x x) (shift shift) (digits '()))\n   \
    \ (if (< shift (length x))\n        (loop (sub1 x) (- shift (length x)) (cons\
    \ shift digits))\n        (reverse digits))))\n", "  (let loop ((x x) (shift shift)\
    \ (digits '()))\n    (if (= shift 0)\n        (reverse digits)\n        (let ((digit\
    \ (modulo (modulo x 10) 10)))\n          (cond ((< shift (length digits))\n  \
    \               (loop (quotient x 10) (inc shift) (cons digit digits))))\n   \
    \             (else\n                 (loop (quotient x 10) (inc shift) (cons\
    \ digit digits))))))))\n", "  (let loop ((x x) (shift shift) (digits '()))\n \
    \   (cond\n      [(< shift (length x)) (cons x (reverse digits))]\n      [(< shift\
    \ 0) (cons x (reverse digits))]\n      [else (loop (quotient x 10) (sub1 shift)\
    \ (cons (quotient x 10) digits))]\n    )))\n", "  (let loop ((x x) (shift shift)\
    \ (result '()))\n    (cond\n      [(zero? x) (reverse result)]\n      [(> shift\
    \ (length x)) (reverse result)]\n      [(< shift 0) (cons (car x) result)]\n \
    \     [else (loop (quotient x 10) (- shift 1) (cons (modulo x 10) result))])))\n",
  "  (let loop ((x x) (shift shift) (digits '()))\n    (if (zero? x)\n        (reverse\
    \ digits)\n        (loop (quotient x 10) (incf shift) (cons x digits)))))\n",
  "  (if (= shift 0)\n      '()\n      (cons (mod x (expt 10 shift)) (circular_shift\
    \ (/ x 10) shift))))\n", "  (let loop ((x x) (shift shift) (result '()))\n   \
    \ (if (= shift 0)\n        result\n        (loop (quotient x 10) (incf shift)\
    \ (cons (remainder x 10) result)))))\n", "  (let loop ((x x) (shift shift) (digits\
    \ '()))\n    (cond ((< shift (length x))\n           (reverse digits))\n     \
    \     ((< shift 0)\n           (reverse digits))\n          (else\n          \
    \ (loop (quotient x 10) (sub1 shift) (cons x digits))))))\n", "  (let loop ((x\
    \ x) (shift shift) (digits '()))\n    (if (= shift 0)\n        (reverse digits)\n\
    \        (loop (quotient x 10) (quotient shift 10)\n               (cons (quotient\
    \ x 10) digits)))))\n", "  (let loop ((x x) (shift shift) (digits '()))\n    (cond\
    \ ((< shift (length x))\n           (reverse digits))\n          ((< shift 0)\n\
    \           (reverse digits))\n          (else\n           (let ((digit (modulo\
    \ (modulo x 10) (expt 10 shift))))\n             (set! digits (cons digit digits))\n\
    \             (set! x (modulo x 10))\n             (loop (modulo x 10) (- (length\
    \ digits) shift)))))))\n", "  (let loop ((x x) (shift shift) (digits '()))\n \
    \   (if (= shift 0)\n        (reverse digits)\n        (loop (quotient x 10) (incf\
    \ shift) (cons x digits)))))\n", "  (let loop ((x x) (shift shift) (digits '()))\n\
    \    (if (= shift 0)\n        (reverse digits)\n        (loop (quotient x 10)\
    \ (sub1 shift) (cons x digits)))))\n", "  (let loop ((x x) (shift shift) (digits\
    \ '()))\n    (cond ((< shift (length x))\n           (reverse digits))\n     \
    \     ((< shift 0)\n           (reverse digits))\n          (else\n          \
    \ (let ((digit (modulo (modulo (modulo x 10) (* shift 10)) 10)))\n           \
    \  (loop (quotient x 10) (- (quotient shift 10) digit)\n                   (cons\
    \ digit digits))))))\n", "  (let loop ((x x) (shift shift) (digits '()))\n   \
    \ (if (< shift (length x))\n        (let ((digit (sub1 x)))\n          (set! x\
    \ (sub1 x))\n          (set! digits (cons digit digits))\n          (loop (sub1\
    \ x) shift digits))\n        digits)))\n", "  (let loop ((x x) (shift shift) (digits\
    \ '()))\n    (if (= shift 0)\n        (reverse digits)\n        (loop (quotient\
    \ x 10) (incf shift) (cons x digits)))))\n", "  (let loop ((x x) (shift shift))\n\
    \    (if (< shift (length x))\n        (let ((digits (subseq x 0 (- shift (length\
    \ x))))\n              (result (subseq x shift)))\n          (append result (loop\
    \ (reverse digits) (- shift (length x))))\n          (reverse result))\n     \
    \   x)))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
