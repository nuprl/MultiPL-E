name: HumanEval_21_rescale_to_unit
language: rkt
prompt: "#lang racket\n\n;; Given list of numbers (of at least two elements), apply\
  \ a linear transform to that list,\n;; such that the smallest number will become\
  \ 0 and the largest will become 1\n(define (rescale_to_unit numbers)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate rescale_to_unit))\n\
  \    (check-equal? (candidate (list 2.0 49.9)) (list 0.0 1.0))\n    (check-equal?\
  \ (candidate (list 100.0 49.9)) (list 1.0 0.0))\n    (check-equal? (candidate (list\
  \ 1.0 2.0 3.0 4.0 5.0)) (list 0.0 0.25 0.5 0.75 1.0))\n    (check-equal? (candidate\
  \ (list 2.0 1.0 5.0 3.0 4.0)) (list 0.25 0.0 1.0 0.5 0.75))\n    (check-equal? (candidate\
  \ (list 12.0 11.0 15.0 13.0 14.0)) (list 0.25 0.0 1.0 0.5 0.75))\n))\n\n(test-humaneval)"
completions: ["  (let ((min (min numbers))\n        (max (max numbers)))\n    (map\
    \ #(/ (- %1 min) max) numbers)))\n", "  (let ((min (min numbers)))\n    (map (lambda\
    \ (x)\n           (/ (- x min) max))\n         numbers)))\n", "  (let ((min (first\
    \ numbers))\n        (max (second numbers)))\n    (map #(/ (- %1 min) (- max min))\
    \ numbers)))\n", "  (let ((min (first numbers))\n        (max (second numbers)))\n\
    \    (if (or (< min 0) (< max 0))\n        (list min max)\n        (rescale_to_unit\
    \ (map #(/ (- %1 %2) (- max min)) numbers)))))\n", "  (let ((min (first numbers))\n\
    \        (max (second numbers)))\n    (map (lambda (x) (/ x max)) numbers)))\n",
  "  (let ((min (min numbers))\n        (max (max numbers)))\n    (map (lambda (x)\
    \ (/ x max)) numbers)))\n", "  (let ((min (min numbers))\n        (max (max numbers)))\n\
    \    (map (lambda (x) (/ (- x min) max)) numbers)))\n", "  (let ((min (first numbers))\n\
    \        (max (second numbers)))\n    (map (lambda (x) (/ (- x min) (- x max)))\n\
    \         numbers)))\n", "  (let ((min (min numbers)))\n    (let ((max (max numbers)))\n\
    \      (map #(/ % max) numbers))))\n", "  (let ((min (min numbers))\n        (max\
    \ (max numbers)))\n    (map (lambda (x) (/ (- x min) (- max min)))\n         numbers)))\n",
  "  (let ((min (min numbers))\n        (max (max numbers)))\n    (map (lambda (x)\
    \ (/ x max))\n         (filter (lambda (x) (< x min)) numbers))))\n", "  (let\
    \ ((min (min numbers))\n        (max (max numbers)))\n    (map (lambda (x) (/\
    \ x max)) numbers)))\n", "  (let ((min (min numbers))\n        (max (max numbers)))\n\
    \    (map (lambda (x)\n           (/ (- x min) (- max min)))\n         numbers)))\n",
  "  (let ((min (min numbers))\n        (max (max numbers)))\n    (map #(/ (- %1 min)\
    \ (- max min)) numbers)))\n", "  (let ((min (first numbers))\n        (max (second\
    \ numbers)))\n    (map #(/ % max) numbers)))\n", "  (let ((min (min numbers)))\n\
    \    (map #(/ (- %1 min) 1) numbers)))\n", "  (let ((min (first numbers))\n  \
    \      (max (second numbers)))\n    (map #(/ % max) numbers)))\n", "  (let ((min-number\
    \ (min numbers)))\n    (let ((max-number (max numbers)))\n      (map (lambda (number)\n\
    \             (/ (- number min-number) max-number min-number))\n           numbers))))\n",
  "  (let ((min (min numbers))\n        (max (max numbers)))\n    (if (= min max)\n\
    \        numbers\n        (cons (/ (- min max) 2) numbers))))\n", "  (let ((min\
    \ (min numbers)))\n    (if (null? numbers)\n        numbers\n        (let ((next\
    \ (min (map min numbers))))\n          (cons (/ (- next min) max) numbers)))))\n",
  "  (let ((min (min numbers))\n        (max (max numbers)))\n    (map #(/ (- %1 min)\
    \ (- max min)) numbers)))\n", "  (if (null? numbers)\n      '()\n      (cons (/\
    \ (car numbers) (min numbers))\n            (rescale_to_unit (cdr numbers)))))\n",
  "  (let ((min (min numbers)))\n    (let ((max (max numbers)))\n      (map (lambda\
    \ (number)\n             (/ (- number min) max))\n           numbers))))\n", " \
    \ (let ((min-number (min numbers))\n        (max-number (max numbers)))\n    (map\
    \ #(/ (- %1 min-number) max-number) numbers)))\n", "  (let ((min (first numbers))\n\
    \        (max (second numbers)))\n    (map #(/ (- %1 min) (- max min)) numbers)))\n",
  "  (let ((min-number (min numbers))\n        (max-number (max numbers)))\n    (map\
    \ #(/ (- %1 min-number) max-number) numbers)))\n", "  (if (null? numbers)\n  \
    \    '()\n      (cons (/ (car numbers) (car numbers)) \n            (rescale_to_unit\
    \ (cdr numbers)))))\n", "  (let ((min (first numbers))\n        (max (second numbers)))\n\
    \    (map #(/ (- %1 min) (- max min)) numbers)))\n", "  (let ((min (first numbers))\n\
    \        (max (second numbers)))\n    (map (lambda (x) (min (/ (- x max) max)))\
    \ numbers)))\n", "  (let ((min (min numbers))\n        (max (max numbers)))\n\
    \    (map (lambda (x)\n           (/ (- x min) max))\n         numbers)))\n",
  "  (let loop ((numbers numbers)\n             (min (first numbers))\n          \
    \   (max (second numbers)))\n    (if (null? numbers)\n        (list min max)\n\
    \        (loop (rest numbers)\n              (min (if (< min (first numbers))\
    \ min (first numbers))\n                  (if (> max (second numbers)) max (second\
    \ numbers)))))))\n", "  (let ((min (first numbers))\n        (max (second numbers)))\n\
    \    (map (lambda (n) (/ (- n min) max)) numbers)))\n", "  (let ((min (first numbers))\n\
    \        (max (second numbers)))\n    (map (lambda (x)\n           (/ (- x min)\
    \ (- max min)))\n         numbers)))\n", "  (if (null? numbers)\n      '()\n \
    \     (let ((smallest (car numbers))\n            (largest (caddr numbers)))\n\
    \        (cons (/ (- smallest largest) 2) (rescale_to_unit (cdr numbers))))))\n",
  "  (let ((min (min numbers))\n        (max (max numbers)))\n    (map (lambda (n)\
    \ (/ (- n min) max)) numbers)))\n", "  (if (empty? numbers)\n      '()\n     \
    \ (cons (/ (car numbers) (min numbers)) \n            (rescale_to_unit (rest numbers)))))\n",
  "  (let ((min-number (min numbers))\n        (max-number (max numbers)))\n    (map\
    \ (lambda (x) (/ (- x min-number) max-number)) numbers)))\n", "  (let loop ((numbers\
    \ (reverse numbers))\n             (min (first numbers))\n             (max (second\
    \ numbers)))\n    (if (null? numbers)\n        (list min max)\n        (loop (rest\
    \ numbers)\n              (min (min numbers))\n              (max (max numbers))))))\n",
  "  (let ((min (min numbers)))\n    (if (null? numbers)\n        numbers\n      \
    \  (let ((number (car numbers))\n              (max-number (car numbers)))\n \
    \         (cons (/ (- number min) max-number) \n                (rescale_to_unit\
    \ (cons (- number min) numbers)))))))\n", "  (let loop ((numbers numbers)\n  \
    \           (result '()))\n    (cond [(empty? numbers) result]\n          [(<\
    \ (first numbers) 0) (loop (rest numbers) (cons (first numbers) result))]\n  \
    \        [(> (first numbers) 1) (loop (rest numbers) (cons (first numbers) result))]\n\
    \          [else (loop (rest numbers) (cons (first numbers) result))])))\n", " \
    \ (let ((min (first numbers))\n        (max (second numbers)))\n    (map (lambda\
    \ (n) (/ n max)) numbers)))\n", "  (let ((min (min numbers))\n        (max (max\
    \ numbers)))\n    (map #(/ (- %1 min) (- max min)) numbers)))\n", "  (let ((min\
    \ (min numbers)))\n    (let ((max (max numbers)))\n      (map (lambda (x)\n  \
    \           (/ (- x min) (- max min)))\n           numbers))))\n", "  (let ((min\
    \ (first numbers))\n        (max (second numbers)))\n    (map (lambda (x) (/ x\
    \ max)) numbers)))\n", "  (let ((min (min numbers))\n        (max (max numbers)))\n\
    \    (map (lambda (n) (/ (- n min) max)) numbers)))\n", "  (let ((min (min numbers))\n\
    \        (max (max numbers)))\n    (map #(/ (- %1 min) (- max min)) numbers)))\n",
  "  (let ((min (first numbers))\n        (max (second numbers)))\n    (map (lambda\
    \ (n) (/ (- n min) max)) numbers)))\n", "  (let ((min (min numbers))\n       \
    \ (max (max numbers)))\n    (map #(/ (- %1 min) max) numbers)))\n", "  (let ((min\
    \ (min numbers)))\n    (map (lambda (n) (/ n min)) numbers)))\n", "  (let ((min\
    \ (min numbers))\n        (max (max numbers)))\n    (map #(/ (- %1 max) max) numbers)))\n",
  "  (let ((min (first numbers))\n        (max (second numbers)))\n    (if (= min\
    \ max)\n        (list 0 1)\n        (let ((diff (- max min)))\n          (cons\
    \ (/ (- diff min) diff)\n                (rescale_to_unit (subseq numbers 1 ))))))))\n",
  "  (let ((min (first numbers))\n        (max (second numbers)))\n    (if (< min\
    \ max)\n        (rescale numbers min max)\n        numbers)))\n", "  (let ((min-value\
    \ (first numbers))\n        (max-value (second numbers)))\n    (if (< min-value\
    \ 0)\n        (cons 0 numbers)\n        (cons 1 numbers))))\n", "  (let ((min\
    \ (min numbers))\n        (max (max numbers)))\n    (if (= min max)\n        numbers\n\
    \        (cons 0 (map (lambda (x) (/ x max)) numbers)))))\n", "  (let ((min (first\
    \ numbers))\n        (max (second numbers)))\n    (map (lambda (x) (/ (- x min)\
    \ max)) numbers)))\n", "  (let ((min (min numbers)))\n    (let ((max (max numbers)))\n\
    \      (map #(/ (- %1 %2) (- max min)) numbers))))\n", "  (let ((min (min numbers))\n\
    \        (max (max numbers)))\n    (map (lambda (n) (/ (- n min) max))\n     \
    \    numbers)))\n", "  (let ((min (min numbers))\n        (max (max numbers)))\n\
    \    (map (lambda (x) (/ x max)) numbers)))\n", "  (let ((min (min numbers)))\n\
    \    (map #(/ (- %1 min) 1) numbers)))\n", "  (let ((min (min numbers))\n    \
    \    (max (max numbers)))\n    (map #(/ % max) numbers)))\n", "  (let ((min (min\
    \ numbers)))\n    (map (lambda (n) (/ n min)) numbers)))\n", "  (let ((min (min\
    \ numbers))\n        (max (max numbers)))\n    (if (= min max)\n        numbers\n\
    \        (cons 0 (map #(/ (- %1 %2) max) numbers)))))\n", "  (let ((min (min numbers)))\n\
    \    (map #(/ % min) numbers)))\n", "  (let ((min (min numbers))\n        (max\
    \ (max numbers)))\n    (map (lambda (x) (/ x max)) numbers)))\n", "  (let loop\
    \ ((numbers (reverse numbers))\n             (min (first numbers))\n         \
    \    (max (second numbers)))\n    (if (null? numbers)\n        (list min max)\n\
    \        (loop (rest numbers)\n              (min (min numbers))\n           \
    \   (max (max numbers))))))\n", "  (let ((min (first numbers))\n        (max (second\
    \ numbers)))\n    (if (= min max)\n        numbers\n        (cons 0 (cons 1 (rescale_to_unit\
    \ (subseq numbers 1 max)))))\n  )\n)\n", "  (let ((min (first numbers))\n    \
    \    (max (second numbers)))\n    (if (< min max)\n        (cons 0 (rescale_to_unit\
    \ (rest numbers))))\n    (cons 1 (rescale_to_unit (rest numbers))))))\n", "  (let\
    \ ((min (min numbers))\n        (max (max numbers)))\n    (map #(/ % max) numbers)))\n",
  "  (let ((min (first numbers))\n        (max (second numbers)))\n    (map #(/ (-\
    \ %1 min) (- max min)) numbers)))\n", "  (let ((min-number (min numbers))\n  \
    \      (max-number (max numbers)))\n    (map #(/ % max-number) numbers)))\n",
  "  (if (null? numbers)\n      '()\n      (let ([smallest (car numbers)\n       \
    \      largest (caddr numbers)])\n        (cons (/ (- smallest largest) largest)\
    \ (rest (cdr numbers))))))\n", "  (let ((min (first numbers))\n        (max (second\
    \ numbers)))\n    (map #(/ % max) numbers)))\n", "  (let ((min (first numbers))\n\
    \        (max (second numbers)))\n    (map (lambda (x)\n           (/ (- x min)\
    \ (- max min)))\n         numbers)))\n", "  (let ((min (min numbers))\n      \
    \  (max (max numbers)))\n    (map (lambda (x) (/ x max)) numbers)))\n", "  (if\
    \ (null? numbers)\n      '()\n      (let ((smallest (car numbers))\n         \
    \   (largest (caddr numbers)))\n        (cons (/ (- smallest largest) 2) (rescale_to_unit\
    \ (cdr numbers))))))\n", "  (let ((min (first numbers))\n        (max (second\
    \ numbers)))\n    (map (lambda (x) (/ (- x min) (- x max))) numbers)))\n", " \
    \ (let ((min (min numbers))\n        (max (max numbers)))\n    (map #(/ % max)\
    \ numbers)))\n", "  (let ((min (min numbers)))\n    (map #(/ (- %1 min) 1) numbers)))\n",
  "  (let ((min-number (min numbers))\n        (max-number (max numbers)))\n    (map\
    \ (lambda (x) (/ (- x min-number) max-number x))\n         numbers)))\n", "  (let\
    \ ((min (min numbers)))\n    (map (lambda (x) (/ (- x min) max)) numbers)))\n",
  "  (let ((min (min numbers))\n        (max (max numbers)))\n    (map (lambda (x)\
    \ (/ (- x min) max)) numbers)))\n", "  (let ((min (first numbers))\n        (max\
    \ (second numbers)))\n    (map (lambda (n) (/ (- n min) max)) numbers)))\n", " \
    \ (let ((min (min numbers)))\n    (map (lambda (n) (/ n min)) numbers)))\n", " \
    \ (let ((min (min numbers))\n        (max (max numbers)))\n    (map #(/ (- %1\
    \ min) max) numbers)))\n", "  (let ((min (min numbers))\n        (max (max numbers)))\n\
    \    (map (lambda (x) (/ (- x min) max)) numbers)))\n", "  (let ((min (first numbers))\n\
    \        (max (second numbers)))\n    (map (lambda (n) (/ n max)) numbers)))\n",
  "  (let ((min (min numbers))\n        (max (max numbers)))\n    (map (lambda (n)\n\
    \           (/ (- n min) max))\n         numbers)))\n", "  (let ((min (min numbers)))\n\
    \    (let ((max (max numbers)))\n      (map (lambda (number)\n             (/\
    \ (- number min) (- max min)))\n           numbers))))\n", "  (let ((min-number\
    \ (min numbers))\n        (max-number (max numbers)))\n    (map #(/ % max-number)\
    \ numbers)))\n", "  (let ((min (min numbers))\n        (max (max numbers)))\n\
    \    (if (= min max)\n        numbers\n        (cons (/ (- min max) 2) numbers))))\n",
  "  (let ((min (min numbers)))\n    (map #(/ % min) numbers)))\n", "  (let ((min\
    \ (min numbers))\n        (max (max numbers)))\n    (map (lambda (n)\n       \
    \    (/ (- n min) (- max min))\n           (- max min))\n         numbers)))\n",
  "  (if (null? numbers)\n      '()\n      (let ((smallest (car numbers))\n      \
    \      (largest (car numbers)))\n        (cons (/ (- smallest largest) 2) (rescale_to_unit\
    \ (cdr numbers))))))\n", "  (if (null? numbers)\n      '()\n      (cons (/ (car\
    \ numbers) (car numbers)) \n            (rescale_to_unit (cdr numbers)))))\n",
  "  (if (null? numbers)\n      '()\n      (let ((smallest (car numbers))\n      \
    \      (largest (car numbers)))\n        (cons (/ (- smallest largest) largest)\
    \ \n               (rescale_to_unit (cons (- smallest largest) numbers))))))\n",
  "  (let ((min (min numbers)))\n    (let ((max (max numbers)))\n      (map (lambda\
    \ (number)\n             (/ (- number min) max))\n           numbers))))\n", " \
    \ (let ((min (min numbers))\n        (max (max numbers)))\n    (map #(/ (- %1\
    \ max) (- min max)) numbers)))\n", "  (let ((min (first numbers))\n        (max\
    \ (second numbers)))\n    (map #(/ % 1) (map #(* % max) numbers))))\n", "  (let\
    \ ((min-number (min numbers))\n        (max-number (max numbers)))\n    (map #(/\
    \ (- %1 min-number) max-number) numbers)))\n", "  (if (empty? numbers)\n     \
    \ '()\n      (let ((smallest (car numbers))\n            (largest (car numbers)))\n\
    \        (cons (/ (- smallest largest) 2) (rescale_to_unit (rest numbers))))))\n",
  "  (let ((min (first numbers))\n        (max (second numbers)))\n    (map (lambda\
    \ (n)\n           (/ (- n min) max))\n         numbers)))\n", "  (let loop ((numbers\
    \ (reverse numbers))\n             (min (first numbers))\n             (max (second\
    \ numbers)))\n    (if (null? numbers)\n        (list min max)\n        (loop (rest\
    \ numbers)\n              (min (min numbers))\n              (max (max numbers))))))\n",
  "  (let ((min (min numbers))\n        (max (max numbers)))\n    (map #(/ % max)\
    \ numbers)))\n", "  (if (null? numbers)\n      '()\n      (let ((smallest (car\
    \ numbers))\n            (largest (caddr numbers)))\n        (cons (/ (- smallest\
    \ largest) 2) (rescale_to_unit (cdr numbers))))))\n", "  (let ((min (first numbers))\n\
    \        (max (second numbers)))\n    (if (< min max)\n        (cons 0 (rescale_to_unit\
    \ (rest numbers))) ; rescale all numbers to 0\n        (cons 1 (rescale_to_unit\
    \ (cons (first numbers) numbers))))))\n", "  (let ((min (min numbers))\n     \
    \   (max (max numbers)))\n    (map (lambda (n) (/ n max)) numbers)))\n", "  (let\
    \ ((min-number (min numbers)))\n    (let ((max-number (max numbers)))\n      (map\
    \ (lambda (x)\n             (/ (- x min-number) max-number x))\n           numbers))))\n",
  "  (let ((min (min numbers)))\n    (map #(/ % min) numbers)))\n", "  (let ((min\
    \ (first numbers))\n        (max (second numbers)))\n    (if (< min max)\n   \
    \     (let ((scaled (/ (- min max) 2 )))\n          (cons scaled numbers))\n \
    \       numbers)))\n", "  (let ((min (min numbers)))\n    (map #(/ (- %1 min)\
    \ 1) numbers)))\n", "  (let ((min (min numbers))\n        (max (max numbers)))\n\
    \    (map (lambda (x)\n           (/ (- x min) max))\n         numbers)))\n",
  "  (let ((min (min numbers))\n        (max (max numbers)))\n    (map (lambda (x)\
    \ (/ (- x min) max)) numbers)))\n", "  (let ((min (min numbers))\n        (max\
    \ (max numbers)))\n    (map #(/ (- %1 min) max) numbers)))\n", "  (let ((min (first\
    \ numbers))\n        (max (second numbers)))\n    (if (< min max)\n        (cons\
    \ 0 (rescale_to_unit (rest numbers))) ; rescale all numbers to 0\n        (cons\
    \ 1 (rescale_to_unit (rest numbers))) ; rescale all numbers to 1\n        numbers)))\n",
  "  (let ((min (first numbers))\n        (max (second numbers)))\n    (map (lambda\
    \ (n) (/ n max)) numbers)))\n", "  (let ((min (first numbers))\n        (max (second\
    \ numbers)))\n    (map #(/ (- %1 min) (- max min)) numbers)))\n", "  (let ((min\
    \ (min numbers)))\n    (map (lambda (x) (/ x min)) numbers)))\n", "  (let ((min\
    \ (min numbers)))\n    (map (lambda (n)\n           (/ (- n min) 1.0))\n     \
    \    numbers)))\n", "  (let ((min (first numbers))\n        (max (second numbers)))\n\
    \    (map (lambda (n) (/ (- n min) (- max min))) numbers)))\n", "  (let ((min\
    \ (first numbers))\n        (max (second numbers)))\n    (map (lambda (x) (/ (-\
    \ x min) (- x max)))\n         numbers)))\n", "  (let ((min (first numbers))\n\
    \        (max (second numbers)))\n    (map #(/ % max) numbers)))\n", "  (let ((min\
    \ (first numbers))\n        (max (second numbers)))\n    (map (lambda (n) (/ n\
    \ max)) numbers)))\n", "  (let ((min (min numbers))\n        (max (max numbers)))\n\
    \    (if (= min max)\n        numbers\n        (map (lambda (x) (/ (- x min) max))\
    \ numbers))))\n", "  (let ((min (min numbers))\n        (max (max numbers)))\n\
    \    (map #(/ (- %1 min) (- max min)) numbers)))\n", "  (let ((min (min numbers))\n\
    \        (max (max numbers)))\n    (map (lambda (x)\n           (/ (- x min) max))\n\
    \         numbers)))\n", "  (if (null? numbers)\n      '()\n      (cons (/ (car\
    \ numbers) (car (cdr numbers))) \n            (rescale_to_unit (cdr numbers)))))\n",
  "  (let loop ((numbers numbers)\n             (min (first numbers))\n          \
    \   (max (second numbers)))\n    (if (null? numbers)\n        (list min max)\n\
    \        (loop (rest numbers)\n              (min (min numbers))\n           \
    \   (max (max numbers))))))\n", "  (let ((min (min numbers)))\n    (map #(/ (-\
    \ %1 min) 1) numbers)))\n", "  (let ((min (min numbers))\n        (max (max numbers)))\n\
    \    (map #(/ % max) numbers)))\n", "  (let ((min-number (min numbers)))\n   \
    \ (let ((max-number (max numbers)))\n      (map (lambda (x)\n             (/ (-\
    \ x min-number) max-number))\n           numbers))))\n", "  (let ((min (min numbers))\n\
    \        (max (max numbers)))\n    (map #(/ (- %1 min) (- max min)) numbers)))\n",
  "  (let ((min (first numbers))\n        (max (second numbers)))\n    (if (< min\
    \ max)\n        (cons min (rescale_to_unit (rest numbers))) ; min and max are\
    \ both 0\n        (cons 0 (rescale_to_unit (rest numbers))))))\n", "  (let ((min\
    \ (first numbers))\n        (max (second numbers)))\n    (map #(/ (- %1 min) (-\
    \ max min)) numbers)))\n", "  (let ((min (min numbers))\n        (max (max numbers)))\n\
    \    (map (lambda (x) (/ x max))\n         (map (lambda (x) (* x max)) numbers))))\n",
  "  (let ((min (min numbers))\n        (max (max numbers)))\n    (map #(/ (- %1 max)\
    \ max) numbers)))\n", "  (let ((min (min numbers))\n        (max (max numbers)))\n\
    \    (map (lambda (n) (/ (- n min) max)) numbers)))\n", "  (let ((min (first numbers))\n\
    \        (max (second numbers)))\n    (if (< min max)\n        (cons 0 (rescale_to_unit\
    \ (rest numbers))))\n    (cons 1 (rescale_to_unit (rest numbers))))))\n", "  (let\
    \ ((min (first numbers))\n        (max (second numbers)))\n    (map #(/ (- %1\
    \ min) (- max min)) numbers)))\n", "  (let ((min (min numbers))\n        (max\
    \ (max numbers)))\n    (map #(/ % max) numbers)))\n", "  (let ((min (first numbers))\n\
    \        (max (second numbers)))\n    (map (lambda (x) (/ (- x min) max)) numbers)))\n",
  "  (let ((min (first numbers))\n        (max (second numbers)))\n    (map (lambda\
    \ (n) (/ (- n min) max)) numbers)))\n", "  (let ((min (min numbers))\n       \
    \ (max (max numbers)))\n    (map #(/ (- %1 min) (- max min)) numbers)))\n", " \
    \ (let ((min (min numbers)))\n    (let ((max (max numbers)))\n      (map (lambda\
    \ (x) (/ x max)) numbers))))\n", "  (let ((min (min numbers))\n        (max (max\
    \ numbers)))\n    (map #(/ (- %1 max) (- min max)) numbers)))\n", "  (let ((min-number\
    \ (min numbers)))\n    (let ((max-number (max numbers)))\n      (map (lambda (number)\n\
    \             (/ (- number min-number) max-number min-number))\n           numbers))))\n",
  "  (let ((min (first numbers))\n        (max (second numbers)))\n    (map #(/ (-\
    \ %1 min) (- %2 max)) numbers)))\n", "  (let ((min (first numbers))\n        (max\
    \ (second numbers)))\n    (if (< min max)\n        (rescale numbers min max)\n\
    \        (rescale numbers 0 1))))\n", "  (let ((min-number (min numbers)))\n \
    \   (let ((max-number (max numbers)))\n      (map (lambda (n) (/ (- n min-number)\
    \ max-number)) numbers))))\n", "  (let ((min (first numbers))\n        (max (second\
    \ numbers)))\n    (map (lambda (x) (/ x max)) numbers)))\n", "  (if (null? numbers)\n\
    \      '()\n      (let ((smallest (car numbers))\n            (largest (caddr\
    \ numbers)))\n        (cons (/ (- smallest largest) 2) (rescale_to_unit (cdr numbers))))))\n",
  "  (let ((min (min numbers))\n        (max (max numbers)))\n    (if (= min max)\n\
    \        numbers\n        (map #(/ (- %1 max) max) numbers))))\n", "  (let ((min\
    \ (min numbers))\n        (max (max numbers)))\n    (map (lambda (x) (/ x max))\n\
    \         (map - numbers))))\n", "  (let loop ((numbers numbers)\n           \
    \  (result '()))\n    (if (null? numbers)\n        result\n        (loop (rest\
    \ numbers)\n              (cons (min numbers) result)))))\n", "  (let ((min (min\
    \ numbers))\n        (max (max numbers)))\n    (map #(/ (- %1 min) (- max min))\
    \ numbers)))\n", "  (let ((min (first numbers))\n        (max (second numbers)))\n\
    \    (if (< (min max) 0)\n        (cons (- min) numbers)\n        numbers)))\n",
  "  (let ((min (min numbers)))\n    (map (lambda (x) (/ x min)) numbers)))\n", " \
    \ (let ((min (min numbers)))\n    (map (lambda (number)\n           (/ (- number\
    \ min) 1.0))\n         numbers)))\n", "  (let ((min (first numbers))\n       \
    \ (max (second numbers)))\n    (if (< min max)\n        (cons min (rescale_to_unit\
    \ (rest numbers))) (cons max (rescale_to_unit numbers)))))\n", "  (let ((min (min\
    \ numbers)))\n    (map #(/ (- %1 min) 1) numbers)))\n", "  (if (null? numbers)\n\
    \      '()\n      (cons (/ (car numbers) (car numbers)) \n            (rescale_to_unit\
    \ (cdr numbers)))))\n", "  (let ((min (min numbers))\n        (max (max numbers)))\n\
    \    (map (lambda (x) (/ x max)) numbers)))\n", "  (let ((min (min numbers))\n\
    \        (max (max numbers)))\n    (if (= min max)\n        numbers\n        (cons\
    \ 0 (map (lambda (x) (/ x max)) numbers)))))\n", "  (let ((min (first numbers))\n\
    \        (max (second numbers)))\n    (map #(/ (- %1 min) (- max min)) numbers)))\n",
  "  (if (null? numbers)\n      '()\n      (let ((smallest (car numbers))\n      \
    \      (largest (car numbers)))\n        (cons (/ (- smallest largest) 2) (rescale_to_unit\
    \ (cdr numbers))))))\n", "  (let ((min (min numbers))\n        (max (max numbers)))\n\
    \    (map (lambda (n)\n           (/ (- n min) max))\n         numbers)))\n",
  "  (if (null? numbers)\n      '()\n      (let ((smallest (car numbers))\n      \
    \      (largest (caddr numbers)))\n        (cons (/ (- smallest largest) 2) (rescale_to_unit\
    \ (cdr numbers))))))\n", "  (let ((min (min numbers))\n        (max (max numbers)))\n\
    \    (map (lambda (x) (/ x max)) numbers)))\n", "  (let loop ((numbers (reverse\
    \ numbers))\n             (min (first numbers))\n             (max (second numbers)))\n\
    \    (if (null? numbers)\n        (list min max)\n        (loop (rest numbers)\n\
    \              (min (min numbers))\n              (max (max numbers))))))\n",
  "  (let ((min-number (min numbers))\n        (max-number (max numbers)))\n    (map\
    \ (lambda (x) (/ (- x min-number) max-number x))\n         numbers)))\n", "  (let\
    \ loop ((numbers numbers)\n             (min (first numbers))\n             (max\
    \ (second numbers)))\n    (if (null? numbers)\n        (list min max)\n      \
    \  (loop (rest numbers)\n              (min (min numbers))\n              (max\
    \ (max numbers))))))\n", "  (let ((min (first numbers))\n        (max (second\
    \ numbers)))\n    (map #(/ (- %1 min) (- max min)) numbers)))\n", "  (let ((min\
    \ (min numbers))\n        (max (max numbers)))\n    (map #(/ % max) numbers)))\n",
  "  (let ((min (min numbers))\n        (max (max numbers)))\n    (map (lambda (x)\
    \ (/ (- x min) max)) numbers)))\n", "  (let ((min-number (min numbers))\n    \
    \    (max-number (max numbers)))\n    (if (= min-number max-number)\n        numbers\n\
    \        (cons 0 (map #(/ (- %1 %2) max-number) numbers)))))\n", "  (let ((min\
    \ (min numbers)))\n    (let ((max (max numbers)))\n      (map (lambda (x) (/ (-\
    \ x min) max)) numbers))))\n", "  (let ((min (first numbers))\n        (max (second\
    \ numbers)))\n    (map #(/ % max) numbers)))\n", "  (let ((min (min numbers))\n\
    \        (max (max numbers)))\n    (map #(/ (- %1 min) (- max min)) numbers)))\n",
  "  (let ((min (min numbers)))\n    (map (lambda (n)\n           (/ (- n min) max))\n\
    \         numbers)))\n", "  (let ((min (min numbers))\n        (max (max numbers)))\n\
    \    (map (lambda (x)\n           (/ (- x min) max))\n         numbers)))\n",
  "  (let ((min (min numbers)))\n    (let ((max (max numbers)))\n      (map (lambda\
    \ (number)\n             (/ (- number min) max))\n           numbers))))\n", " \
    \ (let ((min (min numbers))\n        (max (max numbers)))\n    (map #(/ (- %1\
    \ min) max) numbers)))\n", "  (let ((min (min numbers)))\n    (map #(/ (- %1 min)\
    \ 1) numbers)))\n", "  (let ((min-value (first numbers))\n        (max-value (second\
    \ numbers)))\n    (if (< min-value 0)\n        (/ max-value min-value)\n     \
    \   (/ max-value 1))))\n", "  (let ((min (min numbers)))\n    (map (lambda (x)\
    \ (/ x min)) numbers)))\n", "  (let ((min (first numbers))\n        (max (second\
    \ numbers)))\n    (if (< (min max) 0)\n        (cons 0 (rescale_to_unit (rest\
    \ numbers))) ; rescale all numbers to 0-1\n        (cons 1 (rescale_to_unit (rest\
    \ numbers))))))\n", "  (let ((min (min numbers)))\n    (map #(/ % min) numbers)))\n",
  "  (let ((min (min numbers)))\n    (let ((max (max numbers)))\n      (map #(/ (-\
    \ %1 min) max) numbers))))\n", "  (let ((min (min numbers))\n        (max (max\
    \ numbers)))\n    (map #(/ (- %1 max) max) numbers)))\n", "  (let ((min (min numbers))\n\
    \        (max (max numbers)))\n    (map #(/ (- %1 min) (- max min)) numbers)))\n",
  "  (let ((min (min numbers))\n        (max (max numbers)))\n    (map (lambda (x)\
    \ (/ x max)) numbers)))\n", "  (let ((min (min numbers))\n        (max (max numbers)))\n\
    \    (if (= min max)\n        numbers\n        (cons (/ (- min max) max) numbers))))\n",
  "  (let ((min (first numbers))\n        (max (second numbers)))\n    (map (lambda\
    \ (x) (/ (- x min) max)) numbers)))\n", "  (let ((min (min numbers))\n       \
    \ (max (max numbers)))\n    (map #(/ (- %1 min) max) numbers)))\n", "  (let ((min\
    \ (first numbers))\n        (max (second numbers)))\n    (if (or (< min 0) (>\
    \ max 1))\n        (error \"Arguments must be non-negative and non-positive\"\
    )\n        (let ((scaled (/ (- max min) 2 )))\n          (cons (* scaled (first\
    \ numbers)) (cons (* scaled (second numbers)) numbers))))))\n", "  (let ((min\
    \ (first numbers))\n        (max (second numbers)))\n    (map #(/ (- %1 min) (-\
    \ max min)) numbers)))\n", "  (if (null? numbers)\n      '()\n      (cons (/ (car\
    \ numbers) (min numbers))\n            (rescale_to_unit (cdr numbers)))))\n",
  "  (let ((min (min numbers)))\n    (map (lambda (n) (/ (- n min) max)) numbers)))\n",
  "  (let ((min (min numbers))\n        (max (max numbers)))\n    (map #(/ (- %1 min)\
    \ (- max min)) numbers)))\n", "  (let ((min (first numbers))\n        (max (second\
    \ numbers)))\n    (if (< min max)\n        (let ((diff (- max min)))\n       \
    \   (cons 0 (cons diff numbers))))\n    numbers))\n", "  (let ((min-number (min\
    \ numbers)))\n    (let ((max-number (max numbers)))\n      (map (lambda (n)\n\
    \             (/ (- n min-number) max-number min-number))\n           numbers))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
