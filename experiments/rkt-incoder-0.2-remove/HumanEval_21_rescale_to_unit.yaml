name: HumanEval_21_rescale_to_unit
language: rkt
prompt: "#lang racket\n\n;; Given list of numbers (of at least two elements), apply\
  \ a linear transform to that list,\n;; such that the smallest number will become\
  \ 0 and the largest will become 1\n(define (rescale_to_unit numbers)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate rescale_to_unit))\n\
  \    (check-equal? (candidate (list 2.0 49.9)) (list 0.0 1.0))\n    (check-equal?\
  \ (candidate (list 100.0 49.9)) (list 1.0 0.0))\n    (check-equal? (candidate (list\
  \ 1.0 2.0 3.0 4.0 5.0)) (list 0.0 0.25 0.5 0.75 1.0))\n    (check-equal? (candidate\
  \ (list 2.0 1.0 5.0 3.0 4.0)) (list 0.25 0.0 1.0 0.5 0.75))\n    (check-equal? (candidate\
  \ (list 12.0 11.0 15.0 13.0 14.0)) (list 0.25 0.0 1.0 0.5 0.75))\n))\n\n(test-humaneval)"
completions: ["  (let ((min (min numbers))\n        (max (max numbers)))\n    (map\
    \ #(/ (- %1 min) max) numbers)))\n", "  (let ((min (min numbers)))\n    (map (lambda\
    \ (x)\n           (/ (- x min) max))\n         numbers)))\n", "  (let ((min (first\
    \ numbers))\n        (max (second numbers)))\n    (map #(/ (- %1 min) (- max min))\
    \ numbers)))\n", "  (let ((min (first numbers))\n        (max (second numbers)))\n\
    \    (if (or (< min 0) (< max 0))\n        (list min max)\n        (rescale_to_unit\
    \ (map #(/ (- %1 %2) (- max min)) numbers)))))\n", "  (let ((min (first numbers))\n\
    \        (max (second numbers)))\n    (map (lambda (x) (/ x max)) numbers)))\n",
  "  (let ((min (min numbers))\n        (max (max numbers)))\n    (map (lambda (x)\
    \ (/ x max)) numbers)))\n", "  (let ((min (min numbers))\n        (max (max numbers)))\n\
    \    (map (lambda (x) (/ (- x min) max)) numbers)))\n", "  (let ((min (first numbers))\n\
    \        (max (second numbers)))\n    (map (lambda (x) (/ (- x min) (- x max)))\n\
    \         numbers)))\n", "  (let ((min (min numbers)))\n    (let ((max (max numbers)))\n\
    \      (map #(/ % max) numbers))))\n", "  (let ((min (min numbers))\n        (max\
    \ (max numbers)))\n    (map (lambda (x) (/ (- x min) (- max min)))\n         numbers)))\n",
  "  (let ((min (min numbers))\n        (max (max numbers)))\n    (map (lambda (x)\
    \ (/ x max))\n         (filter (lambda (x) (< x min)) numbers))))\n", "  (let\
    \ ((min (min numbers))\n        (max (max numbers)))\n    (map (lambda (x) (/\
    \ x max)) numbers)))\n", "  (let ((min (min numbers))\n        (max (max numbers)))\n\
    \    (map (lambda (x)\n           (/ (- x min) (- max min)))\n         numbers)))\n",
  "  (let ((min (min numbers))\n        (max (max numbers)))\n    (map #(/ (- %1 min)\
    \ (- max min)) numbers)))\n", "  (let ((min (first numbers))\n        (max (second\
    \ numbers)))\n    (map #(/ % max) numbers)))\n", "  (let ((min (min numbers)))\n\
    \    (map #(/ (- %1 min) 1) numbers)))\n", "  (let ((min (first numbers))\n  \
    \      (max (second numbers)))\n    (map #(/ % max) numbers)))\n", "  (let ((min-number\
    \ (min numbers)))\n    (let ((max-number (max numbers)))\n      (map (lambda (number)\n\
    \             (/ (- number min-number) max-number min-number))\n           numbers))))\n",
  "  (let ((min (min numbers))\n        (max (max numbers)))\n    (if (= min max)\n\
    \        numbers\n        (cons (/ (- min max) 2) numbers))))\n", "  (let ((min\
    \ (min numbers)))\n    (if (null? numbers)\n        numbers\n        (let ((next\
    \ (min (map min numbers))))\n          (cons (/ (- next min) max) numbers)))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
