name: HumanEval_27_flip_case
language: rkt
prompt: "#lang racket\n\n;; For a given string, flip lowercase characters to uppercase\
  \ and uppercase to lowercase.\n(define (flip_case string)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate flip_case))\n\
  \    (check-equal? (candidate \"\") \"\")\n    (check-equal? (candidate \"Hello!\"\
  ) \"hELLO!\")\n    (check-equal? (candidate \"These violent delights have violent\
  \ ends\") \"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\")\n))\n\n(test-humaneval)"
completions: ["  (let loop ((string string) (result '()))\n    (if (string-empty?\
    \ string)\n        result\n        (loop (substring string 0 1) (append result\
    \ (list (char->string (char->integer char->char (char->integer char->char (char->integer\
    \ char->char (char->integer char->char (char->integer char->char (char->integer\
    \ char->char (char->integer char->char (char->integer char->char (char->integer\
    \ char->char (char->integer char->char (char->integer char->char (char->integer\
    \ char->char (char->integer char->char (char->integer char->char (char->integer\
    \ char->char (char->integer char->char (char->integer char->char (char->integer\
    \ char->char (char->integer char->char (char->integer char->char (char->integer\
    \ char->char (char->integer char->char (char->integer char->char (char->integer\
    \ char->char (char->integer char->char (char->integer char->char (char->integer\
    \ char->char (char->integer char->char (char->integer char->char (char->integer\
    \ char->char (char->integer char->char (char->integer char->char (char->integer\
    \ char->char (char->integer char->char (char->integer char->char (char->integer\
    \ char->char (char->integer char->char (char->integer char->char (char->integer\
    \ char->char (char->integer char->char (char->integer char->char (char->integer\
    \ char->char (char->integer char->char (char->integer char->char (char->integer\
    \ char->char (char->integer char->char (char->integer char->char (char->integer\
    \ char->char (char->integer char->char (char->integer char->char (char->integer\
    \ char->char (char->integer char->char (char->integer char->char (char->integer\
    \ char->char (char->integer char->char (char->integer char->char (char->integer\
    \ char->char (char->integer char->char (char->integer char->char (char->integer\
    \ char->char (char->integer char->char (char->integer char->char (char->integer\
    \ char->char (char->integer char->char (char->integer char->char (char->integer\
    \ char->char (char->integer char->char (char->integer char->char", "  (cond\n\
    \    [(empty? string) \"\"]\n    [(equal? (first string) (string-ref string 0))\
    \ (string-append (second string) (first string))]\n    [else (string-append (flip_case\
    \ (substring string 0 1)) (substring string 1 0))]))\n", "  (define (helper string\
    \ result)\n    (if (string-empty? string)\n        result\n        (helper (substring\
    \ string 0 1) (append result (substring string 1 string)))\n      )\n  )\n  (helper\
    \ string '())\n)\n", "  (cond\n    [(string-empty? string) string]\n    [(equal?\
    \ (char-code (car string)) #\\A) (upper-case (substring string 1))]\n    [(equal?\
    \ (char-code (car string)) #\\a) (lower-case (substring string 1))]\n    [(equal?\
    \ (char-code (car string)) #\\z) (upper-case (substring string 1))]\n    [(equal?\
    \ (char-code (car string)) #\\Z) (lower-case (substring string 1))]\n    [else\
    \ (string-append (substring string 1)\n                       (flip_case (substring\
    \ string 2)))]))\n", "  (let ((lower (string->list string)))\n    (map (lambda\
    \ (char)\n           (if (char->char? char)\n               (char->string (char->char\
    \ (char->string char)))\n               (char->string (char->char (char->string\
    \ char))))\n           lower)\n         string)))\n", "  (cond\n    [(empty? string)\
    \ \"\"]\n    [(equal? (first string) (string-ref string 0)) (string-append (string-ref\
    \ string 0) (string-ref string 1))]\n    [else (string-append (string-ref string\
    \ 0) (string-ref string 1))]))\n", "  (let ((result '()))\n    (for ((i (length\
    \ string))) (cond ((char=? string #\\A) (set! result (append result #\\A))\n \
    \                                              (char=? string #\\z) (set! result\
    \ (append result #\\z))\n                                               ((char=?\
    \ string #\\A) (set! result (append result #\\a)))\n                         \
    \                      ((char=? string #\\z) (set! result (append result #\\z)))\n\
    \                                               (else (set! result (append result\
    \ string)))))\n    result))\n", "  (let loop ((string string)\n             (result\
    \ '()))\n    (if (empty? string)\n        result\n        (loop (rest string)\n\
    \              (cons (char->string (char->integer char->char (first string)))\
    \ result)))))\n", "  (cond\n    [(empty? string) string]\n    [(equal? (first\
    \ string) (string-ref string 0)) (string-append (string-ref string 0) (string-ref\
    \ string 1))]\n    [else (string-append (string-ref string 0) (string-ref string\
    \ 1))]))\n", "  (cond\n    [(empty? string) \"\"]\n    [(equal? (first string)\
    \ (string-ref string 0)) (string-append \"-\" (second string))]\n    [else (string-append\
    \ \"-\" (first string) (flip_case (rest string)))]))\n", "  (define (helper string\
    \ result)\n    (if (string-empty? string)\n        result\n        (helper (substring\
    \ string 0 1)\n                (cond [(char=? (char-code string) 'a)\n       \
    \                'A]\n                          [(char=? (char-code string) 'b)\n\
    \                       'B]\n                          [(char=? (char-code string)\
    \ 'c)\n                       'C]\n                          [(char=? (char-code\
    \ string) 'd)\n                       'D]\n                          [(char=?\
    \ (char-code string) 'e)\n                       'E]\n                       \
    \   [(char=? (char-code string) 'f)\n                       'F]\n            \
    \              [(char=? (char-code string) 'g)\n                       'G]\n \
    \                         [(char=? (char-code string) 'h)\n                  \
    \     'H]\n                          [(char=? (char-code string) 'i)\n       \
    \                'I]\n                          [(char=? (char-code string) 'j)\n\
    \                       'J]\n                          [(char=? (char-code string)\
    \ 'k)\n                       'K]\n                          [(char=? (char-code\
    \ string) 'l)\n                       'L]\n                          [(char=?\
    \ (char-code string) 'm)\n                       'M]\n                       \
    \   [(char=? (char-code string) 'n)\n                       'N]\n            \
    \              [(char=? (char-code string) 'o)\n                       'O]\n \
    \                         [(char=? (char-code string) 'p)\n                  \
    \     'P]\n                          [(char=? (char-code string) 'q)\n       \
    \                'Q]\n                          [(char=? (char-code string) 'r)\n\
    \                       'R]\n                          [(char=? (char-code string)\
    \ 's)\n                       'S]\n                          [(char=? (char-code\
    \ string) 't) 'T]\n                          [(char=? (char-code string) 'u)\n\
    \                       'U]\n                          [(char=? (char-code string)\
    \ 'v)\n                       'V]\n                          [(char=? (char-code\
    \ string) 'w)\n                       'W]\n                          [(char=?\
    \ (char-code string) 'x)\n                       'X]\n                       \
    \   [(char=? (char-code string) 'y)\n                       'Y]\n            \
    \              [(char=? (char-code string) 'z)\n                       'Z]\n \
    \                         [else string])))\n  (helper string '()))\n", "  (define\
    \ (helper string result)\n    (cond [(empty? string) result]\n          [else\n\
    \           (helper (cdr string) (append result (list (char->string (char->integer\
    \ (car string)))))]\n          ))\n  (helper string '()))\n", "  (let ((chars\
    \ (string->list string)))\n    (map (lambda (c)\n           (if (char=? c #\\\
    a)\n               (char-upper-case c)\n               (char-lower-case c)))\n\
    \         chars)))\n", "  (cond\n    [(empty? string) \"\"]\n    [(equal? (first\
    \ string) (string-ref string 0)) (string-append (make-string (string-length string)\
    \ (char->string #\\A)) (string-append (make-string (string-length string) (char->string\
    \ #\\a)) (string-append (make-string (string-length string) (char->string #\\\
    z)) (string-append (make-string (string-length string) (char->string #\\Z))))]\n\
    \    [else (string-append (make-string (string-length string) (char->string #\\\
    A)) (string-append (make-string (string-length string) (char->string #\\a)) (string-append\
    \ (make-string (string-length string) (char->string #\\z)) (string-append (make-string\
    \ (string-length string) (char->string #\\Z))))]\n  ))\n", "  (define (helper\
    \ string result)\n    (if (string-empty? string)\n        result\n        (helper\
    \ (substring string 0 1)\n                (cond [(char=? (char-code string) 97)\
    \ (concat result (char->string (char->integer 97)))]\n                      [(char=?\
    \ (char-code string) 65) (concat result (char->string (char->integer 65)))]\n\
    \                      [else (concat result (char->string (char->integer 97)))])))\n\
    \  (helper string \"\"))\n</code>\n<|/ a tags=racket,scheme |>\n<| c |>\nThanks\
    \ for your answer. Unfortunately I cannot use any libraries. I only have to use\
    \ basic functions. I edited my question to make it more clear.\n<|/ c |>\n<| c\
    \ |>\nI edited my answer to include a solution that uses basic functions. I hope\
    \ it helps.\n<|/ c |>\n<| c |>\nThanks for your answer. Unfortunately I cannot\
    \ use any libraries. I only have to use basic functions. I edited my question\
    \ to make it more clear.\n<|/ c |>\n<| c |>\nI edited my answer to include a solution\
    \ that uses basic functions. I hope it helps.\n<|/ c |>\n<| c |>\nThanks for your\
    \ answer. Unfortunately I cannot use any libraries. I only have to use basic functions.\
    \ I edited my question to make it more clear.\n<|/ c |>\n<| a tags=racket,scheme\
    \ |>\n<code>", "  (define (helper string result)\n    (if (string-empty? string)\n\
    \        result\n        (helper (substring string 0 1) (append result (list (char->string\
    \ (char->integer char)))))\n      )\n    )\n  (helper string '())\n  )\n", " \
    \ (let loop ((string string) (result '()))\n    (cond ((null? string) result)\n\
    \          ((char=? (car string) 'A) (loop (cdr string) (cons (char->upper (car\
    \ string)) result)))\n          ((char=? (car string) 'a) (loop (cdr string) (cons\
    \ (char->lower (car string)) result)))\n          (else (loop (cdr string) (cons\
    \ (car string) result)))))\n  result)\n", "  (cond\n    [(empty? string) string]\n\
    \    [(equal? (first string) (string-ref string 0)) (string-append (make-string\
    \ (string-length string) (char->string #\\U)) (string-append (make-string (string-length\
    \ string) (char->string #\\L)) (string-append (make-string (string-length string)\
    \ (char->string #\\l)) (string-append (make-string (string-length string) (char->string\
    \ #\\u)) (string-append (make-string (string-length string) (char->string #\\\
    L)) (string-append (make-string (string-length string) (char->string #\\l)) (string-append\
    \ (make-string (string-length string) (char->string #\\u)) (string-append (make-string\
    \ (string-length string) (char->string #\\U)) (string-append (make-string (string-length\
    \ string) (char->string #\\l)) (string-append (make-string (string-length string)\
    \ (char->string #\\u)) (string-append (make-string (string-length string) (char->string\
    \ #\\U)) (string-append (make-string (string-length string) (char->string #\\\
    l)) (string-append (make-string (string-length string) (char->string #\\u)) (string-append\
    \ (make-string (string-length string) (char->string #\\U)) (string-append (make-string\
    \ (string-length string) (char->string #\\l)) (string-append (make-string (string-length\
    \ string) (char->string #\\u)) (string-append (make-string (string-length string)\
    \ (char->string #\\L)) (string-append (make-string (string-length string) (char->string\
    \ #\\l)) (string-append (make-string (string-length string) (char->string #\\\
    u)) (string-append (make-string (string-length string) (char->string #\\U)) (string-append\
    \ (make-string (string-length string) (char->string #\\L)) (string-append (make-string\
    \ (string-length string) (char->string #\\l)) (string-append (make-string (string-length\
    \ string) (char->string #\\u)) (string-append (make-string (string-length string)\
    \ (char->string #\\U)) (string-append (make-string (string-length string) (char->string\
    \ #\\L)) (string-append (make-string (string-length string) (char->string #\\\
    l)) (string-append (make-string (string-length string) (char->string #\\u)) (string-append\
    \ (make-string (string-length string", "  (cond\n    [(empty? string) \"\"]\n\
    \    [(equal? (first string) (string-ref string 0)) (string-append (string-ref\
    \ string 0) (string-ref string 1))]\n    [else (string-append (string-ref string\
    \ 0) (string-ref string 1))]))\n", "  (let ((chars (string->list string)))\n \
    \   (map (lambda (c)\n           (if (char=? c #\\a)\n               (char-upper-case\
    \ c)\n               (char-lower-case c)))\n         chars)))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
