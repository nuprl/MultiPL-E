name: HumanEval_27_flip_case
language: rkt
prompt: "#lang racket\n\n;; For a given string, flip lowercase characters to uppercase\
  \ and uppercase to lowercase.\n(define (flip_case string)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate flip_case))\n\
  \    (check-equal? (candidate \"\") \"\")\n    (check-equal? (candidate \"Hello!\"\
  ) \"hELLO!\")\n    (check-equal? (candidate \"These violent delights have violent\
  \ ends\") \"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\")\n))\n\n(test-humaneval)"
completions: ["  (let loop ((string string) (result '()))\n    (if (string-empty?\
    \ string)\n        result\n        (loop (substring string 0 1) (append result\
    \ (list (char->string (char->integer char->char (char->integer char->char (char->integer\
    \ char->char (char->integer char->char (char->integer char->char (char->integer\
    \ char->char (char->integer char->char (char->integer char->char (char->integer\
    \ char->char (char->integer char->char (char->integer char->char (char->integer\
    \ char->char (char->integer char->char (char->integer char->char (char->integer\
    \ char->char (char->integer char->char (char->integer char->char (char->integer\
    \ char->char (char->integer char->char (char->integer char->char (char->integer\
    \ char->char (char->integer char->char (char->integer char->char (char->integer\
    \ char->char (char->integer char->char (char->integer char->char (char->integer\
    \ char->char (char->integer char->char (char->integer char->char (char->integer\
    \ char->char (char->integer char->char (char->integer char->char (char->integer\
    \ char->char (char->integer char->char (char->integer char->char (char->integer\
    \ char->char (char->integer char->char (char->integer char->char (char->integer\
    \ char->char (char->integer char->char (char->integer char->char (char->integer\
    \ char->char (char->integer char->char (char->integer char->char (char->integer\
    \ char->char (char->integer char->char (char->integer char->char (char->integer\
    \ char->char (char->integer char->char (char->integer char->char (char->integer\
    \ char->char (char->integer char->char (char->integer char->char (char->integer\
    \ char->char (char->integer char->char (char->integer char->char (char->integer\
    \ char->char (char->integer char->char (char->integer char->char (char->integer\
    \ char->char (char->integer char->char (char->integer char->char (char->integer\
    \ char->char (char->integer char->char (char->integer char->char (char->integer\
    \ char->char (char->integer char->char (char->integer char->char", "  (cond\n\
    \    [(empty? string) \"\"]\n    [(equal? (first string) (string-ref string 0))\
    \ (string-append (second string) (first string))]\n    [else (string-append (flip_case\
    \ (substring string 0 1)) (substring string 1 0))]))\n", "  (define (helper string\
    \ result)\n    (if (string-empty? string)\n        result\n        (helper (substring\
    \ string 0 1) (append result (substring string 1 string)))\n      )\n  )\n  (helper\
    \ string '())\n)\n", "  (cond\n    [(string-empty? string) string]\n    [(equal?\
    \ (char-code (car string)) #\\A) (upper-case (substring string 1))]\n    [(equal?\
    \ (char-code (car string)) #\\a) (lower-case (substring string 1))]\n    [(equal?\
    \ (char-code (car string)) #\\z) (upper-case (substring string 1))]\n    [(equal?\
    \ (char-code (car string)) #\\Z) (lower-case (substring string 1))]\n    [else\
    \ (string-append (substring string 1)\n                       (flip_case (substring\
    \ string 2)))]))\n", "  (let ((lower (string->list string)))\n    (map (lambda\
    \ (char)\n           (if (char->char? char)\n               (char->string (char->char\
    \ (char->string char)))\n               (char->string (char->char (char->string\
    \ char))))\n           lower)\n         string)))\n", "  (cond\n    [(empty? string)\
    \ \"\"]\n    [(equal? (first string) (string-ref string 0)) (string-append (string-ref\
    \ string 0) (string-ref string 1))]\n    [else (string-append (string-ref string\
    \ 0) (string-ref string 1))]))\n", "  (let ((result '()))\n    (for ((i (length\
    \ string))) (cond ((char=? string #\\A) (set! result (append result #\\A))\n \
    \                                              (char=? string #\\z) (set! result\
    \ (append result #\\z))\n                                               ((char=?\
    \ string #\\A) (set! result (append result #\\a)))\n                         \
    \                      ((char=? string #\\z) (set! result (append result #\\z)))\n\
    \                                               (else (set! result (append result\
    \ string)))))\n    result))\n", "  (let loop ((string string)\n             (result\
    \ '()))\n    (if (empty? string)\n        result\n        (loop (rest string)\n\
    \              (cons (char->string (char->integer char->char (first string)))\
    \ result)))))\n", "  (cond\n    [(empty? string) string]\n    [(equal? (first\
    \ string) (string-ref string 0)) (string-append (string-ref string 0) (string-ref\
    \ string 1))]\n    [else (string-append (string-ref string 0) (string-ref string\
    \ 1))]))\n", "  (cond\n    [(empty? string) \"\"]\n    [(equal? (first string)\
    \ (string-ref string 0)) (string-append \"-\" (second string))]\n    [else (string-append\
    \ \"-\" (first string) (flip_case (rest string)))]))\n", "  (define (helper string\
    \ result)\n    (if (string-empty? string)\n        result\n        (helper (substring\
    \ string 0 1)\n                (cond [(char=? (char-code string) 'a)\n       \
    \                'A]\n                          [(char=? (char-code string) 'b)\n\
    \                       'B]\n                          [(char=? (char-code string)\
    \ 'c)\n                       'C]\n                          [(char=? (char-code\
    \ string) 'd)\n                       'D]\n                          [(char=?\
    \ (char-code string) 'e)\n                       'E]\n                       \
    \   [(char=? (char-code string) 'f)\n                       'F]\n            \
    \              [(char=? (char-code string) 'g)\n                       'G]\n \
    \                         [(char=? (char-code string) 'h)\n                  \
    \     'H]\n                          [(char=? (char-code string) 'i)\n       \
    \                'I]\n                          [(char=? (char-code string) 'j)\n\
    \                       'J]\n                          [(char=? (char-code string)\
    \ 'k)\n                       'K]\n                          [(char=? (char-code\
    \ string) 'l)\n                       'L]\n                          [(char=?\
    \ (char-code string) 'm)\n                       'M]\n                       \
    \   [(char=? (char-code string) 'n)\n                       'N]\n            \
    \              [(char=? (char-code string) 'o)\n                       'O]\n \
    \                         [(char=? (char-code string) 'p)\n                  \
    \     'P]\n                          [(char=? (char-code string) 'q)\n       \
    \                'Q]\n                          [(char=? (char-code string) 'r)\n\
    \                       'R]\n                          [(char=? (char-code string)\
    \ 's)\n                       'S]\n                          [(char=? (char-code\
    \ string) 't) 'T]\n                          [(char=? (char-code string) 'u)\n\
    \                       'U]\n                          [(char=? (char-code string)\
    \ 'v)\n                       'V]\n                          [(char=? (char-code\
    \ string) 'w)\n                       'W]\n                          [(char=?\
    \ (char-code string) 'x)\n                       'X]\n                       \
    \   [(char=? (char-code string) 'y)\n                       'Y]\n            \
    \              [(char=? (char-code string) 'z)\n                       'Z]\n \
    \                         [else string])))\n  (helper string '()))\n", "  (define\
    \ (helper string result)\n    (cond [(empty? string) result]\n          [else\n\
    \           (helper (cdr string) (append result (list (char->string (char->integer\
    \ (car string)))))]\n          ))\n  (helper string '()))\n", "  (let ((chars\
    \ (string->list string)))\n    (map (lambda (c)\n           (if (char=? c #\\\
    a)\n               (char-upper-case c)\n               (char-lower-case c)))\n\
    \         chars)))\n", "  (cond\n    [(empty? string) \"\"]\n    [(equal? (first\
    \ string) (string-ref string 0)) (string-append (make-string (string-length string)\
    \ (char->string #\\A)) (string-append (make-string (string-length string) (char->string\
    \ #\\a)) (string-append (make-string (string-length string) (char->string #\\\
    z)) (string-append (make-string (string-length string) (char->string #\\Z))))]\n\
    \    [else (string-append (make-string (string-length string) (char->string #\\\
    A)) (string-append (make-string (string-length string) (char->string #\\a)) (string-append\
    \ (make-string (string-length string) (char->string #\\z)) (string-append (make-string\
    \ (string-length string) (char->string #\\Z))))]\n  ))\n", "  (define (helper\
    \ string result)\n    (if (string-empty? string)\n        result\n        (helper\
    \ (substring string 0 1)\n                (cond [(char=? (char-code string) 97)\
    \ (concat result (char->string (char->integer 97)))]\n                      [(char=?\
    \ (char-code string) 65) (concat result (char->string (char->integer 65)))]\n\
    \                      [else (concat result (char->string (char->integer 97)))])))\n\
    \  (helper string \"\"))\n</code>\n<|/ a tags=racket,scheme |>\n<| c |>\nThanks\
    \ for your answer. Unfortunately I cannot use any libraries. I only have to use\
    \ basic functions. I edited my question to make it more clear.\n<|/ c |>\n<| c\
    \ |>\nI edited my answer to include a solution that uses basic functions. I hope\
    \ it helps.\n<|/ c |>\n<| c |>\nThanks for your answer. Unfortunately I cannot\
    \ use any libraries. I only have to use basic functions. I edited my question\
    \ to make it more clear.\n<|/ c |>\n<| c |>\nI edited my answer to include a solution\
    \ that uses basic functions. I hope it helps.\n<|/ c |>\n<| c |>\nThanks for your\
    \ answer. Unfortunately I cannot use any libraries. I only have to use basic functions.\
    \ I edited my question to make it more clear.\n<|/ c |>\n<| a tags=racket,scheme\
    \ |>\n<code>", "  (define (helper string result)\n    (if (string-empty? string)\n\
    \        result\n        (helper (substring string 0 1) (append result (list (char->string\
    \ (char->integer char)))))\n      )\n    )\n  (helper string '())\n  )\n", " \
    \ (let loop ((string string) (result '()))\n    (cond ((null? string) result)\n\
    \          ((char=? (car string) 'A) (loop (cdr string) (cons (char->upper (car\
    \ string)) result)))\n          ((char=? (car string) 'a) (loop (cdr string) (cons\
    \ (char->lower (car string)) result)))\n          (else (loop (cdr string) (cons\
    \ (car string) result)))))\n  result)\n", "  (cond\n    [(empty? string) string]\n\
    \    [(equal? (first string) (string-ref string 0)) (string-append (make-string\
    \ (string-length string) (char->string #\\U)) (string-append (make-string (string-length\
    \ string) (char->string #\\L)) (string-append (make-string (string-length string)\
    \ (char->string #\\l)) (string-append (make-string (string-length string) (char->string\
    \ #\\u)) (string-append (make-string (string-length string) (char->string #\\\
    L)) (string-append (make-string (string-length string) (char->string #\\l)) (string-append\
    \ (make-string (string-length string) (char->string #\\u)) (string-append (make-string\
    \ (string-length string) (char->string #\\U)) (string-append (make-string (string-length\
    \ string) (char->string #\\l)) (string-append (make-string (string-length string)\
    \ (char->string #\\u)) (string-append (make-string (string-length string) (char->string\
    \ #\\U)) (string-append (make-string (string-length string) (char->string #\\\
    l)) (string-append (make-string (string-length string) (char->string #\\u)) (string-append\
    \ (make-string (string-length string) (char->string #\\U)) (string-append (make-string\
    \ (string-length string) (char->string #\\l)) (string-append (make-string (string-length\
    \ string) (char->string #\\u)) (string-append (make-string (string-length string)\
    \ (char->string #\\L)) (string-append (make-string (string-length string) (char->string\
    \ #\\l)) (string-append (make-string (string-length string) (char->string #\\\
    u)) (string-append (make-string (string-length string) (char->string #\\U)) (string-append\
    \ (make-string (string-length string) (char->string #\\L)) (string-append (make-string\
    \ (string-length string) (char->string #\\l)) (string-append (make-string (string-length\
    \ string) (char->string #\\u)) (string-append (make-string (string-length string)\
    \ (char->string #\\U)) (string-append (make-string (string-length string) (char->string\
    \ #\\L)) (string-append (make-string (string-length string) (char->string #\\\
    l)) (string-append (make-string (string-length string) (char->string #\\u)) (string-append\
    \ (make-string (string-length string", "  (cond\n    [(empty? string) \"\"]\n\
    \    [(equal? (first string) (string-ref string 0)) (string-append (string-ref\
    \ string 0) (string-ref string 1))]\n    [else (string-append (string-ref string\
    \ 0) (string-ref string 1))]))\n", "  (let ((chars (string->list string)))\n \
    \   (map (lambda (c)\n           (if (char=? c #\\a)\n               (char-upper-case\
    \ c)\n               (char-lower-case c)))\n         chars)))\n", "  (cond\n \
    \   [(empty? string) \"\"]\n    [(equal? (first string) (string-ref string 0))\
    \ (string-append (make-string (string-length string) (char->string #\\A)) (string-append\
    \ (make-string (string-length string) (char->string #\\z)) (string-append (make-string\
    \ (string-length string) (char->string #\\Z))))]\n    [else (string-append (make-string\
    \ (string-length string) (char->string #\\A)) (string-append (make-string (string-length\
    \ string) (char->string #\\z)) (string-append (make-string (string-length string)\
    \ (char->string #\\Z))) (string-append (make-string (string-length string) (char->string\
    \ #\\A)) (string-append (make-string (string-length string) (char->string #\\\
    z)) (string-append (make-string (string-length string) (char->string #\\Z))))]))\n",
  "  (let loop ((string string)\n             (result '()))\n    (if (empty? string)\n\
    \        result\n        (loop (rest string)\n              (cons (char->string\
    \ (char->integer char->char (first string))) result)))))\n", "  (define (helper\
    \ string result)\n    (if (string-empty? string)\n        result\n        (helper\
    \ (substring string 0 1)\n                (cond [(char=? (char-code string) 97)\
    \ (concat result (char->string (char->integer 97)))]\n                      [(char=?\
    \ (char-code string) 65) (concat result (char->string (char->integer 65)))]\n\
    \                      [else (concat result (char->string (char->integer char-code\
    \ string))))])))\n  (helper string \"\"))\n", "  (cond [(empty? string) string]\n\
    \        [(equal? (first string) (string-ref string 0)) (string-append (make-string\
    \ (string-length string) (char->string #\\U)) (flip_case (rest string)))]\n  \
    \      [else (string-append (make-string (string-length string) (char->string\
    \ #\\L)) (flip_case (rest string)))]))\n", "  (cond\n    [(empty? string) \"\"\
    ]\n    [(equal? (first string) (string-ref string 0)) (string-append (string-ref\
    \ string 0) (string-ref string 1))]\n    [else (string-append (string-ref string\
    \ 0) (string-ref string 1))]))\n", "  (let ((chars (string->list string)))\n \
    \   (map (lambda (char)\n           (if (char-lower? char)\n               (char-upcase\
    \ char)\n               (char-downcase char)))\n         chars)))\n", "  (cond\n\
    \    [(empty? string) \"\"]\n    [(equal? (first string) (string-ref string 0))\
    \ (string-append (make-string (string-length string) (char->string #\\U)) (string-append\
    \ (make-string (string-length string) (char->string #\\l)) (string-append (make-string\
    \ (string-length string) (char->string #\\L)) (string-append (make-string (string-length\
    \ string) (char->string #\\l)) (string-append (make-string (string-length string)\
    \ (char->string #\\L)) (string-append (make-string (string-length string) (char->string\
    \ #\\U)) (string-append (make-string (string-length string) (char->string #\\\
    l)) (string-append (make-string (string-length string) (char->string #\\L)) (string-append\
    \ (make-string (string-length string) (char->string #\\l)) (string-append (make-string\
    \ (string-length string) (char->string #\\L)) (string-append (make-string (string-length\
    \ string) (char->string #\\U)) (string-append (make-string (string-length string)\
    \ (char->string #\\l)) (string-append (make-string (string-length string) (char->string\
    \ #\\L)) (string-append (make-string (string-length string) (char->string #\\\
    l)) (string-append (make-string (string-length string) (char->string #\\L)) (string-append\
    \ (make-string (string-length string) (char->string #\\U)) (string-append (make-string\
    \ (string-length string) (char->string #\\l)) (string-append (make-string (string-length\
    \ string) (char->string #\\L)) (string-append (make-string (string-length string)\
    \ (char->string #\\l)) (string-append (make-string (string-length string) (char->string\
    \ #\\L)) (string-append (make-string (string-length string) (char->string #\\\
    U)) (string-append (make-string (string-length string) (char->string #\\l)) (string-append\
    \ (make-string (string-length string) (char->string #\\L)) (string-append (make-string\
    \ (string-length string) (char->string #\\l)) (string-append (make-string (string-length\
    \ string) (char->string #\\L)) (string-append (make-string (string-length string)\
    \ (char->string #\\U)) (string-append (make-string (string-length string) (char->string\
    \ #\\l)) (string-", "  (let ((result '()))\n    (for ([i (in-range (length string)\
    \ inc)])\n      (if (char=? (char-code string i) 'a)\n          (set! result (append\
    \ result 'A))\n          (set! result (append result 'a)))\n      (set! result\
    \ (append result (char-code string i))))\n    result))\n", "  (cond\n    [(empty?\
    \ string) \"\"]\n    [(equal? (first string) (string-ref string 0)) (string-append\
    \ (string-ref string 0) (string-ref string 1))]\n    [else (string-append (string-ref\
    \ string 0) (string-ref string 1))]))\n", "  (let ([lower (string->list string)])\n\
    \    (map (lambda (char)\n           (if (char->char? char)\n               (char->string\
    \ (char->char (char->string char)))\n               (char->string (char->char\
    \ (char->string char))))\n           lower)\n         string)))\n", "  (let ((result\
    \ '()))\n    (for ((i 0 (+ i 1))) (if (char=? string #\\A) (cons #\\A result)\
    \ (cons string result))\n    result))\n", "  (let loop ((string string) (result\
    \ '()))\n    (cond ((null? string) result)\n          ((char-lower? (car string))\
    \ (loop (cdr string) (cons (char-upper? (car string)) result)))\n          ((char-upper?\
    \ (car string)) (loop (cdr string) (cons (char-lower? (car string)) result)))\n\
    \          (else (loop (cdr string) (cons (car string) result))))))\n", "  (cond\n\
    \    [(empty? string) string]\n    [(equal? (first string) (string-ref string\
    \ 0)) (string-append (make-string (string-length string) ?A) (make-string (string-length\
    \ string) ?B))]\n    [else (string-append (make-string (string-length string)\
    \ ?A) (make-string (string-length string) ?B) (flip_case (string-ref string 1)))]))\n",
  "  (cond\n    [(string-length string) string]\n    [(equal? (char-code (string-ref\
    \ string 0)) #\\a) (char->string #\\A)]\n    [(equal? (char-code (string-ref string\
    \ 0)) #\\z) (char->string #\\Z)]\n    [(equal? (char-code (string-ref string 0))\
    \ #\\A) (char->string #\\a)]\n    [(equal? (char-code (string-ref string 0)) #\\\
    Z) (char->string #\\z)]\n    [else (string-append (string-append (string-append\
    \ (string-append (string-append (string-append (string-append (string-append (string-append\
    \ (string-append (string-append (string-append (string-append (string-append (string-append\
    \ (string-append (string-append (string-append (string-append (string-append (string-append\
    \ (string-append (string-append (string-append (string-append (string-append (string-append\
    \ (string-append (string-append (string-append (string-append (string-append (string-append\
    \ (string-append (string-append (string-append (string-append (string-append (string-append\
    \ (string-append (string-append (string-append (string-append (string-append (string-append\
    \ (string-append (string-append (string-append (string-append (string-append (string-append\
    \ (string-append (string-append (string-append (string-append (string-append (string-append\
    \ (string-append (string-append (string-append (string-append (string-append (string-append\
    \ (string-append (string-append (string-append (string-append (string-append (string-append\
    \ (string-append (string-append (string-append (string-append (string-append (string-append\
    \ (string-append (string-append (string-append (string-append (string-append (string-append\
    \ (string-append (string-append (string-append (string-append (string-append (string-append\
    \ (string-append (string-append (string-append (string-append (string-append (string-append\
    \ (string-append (string-append (string-append (string-append (string-append (string-append\
    \ (string-append (string-append (string-append (string-append (string-append (string-append\
    \ (string-append (string-append (string-append (string-append (string-append (string-append\
    \ (string-append (string-append (string-append (string-append (string-append (string-append\
    \ (string-append (string-append (string-append (string-append (string-append (string-append\
    \ (string-append (string-append (string-append (string-append (string-append (string-append\
    \ (string-append (string-append (string-append (string-append (string-append ",
  "  (cond\n    [(empty? string) \"\"]\n    [(equal? (first string) (string-ref string\
    \ 0)) (string-append \"A\" (second string))]\n    [else (string-append \"a\" (second\
    \ string))]))\n", "  (cond\n    [(empty? string) \"\"]\n    [(equal? (first string)\
    \ (string-ref string 0)) (string-append \"-\" (second string))]\n    [else (string-append\
    \ \"-\" (first string) (flip_case (rest string)))]))\n", "  (let ((lower (string->list\
    \ string)))\n    (map (lambda (char)\n           (if (char->char? char)\n    \
    \           (char->string (char->char (char->string char)))\n               char))\n\
    \         lower)))\n", "  (let ((lower (string->list string)))\n    (map (lambda\
    \ (x)\n           (if (string=? x #\\a)\n               (string=? (string->list\
    \ x) #\\A)\n               (string=? (string->list x) #\\a)))\n         lower)))\n",
  "  (cond\n    [(empty? string) string]\n    [(equal? (first string) (string-ref\
    \ string 0)) (string-append (make-string (string-length string) ?A) (make-string\
    \ (string-length string) ?a))]\n    [else (string-append (make-string (string-length\
    \ string) ?A) (make-string (string-length string) ?a) (flip_case (rest string)))]))\n",
  "  (define (helper string result)\n    (cond\n      [(empty? string) result]\n \
    \     [(char-lower? (car string)) (helper (cdr string) (cons (char-upper? (car\
    \ string)) result))]\n      [(char-upper? (car string)) (helper (cdr string) (cons\
    \ (char-lower? (car string)) result))]\n      [else (helper (cdr string) (cons\
    \ (car string) result))]))\n  (helper string '()))\n", "  (cond\n    [(empty?\
    \ string) \"\"]\n    [(equal? (first string) (string-ref string 0)) (string-append\
    \ (string-ref string 0) (string-ref string 1))]\n    [else (string-append (string-ref\
    \ string 0) (string-ref string 1))]))\n", "  (let loop ((string string)\n    \
    \         (result '()))\n    (cond ((empty? string) result)\n          ((char-lower?\
    \ (first string))\n           (loop (rest string) (cons (first string) result)))\n\
    \          ((char-upper? (first string))\n           (loop (rest string) (cons\
    \ (first string) result)))\n          (else\n           (loop (rest string) (cons\
    \ (first string) result))))))\n", "  (cond\n    [(string-empty? string) string]\n\
    \    [(equal? (char-code (first string)) #\\A) (make-string (char-code (first\
    \ string)) (length (first string)))\n     (make-string (char-code (first string))\
    \ (length (first string)))]\n    [else (make-string (char-code (first string))\
    \ (length (first string))) (make-string (char-code (first string)) (length (first\
    \ string)))]\n    [else (string-append (make-string (char-code (first string))\
    \ (length (first string)) (make-string (char-code (first string)) (length (first\
    \ string))))\n                       (make-string (char-code (first string)) (length\
    \ (first string)))]\n    [else (string-append (make-string (char-code (first string))\
    \ (length (first string)) (make-string (char-code (first string)) (length (first\
    \ string))))\n                       (make-string (char-code (first string)) (length\
    \ (first string)))]\n    [else (string-append (make-string (char-code (first string))\
    \ (length (first string)) (make-string (char-code (first string)) (length (first\
    \ string))))\n                       (make-string (char-code (first string)) (length\
    \ (first string)))]\n    [else (string-append (make-string (char-code (first string))\
    \ (length (first string)) (make-string (char-code (first string)) (length (first\
    \ string))))\n                       (make-string (char-code (first string)) (length\
    \ (first string)))]\n    [else (string-append (make-string (char-code (first string))\
    \ (length (first string)) (make-string (char-code (first string)) (length (first\
    \ string))))\n                       (make-string (char-code (first string)) (length\
    \ (first string)))]\n    [else (string-append (make-string (char-code (first string))\
    \ (length (first string)) (make-string (char-code (first string)) (length (first\
    \ string))))\n                       (make-string (char-code (first string)) (length\
    \ (first string)))]\n    [else (string-append (make-string (char-code (first string))\
    \ (length (first string)) (make-string (char-code (first string)) (length (first\
    \ string))))\n                       (make-string (char-code (first string)) (length\
    \ (first string)))]\n    [else (string-append (make-string (char-code (first string)) ",
  "  (let ((result '()))\n    (for ([i (in-range (length string) -1)])\n      (let\
    \ ((char (substring string i 1)))\n        (if (char >= 'A' char <= 'Z')\n   \
    \         (set! result (append result (char - 'A' + 'a')))\n            (set!\
    \ result (append result char)))))\n    result))\n", "  (define (helper string\
    \ result)\n    (cond [(empty? string) result]\n          [(char-lower? (car string))\
    \ (helper (cdr string) (cons (char-upper? (car string)) result))]\n          [else\
    \ (helper (cdr string) (cons (car string) result))]))\n  (helper string '()))\n",
  "  (cond [(empty? string) \"\"]\n        [(equal? (first string) (string-ref string\
    \ 0)) (string-append (make-string (string-length string) ?A) (make-string (string-length\
    \ string) ?B))]\n        [else (string-append (make-string (string-length string)\
    \ ?A) (make-string (string-length string) ?B))]))\n", "  (cond\n    [(empty? string)\
    \ string]\n    [(equal? (first string) (string-ref string 0)) (string-append (make-string\
    \ (string-length string) ?A) (make-string (string-length string) ?B))]\n    [else\
    \ (string-append (make-string (string-length string) ?A) (make-string (string-length\
    \ string) ?B))]))\n", "  (cond\n    [(string-empty? string) string]\n    [(equal?\
    \ (char-code (car string)) #\\a) (upper-case (string-reverse string))]\n    [(equal?\
    \ (char-code (car string)) #\\A) (lower-case (string-reverse string))]\n    [else\
    \ (string-append (string-reverse string) (string-reverse (lower-case string)))]))\n",
  "  (define (helper char result)\n    (cond [(char= char #\\a) (char= result #\\\
    A)\n          (char= char #\\B) (char= result #\\B)\n          (char= char #\\\
    C) (char= result #\\C)\n          (char= char #\\D) (char= result #\\D)\n    \
    \      (char= char #\\E) (char= result #\\E)\n          (char= char #\\F) (char=\
    \ result #\\F)\n          (char= char #\\G) (char= result #\\G)\n          (char=\
    \ char #\\H) (char= result #\\H)\n          (char= char #\\I) (char= result #\\\
    I)\n          (char= char #\\J) (char= result #\\J)\n          (char= char #\\\
    K) (char= result #\\K)\n          (char= char #\\L) (char= result #\\L)\n    \
    \      (char= char #\\M) (char= result #\\M)\n          (char= char #\\N) (char=\
    \ result #\\N)\n          (char= char #\\O) (char= result #\\O)\n          (char=\
    \ char #\\P) (char= result #\\P)\n          (char= char #\\Q) (char= result #\\\
    Q)\n          (char= char #\\R) (char= result #\\R)\n          (char= char #\\\
    S) (char= result #\\S)\n          (char= char #\\T) (char= result #\\T)\n    \
    \      (char= char #\\U) (char= result #\\U)\n          (char= char #\\V) (char=\
    \ result #\\V)\n          (char= char #\\W) (char= result #\\W)\n          (char=\
    \ char #\\x) (char= result #\\x)\n          (char= char #\\y) (char= result #\\\
    y)\n          (char= char #\\z) (char= result #\\z)\n          (char= char #\\\
    0) (char= result #\\0)\n          (char= char #\\1) (char= result #\\1)\n    \
    \      (char= char #\\2) (char= result #\\2)\n          (char= char #\\3) (char=\
    \ result #\\3)\n          (char= char #\\4) (char= result #\\4)\n          (char=\
    \ char #\\5) (char= result #\\5)\n          (char= char #\\6) (char= result #\\\
    6)\n          (char= char #\\7) (char= ", "  (let loop ((string string) (result\
    \ '()))\n    (cond ((empty? string) result)\n          ((char-lower? (car string))\
    \ (loop (cdr string) (cons (char-upper? (car string)) result)))\n          ((char-upper?\
    \ (car string)) (loop (cdr string) (cons (char-lower? (car string)) result)))\n\
    \          (else (loop (cdr string) (cons (car string) result))))))\n", "  (let\
    \ loop ((string string)\n             (result '()))\n    (if (string-empty? string)\n\
    \        result\n        (loop (substring string 0 1)\n              (cons (char->upper-case\n\
    \                       (char->lower-case (string-ref string 0))))\n         \
    \     (loop (substring string 1 string-length (length string))\n             \
    \       result))))))\n", "  (define (helper string result)\n    (if (string-empty?\
    \ string)\n        result\n        (helper (substring string 0 1) (append result\
    \ (list (char->string (char->integer char-code string)))))))\n  (helper string\
    \ '()))\n", "  (cond\n    [(string-empty? string) \"\"]\n    [(equal? (char-code\
    \ (string-ref string 0)) #\\A) (substring string 1)]\n    [(equal? (char-code\
    \ (string-ref string 0)) #\\z) (substring string 1)]\n    [else (string-append\
    \ (string-append (substring string 1)\n                                      \
    \ (substring string 0 (char-code (string-ref string 0))))\n                  \
    \   (substring string 0 (char-code (string-ref string 0))))]))\n", "  (cond\n\
    \    [(empty? string) \"\"]\n    [(equal? (first string) (string-ref string 0))\
    \ (string-append (substring (second string) 0 1) (string-append (substring (first\
    \ string) 1 0) (substring (second string) 0 1)))]\n    [else (string-append (substring\
    \ (second string) 0 1) (string-append (substring (first string) 1 0) (substring\
    \ (second string) 0 1)))]))\n", "  (define (helper string result)\n    (if (string-empty?\
    \ string)\n        result\n        (helper (substring string 0 1)\n          \
    \      (cond [(char=? (char-code string) 97) (char-code (substring string 1 0))\
    \ #\\A]\n                      [(char=? (char-code string) 65) (char-code (substring\
    \ string 1 0)) #\\a]\n                      [(char=? (char-code string) 97) (char-code\
    \ (substring string 1 0)) #\\Z]\n                      [(char=? (char-code string)\
    \ 65) (char-code (substring string 1 0)) #\\z]\n                      [else (cons\
    \ string result)]))))\n  (helper string '()))\n", "  (cond\n    [(empty? string)\
    \ string]\n    [(equal? (first string) (string-ref string 0)) (string-append (substring\
    \ (second string) 0 1) (string-append (substring (second string) 1 0) (substring\
    \ (second string) 0 1)))]\n    [else (string-append (substring (second string)\
    \ 0 1) (string-append (substring (second string) 1 0) (substring (second string)\
    \ 0 1)))]))\n", "  (let ((lower (string->list string)))\n    (map (lambda (x)\n\
    \           (if (string=? (car x) lower)\n               (string=? (car x) (string->string\
    \ (string->list (string->string (string->list (string->string (string->string\
    \ (string->string (string->string (string->string (string->string (string->string\
    \ (string->string (string->string (string->string (string->string (string->string\
    \ (string->string (string->string (string->string (string->string (string->string\
    \ (string->string (string->string (string->string (string->string (string->string\
    \ (string->string (string->string (string->string (string->string (string->string\
    \ (string->string (string->string (string->string (string->string (string->string\
    \ (string->string (string->string (string->string (string->string (string->string\
    \ (string->string (string->string (string->string (string->string (string->string\
    \ (string->string (string->string (string->string (string->string (string->string\
    \ (string->string (string->string (string->string (string->string (string->string\
    \ (string->string (string->string (string->string (string->string (string->string\
    \ (string->string (string->string (string->string (string->string (string->string\
    \ (string->string (string->string (string->string (string->string (string->string\
    \ (string->string (string->string (string->string (string->string (string->string\
    \ (string->string (string->string (string->string (string->string (string->string\
    \ (string->string (string->string (string->string (string->string (string->string\
    \ (string->string (string->string (string->string (string->string (string->string\
    \ (string->string (string->string (string->string (string->string (string->string\
    \ (string->string (string->string (string->string (string->string (string->string\
    \ (string->string (string->string (string->string (string->string (string->string\
    \ (string->string (string->string (string->string (string->string (string->string\
    \ (string->string (string->string (string->string (string->string (string->string\
    \ (string->string (string->string (string->string (string->string (string->string\
    \ (string->string (string->string (string->string (string->string (string->string\
    \ (string->string (string->string (string->string (string->string (string->string\
    \ (string->string (string->string (string->string (string->string (string->string\
    \ (string->string (string->string (string->string (string->string (string->string\
    \ (string->string (string->string (string->string (string->string (string->string\
    \ (string->string (string->string (string->string (string->string (string->string\
    \ (string->string (string->string (string->string (string->string (string->string\
    \ (string->string (string->string (string->", "  (cond [(empty? string) string]\n\
    \        [(equal? (first string) (string-ref string 0)) (string-append (second\
    \ string) (first string))]\n        [else (string-append (flip_case (substring\
    \ string 0 1)) (string-append (second string) (first string)))))\n", "  (cond\n\
    \    [(empty? string) \"\"]\n    [(equal? (first string) (string-ref string 0))\
    \ (string-append \"-\" (flip_case (substring string 1)))]\n    [else (string-append\
    \ \"-\" (flip_case (substring string 1)))]))\n", "  (cond [(empty? string) string]\n\
    \        [(equal? (first string) (string-ref string 0)) (string-append (string-ref\
    \ string 1) (string-ref string 0))]\n        [else (string-append (string-ref\
    \ string 0) (string-ref string 1))]))\n", "  (define (helper string result)\n\
    \    (if (string-empty? string)\n        result\n        (helper (substring string\
    \ 0 1) (if (char-lower-case? string) (string-append result (char-upper-case? string))\
    \ result))))\n  (helper string \"\"))\n", "  (let ((chars (string->list string)))\n\
    \    (map (lambda (c)\n           (if (char-lower? c)\n               (char-upcase\
    \ c)\n               (char-downcase c)))\n         chars)))\n", "  (cond\n   \
    \ [(empty? string) string]\n    [(equal? (first string) (string-ref string 0))\
    \ (string-append (string-ref string 0) (string-ref string 1))]\n    [else (string-append\
    \ (string-ref string 0) (string-ref string 1))]))\n", "  (let ((lower (string->list\
    \ string)))\n    (map (lambda (char)\n           (if (char->char? char)\n    \
    \           (char->string (char->char (char->string char)))\n               (char->string\
    \ (char->char (char->string char))))\n           lower)\n         string)))\n",
  "  (cond [(empty? string) string]\n        [(equal? (first string) (string-ref string\
    \ 0)) (string-append (make-string (string-length string) (char->string #\\U))\
    \ (string-reverse (substring (second string) 1)))]\n        [else (string-append\
    \ (make-string (string-length string) (char->string #\\L)) (string-reverse (substring\
    \ (second string) 1)))]))\n", "  (let loop ((string string)\n             (result\
    \ '()))\n    (if (empty? string)\n        result\n        (loop (rest string)\n\
    \              (cons (char->string (char->integer char->char (first string)))\
    \ result)))))\n", "  (define (helper char)\n    (cond\n      [(char >= 'a' char)\
    \ (char - 'a' + 'A')]\n      [(char >= 'A' char) (char - 'A' + 'a')]\n      [else\
    \ char]))\n  (define (helper string)\n    (map (lambda (char)\n           (helper\
    \ (helper char)))\n          string))\n  (helper string))\n", "  (let loop ((string\
    \ string) (result '()))\n    (cond\n      [(empty? string) result]\n      [(char-lower?\
    \ (car string)) (loop (cdr string) (cons (char-upper? (car string)) result))]\n\
    \      [(char-upper? (car string)) (loop (cdr string) (cons (char-lower? (car\
    \ string)) result))]\n      [else (loop (cdr string) (cons (car string) result))]))\n\
    \  result)\n", "  (let loop ((string string) (result '()))\n    (cond\n      [(empty?\
    \ string) result]\n      [(char-lower? (first string)) (loop (rest string) (cons\
    \ (first string) result))]\n      [(char-upper? (first string)) (loop (rest string)\
    \ (cons (first string) (cons (first string) result)))]\n      [else (loop (rest\
    \ string) (cons (first string) (cons (first string) result)))])))\n", "  (cond\n\
    \    [(empty? string) \"\"]\n    [(equal? (first string) (string-ref string 0))\
    \ (string-append (string-ref string 0) (string-ref string 1))]\n    [else (string-append\
    \ (string-ref string 0) (string-ref string 1))]))\n", "  (let ([flipped-string\
    \ \"\"])\n    (for [c string]\n      (if (char=? c #\\a)\n          (set! flipped-string\
    \ (append flipped-string #\\A))\n          (set! flipped-string (append flipped-string\
    \ c)))\n      (flipped-string))))\n", "  (cond\n    [(empty? string) \"\"]\n \
    \   [(equal? (first string) (string-ref string 0)) (string-append \"-\" (second\
    \ string))]\n    [else (string-append \"-\" (first string) (flip_case (string-rest\
    \ string)))]))\n", "  (let loop ((string string) (result '()))\n    (cond ((null?\
    \ string) result)\n          ((char-lower? (car string)) (loop (cdr string) (cons\
    \ (char-upper? (car string)) result)))\n          ((char-upper? (car string))\
    \ (loop (cdr string) (cons (char-lower? (car string)) result)))\n          (else\
    \ (loop (cdr string) (cons (car string) result))))))\n", "  (cond\n    [(empty?\
    \ string) \"\"]\n    [(equal? (first string) (string-ref string 0)) (string-append\
    \ (second string) (first string))]\n    [else (string-append (flip_case (string-ref\
    \ string 0)) (string-append (second string) (first string)))))\n", "  (define\
    \ (helper string result)\n    (cond\n      [(empty? string) result]\n      [(char-lower?\
    \ (car string)) (helper (cdr string) (cons (char-upper? (car string)) result))]\n\
    \      [else (helper (cdr string) (cons (car string) result))]))\n  (helper string\
    \ '()))\n", "  (cond [(empty? string) string]\n        [(equal? (first string)\
    \ (string-ref string 0)) (string-append (string-ref string 0) (string-ref string\
    \ 1))]\n        [else (string-append (string-ref string 0) (string-ref string\
    \ 1))]))\n", "  (cond\n    [(empty? string) string]\n    [(equal? (first string)\
    \ (string-ref string 0)) (string-append (make-string (string-length string) (char->string\
    \ #\\U)) (string-reverse (substring (second string) 1)))]\n    [else (string-append\
    \ (make-string (string-length string) (char->string #\\L)) (string-reverse (substring\
    \ (second string) 1)))]))\n", "  (let ((result '()))\n    (for ([i (in-range (length\
    \ string) -1)])\n      (let ((char (char-ref string i)))\n        (if (char >=\
    \ 'A' char <= 'Z')\n            (set! result (append result (char-code (char -\
    \ 'A'))))\n            (set! result (append result (char-code (char - 'a')))))))\n\
    \    result))\n", "  (define (helper string result)\n    (if (string-empty? string)\n\
    \        result\n        (helper (substring string 0 1)\n                (if (char-lower-case?\
    \ string)\n                    (cons (char-upper-case? string) result)\n     \
    \               (cons string result))))\n  (helper string '()))\n", "  (let loop\
    \ ((string string) (result '()))\n    (cond ((null? string) result)\n        \
    \  ((char=? (car string) 'A) (loop (cdr string) (cons (char->string (char->integer\
    \ 'A')) result)))\n          ((char=? (car string) 'a) (loop (cdr string) (cons\
    \ (char->string (char->integer 'a')) result)))\n          ((char=? (car string)\
    \ 'Z) (loop (cdr string) (cons (char->string (char->integer 'Z')) result)))\n\
    \          ((char=? (car string) 'z) (loop (cdr string) (cons (char->string (char->integer\
    \ 'z')) result)))\n          (else (loop (cdr string) (cons (car string) result)))))\n\
    \  result)\n", "  (let ((chars (string->list string)))\n    (map (lambda (c)\n\
    \           (if (char=? c #\\a)\n               (char-upper-case c)\n        \
    \       (char-lower-case c)))\n         chars)))\n", "  (define (helper string\
    \ result)\n    (cond\n      [(empty? string) result]\n      [(char-lower? (car\
    \ string)) (helper (cdr string) (cons (char-upper? (car string)) result))]\n \
    \     [else (helper (cdr string) (cons (car string) result))]\n      ))\n  (helper\
    \ string '()))\n", "  (cond\n    [(empty? string) \"\"]\n    [(equal? (first string)\
    \ (string-ref string 0)) (string-append (string-ref string 0) (string-ref string\
    \ 1))]\n    [else (string-append (string-ref string 0) (string-ref string 1))]))\n",
  "  (cond\n    [(empty? string) \"\"]\n    [(equal? (first string) (string-ref string\
    \ 0)) (string-append \"-\" (second string))]\n    [else (string-append \"-\" (second\
    \ string) (flip_case (rest string)))]))\n", "  (let ((result '()))\n    (for ((i\
    \ (length string)))\n      (if (char=? (char-code string) (string-ref string i))\n\
    \          (set! result (append result (list char->upper-case\n              \
    \                             (char-code string)))\n                (list char->lower-case\n\
    \                       (char-code string)))\n          (set! result (append result\
    \ (list char->lower-case\n                                           (char-code\
    \ string)))\n                (list char->upper-case\n                       (char-code\
    \ string))))))\n", "  (cond\n    [(empty? string) string]\n    [(equal? (first\
    \ string) (string-ref string 0)) (string-append (string-ref string 0) (string-ref\
    \ string 1))]\n    [else (string-append (string-ref string 0) (string-ref string\
    \ 1))]))\n", "  (cond\n    [(string-empty? string) \"\"]\n    [(equal? (char-code\
    \ (car string)) #\\A) (upper-case (string-reverse string))]\n    [else (cons (char-code\
    \ (car string)) (flip_case (string-reverse string)))]))\n", "  (define (helper\
    \ string index result)\n    (cond\n      [(empty? string) (list result)]\n   \
    \   [(char=? (car string) (car result)) (helper (cdr string) (+ index 1) (cdr\
    \ result))]\n      [else (helper (cdr string) (+ index 1) (cons (car string) result))]\n\
    \      ))\n  (helper string 0 '()))\n", "  (define (helper string result)\n  \
    \  (cond [(empty? string) result]\n          [(char=? (first string) 'A) (helper\
    \ (rest string) (conj result (first string)))]\n          [(char=? (first string)\
    \ 'a) (helper (rest string) (conj result (first string)))]\n          [else (helper\
    \ (rest string) (conj result (first string)))]))\n  (helper string '()))\n", " \
    \ (cond\n    [(string-empty? string) \"\"]\n    [(equal? (char-code (car string))\
    \ #\\A) (upper-case (substring string 1))]\n    [else (cons (char-code (car string))\
    \ (flip_case (substring string 1)))]))\n", "  (cond [(empty? string) empty]\n\
    \        [(equal? (first string) (string-ref string 0)) (string-append (make-string\
    \ 1 (string->length (first string)) #\\U) (second string)]\n        [else (string-append\
    \ (make-string 1 (string->length (first string)) #\\L) (second string)]\n    \
    \    [else (string-append (make-string 1 (string->length (first string)) #\\L)\
    \ (second string)\n                           (make-string 1 (string->length (first\
    \ string)) #\\U) (third string)]))\n", "  (cond\n    [(empty? string) \"\"]\n\
    \    [(equal? (first string) (string-ref string 0)) (string-append (string-ref\
    \ string 0) (string-ref string 1))]\n    [else (string-append (string-ref string\
    \ 0) (string-ref string 1))]))\n", "  (let loop ((string string)\n           \
    \  (result '()))\n    (if (string-empty? string)\n        result\n        (loop\
    \ (substring string 0 1)\n              (cons (char->string (char->integer char->char\
    \ (char->integer char->char (char->integer string)))) result)))))\n", "  (cond\n\
    \    [(empty? string) \"\"]\n    [(equal? (first string) (string-ref string 0))\
    \ (string-append (string-ref string 0) (string-ref string 1))]\n    [else (string-append\
    \ (string-ref string 0) (string-ref string 1))]))\n", "  (define (helper string\
    \ result)\n    (if (string-empty? string)\n        result\n        (helper (substring\
    \ string 0 1) (append result (string-append (substring string 1 string) (substring\
    \ string 0 1))))\n      )\n    )\n  (helper string '())\n  )\n", "  (define (helper\
    \ string index result)\n    (cond [(< index 0) result]\n          [(char=? (char-code\
    \ string) (char-code (char-code (substring string 0 index)))) (helper (substring\
    \ string (1+ (index)) (length string)) (+ index 1) (append result (substring string\
    \ 0 index)))]\n          [else (helper (substring string (1+ (index)) (length\
    \ string)) (+ index 1) result)]))\n  (helper string 0 '()))\n", "  (let loop ((string\
    \ string) (result '()))\n    (if (string-empty? string)\n        result\n    \
    \    (loop (substring string 0 1)\n              (cons (char->upper-case\n   \
    \                    (char->lower-case (string-ref string 0))))\n            \
    \  (loop (substring string 1 string-length (length string))\n                \
    \    result))))))\n", "  (let ((lower (string->list string)))\n    (map (lambda\
    \ (char)\n           (if (char->char? char)\n               (char->string (char->char\
    \ (char->string char)))\n               (char->string (char->char (char->string\
    \ char))))\n           lower)\n         string)))\n", "  (define (helper string\
    \ result)\n    (if (string-empty? string)\n        result\n        (helper (substring\
    \ string 0 1)\n                (cond [(char=? (first string) (char->integer ?A))\
    \ (cons ?A result)\n                       (char=? (first string) (char->integer\
    \ ?B)) (cons ?B result)\n                       (char=? (first string) (char->integer\
    \ ?C)) (cons ?C result)\n                       (char=? (first string) (char->integer\
    \ ?D)) (cons ?D result)\n                       (char=? (first string) (char->integer\
    \ ?E)) (cons ?E result)\n                       (char=? (first string) (char->integer\
    \ ?F)) (cons ?F result)\n                       (char=? (first string) (char->integer\
    \ ?G)) (cons ?G result)\n                       (char=? (first string) (char->integer\
    \ ?H)) (cons ?H result)\n                       (char=? (first string) (char->integer\
    \ ?I)) (cons ?I result)\n                       (char=? (first string) (char->integer\
    \ ?J)) (cons ?J result)\n                       (char=? (first string) (char->integer\
    \ ?K)) (cons ?K result)\n                       (char=? (first string) (char->integer\
    \ ?L)) (cons ?L result)\n                       (char=? (first string) (char->integer\
    \ ?M)) (cons ?M result)\n                       (char=? (first string) (char->integer\
    \ ?N)) (cons ?N result)\n                       (char=? (first string) (char->integer\
    \ ?O)) (cons ?O result)\n                       (char=? (first string) (char->integer\
    \ ?P)) (cons ?P result)\n                       (char=? (first string) (char->integer\
    \ ?Q)) (cons ?Q result)\n                       (char=? (first string) (char->integer\
    \ ?R)) (cons ?R result)\n                       (char=? (first string) (char->integer\
    \ ?S)) (cons ?S result)\n                       (char=? (first string) (char->integer\
    \ ?T)) (cons ?T result)\n                       (char=? (first string) (char->integer\
    \ ?U)) (cons ?U result)\n                       (char=? (first string) (char->integer\
    \ ?V)) (cons ?V result)\n                       (char=? (first string) (char->integer\
    \ ?W)) (cons ?W result)\n                       (char", "  (cond\n    [(empty?\
    \ string) string]\n    [(equal? (first string) (string-ref string 0)) (string-append\
    \ (make-string (string-length string) (char->string #\\A)) (string-append (make-string\
    \ (string-length string) (char->string #\\a)) (string-append (make-string (string-length\
    \ string) (char->string #\\B)) (string-append (make-string (string-length string)\
    \ (char->string #\\b)) (string-append (make-string (string-length string) (char->string\
    \ #\\C)) (string-append (make-string (string-length string) (char->string #\\\
    c)) (string-append (make-string (string-length string) (char->string #\\D)) (string-append\
    \ (make-string (string-length string) (char->string #\\d)) (string-append (make-string\
    \ (string-length string) (char->string #\\E)) (string-append (make-string (string-length\
    \ string) (char->string #\\e)) (string-append (make-string (string-length string)\
    \ (char->string #\\F)) (string-append (make-string (string-length string) (char->string\
    \ #\\f)) (string-append (make-string (string-length string) (char->string #\\\
    G)) (string-append (make-string (string-length string) (char->string #\\g)) (string-append\
    \ (make-string (string-length string) (char->string #\\H)) (string-append (make-string\
    \ (string-length string) (char->string #\\h)) (string-append (make-string (string-length\
    \ string) (char->string #\\I)) (string-append (make-string (string-length string)\
    \ (char->string #\\i)) (string-append (make-string (string-length string) (char->string\
    \ #\\J)) (string-append (make-string (string-length string) (char->string #\\\
    j)) (string-append (make-string (string-length string) (char->string #\\K)) (string-append\
    \ (make-string (string-length string) (char->string #\\k)) (string-append (make-string\
    \ (string-length string) (char->string #\\L)) (string-append (make-string (string-length\
    \ string) (char->string #\\l)) (string-append (make-string (string-length string)\
    \ (char->string #\\M)) (string-append (make-string (string-length string) (char->string\
    \ #\\m)) (string-append (make-string (string-length string) (char->string #\\\
    N)) (string-append (make-", "  (cond\n    [(empty? string) string]\n    [(equal?\
    \ (first string) (string-ref string 0)) (string-append (string-ref string 1) (string-ref\
    \ string 0))]\n    [else (string-append (string-ref string 0) (string-ref string\
    \ 1))]))\n", "  (cond\n    [(empty? string) \"\"]\n    [(equal? (first string)\
    \ (string-ref string 0)) (string-append (string-ref string 0) (string-ref string\
    \ 1))]\n    [else (string-append (string-ref string 0) (string-ref string 1))]))\n",
  "  (let ((lower (string->list string)))\n    (map (lambda (x)\n           (if (string=?\
    \ (string->string x) \"A\")\n               (string->string \"a\")\n         \
    \      (string->string \"A\")))\n         lower)))\n", "  (cond\n    [(empty?\
    \ string) string]\n    [(equal? (first string) (string-ref string 0)) (string-append\
    \ (make-string (string-length string) (char->string #\\U)) (string-reverse (substring\
    \ (second string) 1)))]\n    [else (string-append (make-string (string-length\
    \ string) (char->string #\\L)) (string-reverse (substring (second string) 1)))]))\n",
  "  (define (helper char)\n    (if (char-lower? char)\n        (char-upper? char)\n\
    \        char))\n  (define (helper string)\n    (if (null? string)\n        '()\n\
    \        (cons (helper (car string))\n              (helper (cdr string)))))\n\
    \  (helper string))\n", "  (define (helper char str)\n    (if (char? char)\n \
    \       (if (char=? char #\\A)\n            (helper (char->string #\\Z) str)\n\
    \            (helper (char->string #\\z) str))\n        str))\n  (helper (char->string\
    \ #\\A) string))\n", "  (cond\n    [(empty? string) \"\"]\n    [(equal? (first\
    \ string) (string-ref string 0)) (string-append \"-\" (second string))]\n    [else\
    \ (string-append \"-\" (second string) (flip_case (rest string)))]))\n", "  (define\
    \ (helper string result)\n    (if (string-empty? string)\n        result\n   \
    \     (helper (substring string 0 1)\n                (cond [(char=? (char-code\
    \ string) 97) (concat result (char->string (char->integer 97)))]\n           \
    \           [(char=? (char-code string) 65) (concat result (char->string (char->integer\
    \ 65)))]\n                      [else (concat result (char->string (char->integer\
    \ char-code string))))])))\n  (helper string \"\"))\n", "  (cond\n    [(empty?\
    \ string) string]\n    [(equal? (first string) (string-ref string 0)) (string-append\
    \ (make-string (string-length string) ?A) (make-string (string-length string)\
    \ ?B))]\n    [else (string-append (make-string (string-length string) ?A) (make-string\
    \ (string-length string) ?B))]))\n", "  (let ((chars (string->list string)))\n\
    \    (map (lambda (c) (if (char=? c #\\a) (char-code c) (char-code #\\A))) chars)))\n",
  "  (define (helper char)\n    (cond\n      [(char-lower-case? char) (char-upper-case?\
    \ char) (char-lower-case? char)]\n      [(char-upper-case? char) (char-lower-case?\
    \ char) (char-upper-case? char)]\n      [else char]))\n  (apply map helper string))\n",
  "  (cond\n    [(empty? string) \"\"]\n    [(equal? (first string) (string-ref string\
    \ 0)) (string-append (string-ref string 0) (string-ref string 1))]\n    [else\
    \ (string-append (string-ref string 0) (string-ref string 1))]))\n", "  (define\
    \ (helper string result)\n    (if (string-empty? string)\n        result\n   \
    \     (helper (substring string 0 1)\n                (cond [(char=? (first string)\
    \ 'a)\n                       (cond [(char=? (first string) 'A)\n            \
    \                  (cond [(char=? (first string) 'a)\n                       \
    \              ('A)]\n                               [(char=? (first string) 'A)\n\
    \                                    (cond [(char=? (first string) 'a)\n     \
    \                                      'a]]\n                                \
    \       [(char=? (first string) 'A)\n                                        \
    \   'A]])]\n                               [(char=? (first string) 'a)\n     \
    \                               (cond [(char=? (first string) 'A)\n          \
    \                                 'A]]\n                                     \
    \  [(char=? (first string) 'a)\n                                           'a]])]\n\
    \                               [(char=? (first string) 'A)\n                \
    \                    (cond [(char=? (first string) 'a)\n                     \
    \                      'a]]\n                                       [(char=? (first\
    \ string) 'A)\n                                           'A]])]\n           \
    \                    [(char=? (first string) 'a)\n                           \
    \         (cond [(char=? (first string) 'A)\n                                \
    \           'A]]\n                                       [(char=? (first string)\
    \ 'A)\n                                           'a]])]\n                   \
    \            [(char=? (first string) 'A)\n                                   \
    \ (cond [(char=? (first string) 'a)\n                                        \
    \   'a]]\n                                       [(char=? (first string) 'A)\n\
    \                                           'A]])]\n                         \
    \      [(char=? (first string) 'a)\n                                    (cond\
    \ [(char=? (first string) 'A)\n                                           'A]]\n\
    \                                       [(char=? (first string) 'A)\n        \
    \                                   'a]])]\n                               [(char=?\
    \ (first string) 'A)\n                                    (cond [(char=? (first\
    \ string) 'a)\n                                           'a]]\n             \
    \                          [(char=? (first string) 'A)\n                     \
    \                      'A]])]\n                               [(char=? (first\
    \ string) 'a)\n                                    (cond [(char=? (first string)\
    \ 'A)\n                                           'A]]\n                     \
    \                  [(char=? (first string) 'A)\n                             \
    \              'a]])]\n                               [(char=? (first string)\
    \ 'A)\n                                    (cond [(char=? (first string) 'a)\n\
    \                                           'a]]\n                           \
    \            [(char=? (first string) 'A)\n                                   \
    \        'A]])]\n                               [(char=? (first string) 'a)\n\
    \                                    (cond [(char=? (", "  (let ((lower (string->list\
    \ string)))\n    (map (lambda (x)\n           (if (string=? x #\\a)\n        \
    \       (string=? (string->list x) #\\A)\n               (string=? (string->list\
    \ x) #\\a)))\n         lower)))\n", "  (define (helper string result)\n    (if\
    \ (string-empty? string)\n        result\n        (helper (substring string 0\
    \ 1) (append result (substring string 1 string)))))\n  (helper string '()))\n",
  "  (cond\n    [(string-length string) string]\n    [else (cons (char->string\n \
    \                 (if (char->lower-case? #\\a)\n                      #\\A\n \
    \                     #\\z))\n              (flip_case (string-tail string)))]))\n",
  "  (cond\n    [(empty? string) string]\n    [(equal? (first string) (string-ref\
    \ string 0)) (string-append (string-ref string 0) (string-ref string 1))]\n  \
    \  [else (string-append (string-ref string 0) (string-ref string 1))]))\n", " \
    \ (define (helper string result)\n    (if (string-empty? string)\n        result\n\
    \        (helper (substring string 0 1)\n                (cond [(char=? (first\
    \ string) 'a)\n                       (cond [(char=? (first string) 'A)\n    \
    \                          (cond [(char=? (first string) 'a)\n               \
    \                       (cond [(char=? (first string) 'A)\n                  \
    \                            (cond [(char=? (first string) 'A)\n             \
    \                                         (cond [(char=? (first string) 'a)\n\
    \                                                              (cond [(char=?\
    \ (first string) 'A)\n                                                       \
    \            result\n                                                        \
    \         (cond [(char=? (first string) 'a)\n                                \
    \                                          (cond [(char=? (first string) 'A)\n\
    \                                                                            \
    \      (cond [(char=? (first string) 'a)\n                                   \
    \                                                       result\n             \
    \                                                                            \
    \ (cond [(char=? (first string) 'A)\n                                        \
    \                                                          (cond [(char=? (first\
    \ string) 'a)\n                                                              \
    \                                            result\n                        \
    \                                                                            \
    \      (cond [(char=? (first string) 'A)\n                                   \
    \                                                                            \
    \   (cond [(char=? (first string) 'a)\n                                      \
    \                                                                            \
    \        result\n                                                            \
    \                                                              result\n      \
    \                                                                            \
    \                                        result\n                            \
    \                                                                            \
    \                  result\n                                                  \
    \                                                                        result\n\
    \                                                                            \
    \                                              result\n                      \
    \                                                                            \
    \                        result\n                                            \
    \                                                                            \
    \  result\n                                                                  \
    \                                                        result\n            \
    \                                                                            \
    \                                  result\n                                  \
    \                                                                            \
    \            result\n                                                        \
    \                                                                  result\n  \
    \                                                                            \
    \                                            result\n                        \
    \                                                                            \
    \                      result\n                                              \
    \                                                                            result\n\
    \                                                                            \
    \                                              result\n                      \
    \                                                                            \
    \                        result\n                                            \
    \                                                                            \
    \  result\n                                                                  \
    \                                                        result\n            \
    \                                                                            \
    \                                  result\n                                  \
    \                                                                            \
    \            result\n                                                        \
    \                                                                  result\n  \
    \                                                                            \
    \                                            result\n                        \
    \                                                                            \
    \                      result\n                                              \
    \                                                                            result\n\
    \                                                                            \
    \                                              result\n                      \
    \                                                                            \
    \                        result\n                                            \
    \                                                                            \
    \  result\n                                                                  \
    \                                                        result\n            \
    \                                                                            \
    \                                  result\n                                  \
    \                                                                            \
    \            result\n                                                        \
    \                                                                  result\n  \
    \                                                                            \
    \                                            result\n                        \
    \                                                                            \
    \                      result\n                                              \
    \                                                                            result\n\
    \                                                                            \
    \                                              result\n                      \
    \                                                                            \
    \                        result\n                                            \
    \                                                                            \
    \  result\n                                                                  \
    \                                                        result\n            \
    \                                                                            \
    \                                  result\n                                  \
    \                                                                            \
    \            result\n                                                        \
    \                                                                  result\n  \
    \                                                                            \
    \                                            result\n                        \
    \                                                                            \
    \                      result\n                                              \
    \                                                                            result\n\
    \                                                                            \
    \                                              result\n                      \
    \                                                                            \
    \                        result\n                                            \
    \                                                                            \
    \  result\n                                                                  \
    \                                                        result\n            \
    \                                                                            \
    \                                  result\n                                  \
    \                                                                            \
    \            result\n                                                        \
    \                                                                  result\n  \
    \                                                                            \
    \                                            result\n                        \
    \                                                                            \
    \                      result\n                                              \
    \                                                                            result\n\
    \                                                                            \
    \                                              result\n                      \
    \                                                                            \
    \                        result\n                                            \
    \                                                                            \
    \  result\n                                                                  \
    \                                                        result\n            \
    \                                                                            \
    \                                  result\n                                  \
    \                                                                            \
    \            result\n                                                        \
    \                                                                  result\n  \
    \                                                                            \
    \                                            result\n                        \
    \                                                                            \
    \                      result\n                                              \
    \                                                                            result\n\
    \                                                                            \
    \                                              result\n                      \
    \                                                                            \
    \                        result\n                                            \
    \                                                                            \
    \  result\n                                                                  \
    \                                                        ", "  (cond\n    [(empty?\
    \ string) string]\n    [(equal? (first string) (string-ref string 0)) (string-append\
    \ (make-string (string-length string) (char->string #\\U)) (string-append (make-string\
    \ (string-length string) (char->string #\\L)) (string-append (make-string (string-length\
    \ string) (char->string #\\l)) (string-append (make-string (string-length string)\
    \ (char->string #\\u)) (string-append (make-string (string-length string) (char->string\
    \ #\\U)) (string-append (make-string (string-length string) (char->string #\\\
    l)) (string-append (make-string (string-length string) (char->string #\\u)) (string-append\
    \ (make-string (string-length string) (char->string #\\l)) (string-append (make-string\
    \ (string-length string) (char->string #\\u)) (string-append (make-string (string-length\
    \ string) (char->string #\\L)) (string-append (make-string (string-length string)\
    \ (char->string #\\l)) (string-append (make-string (string-length string) (char->string\
    \ #\\u)) (string-append (make-string (string-length string) (char->string #\\\
    L)) (string-append (make-string (string-length string) (char->string #\\l)) (string-append\
    \ (make-string (string-length string) (char->string #\\u)) (string-append (make-string\
    \ (string-length string) (char->string #\\L)) (string-append (make-string (string-length\
    \ string) (char->string #\\l)) (string-append (make-string (string-length string)\
    \ (char->string #\\u)) (string-append (make-string (string-length string) (char->string\
    \ #\\L)) (string-append (make-string (string-length string) (char->string #\\\
    l)) (string-append (make-string (string-length string) (char->string #\\u)) (string-append\
    \ (make-string (string-length string) (char->string #\\L)) (string-append (make-string\
    \ (string-length string) (char->string #\\l)) (string-append (make-string (string-length\
    \ string) (char->string #\\u)) (string-append (make-string (string-length string)\
    \ (char->string #\\L)) (string-append (make-string (string-length string) (char->string\
    \ #\\l)) (string-append (make-string (string-length string) (char->string #\\\
    u)) (string-append (make-string (string-length string) (", "  (cond\n    [(empty?\
    \ string) \"\"]\n    [(equal? (first string) (string-ref string 0)) (string-append\
    \ \"-\" (second string))]\n    [else (string-append \"-\" (second string) (flip_case\
    \ (string-tail string)))]))\n", "  (let loop ((string string) (result '()))\n\
    \    (cond ((null? string) result)\n          ((char-lower? (car string)) (loop\
    \ (cdr string) (cons (char-upper? (car string)) result)))\n          ((char-upper?\
    \ (car string)) (loop (cdr string) (cons (char-lower? (car string)) result)))\n\
    \          (else (loop (cdr string) (cons (car string) result))))))\n", "  (let\
    \ ((result '()))\n    (for ([i (in-range (length string) )])\n      (if (char=?\
    \ (char-code string i) 'a)\n          (set! result (append result 'A))\n     \
    \     (set! result (append result 'a)))\n      (set! result (append result (char-code\
    \ string i))))\n    result))\n", "  (cond\n    [(empty? string) \"\"]\n    [(equal?\
    \ (first string) (string-ref string 0)) (string-append (string-ref string 1) (string-ref\
    \ string 0))]\n    [else (string-append (string-ref string 0) (string-append (string-ref\
    \ string 1) (string-ref string 0)))]))\n", "  (cond\n    [(empty? string) string]\n\
    \    [(equal? (first string) (string-ref string 0)) (string-append (substring\
    \ (second string) 0 1) (string-append (substring (first string) 1 0) (substring\
    \ (second string) 0 1)))]\n    [else (string-append (substring (second string)\
    \ 0 1) (string-append (substring (first string) 1 0) (substring (second string)\
    \ 0 1)))]))\n", "  (define (helper string result)\n    (if (string-empty? string)\n\
    \        result\n        (helper (substring string 0 1)\n                (cond\
    \ [(char=? (char-code string) 97) (char-code (substring string 1 -1))\n      \
    \                 (char-code (substring string 0 -1))\n                      \
    \ (char-code (substring string 1 -1))\n                       (char-code (substring\
    \ string 0 -1))\n                       (char-code (substring string 0 -1))\n\
    \                       (char-code (substring string 0 -1))\n                \
    \       (char-code (substring string 0 -1))\n                       (char-code\
    \ (substring string 0 -1))\n                       (char-code (substring string\
    \ 0 -1))\n                       (char-code (substring string 0 -1))\n       \
    \                (char-code (substring string 0 -1))\n                       (char-code\
    \ (substring string 0 -1))\n                       (char-code (substring string\
    \ 0 -1))\n                       (char-code (substring string 0 -1))\n       \
    \                (char-code (substring string 0 -1))\n                       (char-code\
    \ (substring string 0 -1))\n                       (char-code (substring string\
    \ 0 -1))\n                       (char-code (substring string 0 -1))\n       \
    \                (char-code (substring string 0 -1))\n                       (char-code\
    \ (substring string 0 -1))\n                       (char-code (substring string\
    \ 0 -1))\n                       (char-code (substring string 0 -1))\n       \
    \                (char-code (substring string 0 -1))\n                       (char-code\
    \ (substring string 0 -1))\n                       (char-code (substring string\
    \ 0 -1))\n                       (char-code (substring string 0 -1))\n       \
    \                (char-code (substring string 0 -1))\n                       (char-code\
    \ (substring string 0 -1))\n                       (char-code (substring string\
    \ 0 -1))\n                       (char-code (substring string 0 -1))\n       \
    \                (char-code (substring string 0 -1))\n                       (char-code\
    \ (substring string 0 -1))\n                       (char-code (substring string\
    \ 0 -1))\n                       (char-code (substring string 0 -1))\n       \
    \                (char-code (substring string 0 -1))\n                       (char-code\
    \ (substring string 0 -1))\n                       (char-code (substring string\
    \ 0 -1))\n                       (char-code (substring string 0 -1))\n       \
    \                (char-code (substring string 0 -1))\n                       (char-code\
    \ (sub", "  (let loop ((string string) (result '()))\n    (if (string-empty? string)\n\
    \        result\n        (loop (substring string 0 1) (cons (char->upper-case\n\
    \                                           (char->lower-case (first string)))\
    \ result)))))\n", "  (define (helper string index result)\n    (cond [(empty?\
    \ string) result]\n          [(char-lower? (car string)) (helper (cdr string)\
    \ (+ index 1) (cons (char-upper? (car string)) result))]\n          [else (helper\
    \ (cdr string) (+ index 1) result)]))\n  (helper string 0 '()))\n", "  (cond\n\
    \    [(empty? string) \"\"]\n    [(equal? (first string) (string-ref string 0))\
    \ (string-append (make-string (string-length string) (char->string #\\U)) (string-reverse\
    \ (substring (second string) 1)))]\n    [else (string-append (make-string (string-length\
    \ string) (char->string #\\L)) (string-reverse (substring (second string) 1)))]))\n",
  "  (define (helper string)\n    (cond\n      [(empty? string) string]\n      [(char-lower?\
    \ (first string)) (helper (rest string))\n       (char-upper? (first string))\
    \ (helper (rest string))\n       (char-upper? (first string)) (helper (rest string))\n\
    \       (char-lower? (first string)) (helper (rest string))\n       (char-lower?\
    \ (first string)) (helper (rest string))\n       (char-upper? (first string))\
    \ (helper (rest string))\n       (char-upper? (first string)) (helper (rest string))\n\
    \       (char-lower? (first string)) (helper (rest string))\n       (char-lower?\
    \ (first string)) (helper (rest string))\n       (char-upper? (first string))\
    \ (helper (rest string))\n       (char-upper? (first string)) (helper (rest string))\n\
    \       (char-lower? (first string)) (helper (rest string))\n       (char-lower?\
    \ (first string)) (helper (rest string))\n       (char-upper? (first string))\
    \ (helper (rest string))\n       (char-upper? (first string)) (helper (rest string))\n\
    \       (char-lower? (first string)) (helper (rest string))\n       (char-lower?\
    \ (first string)) (helper (rest string))\n       (char-upper? (first string))\
    \ (helper (rest string))\n       (char-upper? (first string)) (helper (rest string))\n\
    \       (char-lower? (first string)) (helper (rest string))\n       (char-lower?\
    \ (first string)) (helper (rest string))\n       (char-upper? (first string))\
    \ (helper (rest string))\n       (char-upper? (first string)) (helper (rest string))\n\
    \       (char-lower? (first string)) (helper (rest string))\n       (char-lower?\
    \ (first string)) (helper (rest string))\n       (char-upper? (first string))\
    \ (helper (rest string))\n       (char-upper? (first string)) (helper (rest string))\n\
    \       (char-lower? (first string)) (helper (rest string))\n       (char-lower?\
    \ (first string)) (helper (rest string))\n       (char-upper? (first string))\
    \ (helper (rest string))\n       (char-upper? (first string)) (helper (rest string))\n\
    \       (char-lower? (first string)) (helper (rest string))\n       (char-lower?\
    \ (first string)) (helper (rest string", "  (let ((result '()))\n    (for ([i\
    \ (in-range (length string) -1)])\n      (let ((char (char-ref string i)))\n \
    \       (if (char >= 'A' char 'Z)\n            (set! result (append result (char-code\
    \ (char - 'A'))))\n            (set! result (append result (char-code (char -\
    \ 'a')))))))\n    result))\n", "  (cond\n    [(string-length string) string]\n\
    \    [(equal? (char-code (string-ref string 0)) #\\A) (make-string (string-length\
    \ string) (char->string #\\A))]\n    [(equal? (char-code (string-ref string 0))\
    \ #\\a) (make-string (string-length string) (char->string #\\A))]\n    [(equal?\
    \ (char-code (string-ref string 0)) #\\b) (make-string (string-length string)\
    \ (char->string #\\B))]\n    [(equal? (char-code (string-ref string 0)) #\\c)\
    \ (make-string (string-length string) (char->string #\\C))]\n    [(equal? (char-code\
    \ (string-ref string 0)) #\\d) (make-string (string-length string) (char->string\
    \ #\\D))]\n    [(equal? (char-code (string-ref string 0)) #\\e) (make-string (string-length\
    \ string) (char->string #\\E))]\n    [(equal? (char-code (string-ref string 0))\
    \ #\\F) (make-string (string-length string) (char->string #\\F))]\n    [(equal?\
    \ (char-code (string-ref string 0)) #\\G) (make-string (string-length string)\
    \ (char->string #\\G))]\n    [(equal? (char-code (string-ref string 0)) #\\h)\
    \ (make-string (string-length string) (char->string #\\H))]\n    [(equal? (char-code\
    \ (string-ref string 0)) #\\I) (make-string (string-length string) (char->string\
    \ #\\I))]\n    [(equal? (char-code (string-ref string 0)) #\\j) (make-string (string-length\
    \ string) (char->string #\\J))]\n    [(equal? (char-code (string-ref string 0))\
    \ #\\k) (make-string (string-length string) (char->string #\\K))]\n    [(equal?\
    \ (char-code (string-ref string 0)) #\\l) (make-string (string-length string)\
    \ (char->string #\\L))]\n    [(equal? (char-code (string-ref string 0)) #\\m)\
    \ (make-string (string-length string) (char->string #\\M))]\n    [(equal? (char-code\
    \ (string-ref string 0)) #\\n) (make-string (string-length string) (char->string\
    \ #\\N))]\n    [(equal? (char-code (string-ref string 0)) #\\o) (make-string (string-length\
    \ string) (char->string #\\O))]\n    [(equal? (char-code ", "  (cond\n    [(empty?\
    \ string) \"\"]\n    [(equal? (first string) (string-ref string 0)) (string-append\
    \ (string-ref string 0) (string-ref string 1))]\n    [else (string-append (string-ref\
    \ string 0) (string-ref string 1))]))\n", "  (cond\n    [(string-empty? string)\
    \ string]\n    [(equal? (char-code (string-ref string 0)) #\\A) (make-string (string-length\
    \ string) (char->string #\\A))]\n    [(equal? (char-code (string-ref string 0))\
    \ #\\a) (make-string (string-length string) (char->string #\\A))]\n    [(equal?\
    \ (char-code (string-ref string 0)) #\\b) (make-string (string-length string)\
    \ (char->string #\\B))]\n    [(equal? (char-code (string-ref string 0)) #\\c)\
    \ (make-string (string-length string) (char->string #\\C))]\n    [(equal? (char-code\
    \ (string-ref string 0)) #\\d) (make-string (string-length string) (char->string\
    \ #\\D))]\n    [(equal? (char-code (string-ref string 0)) #\\e) (make-string (string-length\
    \ string) (char->string #\\E))]\n    [(equal? (char-code (string-ref string 0))\
    \ #\\F) (make-string (string-length string) (char->string #\\F))]\n    [(equal?\
    \ (char-code (string-ref string 0)) #\\G) (make-string (string-length string)\
    \ (char->string #\\G))]\n    [(equal? (char-code (string-ref string 0)) #\\H)\
    \ (make-string (string-length string) (char->string #\\H))]\n    [(equal? (char-code\
    \ (string-ref string 0)) #\\I) (make-string (string-length string) (char->string\
    \ #\\I))]\n    [(equal? (char-code (string-ref string 0)) #\\J) (make-string (string-length\
    \ string) (char->string #\\J))]\n    [(equal? (char-code (string-ref string 0))\
    \ #\\K) (make-string (string-length string) (char->string #\\K))]\n    [(equal?\
    \ (char-code (string-ref string 0)) #\\L) (make-string (string-length string)\
    \ (char->string #\\L))]\n    [(equal? (char-code (string-ref string 0)) #\\M)\
    \ (make-string (string-length string) (char->string #\\M))]\n    [(equal? (char-code\
    \ (string-ref string 0)) #\\N) (make-string (string-length string) (char->string\
    \ #\\N))]\n    [(equal? (char-code (string-ref string 0)) #\\O) (make-string (string-length\
    \ string) (char->string #\\O))]\n    [(equal? (char", "  (cond\n    [(empty? string)\
    \ \"\"]\n    [(equal? (first string) (string-ref string 0)) (string-append \"\
    -\" (second string))]\n    [else (string-append \"-\" (first string) (second string))]))\n",
  "  (cond\n    [(empty? string) string]\n    [(equal? (first string) (string-ref\
    \ string 0)) (string-append (string-ref string 0) (string-ref string 1))]\n  \
    \  [else (string-append (string-ref string 0) (string-ref string 1))]))\n", " \
    \ (cond\n    [(empty? string) string]\n    [(equal? (first string) (string-ref\
    \ string 0)) (string-append (make-string (string-length string) ?A) (make-string\
    \ (string-length string) ?B))]\n    [else (string-append (make-string (string-length\
    \ string) ?A) (make-string (string-length string) ?B) (flip_case (rest string)))]))\n",
  "  (let ((result '()))\n    (for ((i 0 (+ i 1))) (cond ((char=? string #\\A) (set!\
    \ result (append result #\\A))\n                                     (char=? string\
    \ #\\a) (set! result (append result #\\A))\n                                 \
    \    (char=? string #\\B) (set! result (append result #\\B))\n               \
    \                      (char=? string #\\b) (set! result (append result #\\B))\n\
    \                                     (char=? string #\\C) (set! result (append\
    \ result #\\C))\n                                     (char=? string #\\c) (set!\
    \ result (append result #\\C))\n                                     (char=? string\
    \ #\\D) (set! result (append result #\\D))\n                                 \
    \    (char=? string #\\d) (set! result (append result #\\D))\n               \
    \                      (char=? string #\\E) (set! result (append result #\\E))\n\
    \                                     (char=? string #\\e) (set! result (append\
    \ result #\\E))\n                                     (char=? string #\\F) (set!\
    \ result (append result #\\F))\n                                     (char=? string\
    \ #\\f) (set! result (append result #\\F))\n                                 \
    \    (char=? string #\\G) (set! result (append result #\\G))\n               \
    \                      (char=? string #\\g) (set! result (append result #\\G))\n\
    \                                     (char=? string #\\H) (set! result (append\
    \ result #\\H))\n                                     (char=? string #\\h) (set!\
    \ result (append result #\\H))\n                                     (char=? string\
    \ #\\I) (set! result (append result #\\I))\n                                 \
    \    (char=? string #\\i) (set! result (append result #\\I))\n               \
    \                      (char=? string #\\J) (set! result (append result #\\J))\n\
    \                                     (char=? string #\\j) (set! result (append\
    \ result #\\J))\n                                     (char=? string #\\K) (set!\
    \ result (append result #\\K))\n                                     (char=? string\
    \ #\\k) (set! result (append result #\\K))\n                                 \
    \    (char=? string #\\L) (set! result (append result #\\L))\n               \
    \                      (char=? string #\\l) (set! result (append result ", " \
    \ (let ((result '()))\n    (for ((i (length string))\n           (char string))\n\
    \      (if (char-lower? (char i))\n          (set! result (append result (list\
    \ char-upper? (char i))))\n          (set! result (append result (list char-lower?\
    \ (char i))))))))\n", "  (cond\n    [(empty? string) \"\"]\n    [(equal? (first\
    \ string) (string-ref string 0)) (string-append (string-ref string 0) (string-ref\
    \ string 1))]\n    [else (string-append (string-ref string 0) (string-ref string\
    \ 1))]))\n", "  (cond\n    [(empty? string) \"\"]\n    [(equal? (first string)\
    \ (string-ref string 0)) (string-append (string-ref string 0) (string-ref string\
    \ 1))]\n    [else (string-append (string-ref string 0) (string-ref string 1))]))\n",
  "  (let ([lower (string->list string)])\n    (map (lambda (x)\n           (if (string=?\
    \ x #\\a)\n               (string=? (string->list x) #\\A)\n               (string=?\
    \ (string->list x) #\\a)))\n         lower)))\n", "  (let ((chars (string->list\
    \ string)))\n    (map (lambda (c)\n           (if (char=? c #\\a)\n          \
    \     (char-upper-case c)\n               (char-lower-case c)))\n         chars)))\n",
  "  (let loop ((string string)\n             (result '()))\n    (cond [(empty? string)\
    \ result]\n          [(char-lower? (car string)) (loop (cdr string) (cons (char-upper?\
    \ (car string)) result))]\n          [(char-upper? (car string)) (loop (cdr string)\
    \ (cons (char-lower? (car string)) result))]\n          [else (loop (cdr string)\
    \ (cons (car string) result))]))\n  result)\n", "  (let ((lower (string->list\
    \ string)))\n    (map (lambda (x)\n           (if (string=? x #\\a)\n        \
    \       (string=? (string->list x) #\\A)\n               (string=? (string->list\
    \ x) #\\a)))\n         lower)\n    (string->list string)))\n", "  (define (helper\
    \ string result)\n    (if (string-empty? string)\n        result\n        (helper\
    \ (substring string 0 1)\n                (cond [(char=? (char-code string) 97)\
    \ (char-code (substring string 0 1) #\\A)\n                       (char=? (char-code\
    \ string) 65) (char-code (substring string 0 1) #\\A)\n                      \
    \ (char=? (char-code string) 97) (char-code (substring string 0 1) #\\z)\n   \
    \                    (char=? (char-code string) 65) (char-code (substring string\
    \ 0 1) #\\z)\n                       (char=? (char-code string) 32) (char-code\
    \ (substring string 0 1) #\\z)\n                       (char=? (char-code string)\
    \ 9) (char-code (substring string 0 1) #\\z)\n                       (char=? (char-code\
    \ string) 32) (char-code (substring string 0 1) #\\z)\n                      \
    \ (char=? (char-code string) 10) (char-code (substring string 0 1) #\\z)\n   \
    \                    (char=? (char-code string) 13) (char-code (substring string\
    \ 0 1) #\\z)\n                       (char=? (char-code string) 32) (char-code\
    \ (substring string 0 1) #\\z)\n                       (char=? (char-code string)\
    \ 34) (char-code (substring string 0 1) #\\z)\n                       (char=?\
    \ (char-code string) 39) (char-code (substring string 0 1) #\\z)\n           \
    \            (char=? (char-code string) 47) (char-code (substring string 0 1)\
    \ #\\z)\n                       (char=? (char-code string) 58) (char-code (substring\
    \ string 0 1) #\\z)\n                       (char=? (char-code string) 64) (char-code\
    \ (substring string 0 1) #\\z)\n                       (char=? (char-code string)\
    \ 91) (char-code (substring string 0 1) #\\z)\n                       (char=?\
    \ (char-code string) 96) (char-code (substring string 0 1) #\\z)\n           \
    \            (char=? (char-code string) 122) (char-code (substring string 0 1)\
    \ #\\z)\n                       (char=? (char-code string) 126) (char-code (substring\
    \ string 0 1) #\\z)\n                       (char=? (char-code string) ", "  (cond\n\
    \    [(empty? string) string]\n    [(equal? (first string) (string-ref string\
    \ 0)) (string-append (string-ref string 0) (string-ref string 1))]\n    [else\
    \ (string-append (string-ref string 0) (string-ref string 1))]))\n", "  (cond\n\
    \    [(empty? string) string]\n    [(equal? (first string) (string-ref string\
    \ 0)) (string-append (make-string (string-length string) ?A) (make-string (string-length\
    \ string) ?B))]\n    [else (string-append (make-string (string-length string)\
    \ ?A) (make-string (string-length string) ?B))]))\n", "  (define (helper string\
    \ result)\n    (if (string-empty? string)\n        result\n        (helper (substring\
    \ string 0 1) (append result (list string)))))\n  (helper string '()))\n", " \
    \ (cond\n    [(empty? string) string]\n    [(equal? (first string) (string-ref\
    \ string 0)) (string-append (substring string 1) (substring string 0))]\n    [else\
    \ (string-append (substring string 1) (substring string 0))]))\n", "  (define\
    \ (helper string result)\n    (if (string-empty? string)\n        result\n   \
    \     (helper (substring string 0 1)\n                (if (char-lower-case? string)\n\
    \                    (cons (char-upper-case? string) result)\n               \
    \     (cons string result))))\n    (helper (substring string 1 string.length)\n\
    \            '()))\n  (helper string '()))\n", "  (define (helper string result)\n\
    \    (cond\n      [(empty? string) result]\n      [(char-lower? (first string))\
    \ (helper (rest string) (cons (first string) result))]\n      [(char-upper? (first\
    \ string)) (helper (rest string) (cons (first string) result))]\n      [else (helper\
    \ (rest string) (cons (first string) (cons (first string) result)))]))\n  (helper\
    \ string '()))\n", "  (let ((result '()))\n    (for ([i (in-range (string-length\
    \ string))])\n      (let ((char (string->char (substring string i i))))\n    \
    \    (if (char >= 'A' char <= 'Z')\n            (set! result (append result (char->string\
    \ (char - 'A' + 'a'))))\n            (set! result (append result (char->string\
    \ (char - 'a' + 'A')))))))\n    result))\n", "  (define (helper string result)\n\
    \    (cond\n      [(empty? string) result]\n      [(char-lower? (car string))\
    \ (helper (cdr string) (cons (char-upper? (car string)) result))]\n      [(char-upper?\
    \ (car string)) (helper (cdr string) (cons (char-lower? (car string)) result))]\n\
    \      [else (helper (cdr string) (cons (car string) result))]))\n  (helper string\
    \ '()))\n", "  (let ((chars (string->list string)))\n    (map (lambda (x)\n  \
    \         (if (char=? x #\\A)\n               (char-upper-case x)\n          \
    \     (char-lower-case x))\n             chars)\n         string)))\n", "  (let\
    \ ((chars (string->list string)))\n    (map (lambda (c)\n           (if (char=?\
    \ c #\\a)\n               (char-upper-case c)\n               (char-lower-case\
    \ c)))\n         chars)))\n", "  (cond\n    [(string-length string) string]\n\
    \    [else (string-append (substring string 0 (string-length string)) (substring\
    \ string (string-length string) (string-length string)))]))\n", "  (cond [(empty?\
    \ string) string]\n        [(equal? (first string) (string-ref string 0)) (string-append\
    \ (make-string (string-length string) (char->string #\\U)) (string-append (make-string\
    \ (string-length string) (char->string #\\L)) (substring (second string) 0 1)))]\n\
    \        [else (string-append (make-string (string-length string) (char->string\
    \ #\\U)) (string-append (make-string (string-length string) (char->string #\\\
    L)) (substring (second string) 0 1)))]))\n", "  (cond\n    [(string-empty? string)\
    \ \"\"]\n    [(equal? (char-code (car string)) #\\A) (upper-case (string-reverse\
    \ string))]\n    [else (string-append (upper-case (string-reverse string)) (lower-case\
    \ (string-reverse string)))]))\n", "  (define (helper string result)\n    (if\
    \ (string-empty? string)\n        result\n        (helper (substring string 0\
    \ 1) (append result (list (char->string (char->integer char->char (char->integer\
    \ char->char (char->integer char->char (char->integer char->char (char->integer\
    \ char->char (char->integer char->char (char->integer char->char (char->integer\
    \ char->char (char->integer char->char (char->integer char->char (char->integer\
    \ char->char (char->integer char->char (char->integer char->char (char->integer\
    \ char->char (char->integer char->char (char->integer char->char (char->integer\
    \ char->char (char->integer char->char (char->integer char->char (char->integer\
    \ char->char (char->integer char->char (char->integer char->char (char->integer\
    \ char->char (char->integer char->char (char->integer char->char (char->integer\
    \ char->char (char->integer char->char (char->integer char->char (char->integer\
    \ char->char (char->integer char->char (char->integer char->char (char->integer\
    \ char->char (char->integer char->char (char->integer char->char (char->integer\
    \ char->char (char->integer char->char (char->integer char->char (char->integer\
    \ char->char (char->integer char->char (char->integer char->char (char->integer\
    \ char->char (char->integer char->char (char->integer char->char (char->integer\
    \ char->char (char->integer char->char (char->integer char->char (char->integer\
    \ char->char (char->integer char->char (char->integer char->char (char->integer\
    \ char->char (char->integer char->char (char->integer char->char (char->integer\
    \ char->char (char->integer char->char (char->integer char->char (char->integer\
    \ char->char (char->integer char->char (char->integer char->char (char->integer\
    \ char->char (char->integer char->char (char->integer char->char (char->integer\
    \ char->char (char->integer char->char (char->integer char->char (char->integer\
    \ char->char (char->integer char->char (char->integer char->char (char->integer\
    \ char->char (char->integer char", "  (cond\n    [(empty? string) \"\"]\n    [(equal?\
    \ (first string) (string-ref string 0)) (string-append \"-\" (second string))]\n\
    \    [else (string-append \"-\" (second string) (flip_case (string-drop string\
    \ 1))) ]))\n", "  (define (helper string index result)\n    (cond [(< index 0)\
    \ result]\n          [(char=? (char-code string) (char-code (char-code (substring\
    \ string 0 index)))) (string-append result (char-code (char-code (substring string\
    \ 0 index))))]\n          [else (helper (substring string index (+ index 1)) index\
    \ (string-append result (char-code (char-code (substring string index (+ index\
    \ 1))))))]))\n  (helper string 0 (string-append string 'a)))\n", "  (cond [(empty?\
    \ string) string]\n        [(equal? (first string) (string-ref string 0)) (string-append\
    \ (make-string (string-length string) (char->string #\\U)) (string-append (make-string\
    \ (string-length string) (char->string #\\l)) (string-append (make-string (string-length\
    \ string) (char->string #\\L)) (string-append (make-string (string-length string)\
    \ (char->string #\\l)) (string-append (make-string (string-length string) (char->string\
    \ #\\L)) (string-append (make-string (string-length string) (char->string #\\\
    U)) (string-append (make-string (string-length string) (char->string #\\l)) (string-append\
    \ (make-string (string-length string) (char->string #\\L)) (string-append (make-string\
    \ (string-length string) (char->string #\\l)) (string-append (make-string (string-length\
    \ string) (char->string #\\L)) (string-append (make-string (string-length string)\
    \ (char->string #\\U)) (string-append (make-string (string-length string) (char->string\
    \ #\\l)) (string-append (make-string (string-length string) (char->string #\\\
    L)) (string-append (make-string (string-length string) (char->string #\\l)) (string-append\
    \ (make-string (string-length string) (char->string #\\L)) (string-append (make-string\
    \ (string-length string) (char->string #\\U)) (string-append (make-string (string-length\
    \ string) (char->string #\\l)) (string-append (make-string (string-length string)\
    \ (char->string #\\L)) (string-append (make-string (string-length string) (char->string\
    \ #\\l)) (string-append (make-string (string-length string) (char->string #\\\
    L)) (string-append (make-string (string-length string) (char->string #\\U)) (string-append\
    \ (make-string (string-length string) (char->string #\\l)) (string-append (make-string\
    \ (string-length string) (char->string #\\L)) (string-append (make-string (string-length\
    \ string) (char->string #\\l)) (string-append (make-string (string-length string)\
    \ (char->string #\\L)) (string-append (make-string (string-length string) (char->string\
    \ #\\U)) (string-append (make-string (string-length string) (char->string #\\\
    l)) (string-append ", "  (let loop ((string string) (result '()))\n    (cond\n\
    \      [(empty? string) result]\n      [(char-lower? (car string)) (loop (cdr\
    \ string) (cons (char-upper? (car string)) result))]\n      [else (loop (cdr string)\
    \ (cons (car string) result))]))\n</code>\n<|/ a tags=racket,scheme |>\n<| a tags=racket,scheme\
    \ |>\n<code>", "  (let loop ((string string) (result '()))\n    (cond ((null?\
    \ string) result)\n          ((char=? (car string) 'A) (loop (cdr string) (cons\
    \ (char->upper (car string)) result)))\n          ((char=? (car string) 'a) (loop\
    \ (cdr string) (cons (char->lower (car string)) result)))\n          (else (loop\
    \ (cdr string) (cons (car string) result))))))\n", "  (cond\n    [(string-empty?\
    \ string) string]\n    [(equal? (char-code (first string)) #\\a) (upper-case-char\
    \ (first string))]\n    [(equal? (char-code (first string)) #\\A) (lower-case-char\
    \ (first string))]\n    [else (cons (char-code (first string)) (flip_case (rest\
    \ string)))]))\n", "  (let ((result (make-string (string-length string) ?*)))\n\
    \    (for ([i (in-range (string-length string))])\n      (let ((c (string->char\
    \ (substring string i i))))\n        (cond\n          [(< c ?A) (set! result (append\
    \ result ?U))\n           (< c ?a) (set! result (append result ?u))\n        \
    \   (< c ?0) (set! result (append result ?0))]\n          [(< c ?Z) (set! result\
    \ (append result ?Z))\n           (< c ?z) (set! result (append result ?z))\n\
    \           (< c ?_) (set! result (append result ?_))]\n          [(< c ?_) (set!\
    \ result (append result ?_))]))\n    result))\n", "  (let ((result '()))\n   \
    \ (for ([i (in-range (length string) )])\n      (if (char=? (char-code string\
    \ i) 'a)\n          (set! result (append result 'A))\n          (set! result (append\
    \ result 'a)))\n      (set! result (append result (char-code string i))))\n  \
    \  result))\n", "  (cond\n    [(string-empty? string) \"\"]\n    [(string-match\
    \ (regexp-opt \"[a-z]\") string) (string-replace (regexp-opt \"[a-z]\") #\\U (string-replace\
    \ (regexp-opt \"[A-Z]\") #\\l (string-replace (regexp-opt \"[A-Z]\") #\\L (string-replace\
    \ (regexp-opt \"[a-z]\") #\\l (string-replace (regexp-opt \"[A-Z]\") #\\U (string-replace\
    \ (regexp-opt \"[a-z]\") #\\l (string-replace (regexp-opt \"[A-Z]\") #\\U (string-replace\
    \ (regexp-opt \"[a-z]\") #\\l (string-replace (regexp-opt \"[A-Z]\") #\\U (string-replace\
    \ (regexp-opt \"[a-z]\") #\\l (string-replace (regexp-opt \"[A-Z]\") #\\U (string-replace\
    \ (regexp-opt \"[a-z]\") #\\l (string-replace (regexp-opt \"[A-Z]\") #\\U (string-replace\
    \ (regexp-opt \"[a-z]\") #\\l (string-replace (regexp-opt \"[A-Z]\") #\\U (string-replace\
    \ (regexp-opt \"[a-z]\") #\\l (string-replace (regexp-opt \"[A-Z]\") #\\U (string-replace\
    \ (regexp-opt \"[a-z]\") #\\l (string-replace (regexp-opt \"[A-Z]\") #\\U (string-replace\
    \ (regexp-opt \"[a-z]\") #\\l (string-replace (regexp-opt \"[A-Z]\") #\\U (string-replace\
    \ (regexp-opt \"[a-z]\") #\\l (string-replace (regexp-opt \"[A-Z]\") #\\U (string-replace\
    \ (regexp-opt \"[a-z]\") #\\l (string-replace (regexp-opt \"[A-Z]\") #\\U (string-replace\
    \ (regexp-opt \"[a-z]\") #\\l (string-replace (regexp-opt \"[A-Z]\") #\\U (string-replace\
    \ (regexp-opt \"[a-z]\") #\\l (string-replace (regexp-opt \"[A-Z]\") #\\U (string-replace\
    \ (regexp-opt \"[a-z]\") #\\l (string-replace (regexp-opt \"[A-Z]\") #\\U (string-replace\
    \ (regexp-opt \"[a-z]\") #\\l (string-replace (regexp-opt \"[A-Z]\") #\\U (string-replace\
    \ (regexp-opt \"[a-z]\") #\\l (string-replace (regexp-opt \"[A-Z", "  (let ((result\
    \ '()))\n    (for ((i 0) (j string.length))\n      (if (char=? string i)\n   \
    \       (set! result (conj result (char i j)))\n          (set! result (conj result\
    \ (char j i))))))\n  result)\n", "  (cond\n    [(empty? string) \"\"]\n    [(equal?\
    \ (first string) (string-ref string 0)) (string-append (string-ref string 0) (string-ref\
    \ string 1))]\n    [else (string-append (string-ref string 0) (string-ref string\
    \ 1))]))\n", "  (cond\n    [(empty? string) string]\n    [(equal? (first string)\
    \ (string-ref string 0)) (string-append (string-ref string 0) (string-ref string\
    \ 1))]\n    [else (string-append (string-ref string 0) (string-ref string 1))]))\n",
  "  (let ((chars (string->list string)))\n    (map (lambda (x)\n           (if (char=?\
    \ x #\\a)\n               (char-upper-case x)\n               (char-lower-case\
    \ x)))\n         chars)))\n", "  (cond\n    [(empty? string) \"\"]\n    [(equal?\
    \ (first string) (string-ref string 0)) (string-append \"-\" (second string))]\n\
    \    [else (string-append \"-\" (first string) (flip_case (rest string)))]))\n",
  "  (define (helper string result)\n    (cond\n      [(empty? string) result]\n \
    \     [(char-lower? (first string)) (helper (rest string) (conj result (char-upper\
    \ (first string))))]\n      [(char-upper? (first string)) (helper (rest string)\
    \ (conj result (char-lower (first string))))]\n      [else (helper (rest string)\
    \ result)]\n      ))\n  (helper string '()))\n", "  (cond\n    [(empty? string)\
    \ \"\"]\n    [(equal? (first string) (string-ref string 0)) (string-append (second\
    \ string) (first string))]\n    [else (string-append (flip_case (substring string\
    \ 0 1)) (string-append (first string) (second string)))))\n", "  (define (helper\
    \ string result)\n    (if (string-empty? string)\n        result\n        (helper\
    \ (substring string 0 1)\n                (cond [(char=? (char-code string) 97)\
    \ (concat result (char->string (char->integer 97)))]\n                      [(char=?\
    \ (char-code string) 65) (concat result (char->string (char->integer 65)))]\n\
    \                      [else (concat result (char->string (char->integer char-code\
    \ string))))])))\n  (helper string \"\"))\n", "  (cond\n    [(empty? string) \"\
    \"]\n    [(equal? (first string) (string-ref string 0)) (string-append (string-ref\
    \ string 1) (string-ref string 0))]\n    [else (string-append (string-ref string\
    \ 1) (string-ref string 0))]))\n", "  (cond\n    [(empty? string) string]\n  \
    \  [(equal? (first string) (string-ref string 0)) (string-append (string-ref string\
    \ 1) (string-ref string 0))]\n    [else (string-append (string-ref string 1) (string-ref\
    \ string 0))]))\n", "  (let loop ((string string) (result '()))\n    (cond [(empty?\
    \ string) result]\n          [(char=? (first string) 'A) (loop (rest string) (cons\
    \ (first string) result))]\n          [(char=? (first string) 'a) (loop (rest\
    \ string) (cons (first string) result))]\n          [else (loop (rest string)\
    \ (cons (first string) (cons (first string) result)))])))\n", "  (let ([chars\
    \ (string->list string)]\n        [flipped (make-array (length chars) #f)])\n\
    \    (do ([i 0 (+ i 1)]\n         [char chars i])\n        ((< i length) (flipped\
    \ i char))\n      (set! char (char->string (char->lowercase char)))\n      (set!\
    \ char (char->string (char->uppercase char)))\n      (set! char (char->string\
    \ char))\n      (set! char (char->string char))\n      (set! char (char->string\
    \ char))\n      (set! char (char->string char))\n      (set! char (char->string\
    \ char))\n      (set! char (char->string char))\n      (set! char (char->string\
    \ char))\n      (set! char (char->string char))\n      (set! char (char->string\
    \ char))\n      (set! char (char->string char))\n      (set! char (char->string\
    \ char))\n      (set! char (char->string char))\n      (set! char (char->string\
    \ char))\n      (set! char (char->string char))\n      (set! char (char->string\
    \ char))\n      (set! char (char->string char))\n      (set! char (char->string\
    \ char))\n      (set! char (char->string char))\n      (set! char (char->string\
    \ char))\n      (set! char (char->string char))\n      (set! char (char->string\
    \ char))\n      (set! char (char->string char))\n      (set! char (char->string\
    \ char))\n      (set! char (char->string char))\n      (set! char (char->string\
    \ char))\n      (set! char (char->string char))\n      (set! char (char->string\
    \ char))\n      (set! char (char->string char))\n      (set! char (char->string\
    \ char))\n      (set! char (char->string char))\n      (set! char (char->string\
    \ char))\n      (set! char (char->string char))\n      (set! char (char->string\
    \ char))\n      (set! char (char->string char))\n      (set! char (char->string\
    \ char))\n      (set! char (char->string char))\n      (set! char (char->string\
    \ char))\n      (set! char (char->string char))\n      (set! char (char->string\
    \ char", "  (cond\n    [(empty? string) \"\"]\n    [(equal? (first string) (string-ref\
    \ string 0)) (string-append \"-\" (flip_case (rest string)))]\n    [else (string-append\
    \ \"-\" (flip_case (rest string)))]))\n", "  (let ((result '()))\n    (for ([i\
    \ (in-range (length string) )])\n      (let ((c (char-ref string i)))\n      \
    \  (if (char-equal? c #\\a)\n            (set! result (append result (list #\\\
    A)))\n            (set! result (append result (list c)))))))\n  (string-join result\
    \ \"\"))\n", "  (cond\n    [(empty? string) string]\n    [(equal? (first string)\
    \ (string-ref string 0)) (string-append (make-string (string-length string) ?A)\
    \ (make-string (string-length string) ?B))]\n    [else (string-append (make-string\
    \ (string-length string) ?A) (make-string (string-length string) ?B) (flip_case\
    \ (rest string)))]))\n", "  (cond\n    [(empty? string) string]\n    [(equal?\
    \ (first string) (string-ref string 0)) (string-append (string-ref string 0) (string-ref\
    \ string 1))]\n    [else (string-append (flip_case (string-ref string 0)) (flip_case\
    \ (string-ref string 1)))]))\n", "  (cond [(empty? string) string]\n        [(equal?\
    \ (first string) (string-ref string 0)) (string-append (string-ref string 0) (string-ref\
    \ string 1))]\n        [else (string-append (string-ref string 0) (string-ref\
    \ string 1))]))\n", "  (let loop ((string string) (result '()))\n    (cond ((null?\
    \ string) result)\n          ((char-lower? (car string)) (loop (cdr string) (cons\
    \ (char-upper? (car string)) result)))\n          ((char-upper? (car string))\
    \ (loop (cdr string) (cons (char-lower? (car string)) result)))\n          (else\
    \ (loop (cdr string) (cons (car string) result))))))\n", "  (let ([flipped-string\
    \ \"\"])\n    (for [c string]\n      (if (char-lower? c)\n          (set! flipped-string\
    \ (append flipped-string (make-string (char-code c) (char-code (char-code c) char-upper-case)))\n\
    \          (set! flipped-string (append flipped-string (make-string (char-code\
    \ c) (char-code (char-code c) char-lower-case)))))))\n", "  (let loop ((string\
    \ string) (result '()))\n    (cond ((null? string) result)\n          ((char-lower?\
    \ (car string)) (loop (cdr string) (cons (char-upper? (car string)) result)))\n\
    \          ((char-upper? (car string)) (loop (cdr string) (cons (char-lower? (car\
    \ string)) result)))\n          (else (loop (cdr string) (cons (car string) result))))))\n",
  "  (define (helper string result)\n    (if (string-empty? string)\n        result\n\
    \        (helper (substring string 0 1)\n                (if (char-lower-case?\
    \ string)\n                    (cons (char-upper-case? string) result)\n     \
    \               (cons string result))))\n  (helper string '()))\n", "  (define\
    \ (helper char result)\n    (cond\n      [(char-lower-case? char) (cons char (helper\
    \ (char-upper-case? char) result))]\n      [(char-upper-case? char) (cons (char-lower-case?\
    \ char) result)]\n      [else result]))\n  (helper string '()))\n", "  (cond\n\
    \    [(empty? string) \"\"]\n    [(equal? (first string) (string-ref string 0))\
    \ (string-append \"-\" (second string))]\n    [else (string-append \"-\" (first\
    \ string) (flip_case (rest string)))]))\n", "  (define (helper string index result)\n\
    \    (cond\n      [(empty? string) (list result)]\n      [(char=? (car string)\
    \ (car result)) (helper (cdr string) (+ index 1) (cdr result))]\n      [else (helper\
    \ (cdr string) (+ index 1) (cons (car string) result))]\n      ))\n  (helper string\
    \ 0 '()))\n", "  (define (helper string result)\n    (if (string-empty? string)\n\
    \        result\n        (helper (substring string 0 1)\n                (cons\
    \ (char->upper-case (first string))\n                      result)))\n    (helper\
    \ (substring string 1 string-length) '())))\n", "  (define (helper string result)\n\
    \    (if (string-empty? string)\n        result\n        (helper (substring string\
    \ 0 1)\n                (cond [(char=? (first string) 'a)\n                  \
    \     result\n                       (helper (substring string 1 -1)\n       \
    \                       (cond [(char=? (first string) 'A)\n                  \
    \                   result\n                                     (helper (substring\
    \ string 2 -1)\n                                           result)]\n        \
    \                             [else (string-append result (first string))]))]\n\
    \                  [else (string-append result (first string))]))))\n  (helper\
    \ string '()))\n", "  (cond\n    [(empty? string) \"\"]\n    [(equal? (first string)\
    \ (string-ref string 0)) (string-append \"-\" (second string))]\n    [else (string-append\
    \ \"-\" (first string) (flip_case (rest string)))]))\n", "  (define (helper char)\n\
    \    (if (char-lower? char)\n        (char-upper-case? char)\n        (char-lower-case?\
    \ char)))\n  (define (helper string)\n    (if (null? string)\n        '()\n  \
    \      (cons (helper (car string)) (helper (cdr string)))))\n  (helper string))\n",
  "  (cond\n    [(empty? string) string]\n    [(equal? (first string) (string-ref\
    \ string 0)) (string-append (string-ref string 0) (string-ref string 1))]\n  \
    \  [else (string-append (string-ref string 0) (string-ref string 1))]\n  ))\n",
  "  (let ((chars (string->list string)))\n    (map (lambda (c)\n           (if (char=?\
    \ c #\\a)\n               (char-upper-case c)\n               (char-lower-case\
    \ c)))\n         chars)))\n", "  (let ((lower (string->list string)))\n    (map\
    \ (lambda (char)\n           (if (char->char < #\\a)\n               (char->char\
    \ + #\\A)\n               (char->char + #\\z))\n           lower)\n         string)))\n",
  "  (let ((lower (string->list string)))\n    (map (lambda (x)\n           (if (string=?\
    \ (car x) (string->string (string->list (string->string string)))) \n        \
    \       (string->string (string->list (string->string string))) \n           \
    \    (string->string (string->list (string->string string))))\n           lower)\n\
    \         string)))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
