name: HumanEval_49_modp
language: rkt
prompt: "#lang racket\n\n;; Return 2^n modulo p (be aware of numerics).\n(define (modp\
  \ n p)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate modp))\n\
  \    (check-equal? (candidate 3 5) 3)\n    (check-equal? (candidate 1101 101) 2)\n\
  \    (check-equal? (candidate 0 101) 1)\n    (check-equal? (candidate 3 11) 8)\n\
  \    (check-equal? (candidate 100 101) 1)\n    (check-equal? (candidate 30 5) 4)\n\
  \    (check-equal? (candidate 31 5) 3)\n))\n\n(test-humaneval)"
completions: ["  (if (= n 0)\n      0\n      (* p (modp n (sub1 p))))) ;; #lang racket\n",
  "  (if (= n 0)\n      p\n      (modp (- n 1) (* p p))))\n", "  (if (= n 0)\n   \
    \   p\n      (modp (- n 1) (modulo (modulo n p) p))))\n", "  (if (= n 0)\n   \
    \   0\n      (modulo (modulo (modulo n p) p) p)))\n", "  (mod n p))\n", "  (if\
    \ (= n 0)\n      0\n      (modulo (expt 2 n) p)))\n", "  (let ((m (modulo n p)))\n\
    \    (if (= m 0)\n        p\n        (modp m p))))\n", "  (if (= n 0)\n      0\n\
    \      (modulo (expt 2 n) p)))\n", "  (let ((m (mod-n n p)))\n    (if (= m 0)\n\
    \        p\n        (modp m (mod-n m p)))))\n", "  (let ((m (modulo n p)))\n \
    \   (if (= m 0)\n        p\n        (modp m p))))\n", "  (mod n p))\n", "  (if\
    \ (= n 0)\n      p\n      (modp (- n 1) (* p p))))\n", "  (if (= n 0)\n      0\n\
    \      (* 2 (modp n (remainder p 2)))))\n", "  (if (= n 0)\n      0\n      (modulo\
    \ (expt 2 n) p)))\n", "  (mod n p))\n", "  (if (= n 0)\n      0\n      (mod n\
    \ (expt p 2))))\n", "  (if (= n 0)\n      0\n      (modulo (* 2 n) p)))\n", " \
    \ (mod n p))\n", "  (mod n p))\n", "  (let ((m (modulo n p)))\n    (if (= m 0)\n\
    \        p\n        (modp m p))))\n", "  (if (= n 0)\n      0\n      (modulo (*\
    \ 2 n) p)))\n", "  (if (= n 0)\n      0\n      (modulo (expt 2 n) p)))\n", " \
    \ (mod n p))\n", "  (if (= n 0)\n      0\n      (* 2 (modp n (remainder p 2)))))\n",
  "  (if (= n 0)\n      0\n      (modulo (expt 2 n) p)))\n", "  (let ((m (* n p)))\n\
    \    (if (< m p)\n        (- m p)\n        m)))\n", "  (if (= n 0)\n      0\n\
    \      (modulo (expt 2 n) p)))\n", "  (if (= n 0)\n      0\n      (modulo (expt\
    \ 2 n) p)))\n", "  (if (= n 0)\n      0\n      (modulo (expt 2 n) p)))\n", " \
    \ (if (= n 0)\n      0\n      (modulo (expt 2 n) p)))\n", "  (if (= n 0)\n   \
    \   0\n      (modulo (expt 2 n) p)))\n", "  (if (= n 0)\n      0\n      (modulo\
    \ (modulo (modulo n p) p) p)))\n", "  (if (= n 0)\n      0\n      (* 2 (modp n\
    \ (remainder p 2)))))\n", "  (if (= n 0)\n      0\n      (modulo (modulo (modulo\
    \ n p) p) p)))\n", "  (if (= n 0)\n      0\n      (modulo (* 2 n) p)))\n", " \
    \ (let ((m (modulo n p)))\n    (if (= m 0)\n        p\n        (modp m p))))\n",
  "  (if (= n 0)\n      0\n      (modulo (expt 2 n) p)))\n", "  (if (= n 0)\n    \
    \  0\n      (modulo (expt 2 n) p)))\n", "  (if (= n 0)\n      0\n      (modulo\
    \ (expt 2 n) p)))\n", "  (if (= n 0)\n      p\n      (modp (- n 1) (modulo (modulo\
    \ (modulo n p) p) p))))\n", "  (mod n p))\n", "  (mod n p))\n", "  (if (= n 0)\n\
    \      p\n      (modp (- n 1) (* p p))))\n", "  (if (= n 0)\n      p\n      (modp\
    \ (- n 1) (* p p))))\n", "  (if (= n 0)\n      p\n      (modp (- n 1) p)))\n",
  "  (if (= n 0)\n      p\n      (modp (- n 1) (modulo p 2))))\n", "  (if (= n 0)\n\
    \      p\n      (modp (- n 1) (* p p))))\n", "  (if (= n 0)\n      0\n      (*\
    \ 2 (modp n (sub1 p))))) ;; #lang racket\n", "  (let ((m (modulo n p)))\n    (if\
    \ (= m 0)\n        p\n        (modp m p))))\n", "  (if (= n 0)\n      0\n    \
    \  (modulo (modulo (modulo n p) p) p)))\n", "  (if (= n 0)\n      0\n      (modulo\
    \ (expt 2 n) p)))\n", "  (mod n p))\n", "  (let ((m (mod-n n p)))\n    (if (=\
    \ m 0)\n        p\n        (mod-p m p))))\n", "  (if (= n 0)\n      0\n      (modulo\
    \ (modulo n p) p)))\n", "  (if (= n 0)\n      0\n      (modulo (expt 2 n) p)))\n",
  "  (if (= n 0)\n      0\n      (modulo (expt 2 n) p)))\n", "  (mod n p))\n", " \
    \ (if (= n 0)\n      0\n      (modulo (expt 2 n) p)))\n", "  (let ((m (modulo\
    \ n p)))\n    (if (= m 0)\n        0\n        (* m (modp m p)))))\n", "  (let\
    \ ((m (* n p)))\n    (if (< m p)\n        (modp m p)\n        m)))\n", "  (if\
    \ (= n 0)\n      0\n      (modulo (modulo (modulo (modulo n p) p) p) p)))\n",
  "  (if (= n 0)\n      0\n      (modulo (expt 2 n) p)))\n", "  (let ((m (modulo n\
    \ p)))\n    (if (= m 0)\n        p\n        (modp m p))))\n", "  (if (= n 0)\n\
    \      p\n      (modp (- n 1) (* p p))))\n", "  (let ((m (modulo n p)))\n    (if\
    \ (= m 0)\n        0\n        (- m 1))))\n", "  (if (= n 0)\n      p\n      (modp\
    \ (- n 1) (* p p))))\n", "  (if (= n 0)\n      p\n      (modp (- n 1) (* p p))))\n",
  "  (let loop ((n n) (p p))\n    (if (zero? n)\n        p\n        (loop (quotient\
    \ n p) (modulo n p))))))\n", "  (if (= n 0)\n      0\n      (modulo (modulo n\
    \ p) p)))\n", "  (if (= n 0)\n      0\n      (modulo (modulo n p) p)))\n", " \
    \ (let ((m (modulo n p)))\n    (if (< m p)\n        m\n        (modp m p))))\n",
  "  (mod n p))\n", "  (mod n p))\n", "  (let ((m (mod-arithmetic n p)))\n    (if\
    \ (= m 0)\n        p\n        (modp m p))))\n", "  (if (= n 0)\n      p\n    \
    \  (modp (- n 1) (* p p))))\n", "  (if (= n 0)\n      0\n      (modulo (expt 2\
    \ n) p)))\n", "  (if (= n 0)\n      p\n      (modp (- n 1) (* p p))))\n", "  (if\
    \ (= n 0)\n      0\n      (* p (modp n (sub1 p))))) ;; #lang racket\n", "  (let\
    \ ((m (* 2 n)))\n    (if (= m 0)\n        p\n        (modp m p))))\n", "  (if\
    \ (= n 0)\n      p\n      (modp (- n 1) (* p p))))\n", "  (if (= n 0)\n      0\n\
    \      (modulo (expt 2 n) p)))\n", "  (mod n p))\n", "  (if (= n 0)\n      0\n\
    \      (modulo (expt 2 n) p)))\n", "  (if (= n 0)\n      p\n      (modp (- n 1)\
    \ (* p p))))\n", "  (let ((m (mod-arithmetic-log2 n)))\n    (if (= m 0)\n    \
    \    p\n        (mod-arithmetic-mult m p))))\n", "  (if (= n 0)\n      0\n   \
    \   (modulo (expt 2 n) p)))\n", "  (if (= n 0)\n      0\n      (modulo (modulo\
    \ n p) p)))\n", "  (if (= n 0)\n      0\n      (modulo (expt 2 n) p)))\n", " \
    \ (if (= n 0)\n      0\n      (modulo (expt 2 n) p)))\n", "  (if (= n 0)\n   \
    \   0\n      (modulo (modulo n p) p)))\n", "  (if (= n 0)\n      0\n      (modulo\
    \ (expt 2 n) p)))\n", "  (if (= n 0)\n      0\n      (* 2 (modp n (sub1 p)))))\
    \ ;; #lang racket\n", "  (if (= n 0)\n      0\n      (* 2 (modp n (- p 1)))))\n",
  "  (mod n p))\n", "  (mod n p))\n", "  (if (= n 0)\n      p\n      (modp (- n 1)\
    \ (* p p))))\n", "  (if (= n 0)\n      0\n      (modulo (expt 2 n) p)))\n", " \
    \ (let ((q (* n p)))\n    (if (= q 0)\n        p\n        (modp q (remainder q\
    \ p))))) ; mod p\n", "  (if (= n 0)\n      0\n      (* 2 (modp n (remainder p\
    \ n))))) ;; #lang racket\n", "  (let ((m (mod-n n p)))\n    (if (= m 0)\n    \
    \    p\n        (modp m (mod-n m p)))))\n", "  (if (= n 0)\n      0\n      (modulo\
    \ (modulo (modulo n p) p) p)))\n", "  (if (= n 0)\n      p\n      (modp (- n 1)\
    \ (* p p))))\n", "  (if (= n 0)\n      0\n      (modulo (expt 2 n) p)))\n", " \
    \ (if (= n 0)\n      0\n      (modulo (expt 2 n) p)))\n", "  (mod n p))\n", " \
    \ (let ((m (mod-n n p)))\n    (if (= m 0)\n        p\n        (modp m p))))\n",
  "  (if (= n 0)\n      0\n      (* 2 (modp n (sub1 p))))) ;; #lang racket\n", " \
    \ (if (= n 0)\n      0\n      (* 2 (modp n (sub1 p))))) ;; #lang racket\n", " \
    \ (if (= n 0)\n      p\n      (modp (- n 1) (* p p))))\n", "  (let ((m (* n p)))\n\
    \    (if (< m p)\n        p\n        (modp m p))))\n", "  (if (= n 0)\n      0\n\
    \      (modulo (expt 2 n) p)))\n", "  (if (= n 0)\n      0\n      (* 2 (modp n\
    \ (sub1 p))))) ;; #lang racket\n", "  (mod n p))\n", "  (let ((q (/ n p)))\n \
    \   (if (< q 0)\n        0\n        (modulo (* q p) p))))\n", "  (if (= n 0)\n\
    \      0\n      (modulo (expt 2 n) p)))\n", "  (if (= n 0)\n      0\n      (modulo\
    \ (modulo n p) p)))\n", "  (if (= n 0)\n      0\n      (modulo (* 2 n) p)))\n",
  "  (if (= n 0)\n      p\n      (modp (- n 1) (modulo (modulo n p) p))))\n", "  (if\
    \ (= n 0)\n      0\n      (mod n (expt p 2))))\n", "  (if (= n 0)\n      0\n \
    \     (modulo (expt 2 n) p)))\n", "  (mod n p))\n", "  (if (= n 0)\n      0\n\
    \      (modulo (expt 2 n) p)))\n", "  (if (= n 0)\n      0\n      (mod n (expt\
    \ p 2))))\n", "  (let ((q (/ n p)))\n    (if (= q 0)\n        p\n        (modp\
    \ q (remainder n p))))) ; mod p\n", "  (if (= n 0)\n      0\n      (modulo (modulo\
    \ (modulo n p) p) p)))\n", "  (let ((m (* n p)))\n    (if (= m 0)\n        p\n\
    \        (modp m p))))\n", "  (if (= n 0)\n      p\n      (modp (- n 1) (* p p))))\n",
  "  (if (= n 0)\n      0\n      (modulo (expt 2 n) p)))\n", "  (let ((m (mod-n n\
    \ p)))\n    (if (= m 0)\n        p\n        (modp m p))))\n", "  (if (= n 0)\n\
    \      0\n      (modulo (expt 2 n) p)))\n", "  (let ((m (mod-arithmetic-log2 n)))\n\
    \    (if (= m 0)\n        p\n        (modp m p))))\n", "  (if (= n 0)\n      p\n\
    \      (modp (- n 1) (* p p))))\n", "  (if (= n 0)\n      p\n      (modp (- n\
    \ 1) (* p p))))\n", "  (if (= n 0)\n      0\n      (modulo (expt 2 n) p)))\n",
  "  (if (= n 0)\n      p\n      (modp (- n 1) (* p p))))\n", "  (let ((q (/ n p)))\n\
    \    (if (= q 0)\n        p\n        (modp q (remainder n p))))) ; mod p\n", " \
    \ (if (= n 0)\n      p\n      (modp (- n 1) (* p p))))\n", "  (if (= n 0)\n  \
    \    p\n      (modp (- n 1) (* p p))))\n", "  (mod n p))\n", "  (if (= n 0)\n\
    \      0\n      (mod n (expt p 2))))\n", "  (if (= n 0)\n      p\n      (modp\
    \ (- n 1) (* p p))))\n", "  (if (= n 0)\n      0\n      (modulo (expt 2 n) p)))\n",
  "  (let ((m (mod-n n p)))\n    (if (= m 0)\n        p\n        (modp m (mod-n m\
    \ p)))))\n", "  (mod n p))\n", "  (if (= n 0)\n      p\n      (modp (- n 1) (*\
    \ p p))))\n", "  (if (= n 0)\n      0\n      (* 2 (modp n (- p 1)))))\n", "  (mod\
    \ n p))\n", "  (if (= n 0)\n      0\n      (mod n (expt p 2))))\n", "  (if (=\
    \ n 0)\n      p\n      (modp (- n 1) (* p p))))\n", "  (if (= n 0)\n      0\n\
    \      (modulo (* 2 n) p)))\n", "  (let loop ((n n) (p p))\n    (if (= n 0)\n\
    \        p\n        (loop (quotient n p) (modulo n p))))))\n", "  (if (= n 0)\n\
    \      p\n      (modp (- n 1) (* p p))))\n", "  (let ((m (mod-n n p)))\n    (if\
    \ (= m 0)\n        p\n        (modp m (modulo m p)))))\n", "  (if (= n 0)\n  \
    \    0\n      (modulo (expt 2 n) p)))\n", "  (let loop ((n n) (p p))\n    (if\
    \ (= n 0)\n        p\n        (loop (quotient n p) (modulo n p))))))\n", "  (mod\
    \ n p))\n", "  (let ((m (modulo n p)))\n    (if (= m 0)\n        p\n        (modp\
    \ m p))))\n", "  (if (= n 0)\n      0\n      (modulo (expt 2 n) p)))\n", "  (if\
    \ (= n 0)\n      0\n      (modulo (expt 2 n) p)))\n", "  (let ((q (quotient n\
    \ p)))\n    (if (= q 0)\n        p\n        (modp q (remainder n p))))\n  )\n",
  "  (let ((m (mod-arithmetic-log2 n)))\n    (if (= m 0)\n        p\n        (mod-arithmetic-mul\
    \ (modulo-arithmetic-mul m p) p))))\n", "  (if (= n 0)\n      p\n      (modp (-\
    \ n 1) p)))\n", "  (let loop ((n n) (p p))\n    (cond ((= n 0) p)\n          ((=\
    \ p 1) n)\n          ((even? n) (loop (/ n 2) p))\n          (else (loop (* n\
    \ p) (/ p 2))))))\n", "  (if (= n 0)\n      0\n      (* 2 (modp n (- p 1)))))\n",
  "  (if (= n 0)\n      p\n      (modp (- n 1) (* p p))))\n", "  (if (= n 0)\n   \
    \   0\n      (* 2 (modp n (remainder p n))))) ;; #lang racket\n", "  (if (= n\
    \ 0)\n      p\n      (modp (- n 1) (* p p))))\n", "  (let ((q (quotient n p)))\n\
    \    (if (= q 0)\n        p\n        (modp q (remainder n p))))) ;; #lang racket\n",
  "  (if (= n 0)\n      p\n      (modp (- n 1) (* p p))))\n", "  (if (= n 0)\n   \
    \   p\n      (modp (- n 1) (* p p))))\n", "  (if (= n 0)\n      0\n      (* p\
    \ (modp n (sub1 p))))) ;; #lang racket\n", "  (let ((m (expt 2 n)))\n    (if (=\
    \ m 0)\n        p\n        (modp m p))))\n", "  (if (= n 0)\n      0\n      (*\
    \ 2 (modp n (sub1 p))))) ;; #lang racket\n", "  (if (= n 0)\n      0\n      (modulo\
    \ (modulo (modulo n p) p) p)))\n", "  (if (= n 0)\n      p\n      (modp (- n 1)\
    \ (* p p))))\n", "  (if (= n 0)\n      0\n      (* 2 (modp n (remainder p 2)))))\n",
  "  (if (= n 0)\n      0\n      (* 2 (modp n (sub1 p))))) ;; #lang racket\n", " \
    \ (if (= n 0)\n      0\n      (mod n (expt p 2))))\n", "  (if (= n 0)\n      0\n\
    \      (mod n (expt p 2))))\n", "  (if (= n 0)\n      0\n      (modulo (expt 2\
    \ n) p)))\n", "  (if (= n 0)\n      p\n      (modp (- n 1) (* p p))))\n", "  (if\
    \ (= n 0)\n      p\n      (modp (- n 1) (* p p))))\n", "  (let ((m (mod-n n p)))\n\
    \    (if (= m 0)\n        p\n        (modp m (modulo m p)))))\n", "  (if (= n\
    \ 0)\n      0\n      (modulo (expt 2 n) p)))\n", "  (if (= n 0)\n      0\n   \
    \   (modulo (expt 2 n) p)))\n", "  (mod n p))\n", "  (if (= n 0)\n      p\n  \
    \    (modp (- n 1) (* p p))))\n", "  (if (= n 0)\n      0\n      (modulo (expt\
    \ 2 n) p)))\n", "  (if (= n 0)\n      0\n      (modulo (expt 2 n) p)))\n", " \
    \ (mod n p))\n", "  (mod n p))\n", "  (let ((q (remainder n p)))\n    (if (= q\
    \ 0)\n        p\n        (modp q (remainder n p)))))\n", "  (if (= n 0)\n    \
    \  0\n      (modulo (expt 2 n) p)))\n", "  (let ((m (modulo n p)))\n    (if (=\
    \ m 0)\n        p\n        (modp m p))))\n", "  (let ((m (expt 2 n)))\n    (if\
    \ (= m 0)\n        p\n        (modp m p))))\n", "  (mod n p))\n", "  (if (= n\
    \ 0)\n      0\n      (modulo (modulo (modulo n p) p) p)))\n", "  (if (= n 0)\n\
    \      0\n      (modulo (expt 2 n) p)))\n", "  (mod n p))\n", "  (if (= n 0)\n\
    \      p\n      (modp (- n 1) (* p p))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
