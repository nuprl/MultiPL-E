name: HumanEval_40_triples_sum_to_zero
language: rkt
prompt: "#lang racket\n\n;; triples_sum_to_zero takes a list of integers as an input.\n\
  ;; it returns True if there are three distinct elements in the list that\n;; sum\
  \ to zero, and False otherwise.\n(define (triples_sum_to_zero l)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate triples_sum_to_zero))\n\
  \    (check-equal? (candidate (list 1 3 5 0)) #f)\n    (check-equal? (candidate\
  \ (list 1 3 5 -1)) #f)\n    (check-equal? (candidate (list 1 3 -2 1)) #t)\n    (check-equal?\
  \ (candidate (list 1 2 3 7)) #f)\n    (check-equal? (candidate (list 1 2 5 7)) #f)\n\
  \    (check-equal? (candidate (list 2 4 -5 3 9 7)) #t)\n    (check-equal? (candidate\
  \ (list 1)) #f)\n    (check-equal? (candidate (list 1 3 5 -100)) #f)\n    (check-equal?\
  \ (candidate (list 100 3 5 -100)) #f)\n))\n\n(test-humaneval)"
completions: ["  (cond\n    [(empty? l) #t]\n    [(= (first l) 0) #t]\n    [else (and\
    \ (triples_sum_to_zero (rest l))\n               (= (first l) (+ (first l) (second\
    \ l) (third l))))]))\n", "  (cond [(empty? l) #t]\n        [(equal? (first l)\
    \ 0) #f]\n        [else (triples_sum_to_zero (rest l))]))\n", "  (let loop ((l\
    \ l) (acc '()))\n    (cond ((null? l) acc)\n          ((= (+ (car l) (car l))\
    \ 0)\n           (loop (cdr l) (cons (car l) acc)))\n          (else (loop (cdr\
    \ l) (cons (car l) acc))))))\n", "  (let loop ((l l) (acc #t) (i 0))\n    (cond\
    \ ((null? l) #f)\n          ((eqv? (car l) (cadr l)) (loop (cdr l) (not acc) (+\
    \ i 1)))\n          ((eqv? (car l) (caddr l)) (loop (cdr l) (not acc) (+ i 2)))\n\
    \          (else (loop (cdr l) (and acc (eqv? (car l) (caddr l))) (+ i 1))))))\n",
  "  (let loop ((l l) (acc #t) (i 0))\n    (cond ((null? l) acc)\n          ((eqv?\
    \ (car l) (cadr l)) (loop (cdr l) (not acc) (i + 1))\n           (loop (cdr l)\
    \ acc (+ i 1)))\n          (else (loop (cdr l) (not acc) i))))))\n", "  (let loop\
    \ ((l l) (acc #t) (i 0))\n    (cond ((null? l) acc)\n          ((= i 3) (or (=\
    \ (+ acc (car l)) 0) (= (+ acc (cdr l)) 0)))\n          (else (loop (cdr l) (or\
    \ (= (+ acc (car l)) 0) (= (+ acc (cdr l)) 0)) (inc i))))))\n", "  (let loop ((l\
    \ l) (acc #t) (i 0))\n    (cond ((null? l) acc)\n          ((= i 3) (set! acc\
    \ (not acc)))\n          ((= (+ (car l) (car l)) 0) (loop (cdr l) (not acc) (inc\
    \ i)))\n          (else (loop (cdr l) (and acc (= (+ (car l) (car l)) 0)) (inc\
    \ i))))))\n", "  (cond\n    [(empty? l) false]\n    [(member (first l) '(0 1 2))\
    \ false]\n    [else (triples_sum_to_zero (rest l))]\n  ))\n", "  (let loop ((l\
    \ l) (acc #t) (seen #t))\n    (cond ((null? l) acc)\n          ((not seen)\n \
    \          (loop (cdr l) (not (= (+ (car l) acc)) seen) (car l)))\n          ((=\
    \ (+ (car l) acc) 0)\n           (loop (cdr l) (not (= (+ (car l) acc)) seen)\
    \ (car l)))\n          (else\n           (loop (cdr l) (not (= (+ (car l) acc))\
    \ seen) (car l))))))\n", "  (let loop ((l l) (acc '()))\n    (cond ((null? l)\
    \ acc)\n          ((= (+ (car l) (car acc)) 0)\n           (loop (cdr l) (cons\
    \ (car l) acc)))\n          (else\n           (loop (cdr l) (cons (car l) acc))))))\n",
  "  (let loop ((l l) (acc #t) (seen #t))\n    (cond ((null? l) acc)\n          ((not\
    \ seen)\n           (loop (cdr l) (not (= (+ (car l) acc)) seen) (car l)))\n \
    \         ((= (+ (car l) acc) 0)\n           (loop (cdr l) acc (not seen)))\n\
    \          (else\n           (loop (cdr l) (not (= (+ (car l) acc)) seen))))))\n",
  "  (cond [(empty? l) #t]\n        [(= (first l) 0) #f]\n        [else (triples_sum_to_zero\
    \ (rest l))]))\n", "  (let ((sum (apply + l)))\n    (cond\n      [(= 3 sum) true]\n\
    \      [else false]\n      )))\n", "  (let loop ((l l) (acc #t) (i 0))\n    (if\
    \ (null? l)\n        acc\n        (loop (cdr l) (and (= i (+ (car l) acc)) (=\
    \ i (+ (cdr l) acc))) (+ i 1)))))\n", "  (cond [(empty? l) #t]\n        [(equal?\
    \ (first l) (first l)) #t]\n        [else (triples_sum_to_zero (rest l))]))\n",
  "  (let loop ((l l) (sum 0))\n    (cond ((null? l) #f)\n          ((= (first l)\
    \ sum) #t)\n          ((= (second l) sum) #t)\n          ((= (third l) sum) #t)\n\
    \          (else (loop (rest l) (+ sum (first l)))))))\n", "  (let loop ((l l)\
    \ (sum 0))\n    (cond ((null? l) false)\n          ((= (first l) sum) true)\n\
    \          (else (loop (rest l) (+ sum (first l)))\n                (loop (rest\
    \ l) (+ sum (first l)))))))\n", "  (let loop ((lst l) (acc '()))\n    (cond ((null?\
    \ lst) acc)\n          ((= 3 (car lst)) (loop (cdr lst) (cons (car lst) acc)))\n\
    \          (else (loop (cdr lst) (cons (car lst) (cons (car lst) acc)))))))\n",
  "  (let loop ((l l) (acc #t) (i 0))\n    (cond\n      [(empty? l) #f]\n      [(equal?\
    \ (first l) 0) (or (not acc) (not (loop (rest l) true i)))]\n      [(equal? (first\
    \ l) 1) (or (not acc) (not (loop (rest l) false i)))]\n      [(equal? (first l)\
    \ 2) (or (not acc) (not (loop (rest l) (loop (rest l) true i) (add1 i))))]\n \
    \     [else (or (not acc) (not (loop (rest l) (loop (rest l) false i) (add1 i))))]\n\
    \    )\n  )\n)\n", "  (let loop ((l l) (acc #t) (i 0))\n    (cond ((null? l) acc)\n\
    \          ((= i 3) (or (= (+ acc 1) (+ acc 2)) (= (+ acc 3) (+ acc 4))))\n  \
    \        (else (loop (cdr l) (or (= (+ acc 1) (+ acc 2)) (= (+ acc 3) (+ acc 4)))\
    \ (+ i 1))))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
