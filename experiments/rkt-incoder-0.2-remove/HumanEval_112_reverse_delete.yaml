name: HumanEval_112_reverse_delete
language: rkt
prompt: "#lang racket\n\n;; Task\n;; We are given two strings s and c, you have to\
  \ deleted all the characters in s that are equal to any character in c\n;; then\
  \ check if the result string is palindrome.\n;; A string is called palindrome if\
  \ it reads the same backward as forward.\n;; You should return a tuple containing\
  \ the result string and True/False for the check.\n;; Example\n(define (reverse_delete\
  \ s c)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate reverse_delete))\n\
  \    (check-equal? (candidate \"abcde\" \"ae\") (list \"bcd\" #f))\n    (check-equal?\
  \ (candidate \"abcdef\" \"b\") (list \"acdef\" #f))\n    (check-equal? (candidate\
  \ \"abcdedcba\" \"ab\") (list \"cdedc\" #t))\n    (check-equal? (candidate \"dwik\"\
  \ \"w\") (list \"dik\" #f))\n    (check-equal? (candidate \"a\" \"a\") (list \"\"\
  \ #t))\n    (check-equal? (candidate \"abcdedcba\" \"\") (list \"abcdedcba\" #t))\n\
  \    (check-equal? (candidate \"abcdedcba\" \"v\") (list \"abcdedcba\" #t))\n  \
  \  (check-equal? (candidate \"vabba\" \"v\") (list \"abba\" #t))\n    (check-equal?\
  \ (candidate \"mamma\" \"mia\") (list \"\" #t))\n))\n\n(test-humaneval)"
completions: ["  (cond\n    [(empty? s) (list '())]\n    [(equal? (first s) c) (cons\
    \ (first s) (reverse_delete (rest s) c))]\n    [else (reverse_delete (rest s)\
    \ c)]))\n", "  (cond\n    [(empty? s) (list '())]\n    [(equal? (first s) c) (cons\
    \ (first s) (reverse_delete (rest s) c))]\n    [else (reverse_delete (rest s)\
    \ c)]))\n", "  (cond\n    [(empty? s) (list '())]\n    [(equal? (first s) c) (cons\
    \ (first s) (reverse_delete (rest s) c))]\n    [else (reverse_delete (rest s)\
    \ c)]))\n", "  (cond\n    [(empty? s) (list '())]\n    [(equal? (first s) c) (cons\
    \ (first s) (reverse_delete (rest s) c))]\n    [else (reverse_delete (rest s)\
    \ c)]\n  )\n)\n", "  (let loop ((s s)\n             (c c))\n    (cond\n      [(empty?\
    \ s) (list empty? false)]\n      [(equal? (first s) c) (loop (rest s) c)]\n  \
    \    [else (loop (rest s) (first s))])))\n", "  (if (empty? s)\n      (list '())\n\
    \      (append (reverse_delete (rest s) c) (list (first s)))))\n", "  (cond\n\
    \    [(empty? s) (list '())]\n    [(equal? (first s) c) (cons (first s) (reverse_delete\
    \ (rest s) c))]\n    [else (reverse_delete (rest s) c)]\n  ))\n", "  (cond\n \
    \   [(empty? s) (list '())]\n    [(equal? (first s) c) (cons (first s) (reverse_delete\
    \ (rest s) c))]\n    [else (reverse_delete (rest s) c)]))\n", "  (cond\n    [(empty?\
    \ s) (list '())]\n    [(equal? (first s) c) (cons (first s) (reverse_delete (rest\
    \ s) c))]\n    [else (cons (first s) (reverse_delete (rest s) c))]\n  ))\n", " \
    \ (cond\n    [(empty? s) (list '())]\n    [(equal? (first s) c) (cons (first s)\
    \ (reverse_delete (rest s) c))]\n    [else (reverse_delete (rest s) c)]))\n",
  "  (cond\n    [(empty? s) (list '())]\n    [(equal? (first s) c) (cons (first s)\
    \ (reverse_delete (rest s) c))]\n    [else (reverse_delete (rest s) c)]))\n",
  "  (cond\n    [(empty? s) (list '())]\n    [(equal? (first s) c) (cons (first s)\
    \ (reverse_delete (rest s) c))]\n    [else (reverse_delete (rest s) c)]))\n",
  "  (cond\n    [(empty? s) (list '())]\n    [(equal? (first s) c) (cons (first s)\
    \ (reverse_delete (rest s) c))]\n    [else (reverse_delete (rest s) c)]\n  )\n\
    )\n", "  (if (empty? s)\n      (list '())\n      (let ((head (car s))\n      \
    \      (tail (cdr s)))\n        (if (equal? head c)\n            (cons head (reverse_delete\
    \ tail c))\n            (cons (car s) (reverse_delete tail c)))))\n  (equal? (reverse\
    \ s) (reverse (reverse_delete s c))))\n", "  (cond\n    [(empty? s) (list '())]\n\
    \    [(equal? (first s) c) (cons (first s) (reverse_delete (rest s) c))]\n   \
    \ [else (reverse_delete (rest s) c)]))\n", "  (let loop ((s s)\n             (c\
    \ c))\n    (cond ((null? s) (list s))\n          ((eq? (car s) (cadr s)) (loop\
    \ (cdr s) c))\n          (else (loop (cdr s) c))))))\n", "  (cond\n    [(empty?\
    \ s) (list '())]\n    [(equal? (first s) c) (cons (first s) (reverse_delete (rest\
    \ s) c))]\n    [else (cons (first s) (reverse_delete (rest s) c))]))\n", "  (cond\n\
    \    [(empty? s) (list '())]\n    [(equal? (first s) c) (cons (first s) (reverse_delete\
    \ (rest s) c))]\n    [else (reverse_delete (rest s) c)]))\n", "  (let loop ((s\
    \ s)\n             (c c))\n    (cond ((null? s) (list s))\n          ((eq? (car\
    \ s) (cadr s)) (loop (cdr s) c))\n          (else (loop (cdr s) (car s))))))\n",
  "  (cond\n    [(empty? s) (list '())]\n    [(equal? (first s) c) (cons (first s)\
    \ (reverse_delete (rest s) c))]\n    [else (reverse_delete (rest s) c)]))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
