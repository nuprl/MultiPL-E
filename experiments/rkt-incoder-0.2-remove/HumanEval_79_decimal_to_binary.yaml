name: HumanEval_79_decimal_to_binary
language: rkt
prompt: "#lang racket\n\n;; You will be given a number in decimal form and your task\
  \ is to convert it to\n;; binary format. The function should return a string, with\
  \ each character representing a binary\n;; number. Each character in the string\
  \ will be '0' or '1'.\n;; There will be an extra couple of characters 'db' at the\
  \ beginning and at the end of the string.\n;; The extra characters are there to\
  \ help with the format.\n;; Examples:\n(define (decimal_to_binary decimal)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate decimal_to_binary))\n\
  \    (check-equal? (candidate 0) \"db0db\")\n    (check-equal? (candidate 32) \"\
  db100000db\")\n    (check-equal? (candidate 103) \"db1100111db\")\n    (check-equal?\
  \ (candidate 15) \"db1111db\")\n))\n\n(test-humaneval)"
completions: ["  (let loop ((decimal decimal)\n             (result '()))\n    (if\
    \ (> decimal 0)\n        (loop (sub1 decimal)\n               (conj result (if\
    \ (= decimal 0) '1\n                                (if (= decimal 1) '0\n   \
    \                               (if (= decimal 2) '10\n                      \
    \              '11))))))\n    (append 'db (reverse result))))\n", "  (define (helper\
    \ decimal acc)\n    (cond\n      [(= decimal 0) (append acc 'db)]\n      [(= decimal\
    \ 1) (append acc '1)]\n      [(= decimal -1) '(helper (- decimal 1) (append acc\
    \ '0))]\n      [else (helper (- decimal 1) (append acc '0))]))\n  (helper decimal\
    \ '()))\n", "  (let loop ((decimal decimal)\n             (result '()))\n    (if\
    \ (zero? decimal)\n        result\n        (loop (quotient decimal 2)\n      \
    \        (cons 0 (if (zero? (quotient decimal 2))\n                          '1\n\
    \                          '0))))))\n", "  (let ([remainder (remainder decimal\
    \ 2)])\n    (if (= remainder 0)\n        '()\n        (append (list 'db) (decimal_to_binary\
    \ remainder))))))\n", "  (let ([remainder (modulo decimal 2)])\n    (cond\n  \
    \    [(= remainder 0) 'db]\n      [(= remainder 1) '0]\n      [else (decimal_to_binary\
    \ (quotient decimal 2))])))\n", "  (let ([remainder (modulo decimal 2)])\n   \
    \ (cond\n      [(= remainder 0) 'db]\n      [(= remainder 1) '0]\n      [(= remainder\
    \ 2) '1]\n      [(= remainder 3) '10]\n      [(= remainder 4) '100]\n      [(=\
    \ remainder 5) '1000]\n      [(= remainder 6) '10000]\n      [(= remainder 7)\
    \ '100000]\n      [(= remainder 8) '1000000]\n      [(= remainder 9) '10000000]\n\
    \      [(= remainder 10) '100000000]\n      [(= remainder 11) '1000000000]\n \
    \     [(= remainder 12) '10000000000]\n      [(= remainder 13) '100000000000]\n\
    \      [(= remainder 14) '1000000000000]\n      [(= remainder 15) '10000000000000]\n\
    \      [(= remainder 16) '100000000000000]\n      [(= remainder 17) '1000000000000000]\n\
    \      [(= remainder 18) '10000000000000000]\n      [(= remainder 19) '100000000000000000]\n\
    \      [(= remainder 20) '1000000000000000001]\n      [(= remainder 21) '1000000000000000000]\n\
    \      [(= remainder 22) '10000000000000000000]\n      [(= remainder 23) '100000000000000000000]\n\
    \      [(= remainder 24) '1000000000000000000000]\n      [(= remainder 25) '10000000000000000000000]\n\
    \      [(= remainder 26) '100000000000000000000000]\n      [(= remainder 27) '1000000000000000000000000]\n\
    \      [(= remainder 28) '10000000000000000000000000]\n      [(= remainder 29)\
    \ '100000000000000000000000001]\n      [(= remainder 30) '100000000000000000000000000]\n\
    \      [(= remainder 31) '1000000000000000000000000000]\n      [(= remainder 32)\
    \ '10000000000000000000000000000]\n      [(= remainder 33) '100000000000000000000000000000]\n\
    \      [(= remainder 34) '1000000000000000000000000000000]\n      [(= remainder\
    \ 35) '10000000000000000000000000000000]\n      [(= remainder 36) '100000000000000000000000000000000]\n\
    \      [(= remainder 37) '1000000000000000000000000000000000]\n      [(= remainder\
    \ 38) '10000000000000000000000000000000001]\n      [(= remainder 39) '10000000000000000000000000000000000]\n\
    \      [(= remainder 40) '", "  (let loop ((decimal decimal)\n             (result\
    \ '()))\n    (if (= decimal 0)\n        (reverse result)\n        (loop (quotient\
    \ decimal 2)\n              (cons 0 (if (= (modulo decimal 2) 0)\n           \
    \               '1\n                          '0)))\n        (loop (quotient decimal\
    \ 2)\n              (cons 1 (if (= (modulo decimal 2) 0)\n                   \
    \       '1\n                          '0))))))\n", "  (cond\n    [(= decimal 0)\
    \ '0]\n    [(= decimal 1) '1]\n    [else (decimal_to_binary (quotient decimal\
    \ 2)\n                           (+ decimal 1))]))\n", "  (let ([remainder (modulo\
    \ decimal 2)])\n    (if (= remainder 0)\n        '()\n        (append (decimal_to_binary\
    \ (remainder 0)) 'db))))\n", "  (let loop ((decimal decimal)\n             (result\
    \ '()))\n    (if (zero? decimal)\n        result\n        (loop (quotient decimal\
    \ 2)\n              (cons (if (even? decimal)\n                       '1\n   \
    \                    '0)\n                    result)))))\n", "  (let loop ((decimal\
    \ decimal)\n             (result '()))\n    (if (= decimal 0)\n        (reverse\
    \ result)\n        (loop (quotient decimal 2)\n              (cons (if (= (quotient\
    \ decimal 2) 0)\n                       '0\n                       '1)\n     \
    \               result)))))\n", "  (let loop ((decimal decimal)\n            \
    \ (result '()))\n    (if (= decimal 0)\n        result\n        (loop (quotient\
    \ decimal 2)\n              (cons 0 (if (= (quotient decimal 2) 0)\n         \
    \                '1\n                         '0)))\n        (loop (quotient decimal\
    \ 2)\n              (cons 1 (if (= (quotient decimal 2) 0)\n                 \
    \        '1\n                         '0))))))\n", "  (let ([remainder (remainder\
    \ decimal 2)])\n    (if (= remainder 0)\n        '()\n        (append (list 'db)\
    \ (decimal_to_binary remainder)))))\n", "  (let loop ((decimal decimal)\n    \
    \         (result '()))\n    (if (> decimal 0)\n        (loop (quotient decimal\
    \ 2)\n               (cons 0 (if (= (quotient decimal 2) 0)\n                \
    \          '1\n                          '0)))\n        (reverse result))))\n",
  "  (let ([remainder (remainder decimal 2)])\n    (if (= remainder 0)\n        '()\n\
    \        (cons (if (= remainder 1) 'a 'b) (decimal_to_binary remainder)))))\n",
  "  (let ([result (make-string 64 #\\0)])\n    (decimal-to-binary-helper decimal\
    \ result 0 0))\n  (substring result 0 64))\n", "  (let loop ((decimal decimal)\n\
    \             (result '()))\n    (if (> decimal 0)\n        (loop (- decimal 1)\n\
    \               (cons decimal result))\n        result)))\n", "  (let loop ((decimal\
    \ decimal)\n             (result '()))\n    (if (= decimal 0)\n        (reverse\
    \ result)\n        (loop (quotient decimal 2)\n              (cons (if (= (modulo\
    \ decimal 2) 0)\n                       '0\n                       '1)\n     \
    \               result)))))\n", "  (let ([remainder (remainder decimal 2)])\n\
    \    (if (= remainder 0)\n        '()\n        (append (list (char 'db))\n   \
    \             (decimal_to_binary remainder))))))\n", "  (let loop ((decimal decimal)\n\
    \             (result '()))\n    (if (= decimal 0)\n        result\n        (loop\
    \ (sub1 decimal)\n              (cons (char->integer (char->string decimal)) result)))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
