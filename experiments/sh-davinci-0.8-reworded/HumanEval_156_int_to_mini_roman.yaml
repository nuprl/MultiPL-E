name: HumanEval_156_int_to_mini_roman
language: sh
prompt: "#!/bin/bash\n# Given a positive integer, obtain its roman numeral equivalent\
  \ as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n\
  # Examples:\n# >>> $(int_to_mini_roman \"19\")\n# \"xix\"\n# >>> $(int_to_mini_roman\
  \ \"152\")\n# \"clii\"\n# >>> $(int_to_mini_roman \"426\")\n# \"cdxxvi\"\n#\n# $1\
  \ is an integer\nint_to_mini_roman() {\n"
tests: "}\n\ncandidate() {\n    int_to_mini_roman \"$@\"\n}\n\nset -e\nrun_test()\
  \ {\n    [[ $(candidate \"19\") = \"xix\" ]]\n    [[ $(candidate \"152\") = \"clii\"\
  \ ]]\n    [[ $(candidate \"251\") = \"ccli\" ]]\n    [[ $(candidate \"426\") = \"\
  cdxxvi\" ]]\n    [[ $(candidate \"500\") = \"d\" ]]\n    [[ $(candidate \"1\") =\
  \ \"i\" ]]\n    [[ $(candidate \"4\") = \"iv\" ]]\n    [[ $(candidate \"43\") =\
  \ \"xliii\" ]]\n    [[ $(candidate \"90\") = \"xc\" ]]\n    [[ $(candidate \"94\"\
  ) = \"xciv\" ]]\n    [[ $(candidate \"532\") = \"dxxxii\" ]]\n    [[ $(candidate\
  \ \"900\") = \"cm\" ]]\n    [[ $(candidate \"994\") = \"cmxciv\" ]]\n    [[ $(candidate\
  \ \"1000\") = \"m\" ]]\n}\n\nrun_test"
completions: ["    if [ $1 -lt 1 -o $1 -gt 1000 ]; then\n        return 1\n    fi\n\
    \    if [ $1 -eq 1 ]; then\n        echo \"i\"\n        return 0\n    fi\n   \
    \ if [ $1 -eq 5 ]; then\n        echo \"v\"\n        return 0\n    fi\n    if\
    \ [ $1 -eq 10 ]; then\n        echo \"x\"\n        return 0\n    fi\n    if [\
    \ $1 -eq 50 ]; then\n        echo \"l\"\n        return 0\n    fi\n    if [ $1\
    \ -eq 100 ]; then\n        echo \"c\"\n        return 0\n    fi\n    if [ $1 -eq\
    \ 500 ]; then\n        echo \"d\"\n        return 0\n    fi\n    if [ $1 -eq 1000\
    \ ]; then\n        echo \"m\"\n        return 0\n    fi\n    if [ $1 -lt 5 ];\
    \ then\n        echo \"i$(int_to_mini_roman $(( $1 - 1 )))\"\n        return 0\n\
    \    fi\n    if [ $1 -lt 10 ]; then\n        echo \"v$(int_to_mini_roman $(( $1\
    \ - 5 )))\"\n        return 0\n    fi\n    if [ $1 -lt 50 ]; then\n        echo\
    \ \"x$(int_to_mini_roman $(( $1 - 10 )))\"\n        return 0\n    fi\n    if [\
    \ $1 -lt 100 ]; then\n        echo \"l$(int_to_mini_roman $(( $1 - 50 )))\"\n\
    \        return 0\n    fi\n    if [ $1 -lt 500 ]; then\n        echo \"c$(int_to_mini_roman\
    \ $(( $1 - 100 )))\"\n        return 0\n    fi\n    if [ $1 -lt 1000 ]; then\n\
    \        echo \"d$(int_to_mini_roman $(( $1 - 500 )))\"\n        return 0\n  \
    \  fi", "    # Init\n    local num=$1\n    local roman=''\n    local div=''\n\
    \    local remain=''\n    local factor=''\n    local i=''\n    local count=''\n\
    \    local local_expr=''\n    # Dict\n    local mini_roman_dict=( \\\n       \
    \ 'I' 'V' 'X' 'L' 'C' 'D' 'M' \\\n        'II' 'III' 'IV' 'VI' 'VII' 'VIII' 'IX'\
    \ \\\n        'XI' 'XII' 'XIII' 'XIV' 'XV' 'XVI' 'XVII' 'XVIII' 'XIX' \\\n   \
    \     'XX' 'XXI' 'XXII' 'XXIII' 'XXIV' 'XXV' 'XXVI' 'XXVII' 'XXVIII' 'XXIX' \\\
    \n        'XXX' 'XXXI' 'XXXII' 'XXXIII' 'XXXIV' 'XXXV' 'XXXVI' 'XXXVII' 'XXXVIII'\
    \ 'XXXIX' \\\n        'XL' 'L' 'LX' 'LXX' 'LXXX' 'XC' \\\n        'C' 'CI' 'CII'\
    \ 'CIII' 'CIV' 'CV' 'CVI' 'CVII' 'CVIII' 'CIX' \\\n        'CX' 'CXI' 'CXII' 'CXIII'\
    \ 'CXIV' 'CXV' 'CXVI' 'CXVII' 'CXVIII' 'CXIX' \\\n        'CXX' 'CXXI' 'CXXII'\
    \ 'CXXIII' 'CXXIV' 'CXXV' 'CXXVI' 'CXXVII' 'CXXVIII' 'CXXIX' \\\n        'CXXX'\
    \ 'CXXXI' 'CXXXII' 'CXXXIII' 'CXXXIV' 'CXXXV' 'CXXXVI' 'CXXXVII' 'CXXXVIII' 'CXXXIX'\
    \ \\\n        'CXL' 'CL' 'CLX' 'CLXX' 'CLXXX' 'CXC' \\\n        'CC' 'CCI' 'CCII'\
    \ 'CCIII", "    # Split the input number into its individual digits, then iterate\
    \ over each digit,\n    # and for each digit, map it to its corresponding roman\
    \ numeral.\n    # Finally, join the generated array of roman numerals by an empty\
    \ string.\n    echo \"$1\" | grep -o . | mapfile -t -c 1 | {\n        counter=0\n\
    \        while read digit; do\n            case $digit in\n                1)\
    \ roman=i ;;\n                2) roman=ii ;;\n                3) roman=iii ;;\n\
    \                4) roman=iv ;;\n                5) roman=v ;;\n             \
    \   6) roman=vi ;;\n                7) roman=vii ;;\n                8) roman=viii\
    \ ;;\n                9) roman=ix ;;\n                0) roman= ;;\n         \
    \   esac\n            printf \"$roman\"\n            ((counter++))\n        done\n\
    \    }", "    local number=\"$1\"\n    local result=\"\"\n    for d in {1000..1};\
    \ do\n        ((digit = number / d))\n        if ((digit)); then\n           \
    \ number=$((number % d))\n            result=\"$result\"\"$(int_to_mini_roman_digit\
    \ \"$digit\" \"$d\")\"\n        fi\n    done\n    echo \"$result\"", "    integer=$1\n\
    \n    case $integer in\n        1)\n            echo 'i';;\n        2)\n     \
    \       echo 'ii';;\n        3)\n            echo 'iii';;\n        4)\n      \
    \      echo 'iv';;\n        5)\n            echo 'v';;\n        6)\n         \
    \   echo 'vi';;\n        7)\n            echo 'vii';;\n        8)\n          \
    \  echo 'viii';;\n        9)\n            echo 'ix';;\n        10)\n         \
    \   echo 'x';;\n        20)\n            echo 'xx';;\n        30)\n          \
    \  echo 'xxx';;\n        40)\n            echo 'xl';;\n        50)\n         \
    \   echo 'l';;\n        60)\n            echo 'lx';;\n        70)\n          \
    \  echo 'lxx';;\n        80)\n            echo 'lxxx';;\n        90)\n       \
    \     echo 'xc';;\n        100)\n            echo 'c';;\n        200)\n      \
    \      echo 'cc';;\n        300)\n            echo 'ccc';;\n        400)\n   \
    \         echo 'cd';;\n        500)\n            echo 'd';;\n        600)\n  \
    \          echo 'dc';;\n        700)\n            echo 'dcc';;\n        800)\n\
    \            echo 'dccc';;\n        900)\n            echo 'cm';;\n        1000)\n\
    \            echo 'm';;\n        *)\n            echo $integer;;\n    esac", " \
    \   local n=$1\n    local d c l x v i\n    d=$((n/500))\n    c=$((n%500/100))\n\
    \    l=$((n%100/50))\n    x=$((n%50/10))\n    v=$((n%10/5))\n    i=$((n%5))\n\
    \    printf \"%s%s%s%s%s%s\" \\\n        $(printf \"%s\" \"d\" | xargs -I{} printf\
    \ \"{}\" $(seq $d)) \\\n        $(printf \"%s\" \"c\" | xargs -I{} printf \"{}\"\
    \ $(seq $c)) \\\n        $(printf \"%s\" \"l\" | xargs -I{} printf \"{}\" $(seq\
    \ $l)) \\\n        $(printf \"%s\" \"x\" | xargs -I{} printf \"{}\" $(seq $x))\
    \ \\\n        $(printf \"%s\" \"v\" | xargs -I{} printf \"{}\" $(seq $v)) \\\n\
    \        $(printf \"%s\" \"i\" | xargs -I{} printf \"{}\" $(seq $i))", "  local\
    \ int=$1\n  local numeral=\"\"\n  local characters\n  local num_characters\n \
    \ local num_remaining\n  local current_num\n  local current_numeral\n  local remainder\n\
    \  local i\n\n  # Create array of numeral characters and their corresponding values.\n\
    \  # Note that this array is ordered in reverse, as we'll be iterating over it.\n\
    \  # This gives us the ability to do modulo on the current int, and separate\n\
    \  # the ones, tens, hundreds, and thousands.\n  # Ex: If int is 8, the third\
    \ iteration is where we can do % 10, and get 0,\n  # which indicates we do not\
    \ need to add any characters for the tens place,\n  # and proceed to the hundreds.\n\
    \  local -A symbols=(\n    [M]=1000\n    [CM]=900\n    [D]=500\n    [CD]=400\n\
    \    [C]=100\n    [XC]=90\n    [L]=50\n    [XL]=40\n    [X]=10\n    [IX]=9\n \
    \   [V]=5\n    [IV]=4\n    [I]=1\n  )\n\n  # Get all the keys and values\n  characters=(${!symbols[@]})\n\
    \  num_characters=${#symbols[@]}\n\n  # Iterate over all the keys, starting from\
    \ the largest\n  for ((i=0; i<num_characters; i++)); do\n    # Get the current\
    \ symbol and corresponding number\n    current_numeral=${characters[$i]}\n   \
    \ current_num=${symbols[$current_numeral]}\n\n    # If the int is >= the current\
    \ number, we need to add it to the numeral\n    if ((int >= current_num)); then\n\
    \      # Get the number of times we need to add the numeral\n      num_remaining=$((int\
    \ / current_num))\n\n      # Add the necessary numeral to the string\n      while\
    \ ((num_remaining > 0)); do\n        numeral+=$current_numeral\n        num_remaining=$((num_remaining\
    \ - 1))\n      done\n\n      # Get the remainder of int / current_num\n      remainder=$((int\
    \ % current_num))\n\n      # Break out of the", "  int=$1\n  roman=\"\"\n  while\
    \ [ \"$int\" -gt 0 ]; do\n    if [ \"$int\" -ge 1000 ]; then\n      ((int -= 1000))\n\
    \      roman+=\"m\"\n    elif [ \"$int\" -ge 900 ]; then\n      ((int -= 900))\n\
    \      roman+=\"cm\"\n    elif [ \"$int\" -ge 500 ]; then\n      ((int -= 500))\n\
    \      roman+=\"d\"\n    elif [ \"$int\" -ge 400 ]; then\n      ((int -= 400))\n\
    \      roman+=\"cd\"\n    elif [ \"$int\" -ge 100 ]; then\n      ((int -= 100))\n\
    \      roman+=\"c\"\n    elif [ \"$int\" -ge 90 ]; then\n      ((int -= 90))\n\
    \      roman+=\"xc\"\n    elif [ \"$int\" -ge 50 ]; then\n      ((int -= 50))\n\
    \      roman+=\"l\"\n    elif [ \"$int\" -ge 40 ]; then\n      ((int -= 40))\n\
    \      roman+=\"xl\"\n    elif [ \"$int\" -ge 10 ]; then\n      ((int -= 10))\n\
    \      roman+=\"x\"\n    elif [ \"$int\" -ge 9 ]; then\n      ((int -= 9))\n \
    \     roman+=\"ix\"\n    elif [ \"$int\" -ge 5 ]; then\n      ((int -= 5))\n \
    \     roman+=\"v\"\n    elif [ \"$int\" -ge 4 ]; then\n      ((int -= 4))\n  \
    \    roman+=\"iv\"\n    else\n      ((int -= 1))\n      roman+=\"i\"\n    fi\n\
    \  done\n  echo \"$roman\"", "  local __retval=$(int_to_roman \"$1\")\n  echo\
    \ \"${__retval,,}\"", "    local num=$1\n    local result=\"\"\n    local -a n=(\"\
    m\" \"cm\" \"d\" \"cd\" \"c\" \"xc\" \"l\" \"xl\" \"x\" \"ix\" \"v\" \"iv\" \"\
    i\")\n    local -a v=(1000 900 500 400 100 90 50 40 10 9 5 4 1)\n    for (( i=0;\
    \ i<${#v[@]}; i++ )); do\n        while (( num >= v[i] )); do\n            result+=${n[i]}\n\
    \            ((num-=v[i]))\n        done\n    done\n    echo \"$result\"", " \
    \   # initialize return string\n    local str=\"\"\n    # list of 10's place in\
    \ descending order\n    local d=(X C M)\n    # list of 1's place in descending\
    \ order\n    local u=(I V X)\n    # list of 5's place in descending order\n  \
    \  local f=(V L D)\n    # pad input to 4 digits, reverse it\n    local n=$(printf\
    \ \"%04d\" $1 | rev)\n    local idx=0\n    local i=0\n    # loop through each\
    \ digit\n    for i in `seq 0 3`; do\n        idx=$((i/2))\n        if [ $i -eq\
    \ 1 ]; then\n            str+=$(d2f ${n:$i:1} ${u[$idx]} ${f[$idx]})\n       \
    \ elif [ $i -eq 3 ]; then\n            str+=$(d2u ${n:$i:1} ${d[$idx]})\n    \
    \    else\n            str+=$(d2u ${n:$i:1} ${u[$idx]})\n        fi\n    done\n\
    \    echo $str", "  local num=$1\n  if (( num <= 1000 )); then\n    while (( num\
    \ > 0 )); do\n      # Start with 1000s.\n      if (( num >= 1000 )); then\n  \
    \      printf 'm'\n        (( num -= 1000 ))\n      elif (( num >= 900 )); then\n\
    \        printf 'cm'\n        (( num -= 900 ))\n      elif (( num >= 500 )); then\n\
    \        printf 'd'\n        (( num -= 500 ))\n      elif (( num >= 400 )); then\n\
    \        printf 'cd'\n        (( num -= 400 ))\n      elif (( num >= 100 )); then\n\
    \        printf 'c'\n        (( num -= 100 ))\n      elif (( num >= 90 )); then\n\
    \        printf 'xc'\n        (( num -= 90 ))\n      elif (( num >= 50 )); then\n\
    \        printf 'l'\n        (( num -= 50 ))\n      elif (( num >= 40 )); then\n\
    \        printf 'xl'\n        (( num -= 40 ))\n      elif (( num >= 10 )); then\n\
    \        printf 'x'\n        (( num -= 10 ))\n      elif (( num >= 9 )); then\n\
    \        printf 'ix'\n        (( num -= 9 ))\n      elif (( num >= 5 )); then\n\
    \        printf 'v'\n        (( num -= 5 ))\n      elif (( num >= 4 )); then\n\
    \        printf 'iv'\n        (( num -= 4 ))\n      elif (( num >= 1 )); then\n\
    \        printf 'i'\n        (( num -= 1 ))\n      fi\n    done\n  fi", "    local\
    \ m_ones=\"ixv\"\n    local m_fives=\"xlcdm\"\n    local m_ten_ones=''\n    local\
    \ m_ones_digit=''\n    local m_fives_digit=''\n    local m_ten_ones_digit=''\n\
    \    local m_roman=''\n    # Calculate the roman digit for the ones place\n  \
    \  m_ones_digit=\"$(($1 % 10))\"\n    m_ones_digit=$((m_ones_digit - 5))\n   \
    \ if [ $m_ones_digit -ge 0 ]; then\n        m_roman=\"${m_ones:0:$m_ones_digit}${m_fives:0:1}\"\
    \n    else\n        m_ones_digit=$((m_ones_digit + 5))\n        m_roman=\"${m_fives:0:1}${m_ones:0:$m_ones_digit}\"\
    \n    fi\n    # Calculate the roman digit for the tens place\n    m_ten_ones_digit=\"\
    $(($1 % 100))\"\n    m_ten_ones_digit=$((m_ten_ones_digit / 10))\n    m_ten_ones_digit=$((m_ten_ones_digit\
    \ - 5))\n    if [ $m_ten_ones_digit -ge 0 ]; then\n        m_roman=\"${m_ones:0:$m_ten_ones_digit}${m_fives:1:1}${m_roman}\"\
    \n    else\n        m_ten_ones_digit=$((m_ten_ones_digit + 5))\n        m_roman=\"\
    ${m_fives:1:1}${m_ones:0:$m_ten_ones_digit}${m_roman}\"\n    fi\n    # Calculate\
    \ the roman digit for the hundreds place\n    m_hundreds_digit=\"$(($1 % 1000))\"\
    \n    m_hundreds_digit=$((m_hundreds_digit / 100))\n    m_hundreds_digit=$((m_hundreds_digit\
    \ - 5))\n    if [ $m_hundreds_digit -ge 0 ]; then\n        m_roman=\"${m_ones:0:$m_hundreds_",
  "  awk 'BEGIN {\n    ORS = \"\";\n    digits[1] = \"i\";\n    digits[2] = \"ii\"\
    ;\n    digits[3] = \"iii\";\n    digits[4] = \"iv\";\n    digits[5] = \"v\";\n\
    \    digits[6] = \"vi\";\n    digits[7] = \"vii\";\n    digits[8] = \"viii\";\n\
    \    digits[9] = \"ix\";\n    num = \"'$1'\";\n    while (num > 0) {\n      rem\
    \ = num % 10;\n      num = int(num / 10);\n      if (rem > 0) {\n        print\
    \ digits[rem];\n      }\n    }\n  }'", "  local num=\"$1\"\n  local roman_val\n\
    \  for denom in 1 5 10 50 100 500 1000\n  do\n    local current_char=$(plural_to_mini_roman\
    \ $denom)\n    local count=$((num / denom))\n    if [ $count -gt 0 ] && [ $count\
    \ -lt 4 ]\n    then\n      while [ $count -gt 0 ]\n      do\n        roman_val+=$current_char\n\
    \        ((count--))\n      done\n      ((num %= denom))\n    fi\n  done\n  echo\
    \ \"$roman_val\"", "    local num=\"$1\"\n    local i=0\n    local result=''\n\
    \    for (( i=0; i<\"${#ROMAN_POWER_OF_TEN[@]}\"; i++ )); do\n        local div_by_power=\"\
    $(( num / 10 ** i ))\"\n        if (( div_by_power > 0 )); then\n            num=\"\
    $(( num % 10 ** i ))\"\n            result+=\"$(int_to_roman \"$div_by_power\"\
    \ \"${ROMAN_POWER_OF_TEN[$i]}\")\"\n        fi\n    done\n    # Remove any adjacent\
    \ duplicate symbols, e.g. 'IIII' -> 'IV'.\n    echo \"$result\" | sed 's/MMMMM/v/g;\
    \ s/MMMM/iv/g; s/MMM/ix/g; s/MM/xl/g; s/M/xc/g; s/XXXXX/v/g; s/XXXX/iv/g; s/XXX/ix/g;\
    \ s/XX/xl/g; s/X/xc/g; s/vv/x/g; s/iv/xiv/g; s/ix/xix/g; s/xl/lx/g; s/xc/cx/g;\
    \ s/lll/xc/g; s/ll/lx/g; s/l/xc/g; s/ccc/cd/g; s/cc/xc/g; s/c/cd/g; s/dd/cm/g;\
    \ s/d/cm/g' | sed 's/iii/ix/g; s/ii/iv/g; s/i/ix/g' | tr -d 'v'", "    local num=\"\
    $1\"\n    local result=''\n    local thousands=''\n    local hundreds=''\n   \
    \ local tens=''\n    local ones=''\n    local i=''\n    local j=''\n    local\
    \ x=''\n    local y=''\n    local c=''\n    local digit=''\n    local exception=''\n\
    \    local exception_num=''\n    local exception_mini_roman=''\n    local exceptions_file='exceptions.txt'\n\
    \    local exceptions=()\n    local exceptions_len=0\n    #echo \"num is $num\"\
    \n\n    if [[ $num -lt 1 || $num -gt 1000 ]]; then\n        echo \"number must\
    \ be between 1 and 1000\" >&2\n        return 1\n    fi\n\n    # read exceptions\
    \ into an array\n    while read -r exception\n    do\n        exceptions+=(\"\
    $exception\")\n    done < $exceptions_file\n    exceptions_len=\"${#exceptions[@]}\"\
    \n\n    # Convert $num to thousands, hundreds, tens, and ones\n    thousands=$((\
    \ num / 1000 ))\n    hundreds=$(( (num % 1000) / 100 ))\n    tens=$(( (num % 100)\
    \ / 10 ))\n    ones=$(( num % 10 ))\n\n    # See if $num is an exception and return\
    \ roman numeral\n    for (( i=0; i<exceptions_len; i++ ))\n    do\n        exception=\"\
    ${exceptions[$i]}\"\n        exception_num=\"${exception% *}\"\n        exception_mini_roman=\"\
    ${exception#* }\"\n        if [[ $num -eq $exception_num ]]; then\n          \
    \  echo \"$exception_mini_roman\"\n            return 0\n        fi\n    done\n\
    \n    # Process thousands\n    for (( i=0; i<thousands; i++ ))\n    do\n     \
    \   result+='m'\n    done\n\n    # Process hundreds\n    if [[ $hundreds -eq 0\
    \ ]]; then\n        # do nothing\n        true\n    elif [[ $hundreds -eq 4 ]];\
    \ then\n        result+='cd'\n    elif [[ $hundreds -eq 5 ]]; then\n        result+='d'\n\
    \    elif [[ $hundreds -eq 9 ]]; then", "  local int=\"$1\"\n  local roman=\"\
    $(($int / 1000))m\"\n  int=\"$(($int % 1000))\"\n  roman=\"$roman$(($int / 500))d\"\
    \n  int=\"$(($int % 500))\"\n  roman=\"$roman$(($int / 100))c\"\n  int=\"$(($int\
    \ % 100))\"\n  roman=\"$roman$(($int / 50))l\"\n  int=\"$(($int % 50))\"\n  roman=\"\
    $roman$(($int / 10))x\"\n  int=\"$(($int % 10))\"\n  roman=\"$roman$(($int / 5))v\"\
    \n  int=\"$(($int % 5))\"\n  roman=\"$roman$int\"\n  echo \"$roman\"", "    local\
    \ output=\"\"\n    local args=\"$@\"\n    local args_copy=\"$args\"\n    # Size\
    \ checks\n    if (( args_copy > 1000 )); then\n        echo \"error: number must\
    \ be less than 1000\"\n        return 1\n    elif (( args_copy < 1 )); then\n\
    \        echo \"error: number must be greater than 0\"\n        return 1\n   \
    \ fi\n    # Integer to romain conversion algorithm\n    local romans=(M D C L\
    \ X V I)\n    local romans_size=${#romans[@]}\n    for (( i=0; i<romans_size;\
    \ i++ ))\n    do\n        local factor=$(( 2**(2*i) ))\n        local count=$((\
    \ args_copy / factor ))\n        args_copy=$(( args_copy % factor ))\n       \
    \ while (( count-- > 0 ))\n        do\n            output+=\"${romans[i]}\"\n\
    \        done\n    done\n    # Perform substitutions\n    output=${output/M/m}\n\
    \    output=${output/D/d}\n    output=${output/C/c}\n    output=${output/L/l}\n\
    \    output=${output/X/x}\n    output=${output/V/v}\n    output=${output/I/i}\n\
    \    echo \"$output\"", "    local original_int=${1}\n    local result=\"\"\n\
    \    local int=${original_int}\n    while [ ${int} -gt 0 ]; do\n        local\
    \ add_on=\"\"\n        if [ ${int} -ge 1000 ]; then\n            add_on=\"m\"\n\
    \            int=$((int - 1000))\n        elif [ ${int} -ge 900 ]; then\n    \
    \        add_on=\"cm\"\n            int=$((int - 900))\n        elif [ ${int}\
    \ -ge 500 ]; then\n            add_on=\"d\"\n            int=$((int - 500))\n\
    \        elif [ ${int} -ge 400 ]; then\n            add_on=\"cd\"\n          \
    \  int=$((int - 400))\n        elif [ ${int} -ge 100 ]; then\n            add_on=\"\
    c\"\n            int=$((int - 100))\n        elif [ ${int} -ge 90 ]; then\n  \
    \          add_on=\"xc\"\n            int=$((int - 90))\n        elif [ ${int}\
    \ -ge 50 ]; then\n            add_on=\"l\"\n            int=$((int - 50))\n  \
    \      elif [ ${int} -ge 40 ]; then\n            add_on=\"xl\"\n            int=$((int\
    \ - 40))\n        elif [ ${int} -ge 10 ]; then\n            add_on=\"x\"\n   \
    \         int=$((int - 10))\n        elif [ ${int} -ge 9 ]; then\n           \
    \ add_on=\"ix\"\n            int=$((int - 9))\n        elif [ ${int} -ge 5 ];\
    \ then\n            add_on=\"v\"\n            int=$((int - 5))\n        elif [\
    \ ${int} -ge 4 ]; then\n            add_on=\"iv\"\n            int=$((int - 4))\n\
    \        elif [ ${int} -ge 1 ]; then\n            add_on=\"i\"\n            int=$((int\
    \ - 1))\n        fi\n        result=${result}${add_on}\n    done\n    echo ${result}"]
stop_tokens:
- "\n}"
