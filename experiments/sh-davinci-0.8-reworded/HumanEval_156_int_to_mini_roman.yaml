name: HumanEval_156_int_to_mini_roman
language: sh
prompt: "#!/bin/bash\n# Given a positive integer, obtain its roman numeral equivalent\
  \ as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n\
  # Examples:\n# >>> $(int_to_mini_roman \"19\")\n# \"xix\"\n# >>> $(int_to_mini_roman\
  \ \"152\")\n# \"clii\"\n# >>> $(int_to_mini_roman \"426\")\n# \"cdxxvi\"\n#\n# $1\
  \ is an integer\nint_to_mini_roman() {\n"
tests: "}\n\ncandidate() {\n    int_to_mini_roman \"$@\"\n}\n\nset -e\nrun_test()\
  \ {\n    [[ $(candidate \"19\") = \"xix\" ]]\n    [[ $(candidate \"152\") = \"clii\"\
  \ ]]\n    [[ $(candidate \"251\") = \"ccli\" ]]\n    [[ $(candidate \"426\") = \"\
  cdxxvi\" ]]\n    [[ $(candidate \"500\") = \"d\" ]]\n    [[ $(candidate \"1\") =\
  \ \"i\" ]]\n    [[ $(candidate \"4\") = \"iv\" ]]\n    [[ $(candidate \"43\") =\
  \ \"xliii\" ]]\n    [[ $(candidate \"90\") = \"xc\" ]]\n    [[ $(candidate \"94\"\
  ) = \"xciv\" ]]\n    [[ $(candidate \"532\") = \"dxxxii\" ]]\n    [[ $(candidate\
  \ \"900\") = \"cm\" ]]\n    [[ $(candidate \"994\") = \"cmxciv\" ]]\n    [[ $(candidate\
  \ \"1000\") = \"m\" ]]\n}\n\nrun_test"
completions: ["    if [ $1 -lt 1 -o $1 -gt 1000 ]; then\n        return 1\n    fi\n\
    \    if [ $1 -eq 1 ]; then\n        echo \"i\"\n        return 0\n    fi\n   \
    \ if [ $1 -eq 5 ]; then\n        echo \"v\"\n        return 0\n    fi\n    if\
    \ [ $1 -eq 10 ]; then\n        echo \"x\"\n        return 0\n    fi\n    if [\
    \ $1 -eq 50 ]; then\n        echo \"l\"\n        return 0\n    fi\n    if [ $1\
    \ -eq 100 ]; then\n        echo \"c\"\n        return 0\n    fi\n    if [ $1 -eq\
    \ 500 ]; then\n        echo \"d\"\n        return 0\n    fi\n    if [ $1 -eq 1000\
    \ ]; then\n        echo \"m\"\n        return 0\n    fi\n    if [ $1 -lt 5 ];\
    \ then\n        echo \"i$(int_to_mini_roman $(( $1 - 1 )))\"\n        return 0\n\
    \    fi\n    if [ $1 -lt 10 ]; then\n        echo \"v$(int_to_mini_roman $(( $1\
    \ - 5 )))\"\n        return 0\n    fi\n    if [ $1 -lt 50 ]; then\n        echo\
    \ \"x$(int_to_mini_roman $(( $1 - 10 )))\"\n        return 0\n    fi\n    if [\
    \ $1 -lt 100 ]; then\n        echo \"l$(int_to_mini_roman $(( $1 - 50 )))\"\n\
    \        return 0\n    fi\n    if [ $1 -lt 500 ]; then\n        echo \"c$(int_to_mini_roman\
    \ $(( $1 - 100 )))\"\n        return 0\n    fi\n    if [ $1 -lt 1000 ]; then\n\
    \        echo \"d$(int_to_mini_roman $(( $1 - 500 )))\"\n        return 0\n  \
    \  fi", "    # Init\n    local num=$1\n    local roman=''\n    local div=''\n\
    \    local remain=''\n    local factor=''\n    local i=''\n    local count=''\n\
    \    local local_expr=''\n    # Dict\n    local mini_roman_dict=( \\\n       \
    \ 'I' 'V' 'X' 'L' 'C' 'D' 'M' \\\n        'II' 'III' 'IV' 'VI' 'VII' 'VIII' 'IX'\
    \ \\\n        'XI' 'XII' 'XIII' 'XIV' 'XV' 'XVI' 'XVII' 'XVIII' 'XIX' \\\n   \
    \     'XX' 'XXI' 'XXII' 'XXIII' 'XXIV' 'XXV' 'XXVI' 'XXVII' 'XXVIII' 'XXIX' \\\
    \n        'XXX' 'XXXI' 'XXXII' 'XXXIII' 'XXXIV' 'XXXV' 'XXXVI' 'XXXVII' 'XXXVIII'\
    \ 'XXXIX' \\\n        'XL' 'L' 'LX' 'LXX' 'LXXX' 'XC' \\\n        'C' 'CI' 'CII'\
    \ 'CIII' 'CIV' 'CV' 'CVI' 'CVII' 'CVIII' 'CIX' \\\n        'CX' 'CXI' 'CXII' 'CXIII'\
    \ 'CXIV' 'CXV' 'CXVI' 'CXVII' 'CXVIII' 'CXIX' \\\n        'CXX' 'CXXI' 'CXXII'\
    \ 'CXXIII' 'CXXIV' 'CXXV' 'CXXVI' 'CXXVII' 'CXXVIII' 'CXXIX' \\\n        'CXXX'\
    \ 'CXXXI' 'CXXXII' 'CXXXIII' 'CXXXIV' 'CXXXV' 'CXXXVI' 'CXXXVII' 'CXXXVIII' 'CXXXIX'\
    \ \\\n        'CXL' 'CL' 'CLX' 'CLXX' 'CLXXX' 'CXC' \\\n        'CC' 'CCI' 'CCII'\
    \ 'CCIII", "    # Split the input number into its individual digits, then iterate\
    \ over each digit,\n    # and for each digit, map it to its corresponding roman\
    \ numeral.\n    # Finally, join the generated array of roman numerals by an empty\
    \ string.\n    echo \"$1\" | grep -o . | mapfile -t -c 1 | {\n        counter=0\n\
    \        while read digit; do\n            case $digit in\n                1)\
    \ roman=i ;;\n                2) roman=ii ;;\n                3) roman=iii ;;\n\
    \                4) roman=iv ;;\n                5) roman=v ;;\n             \
    \   6) roman=vi ;;\n                7) roman=vii ;;\n                8) roman=viii\
    \ ;;\n                9) roman=ix ;;\n                0) roman= ;;\n         \
    \   esac\n            printf \"$roman\"\n            ((counter++))\n        done\n\
    \    }", "    local number=\"$1\"\n    local result=\"\"\n    for d in {1000..1};\
    \ do\n        ((digit = number / d))\n        if ((digit)); then\n           \
    \ number=$((number % d))\n            result=\"$result\"\"$(int_to_mini_roman_digit\
    \ \"$digit\" \"$d\")\"\n        fi\n    done\n    echo \"$result\"", "    integer=$1\n\
    \n    case $integer in\n        1)\n            echo 'i';;\n        2)\n     \
    \       echo 'ii';;\n        3)\n            echo 'iii';;\n        4)\n      \
    \      echo 'iv';;\n        5)\n            echo 'v';;\n        6)\n         \
    \   echo 'vi';;\n        7)\n            echo 'vii';;\n        8)\n          \
    \  echo 'viii';;\n        9)\n            echo 'ix';;\n        10)\n         \
    \   echo 'x';;\n        20)\n            echo 'xx';;\n        30)\n          \
    \  echo 'xxx';;\n        40)\n            echo 'xl';;\n        50)\n         \
    \   echo 'l';;\n        60)\n            echo 'lx';;\n        70)\n          \
    \  echo 'lxx';;\n        80)\n            echo 'lxxx';;\n        90)\n       \
    \     echo 'xc';;\n        100)\n            echo 'c';;\n        200)\n      \
    \      echo 'cc';;\n        300)\n            echo 'ccc';;\n        400)\n   \
    \         echo 'cd';;\n        500)\n            echo 'd';;\n        600)\n  \
    \          echo 'dc';;\n        700)\n            echo 'dcc';;\n        800)\n\
    \            echo 'dccc';;\n        900)\n            echo 'cm';;\n        1000)\n\
    \            echo 'm';;\n        *)\n            echo $integer;;\n    esac", " \
    \   local n=$1\n    local d c l x v i\n    d=$((n/500))\n    c=$((n%500/100))\n\
    \    l=$((n%100/50))\n    x=$((n%50/10))\n    v=$((n%10/5))\n    i=$((n%5))\n\
    \    printf \"%s%s%s%s%s%s\" \\\n        $(printf \"%s\" \"d\" | xargs -I{} printf\
    \ \"{}\" $(seq $d)) \\\n        $(printf \"%s\" \"c\" | xargs -I{} printf \"{}\"\
    \ $(seq $c)) \\\n        $(printf \"%s\" \"l\" | xargs -I{} printf \"{}\" $(seq\
    \ $l)) \\\n        $(printf \"%s\" \"x\" | xargs -I{} printf \"{}\" $(seq $x))\
    \ \\\n        $(printf \"%s\" \"v\" | xargs -I{} printf \"{}\" $(seq $v)) \\\n\
    \        $(printf \"%s\" \"i\" | xargs -I{} printf \"{}\" $(seq $i))", "  local\
    \ int=$1\n  local numeral=\"\"\n  local characters\n  local num_characters\n \
    \ local num_remaining\n  local current_num\n  local current_numeral\n  local remainder\n\
    \  local i\n\n  # Create array of numeral characters and their corresponding values.\n\
    \  # Note that this array is ordered in reverse, as we'll be iterating over it.\n\
    \  # This gives us the ability to do modulo on the current int, and separate\n\
    \  # the ones, tens, hundreds, and thousands.\n  # Ex: If int is 8, the third\
    \ iteration is where we can do % 10, and get 0,\n  # which indicates we do not\
    \ need to add any characters for the tens place,\n  # and proceed to the hundreds.\n\
    \  local -A symbols=(\n    [M]=1000\n    [CM]=900\n    [D]=500\n    [CD]=400\n\
    \    [C]=100\n    [XC]=90\n    [L]=50\n    [XL]=40\n    [X]=10\n    [IX]=9\n \
    \   [V]=5\n    [IV]=4\n    [I]=1\n  )\n\n  # Get all the keys and values\n  characters=(${!symbols[@]})\n\
    \  num_characters=${#symbols[@]}\n\n  # Iterate over all the keys, starting from\
    \ the largest\n  for ((i=0; i<num_characters; i++)); do\n    # Get the current\
    \ symbol and corresponding number\n    current_numeral=${characters[$i]}\n   \
    \ current_num=${symbols[$current_numeral]}\n\n    # If the int is >= the current\
    \ number, we need to add it to the numeral\n    if ((int >= current_num)); then\n\
    \      # Get the number of times we need to add the numeral\n      num_remaining=$((int\
    \ / current_num))\n\n      # Add the necessary numeral to the string\n      while\
    \ ((num_remaining > 0)); do\n        numeral+=$current_numeral\n        num_remaining=$((num_remaining\
    \ - 1))\n      done\n\n      # Get the remainder of int / current_num\n      remainder=$((int\
    \ % current_num))\n\n      # Break out of the", "  int=$1\n  roman=\"\"\n  while\
    \ [ \"$int\" -gt 0 ]; do\n    if [ \"$int\" -ge 1000 ]; then\n      ((int -= 1000))\n\
    \      roman+=\"m\"\n    elif [ \"$int\" -ge 900 ]; then\n      ((int -= 900))\n\
    \      roman+=\"cm\"\n    elif [ \"$int\" -ge 500 ]; then\n      ((int -= 500))\n\
    \      roman+=\"d\"\n    elif [ \"$int\" -ge 400 ]; then\n      ((int -= 400))\n\
    \      roman+=\"cd\"\n    elif [ \"$int\" -ge 100 ]; then\n      ((int -= 100))\n\
    \      roman+=\"c\"\n    elif [ \"$int\" -ge 90 ]; then\n      ((int -= 90))\n\
    \      roman+=\"xc\"\n    elif [ \"$int\" -ge 50 ]; then\n      ((int -= 50))\n\
    \      roman+=\"l\"\n    elif [ \"$int\" -ge 40 ]; then\n      ((int -= 40))\n\
    \      roman+=\"xl\"\n    elif [ \"$int\" -ge 10 ]; then\n      ((int -= 10))\n\
    \      roman+=\"x\"\n    elif [ \"$int\" -ge 9 ]; then\n      ((int -= 9))\n \
    \     roman+=\"ix\"\n    elif [ \"$int\" -ge 5 ]; then\n      ((int -= 5))\n \
    \     roman+=\"v\"\n    elif [ \"$int\" -ge 4 ]; then\n      ((int -= 4))\n  \
    \    roman+=\"iv\"\n    else\n      ((int -= 1))\n      roman+=\"i\"\n    fi\n\
    \  done\n  echo \"$roman\"", "  local __retval=$(int_to_roman \"$1\")\n  echo\
    \ \"${__retval,,}\"", "    local num=$1\n    local result=\"\"\n    local -a n=(\"\
    m\" \"cm\" \"d\" \"cd\" \"c\" \"xc\" \"l\" \"xl\" \"x\" \"ix\" \"v\" \"iv\" \"\
    i\")\n    local -a v=(1000 900 500 400 100 90 50 40 10 9 5 4 1)\n    for (( i=0;\
    \ i<${#v[@]}; i++ )); do\n        while (( num >= v[i] )); do\n            result+=${n[i]}\n\
    \            ((num-=v[i]))\n        done\n    done\n    echo \"$result\"", " \
    \   # initialize return string\n    local str=\"\"\n    # list of 10's place in\
    \ descending order\n    local d=(X C M)\n    # list of 1's place in descending\
    \ order\n    local u=(I V X)\n    # list of 5's place in descending order\n  \
    \  local f=(V L D)\n    # pad input to 4 digits, reverse it\n    local n=$(printf\
    \ \"%04d\" $1 | rev)\n    local idx=0\n    local i=0\n    # loop through each\
    \ digit\n    for i in `seq 0 3`; do\n        idx=$((i/2))\n        if [ $i -eq\
    \ 1 ]; then\n            str+=$(d2f ${n:$i:1} ${u[$idx]} ${f[$idx]})\n       \
    \ elif [ $i -eq 3 ]; then\n            str+=$(d2u ${n:$i:1} ${d[$idx]})\n    \
    \    else\n            str+=$(d2u ${n:$i:1} ${u[$idx]})\n        fi\n    done\n\
    \    echo $str", "  local num=$1\n  if (( num <= 1000 )); then\n    while (( num\
    \ > 0 )); do\n      # Start with 1000s.\n      if (( num >= 1000 )); then\n  \
    \      printf 'm'\n        (( num -= 1000 ))\n      elif (( num >= 900 )); then\n\
    \        printf 'cm'\n        (( num -= 900 ))\n      elif (( num >= 500 )); then\n\
    \        printf 'd'\n        (( num -= 500 ))\n      elif (( num >= 400 )); then\n\
    \        printf 'cd'\n        (( num -= 400 ))\n      elif (( num >= 100 )); then\n\
    \        printf 'c'\n        (( num -= 100 ))\n      elif (( num >= 90 )); then\n\
    \        printf 'xc'\n        (( num -= 90 ))\n      elif (( num >= 50 )); then\n\
    \        printf 'l'\n        (( num -= 50 ))\n      elif (( num >= 40 )); then\n\
    \        printf 'xl'\n        (( num -= 40 ))\n      elif (( num >= 10 )); then\n\
    \        printf 'x'\n        (( num -= 10 ))\n      elif (( num >= 9 )); then\n\
    \        printf 'ix'\n        (( num -= 9 ))\n      elif (( num >= 5 )); then\n\
    \        printf 'v'\n        (( num -= 5 ))\n      elif (( num >= 4 )); then\n\
    \        printf 'iv'\n        (( num -= 4 ))\n      elif (( num >= 1 )); then\n\
    \        printf 'i'\n        (( num -= 1 ))\n      fi\n    done\n  fi", "    local\
    \ m_ones=\"ixv\"\n    local m_fives=\"xlcdm\"\n    local m_ten_ones=''\n    local\
    \ m_ones_digit=''\n    local m_fives_digit=''\n    local m_ten_ones_digit=''\n\
    \    local m_roman=''\n    # Calculate the roman digit for the ones place\n  \
    \  m_ones_digit=\"$(($1 % 10))\"\n    m_ones_digit=$((m_ones_digit - 5))\n   \
    \ if [ $m_ones_digit -ge 0 ]; then\n        m_roman=\"${m_ones:0:$m_ones_digit}${m_fives:0:1}\"\
    \n    else\n        m_ones_digit=$((m_ones_digit + 5))\n        m_roman=\"${m_fives:0:1}${m_ones:0:$m_ones_digit}\"\
    \n    fi\n    # Calculate the roman digit for the tens place\n    m_ten_ones_digit=\"\
    $(($1 % 100))\"\n    m_ten_ones_digit=$((m_ten_ones_digit / 10))\n    m_ten_ones_digit=$((m_ten_ones_digit\
    \ - 5))\n    if [ $m_ten_ones_digit -ge 0 ]; then\n        m_roman=\"${m_ones:0:$m_ten_ones_digit}${m_fives:1:1}${m_roman}\"\
    \n    else\n        m_ten_ones_digit=$((m_ten_ones_digit + 5))\n        m_roman=\"\
    ${m_fives:1:1}${m_ones:0:$m_ten_ones_digit}${m_roman}\"\n    fi\n    # Calculate\
    \ the roman digit for the hundreds place\n    m_hundreds_digit=\"$(($1 % 1000))\"\
    \n    m_hundreds_digit=$((m_hundreds_digit / 100))\n    m_hundreds_digit=$((m_hundreds_digit\
    \ - 5))\n    if [ $m_hundreds_digit -ge 0 ]; then\n        m_roman=\"${m_ones:0:$m_hundreds_",
  "  awk 'BEGIN {\n    ORS = \"\";\n    digits[1] = \"i\";\n    digits[2] = \"ii\"\
    ;\n    digits[3] = \"iii\";\n    digits[4] = \"iv\";\n    digits[5] = \"v\";\n\
    \    digits[6] = \"vi\";\n    digits[7] = \"vii\";\n    digits[8] = \"viii\";\n\
    \    digits[9] = \"ix\";\n    num = \"'$1'\";\n    while (num > 0) {\n      rem\
    \ = num % 10;\n      num = int(num / 10);\n      if (rem > 0) {\n        print\
    \ digits[rem];\n      }\n    }\n  }'", "  local num=\"$1\"\n  local roman_val\n\
    \  for denom in 1 5 10 50 100 500 1000\n  do\n    local current_char=$(plural_to_mini_roman\
    \ $denom)\n    local count=$((num / denom))\n    if [ $count -gt 0 ] && [ $count\
    \ -lt 4 ]\n    then\n      while [ $count -gt 0 ]\n      do\n        roman_val+=$current_char\n\
    \        ((count--))\n      done\n      ((num %= denom))\n    fi\n  done\n  echo\
    \ \"$roman_val\"", "    local num=\"$1\"\n    local i=0\n    local result=''\n\
    \    for (( i=0; i<\"${#ROMAN_POWER_OF_TEN[@]}\"; i++ )); do\n        local div_by_power=\"\
    $(( num / 10 ** i ))\"\n        if (( div_by_power > 0 )); then\n            num=\"\
    $(( num % 10 ** i ))\"\n            result+=\"$(int_to_roman \"$div_by_power\"\
    \ \"${ROMAN_POWER_OF_TEN[$i]}\")\"\n        fi\n    done\n    # Remove any adjacent\
    \ duplicate symbols, e.g. 'IIII' -> 'IV'.\n    echo \"$result\" | sed 's/MMMMM/v/g;\
    \ s/MMMM/iv/g; s/MMM/ix/g; s/MM/xl/g; s/M/xc/g; s/XXXXX/v/g; s/XXXX/iv/g; s/XXX/ix/g;\
    \ s/XX/xl/g; s/X/xc/g; s/vv/x/g; s/iv/xiv/g; s/ix/xix/g; s/xl/lx/g; s/xc/cx/g;\
    \ s/lll/xc/g; s/ll/lx/g; s/l/xc/g; s/ccc/cd/g; s/cc/xc/g; s/c/cd/g; s/dd/cm/g;\
    \ s/d/cm/g' | sed 's/iii/ix/g; s/ii/iv/g; s/i/ix/g' | tr -d 'v'", "    local num=\"\
    $1\"\n    local result=''\n    local thousands=''\n    local hundreds=''\n   \
    \ local tens=''\n    local ones=''\n    local i=''\n    local j=''\n    local\
    \ x=''\n    local y=''\n    local c=''\n    local digit=''\n    local exception=''\n\
    \    local exception_num=''\n    local exception_mini_roman=''\n    local exceptions_file='exceptions.txt'\n\
    \    local exceptions=()\n    local exceptions_len=0\n    #echo \"num is $num\"\
    \n\n    if [[ $num -lt 1 || $num -gt 1000 ]]; then\n        echo \"number must\
    \ be between 1 and 1000\" >&2\n        return 1\n    fi\n\n    # read exceptions\
    \ into an array\n    while read -r exception\n    do\n        exceptions+=(\"\
    $exception\")\n    done < $exceptions_file\n    exceptions_len=\"${#exceptions[@]}\"\
    \n\n    # Convert $num to thousands, hundreds, tens, and ones\n    thousands=$((\
    \ num / 1000 ))\n    hundreds=$(( (num % 1000) / 100 ))\n    tens=$(( (num % 100)\
    \ / 10 ))\n    ones=$(( num % 10 ))\n\n    # See if $num is an exception and return\
    \ roman numeral\n    for (( i=0; i<exceptions_len; i++ ))\n    do\n        exception=\"\
    ${exceptions[$i]}\"\n        exception_num=\"${exception% *}\"\n        exception_mini_roman=\"\
    ${exception#* }\"\n        if [[ $num -eq $exception_num ]]; then\n          \
    \  echo \"$exception_mini_roman\"\n            return 0\n        fi\n    done\n\
    \n    # Process thousands\n    for (( i=0; i<thousands; i++ ))\n    do\n     \
    \   result+='m'\n    done\n\n    # Process hundreds\n    if [[ $hundreds -eq 0\
    \ ]]; then\n        # do nothing\n        true\n    elif [[ $hundreds -eq 4 ]];\
    \ then\n        result+='cd'\n    elif [[ $hundreds -eq 5 ]]; then\n        result+='d'\n\
    \    elif [[ $hundreds -eq 9 ]]; then", "  local int=\"$1\"\n  local roman=\"\
    $(($int / 1000))m\"\n  int=\"$(($int % 1000))\"\n  roman=\"$roman$(($int / 500))d\"\
    \n  int=\"$(($int % 500))\"\n  roman=\"$roman$(($int / 100))c\"\n  int=\"$(($int\
    \ % 100))\"\n  roman=\"$roman$(($int / 50))l\"\n  int=\"$(($int % 50))\"\n  roman=\"\
    $roman$(($int / 10))x\"\n  int=\"$(($int % 10))\"\n  roman=\"$roman$(($int / 5))v\"\
    \n  int=\"$(($int % 5))\"\n  roman=\"$roman$int\"\n  echo \"$roman\"", "    local\
    \ output=\"\"\n    local args=\"$@\"\n    local args_copy=\"$args\"\n    # Size\
    \ checks\n    if (( args_copy > 1000 )); then\n        echo \"error: number must\
    \ be less than 1000\"\n        return 1\n    elif (( args_copy < 1 )); then\n\
    \        echo \"error: number must be greater than 0\"\n        return 1\n   \
    \ fi\n    # Integer to romain conversion algorithm\n    local romans=(M D C L\
    \ X V I)\n    local romans_size=${#romans[@]}\n    for (( i=0; i<romans_size;\
    \ i++ ))\n    do\n        local factor=$(( 2**(2*i) ))\n        local count=$((\
    \ args_copy / factor ))\n        args_copy=$(( args_copy % factor ))\n       \
    \ while (( count-- > 0 ))\n        do\n            output+=\"${romans[i]}\"\n\
    \        done\n    done\n    # Perform substitutions\n    output=${output/M/m}\n\
    \    output=${output/D/d}\n    output=${output/C/c}\n    output=${output/L/l}\n\
    \    output=${output/X/x}\n    output=${output/V/v}\n    output=${output/I/i}\n\
    \    echo \"$output\"", "    local original_int=${1}\n    local result=\"\"\n\
    \    local int=${original_int}\n    while [ ${int} -gt 0 ]; do\n        local\
    \ add_on=\"\"\n        if [ ${int} -ge 1000 ]; then\n            add_on=\"m\"\n\
    \            int=$((int - 1000))\n        elif [ ${int} -ge 900 ]; then\n    \
    \        add_on=\"cm\"\n            int=$((int - 900))\n        elif [ ${int}\
    \ -ge 500 ]; then\n            add_on=\"d\"\n            int=$((int - 500))\n\
    \        elif [ ${int} -ge 400 ]; then\n            add_on=\"cd\"\n          \
    \  int=$((int - 400))\n        elif [ ${int} -ge 100 ]; then\n            add_on=\"\
    c\"\n            int=$((int - 100))\n        elif [ ${int} -ge 90 ]; then\n  \
    \          add_on=\"xc\"\n            int=$((int - 90))\n        elif [ ${int}\
    \ -ge 50 ]; then\n            add_on=\"l\"\n            int=$((int - 50))\n  \
    \      elif [ ${int} -ge 40 ]; then\n            add_on=\"xl\"\n            int=$((int\
    \ - 40))\n        elif [ ${int} -ge 10 ]; then\n            add_on=\"x\"\n   \
    \         int=$((int - 10))\n        elif [ ${int} -ge 9 ]; then\n           \
    \ add_on=\"ix\"\n            int=$((int - 9))\n        elif [ ${int} -ge 5 ];\
    \ then\n            add_on=\"v\"\n            int=$((int - 5))\n        elif [\
    \ ${int} -ge 4 ]; then\n            add_on=\"iv\"\n            int=$((int - 4))\n\
    \        elif [ ${int} -ge 1 ]; then\n            add_on=\"i\"\n            int=$((int\
    \ - 1))\n        fi\n        result=${result}${add_on}\n    done\n    echo ${result}",
  "    local num=$1\n    local result=\"\"\n    local -a romans=(\n        \"m\" \
    \ \"cm\" \"d\"  \"cd\" \"c\"  \"xc\" \"l\"  \"xl\" \"x\"  \"ix\" \"v\"  \"iv\"\
    \ \"i\"\n    )\n    local -a arabs=(1000 900 500 400 100 90 50 40 10 9 5 4 1)\n\
    \    for (( i=0; i<${#arabs[@]}; i++ )); do\n        while (( num >= arabs[i]\
    \ )); do\n            num=$(( num - arabs[i] ))\n            result=${result}${romans[i]}\n\
    \        done\n    done\n    echo $result", "    if ! [[ \"$1\" =~ ^[0-9]+$ ]];\
    \ then\n        echo \"$0: error: invalid argument: $1\" >&2\n        return 1\n\
    \    fi\n    local integer=\"$1\"\n    local roman=\"\"\n    local -a one=(I II\
    \ III IV V VI VII VIII IX)\n    local -a ten=(X XX XXX XL L LX LXX LXXX XC)\n\
    \    local -a hund=(C CC CCC CD D DC DCC DCCC CM)\n    local -a thou=(M MM MMM)\n\
    \    [[ \"$integer\" -ge 1000 ]] && roman+=\"${thou[$((integer/1000-1))]}\" &&\
    \ integer=\"$((integer%1000))\"\n    [[ \"$integer\" -ge 100 ]] && roman+=\"${hund[$((integer/100-1))]}\"\
    \ && integer=\"$((integer%100))\"\n    [[ \"$integer\" -ge 10 ]] && roman+=\"\
    ${ten[$((integer/10-1))]}\" && integer=\"$((integer%10))\"\n    [[ \"$integer\"\
    \ -ge 1 ]] && roman+=\"${one[$((integer-1))]}\"\n    echo \"$roman\"", "    local\
    \ -a numerals=( \\\n        \"i\" \"iv\" \"v\" \"ix\" \"x\" \"xl\" \"l\" \"xc\"\
    \ \"c\" \"cd\" \"d\" \"cm\" \"m\" \\\n    )\n    local -a values=( \\\n      \
    \  1 4 5 9 10 40 50 90 100 400 500 900 1000 \\\n    )\n    local num=$1\n    local\
    \ -i i len=${#values[@]}\n    local roman=\"\"\n    for ((i=len-1; i>=0; i--));\
    \ do\n        local -i val=${values[i]}\n        local numeral=${numerals[i]}\n\
    \        while ((num >= val)); do\n            roman+=$numeral\n            ((num\
    \ -= val))\n        done\n    done\n    echo $roman", "  if [[ $1 =~ ^[0-9]+$\
    \ ]]; then\n    if [[ \"$1\" -ge 1 && \"$1\" -le 1000 ]]; then\n      local decimal_to_roman=(M\
    \ CM D CD C XC L XL X IX V IV I)\n      local decimal_to_roman_value=(1000 900\
    \ 500 400 100 90 50 40 10 9 5 4 1)\n      local -i decimal=\"$1\" remainder\n\
    \      local -i num roman roman_value\n\n      # Take advantage of the ordering\
    \ of the arrays\n      for (( num=0; num<${#decimal_to_roman[@]}; num++ )); do\n\
    \        (( remainder = decimal - decimal_to_roman_value[num] ))\n        if [[\
    \ $remainder -ge 0 ]]; then\n          (( decimal = remainder ))\n          roman=\"\
    ${roman}${decimal_to_roman[num]}\"\n        fi\n      done\n      echo \"$roman\"\
    \n    else\n      echo \"int_to_mini_roman: $1 is out of range\" >&2\n      return\
    \ 1\n    fi\n  else\n    echo \"int_to_mini_roman: $1 is not an integer\" >&2\n\
    \    return 1\n  fi", "\tlocal -i num=\"$1\"\n\tlocal -i res=0\n\tlocal -a numeral=(M\
    \ D C L X V I)\n\tlocal -a value=(1000 500 100 50 10 5 1)\n\tlocal i=0\n\n\tif\
    \ (( num < 1 || num > 1000 )); then\n\t\tprintf \"error: number must be between\
    \ 1 and 1000\\n\" >&2\n\t\treturn 1\n\tfi\n\n\twhile (( num > 0 )); do\n\t\twhile\
    \ (( num >= value[i] )); do\n\t\t\tres=$(( res + value[i] ))\n\t\t\tprintf \"\
    %s\" \"${numeral[i]}\"\n\t\t\tnum=$(( num - value[i] ))\n\t\tdone\n\t\t(( i++\
    \ ))\n\tdone\n\tprintf \"\\n\"", "  # Mapping roman numeral table\n  local -A\
    \ numerals\n  numerals=(\n    [1]=\"i\" [2]=\"ii\" [3]=\"iii\" [4]=\"iv\" [5]=\"\
    v\" [6]=\"vi\" [7]=\"vii\" [8]=\"viii\" [9]=\"ix\"\n    [10]=\"x\" [20]=\"xx\"\
    \ [30]=\"xxx\" [40]=\"xl\" [50]=\"l\" [60]=\"lx\" [70]=\"lxx\" [80]=\"lxxx\" [90]=\"\
    xc\"\n    [100]=\"c\" [200]=\"cc\" [300]=\"ccc\" [400]=\"cd\" [500]=\"d\" [600]=\"\
    dc\" [700]=\"dcc\" [800]=\"dccc\" [900]=\"cm\"\n    [1000]=\"m\"\n  )\n  local\
    \ n=$1\n\n  if ((n == 0)); then\n    echo \"\"\n    return 0\n  fi\n\n  local\
    \ result=\"\"\n  local remainder=0\n  local quotient=0\n  local power=0\n  local\
    \ unit=0\n\n  while ((n > 0)); do\n    # For example, 3456 is 3 * 1000 + 4 * 100\
    \ + 5 * 10 + 6 * 1\n    # The biggest power of 10 that can divide n is the number\
    \ of digits\n    # in n minus 1.\n    power=$((10 ** ((${#n} - 1))))\n    # The\
    \ remaining power of 10 that cannot divide n is\n    # the least significant digit\
    \ of n.\n    remainder=$((n % 10))\n    # The quotient of n divided by power of\
    \ 10 is\n    # the most significant digit of n.\n    quotient=$((n / power))\n\
    \    # The corresponding integer unit is a power of 10 times quotient.\n    unit=$((power\
    \ * quotient))\n    # Add corresponding roman numeral unit to result string.\n\
    \    result=\"${result}${numerals[$unit]}\"\n    # Reduce n by unit.\n    n=$((n\
    \ - unit))\n  done\n\n  echo \"${result}\"", "\tlocal I=$1\n\tlocal R=''\n\twhile\
    \ ((I > 0)); do\n\t\t((I >= 1000)) && { printf -v R '%sm' \"$R\"; ((I -= 1000));\
    \ continue; }\n\t\t((I >= 900)) && { printf -v R '%scm' \"$R\"; ((I -= 900));\
    \ continue; }\n\t\t((I >= 500)) && { printf -v R '%sd' \"$R\"; ((I -= 500)); continue;\
    \ }\n\t\t((I >= 400)) && { printf -v R '%scd' \"$R\"; ((I -= 400)); continue;\
    \ }\n\t\t((I >= 100)) && { printf -v R '%sc' \"$R\"; ((I -= 100)); continue; }\n\
    \t\t((I >= 90)) && { printf -v R '%sxc' \"$R\"; ((I -= 90)); continue; }\n\t\t\
    ((I >= 50)) && { printf -v R '%sl' \"$R\"; ((I -= 50)); continue; }\n\t\t((I >=\
    \ 40)) && { printf -v R '%sxl' \"$R\"; ((I -= 40)); continue; }\n\t\t((I >= 10))\
    \ && { printf -v R '%sx' \"$R\"; ((I -= 10)); continue; }\n\t\t((I >= 9)) && {\
    \ printf -v R '%si' \"$R\"; ((I -= 9)); continue; }\n\t\t((I >= 5)) && { printf\
    \ -v R '%sv' \"$R\"; ((I -= 5)); continue; }\n\t\t((I >= 4)) && { printf -v R\
    \ '%siv' \"$R\"; ((I -= 4)); continue; }\n\t\t((I >= 1)) && { printf -v R '%si'\
    \ \"$R\"; ((I -= 1)); continue; }\n\tdone\n\tprintf '%s\\n' \"$R\"", "  declare\
    \ -A romandict=([0]=\"\" [1]=\"i\" [2]=\"ii\" [3]=\"iii\" [4]=\"iv\" [5]=\"v\"\
    \n\t\t\t[6]=\"vi\" [7]=\"vii\" [8]=\"viii\" [9]=\"ix\" [10]=\"x\" [20]=\"xx\"\n\
    \t\t\t[30]=\"xxx\" [40]=\"xl\" [50]=\"l\" [60]=\"lx\" [70]=\"lxx\" [80]=\"lxxx\"\
    \n\t\t\t[90]=\"xc\" [100]=\"c\" [200]=\"cc\" [300]=\"ccc\" [400]=\"cd\" [500]=\"\
    d\"\n\t\t\t[600]=\"dc\" [700]=\"dcc\" [800]=\"dccc\" [900]=\"cm\" [1000]=\"m\"\
    )\n  declare -i ones tens hundreds\n  declare -a numarray\n  declare integer\n\
    \  declare numstring\n  declare -i numlen\n  declare -i power\n  declare -i result\n\
    \  integer=\"$1\"\n  if (( integer <= 1000 )); then\n    numstring=$(echo $integer\
    \ | sed 's/\\(.\\)/\\1 /g')\n    numarray=($numstring)\n    numlen=${#numarray[@]}\n\
    \    power=0\n    result=0\n    for i in $(seq 1 $numlen); do\n      ((power=i-1))\n\
    \      ((result=$((10**power))*${numarray[-i]}))\n      if (( i==1 )); then\n\t\
    ones=${romandict[$result]}\n      elif (( i==2 )); then\n\ttens=${romandict[$result]}\n\
    \      elif (( i==3 )); then\n\thundreds=${romandict[$result]}\n      fi\n   \
    \ done\n    echo \"$hundreds$tens$ones\" | tr \"[:upper:]\" \"[:lower:]\"\n  else\n\
    \    echo \"Error: integer greater than 1000\"\n  fi", "    # Convert the number\
    \ to a roman numeral, then use sed to convert uppercase\n    # to lowercase\n\
    \    int_to_roman \"$1\" | sed 's/\\(.\\)/\\L\\1/g'", "    local integer=\"$1\"\
    \n    local mini_roman=\"\"\n    local -i digit=0\n    while [ $integer -gt 0\
    \ ]; do\n        digit=$((integer % 10))\n        case $digit in\n           \
    \ 1) mini_roman=\"i$mini_roman\" ;;\n            2) mini_roman=\"ii$mini_roman\"\
    \ ;;\n            3) mini_roman=\"iii$mini_roman\" ;;\n            4) mini_roman=\"\
    iv$mini_roman\" ;;\n            5) mini_roman=\"v$mini_roman\" ;;\n          \
    \  6) mini_roman=\"vi$mini_roman\" ;;\n            7) mini_roman=\"vii$mini_roman\"\
    \ ;;\n            8) mini_roman=\"viii$mini_roman\" ;;\n            9) mini_roman=\"\
    ix$mini_roman\" ;;\n        esac\n        integer=$((integer / 10))\n    done\n\
    \    echo \"$mini_roman\"", '    _to_roman_helper "$1" 0', "    sed -e 's/^1$/i/;s/^5$/v/;s/^10$/x/;s/^50$/l/;s/^100$/c/;s/^500$/d/;s/^1000$/m/'\
    \ <<<\"$1\"", "    local int=\"$1\"\n    local u=\"\"\n    local t=\"\"\n    local\
    \ h=\"\"\n    local t_u=\"\"\n    local h_u=\"\"\n    local miniroman=\"\"\n \
    \   local flag=0\n    # one's digit\n    u=\"$(echo \"$int\" | grep -oE \"[0-9]$\"\
    )\"\n    # ten's digit\n    t=\"$(echo \"$int\" | grep -oE \"[0-9]{2}\" | grep\
    \ -oE \"[0-9]$\")\"\n    # hundred's digit\n    h=\"$(echo \"$int\" | grep -oE\
    \ \"[0-9]{3}\" | grep -oE \"[0-9]$\")\"\n    # two's digit\n    t_u=\"$(echo \"\
    $int\" | grep -oE \"[0-9]{2}\" | grep -oE \"[0-9]{1}\")\"\n    # three's digit\n\
    \    h_u=\"$(echo \"$int\" | grep -oE \"[0-9]{3}\" | grep -oE \"[0-9]{1}\")\"\n\
    \    #\n    # unit\n    if [[ $u -eq 9 ]]; then\n        miniroman+=\"ix\"\n \
    \   elif [[ $u -ge 5 ]]; then\n        miniroman+=\"v\"\n        flag=1\n    \
    \    if [[ $u -gt 5 ]]; then\n            while [[ $u -gt 5 ]]; do\n         \
    \       miniroman+=\"i\"\n                u=$((u-1))\n            done\n     \
    \   fi\n    elif [[ $u -eq 4 ]]; then\n        miniroman+=\"iv\"\n    else\n \
    \       while [[ $u -gt 0 ]]; do\n            miniroman+=\"i\"\n            u=$((u-1))\n\
    \        done\n    fi\n    # ten\n    if [[ $t -eq 9 ]]; then\n        miniroman=\"\
    x\"$miniroman\n    elif [[ $t -ge 5 ]]; then\n        miniroman=\"l\"$miniroman\n\
    \        flag=1\n        if [[ $t -gt 5 ]]; then\n            while [[ $t -gt\
    \ 5 ]]; do\n                miniroman=\"x\"$minir", "  # Your code here\n  # replace\
    \ the following\n  echo \"\"", "  # TODO: your code here\n  echo ''", "  local\
    \ num=$1\n  local result=\"\"\n  local -a roman=([1]=\"i\" [5]=\"v\" [10]=\"x\"\
    \ [50]=\"l\" [100]=\"c\" [500]=\"d\" [1000]=\"m\")\n  local -a divisors=(1000\
    \ 500 100 50 10 5 1)\n  local -A prefixes=([1]=\"iv\" [10]=\"ix\" [100]=\"ic\"\
    \ [1000]=\"im\")\n  local -A suffixes=([1]=\"iv\" [10]=\"xl\" [100]=\"cd\" [1000]=\"\
    cm\")\n  local divisor i=\"${divisors[0]}\" j=0\n  for divisor in \"${divisors[@]}\"\
    ; do\n    [ $i -ne $divisor ] && i=$divisor\n    if [ $((num / i)) -gt 0 ]; then\n\
    \      if [ $j -eq 0 ]; then\n        result+=\"${prefixes[$i]:-${roman[$i]}}\"\
    \n      elif [ $j -eq 1 ]; then\n        result+=\"${suffixes[$i]:-${roman[$i]}}\"\
    \n      else\n        result+=\"${roman[$i]}\"\n      fi\n      num=$((num % i))\n\
    \      j=$((j + 1))\n    else\n      j=0\n    fi\n  done\n  printf \"%s\" \"$result\"",
  "  # The following list of rules/patterns in mini-roman numerals was\n  # obtained\
    \ from:\n  # https://en.wikipedia.org/wiki/Roman_numerals#Standard_forms\n  #\n\
    \  # -----  ----  -----  ----  -----  ----  -----  ----  -----  ----  -----  ----\n\
    \  # 1000   2000  3000   4000  5000   6000  7000   8000  9000   10000 100000\n\
    \  # m       mm     mmm    mv     v      vm     vmm    vmmm   mx     mxm\n  #\
    \ -----  ----  -----  ----  -----  ----  -----  ----  -----  ----  -----  ----\n\
    \  #\n  # -----  ----  -----  ----  -----  ----  -----  ----  -----  ----  -----\
    \  ----\n  # 100     200   300    400   500    600   700    800   900    1000\n\
    \  # c       cc     ccc    cd     d      dc     dcc    dccc   cm\n  # -----  ----\
    \  -----  ----  -----  ----  -----  ----  -----  ----  -----  ----\n  #\n  # -----\
    \  ----  -----  ----  -----  ----  -----  ----  -----  ----  -----  ----\n  #\
    \ 10      20    30     40    50     60    70     80    90     100\n  # x     \
    \  xx     xxx    xl     l      lx     lxx    lxxx   xc\n  # -----  ----  -----\
    \  ----  -----  ----  -----  ----  -----  ----  -----  ----\n  #\n  # -----  ----\
    \  -----  ----  -----  ----  -----  ----  -----  ----  -----  ----\n  # 1    \
    \   2     3      4     5      6     7      8     9      10\n  # i       ii   \
    \  iii    iv     v      vi     vii    viii   ix\n  # -----  ----  -----  ----\
    \  -----  ----  -----  ----  -----  ----  -----  ----\n  #\n  # We can thus create\
    \ a hash table with the keys as the numbers, and\n  # the values as the corresponding\
    \ mini-roman numerals.\n\n  # The following hash table was also obtained from:\n\
    \  # https://en.", "  integer=\"$1\"\n  if [[ ! \"$integer\" =~ ^[0-9]+$ ]]; then\n\
    \    echo \"error: argument not an integer\" >&2\n    exit 1\n  fi\n  if [[ \"\
    $integer\" -lt 1 ]] || [[ \"$integer\" -gt 1000 ]]; then\n    echo \"error: argument\
    \ not in range 1-1000\" >&2\n    exit 1\n  fi\n  local roman=\"\"\n  local numeral=\"\
    \"\n  local s=\"\"\n  local p=\"\"\n  for numeral in M D C L X V I; do\n    s=\"\
    $(echo \"$numeral\" | tr \"[:upper:]\" \"[:lower:]\")\"\n    p=\"$(echo \"$numeral\"\
    \ | tr \"[:lower:]\" \"[:upper:]\")\"\n    case \"$integer\" in\n      [0-3]*)\n\
    \        integer=\"$((integer - $(num_letters \"$numeral\" \"$integer\" \"$s\"\
    )))\";\n        roman=\"$roman$(str_times \"$s\" \"$(num_letters \"$numeral\"\
    \ \"$integer\" \"$s\")\")\"\n        ;;\n      4*)\n        integer=\"$((integer\
    \ - 4))\";\n        roman=\"$roman$s$p\"\n        ;;\n      5*)\n        integer=\"\
    $((integer - 5))\";\n        roman=\"$roman$p\"\n        ;;\n      6*)\n     \
    \   integer=\"$((integer - 6))\";\n        roman=\"$roman$p$s\"\n        ;;\n\
    \      7*)\n        integer=\"$((integer - 7))\";\n        roman=\"$roman$p$(str_times\
    \ \"$s\" \"2\")\"\n        ;;\n      8*)\n        integer=\"$((integer - 8))\"\
    ;\n        roman=\"$roman$p$(str_times \"$s\" \"3\")\"\n        ;;\n      9*)\n\
    \        integer=\"$((integer - 9))\";\n        roman=\"$roman$s$(echo \"$numeral\"\
    \ | tr \"[:lower:]\" \"[:upper:]\")\"\n        ;;\n    esac\n  done\n  echo \"\
    $roman\"", "    if [[ \"$1\" -le 0 ]]; then\n        echo \"The input should be\
    \ a positive integer\"\n        return 1\n    fi\n    if [[ \"$1\" -gt 1000 ]];\
    \ then\n        echo \"The input is not in the valid range\"\n        return 1\n\
    \    fi\n    num=\"$1\"\n    num_len=\"${#num}\"\n    result=\"\"\n    for ((\
    \ i=0; i<num_len; i++ )); do\n        curr_num=\"${num:$i:1}\"\n        curr_ten=\"\
    $((10**(num_len-i-1)))\"\n        if [[ \"$curr_num\" -eq 9 ]]; then\n       \
    \     result+=\"ix\"\n        elif [[ \"$curr_num\" -eq 4 ]]; then\n         \
    \   result+=\"iv\"\n        else\n            if [[ \"$curr_num\" -ge 5 ]]; then\n\
    \                result+=\"v\"\n                curr_num=\"$((curr_num-5))\"\n\
    \            fi\n            for (( j=0; j<curr_num; j++ )); do\n            \
    \    result+=\"i\"\n            done\n        fi\n    done\n    echo \"$result\"",
  "    local i=$1\n    local roman=\"\"\n    while ((i>0)); do\n        if ((i==1000));\
    \ then\n            roman=\"m$roman\"\n            ((i-=1000))\n        elif ((i>=900));\
    \ then\n            roman=\"cm$roman\"\n            ((i-=900))\n        elif ((i>=500));\
    \ then\n            roman=\"d$roman\"\n            ((i-=500))\n        elif ((i>=400));\
    \ then\n            roman=\"cd$roman\"\n            ((i-=400))\n        elif ((i>=100));\
    \ then\n            roman=\"c$roman\"\n            ((i-=100))\n        elif ((i>=90));\
    \ then\n            roman=\"xc$roman\"\n            ((i-=90))\n        elif ((i>=50));\
    \ then\n            roman=\"l$roman\"\n            ((i-=50))\n        elif ((i>=40));\
    \ then\n            roman=\"xl$roman\"\n            ((i-=40))\n        elif ((i>=10));\
    \ then\n            roman=\"x$roman\"\n            ((i-=10))\n        elif ((i>=9));\
    \ then\n            roman=\"ix$roman\"\n            ((i-=9))\n        elif ((i>=5));\
    \ then\n            roman=\"v$roman\"\n            ((i-=5))\n        elif ((i>=4));\
    \ then\n            roman=\"iv$roman\"\n            ((i-=4))\n        else\n \
    \           roman=\"i$roman\"\n            ((i-=1))\n        fi\n    done\n  \
    \  echo \"$roman\"", "\tlocal num=$1\n\t[ $num -lt 1 ] && return 1\n\t[ $num -gt\
    \ 1000 ] && return 1\n\tlocal result=\"\"\n\tlocal -a roman=([1]=\"i\" [5]=\"\
    v\" [10]=\"x\" [50]=\"l\" [100]=\"c\" [500]=\"d\" [1000]=\"m\")\n\tlocal place=1\n\
    \twhile [ $num -gt 0 ]; do\n\t\tlocal digit=$((num % 10))\n\t\tlocal digit_result=\"\
    \"\n\t\tcase $digit in\n\t\t\t1) digit_result=\"i\" ;;\n\t\t\t2) digit_result=\"\
    ii\" ;;\n\t\t\t3) digit_result=\"iii\" ;;\n\t\t\t4) digit_result=\"iv\" ;;\n\t\
    \t\t5) digit_result=\"v\" ;;\n\t\t\t6) digit_result=\"vi\" ;;\n\t\t\t7) digit_result=\"\
    vii\" ;;\n\t\t\t8) digit_result=\"viii\" ;;\n\t\t\t9) digit_result=\"ix\" ;;\n\
    \t\tesac\n\t\tdigit_result=${digit_result//i/${roman[$place]}}\n\t\tdigit_result=${digit_result//v/${roman[$((place\
    \ * 5))]}}\n\t\tdigit_result=${digit_result//x/${roman[$((place * 10))]}}\n\t\t\
    result=${digit_result}${result}\n\t\tnum=$((num / 10))\n\t\tplace=$((place * 10))\n\
    \tdone\n\techo $result", "  # Initialize roman numeral to empty string\n  local\
    \ roman=\"\"\n  # Create array mapping numbers to roman numerals\n  local numeral_array=([\"\
    1\"]=\"i\" [\"4\"]=\"iv\" [\"5\"]=\"v\" [\"9\"]=\"ix\" [\"10\"]=\"x\" \\\n  [\"\
    40\"]=\"xl\" [\"50\"]=\"l\" [\"90\"]=\"xc\" [\"100\"]=\"c\" [\"400\"]=\"cd\" [\"\
    500\"]=\"d\" \\\n  [\"900\"]=\"cm\" [\"1000\"]=\"m\")\n  # Starting at 1000, while\
    \ our integer is at least as large\n  # as the roman numeral equivalent, append\
    \ the roman numeral equivalent\n  # and subtract it from the integer\n  for i\
    \ in 1000 900 500 400 100 90 50 40 10 9 5 4 1; do\n    while [ \"$1\" -ge \"$i\"\
    \ ]; do\n      roman+=\"${numeral_array[$i]}\"\n      let \"1 -= $i\"\n    done\n\
    \  done\n  # Return roman numeral in lowercase\n  echo \"$roman\" | tr '[:upper:]'\
    \ '[:lower:]'", "    printf \"%s\" \"$1\" | awk '{\n        {\n            $1\
    \ < 1 || $1 > 1000 || exit 1\n        }\n        {\n            printf(\"%s\"\
    ,\n                tolower(\n                    sprintf(\"%s%s%s%s\",\n     \
    \                   gensub(/([0-9])00$/, \"\\\\1m\", \"g\", $1),\n           \
    \             gensub(/([0-9])0([0-9])$/, \"\\\\1c\\\\2\", \"g\", $1),\n      \
    \                  gensub(/([0-9])0$/, \"\\\\1x\", \"g\", $1),\n             \
    \           gensub(/([0-9])$/, \"\\\\1\", \"g\", $1)\n                    )\n\
    \                )\n            )\n        }\n    }'", "    if [[ ! \"$1\" =~\
    \ ^[0-9]+$ ]]; then\n        return 1\n    fi\n    # Disallow input <= 0 or >=\
    \ 1000\n    if [[ \"$1\" -le 0 || \"$1\" -ge 1000 ]]; then\n        return 1\n\
    \    fi\n    printf \"%s\" \"$(int_to_mini_roman_helper \"$1\")\"", "  declare\
    \ -A numerals=(\n    [\"1\"]=\"i\" [\"2\"]=\"ii\" [\"3\"]=\"iii\" [\"4\"]=\"iv\"\
    \ [\"5\"]=\"v\"\n    [\"6\"]=\"vi\" [\"7\"]=\"vii\" [\"8\"]=\"viii\" [\"9\"]=\"\
    ix\" [\"10\"]=\"x\"\n    [\"20\"]=\"xx\" [\"30\"]=\"xxx\" [\"40\"]=\"xl\" [\"\
    50\"]=\"l\"\n    [\"60\"]=\"lx\" [\"70\"]=\"lxx\" [\"80\"]=\"lxxx\" [\"90\"]=\"\
    xc\" [\"100\"]=\"c\"\n    [\"200\"]=\"cc\" [\"300\"]=\"ccc\" [\"400\"]=\"cd\"\
    \ [\"500\"]=\"d\"\n    [\"600\"]=\"dc\" [\"700\"]=\"dcc\" [\"800\"]=\"dccc\" [\"\
    900\"]=\"cm\" [\"1000\"]=\"m\"\n  )\n  declare int=$1\n  declare -a roman\n  declare\
    \ digit place\n  ((int > 1000)) && int=1000\n  while ((int > 0)); do\n    ((place\
    \ = int % 10))\n    digit=$((int - place))\n    ((place == 0)) && place=10\n \
    \   roman+=( \"${numerals[$((digit*place))]}\" )\n    ((int /= 10))\n  done\n\
    \  echo \"${roman[*]}\" | tr '[:upper:]' '[:lower:]' | tr -d $'\\n'", "\tlocal\
    \ -i num=$1\n\tlocal -a roman_values=(1000 900 500 400 100 90 50 40 10 9 5 4 1)\n\
    \tlocal -a roman_letters=(M CM D CD C XC L XL X IX V IV I)\n\tlocal -i i\n\tlocal\
    \ result=\"\"\n\tif [ $num -le 0 ]; then\n\t\tresult=\"undefined\"\n\telif [ $num\
    \ -gt 1000 ]; then\n\t\tresult=\"undefined\"\n\telse\n\t\tfor ((i=0; i<${#roman_values[@]};\
    \ i++)); do\n\t\t\twhile [ $num -ge ${roman_values[$i]} ]; do\n\t\t\t\tresult+=\"\
    ${roman_letters[$i]}\"\n\t\t\t\tnum-=${roman_values[$i]}\n\t\t\tdone\n\t\tdone\n\
    \tfi\n\techo $result", "    local array=(M CM D CD C XC L XL X IX V IV I)\n  \
    \  local index=(1000 900 500 400 100 90 50 40 10 9 5 4 1)\n    local num\n   \
    \ local result=''\n    local i\n    if ! [[ $1 =~ ^[0-9]+$ ]]; then\n        return\
    \ 1\n    fi\n    num=$1\n    for ((i=0;i<=${#index[@]};i++)); do\n        while\
    \ ((num >= index[i])); do\n            result+=\"${array[i]}\"\n            ((num\
    \ -= index[i]))\n        done\n    done\n    echo \"$result\"", "  local romans=(\
    \ [0]=\"\" [1]=\"i\" [2]=\"ii\" [3]=\"iii\" [4]=\"iv\" [5]=\"v\" [6]=\"vi\" [7]=\"\
    vii\" [8]=\"viii\" [9]=\"ix\" [10]=\"x\" [20]=\"xx\" [30]=\"xxx\" [40]=\"xl\"\
    \ [50]=\"l\" [60]=\"lx\" [70]=\"lxx\" [80]=\"lxxx\" [90]=\"xc\" [100]=\"c\" [200]=\"\
    cc\" [300]=\"ccc\" [400]=\"cd\" [500]=\"d\" [600]=\"dc\" [700]=\"dcc\" [800]=\"\
    dccc\" [900]=\"cm\" [1000]=\"m\" )\n  local num=$1\n  local ret=\"\"\n  local\
    \ multiple=1\n  local curr_digit=0\n  while [ $num -gt 0 ]; do\n    curr_digit=$((\
    \ num % 10 ))\n    num=$(( num / 10 ))\n    if [ $curr_digit -gt 0 ]; then\n \
    \     ret=${romans[$(( curr_digit * multiple ))]}${ret}\n    fi\n    multiple=$((\
    \ multiple * 10 ))\n  done\n  echo $ret", "  awk 'BEGIN {\n      ONES[1] = \"\
    i\"; ONES[2] = \"ii\"; ONES[3] = \"iii\"; ONES[4] = \"iv\";\n      ONES[5] = \"\
    v\"; ONES[6] = \"vi\"; ONES[7] = \"vii\"; ONES[8] = \"viii\";\n      ONES[9] =\
    \ \"ix\";\n\n      TENS[1] = \"x\"; TENS[2] = \"xx\"; TENS[3] = \"xxx\"; TENS[4]\
    \ = \"xl\";\n      TENS[5] = \"l\"; TENS[6] = \"lx\"; TENS[7] = \"lxx\"; TENS[8]\
    \ = \"lxxx\";\n      TENS[9] = \"xc\";\n\n      HUNDREDS[1] = \"c\"; HUNDREDS[2]\
    \ = \"cc\"; HUNDREDS[3] = \"ccc\";\n      HUNDREDS[4] = \"cd\"; HUNDREDS[5] =\
    \ \"d\"; HUNDREDS[6] = \"dc\";\n      HUNDREDS[7] = \"dcc\"; HUNDREDS[8] = \"\
    dccc\"; HUNDREDS[9] = \"cm\";\n\n      THOUSANDS[1] = \"m\"; THOUSANDS[2] = \"\
    mm\"; THOUSANDS[3] = \"mmm\";\n      THOUSANDS[4] = \"\"; THOUSANDS[5] = \"\"\
    ; THOUSANDS[6] = \"\";\n      THOUSANDS[7] = \"\"; THOUSANDS[8] = \"\"; THOUSANDS[9]\
    \ = \"\";\n\n      # Get the integer and make it a string\n      num_str = \"\
    '\"$1\"'\";\n\n      # Get the length of the string\n      num_len = length(num_str);\n\
    \n      # Now parse the string and convert each digit to its roman numeral\n \
    \     # equivalent and concatenate them all into one string\n      roman_num =\
    \ \"\";\n      if (num_len >= 1)\n        ones_pos = substr(num_str, num_len,\
    \ 1);\n        roman_", "    local num=$1\n    if [ $num -eq 0 ]; then\n     \
    \   echo \"\"\n        return 0\n    fi\n    local ret=\"\"\n    if [ $num -ge\
    \ 1000 ]; then\n        local sym=m\n        local div=1000\n    elif [ $num -ge\
    \ 100 ]; then\n        local sym=c\n        local div=100\n    elif [ $num -ge\
    \ 10 ]; then\n        local sym=x\n        local div=10\n    else\n        local\
    \ sym=i\n        local div=1\n    fi\n    while [ $num -ge $div ]; do\n      \
    \  ret=\"$ret$sym\"\n        num=$((num-div))\n    done\n    local quotient=$((num/div))\n\
    \    local remainder=$((num%div))\n    if [ $quotient -eq 4 ]; then\n        ret=\"\
    $ret$sym$sym\"\n    elif [ $quotient -eq 9 ]; then\n        ret=\"$ret$sym$sym$sym\"\
    \n    elif [ $quotient -eq 5 ]; then\n        ret=\"$ret$sym$sym\"\n    elif [\
    \ $quotient -eq 6 ]; then\n        ret=\"$ret$sym$sym$sym\"\n    elif [ $quotient\
    \ -eq 7 ]; then\n        ret=\"$ret$sym$sym$sym$sym\"\n    elif [ $quotient -eq\
    \ 8 ]; then\n        ret=\"$ret$sym$sym$sym$sym$sym\"\n    fi\n    ret=\"$ret$(int_to_mini_roman\
    \ $remainder)\"\n    echo \"$ret\"", "  local num=\"$1\"\n  local int_roman=(0\
    \ M CM D CD C XC L XL X IX V IV I)\n  local num_roman=()\n  local i=0\n\n  while\
    \ [ \"$num\" -gt 0 ]; do\n    while [ \"$((num - 10 ** $i))\" -ge 0 ]; do\n  \
    \    num_roman+=(${int_roman[2 * $i]})\n      num=$((num - 10 ** $i))\n    done\n\
    \    i=$((i + 1))\n  done\n\n  echo \"${num_roman[@]}\" | tr -d \" \"", "  local\
    \ I=(\"\" \"i\" \"ii\" \"iii\" \"iv\" \"v\" \"vi\" \"vii\" \"viii\" \"ix\")\n\
    \  local X=(\"\" \"x\" \"xx\" \"xxx\" \"xl\" \"l\" \"lx\" \"lxx\" \"lxxx\" \"\
    xc\")\n  local C=(\"\" \"c\" \"cc\" \"ccc\" \"cd\" \"d\" \"dc\" \"dcc\" \"dccc\"\
    \ \"cm\")\n  local M=(\"\" \"m\" \"mm\" \"mmm\")\n  local res=\"\"\n  local n=\"\
    $1\"\n  local n_m=$((n/1000))\n  local n_c=$(((n%1000)/100))\n  local n_x=$(((n%100)/10))\n\
    \  local n_i=$((n%10))\n  local m=${M[$n_m]}\n  local c=${C[$n_c]}\n  local x=${X[$n_x]}\n\
    \  local i=${I[$n_i]}\n  res=\"${m}${c}${x}${i}\"\n  printf \"%s\" \"$res\"",
  "  local i d=$1; r=''\n  for r_i in [MC] [CD] [XC] [XL] [IX] [IV] M C X I; do\n\
    \    ((i=d/1000)) && ((d%=1000))\n    ((i=d/900)) && ((d%=900)) && r=$r$r_i\n\
    \    ((i=d/500)) && ((d%=500)) && r=$r${r_i%?}\n    ((i=d/400)) && ((d%=400))\
    \ && r=$r$r_i\n    ((i=d/100)) && ((d%=100)) && r=$r${r_i%?}\n    ((i=d/90)) &&\
    \ ((d%=90)) && r=$r$r_i\n    ((i=d/50)) && ((d%=50)) && r=$r${r_i%?}\n    ((i=d/40))\
    \ && ((d%=40)) && r=$r$r_i\n    ((i=d/10)) && ((d%=10)) && r=$r${r_i%?}\n    ((i=d/9))\
    \ && ((d%=9)) && r=$r$r_i\n    ((i=d/5)) && ((d%=5)) && r=$r${r_i%?}\n    ((i=d/4))\
    \ && ((d%=4)) && r=$r$r_i\n    ((i=d/1)) && ((d%=1)) && r=$r${r_i%?}\n  done\n\
    \  printf \"%s\\n\" \"$r\"", "  local -i n=$1;\n  # build-up the roman digit char-by-char\n\
    \  local rom=\"\"\n  # no more than 3 digits per char-grouping\n  while ((n>=1000));\
    \ do\n    rom+=\"m\"\n    ((n-=1000))\n  done\n  while ((n>=900)); do\n    rom+=\"\
    cm\"\n    ((n-=900))\n  done\n  while ((n>=500)); do\n    rom+=\"d\"\n    ((n-=500))\n\
    \  done\n  while ((n>=400)); do\n    rom+=\"cd\"\n    ((n-=400))\n  done\n  while\
    \ ((n>=100)); do\n    rom+=\"c\"\n    ((n-=100))\n  done\n  while ((n>=90)); do\n\
    \    rom+=\"xc\"\n    ((n-=90))\n  done\n  while ((n>=50)); do\n    rom+=\"l\"\
    \n    ((n-=50))\n  done\n  while ((n>=40)); do\n    rom+=\"xl\"\n    ((n-=40))\n\
    \  done\n  while ((n>=10)); do\n    rom+=\"x\"\n    ((n-=10))\n  done\n  while\
    \ ((n>=9)); do\n    rom+=\"ix\"\n    ((n-=9))\n  done\n  while ((n>=5)); do\n\
    \    rom+=\"v\"\n    ((n-=5))\n  done\n  while ((n>=4)); do\n    rom+=\"iv\"\n\
    \    ((n-=4))\n  done\n  while ((n>=1)); do\n    rom+=\"i\"\n    ((n-=1))\n  done\n\
    \  # return\n  echo \"$rom\"", "\tlocal -i n=$1\n\tlocal -i y=0\n\tlocal -i x=0\n\
    \tlocal -i z=0\n\tlocal -i q=0\n\tlocal -i w=0\n\tlocal -i u=0\n\tlocal -i v=0\n\
    \tlocal roman=\"\"\n\t# restrict input to values within the roman numeral range\n\
    \tif [[ $n -lt 1 || $n -gt 1000 ]]; then\n\t\techo \"Number must be between 1\
    \ and 1000.\"\n\t\treturn 1\n\tfi\n\ty=$((n / 1000))\n\tx=$((n / 100))\n\tz=$((n\
    \ / 10))\n\tq=$((n / 9))\n\tw=$((n / 5))\n\tu=$((n / 4))\n\tv=$((n / 1))\n\tfor\
    \ i in $(seq 1 $y); do\n\t\troman+=\"m\"\n\tdone\n\tfor i in $(seq 1 $x); do\n\
    \t\tif [[ $i -eq 5 ]]; then\n\t\t\troman+=\"d\"\n\t\telif [[ $i -eq 9 ]]; then\n\
    \t\t\troman+=\"xm\"\n\t\telif [[ $i -eq 4 ]]; then\n\t\t\troman+=\"cm\"\n\t\t\
    else\n\t\t\troman+=\"c\"\n\t\tfi\n\tdone\n\tfor i in $(seq 1 $z); do\n\t\tif [[\
    \ $i -eq 5 ]]; then\n\t\t\troman+=\"l\"\n\t\telif [[ $i -eq 9 ]]; then\n\t\t\t\
    roman+=\"xc\"\n\t\telif [[ $i -eq 4 ]]; then\n\t\t\troman+=\"xc\"\n\t\telse\n\t\
    \t\troman+=\"x\"\n\t\tfi\n\tdone\n\tfor i in $(seq 1 $q); do\n\t\troman+=\"ix\"\
    \n\tdone\n\tfor i in $(seq 1 $w); do\n\t\troman+=\"v\"\n\tdone\n\tfor i in $(seq\
    \ 1 $u); do\n\t\troman+=\"iv\"\n\tdone\n\tfor i in $(seq 1 $v); do\n\t\troman+=\"\
    i\"\n\tdone\n\techo $roman", "    if [ $1 -gt 1000 ]; then return 1; fi\n    [\
    \ $1 -lt 1 ] && return 1\n    echo $1 | perl -nE '\n        next if /[^0-9]/;\n\
    \        my $roman = \"\";\n        my $n = $_;\n        $roman .= \"m\" x ($n\
    \ / 1000);\n        $n %= 1000;\n        $roman .= \"d\" x ($n / 500);\n     \
    \   $n %= 500;\n        $roman .= \"c\" x ($n / 100);\n        $n %= 100;\n  \
    \      $roman .= \"l\" x ($n / 50);\n        $n %= 50;\n        $roman .= \"x\"\
    \ x ($n / 10);\n        $n %= 10;\n        $roman .= \"v\" x ($n / 5);\n     \
    \   $n %= 5;\n        $roman .= \"i\" x $n;\n        $roman =~ s/^iv(iv)*//;\n\
    \        $roman =~ s/^ix(ix)*//;\n        $roman =~ s/^xc(xc)*//;\n        $roman\
    \ =~ s/^xl(xl)*//;\n        $roman =~ s/^cd(cd)*//;\n        $roman =~ s/^cm(cm)*//;\n\
    \        say $roman;\n    '", "    # vars\n    local num=$1\n    local rom=\"\"\
    \n    local -A dict\n\n    dict=(\n    [1]=\"i\" [2]=\"ii\" [3]=\"iii\" [4]=\"\
    iv\" [5]=\"v\" [6]=\"vi\" [7]=\"vii\" [8]=\"viii\" [9]=\"ix\" [10]=\"x\"\n   \
    \ [20]=\"xx\" [30]=\"xxx\" [40]=\"xl\" [50]=\"l\" [60]=\"lx\" [70]=\"lxx\" [80]=\"\
    lxxx\" [90]=\"xc\" [100]=\"c\"\n    [200]=\"cc\" [300]=\"ccc\" [400]=\"cd\" [500]=\"\
    d\" [600]=\"dc\" [700]=\"dcc\" [800]=\"dccc\" [900]=\"cm\" [1000]=\"m\"\n    )\n\
    \n    # If the number is less than 10, we simply need to look it up in the dictionary.\n\
    \    if (( num < 10 )); then\n        rom=${dict[$num]}\n    # If the number is\
    \ greater than 10 but less than 100, we need to break it up into\n    # tens and\
    \ ones (eg: 92).\n    elif (( num < 100 )); then\n        # This is the tens place.\n\
    \        local tens=$(( num / 10 ))\n        # This is the ones place.\n     \
    \   local ones=$(( num % 10 ))\n        # We need to concatenate the roman numerals\
    \ for the tens and ones together.\n        rom=\"${dict[$(( tens * 10 ))]}${dict[$ones]}\"\
    \n    # If the number is greater than 100 but less than 1000, we need to break\
    \ it up into\n    # hundreds, tens, and ones (eg: 426).\n    elif (( num < 1000\
    \ )); then\n        # This is the hundreds place.\n        local hundreds=$((\
    \ num / 100 ))\n        # This is the tens place.\n        local tens=$(( (num\
    \ / 10) % 10 ))\n        # This is the ones place.\n        local ones=$(( num\
    \ % 10 ))\n        # We need to concatenate the roman numerals for the hundreds,\
    \ tens, and ones together.\n        rom=\"", "    if [ $1 -eq 1 ]; then\n    \
    \    echo i\n    elif [ $1 -eq 5 ]; then\n        echo v\n    elif [ $1 -eq 10\
    \ ]; then\n        echo x\n    elif [ $1 -eq 50 ]; then\n        echo l\n    elif\
    \ [ $1 -eq 100 ]; then\n        echo c\n    elif [ $1 -eq 500 ]; then\n      \
    \  echo d\n    elif [ $1 -eq 1000 ]; then\n        echo m\n    elif [ $1 -lt 4\
    \ ]; then\n        printf \"%$1.s\" $(int_to_mini_roman 1)\n    elif [ $1 -eq\
    \ 4 ]; then\n        echo iv\n    elif [ $1 -lt 9 ]; then\n        echo v\n  \
    \      printf \"%$(($1 - 5)).s\" $(int_to_mini_roman 1)\n    elif [ $1 -eq 9 ];\
    \ then\n        echo ix\n    elif [ $1 -lt 40 ]; then\n        printf \"%$(($1\
    \ / 10)).s\" $(int_to_mini_roman 10)\n        printf \"%$(($1 % 10)).s\" $(int_to_mini_roman\
    \ 1)\n    elif [ $1 -lt 50 ]; then\n        echo xl\n        printf \"%$(($1 -\
    \ 40)).s\" $(int_to_mini_roman 1)\n    elif [ $1 -lt 90 ]; then\n        echo\
    \ l\n        printf \"%$(($(($1 - 50)) / 10)).s\" $(int_to_mini_roman 10)\n  \
    \      printf \"%$(($(($1 - 50)) % 10)).s\" $(int_to_mini_roman 1)\n    elif [\
    \ $1 -lt 100 ]; then\n        echo xc\n        printf \"%$(($1 - 90)).s\" $(int_to_mini_roman\
    \ 1)\n    elif [ $1 -lt 400 ]; then\n        printf \"%$(($1 / 100)).s\" $(int_to_mini_roman\
    \ 100)\n        printf \"%$(($1 % 100)).s\" $(int_to_mini_roman 1)\n    elif [\
    \ $1 -lt 500 ]; then\n        echo cd\n        printf \"%$(($1 - 400)).s\" $(",
  "    local num=\"$1\"\n    local n=0 i=0 v=0 x=0 l=0 c=0 d=0 m=0 # roman numerals\n\
    \    local r=''     # roman numeral string to be returned\n    while (( num >\
    \ 0 )); do\n        (( $num >= 1000 )) && {\n            (( num -= 1000 ))\n \
    \           (( m++ ))\n        }\n        (( $num >= 900 )) && {\n           \
    \ (( num -= 900 ))\n            (( d++ ))\n            (( c++ ))\n        }\n\
    \        (( $num >= 500 )) && {\n            (( num -= 500 ))\n            ((\
    \ d++ ))\n        }\n        (( $num >= 400 )) && {\n            (( num -= 400\
    \ ))\n            (( c++ ))\n            (( d++ ))\n        }\n        (( $num\
    \ >= 100 )) && {\n            (( num -= 100 ))\n            (( c++ ))\n      \
    \  }\n        (( $num >= 90 )) && {\n            (( num -= 90 ))\n           \
    \ (( l++ ))\n            (( x++ ))\n        }\n        (( $num >= 50 )) && {\n\
    \            (( num -= 50 ))\n            (( l++ ))\n        }\n        (( $num\
    \ >= 40 )) && {\n            (( num -= 40 ))\n            (( x++ ))\n        \
    \    (( l++ ))\n        }\n        (( $num >= 10 )) && {\n            (( num -=\
    \ 10 ))\n            (( x++ ))\n        }\n        (( $num >= 9 )) && {\n    \
    \        (( num -= 9 ))\n            (( v++ ))\n            (( i++ ))\n      \
    \  }\n        (( $num >= 5 )) && {\n            (( num -= 5 ))\n            ((\
    \ v++ ))\n        }\n        (( $num >= 4 )) && {\n            (( num -= 4 ))\n\
    \            (( i++ ))\n            (( v++ ))\n        }\n        (( $num >= 1\
    \ )) && {\n            (( num -= 1 ))\n            (( i++ ))\n        }\n    done\n\
    \    # we now have all the roman numerals:\n    # i = 1,  v = 5,  x = 10, l =\
    \ 50,\n    # c = 100, d = 500, m = 1000\n    # build up the roman numeral string\
    \ from them:\n    (( m > 0 )) &&", "  if [ $1 -lt 1 ] || [ $1 -gt 1000 ]; then\n\
    \    echo \"Expecting 1 <= num <= 1000\"\n    return 1\n  fi\n  #\n  # roman digits:\n\
    \  # I, V, X, L, C, D, M\n  # 1, 5, 10, 50, 100, 500, 1000\n  #\n  # a number\
    \ is represented as a sum of digits,\n  # and the lower digits occur before the\
    \ higher digits\n  # for example, 3 represents III\n  #\n  # when a digit's value\
    \ is equal to or greater than the value of the next\n  # digit, add the two digits\n\
    \  # for example, 17 represents XVII\n  #\n  # when a digit's value is less than\
    \ the value of the next digit, subtract\n  # the digit from the next digit, and\
    \ add this value to the remaining digits\n  # for example, 4 represents IV\n \
    \ # for example, 9 represents IX\n  #\n  # Examples of roman numbers:\n  # 1:\
    \ I\n  # 2: II\n  # 3: III\n  # 4: IV\n  # 5: V\n  # 6: VI\n  # 7: VII\n  # 8:\
    \ VIII\n  # 9: IX\n  # 10: X\n  # 11: XI\n  # 12: XII\n  # 13: XIII\n  # 14: XIV\n\
    \  # 15: XV\n  # 16: XVI\n  # 17: XVII\n  # 18: XVIII\n  # 19: XIX\n  # 20: XX\n\
    \  #\n  # roman numbers for 1, 2, 3, 4, 5, 6, 7, 8, 9\n  local roman_units=\"\
    i v x l c d m\"\n  #\n  # separate the digits of the input number\n  local rem=$1\n\
    \  local digits=\"\"\n  while [ $rem -gt 0 ]; do\n    digits=\"$rem%10 $digits\"\
    \n    rem=$((rem/10))\n  done\n  #\n  # for each digit:\n  #   a) use it to build\
    \ a partial roman number\n  #   b) if the next digit is 4 or 9, prepend the corresponding\
    \ special symbol\n  #\n  local roman_string=\"\"\n ", "  if [ $1 -lt 1 ] || [\
    \ $1 -gt 1000 ]; then\n    echo \"Invalid input: $1\"\n    exit 1\n  fi\n  # use\
    \ printf to avoid leading zeros\n  printf \"$(awk \"BEGIN { print \\$(($1)) }\"\
    )\"", "  if [[ ! $1 =~ ^[0-9]+$ ]]; then\n    echo \"\\\"$1\\\" is not an integer\"\
    \n    return 1\n  fi\n  # Below is an arbitrary limit\n  if [[ $1 -gt 1000 ]];\
    \ then\n    echo \"\\\"$1\\\" is greater than 1000\"\n    return 1\n  fi\n  #\
    \ Check for the presence of the roman numeral in the roman numeral \"alphabet\"\
    \n  for k in $alphabet; do\n    if [[ $1 == ${alphabet_dict[$k]} ]]; then\n  \
    \    echo $k\n      return 0\n    fi\n  done\n  # If there is no direct match,\
    \ attempt to derive the roman numeral representation\n  # in a way that's similar\
    \ to how we learned roman numerals in school:\n  # the largest roman numeral (representing\
    \ the largest integer value) that does\n  # not exceed our target number becomes\
    \ the leftmost digit in our roman numeral,\n  # and the remaining digits are derived\
    \ in a similar manner using the remaining\n  # values.\n  # Start by looking at\
    \ the largest roman numeral that fits in our target number\n  local leftmost_digit=1000\n\
    \  local leftmost_numeral=m\n  local remaining_integer=$1\n  local roman_numeral=\"\
    \"\n  while [[ $remaining_integer -gt 0 ]]; do\n    if [[ $remaining_integer -ge\
    \ $leftmost_digit ]]; then\n      remaining_integer=$((remaining_integer - leftmost_digit))\n\
    \      roman_numeral=$roman_numeral$leftmost_numeral\n    elif [[ $remaining_integer\
    \ -lt $leftmost_digit ]]; then\n      leftmost_digit=$((leftmost_digit / 10))\n\
    \      leftmost_numeral=${alphabet[$leftmost_digit]}\n    fi\n  done\n  echo $roman_numeral",
  "\tlocal -r num=\"$1\"\n\tlocal -r arabics=( \"1000\" \"900\" \"500\" \"400\" \"\
    100\" \"90\" \"50\" \"40\" \"10\" \"9\" \"5\" \"4\" \"1\" )\n\tlocal -r romans=(\
    \ \"m\" \"cm\" \"d\" \"cd\" \"c\" \"xc\" \"l\" \"xl\" \"x\" \"ix\" \"v\" \"iv\"\
    \ \"i\" )\n\tlocal -r n=\"${#arabics[@]}\"\n\tlocal roman=\"\"\n\tlocal i=0\n\t\
    while [ \"$i\" -lt \"$n\" ] && [ \"$num\" -gt 0 ]; do\n\t\tif [ \"$num\" -ge \"\
    ${arabics[$i]}\" ]; then\n\t\t\troman+=\"${romans[$i]}\"\n\t\t\tnum=$((num - ${arabics[$i]}))\n\
    \t\telse\n\t\t\ti=$((i + 1))\n\t\tfi\n\tdone\n\techo \"$roman\"", "    local num=\"\
    $1\"\n    local numeral_str=\"\"\n    local roman_hash\n\n    roman_hash=(\n \
    \       [1]=\"i\"\n        [5]=\"v\"\n        [10]=\"x\"\n        [50]=\"l\"\n\
    \        [100]=\"c\"\n        [500]=\"d\"\n        [1000]=\"m\"\n    )\n\n   \
    \ [ \"$num\" -gt 1000 ] && echo \"Out of range\" && return 1\n\n    if (( num\
    \ >= 100 )); then\n        local hundreds=\"$(( num / 100 ))\"\n        numeral_str+=\"\
    ${roman_hash[100]}\"\n        for (( i=0; i<$(( hundreds - 1 )); i++ )); do\n\
    \            numeral_str+=\"${roman_hash[100]}\"\n        done\n        num=\"\
    $(( num % 100 ))\"\n    fi\n\n    if (( num >= 10 )); then\n        local tens=\"\
    $(( num / 10 ))\"\n        if (( tens == 4 )); then\n            numeral_str+=\"\
    ${roman_hash[10]}${roman_hash[50]}\"\n        elif (( tens == 9 )); then\n   \
    \         numeral_str+=\"${roman_hash[10]}${roman_hash[100]}\"\n        elif ((\
    \ tens >= 5 )); then\n            numeral_str+=\"${roman_hash[50]}\"\n       \
    \     for (( i=0; i<$(( tens - 5 )); i++ )); do\n                numeral_str+=\"\
    ${roman_hash[10]}\"\n            done\n        else\n            for (( i=0; i<$tens;\
    \ i++ )); do\n                numeral_str+=\"${roman_hash[10]}\"\n           \
    \ done\n        fi\n        num=\"$(( num % 10 ))\"\n    fi\n\n    if (( num >\
    \ 0 )); then\n        if (( num == 4 )); then\n            numeral_str+=\"${roman_hash[1]}${roman_hash[5]}\"\
    \n        elif (( num == 9 )); then\n            numeral_str+=\"${roman_hash[1]}${roman_hash[10]}\"\
    \n        elif (( num >= 5 )); then\n            numeral_str+=\"${roman_hash[5]}\"\
    \n            for (( i", "    printf '%s' \"$1\" | awk '{printf \"%s\", toupper(int_to_roman($1))}'",
  "  roman_numerals=\"m d c l x v i\"\n  integer=\"$1\"\n  roman_numeral=\"\"\n  multiplier=1000\n\
    \  for roman_numeral in $roman_numerals; do\n    if [ $integer -ge $multiplier\
    \ ]; then\n      integer=$((integer - multiplier))\n      roman_numeral=\"$roman_numeral$roman_numeral\"\
    \n    fi\n    multiplier=$((multiplier / 10))\n  done\n  echo \"$roman_numeral\"",
  "  local -i num=\"$1\"\n  if [[ $num -lt 1 || $num -gt 1000 ]]; then\n    echo \"\
    Unable to obtain Roman numeral for $num\" >&2\n    return 1\n  fi\n  local -A\
    \ map=(\n    [0]=\"dcccc\" [1]=\"cccc\" [2]=\"ccc\" [3]=\"cc\" [4]=\"c\"\n   \
    \ [5]=\"lxxxx\" [6]=\"xxxx\" [7]=\"xxx\" [8]=\"xx\" [9]=\"x\"\n    [10]=\"viiii\"\
    \ [11]=\"iiii\" [12]=\"iii\" [13]=\"ii\" [14]=\"i\"\n  )\n  local -i hundreds=$((num\
    \ / 100))\n  local -i tens=$(((num % 100) / 10))\n  local -i ones=$((num % 10))\n\
    \  printf \"%s%s%s\" \\\n    \"${map[$hundreds]}\" \\\n    \"${map[$tens + 5]}\"\
    \ \\\n    \"${map[$ones + 10]}\"", "  local num=$1\n  local out=''\n  local -A\
    \ roman_numerals=( ['1']=i ['2']=ii ['3']=iii ['4']=iv ['5']=v ['6']=vi ['7']=vii\
    \ ['8']=viii ['9']=ix ['10']=x ['20']=xx ['30']=xxx ['40']=xl ['50']=l ['60']=lx\
    \ ['70']=lxx ['80']=lxxx ['90']=xc ['100']=c ['200']=cc ['300']=ccc ['400']=cd\
    \ ['500']=d ['600']=dc ['700']=dcc ['800']=dccc ['900']=cm ['1000']=m )\n  if\
    \ [[ $num -ge 1 && $num -le 1000 ]]; then\n    for ((i=0; num>0; i++)); do\n \
    \     digit=$(( num % 10 ))\n      out=${roman_numerals[$(( digit * 10**i ))]}$out\n\
    \      num=$(( num / 10 ))\n    done\n  fi\n  echo $out", "  local input=\"$1\"\
    \n  local numerals=(\"\" \"i\" \"ii\" \"iii\" \"iv\" \"v\" \"vi\" \"vii\" \"viii\"\
    \ \"ix\")\n  local huns=(\"\" \"c\" \"cc\" \"ccc\" \"cd\" \"d\" \"dc\" \"dcc\"\
    \ \"dccc\" \"cm\")\n  local tens=(\"\" \"x\" \"xx\" \"xxx\" \"xl\" \"l\" \"lx\"\
    \ \"lxx\" \"lxxx\" \"xc\")\n  local thousands=(\"\" \"m\" \"mm\" \"mmm\")\n  local\
    \ num_thousands=$((input / 1000))\n  local num_hundreds=$(((input % 1000) / 100))\n\
    \  local num_tens=$(((input % 100) / 10))\n  local num_ones=$((input % 10))\n\
    \  local roman=\"${thousands[$num_thousands]}${huns[$num_hundreds]}${tens[$num_tens]}${numerals[$num_ones]}\"\
    \n  echo \"$roman\"", "  # input validation\n  if ! [[ \"$1\" =~ ^[0-9]+$ ]];\
    \ then\n    error \"invalid argument: $1\"\n    return 1\n  fi\n  # check for\
    \ valid range\n  if (($1 < 1 || $1 > 1000)); then\n    error \"invalid range:\
    \ $1\"\n    return 1\n  fi\n  # replace the numbers with the equivalent roman\
    \ numerals\n  local mini_roman_number=$(replace_number_with_numeral $1)\n  # convert\
    \ to lowercase\n  local mini_roman_number=$(to_lower $mini_roman_number)\n  #\
    \ return result\n  echo $mini_roman_number", "    if [[ $1 -le 0 ]]; then\n  \
    \      echo 'invalid input'\n        return 1\n    fi\n    if [[ $1 -gt 1000 ]];\
    \ then\n        echo 'input too large'\n        return 1\n    fi\n    local num=$1\n\
    \    local m='m'\n    local d='d'\n    local c='c'\n    local l='l'\n    local\
    \ x='x'\n    local v='v'\n    local i='i'\n    local roman=''\n    if [[ $num\
    \ -ge 1000 ]]; then\n        num=$((num-1000))\n        roman=$m\n    fi\n   \
    \ if [[ $num -ge 900 ]]; then\n        num=$((num-900))\n        roman=$roman$c$m\n\
    \    fi\n    if [[ $num -ge 500 ]]; then\n        num=$((num-500))\n        roman=$roman$d\n\
    \    fi\n    if [[ $num -ge 400 ]]; then\n        num=$((num-400))\n        roman=$roman$c$d\n\
    \    fi\n    if [[ $num -ge 100 ]]; then\n        num=$((num-100))\n        roman=$roman$c\n\
    \    fi\n    if [[ $num -ge 90 ]]; then\n        num=$((num-90))\n        roman=$roman$x$c\n\
    \    fi\n    if [[ $num -ge 50 ]]; then\n        num=$((num-50))\n        roman=$roman$l\n\
    \    fi\n    if [[ $num -ge 40 ]]; then\n        num=$((num-40))\n        roman=$roman$x$l\n\
    \    fi\n    if [[ $num -ge 10 ]]; then\n        num=$((num-10))\n        roman=$roman$x\n\
    \    fi\n    if [[ $num -ge 9 ]]; then\n        num=$((num-9))\n        roman=$roman$i$x\n\
    \    fi\n    if [[ $num -ge 5 ]]; then\n        num=$((num-5))\n        roman=$roman$v\n\
    \    fi\n    if [[ $num -ge 4 ]]; then\n        num=$((num-4))\n        roman=$roman$i$v\n\
    \    fi\n   ", "    local TEMP_INT=\"$1\"\n    local RN=\"\"\n    while [[ \"\
    $TEMP_INT\" != 0 ]]; do\n        while [[ \"$TEMP_INT\" -ge 1000 ]]; do\n    \
    \        TEMP_INT=$((TEMP_INT - 1000))\n            RN+=\"m\"\n        done\n\
    \        while [[ \"$TEMP_INT\" -ge 900 ]]; do\n            TEMP_INT=$((TEMP_INT\
    \ - 900))\n            RN+=\"cm\"\n        done\n        while [[ \"$TEMP_INT\"\
    \ -ge 500 ]]; do\n            TEMP_INT=$((TEMP_INT - 500))\n            RN+=\"\
    d\"\n        done\n        while [[ \"$TEMP_INT\" -ge 400 ]]; do\n           \
    \ TEMP_INT=$((TEMP_INT - 400))\n            RN+=\"cd\"\n        done\n       \
    \ while [[ \"$TEMP_INT\" -ge 100 ]]; do\n            TEMP_INT=$((TEMP_INT - 100))\n\
    \            RN+=\"c\"\n        done\n        while [[ \"$TEMP_INT\" -ge 90 ]];\
    \ do\n            TEMP_INT=$((TEMP_INT - 90))\n            RN+=\"xc\"\n      \
    \  done\n        while [[ \"$TEMP_INT\" -ge 50 ]]; do\n            TEMP_INT=$((TEMP_INT\
    \ - 50))\n            RN+=\"l\"\n        done\n        while [[ \"$TEMP_INT\"\
    \ -ge 40 ]]; do\n            TEMP_INT=$((TEMP_INT - 40))\n            RN+=\"xl\"\
    \n        done\n        while [[ \"$TEMP_INT\" -ge 10 ]]; do\n            TEMP_INT=$((TEMP_INT\
    \ - 10))\n            RN+=\"x\"\n        done\n        while [[ \"$TEMP_INT\"\
    \ -ge 9 ]]; do\n            TEMP_INT=$((TEMP_INT - 9))\n            RN+=\"ix\"\
    \n        done\n        while [[ \"$TEMP_INT\" -ge 5 ]]; do\n            TEMP_INT=$((TEMP_INT\
    \ - 5))\n            RN+=\"v\"\n        done\n        while [[ \"$TEMP_INT\" -ge\
    \ 4 ]]; do\n            TEMP_INT=$((TEMP_INT -", "  local int=$1\n  local numeral\n\
    \  for numeral in i v x l c d m; do\n    if (($int == 1)); then\n      echo $numeral\n\
    \      return\n    elif (($int == 4)); then\n      echo ${numeral}v\n      return\n\
    \    elif (($int == 5)); then\n      echo v\n      return\n    elif (($int ==\
    \ 9)); then\n      echo ${numeral}x\n      return\n    elif (($int < 4)); then\n\
    \      local temp=$numeral\n      while (($int > 1)); do\n        numeral=$numeral$temp\n\
    \        int=$(($int - 1))\n      done\n      echo $numeral\n      return\n  \
    \  elif (($int < 9)); then\n      local temp=$numeral\n      while (($int > 5));\
    \ do\n        numeral=$numeral$temp\n        int=$(($int - 1))\n      done\n \
    \     numeral=v$numeral\n      echo $numeral\n      return\n    fi\n    int=$(($int\
    \ / 10))\n  done", "    IFS='' read -r -d '' map <<- EOF\n        1  i\n     \
    \   2  ii\n        3  iii\n        4  iv\n        5  v\n        6  vi\n      \
    \  7  vii\n        8  viii\n        9  ix\n        10 x\n        20 xx\n     \
    \   30 xxx\n        40 xl\n        50 l\n        60 lx\n        70 lxx\n     \
    \   80 lxxx\n        90 xc\n        100 c\n        200 cc\n        300 ccc\n \
    \       400 cd\n        500 d\n        600 dc\n        700 dcc\n        800 dccc\n\
    \        900 cm\n        1000 m\n        2000 mm\n        3000 mmm\n        4000\
    \ mv\n        5000 v\n        6000 vm\n        7000 vmm\n        8000 vmmm\n \
    \       9000 mx\n        10000 x\n        20000 xx\n        30000 xxx\n      \
    \  40000 xl\n        50000 l\n        60000 lx\n        70000 lxx\n        80000\
    \ lxxx\n        90000 xc\n        100000 c\n        200000 cc\n        300000\
    \ ccc\n        400000 cd\n        500000 d\n        600000 dc\n        700000\
    \ dcc\n        800000 dccc\n        900000 cm\n        1000000 m\n        2000000\
    \ mm\n        3000000 mmm\n        4000000 mv\n        5000000 v\n        6000000\
    \ vm\n        7000000 vmm\n        8000000 vmmm\n        9000000 mx\n        10000000\
    \ x\n        20000000 xx\n        30000000 xxx\n        40000000 xl\n        50000000\
    \ l\n        60000000 lx\n        70000000 lxx\n        80000000 lxxx\n      \
    \  90000000 xc\n        100000000 c\n        200000000 cc\n        300000000 ccc\n\
    \        400000000 cd\n        500000000 d\n        600000000 dc\n        700000000\
    \ dcc\n        800000000 dccc\n        900000000 cm\n        1000000000 m\n  \
    \      2000000000 mm\n        3000000000 mmm\n        4000000000 mv\n        5000000000\
    \ v\n        6000000000 vm\n        7000000000 vmm\n        8000000000 vmmm\n\
    \        9000000000 mx\n        10000000000 x\n        20000000000 xx\n      \
    \  30000000000 xxx\n", "\tlocal int=\"$1\"\n\tlocal roman=\"\"\n\t[ \"$int\" -lt\
    \ \"1\" ] && echo \"Integer must be a positive integer\" >&2 && return 1\n\t[\
    \ \"$int\" -gt \"1000\" ] && echo \"Integer must be <= 1000\" >&2 && return 1\n\
    \twhile [ \"$int\" -gt \"0\" ]; do\n\t\tif [ \"$int\" -ge \"900\" ]; then\n\t\t\
    \troman+=\"cm\"\n\t\t\tint=$((int-900))\n\t\telif [ \"$int\" -ge \"500\" ]; then\n\
    \t\t\troman+=\"d\"\n\t\t\tint=$((int-500))\n\t\telif [ \"$int\" -ge \"400\" ];\
    \ then\n\t\t\troman+=\"cd\"\n\t\t\tint=$((int-400))\n\t\telif [ \"$int\" -ge \"\
    100\" ]; then\n\t\t\troman+=\"c\"\n\t\t\tint=$((int-100))\n\t\telif [ \"$int\"\
    \ -ge \"90\" ]; then\n\t\t\troman+=\"xc\"\n\t\t\tint=$((int-90))\n\t\telif [ \"\
    $int\" -ge \"50\" ]; then\n\t\t\troman+=\"l\"\n\t\t\tint=$((int-50))\n\t\telif\
    \ [ \"$int\" -ge \"40\" ]; then\n\t\t\troman+=\"xl\"\n\t\t\tint=$((int-40))\n\t\
    \telif [ \"$int\" -ge \"10\" ]; then\n\t\t\troman+=\"x\"\n\t\t\tint=$((int-10))\n\
    \t\telif [ \"$int\" -ge \"9\" ]; then\n\t\t\troman+=\"ix\"\n\t\t\tint=$((int-9))\n\
    \t\telif [ \"$int\" -ge \"5\" ]; then\n\t\t\troman+=\"v\"\n\t\t\tint=$((int-5))\n\
    \t\telif [ \"$int\" -ge \"4\" ]; then\n\t\t\troman+=\"iv\"\n\t\t\tint=$((int-4))\n\
    \t\telif [ \"$int\" -ge \"1\" ]; then\n\t\t\troman+=\"i\"\n\t\t\tint=$((int",
  "  if [[ ! $1 =~ ^[0-9]+$ ]]; then\n    echo \"error: $1 is not an integer.\"\n\
    \    exit 1\n  fi\n  if [[ $1 -lt 1 ]] || [[ $1 -gt 1000 ]]; then\n    echo \"\
    error: $1 is not in the range 1 <= num <= 1000.\"\n    exit 1\n  fi\n  local -i\
    \ int=\"$1\"\n  local -i remainder\n  local roman_numeral=\"\"\n  for (( i=0;\
    \ i<${#mini_romans[@]}; i+=2 )); do\n    if [[ $int -ge ${mini_romans[$i]} ]];\
    \ then\n      let \"remainder = int % ${mini_romans[$i]}\"\n      roman_numeral+=\"\
    ${mini_romans[$(( i+1 ))]}\"\n      let \"int = (int - remainder) / ${mini_romans[$i]}\"\
    \n    fi\n  done\n  echo \"$roman_numeral\"", "  local I=$1\n\n  # No more than\
    \ 3 of the same character in succession, except for M.\n  # MMMMMM is invalid.\n\
    \  local n_M=$((I / 1000))\n  local n_D=$(((I % 1000) / 500))\n  local n_C=$(((I\
    \ % 500) / 100))\n  local n_L=$(((I % 100) / 50))\n  local n_X=$(((I % 50) / 10))\n\
    \  local n_V=$(((I % 10) / 5))\n  local n_I=$((I % 5))\n\n  local roman=\"\"\n\
    \  roman+=$(repeat \"$n_M\" \"M\")\n  roman+=$(repeat \"$n_D\" \"D\")\n  roman+=$(repeat\
    \ \"$n_C\" \"C\")\n  roman+=$(repeat \"$n_L\" \"L\")\n  roman+=$(repeat \"$n_X\"\
    \ \"X\")\n  roman+=$(repeat \"$n_V\" \"V\")\n  roman+=$(repeat \"$n_I\" \"I\"\
    )\n\n  echo \"$roman\"", "  awk -v num=\"$1\" 'BEGIN {\n    while (num) {\n  \
    \    if (num >= 1000) {printf \"m\"; num -= 1000}\n      else if (num >= 900)\
    \ {printf \"cm\"; num -= 900}\n      else if (num >= 500) {printf \"d\"; num -=\
    \ 500}\n      else if (num >= 400) {printf \"cd\"; num -= 400}\n      else if\
    \ (num >= 100) {printf \"c\"; num -= 100}\n      else if (num >= 90) {printf \"\
    xc\"; num -= 90}\n      else if (num >= 50) {printf \"l\"; num -= 50}\n      else\
    \ if (num >= 40) {printf \"xl\"; num -= 40}\n      else if (num >= 10) {printf\
    \ \"x\"; num -= 10}\n      else if (num >= 9) {printf \"ix\"; num -= 9}\n    \
    \  else if (num >= 5) {printf \"v\"; num -= 5}\n      else if (num >= 4) {printf\
    \ \"iv\"; num -= 4}\n      else if (num >= 1) {printf \"i\"; num -= 1}\n    }\n\
    \  }'", "    local result=\"\"\n\n    if (( $1 < 1 || $1 > 1000 )); then\n   \
    \     echo \"Argument is not an integer within [1, 1000]\"\n        return 1\n\
    \    fi\n\n    for i in {1..1000}; do\n        number=$(( $1 % 10 ))\n       \
    \ num_string=$(convert_to_lower_string $number)\n        result=\"$num_string$result\"\
    \n        (( $1 /= 10 ))\n        if (( $1 == 0 )); then\n            break\n\
    \        fi\n    done\n\n    echo $result", "    if [[ $1 =~ ^[0-9]+$ ]]; then\n\
    \        python -c \"print ($1).to_roman()\" | tr '[A-Z]' '[a-z]'\n    else\n\
    \        echo \"ERROR: Arg $1 is not an integer\"\n    fi", "    local -i input=$1\n\
    \    local -i i=0 l=0 c=0 d=0 x=0 v=0 ix=0 xc=0 cd=0 cm=0\n    [ $input -gt 1000\
    \ ] && return 1\n    [ $input -eq 1000 ] && echo \"m\" && return 0\n    [ $input\
    \ -gt  900 ] && input=$((input-900)) && cm=1\n    [ $input -gt  800 ] && input=$((input-800))\
    \ && cm=1 && d=1\n    [ $input -gt  700 ] && input=$((input-700)) && cm=1 && d=1\
    \ && c=1\n    [ $input -gt  600 ] && input=$((input-600)) && cm=1 && d=1 && c=1\
    \ && d=1\n    [ $input -gt  500 ] && input=$((input-500)) && d=1\n    [ $input\
    \ -gt  400 ] && input=$((input-400)) && cd=1\n    [ $input -gt  300 ] && input=$((input-300))\
    \ && cd=1 && c=1\n    [ $input -gt  200 ] && input=$((input-200)) && cd=1 && c=1\
    \ && c=1\n    [ $input -gt  100 ] && input=$((input-100)) && c=1\n    [ $input\
    \ -gt   90 ] && input=$((input-90)) && xc=1\n    [ $input -gt   80 ] && input=$((input-80))\
    \ && xc=1 && l=1\n    [ $input -gt   70 ] && input=$((input-70)) && xc=1 && l=1\
    \ && x=1\n    [ $input -gt   60 ] && input=$((input-60)) && xc=1 && l=1 && x=1\
    \ && l=1\n    [ $input -gt   50 ] && input=$((input-50)) && l=1\n    [ $input\
    \ -gt   40 ] && input=$((input-40)) && xl=1\n    [ $input -gt   30 ] && input=$((input-30))\
    \ && xl=1 && x=1\n    [ $input -gt   20 ] && input=$((input-", "    local arabic_num=$1\n\
    \    local roman_num=\"\"\n    local len=$(expr length $arabic_num)\n    local\
    \ i=$(($len - 1))\n    local arabic_num_section\n    local roman_num_section\n\
    \    local j\n    while [ $i -ge 0 ]; do\n        arabic_num_section=$(expr substr\
    \ $arabic_num $i 1)\n        roman_num_section=$(arabic_to_mini_roman $arabic_num_section)\n\
    \        roman_num=\"$roman_num_section$roman_num\"\n        j=$(($i - 1))\n \
    \       if [ $j -ge 0 ]; then\n            while [ $j -ge 0 ]; do\n          \
    \      roman_num_section=$(arabic_to_mini_roman $(expr substr $arabic_num $j 1))\n\
    \                roman_num=\"${roman_num_section}0$roman_num\"\n             \
    \   j=$(($j - 1))\n            done\n        fi\n        i=$(($i - 1))\n    done\n\
    \    echo $roman_num", "  local integer=$1\n  local LEN=${#integer}\n  local result=\"\
    \"\n  for ((i = 0; i < LEN; i++)); do\n    local digit=$(echo \"$integer\" | cut\
    \ -c $((i + 1)))\n    case $digit in\n      1)\n        local one_symbol=\"i\"\
    \n        ;;\n      2)\n        local one_symbol=\"ii\"\n        ;;\n      3)\n\
    \        local one_symbol=\"iii\"\n        ;;\n      4)\n        local one_symbol=\"\
    iv\"\n        ;;\n      5)\n        local one_symbol=\"v\"\n        ;;\n     \
    \ 6)\n        local one_symbol=\"vi\"\n        ;;\n      7)\n        local one_symbol=\"\
    vii\"\n        ;;\n      8)\n        local one_symbol=\"viii\"\n        ;;\n \
    \     9)\n        local one_symbol=\"ix\"\n        ;;\n      0)\n        local\
    \ one_symbol=\"\"\n        ;;\n    esac\n    result=\"${one_symbol}${result}\"\
    \n  done\n  echo \"$result\"", "    local n=\"$1\"\n    local roman=\"\"\n   \
    \ if ((n >= 1000)); then\n        roman=\"m\"\n        ((n -= 1000))\n    fi\n\
    \    if ((n >= 900)); then\n        roman+=\"cm\"\n        ((n -= 900))\n    fi\n\
    \    if ((n >= 500)); then\n        roman+=\"d\"\n        ((n -= 500))\n    fi\n\
    \    if ((n >= 400)); then\n        roman+=\"cd\"\n        ((n -= 400))\n    fi\n\
    \    if ((n >= 100)); then\n        while ((n >= 100)); do\n            roman+=\"\
    c\"\n            ((n -= 100))\n        done\n    fi\n    if ((n >= 90)); then\n\
    \        roman+=\"xc\"\n        ((n -= 90))\n    fi\n    if ((n >= 50)); then\n\
    \        roman+=\"l\"\n        ((n -= 50))\n    fi\n    if ((n >= 40)); then\n\
    \        roman+=\"xl\"\n        ((n -= 40))\n    fi\n    if ((n >= 10)); then\n\
    \        while ((n >= 10)); do\n            roman+=\"x\"\n            ((n -= 10))\n\
    \        done\n    fi\n    if ((n >= 9)); then\n        roman+=\"ix\"\n      \
    \  ((n -= 9))\n    fi\n    if ((n >= 5)); then\n        roman+=\"v\"\n       \
    \ ((n -= 5))\n    fi\n    if ((n >= 4)); then\n        roman+=\"iv\"\n       \
    \ ((n -= 4))\n    fi\n    if ((n >= 1)); then\n        while ((n >= 1)); do\n\
    \            roman+=\"i\"\n            ((n -= 1))\n        done\n    fi\n    echo\
    \ \"$roman\"", "  local num=$1\n  local out=\"\"\n  while [ $num -ge 1000 ]; do\
    \ out+=\"m\"; let num-=1000; done\n  while [ $num -ge 500 ]; do out+=\"d\"; let\
    \ num-=500; done\n  while [ $num -ge 100 ]; do out+=\"c\"; let num-=100; done\n\
    \  while [ $num -ge 50 ]; do out+=\"l\"; let num-=50; done\n  while [ $num -ge\
    \ 10 ]; do out+=\"x\"; let num-=10; done\n  while [ $num -ge 5 ]; do out+=\"v\"\
    ; let num-=5; done\n  while [ $num -ge 1 ]; do out+=\"i\"; let num-=1; done\n\
    \  echo \"$out\"", "\tn=$1\n\tnumeral=''\n\t# add i's\n\tfor ((i=0; i<n; i++));\
    \ do\n\t\tnumeral+='i'\n\tdone\n\t# change 4s to iv\n\tnumeral=$(echo $numeral\
    \ | sed -e 's/iiii/iv/g')\n\t# change 9s to ix\n\tnumeral=$(echo $numeral | sed\
    \ -e 's/iiiii/ix/g')\n\t# change 50s to l\n\tnumeral=$(echo $numeral | sed -e\
    \ 's/x/l/g')\n\t# change 40s to xl\n\tnumeral=$(echo $numeral | sed -e 's/ll/xl/g')\n\
    \t# change 90s to xc\n\tnumeral=$(echo $numeral | sed -e 's/lll/xc/g')\n\t# change\
    \ 500s to d\n\tnumeral=$(echo $numeral | sed -e 's/c/d/g')\n\t# change 400s to\
    \ cd\n\tnumeral=$(echo $numeral | sed -e 's/dd/cd/g')\n\t# change 900s to cm\n\
    \tnumeral=$(echo $numeral | sed -e 's/ddd/cm/g')\n\t# change 1000s to m\n\tnumeral=$(echo\
    \ $numeral | sed -e 's/d/m/g')\n\techo $numeral", "\tlocal num=\"$1\"\n\tlocal\
    \ num_backup=\"$num\"\n\tlocal roman=\"\"\n\tlocal one=0\n\tlocal five=0\n\tlocal\
    \ ten=0\n\tlocal fifty=0\n\tlocal hundred=0\n\tlocal five_hundred=0\n\tlocal thousand=0\n\
    \t# Convert input number to roman\n\twhile [ \"$num\" -gt 0 ]; do\n\t\t# Check\
    \ if number is in range 1 - 1000\n\t\tif [ \"$num\" -lt 1 ] || [ \"$num\" -gt\
    \ 1000 ]; then\n\t\t\tprintf \"Error: Out of range, must be 1 <= num <= 1000!\\\
    n\"\n\t\t\treturn 1\n\t\tfi\n\t\t# Get each digit\n\t\tone=$((num % 10))\n\t\t\
    num=$((num / 10))\n\t\tten=$((num % 10))\n\t\tnum=$((num / 10))\n\t\thundred=$((num\
    \ % 10))\n\t\tnum=$((num / 10))\n\t\tthousand=$((num % 10))\n\t\tnum=$((num /\
    \ 10))\n\t\t# Convert each digit to roman\n\t\t[ \"$one\" -ne 0 ] && convert_to_roman\
    \ one \"$one\"\n\t\t[ \"$ten\" -ne 0 ] && convert_to_roman ten \"$ten\"\n\t\t\
    [ \"$hundred\" -ne 0 ] && convert_to_roman hundred \"$hundred\"\n\t\t[ \"$thousand\"\
    \ -ne 0 ] && convert_to_roman thousand \"$thousand\"\n\tdone\n\t# Reverse the\
    \ string\n\tlocal roman_rev=$(echo \"$roman\" | rev)\n\tprintf \"$roman_rev\"",
  "\tlocal num=\"$1\"\n\tlocal numeral=\n\tlocal unit=\n\tlocal tens=\n\tlocal hundreds=\n\
    \tlocal thousands=\n\tif [[ $num -lt 1 || $num -gt 1000 ]]; then\n\t\tnumeral=\n\
    \telse\n\t\tthousands=$(( num / 1000 ))\n\t\tnum=$(( num % 1000 ))\n\t\thundreds=$((\
    \ num / 100 ))\n\t\tnum=$(( num % 100 ))\n\t\ttens=$(( num / 10 ))\n\t\tnum=$((\
    \ num % 10 ))\n\t\tunit=$num\n\t\tnumeral=$(gen_mini_numeral_string \"$thousands\"\
    \ \"m\" \"$hundreds\" \"c\" \"$tens\" \"x\" \"$unit\" \"i\")\n\tfi\n\techo \"\
    $numeral\"", "  local CIRCLE_NUM=(\" \" \"i\" \"ii\" \"iii\" \"iv\" \"v\" \"vi\"\
    \ \"vii\" \"viii\" \"ix\")\n  local TENS_NUM=(\" \" \"x\" \"xx\" \"xxx\" \"xl\"\
    \ \"l\" \"lx\" \"lxx\" \"lxxx\" \"xc\")\n  local HUND_NUM=(\" \" \"c\" \"cc\"\
    \ \"ccc\" \"cd\" \"d\" \"dc\" \"dcc\" \"dccc\" \"cm\")\n  local THOU_NUM=(\" \"\
    \ \"m\" \"mm\" \"mmm\")\n  local num=\"$1\"\n  local text=\"\"\n  local TENS=\"\
    $(( ${num} % 100 ))\"\n  local HUND=\"$(( ${num} % 1000 ))\"\n  local THOU=\"\
    $(( ${num} % 10000 ))\"\n  if [ ${THOU} -ge 1000 ]; then\n    text+=\"${THOU_NUM[$((\
    \ (THOU / 1000) ))]}\"\n  fi\n  if [ ${HUND} -ge 100 ]; then\n    text+=\"${HUND_NUM[$((\
    \ (HUND / 100) ))]}\"\n  fi\n  if [ ${TENS} -ge 10 ]; then\n    text+=\"${TENS_NUM[$((\
    \ (TENS / 10) ))]}\"\n  fi\n  text+=\"${CIRCLE_NUM[$(( (num % 10) ))]}\"\n  echo\
    \ \"${text}\"", "    declare -A mini_roman_mapping=([1]=\"i\" [2]=\"ii\" [3]=\"\
    iii\" [4]=\"iv\" [5]=\"v\" [6]=\"vi\" [7]=\"vii\" [8]=\"viii\" [9]=\"ix\"\n  \
    \                                 [10]=\"x\" [20]=\"xx\" [30]=\"xxx\" [40]=\"\
    xl\" [50]=\"l\" [60]=\"lx\" [70]=\"lxx\" [80]=\"lxxx\" [90]=\"xc\"\n         \
    \                          [100]=\"c\" [200]=\"cc\" [300]=\"ccc\" [400]=\"cd\"\
    \ [500]=\"d\" [600]=\"dc\" [700]=\"dcc\" [800]=\"dccc\" [900]=\"cm\"\n       \
    \                            [1000]=\"m\")\n    declare -a keys=(1000 100 10 1)\n\
    \    local -a roman\n    for key in \"${keys[@]}\"; do\n        while (( $1 >=\
    \ $key )); do\n            roman+=(\"${mini_roman_mapping[$key]}\")\n        \
    \    (( $1 -= $key ))\n        done\n    done\n    echo \"${roman[@]}\" | tr '[:upper:]'\
    \ '[:lower:]'", "  local num=$1\n  local -a nums\n  local -a digits\n  local -a\
    \ units\n  local -a fives\n  local -a tens\n  local result=''\n  local index=0\n\
    \  local digit=0\n  local stop=0\n\n  if [[ $num -lt 1 || $num -gt 1000 ]]; then\n\
    \    echo \"$(date +%Y-%m-%dT%H:%M:%SZ) Function int_to_mini_roman() given the\
    \ argument $num\" >&2\n    echo \"Please give a positive integer between 1 and\
    \ 1000\" >&2\n    return 1\n  fi\n\n  # Map numerals and digits.\n  nums=('' I\
    \ V X L C D M)\n  digits=('' x x x x x x x x x)\n  units=('' I II III IV V VI\
    \ VII VIII IX)\n  fives=('' V x x x x x x x x x)\n  tens=('' X XX XXX XL L LX\
    \ LXX LXXX XC)\n\n  # Parse the number into a list of digits.\n  while [[ $num\
    \ -gt 0 ]]; do\n    # Add the digit to the list, and increment the index.\n  \
    \  digits[$index]=$((num % 10))\n    num=$((num / 10))\n    index=$((index + 1))\n\
    \  done\n\n  # Reconstruct the number from the list of digits, in reverse order.\n\
    \  index=$((index - 1))\n  while [[ $index -ge 0 ]]; do\n    # Grab the digit.\n\
    \    digit=${digits[$index]}\n\n    # Determine the correct Roman numeral representation.\n\
    \    case $digit in\n      1) result=${units[$index]};;\n      2) result=${units[$index]}${units[$index]};;\n\
    \      3) result=${units[$index]}${units[$index]}${units[$index]};;\n      4)\
    \ result=${units[$index]}${fives[$index]};;\n      5) result=${fives[$index]};;\n\
    \      6) result=${fives[$index]}${units[$index]};;\n      7) result=${fives[$index]}${units[$",
  "  out=\"\"\n  for ((i=${#1}; i>0; i--)); do\n    num=${1:((i-1)):1}\n    case \"\
    $num\" in\n      1) out=\"$out\"i ;;\n      2) out=\"$out\"ii ;;\n      3) out=\"\
    $out\"iii ;;\n      4) out=\"$out\"iv ;;\n      5) out=\"$out\"v ;;\n      6)\
    \ out=\"$out\"vi ;;\n      7) out=\"$out\"vii ;;\n      8) out=\"$out\"viii ;;\n\
    \      9) out=\"$out\"ix ;;\n      0) ;;\n      *) echo \"Error in int_to_mini_roman\"\
    \ 1>&2 ; exit 1 ;;\n    esac\n    ((i-=1))\n    num=${1:((i-1)):1}\n    case \"\
    $num\" in\n      1) out=\"$out\"x ;;\n      2) out=\"$out\"xx ;;\n      3) out=\"\
    $out\"xxx ;;\n      4) out=\"$out\"xl ;;\n      5) out=\"$out\"l ;;\n      6)\
    \ out=\"$out\"lx ;;\n      7) out=\"$out\"lxx ;;\n      8) out=\"$out\"lxxx ;;\n\
    \      9) out=\"$out\"xc ;;\n      0) ;;\n      *) echo \"Error in int_to_mini_roman\"\
    \ 1>&2 ; exit 1 ;;\n    esac\n    ((i-=1))\n    num=${1:((i-1)):1}\n    case \"\
    $num\" in\n      1) out=\"$out\"c ;;\n      2) out=\"$out\"cc ;;\n      3) out=\"\
    $out\"ccc ;;\n      4) out=\"$out\"cd ;;\n      5) out=\"$out\"d ;;\n      6)\
    \ out=\"$out\"dc ;;\n      7) out=\"$out\"dcc ;;\n      8) out=\"$out\"dccc ;;\n\
    \      9) out=\"$out\"cm ;;\n      0) ;;\n      *) echo \"Error in int_to_mini_roman\"\
    \ 1>&2 ; exit 1 ;;\n    esac\n    ((i-", "    # Ensure the script was called with\
    \ a valid argument\n    if [[ $1 == \"\" ]]; then\n        echo \"ERROR: The script\
    \ must be called with one positive integer argument.\"\n        exit 1\n    elif\
    \ ! [[ $1 =~ ^[0-9]+$ ]]; then\n        echo \"ERROR: The script must be called\
    \ with one positive integer argument.\"\n        exit 1\n    elif [[ $1 -lt 1\
    \ ]]; then\n        echo \"ERROR: The argument must be a positive integer.\"\n\
    \        exit 1\n    elif [[ $1 -gt 1000 ]]; then\n        echo \"ERROR: The argument\
    \ must be less than or equal to 1000.\"\n        exit 1\n    fi\n\n    # Declare\
    \ variables to keep track of how many I, X, C, and M there are\n    # Respectively,\
    \ I=1, X=10, C=100, M=1000\n    local num_i=0\n    local num_x=0\n    local num_c=0\n\
    \    local num_m=0\n\n    # Declare the output variable\n    local out=\"\"\n\n\
    \    # Declare local variables to hold the current number of hundreds, tens, and\
    \ ones\n    local hundreds=0\n    local tens=0\n    local ones=0\n\n    # Get\
    \ the value of the hundreds digit\n    hundreds=$(($1 / 100))\n    # Get the value\
    \ of the tens digit\n    tens=$((($1 % 100) / 10))\n    # Get the value of the\
    \ ones digit\n    ones=$(($1 % 10))\n\n    # While the value of the input is greater\
    \ than 1000\n    while [[ $1 -gt 1000 ]]; do\n        # Subtract 1000 from it\n\
    \        let 1=$1-1000\n        # Increment the number of Ms\n        let num_m=num_m+1\n\
    \    done\n\n    # While the value of the input is greater than 100\n    while\
    \ [[ $1 -gt 100 ]]; do\n        # Subtract 100 from it\n        let 1=$1-100\n\
    \        # Increment the number of Cs\n        let num_c=num_c+1\n    done\n\n\
    \    # While the value of the input is greater than 10\n    while [[ $1 -gt 10\
    \ ]]; do\n        # Subtract 10 from it\n        let 1", "  local -i input=$1\n\
    \  # Edge case\n  if [[ $input -eq 0 ]]; then\n    echo \"\"\n    return 0\n \
    \ fi\n  if [[ $input -le 0 || $input -gt 1000 ]]; then\n    echo \"Number must\
    \ be between 1 and 1000\"\n    return 1\n  fi\n  local -i num\n  local out_str=\"\
    \"\n  local i=0\n  local -a roman_arr=(\"m\" \"cm\" \"d\" \"cd\" \"c\" \"xc\"\
    \ \"l\" \"xl\" \"x\" \"ix\" \"v\" \"iv\" \"i\")\n  local -a dec_arr=(1000 900\
    \ 500 400 100 90 50 40 10 9 5 4 1)\n  while [[ $input -gt 0 ]]; do\n    num=$((\
    \ input / dec_arr[i] ))\n    input=$(( input % dec_arr[i] ))\n    while [[ $num\
    \ -gt 0 ]]; do\n      out_str=\"${out_str}${roman_arr[i]}\"\n      num=$(( num\
    \ - 1 ))\n    done\n    i=$(( i + 1 ))\n  done\n  echo \"$out_str\"", "  num=$1\n\
    \  roman_num=\"\"\n  while [ $num -gt 0 ]; do\n    if [ $num -ge 1000 ]; then\n\
    \      roman_num+=\"m\"\n      num=$((num-1000))\n    elif [ $num -ge 900 ]; then\n\
    \      roman_num+=\"cm\"\n      num=$((num-900))\n    elif [ $num -ge 500 ]; then\n\
    \      roman_num+=\"d\"\n      num=$((num-500))\n    elif [ $num -ge 400 ]; then\n\
    \      roman_num+=\"cd\"\n      num=$((num-400))\n    elif [ $num -ge 100 ]; then\n\
    \      roman_num+=\"c\"\n      num=$((num-100))\n    elif [ $num -ge 90 ]; then\n\
    \      roman_num+=\"xc\"\n      num=$((num-90))\n    elif [ $num -ge 50 ]; then\n\
    \      roman_num+=\"l\"\n      num=$((num-50))\n    elif [ $num -ge 40 ]; then\n\
    \      roman_num+=\"xl\"\n      num=$((num-40))\n    elif [ $num -ge 10 ]; then\n\
    \      roman_num+=\"x\"\n      num=$((num-10))\n    elif [ $num -ge 9 ]; then\n\
    \      roman_num+=\"ix\"\n      num=$((num-9))\n    elif [ $num -ge 5 ]; then\n\
    \      roman_num+=\"v\"\n      num=$((num-5))\n    elif [ $num -ge 4 ]; then\n\
    \      roman_num+=\"iv\"\n      num=$((num-4))\n    elif [ $num -ge 1 ]; then\n\
    \      roman_num+=\"i\"\n      num=$((num-1))\n    fi\n  done\n  echo $roman_num",
  "\tlocal num=\"$1\"\n\tlocal str=\n\twhile [ $num -gt 0 ]; do\n\t\tif [ $num -ge\
    \ 1000 ]; then\n\t\t\tstr=\"m${str}\"\n\t\t\tnum=$((num - 1000))\n\t\telif [ $num\
    \ -ge 900 ]; then\n\t\t\tstr=\"cm${str}\"\n\t\t\tnum=$((num - 900))\n\t\telif\
    \ [ $num -ge 500 ]; then\n\t\t\tstr=\"d${str}\"\n\t\t\tnum=$((num - 500))\n\t\t\
    elif [ $num -ge 400 ]; then\n\t\t\tstr=\"cd${str}\"\n\t\t\tnum=$((num - 400))\n\
    \t\telif [ $num -ge 100 ]; then\n\t\t\tstr=\"c${str}\"\n\t\t\tnum=$((num - 100))\n\
    \t\telif [ $num -ge 90 ]; then\n\t\t\tstr=\"xc${str}\"\n\t\t\tnum=$((num - 90))\n\
    \t\telif [ $num -ge 50 ]; then\n\t\t\tstr=\"l${str}\"\n\t\t\tnum=$((num - 50))\n\
    \t\telif [ $num -ge 40 ]; then\n\t\t\tstr=\"xl${str}\"\n\t\t\tnum=$((num - 40))\n\
    \t\telif [ $num -ge 10 ]; then\n\t\t\tstr=\"x${str}\"\n\t\t\tnum=$((num - 10))\n\
    \t\telif [ $num -ge 9 ]; then\n\t\t\tstr=\"ix${str}\"\n\t\t\tnum=$((num - 9))\n\
    \t\telif [ $num -ge 5 ]; then\n\t\t\tstr=\"v${str}\"\n\t\t\tnum=$((num - 5))\n\
    \t\telif [ $num -ge 4 ]; then\n\t\t\tstr=\"iv${str}\"\n\t\t\tnum=$((num - 4))\n\
    \t\telif [ $num -ge 1 ]; then\n\t\t\tstr=\"i${str}\"\n\t\t\tnum=$((num - 1))\n\
    \t\tfi\n\tdone\n\techo \"$str\"", "    local I=$(int_to_roman \"$1\")\n\n    #\
    \ Bash string manipulation FTW\n    I=${I//VIIII/ix}\n    I=${I//IIII/iv}\n  \
    \  I=${I//LXXXX/xc}\n    I=${I//XXXX/xl}\n    I=${I//DCCCC/cm}\n    I=${I//CCCC/cd}\n\
    \n    echo $I", "  # Check that the integer is within range\n  int_is_positive\
    \ \"$1\" || return 1\n  (( $1 > 1000 )) && return 1\n\n  # Determine the position\
    \ of the digits,\n  #  e.g. 426 is 400 + 20 + 6\n  declare -a digits\n  digits=()\n\
    \  local n\n  n=$1\n  local power\n  power=1\n  for (( ; n>0; n/=10 )); do\n \
    \   local digit\n    digit=$(( n % 10 ))\n    (( digit*power ))\n    digits+=(\"\
    $digit$power\")\n    (( power*=10 ))\n  done\n\n  # Convert them to strings\n\
    \  local strings\n  strings=\"\"\n  local digit\n  for digit in \"${digits[@]}\"\
    ; do\n    local string\n    string=$(mini_digit_to_string \"$digit\")\n    strings=\"\
    $string$strings\"\n  done\n\n  # The result\n  echo \"$strings\"", "  local num=\"\
    $1\"\n  local i=\"\"\n  local roman=\"\"\n  local ones=\"\"\n  local tens=\"\"\
    \n  local hundreds=\"\"\n  local thousands=\"\"\n  local mini_roman_map\n  mini_roman_map=(\"\
    \" \"i\" \"ii\" \"iii\" \"iv\" \"v\" \"vi\" \"vii\" \"viii\" \"ix\")\n  if [[\
    \ $num -gt 0 && $num -le 3999 ]]; then\n    thousands=$((num / 1000))\n    hundreds=$((num\
    \ % 1000 / 100))\n    tens=$((num % 100 / 10))\n    ones=$((num % 10))\n    for\
    \ ((i=0; i<thousands; i++)); do\n      roman+=\"m\"\n    done\n    roman+=\"${mini_roman_map[$hundreds]}\"\
    \n    roman+=\"${mini_roman_map[$tens]}\"\n    roman+=\"${mini_roman_map[$ones]}\"\
    \n    echo \"$roman\"\n  else\n    echo \"Error: $num outside valid range\"\n\
    \  fi", "    local INT=$1\n    if [ $INT -le 0 ]; then\n        echo -n \"Integer\
    \ too small.\"\n        return 1\n    fi\n    if [ $INT -gt 1000 ]; then\n   \
    \     echo -n \"Integer too large.\"\n        return 1\n    fi\n    if [ $INT\
    \ -gt 100 ]; then\n        printf \"c\"\n        INT=$(( $INT - 100 ))\n    fi\n\
    \    while [ $INT -gt 90 ]; do\n        printf \"x\"\n        INT=$(( $INT - 10\
    \ ))\n    done\n    if [ $INT -gt 50 ]; then\n        printf \"l\"\n        INT=$((\
    \ $INT - 50 ))\n    fi\n    while [ $INT -gt 40 ]; do\n        printf \"x\"\n\
    \        INT=$(( $INT - 10 ))\n    done\n    if [ $INT -gt 10 ]; then\n      \
    \  printf \"x\"\n        INT=$(( $INT - 10 ))\n    fi\n    while [ $INT -gt 9\
    \ ]; do\n        printf \"i\"\n        INT=$(( $INT - 1 ))\n    done\n    if [\
    \ $INT -gt 5 ]; then\n        printf \"v\"\n        INT=$(( $INT - 5 ))\n    fi\n\
    \    while [ $INT -gt 4 ]; do\n        printf \"i\"\n        INT=$(( $INT - 1\
    \ ))\n    done\n    if [ $INT -gt 0 ]; then\n        printf \"i\"\n    fi", " \
    \ local int=\"$1\"\n  local roman=\"\"\n  if [ \"$int\" -lt 1 ] || [ \"$int\"\
    \ -gt 1000 ]; then\n    return 1\n  fi\n  while [ \"$int\" -ge 100 ]; do\n   \
    \ roman+=\"c\"\n    int=$((int-100))\n  done\n  while [ \"$int\" -ge 90 ]; do\n\
    \    roman+=\"xc\"\n    int=$((int-90))\n  done\n  while [ \"$int\" -ge 50 ];\
    \ do\n    roman+=\"l\"\n    int=$((int-50))\n  done\n  while [ \"$int\" -ge 40\
    \ ]; do\n    roman+=\"xl\"\n    int=$((int-40))\n  done\n  while [ \"$int\" -ge\
    \ 10 ]; do\n    roman+=\"x\"\n    int=$((int-10))\n  done\n  while [ \"$int\"\
    \ -ge 9 ]; do\n    roman+=\"ix\"\n    int=$((int-9))\n  done\n  while [ \"$int\"\
    \ -ge 5 ]; do\n    roman+=\"v\"\n    int=$((int-5))\n  done\n  while [ \"$int\"\
    \ -ge 4 ]; do\n    roman+=\"iv\"\n    int=$((int-4))\n  done\n  while [ \"$int\"\
    \ -ge 1 ]; do\n    roman+=\"i\"\n    int=$((int-1))\n  done\n  echo \"$roman\"",
  "    local num=\"$1\"\n    local output=\"\"\n    while [ \"$num\" -gt 0 ]; do\n\
    \        local unit=\"$(($num % 10))\"\n        local unit_out=$(case \"$unit\"\
    \ in\n        1) echo \"i\";;\n        2) echo \"ii\";;\n        3) echo \"iii\"\
    ;;\n        4) echo \"iv\";;\n        5) echo \"v\";;\n        6) echo \"vi\"\
    ;;\n        7) echo \"vii\";;\n        8) echo \"viii\";;\n        9) echo \"\
    ix\";;\n        esac)\n        output=\"$unit_out$output\"\n        num=\"$(($num\
    \ / 10))\"\n    done\n    echo \"$output\"", "    # TODO\n    echo $1", "  if\
    \ [ -z \"$1\" ]; then\n    echo \"first argument missing\" >&2\n    exit 1\n \
    \ fi\n  local N=$1\n  local thousands=`expr $N / 1000`\n  local remainder=`expr\
    \ $N % 1000`\n  local hundreds=`expr $remainder / 100`\n  remainder=`expr $remainder\
    \ % 100`\n  local tens=`expr $remainder / 10`\n  remainder=`expr $remainder %\
    \ 10`\n  local ones=$remainder\n  local romans=`int_to_mini_roman_ones $ones`\n\
    \  local romans=\"$romans$(int_to_mini_roman_tens $tens)\"\n  local romans=\"\
    $romans$(int_to_mini_roman_hundreds $hundreds)\"\n  local romans=\"$romans$(int_to_mini_roman_thousands\
    \ $thousands)\"\n  echo $romans", "    local input=$1\n    local roman_numeral=\n\
    \    while [ $input -gt 0 ]; do\n        # 1, 2, and 3 represented by adding I's\
    \ to the string\n        if [ $input -lt 4 ]; then\n            roman_numeral=$roman_numeral$(yes\
    \ I | head -n $input | tr -d \"\\n\")\n            input=0\n        # 4 represented\
    \ by IV\n        elif [ $input -eq 4 ]; then\n            roman_numeral=$roman_numeral\"\
    IV\"\n            input=0\n        # 5 represented by V\n        elif [ $input\
    \ -eq 5 ]; then\n            roman_numeral=$roman_numeral\"V\"\n            input=0\n\
    \        # 6, 7, and 8 represented by V plus I's\n        elif [ $input -lt 9\
    \ ]; then\n            roman_numeral=$roman_numeral\"V\"\n            input=$((\
    \ $input - 5 ))\n        # 9 represented by IX\n        elif [ $input -eq 9 ];\
    \ then\n            roman_numeral=$roman_numeral\"IX\"\n            input=0\n\
    \        # Tens place in similar pattern\n        elif [ $input -lt 40 ]; then\n\
    \            roman_numeral=$roman_numeral$(yes X | head -n $(( $input / 10 ))\
    \ | tr -d \"\\n\")\n            input=$(( $input % 10 ))\n        elif [ $input\
    \ -lt 50 ]; then\n            roman_numeral=$roman_numeral\"XL\"\n           \
    \ input=$(( $input - 40 ))\n        elif [ $input -lt 90 ]; then\n           \
    \ roman_numeral=$roman_numeral\"L\"\n            input=$(( $input - 50 ))\n  \
    \      elif [ $input -lt 100 ]; then\n            roman_numeral=$roman_numeral\"\
    XC\"\n            input=$(( $input - 90 ))\n        # Hundreds place in similar\
    \ pattern\n        elif [ $input -lt 400 ]; then\n            roman_numeral=$roman_numeral$(yes\
    \ C | head -n $(( $input / 100 )) | tr -d \"\\n\")\n            input=$(( $input\
    \ % 100 ))\n        elif [ $input -lt 500 ]; then\n            r", "    local\
    \ -i num=\"$1\"\n    local -i digit\n    local roman_digit\n    local -a roman_digits\n\
    \    local -i idx=0\n    local result\n\n    if (( num > 1000 )); then\n     \
    \   printf '%s\\n' \"Error: int_to_mini_roman: input must be <= 1000\" >&2\n \
    \       return 1\n    fi\n\n    # Build the roman numeral representation by constructing\
    \ it digit by digit\n    # in reverse order\n    # E.g., the roman numeral for\
    \ 342 is built by starting with the \"ones\"\n    # digit, 2, which is \"ii\"\
    , then moving on to the \"tens\" digit, 4, which is\n    # \"iv\", then finally\
    \ moving on to the \"hundreds\" digit, 3, which is \"ccc\".\n    # Putting all\
    \ these together gives us the final answer, \"cccivii\"\n    while (( num > 0\
    \ )); do\n        digit=\"$(( num % 10 ))\"\n        roman_digit=\n        case\
    \ \"$digit\" in\n            1) roman_digit='i' ;;\n            2) roman_digit='ii'\
    \ ;;\n            3) roman_digit='iii' ;;\n            4) roman_digit='iv' ;;\n\
    \            5) roman_digit='v' ;;\n            6) roman_digit='vi' ;;\n     \
    \       7) roman_digit='vii' ;;\n            8) roman_digit='viii' ;;\n      \
    \      9) roman_digit='ix' ;;\n            *) roman_digit= ;;\n        esac\n\
    \        roman_digits[idx]=\"$roman_digit\"\n        (( idx++ ))\n        (( num\
    \ /= 10 ))\n    done\n\n    # Reverse the array, and join its elements together\
    \ with the empty string\n    # as the delimiter\n    # We can omit the count argument\
    \ to the array slice operator, `${array[@]}`,\n    # since we're just reversing\
    \ the entire array\n    result=\"$(reverse_array \"${roman_digits[@]}\")\"\n \
    \   printf '%s\\n' \"$result\"", "    if [ $1 -lt 1 ] || [ $1 -gt 1000 ]; then\n\
    \        echo 'miniroman: number must be between 1 and 1000'\n        return 1\n\
    \    fi\n    local __resultvar=$2\n    local  __val=$1\n    local  __res=''\n\
    \    local  __tmp=''\n    local  __place=1\n    local  __roman=(\n        [1]='i'\
    \ [2]='ii' [3]='iii' [4]='iv' [5]='v' [6]='vi' [7]='vii' [8]='viii'\n        [9]='ix'\
    \ [10]='x' [20]='xx' [30]='xxx' [40]='xl' [50]='l' [60]='lx'\n        [70]='lxx'\
    \ [80]='lxxx' [90]='xc' [100]='c' [200]='cc' [300]='ccc'\n        [400]='cd' [500]='d'\
    \ [600]='dc' [700]='dcc' [800]='dccc' [900]='cm'\n        [1000]='m'\n    )\n\
    \    # Use a string to get the units, tens, hundreds, and thousands places\n \
    \   __tmp=$(printf \"%04d\" $__val)\n    for (( i=0; i<4; i++ )); do\n       \
    \ # Get the value at the current place\n        __val=$(echo $__tmp | cut -c$((4-i))-\
    \ | cut -c1)\n        if [ $__val -ne 0 ]; then\n            # Add the roman numeral\
    \ for the value at this place\n            __res=\"${__res}${__roman[$((__val*__place))]}\"\
    \n        fi\n        # Move to the next place\n        __place=$((__place*10))\n\
    \    done\n    # Return the result in lowercase\n    eval $__resultvar=\"$(echo\
    \ \"$__res\" | tr '[:upper:]' '[:lower:]')\"", "    declare -A romans=( [1]=\"\
    i\" [5]=\"v\" [10]=\"x\" [50]=\"l\" [100]=\"c\" [500]=\"d\" [1000]=\"m\" )\n \
    \   declare -A nums=( [1]=0 [10]=0 [100]=0 [1000]=0 )\n    local output=\"\"\n\
    \n    # break out the thousands, hundreds, tens, and ones\n    local num=$1\n\
    \    while [ \"$num\" -ne 0 ]; do\n        local last_digit=$(( num % 10 ))\n\
    \        local last_two_digits=$(( num % 100 ))\n        local last_three_digits=$((\
    \ num % 1000 ))\n        local last_four_digits=$(( num % 10000 ))\n        local\
    \ last_five_digits=$(( num % 100000 ))\n        local last_six_digits=$(( num\
    \ % 1000000 ))\n        local last_seven_digits=$(( num % 10000000 ))\n      \
    \  local last_eight_digits=$(( num % 100000000 ))\n        local last_nine_digits=$((\
    \ num % 1000000000 ))\n        if [ \"$last_nine_digits\" -ge 100000 ]; then\n\
    \            nums[1000]=$(( last_nine_digits / 100000 ))\n            num=$((\
    \ num - ( last_nine_digits / 100000 ) * 100000 ))\n        elif [ \"$last_eight_digits\"\
    \ -ge 10000 ]; then\n            nums[1000]=$(( last_eight_digits / 10000 ))\n\
    \            num=$(( num - ( last_eight_digits / 10000 ) * 10000 ))\n        elif\
    \ [ \"$last_seven_digits\" -ge 1000 ]; then\n            nums[1000]=$(( last_seven_digits\
    \ / 1000 ))\n            num=$(( num - ( last_seven_digits / 1000 ) * 1000 ))\n\
    \        elif [ \"$last_six_digits\" -ge 100 ]; then\n            nums[100]=$((\
    \ last_six_digits / 100 ))\n            num=$(( num - ( last_six_digits / 100\
    \ ) * 100 ))\n        elif [ \"$last_five_digits\" -ge 10 ]; then\n          \
    \  nums[100]=$(( last_five_digits / 10", '    echo "a"', "    local num=${1}\n\
    \    local roman=\"\"\n    local i=0\n    local j=0\n    local len=0\n    local\
    \ converted_num=\"\"\n    local dict=( \"m\" \"cm\" \"d\" \"cd\" \"c\" \"xc\"\
    \ \"l\" \"xl\" \"x\" \"ix\" \"v\" \"iv\" \"i\" )\n    local int_values=( 1000\
    \ 900 500 400 100 90 50 40 10 9 5 4 1 )\n    local len_dict=${#dict[@]}\n    local\
    \ len_int_values=${#int_values[@]}\n    local int_value=0\n    local divisible=0\n\
    \    local remainder=0\n    local len_curr_roman=0\n    # Iterate through the\
    \ list of dict and int_values\n    while [ $i -lt $len_dict ]; do\n        int_value=${int_values[$i]}\n\
    \        # If current int_value can be divided by the given num, then add\n  \
    \      # the corresponding roman value to the converted_num\n        divisible=$((\
    \ num % int_value ))\n        if [ $divisible -eq 0 ]; then\n            remainder=$((\
    \ num / int_value ))\n            for (( j=0; j<remainder; j++ )); do\n      \
    \          converted_num+=\"${dict[$i]}\"\n            done\n            break\n\
    \        fi\n        # If current int_value cannot be divided by the given num,\
    \ then\n        # increment i\n        i=$(( i + 1 ))\n    done\n    # If i is\
    \ equal to the length of the dict list, that means the given\n    # num cannot\
    \ be divided by anything in the int_values list, so the\n    # remainder must\
    \ be 1.\n    if [ $i -eq $len_dict ]; then\n        converted_num+=\"${dict[$len_dict-1]}\"\
    \n    fi\n    # Now, check how many characters the converted_num has\n    len_curr_roman=${#converted_num}\n\
    \    # Depending on the length of the converted_num, delete the roman\n    # characters\
    \ appropriately to get the mini_roman numeral\n    while [ $len_curr_roman -gt\
    \ 1 ]; do\n        # Obtain", "    local val=$1\n    local a=(1 5 10 50 100 500\
    \ 1000)\n    local r=(i v x l c d m)\n    local ret\n    local prev=0\n    local\
    \ i\n    local x\n    for ((i = 0; i < ${#a[@]}; i++)); do\n        x=${a[$i]}\n\
    \        if [[ $val -eq $x ]]; then\n            ret+=${r[$i]}\n            break\n\
    \        elif [[ $val -gt $x ]]; then\n            prev=$x\n        elif [[ $val\
    \ -lt $x ]]; then\n            if [[ $val -gt $((x - prev)) ]]; then\n       \
    \         ret+=${r[$((i - 1))]}${r[$i]}\n                break\n            else\n\
    \                ret+=${r[$((i - 1))]}\n                val=$((val - prev))\n\
    \                prev=0\n                i=$((i - 2))\n            fi\n      \
    \  fi\n    done\n    echo $ret", "  local num=$1\n  local result=\"\"\n  local\
    \ key\n  for key in I V X L C D M; do\n    result+=$(int_to_mini_roman_one $num\
    \ $key)\n    ((num = num % $(roman_unit_num $key)))\n  done\n  echo $result",
  "  declare -i -r NUMBER=$1\n  declare -r ONES=$(($NUMBER % 10))\n  declare -r TENS=$(($NUMBER\
    \ % 100 / 10))\n  declare -r HUNDREDS=$(($NUMBER % 1000 / 100))\n  declare -r\
    \ THOUSANDS=$(($NUMBER / 1000))\n  declare -i -r FIVE=5\n  declare -a -r ROMAN_NUMERALS=(\n\
    \    [1]=\"i\" [2]=\"ii\" [3]=\"iii\" [4]=\"iv\" [5]=\"v\" [6]=\"vi\" [7]=\"vii\"\
    \ [8]=\"viii\" [9]=\"ix\"\n    [10]=\"x\" [20]=\"xx\" [30]=\"xxx\" [40]=\"xl\"\
    \ [50]=\"l\" [60]=\"lx\" [70]=\"lxx\" [80]=\"lxxx\" [90]=\"xc\"\n    [100]=\"\
    c\" [200]=\"cc\" [300]=\"ccc\" [400]=\"cd\" [500]=\"d\" [600]=\"dc\" [700]=\"\
    dcc\" [800]=\"dccc\" [900]=\"cm\"\n    [1000]=\"m\" [2000]=\"mm\" [3000]=\"mmm\"\
    \ [4000]=\"mmmm\" [5000]=\"mmmmm\"\n  )\n  declare -a -r ROMAN_FIVES=(\n    [1]=\"\
    v\" [10]=\"l\" [100]=\"d\" [1000]=\"m\"\n  )\n  declare -i -r ROMAN_ONES_FIVE=$(($FIVE\
    \ * $ONES))\n  declare -i -r ROMAN_TENS_FIVE=$(($FIVE * $TENS))\n  declare -i\
    \ -r ROMAN_HUNDREDS_FIVE=$(($FIVE * $HUNDREDS))\n  declare -i -r ROMAN_THOUSANDS_FIVE=$(($FIVE\
    \ * $THOUSANDS))\n  declare -a -r ROMAN_NUMBERS=(\n    [1]=$ONES [10]=$TENS [100]=$HUNDREDS\
    \ [1000]=$THOUSANDS", "    local num=$1\n    if [ $num -lt 1 -o $num -gt 1000\
    \ ]; then\n        echo \"Number out of range! ($num)\"\n        return 1\n  \
    \  fi\n    local num_in_roman=\"\"\n    local digits\n    # 0-9 (1-10)\n    digits[0]=\"\
    i\"\n    digits[1]=\"ii\"\n    digits[2]=\"iii\"\n    digits[3]=\"iv\"\n    digits[4]=\"\
    v\"\n    digits[5]=\"vi\"\n    digits[6]=\"vii\"\n    digits[7]=\"viii\"\n   \
    \ digits[8]=\"ix\"\n    digits[9]=\"x\"\n    # 10-90 (10-100)\n    digits[10]=\"\
    x\"\n    digits[20]=\"xx\"\n    digits[30]=\"xxx\"\n    digits[40]=\"xl\"\n  \
    \  digits[50]=\"l\"\n    digits[60]=\"lx\"\n    digits[70]=\"lxx\"\n    digits[80]=\"\
    lxxx\"\n    digits[90]=\"xc\"\n    # 100-900 (100-1000)\n    digits[100]=\"c\"\
    \n    digits[200]=\"cc\"\n    digits[300]=\"ccc\"\n    digits[400]=\"cd\"\n  \
    \  digits[500]=\"d\"\n    digits[600]=\"dc\"\n    digits[700]=\"dcc\"\n    digits[800]=\"\
    dccc\"\n    digits[900]=\"cm\"\n    # 1000 (1000)\n    digits[1000]=\"m\"\n  \
    \  # Let's get the triplets\n    local thousands=$((num / 1000))\n    local hundreds=$(((num\
    \ % 1000) / 100))\n    local tens=$(((num % 100) / 10))\n    local ones=$((num\
    \ % 10))\n    # Now we can compose the final string\n    if [ $thousands -ne 0\
    \ ]; then\n        num_in_roman=\"${digits[1000]}\"\n    fi\n    if [ $hundreds\
    \ -ne 0 ]; then\n        num_in_roman=\"${num_in_roman}${digits[$((hundreds *\
    \ 100))]}\"\n    fi\n    if [ $", "  local decimal=$1;\n  local roman=();\n  if\
    \ [[ $decimal -gt 1000 ]]; then\n    echo \"Invalid number\";\n    return;\n \
    \ fi;\n  while [[ $decimal -gt 0 ]]; do\n    if [[ $decimal -ge 1000 ]]; then\n\
    \      roman+=\"m\";\n      decimal=$((decimal - 1000));\n    elif [[ $decimal\
    \ -ge 900 ]]; then\n      roman+=\"cm\";\n      decimal=$((decimal - 900));\n\
    \    elif [[ $decimal -ge 500 ]]; then\n      roman+=\"d\";\n      decimal=$((decimal\
    \ - 500));\n    elif [[ $decimal -ge 400 ]]; then\n      roman+=\"cd\";\n    \
    \  decimal=$((decimal - 400));\n    elif [[ $decimal -ge 100 ]]; then\n      roman+=\"\
    c\";\n      decimal=$((decimal - 100));\n    elif [[ $decimal -ge 90 ]]; then\n\
    \      roman+=\"xc\";\n      decimal=$((decimal - 90));\n    elif [[ $decimal\
    \ -ge 50 ]]; then\n      roman+=\"l\";\n      decimal=$((decimal - 50));\n   \
    \ elif [[ $decimal -ge 40 ]]; then\n      roman+=\"xl\";\n      decimal=$((decimal\
    \ - 40));\n    elif [[ $decimal -ge 10 ]]; then\n      roman+=\"x\";\n      decimal=$((decimal\
    \ - 10));\n    elif [[ $decimal -ge 9 ]]; then\n      roman+=\"ix\";\n      decimal=$((decimal\
    \ - 9));\n    elif [[ $decimal -ge 5 ]]; then\n      roman+=\"v\";\n      decimal=$((decimal\
    \ - 5));\n    elif [[ $decimal -ge 4 ]]; then\n      roman+=\"iv\";\n      decimal=$((decimal\
    \ - 4));\n    elif [[ $decimal -ge 1 ]]; then\n      roman+=\"i\";\n      decimal=$((decimal\
    \ - 1));\n    fi;\n  done;\n  echo \"${roman}\";", "    if [[ ! \"$1\" =~ ^[0-9]+$\
    \ ]]; then\n        echo \"error: argument is not an integer\"\n        return\
    \ 1\n    fi\n    if (( $1 < 1 || $1 > 1000 )); then\n        echo \"error: argument\
    \ is not in the range 1 <= num <= 1000\"\n        return 1\n    fi\n    local\
    \ deci_to_mini_roman=(\n        [0]=\"\" [1]=\"i\" [2]=\"ii\" [3]=\"iii\" [4]=\"\
    iv\" [5]=\"v\" [6]=\"vi\" [7]=\"vii\"\n        [8]=\"viii\" [9]=\"ix\" [10]=\"\
    x\" [20]=\"xx\" [30]=\"xxx\" [40]=\"xl\" [50]=\"l\"\n        [60]=\"lx\" [70]=\"\
    lxx\" [80]=\"lxxx\" [90]=\"xc\" [100]=\"c\" [200]=\"cc\"\n        [300]=\"ccc\"\
    \ [400]=\"cd\" [500]=\"d\" [600]=\"dc\" [700]=\"dcc\" [800]=\"dccc\"\n       \
    \ [900]=\"cm\" [1000]=\"m\"\n    )\n    local num=\"$1\"\n    local len=$((${#num}\
    \ - 1))\n    local i=0\n    local roman=\"\"\n    while (( i <= len )); do\n \
    \       local char=\"${num:i:1}\"\n        local decimal=$((10 ** $len))\n   \
    \     if [[ \"${deci_to_mini_roman[$decimal]}\" == \"\" ]]; then\n           \
    \ echo \"error: unable to parse argument\"\n            return 1\n        fi\n\
    \        roman+=\"${deci_to_mini_roman[$decimal]}\"\n        len=$((len - 1))\n\
    \        i=$((i + 1))\n    done\n    echo \"$roman\"", "  local rn=\n  local roman=(M\
    \ D C L X V I)\n  local values=(1000 500 100 50 10 5 1)\n  local integer=$1\n\
    \  local roman_numeral_parts=()\n  local roman_numeral_len=${#roman[@]}\n  local\
    \ i\n  for ((i=0; i<roman_numeral_len; i++)); do\n    if [[ $integer -eq 0 ]];\
    \ then\n      break\n    fi\n    rn=\"$(($integer / ${values[$i]}))\"\n    if\
    \ [[ $rn -gt 0 ]]; then\n      integer=$((integer - $rn * ${values[$i]}))\n  \
    \    roman_numeral_parts+=(\"$(char_repeat \"${roman[$i]}\" \"$rn\")\")\n    fi\n\
    \  done\n  roman_numeral_parts=(\"${roman_numeral_parts[@]}\" \"\")\n  printf\
    \ '%s' \"${roman_numeral_parts[@]}\"", "    local -i int_number=${1}\n\n    for\
    \ ((n=1; n <= int_number; n++)); do\n        roman_number+=\"I\"\n    done\n\n\
    \    roman_number=${roman_number//VIIII/IX}\n    roman_number=${roman_number//IIII/IV}\n\
    \    roman_number=${roman_number//XXXX/XL}\n    roman_number=${roman_number//LXXXX/XC}\n\
    \    roman_number=${roman_number//CCCC/CD}\n    roman_number=${roman_number//DCCCC/CM}\n\
    \n    echo ${roman_number,,}", "    local num=$1\n    if (( num > 1000 )); then\n\
    \        echo \"Input must be between 1 and 1000.\"\n        return 1\n    fi\n\
    \    local romans=(\n        \"\" \"i\" \"ii\" \"iii\" \"iv\" \"v\" \"vi\" \"\
    vii\" \"viii\" \"ix\"\n        \"\" \"x\" \"xx\" \"xxx\" \"xl\" \"l\" \"lx\" \"\
    lxx\" \"lxxx\" \"xc\"\n        \"\" \"c\" \"cc\" \"ccc\" \"cd\" \"d\" \"dc\" \"\
    dcc\" \"dccc\" \"cm\"\n        \"\" \"m\" \"mm\" \"mmm\" \"mv\" \"v\" \"vm\" \"\
    vmm\" \"vmmm\" \"mx\"\n    )\n    echo ${romans[num]}", "\tlocal int=\"$1\"\n\t\
    # For each possible value of $int, find the corresponding Roman\n\t# numeral.\
    \ Lowercase these numerals and append them to the final\n\t# output string.\n\t\
    local out=\"\"\n\tif [[ $int -ge 100 ]]; then\n\t\tlocal C=\"$(( int / 100 ))\"\
    \n\t\tif [[ $C -eq 9 ]]; then\n\t\t\tout+=\"cm\"\n\t\t\tint=$(( int - 900 ))\n\
    \t\telif [[ $C -ge 5 ]]; then\n\t\t\tout+=\"d\"\n\t\t\tint=$(( int - 500 ))\n\t\
    \t\tC=$(( C - 5 ))\n\t\t\tfor ((i=0; i<C; i++)); do\n\t\t\t\tout+=\"c\"\n\t\t\t\
    \tint=$(( int - 100 ))\n\t\t\tdone\n\t\telif [[ $C -eq 4 ]]; then\n\t\t\tout+=\"\
    cd\"\n\t\t\tint=$(( int - 400 ))\n\t\telse\n\t\t\tfor ((i=0; i<C; i++)); do\n\t\
    \t\t\tout+=\"c\"\n\t\t\t\tint=$(( int - 100 ))\n\t\t\tdone\n\t\tfi\n\tfi\n\tif\
    \ [[ $int -ge 10 ]]; then\n\t\tlocal X=\"$(( int / 10 ))\"\n\t\tif [[ $X -eq 9\
    \ ]]; then\n\t\t\tout+=\"xc\"\n\t\t\tint=$(( int - 90 ))\n\t\telif [[ $X -ge 5\
    \ ]]; then\n\t\t\tout+=\"l\"\n\t\t\tint=$(( int - 50 ))\n\t\t\tX=$(( X - 5 ))\n\
    \t\t\tfor ((i=0; i<X; i++)); do\n\t\t\t\tout+=\"x\"\n\t\t\t\tint=$(( int - 10\
    \ ))\n\t\t\tdone\n\t\telif [[ $X -eq 4 ]]; then\n\t\t\tout+=\"xl\"\n\t\t\tint=$((\
    \ int - 40 ))\n\t\telse\n\t\t\tfor ((i=0; i<X; i++)); do\n\t\t\t\tout+=\"x\"\n\
    \t\t\t\tint=$((", "  local inp=$1;\n  local c=1;\n  local m;\n  local rom;\n \
    \ while (( inp > 0 )); do\n    m=$(( inp % 10 )); # 0-9\n    rom=$(int_to_mini_roman_single\
    \ \"$m\" \"$c\")$rom;\n    inp=$(( inp / 10 ));\n    (( c++ ));\n  done;\n  echo\
    \ \"$rom\";", "  local input=\"$1\"\n  local mappings=(\n    [0]=''\n    [1]='i'\n\
    \    [2]='ii'\n    [3]='iii'\n    [4]='iv'\n    [5]='v'\n    [6]='vi'\n    [7]='vii'\n\
    \    [8]='viii'\n    [9]='ix'\n    [10]='x'\n    [20]='xx'\n    [30]='xxx'\n \
    \   [40]='xl'\n    [50]='l'\n    [60]='lx'\n    [70]='lxx'\n    [80]='lxxx'\n\
    \    [90]='xc'\n    [100]='c'\n    [200]='cc'\n    [300]='ccc'\n    [400]='cd'\n\
    \    [500]='d'\n    [600]='dc'\n    [700]='dcc'\n    [800]='dccc'\n    [900]='cm'\n\
    \    [1000]='m'\n  )\n  local num_digits=\"${#input}\"\n  local mappings_indices=(\n\
    \    '0'\n    '1'\n    '2'\n    '3'\n    '4'\n    '5'\n    '6'\n    '7'\n    '8'\n\
    \    '9'\n    '10'\n    '20'\n    '30'\n    '40'\n    '50'\n    '60'\n    '70'\n\
    \    '80'\n    '90'\n    '100'\n    '200'\n    '300'\n    '400'\n    '500'\n \
    \   '600'\n    '700'\n    '800'\n    '900'\n    '1000'\n  )\n  for (( i = 0; i\
    \ < ${#mappings_indices[@]}; i++ )); do\n    if [[ ${mappings_indices[$i]} ==\
    \ $(echo \"$input\" | cut -c 1-$num_digits) ]]; then\n      local result=\"${mappings[$i]}\"\
    \n      break\n    fi\n  done\n  if [[ $", "  # TODO: Implement int_to_mini_roman()\n\
    \  #\n  # ${#1} returns the length of the string.\n  # ${1:N:L} returns a substring\
    \ of length L starting at position N.\n  # \"${a[@]}\" returns an array as a string\n\
    \  # \"${a[@]:N:L}\" returns a subarray as a string.\n  # ${#a[@]} returns the\
    \ length of the array\n  # ${!a[@]} returns the indices of the array\n  # ${!a[*]}\
    \ returns the indices of the array as a string\n  # \"${a[*]}\" returns the array\
    \ as a string\n  # \"${a[*]:N:L}\" returns a slice of the array as a string\n\
    \  # $(( )) is arithmetic expression evaluation\n  # $((x = y)) is assignment\n\
    \  # $((x == y)) is equality check\n  # $((x != y)) is inequality check\n  # $((x\
    \ <= y)) is less than or equal to check\n  # $((x >= y)) is greater than or equal\
    \ to check\n  # $((x < y)) is less than check\n  # $((x > y)) is greater than\
    \ check\n  # $((x | y)) is bitwise OR\n  # $((x & y)) is bitwise AND\n  # $((x\
    \ && y)) is boolean AND\n  # $((x || y)) is boolean OR\n  # $((x + y)) is addition\n\
    \  # $((x - y)) is subtraction\n  # $((x * y)) is multiplication\n  # $((x / y))\
    \ is division\n  # $((x % y)) is modulo\n  # $((x ^ y)) is bitwise XOR\n  # $((x\
    \ << y)) is left shift\n  # $((x >> y)) is right shift\n  # $((x++)) is postfix\
    \ increment\n  # $((++x)) is prefix increment\n  # $((x--)) is postfix decrement\n\
    \  # $((--x)) is prefix decrement\n  # $((x += y)) is addition assignment\n  #\
    \ $((x -= y)) is subtraction assignment\n  # $((x *= y)) is multiplication assignment\n",
  "  local num=$1\n  local result=''\n  local -A arab_roman=(\n    ['1']='i'\n   \
    \ ['2']='ii'\n    ['3']='iii'\n    ['4']='iv'\n    ['5']='v'\n    ['6']='vi'\n\
    \    ['7']='vii'\n    ['8']='viii'\n    ['9']='ix'\n    ['10']='x'\n    ['20']='xx'\n\
    \    ['30']='xxx'\n    ['40']='xl'\n    ['50']='l'\n    ['60']='lx'\n    ['70']='lxx'\n\
    \    ['80']='lxxx'\n    ['90']='xc'\n    ['100']='c'\n    ['200']='cc'\n    ['300']='ccc'\n\
    \    ['400']='cd'\n    ['500']='d'\n    ['600']='dc'\n    ['700']='dcc'\n    ['800']='dccc'\n\
    \    ['900']='cm'\n    ['1000']='m'\n  )\n  local -A int_digits=(\n    ['0']='0'\n\
    \    ['1']='1'\n    ['2']='2'\n    ['3']='3'\n    ['4']='4'\n    ['5']='5'\n \
    \   ['6']='6'\n    ['7']='7'\n    ['8']='8'\n    ['9']='9'\n  )\n  local -A int_powers=(\n\
    \    ['1']='0'\n    ['2']='1'\n    ['3']='2'\n    ['4']='3'\n  )\n  if (( num\
    \ <= 1000 )) && (( num > 0 )); then\n    local b10_num=$(int_to_base \"$num\"\
    \ 10)\n    local len=${#b10_num}\n    for (( i=1; i<=len; i++ )); do\n      local\
    \ power=${int_powers[$i]}\n      local digits=${int_digits[${b10_num:$(( -i )):1}]}\n\
    \      local arab_digit=$(( 10 ** power ))\n", "  local rom_num=\"\"\n  local\
    \ rom_m=\"\"\n  local rom_d=\"\"\n  local rom_c=\"\"\n  local rom_l=\"\"\n  local\
    \ rom_x=\"\"\n  local rom_v=\"\"\n  local rom_i=\"\"\n  local newnum=$1\n  local\
    \ ones=$(( $newnum % 10 ))\n  local tens=$(( $newnum % 100 / 10 ))\n  local hunds=$((\
    \ $newnum % 1000 / 100 ))\n  local thous=$(( $newnum / 1000 ))\n  if [ $thous\
    \ -gt 0 ]; then\n    for (( ii=0; ii<$thous; ii++ )); do\n      rom_m+=\"m\"\n\
    \    done\n  fi\n  if [ $hunds -gt 0 ]; then\n    if [ $hunds -eq 9 ]; then\n\
    \      rom_c=\"cm\"\n    elif [ $hunds -gt 5 ]; then\n      rom_c=\"d\"\n    \
    \  for (( ii=6; ii<=$hunds; ii++ )); do\n        rom_c+=\"c\"\n      done\n  \
    \  elif [ $hunds -eq 5 ]; then\n      rom_c=\"d\"\n    elif [ $hunds -eq 4 ];\
    \ then\n      rom_c=\"cd\"\n    else\n      for (( ii=0; ii<$hunds; ii++ )); do\n\
    \        rom_c+=\"c\"\n      done\n    fi\n  fi\n  if [ $tens -gt 0 ]; then\n\
    \    if [ $tens -eq 9 ]; then\n      rom_x=\"xc\"\n    elif [ $tens -gt 5 ]; then\n\
    \      rom_x=\"l\"\n      for (( ii=6; ii<=$tens; ii++ )); do\n        rom_x+=\"\
    x\"\n      done\n    elif [ $tens -eq 5 ]; then\n      rom_x=\"l\"\n    elif [\
    \ $tens -eq 4 ]; then\n      rom_x=\"xl\"\n    else\n      for (( ii=0; ii<$tens;\
    \ ii++ )); do\n        rom_x+=\"x\"\n      done\n    fi\n  fi\n  if [ $ones -gt\
    \ 0 ]; then\n    if", "\t# From Wikipedia,\n\t# 'The rules for the secular usage\
    \ of Roman numerals differed from those\n\t# used for the religious (i.e. canonical)\
    \ writings. When used in secular\n\t# manuscripts, number in the range 1 to 9999\
    \ (1 to 3888 in the official\n\t# canon) was generally written in lower case Roman\
    \ numerals in the right\n\t# order and line, and no subtraction principle was\
    \ used.\n\t# http://en.wikipedia.org/wiki/Roman_numerals\n\t\n\t# From StackOverflow,\n\
    \t# \"We can use an associative array to hold our conversion values:\n\t# declare\
    \ -A romans=( [M]=1000 [CM]=900 [D]=500 [CD]=400 [C]=100 [XC]=90 [L]=50 [XL]=40\
    \ [X]=10 [IX]=9 [V]=5 [IV]=4 [I]=1 )\n\t# We can then loop through the array and\
    \ subtract values until our input\n\t# value is less than 0. Something like this:\n\
    \t# roman=''\n\t# for value in \"${!romans[@]}\"; do\n\t#     [ $input -lt ${romans[$value]}\
    \ ] && continue\n\t#     roman+=$value\n\t#     input=$(( $input - ${romans[$value]}\
    \ ))\n\t# done\n\t# echo $roman\"\n\t# http://stackoverflow.com/questions/7033720/bash-script-to-convert-decimal-to-roman-numerals\n\
    \t\n\t# $1 is a number\n\tlocal -i num=\"$1\"\n\tlocal -i remainder\n\tlocal romans\n\
    \tdeclare -A romans=( [M]=1000 [CM]=900 [D]=500 [CD]=400 [C]=100 [XC]=90 [L]=50\
    \ [XL]=40 [X]=10 [IX]=9 [V]=5 [IV]=4 [I]=1 )\n\tlocal roman=''\n\t\n\tfor value\
    \ in \"${!romans[@]}\"; do\n\t\t# Work out how many times the input is divisible\
    \ by the current value\n\t\t# in the array.\n\t\tlocal -i mult=\"$(( $num / ${romans[$",
  "    # $1 is an integer\n    num_to_roman() {\n        local -r I=i\n        local\
    \ -r V=v\n        local -r X=x\n        local -r L=l\n        local -r C=c\n \
    \       local -r D=d\n        local -r M=m\n        local -r num=$1\n        local\
    \ -r result=\n        local -r remainder=\n\n        while [[ $num -gt 0 ]]; do\n\
    \            if [[ $num -gt 1000 ]]; then\n                local -r result=${result}$M\n\
    \                local -r num=$(( num - 1000 ))\n            elif [[ $num -gt\
    \ 900 ]]; then\n                local -r result=${result}cm\n                local\
    \ -r num=$(( num - 900 ))\n            elif [[ $num -gt 500 ]]; then\n       \
    \         local -r result=${result}d\n                local -r num=$(( num - 500\
    \ ))\n            elif [[ $num -gt 400 ]]; then\n                local -r result=${result}cd\n\
    \                local -r num=$(( num - 400 ))\n            elif [[ $num -gt 100\
    \ ]]; then\n                local -r result=${result}c\n                local\
    \ -r num=$(( num - 100 ))\n            elif [[ $num -gt 90 ]]; then\n        \
    \        local -r result=${result}xc\n                local -r num=$(( num - 90\
    \ ))\n            elif [[ $num -gt 50 ]]; then\n                local -r result=${result}l\n\
    \                local -r num=$(( num - 50 ))\n            elif [[ $num -gt 40\
    \ ]]; then\n                local -r result=${result}xl\n                local\
    \ -r num=$(( num - 40 ))\n            elif [[ $num -gt 10 ]]; then\n         \
    \       local -r result=${result}x\n                local -r num=$(( num - 10\
    \ ))\n            elif [[ $num -gt 9 ]]; then\n                local -r result=${result}ix\n\
    \                local -r num=$(( num - 9 ))\n            elif [[ $num -gt 5 ]];\
    \ then\n                local -r result=${result}v\n                local -r num=$((\
    \ num - 5 ))\n            elif [[ $num -", "  local -i value=$1\n  local -i temp=$value\n\
    \  local mini_roman=\"\"\n  local -a roman=( [1]=\"i\" [5]=\"v\" [10]=\"x\" [50]=\"\
    l\" [100]=\"c\" [500]=\"d\" [1000]=\"m\" )\n  local -a digit=( [0]=1 [1]=10 [2]=100\
    \ [3]=1000 )\n  local -i base=10\n  local -i counter=0\n  if (( value == 0 ))\
    \ || (( value > 1000 )); then\n    return\n  fi\n  while (( temp > 0 )); do\n\
    \    local -i remainder=$(( temp % base ))\n    local -i remainder_place=$(( remainder\
    \ / digit[counter] ))\n    local -i remainder_2digit=$(( remainder % digit[counter]\
    \ ))\n    if (( remainder_place == 4 )); then\n      mini_roman=\"${roman[digit[counter]]}${roman[digit[counter]*5]}${mini_roman}\"\
    \n    elif (( remainder_place == 9 )); then\n      mini_roman=\"${roman[digit[counter]]}${roman[digit[counter]*10]}${mini_roman}\"\
    \n    else\n      if (( remainder_place >= 5 )); then\n        mini_roman=\"${roman[digit[counter]*5]}${mini_roman}\"\
    \n        remainder_place=$(( remainder_place - 5 ))\n      fi\n      for (( i=0;\
    \ i<remainder_place; i++ )); do\n        mini_roman=\"${roman[digit[counter]]}${mini_roman}\"\
    \n      done\n    fi\n    temp=$(( temp / base ))\n    (( counter++ ))\n  done\n\
    \  echo \"${mini_roman}\"", "    local num=$1\n    local result=\"\"\n    local\
    \ -a arabic=(1000 900 500 400 100 90 50 40 10 9 5 4 1)\n    local -a roman=(m\
    \ cm d cd c xc l xl x ix v iv i)\n    #\n    for (( i=0; i<${#arabic[@]}; i++\
    \ )); do\n        while (( num >= arabic[i] )); do\n            num=$(( num -\
    \ arabic[i] ))\n            result+=\"${roman[i]}\"\n        done\n    done\n\
    \    echo \"${result}\"", "  local num=$1\n  [ \"$num\" -gt 1000 ] && return 1\n\
    \  local roman_str=\n\n  # assign roman numerals and their corresponding int values\n\
    \  local roman_int=([I]=1 [V]=5 [X]=10 [L]=50 [C]=100 [D]=500 [M]=1000)\n  # assign\
    \ values for numerals that can be further subtracted\n  local roman_sub=([I]=[V]\
    \ [X]=[L] [C]=[D] [M]=[M])\n  local i=0\n  while [ \"$num\" -gt 0 ]; do\n    #\
    \ check if the current numeral can be further subtracted\n    [ \"$((num/roman_int[${roman_sub[${roman_str:$i:1}]}]))\"\
    \ -eq \"9\" ] &&\n      roman_str+=${roman_sub[${roman_str:$i:1}]}${roman_str:$i:1}\
    \ &&\n      num=$((num-9*roman_int[${roman_sub[${roman_str:$i:1}]}])) &&\n   \
    \   continue\n    # check if the current numeral can be added\n    [ \"$((num/roman_int[${roman_str:$i:1}]))\"\
    \ -ge \"5\" ] &&\n      roman_str+=${roman_sub[${roman_str:$i:1}]} &&\n      num=$((num-5*roman_int[${roman_str:$i:1}]))\
    \ &&\n      continue\n    # check if the current numeral can be further subtracted\n\
    \    [ \"$((num/roman_int[${roman_str:$i:1}]))\" -eq \"4\" ] &&\n      roman_str+=${roman_str:$i:1}${roman_sub[${roman_str:$i:1}]}\
    \ &&\n      num=$((num-4*roman_int[${roman_str:$i:1}])) &&\n      continue\n \
    \   # append the current numeral to the string and move on to the next one\n \
    \   [ \"$num\" -ge \"1\" ] &&\n      roman_str+=${roman_str:$i:1", "    local\
    \ letters=\"ivxlcdm\"\n    local num=\"$1\"\n    local roman=\"\"\n    for ((exp=0;\
    \ num; exp++, num/=10)); do\n        local i=$(((num%10)*2))\n        local letter=\"\
    ${letters:$i:1}\"\n        local next_letter=\"${letters:$((i+2)):1}\"\n     \
    \   local prev_letter=\"${letters:$((i-2)):1}\"\n        local prepend=\"\"\n\
    \        if [ \"${letter}\" == \"${next_letter}\" ]; then\n            letter=\"\
    ${letter}${next_letter}\"\n            num=$((num+1))\n        elif [ \"${letter}\"\
    \ == \"${prev_letter}\" ]; then\n            letter=\"${letter}${prev_letter}\"\
    \n            num=$((num-1))\n        fi\n        while [ $((num%10)) -gt 3 ];\
    \ do\n            prepend=\"${letter}\"\n            num=$((num-5))\n        done\n\
    \        roman=\"${prepend}${roman}\"\n    done\n    echo \"${roman}\"", "\tif\
    \ [[ ! $1 =~ ^[0-9]+$ ]]; then\n\t\techo \"error: argument must be a positive\
    \ integer\" >&2\n\t\treturn 1\n\tfi\n\t# return 0 immediately, as a special case\n\
    \tif [[ $1 -eq 0 ]]; then\n\t\techo \"n\"\n\t\treturn 0\n\tfi\n\t# negative integers\
    \ aren't allowed, so make sure we have a positive int\n\t# by removing any leading\
    \ \"-\" character\n\tint=${1#-}\n\t# build up result\n\tresult=\"\"\n\t# 1000,\
    \ 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n\tvalues=(M CM D CD C XC L XL\
    \ X IX V IV I)\n\tnumerals=(1000 900 500 400 100 90 50 40 10 9 5 4 1)\n\t# while\
    \ there are integers remaining, find the largest numeral that fits\n\t# into the\
    \ number and subtract it\n\twhile [[ $int -gt 0 ]]; do\n\t\tfor (( i=0; i<${#numerals[@]};\
    \ i++ )); do\n\t\t\tif [[ $int -ge ${numerals[$i]} ]]; then\n\t\t\t\tresult+=\"\
    ${values[$i]}\"\n\t\t\t\tint=$((int - ${numerals[$i]}))\n\t\t\t\tbreak\n\t\t\t\
    fi\n\t\tdone\n\tdone\n\t# return the lowercase version of the result\n\techo \"\
    $result\" | tr 'A-Z' 'a-z'", '  echo "not yet implemented"', "  printf \"%s\"\
    \ \"$(\n    printf '%s' \"$(\n      printf \"%s\" \"$1\" |\n      fold -w1 |\n\
    \      while read n; do\n        printf '%s' \"$(int_to_roman \"$n\")\"\n    \
    \  done\n    )\" |\n    sed -r 's/DCCCC/CM/g; s/CCCC/CD/g; s/LXXXX/XC/g; s/XXXX/XL/g;\
    \ s/VIIII/IX/g; s/IIII/IV/g'\n  )\"", "    # Determine the range of numbers for\
    \ the for-loop below\n    if [ \"$1\" -le \"10\" ]; then\n        end_num=10\n\
    \    elif [ \"$1\" -le \"100\" ]; then\n        end_num=100\n    elif [ \"$1\"\
    \ -le \"1000\" ]; then\n        end_num=1000\n    else\n        end_num=1000\n\
    \    fi\n\n    # Loop through the range of numbers and find the \"closest\"\n\
    \    # roman numeral to append to the output string\n    output=\"\"\n    for\
    \ num in 1 5 10 50 100 500 1000; do\n        if [ \"$1\" -lt \"$num\" ]; then\n\
    \            continue\n        elif [ \"$1\" -lt \"$(( $num * 5 ))\" ]; then\n\
    \            if [ \"$1\" -lt \"$(( $num * 4 ))\" ]; then\n                let\
    \ \"remainder = $1 % $num\"\n                let \"quotient = $1 / $num\"\n  \
    \              remainder_str=$(int_to_mini_roman \"$remainder\")\n           \
    \     case \"$num\" in\n                    1)\n                        output=\"\
    ${output}$(replicate \"$quotient\" \"i\")${remainder_str}\"\n                \
    \        ;;\n                    5)\n                        output=\"${output}$(replicate\
    \ \"$quotient\" \"v\")${remainder_str}\"\n                        ;;\n       \
    \             10)\n                        output=\"${output}$(replicate \"$quotient\"\
    \ \"x\")${remainder_str}\"\n                        ;;\n                    50)\n\
    \                        output=\"${output}$(replicate \"$quotient\" \"l\")${remainder_str}\"\
    \n                        ;;\n                    100)\n                     \
    \   output=\"${output}$(replicate \"$quotient\" \"c\")${remainder_str}\"\n   \
    \                     ;;\n                    500)\n                        output=\"\
    ${output}$(replicate \"$quotient\" \"d\")${remainder_str}\"\n                \
    \        ;;\n                    1000)\n                        output=\"${output}$(replicate\
    \ \"$quotient\" \"m\")${remainder_str}\"\n                        ;;\n       \
    \         esac\n            else\n                let \"remainder = $1 % $num\"\
    \n                let \"quotient = $", "  # a map of numbers to their roman numeral\
    \ equivalents\n  mini_roman_number_map=(\n  \"m\" \"cm\" \"d\" \"cd\" \"c\" \"\
    xc\" \"l\" \"xl\" \"x\" \"ix\" \"v\" \"iv\" \"i\"\n  )\n  # a map of numbers to\
    \ their powers of ten\n  mini_roman_tens_map=(\n  \"1000\" \"900\" \"500\" \"\
    400\" \"100\" \"90\" \"50\" \"40\" \"10\" \"9\" \"5\" \"4\" \"1\"\n  )\n  number=\"\
    $1\"\n  mini_roman_numeral=\"\"\n  # loop through the tens map, and apply roman\
    \ numerals\n  for i in $(seq 0 $((${#mini_roman_tens_map[@]} - 1))); do\n    while\
    \ [[ \"$number\" -ge \"${mini_roman_tens_map[$i]}\" ]]; do\n      mini_roman_numeral+=\"\
    ${mini_roman_number_map[$i]}\"\n      number=$((number - ${mini_roman_tens_map[$i]}))\n\
    \    done\n  done\n  echo \"$mini_roman_numeral\"", "    local s result\n\n  \
    \  if [ $1 -lt 1 -o $1 -gt 1000 ]; then\n        echo \"Invalid input: $1\"\n\
    \        return 1\n    fi\n\n    result=\"\"\n    for (( n=$1; n>0; n=n%10 ));\
    \ do\n        case $n in\n            [0-3]) s=$(printf \"%.sI\" $(seq 1 $n))\
    \ ;;\n            4) s=\"IV\" ;;\n            5) s=\"V\" ;;\n            [6-8])\
    \ s=\"V$(printf \"%.sI\" $(seq 1 $((n - 5))))\" ;;\n            9) s=\"IX\" ;;\n\
    \            [1-3][0-9]) s=\"X$(int_to_mini_roman $((n % 10)))\" ;;\n        \
    \    [4-8][0-9]) s=\"L$(int_to_mini_roman $((n % 10)))\" ;;\n            9[0-9])\
    \ s=\"C$(int_to_mini_roman $((n % 10)))\" ;;\n            [1-3][0-9][0-9]) s=\"\
    C$(int_to_mini_roman $((n % 100)))\" ;;\n            [4-8][0-9][0-9]) s=\"D$(int_to_mini_roman\
    \ $((n % 100)))\" ;;\n            9[0-9][0-9]) s=\"M$(int_to_mini_roman $((n %\
    \ 100)))\" ;;\n            [1-3][0-9][0-9][0-9]) s=\"M$(int_to_mini_roman $((n\
    \ % 1000)))\" ;;\n        esac\n        result=\"$result$s\"\n    done\n\n   \
    \ echo \"$result\"", "  local -i n=$1\n  local -i q\n  local -i r\n  local -i\
    \ p\n  local -i i\n  local -i j\n  local -i k\n  local -i l\n  local -i m\n  local\
    \ result=\"\"\n  if (( n < 1 || n > 1000 )); then\n    return 1\n  fi\n  local\
    \ -a roman=([0]=\"\" [1]=\"i\" [2]=\"ii\" [3]=\"iii\" [4]=\"iv\" [5]=\"v\" [6]=\"\
    vi\" [7]=\"vii\" [8]=\"viii\" [9]=\"ix\")\n  local -a roman10=([0]=\"\" [1]=\"\
    x\" [2]=\"xx\" [3]=\"xxx\" [4]=\"xl\" [5]=\"l\" [6]=\"lx\" [7]=\"lxx\" [8]=\"\
    lxxx\" [9]=\"xc\")\n  local -a roman100=([0]=\"\" [1]=\"c\" [2]=\"cc\" [3]=\"\
    ccc\" [4]=\"cd\" [5]=\"d\" [6]=\"dc\" [7]=\"dcc\" [8]=\"dccc\" [9]=\"cm\")\n \
    \ local -a roman1000=([0]=\"\" [1]=\"m\" [2]=\"mm\" [3]=\"mmm\" [4]=\"mmmm\" [5]=\"\
    mmmmm\" [6]=\"mmmmmm\" [7]=\"mmmmmmm\" [8]=\"mmmmmmmm\" [9]=\"mmmmmmmmm\")\n \
    \ (( q = n / 1000 ))\n  (( r = n % 1000 ))\n  (( p = r / 100 ))\n  (( r = r %\
    \ 100 ))\n  (( i = r / 10 ))\n  (( r = r % 10 ))\n  (( j = n / 100 ))\n  (( k\
    \ = n / 10 ))\n  (( l = n % 10 ))\n  (( m = n / 1000 ))\n  result=\"${roman1000[m]}${roman100[p]}${roman10[i]}${roman[r]}\"\
    \n  echo \"${result}\"", "    local -a roman=(\n        [1]=\"i\"\n        [2]=\"\
    ii\"\n        [3]=\"iii\"\n        [4]=\"iv\"\n        [5]=\"v\"\n        [6]=\"\
    vi\"\n        [7]=\"vii\"\n        [8]=\"viii\"\n        [9]=\"ix\"\n        [10]=\"\
    x\"\n        [20]=\"xx\"\n        [30]=\"xxx\"\n        [40]=\"xl\"\n        [50]=\"\
    l\"\n        [60]=\"lx\"\n        [70]=\"lxx\"\n        [80]=\"lxxx\"\n      \
    \  [90]=\"xc\"\n        [100]=\"c\"\n        [200]=\"cc\"\n        [300]=\"ccc\"\
    \n        [400]=\"cd\"\n        [500]=\"d\"\n        [600]=\"dc\"\n        [700]=\"\
    dcc\"\n        [800]=\"dccc\"\n        [900]=\"cm\"\n        [1000]=\"m\"\n  \
    \  )\n    local -a arabic=(\n        [1]=1\n        [2]=2\n        [3]=3\n   \
    \     [4]=4\n        [5]=5\n        [6]=6\n        [7]=7\n        [8]=8\n    \
    \    [9]=9\n        [10]=10\n        [20]=20\n        [30]=30\n        [40]=40\n\
    \        [50]=50\n        [60]=60\n        [70]=70\n        [80]=80\n        [90]=90\n\
    \        [100]=100\n        [200]=200\n        [300]=300\n        [400]=400\n\
    \        [500]=500\n        [600]=600\n        [700]=700\n        [800]=800\n\
    \        [900]=900\n        [1000]=1000\n    )\n    local -a nums=()\n    local\
    \ -i e\n    local -i i\n    local -i d\n    local -i m\n    local -i l\n    local\
    \ -i c\n    local -i n\n    local r\n    local n\n    local temp\n\n    if [[\
    \ $1 =~ ^-?[0-9]+$ ]]; then\n        n=$", "  if ! [[ \"$1\" =~ ^[0-9]+$ ]]; then\n\
    \    echo \"[ERROR] in int_to_mini_roman() - invalid input: \" $1\n    exit 1\n\
    \  fi\n  if (($1 < 1)) || (($1 > 1000)); then\n    echo \"[ERROR] in int_to_mini_roman()\
    \ - input out of range: \" $1\n    exit 1\n  fi\n  local ROMAN_CHARS=('i' 'v'\
    \ 'x' 'l' 'c' 'd' 'm')\n  local NUM_DIGITS=0\n  local i\n  # This is how many\
    \ digits are in the input\n  while (($1 > 0)); do\n    NUM_DIGITS=$((NUM_DIGITS\
    \ + 1))\n    ((i = $1 % 10))\n    # This avoids getting the 1's place, etc.\n\
    \    (($1 = $1 / 10))\n  done\n  local ROMAN_NUMS=()\n  local ROMAN_STRING=''\n\
    \  local ROMAN_INDEX=0\n  local ROMAN_INDEX_OFFSET=0\n  for ((;$NUM_DIGITS > 0;NUM_DIGITS--));\
    \ do\n    ((ROMAN_INDEX = $NUM_DIGITS * 2 - 2))\n    # This is the index we want\
    \ to start with\n    ((ROMAN_INDEX_OFFSET = $ROMAN_INDEX - $NUM_DIGITS + 1))\n\
    \    # This is the offset we need to get the correct romans\n    if ((i < 4));\
    \ then\n      # Handle 1 - 3\n      while ((i > 0)); do\n        # printf \"%s\"\
    \ \"${ROMAN_CHARS[$ROMAN_INDEX]}\"\n        ROMAN_STRING+=\"${ROMAN_CHARS[$ROMAN_INDEX]}\"\
    \n        ((i = $i - 1))\n      done\n    elif ((i == 4)); then\n      # Handle\
    \ 4\n      # printf \"%s\" \"${ROMAN_CHARS[$ROMAN_INDEX_OFFSET]}\"\n      # printf\
    \ \"%s\" \"${ROMAN_CHARS[$ROMAN_INDEX]}\"\n      ROMAN_", "    local num=${1:-0}\n\
    \    local mini_roman=\"ixcm\"\n    local quotient=0\n    local remainder=0\n\
    \    local i=0\n    local ret=0\n    local str=\n    local tmp=\n\n    if [ ${num}\
    \ -lt 1 ] || [ ${num} -gt 1000 ]; then\n        return 1\n    fi\n\n    for i\
    \ in {3..0}\n    do\n        (( quotient = num / 10 ** i ))\n        (( remainder\
    \ = num % 10 ** i ))\n        (( num = remainder ))\n        [ ${quotient} -gt\
    \ 0 ] && {\n            [ ${quotient} -lt 4 ] && {\n                ret=0\n  \
    \              while [ ${ret} -lt ${quotient} ]; do\n                    str+=\"\
    ${mini_roman:${i}:1}\"\n                    (( ret++ ))\n                done\n\
    \            } || {\n                str+=\"${mini_roman:${i}:1}${mini_roman:$((\
    \ i + 1 )):1}\"\n            }\n        }\n    done\n\n    echo \"${str}\"", " \
    \ local result=\"\"\n  local -i num=$1\n\n  # The basic symbols:\n  local -A symbols=(\n\
    \    [1000]=\"m\"\n    [900]=\"cm\"\n    [500]=\"d\"\n    [400]=\"cd\"\n    [100]=\"\
    c\"\n    [90]=\"xc\"\n    [50]=\"l\"\n    [40]=\"xl\"\n    [10]=\"x\"\n    [9]=\"\
    ix\"\n    [5]=\"v\"\n    [4]=\"iv\"\n    [1]=\"i\"\n  )\n\n  # Now assemble the\
    \ result in reverse order:\n  for key in \"${!symbols[@]}\"; do\n    while ((\
    \ num >= key )); do\n      result=\"${symbols[$key]}$result\"\n      (( num -=\
    \ key ))\n    done\n  done\n\n  echo \"$result\"", "    local int=$1\n    local\
    \ t\n    local h\n    local d\n    local c\n    local l\n    local x\n    local\
    \ v\n    local i\n    local result\n    t=$((int / 1000))\n    h=$(((int % 1000)\
    \ / 100))\n    d=$(((int % 100) / 10))\n    c=$((int % 10))\n    l=$((d % 5))\n\
    \    x=$((c % 5))\n    v=$((l % 2))\n    i=$((x % 2))\n    result=$(\n       \
    \ printf %s \"$(\n            printf %s \"$(\n                printf %0.sM%s \"\
    $t\"\n            )\" \"$(\n                printf %0.sC%s \"$h\"\n          \
    \  )\"\n        )\" \"$(\n            printf %s \"$(\n                printf %0.sX%s\
    \ \"$d\"\n            )\" \"$(\n                printf %0.sI%s \"$c\"\n      \
    \      )\"\n        )\"\n    )\n    result=$(\n        printf %s \"$(\n      \
    \      printf %s \"$(\n                printf %0.sL%s \"$l\"\n            )\"\
    \ \"$(\n                printf %0.sV%s \"$v\"\n            )\"\n        )\" \"\
    $(\n            printf %s \"$(\n                printf %0.sX%s \"$x\"\n      \
    \      )\" \"$(\n                printf %0.sI%s \"$i\"\n            )\"\n    \
    \    )\"\n    )\n    printf %s \"$result\"", "  [[ $1 =~ ^[0-9]+$ ]] || return\
    \ 1\n  local num=$1\n  local i roman=''\n  local -A r=([1]=i [5]=v [10]=x [50]=l\
    \ [100]=c [500]=d [1000]=m)\n  local -A keys=([0]=1000 [1]=500 [2]=100 [3]=50\
    \ [4]=10 [5]=5 [6]=1)\n  for i in {0..6}; do\n    local key=${keys[$i]}\n    local\
    \ next_key=${keys[$((i+1))]}\n    local rep=$((num / key))\n    if (( rep < 4\
    \ )); then\n      for (( j=0; j<rep; j++ )); do\n        roman+=${r[$key]}\n \
    \     done\n    elif (( rep == 4 )); then\n      roman+=${r[$key]}${r[$next_key]}\n\
    \    elif (( rep == 5 )); then\n      roman+=${r[$next_key]}\n    elif (( rep\
    \ < 9 )); then\n      roman+=${r[$next_key]}\n      for (( j=0; j<(rep-5); j++\
    \ )); do\n        roman+=${r[$key]}\n      done\n    elif (( rep == 9 )); then\n\
    \      roman+=${r[$key]}${r[$((key*10))]}\n    fi\n    num=$((num % key))\n  done\n\
    \  echo \"$roman\"", "  local i r=\n  while (( i = \"$1\" )); do\n    case $i\
    \ in\n      1000) (( i -= 1000 )) r+='m';;\n      900)  (( i -= 900  )) r+='cm';;\n\
    \      500)  (( i -= 500  )) r+='d';;\n      400)  (( i -= 400  )) r+='cd';;\n\
    \      100)  (( i -= 100  )) r+='c';;\n      90)   (( i -= 90   )) r+='xc';;\n\
    \      50)   (( i -= 50   )) r+='l';;\n      40)   (( i -= 40   )) r+='xl';;\n\
    \      10)   (( i -= 10   )) r+='x';;\n      9)    (( i -= 9    )) r+='ix';;\n\
    \      5)    (( i -= 5    )) r+='v';;\n      4)    (( i -= 4    )) r+='iv';;\n\
    \      1)    (( i -= 1    )) r+='i';;\n    esac\n  done\n  printf '%s\\n' \"$r\"",
  "    local value=\"$1\" numeral=\"\"\n    local table=([0]=\"\" [1]=\"i\" [2]=\"\
    ii\" [3]=\"iii\" [4]=\"iv\" [5]=\"v\" [6]=\"vi\"\n                 [7]=\"vii\"\
    \ [8]=\"viii\" [9]=\"ix\" [10]=\"x\" [20]=\"xx\" [30]=\"xxx\"\n              \
    \   [40]=\"xl\" [50]=\"l\" [60]=\"lx\" [70]=\"lxx\" [80]=\"lxxx\" [90]=\"xc\"\n\
    \                 [100]=\"c\" [200]=\"cc\" [300]=\"ccc\" [400]=\"cd\" [500]=\"\
    d\"\n                 [600]=\"dc\" [700]=\"dcc\" [800]=\"dccc\" [900]=\"cm\" [1000]=\"\
    m\")\n    while ((value > 0)); do\n        numeral+=\"${table[value % 10 * 10\
    \ ** ${#value}]}\"\n        value=$((value / 10))\n    done\n    echo \"${numeral}\"",
  "\tlocal roman c_roman l_num\n\tlocal -i i\n\tlocal -i num=$1\n\tlocal -i temp\n\
    \tlocal -i rem\n\n\tif [ $num -lt 1 ] || [ $num -gt 1000 ]; then\n\t\techo \"\
    Int out of range, must be between 1 and 1000, inclusive\" >&2\n\t\treturn 1\n\t\
    fi\n\n\tc_roman=(\n\t\t[1]=\"i\" [2]=\"ii\" [3]=\"iii\" [4]=\"iv\" [5]=\"v\" [6]=\"\
    vi\" [7]=\"vii\" [8]=\"viii\" [9]=\"ix\"\n\t\t[10]=\"x\" [20]=\"xx\" [30]=\"xxx\"\
    \ [40]=\"xl\" [50]=\"l\" [60]=\"lx\" [70]=\"lxx\" [80]=\"lxxx\" [90]=\"xc\"\n\t\
    \t[100]=\"c\" [200]=\"cc\" [300]=\"ccc\" [400]=\"cd\" [500]=\"d\" [600]=\"dc\"\
    \ [700]=\"dcc\" [800]=\"dccc\" [900]=\"cm\"\n\t\t[1000]=\"m\"\n\t)\n\n\tfor ((i=0;\
    \ i<num/1000; i++)); do\n\t\troman+=\"m\"\n\tdone\n\tnum=$((num%1000))\n\n\tfor\
    \ ((i=100; i>=1; i/=10)); do\n\t\ttemp=$((num/i))\n\t\trem=$((num%i))\n\t\tnum=$rem\n\
    \t\tif [ $temp -gt 0 ]; then\n\t\t\tl_num=$((temp*i))\n\t\t\troman+=\"${c_roman[$l_num]}\"\
    \n\t\tfi\n\tdone\n\n\techo \"$roman\"", "  local integer=$1\n  if [[ \"$integer\"\
    \ -le 0 ]]; then\n    return\n  fi\n  local output=\"\"\n  if [[ \"$integer\"\
    \ -ge 1000 ]]; then\n    local m_factor=$(( integer / 1000 ))\n    local m_output=$(printf\
    \ \"%0.sM\" $(seq 1 $m_factor))\n    output+=\"$m_output\"\n    integer=$(( integer\
    \ % 1000 ))\n  fi\n  if [[ \"$integer\" -ge 900 ]]; then\n    output+=\"CM\"\n\
    \    integer=$(( integer % 900 ))\n  fi\n  if [[ \"$integer\" -ge 500 ]]; then\n\
    \    output+=\"D\"\n    integer=$(( integer % 500 ))\n  fi\n  if [[ \"$integer\"\
    \ -ge 400 ]]; then\n    output+=\"CD\"\n    integer=$(( integer % 400 ))\n  fi\n\
    \  if [[ \"$integer\" -ge 100 ]]; then\n    local c_factor=$(( integer / 100 ))\n\
    \    local c_output=$(printf \"%0.sC\" $(seq 1 $c_factor))\n    output+=\"$c_output\"\
    \n    integer=$(( integer % 100 ))\n  fi\n  if [[ \"$integer\" -ge 90 ]]; then\n\
    \    output+=\"XC\"\n    integer=$(( integer % 90 ))\n  fi\n  if [[ \"$integer\"\
    \ -ge 50 ]]; then\n    output+=\"L\"\n    integer=$(( integer % 50 ))\n  fi\n\
    \  if [[ \"$integer\" -ge 40 ]]; then\n    output+=\"XL\"\n    integer=$(( integer\
    \ % 40 ))\n  fi\n  if [[ \"$integer\" -ge 10 ]]; then\n    local x_factor=$((\
    \ integer / 10 ))\n    local x_output=$(printf \"%0.sX\" $(seq 1 $x_factor))\n\
    \    output+=\"$x_output\"\n    integer=$(( integer % 10 ))\n  fi\n  if [[ \"\
    $integer\" -ge 9 ]]; then\n    output+=\"IX\"\n    integer=$(( integer % 9 ))\n\
    \  fi\n  if [[ \"$integer\" -ge 5 ]]; then\n    output+=\"V\"\n    integer=$((\
    \ integer % 5 ))\n  fi\n  if [[ \"$integer\" -ge 4 ]]; then\n   ", "  # edge cases\n\
    \  [ \"$1\" -eq \"0\" ] && echo \"error: zero\" && return\n  [ \"$1\" -eq \"1001\"\
    \ ] && echo \"error: 1001\" && return\n  # main cases\n  [ \"$1\" -ge 1000 ] &&\
    \ echo -n M && int_to_mini_roman \"$(($1-1000))\" && return\n  [ \"$1\" -ge 900\
    \ ] && echo -n CM && int_to_mini_roman \"$(($1-900))\" && return\n  [ \"$1\" -ge\
    \ 500 ] && echo -n D && int_to_mini_roman \"$(($1-500))\" && return\n  [ \"$1\"\
    \ -ge 400 ] && echo -n CD && int_to_mini_roman \"$(($1-400))\" && return\n  [\
    \ \"$1\" -ge 100 ] && echo -n C && int_to_mini_roman \"$(($1-100))\" && return\n\
    \  [ \"$1\" -ge 90 ] && echo -n XC && int_to_mini_roman \"$(($1-90))\" && return\n\
    \  [ \"$1\" -ge 50 ] && echo -n L && int_to_mini_roman \"$(($1-50))\" && return\n\
    \  [ \"$1\" -ge 40 ] && echo -n XL && int_to_mini_roman \"$(($1-40))\" && return\n\
    \  [ \"$1\" -ge 10 ] && echo -n X && int_to_mini_roman \"$(($1-10))\" && return\n\
    \  [ \"$1\" -ge 9 ] && echo -n IX && int_to_mini_roman \"$(($1-9))\" && return\n\
    \  [ \"$1\" -ge 5 ] && echo -n V && int_to_mini_roman \"$(($1-5))\" && return\n\
    \  [ \"$1\" -ge 4 ] && echo -n IV && int_to_mini_roman \"$(($1-4))\" && return\n\
    \  [ \"$1\" -ge 1 ] && echo -n I && int_to_mini_roman \"$(($1-1))\" && return",
  "  case $1 in\n    0) echo \"\";;\n    1) echo \"i\";;\n    2) echo \"ii\";;\n \
    \   3) echo \"iii\";;\n    4) echo \"iv\";;\n    5) echo \"v\";;\n    6) echo\
    \ \"vi\";;\n    7) echo \"vii\";;\n    8) echo \"viii\";;\n    9) echo \"ix\"\
    ;;\n    10) echo \"x\";;\n    11) echo \"xi\";;\n    12) echo \"xii\";;\n    13)\
    \ echo \"xiii\";;\n    14) echo \"xiv\";;\n    15) echo \"xv\";;\n    16) echo\
    \ \"xvi\";;\n    17) echo \"xvii\";;\n    18) echo \"xviii\";;\n    19) echo \"\
    xix\";;\n    20) echo \"xx\";;\n    21) echo \"xxi\";;\n    22) echo \"xxii\"\
    ;;\n    23) echo \"xxiii\";;\n    24) echo \"xxiv\";;\n    25) echo \"xxv\";;\n\
    \    26) echo \"xxvi\";;\n    27) echo \"xxvii\";;\n    28) echo \"xxviii\";;\n\
    \    29) echo \"xxix\";;\n    30) echo \"xxx\";;\n    31) echo \"xxxi\";;\n  \
    \  32) echo \"xxxii\";;\n    33) echo \"xxxiii\";;\n    34) echo \"xxxiv\";;\n\
    \    35) echo \"xxxv\";;\n    36) echo \"xxxvi\";;\n    37) echo \"xxxvii\";;\n\
    \    38) echo \"xxxviii\";;\n    39) echo \"xxxix\";;\n    40) echo \"xl\";;\n\
    \    41) echo \"xli\";;\n    42) echo \"xlii\";;\n    43) echo \"xliii\";;\n \
    \   44) echo \"xliv\";;\n    45) echo \"xlv\";;\n    46) echo \"xlvi\";;\n   \
    \ 47) echo \"xlvii\";;\n    48) echo \"xlviii\";;\n    49) echo \"xlix\";;\n \
    \   50) echo \"l\"", "  [[ $1 -gt 1000 ]] && echo \"ERROR: Invalid input number.\"\
    \ && return 1\n  for i in \"M\" \"CM\" \"D\" \"CD\" \"C\" \"XC\" \"L\" \"XL\"\
    \ \"X\" \"IX\" \"V\" \"IV\" \"I\"; do\n    while [[ $1 -ge ${mini_roman_numerals[$i]}\
    \ ]]; do\n      roman+=$i\n      ((1))\n    done\n  done\n  echo $roman", "  \
    \  local num=$1\n    local ret=\"\"\n    while [ $num -gt 0 ]; do\n        local\
    \ let=\"$(printf '%d' $num)\"\n        if [ $let -gt 999 ]; then\n           \
    \ local times=$(( $let / 1000 ))\n            ret+=\"$(python -c \"print('m' *\
    \ $times)\")\"\n            num=$(( $num % 1000 ))\n        elif [ $let -gt 899\
    \ ]; then\n            ret+=\"cm\"\n            num=$(( $num % 900 ))\n      \
    \  elif [ $let -gt 499 ]; then\n            ret+=\"d\"\n            num=$(( $num\
    \ % 500 ))\n        elif [ $let -gt 399 ]; then\n            ret+=\"cd\"\n   \
    \         num=$(( $num % 400 ))\n        elif [ $let -gt 99 ]; then\n        \
    \    local times=$(( $let / 100 ))\n            ret+=\"$(python -c \"print('c'\
    \ * $times)\")\"\n            num=$(( $num % 100 ))\n        elif [ $let -gt 89\
    \ ]; then\n            ret+=\"xc\"\n            num=$(( $num % 90 ))\n       \
    \ elif [ $let -gt 49 ]; then\n            ret+=\"l\"\n            num=$(( $num\
    \ % 50 ))\n        elif [ $let -gt 39 ]; then\n            ret+=\"xl\"\n     \
    \       num=$(( $num % 40 ))\n        elif [ $let -gt 9 ]; then\n            local\
    \ times=$(( $let / 10 ))\n            ret+=\"$(python -c \"print('x' * $times)\"\
    )\"\n            num=$(( $num % 10 ))\n        elif [ $let -gt 8 ]; then\n   \
    \         ret+=\"ix\"\n            num=$(( $num % 9 ))\n        elif [ $let -gt\
    \ 4 ]; then\n            ret+=\"v\"\n            num=$(( $num % 5 ))\n       \
    \ elif [ $let -gt 3 ]; then\n            ret+=\"iv\"\n            num=$(( $num\
    \ % 4 ))\n        else\n            ret+=\"$(python -c \"print('i' * $num)\")\"\
    \n            num=0\n        fi\n    done\n    echo $ret", "  local -i num=\"\
    $1\"\n  local -i remainder\n  local result\n\n  local -a hash=(\n    1=i 5=v 10=x\
    \ 50=l 100=c 500=d 1000=m\n  )\n\n  while (( num )); do\n    result+=\"${hash[1]}\"\
    \n    (( num-- ))\n  done\n\n  echo \"$result\"", "  local num=\"$1\"\n  local\
    \ result=\"\"\n  local -A roman\n  # Should have been the other way around, but\
    \ \"i\" is a base in bash\n  roman=([I]=1 [V]=5 [X]=10 [L]=50 [C]=100 [D]=500\
    \ [M]=1000)\n  # Pre-compute the roman numerals\n  local roman_numerals=( M CM\
    \ D CD C XC L XL X IX V IV I )\n  local roman_numerals_value=( 900 500 400 100\
    \ 90 50 40 10 9 5 4 1 )\n  local i=0\n  for ((i=0; i<${#roman_numerals[@]}; i++));\
    \ do\n    local roman_numeral=\"${roman_numerals[$i]}\"\n    local roman_numeral_value=\"\
    ${roman_numerals_value[$i]}\"\n    while ((num >= roman_numeral_value)); do\n\
    \      num=$((num - roman_numeral_value))\n      result+=\"$roman_numeral\"\n\
    \    done\n  done\n  echo \"$result\"", "\tlocal num=$1\n\tlocal result=\"\"\n\
    \tlocal vals=(\" \" \"i\" \"ii\" \"iii\" \"iv\" \"v\" \"vi\" \"vii\" \"viii\"\
    \ \"ix\")\n\tlocal nums=(0 1 2 3 4 5 6 7 8 9)\n\tlocal i=0\n\tlocal ones=\"\"\n\
    \tlocal tens=\"\"\n\tlocal hundreds=\"\"\n\tlocal thousands=\"\"\n\tif [ \"$num\"\
    \ -ge 1 ] && [ \"$num\" -le 1000 ]; then\n\t\t(( thousands = num / 1000 ))\n\t\
    \tif [ \"$thousands\" -gt 0 ]; then\n\t\t\t(( num -= thousands * 1000 ))\n\t\t\
    fi\n\t\t(( hundreds = num / 100 ))\n\t\tif [ \"$hundreds\" -gt 0 ]; then\n\t\t\
    \t(( num -= hundreds * 100 ))\n\t\tfi\n\t\t(( tens = num / 10 ))\n\t\tif [ \"\
    $tens\" -gt 0 ]; then\n\t\t\t(( num -= tens * 10 ))\n\t\tfi\n\t\tones=\"$num\"\
    \n\t\tfor i in \"${!nums[@]}\"; do\n\t\t\tif [ \"$thousands\" -eq \"${nums[$i]}\"\
    \ ]; then\n\t\t\t\tthousands=\"${vals[$i]}\"\n\t\t\tfi\n\t\t\tif [ \"$hundreds\"\
    \ -eq \"${nums[$i]}\" ]; then\n\t\t\t\thundreds=\"${vals[$i]}\"\n\t\t\tfi\n\t\t\
    \tif [ \"$tens\" -eq \"${nums[$i]}\" ]; then\n\t\t\t\ttens=\"${vals[$i]}\"\n\t\
    \t\tfi\n\t\t\tif [ \"$ones\" -eq \"${nums[$i]}\" ]; then\n\t\t\t\tones=\"${vals[$i]}\"\
    \n\t\t\tfi\n\t\tdone\n\t\tresult=\"$thousands$hundreds$tens$ones\"\n\t\tresult=$(echo\
    \ \"$result\" | tr '[:upper:]' '[:lower:]')\n\tfi\n\techo \"$result\"", "    local\
    \ num=$1\n    local res=\"\"\n    if [ $num -lt 1 ] || [ $num -gt 1000 ]; then\n\
    \        echo \"Invalid input.\"\n        return 1\n    fi\n    if [ $num -ge\
    \ 1000 ]; then\n        res=\"m\"\n        num=$((num - 1000))\n    fi\n    if\
    \ [ $num -ge 900 ]; then\n        res=\"${res}cm\"\n        num=$((num - 900))\n\
    \    fi\n    if [ $num -ge 500 ]; then\n        res=\"${res}d\"\n        num=$((num\
    \ - 500))\n    fi\n    if [ $num -ge 400 ]; then\n        res=\"${res}cd\"\n \
    \       num=$((num - 400))\n    fi\n    while [ $num -ge 100 ]; do\n        res=\"\
    ${res}c\"\n        num=$((num - 100))\n    done\n    if [ $num -ge 90 ]; then\n\
    \        res=\"${res}xc\"\n        num=$((num - 90))\n    fi\n    if [ $num -ge\
    \ 50 ]; then\n        res=\"${res}l\"\n        num=$((num - 50))\n    fi\n   \
    \ if [ $num -ge 40 ]; then\n        res=\"${res}xl\"\n        num=$((num - 40))\n\
    \    fi\n    while [ $num -ge 10 ]; do\n        res=\"${res}x\"\n        num=$((num\
    \ - 10))\n    done\n    if [ $num -ge 9 ]; then\n        res=\"${res}ix\"\n  \
    \      num=$((num - 9))\n    fi\n    if [ $num -ge 5 ]; then\n        res=\"${res}v\"\
    \n        num=$((num - 5))\n    fi\n    if [ $num -ge 4 ]; then\n        res=\"\
    ${res}iv\"\n        num=$((num - 4))\n    fi\n    while [ $num -ge 1 ]; do\n \
    \       res=\"${res}i\"\n        num=$((num - 1))\n    done\n    echo \"$res\"",
  "    local num=\"$1\"\n    if [[ ! \"$num\" =~ ^[0-9]+$ ]]; then\n        echo \"\
    Error: Only integers are accepted\"\n        return 1\n    fi\n    local num_letters=\"\
    \"\n    local num_letters_rev=\"\"\n    local char=\"\"\n    local roman=\"\"\n\
    \    local max_ltr_cnt=4\n    local letters=\"ivxlcdm\"\n    local roman_num=\"\
    ${letters:$((${#letters}-1)):1}\"\n    local col=${#letters}\n    # process digits\
    \ in reverse order, going right to left\n    while [[ $num -gt 0 ]]; do\n    \
    \    (( col-- ))\n        local digit=\"$(($num % 10))\"\n        local digit_ltr_cnt=0\n\
    \        local digit_len=${#digit}\n        while [[ $digit_ltr_cnt -lt $max_ltr_cnt\
    \ ]]; do\n            local n=$(($digit % 10))\n            digit=\"$(($digit\
    \ / 10))\"\n            local ltr=\"${letters:$(($col * 2 + $digit_ltr_cnt)):1}\"\
    \n            (( digit_ltr_cnt++ ))\n            while [[ $n -gt 0 ]]; do\n  \
    \              num_letters+=\"$ltr\"\n                (( n-- ))\n            done\n\
    \        done\n        num=\"$(($num / 10))\"\n    done\n    # arrange letters\
    \ to form roman numeral string\n    local len=${#num_letters}\n    local i=0\n\
    \    while [[ $i -lt $len ]]; do\n        char=\"${num_letters:$i:1}\"\n     \
    \   local char_cnt=1\n        (( i++ ))\n        while [[ $i -lt $len ]]; do\n\
    \            if [[ \"${num_letters:$i:1}\" == \"$char\" ]]; then\n           \
    \     (( char_cnt++ ))\n                (( i++ ))\n            else\n        \
    \        break\n            fi\n        done\n        if [[ $char_cnt == 4 ]];\
    \ then\n            roman+=\"${char}${letters:$((${#letters}-2)):1}\"\n      \
    \  elif [[ $", "\tlocal input=\"$1\"\n\tlocal len=${#input}\n\tlocal result=\n\
    \tlocal i=0\n\tlocal left_digit\n\n\twhile [ $i -lt $len ]; do\n\t\t# get a digit\
    \ at the right-most\n\t\tdigit=${input:$len-1:1}\n\t\tlet i=i+1\n\t\t# get a digit\
    \ at the left-most\n\t\tif [ $i -eq $len ]; then\n\t\t\tleft_digit=$digit\n\t\t\
    else\n\t\t\tleft_digit=${input:$len-$i-1:1}\n\t\tfi\n\n\t\t# construct the digit\
    \ in roman numerals\n\t\tif [ $left_digit -lt 5 -a $left_digit -gt 0 ]; then\n\
    \t\t\tcase $digit in\n\t\t\t\t1) result=\"i$result\" ;;\n\t\t\t\t2) result=\"\
    ii$result\" ;;\n\t\t\t\t3) result=\"iii$result\" ;;\n\t\t\t\t4) result=\"iv$result\"\
    \ ;;\n\t\t\t\t5) result=\"v$result\" ;;\n\t\t\t\t6) result=\"vi$result\" ;;\n\t\
    \t\t\t7) result=\"vii$result\" ;;\n\t\t\t\t8) result=\"viii$result\" ;;\n\t\t\t\
    \t9) result=\"ix$result\" ;;\n\t\t\tesac\n\t\telif [ $left_digit -ge 5 ]; then\n\
    \t\t\tcase $digit in\n\t\t\t\t1) result=\"x$result\" ;;\n\t\t\t\t2) result=\"\
    xx$result\" ;;\n\t\t\t\t3) result=\"xxx$result\" ;;\n\t\t\t\t4) result=\"xl$result\"\
    \ ;;\n\t\t\t\t5) result=\"l$result\" ;;\n\t\t\t\t6) result=\"lx$result\" ;;\n\t\
    \t\t\t7) result=\"lxx$result\" ;;\n\t\t\t\t8) result=\"lxxx$result\" ;;\n\t\t\t\
    \t9) result=\"xc$result\" ;;\n\t\t\tesac\n\t\tfi\n\tdone\n\n\t# remove leading\
    \ zeros\n\techo \"$result\" | sed -e 's/^0//'\n", "    local -i num=\"$1\"\n \
    \   local -i x=\"$((num / 1000))\"  # Thousands\n    num=$((num % 1000))\n   \
    \ local -i c=\"$((num / 100))\"   # Hundreds\n    num=$((num % 100))\n    local\
    \ -i xc=\"$((num / 90))\"   # Nineties\n    num=$((num % 90))\n    local -i l=\"\
    $((num / 50))\"    # Fifties\n    num=$((num % 50))\n    local -i xl=\"$((num\
    \ / 40))\"   # Forties\n    num=$((num % 40))\n    local -i x=\"$((num / 10))\"\
    \    # Tens\n    num=$((num % 10))\n    local -i ix=\"$((num / 9))\"    # Nines\n\
    \    num=$((num % 9))\n    local -i v=\"$((num / 5))\"     # Fives\n    num=$((num\
    \ % 5))\n    local -i iv=\"$((num / 4))\"    # Fours\n    num=$((num % 4))\n \
    \   local -i i=\"$num\"             # Ones\n\n    local roman=\"\"\n    if ((x\
    \ > 0)); then roman+=\"m\"; fi\n    if ((xc > 0)); then roman+=\"xc\"; fi\n  \
    \  if ((l > 0)); then roman+=\"l\"; fi\n    if ((xl > 0)); then roman+=\"xl\"\
    ; fi\n    if ((x > 0)); then roman+=\"x\"; fi\n    if ((ix > 0)); then roman+=\"\
    ix\"; fi\n    if ((v > 0)); then roman+=\"v\"; fi\n    if ((iv > 0)); then roman+=\"\
    iv\"; fi\n    if ((i > 0)); then roman+=\"i\"; fi\n\n    echo \"$roman\"", " \
    \   # Set up array for roman numerals.\n    # Keep in mind that the array indices\
    \ will be used to calculate place values.\n    ROMAN_NUMERALS=(I V X L C D M)\n\
    \    COUNTER=0\n    NUM_INPUT=$1\n    RESULT=\"\"\n    # While the input is greater\
    \ than 0.\n    while [ $NUM_INPUT -gt 0 ]; do\n        # Get the ones, tens, hundreds,\
    \ and thousands.\n        # They will be used to determine the index of the roman\
    \ numeral array.\n        ONES=$(($NUM_INPUT % 10))\n        TENS=$(($NUM_INPUT\
    \ % 100 / 10))\n        HUNDREDS=$(($NUM_INPUT % 1000 / 100))\n        THOUSANDS=$(($NUM_INPUT\
    \ / 1000))\n        # If number is 4 or 9, then it needs special conversion.\n\
    \        if [ $ONES -eq 4 ] || [ $ONES -eq 9 ]; then\n            # Use the counter,\
    \ to determine which roman numeral to use.\n            RESULT=$RESULT${ROMAN_NUMERALS[$COUNTER]}${ROMAN_NUMERALS[$COUNTER+1+$ONES/5]}\n\
    \        # Otherwise, it is a straightforward conversion.\n        else\n    \
    \        # Convert the ones to roman numeral.\n            if [ $ONES -ne 0 ];\
    \ then\n                RESULT=$RESULT${ROMAN_NUMERALS[$COUNTER]}\n          \
    \  fi\n            # Convert the tens to roman numeral.\n            if [ $TENS\
    \ -ne 0 ]; then\n                RESULT=$RESULT${ROMAN_NUMERALS[$COUNTER+1]}\n\
    \            fi\n            # Convert the hundreds to roman numeral.\n      \
    \      if [ $HUNDREDS -ne 0 ]; then\n                RESULT=$RESULT${ROMAN_NUMERALS[$COUNTER+2]}\n\
    \            fi\n            # Convert the thousands to roman numeral.\n     \
    \       if [ $THOUSANDS -ne 0 ]; then\n                RESULT=$RESULT${ROMAN_NUMERALS[$COUNTER+3]}\n\
    \            fi\n        fi\n        NUM_INPUT=$(($NUM_INPUT / 10))\n", "    #\
    \ Your code here\n    declare -A map=([0]=\"\" [1]=\"i\" [2]=\"ii\" [3]=\"iii\"\
    \ [4]=\"iv\" [5]=\"v\" [6]=\"vi\" [7]=\"vii\" [8]=\"viii\" [9]=\"ix\"\n      \
    \              [10]=\"x\" [20]=\"xx\" [30]=\"xxx\" [40]=\"xl\" [50]=\"l\" [60]=\"\
    lx\" [70]=\"lxx\" [80]=\"lxxx\" [90]=\"xc\"\n                    [100]=\"c\" [200]=\"\
    cc\" [300]=\"ccc\" [400]=\"cd\" [500]=\"d\" [600]=\"dc\" [700]=\"dcc\" [800]=\"\
    dccc\" [900]=\"cm\"\n                    [1000]=\"m\" [2000]=\"mm\" [3000]=\"\
    mmm\")\n    var=$1\n    while [[ $var -gt 0 ]]; do\n        out=\"\"\n       \
    \ while [[ $var -gt 0 ]]; do\n            tmp=$((var%10))\n            var=$((var/10))\n\
    \            #echo \"$tmp, $var\"\n            out=\"${map[$tmp]}$out\"\n    \
    \    done\n        echo \"$out\"\n    done", "    # Values of mini-romans\n  \
    \  decs=(1 4 5 9 10 40 50 90 100 400 500 900 1000)\n    # Corresponding symbols\
    \ of mini-romans\n    symbols=(i iv v ix x  xl l xc c  cd d  cm m)\n    # Remove\
    \ thousands and remainders\n    [ -z \"$1\" ] && return \"\"\n    thousands=$(echo\
    \ \"$1\" | awk '{print int($1/1000)}')\n    [ -n \"$thousands\" ] && thousand_romans=\"\
    m$(int_to_mini_roman \"$thousands\")\"\n    remainders=$(echo \"$1\" | awk '{print\
    \ $1%1000}')\n    # Check the miniroman corresponding to the remainders\n    for\
    \ ((i=${#decs[@]}-1; i>=0; i--)); do\n        [ \"$remainders\" -ge \"${decs[$i]}\"\
    \ ] && {\n            # Get the roman symbols of hundreds, tens and ones\n   \
    \         hundreds=$(echo \"$remainders\" | awk '{print int($1/100)}')\n     \
    \       [ -n \"$hundreds\" ] && hundred_romans=\"$(int_to_mini_roman \"$hundreds\"\
    )c\"\n            remainders=$(echo \"$remainders\" | awk '{print $1%100}')\n\
    \            tens=$(echo \"$remainders\" | awk '{print int($1/10)}')\n       \
    \     [ -n \"$tens\" ] && ten_romans=\"$(int_to_mini_roman \"$tens\")x\"\n   \
    \         remainders=$(echo \"$remainders\" | awk '{print $1%10}')\n         \
    \   [ -n \"$remainders\" ] && one_romans=\"$(int_to_mini_roman \"$remainders\"\
    )i\"\n            echo \"${thousand_romans}${hundred_romans}${ten_romans}${one_romans}${symbols[$i]}\"\
    \n            return\n        }\n    done", "    local -A roman_table=( [1]=\"\
    i\" [5]=\"v\" [10]=\"x\" [50]=\"l\" [100]=\"c\" [500]=\"d\" [1000]=\"m\" )\n \
    \   local -i num=$1\n\n    local -a roman_list=( $(int_to_roman \"$num\") )\n\
    \    local roman_list_len=${#roman_list[@]}\n    local roman_list_i=0\n    local\
    \ result=\"\"\n\n    local -i num_left num_right\n    local char_left char_right\n\
    \n    # Loop through the list of roman letters for the number.\n    # Loop through\
    \ the list backwards, because the left-most number is the one\n    # that has\
    \ the most impact on the outcome.\n    for (( i=roman_list_len-1; i>=0; i-- ));\
    \ do\n        (( roman_list_i=i ))\n        num_left=${roman_list[i]}\n      \
    \  char_left=${roman_table[num_left]}\n\n        # If we are at the end of the\
    \ list, just append the single letter.\n        if (( roman_list_i == roman_list_len-1\
    \ )); then\n            result=\"${result}${char_left}\"\n            continue\n\
    \        fi\n\n        # If the next letter is greater, then we need to deal with\
    \ the 4 or 9\n        # cases.\n        (( roman_list_i++ ))\n        num_right=${roman_list[roman_list_i]}\n\
    \        char_right=${roman_table[num_right]}\n        if (( num_right > num_left\
    \ )); then\n            (( num_right-=num_left ))\n            result=\"${result}${roman_table[num_right]}\"\
    \n            continue\n        fi\n\n        # Otherwise, we are doing the normal\
    \ \"listing\" of the number.\n        result=\"${result}${char_left}\"\n    done\n\
    \n    echo \"$result\"", "  local in_int=$1\n  local roman_ones=(\"m\" \"c\" \"\
    x\" \"i\")\n  local roman_fives=(\"m\" \"d\" \"l\" \"v\")\n  local out_str=\"\
    $(printf \"%04d\" $in_int)\"\n  local out_str_length=${#out_str}\n  local val_str=\"\
    \"\n  local val_str_length=0\n  local val_num=0\n  local power_ten=0\n  for ((pos\
    \ = 0; pos < out_str_length; pos++)); do\n    val_str=\"${out_str:$pos:1}\"\n\
    \    val_num=${val_str}\n    power_ten=$((3 - pos))\n    if ((val_num < 4)); then\n\
    \      # III, II, I\n      out_str=\"${out_str/$val_str/${roman_ones[$power_ten]}}\"\
    \n    elif ((val_num == 4)); then\n      # IV\n      out_str=\"${out_str/$val_str/${roman_ones[$power_ten]}${roman_fives[$power_ten]}}\"\
    \n    elif ((val_num == 5)); then\n      # V\n      out_str=\"${out_str/$val_str/${roman_fives[$power_ten]}}\"\
    \n    elif ((val_num > 5 && val_num < 9)); then\n      # VI, VII, VIII\n     \
    \ val_str=\"$(($val_num - 5))\"\n      out_str=\"${out_str/$val_str/${roman_fives[$power_ten]}${roman_ones[$power_ten]}}\"\
    \n    elif ((val_num == 9)); then\n      # IX\n      out_str=\"${out_str/$val_str/${roman_ones[$power_ten]}${roman_ones[$((power_ten\
    \ - 1))]}}\"\n    fi\n  done\n  printf \"%s\" \"$out_str\"", "    local num=\"\
    $1\"\n    # convert the number to uppercase roman numeral first\n    local roman=$(int_to_roman\
    \ \"$num\")\n    # then convert it to mini roman numeral\n    roman_to_mini_roman\
    \ \"$roman\"", "    if ! [[ \"$1\" =~ ^[0-9]+$ ]]; then\n        echo \"Invalid\
    \ input\" >&2\n        return 1\n    fi\n    if [ \"$1\" -eq 0 ]; then\n     \
    \   echo \"\"\n        return 0\n    fi\n    if [ \"$1\" -eq 1000 ]; then\n  \
    \      echo \"m\"\n        return 0\n    fi\n    if [ \"$1\" -ge 900 ]; then\n\
    \        echo -n \"cm\"\n        int_to_mini_roman $(( $1 - 900 ))\n        return\
    \ 0\n    fi\n    if [ \"$1\" -ge 500 ]; then\n        echo -n \"d\"\n        int_to_mini_roman\
    \ $(( $1 - 500 ))\n        return 0\n    fi\n    if [ \"$1\" -ge 400 ]; then\n\
    \        echo -n \"cd\"\n        int_to_mini_roman $(( $1 - 400 ))\n        return\
    \ 0\n    fi\n    if [ \"$1\" -ge 100 ]; then\n        echo -n \"c\"\n        int_to_mini_roman\
    \ $(( $1 - 100 ))\n        return 0\n    fi\n    if [ \"$1\" -ge 90 ]; then\n\
    \        echo -n \"xc\"\n        int_to_mini_roman $(( $1 - 90 ))\n        return\
    \ 0\n    fi\n    if [ \"$1\" -ge 50 ]; then\n        echo -n \"l\"\n        int_to_mini_roman\
    \ $(( $1 - 50 ))\n        return 0\n    fi\n    if [ \"$1\" -ge 40 ]; then\n \
    \       echo -n \"xl\"\n        int_to_mini_roman $(( $1 - 40 ))\n        return\
    \ 0\n    fi\n    if [ \"$1\" -ge 10 ]; then\n        echo -n \"x\"\n        int_to_mini_roman\
    \ $(( $1 - 10 ))\n        return 0\n    fi\n    if [ \"$1\" -ge 9 ]; then\n  \
    \      echo -n \"ix\"\n        int_to_mini_roman $(( $1 - 9 ))\n        return\
    \ 0\n    fi\n    if [ \"$1\" -ge 5 ]; then\n        echo -n \"v\"\n        int_to_mini_roman\
    \ $(( $1 - 5 ))\n        return", "    if [[ ! \"$1\" =~ ^[0-9]+$ ]]; then\n \
    \       echo \"Error: Invalid argument\"\n        return 1\n    fi\n    if [[\
    \ \"$1\" -gt 1000 ]]; then\n        echo \"Error: Argument is greater than 1000\"\
    \n        return 1\n    fi\n    if [[ \"$1\" -lt 1 ]]; then\n        echo \"Error:\
    \ Argument is less than 1\"\n        return 1\n    fi\n    local x=$1\n    local\
    \ m=''\n    while [[ \"$x\" -ge 1000 ]]; do\n        m+='m'\n        x=$((x-1000))\n\
    \    done\n    if [[ \"$x\" -ge 900 ]]; then\n        m+='cm'\n        x=$((x-900))\n\
    \    fi\n    if [[ \"$x\" -ge 500 ]]; then\n        m+='d'\n        x=$((x-500))\n\
    \    fi\n    if [[ \"$x\" -ge 400 ]]; then\n        m+='cd'\n        x=$((x-400))\n\
    \    fi\n    while [[ \"$x\" -ge 100 ]]; do\n        m+='c'\n        x=$((x-100))\n\
    \    done\n    if [[ \"$x\" -ge 90 ]]; then\n        m+='xc'\n        x=$((x-90))\n\
    \    fi\n    if [[ \"$x\" -ge 50 ]]; then\n        m+='l'\n        x=$((x-50))\n\
    \    fi\n    if [[ \"$x\" -ge 40 ]]; then\n        m+='xl'\n        x=$((x-40))\n\
    \    fi\n    while [[ \"$x\" -ge 10 ]]; do\n        m+='x'\n        x=$((x-10))\n\
    \    done\n    if [[ \"$x\" -ge 9 ]]; then\n        m+='ix'\n        x=$((x-9))\n\
    \    fi\n    if [[ \"$x\" -ge 5 ]]; then\n        m+='v'\n        x=$((x-5))\n\
    \    fi\n    if [[ \"$x\" -ge 4 ]]; then\n        m+='iv'\n        x=$((x-4))\n\
    \    fi\n    while [[ \"$x\" -ge 1 ]]; do\n       ", "    # The following is a\
    \ good explination of Roman Numerals.\n    # http://mathcentral.uregina.ca/QQ/database/QQ.09.99/h/amanda1.html\n\
    \    local num=$1\n    local result=\"\"\n    local digit=\"\"\n    # First, we\
    \ will convert any thousandths to Roman numerals.\n    # The Roman numeral for\
    \ 1,000 is \"m\", and no more than three\n    # \"m\"s are allowed in a row.\n\
    \    local -i thousands=$(( num / 1000 ))\n    local -i remainder=$(( num % 1000\
    \ ))\n    local -i index=0\n    while (( index < thousands )); do\n        result+=\"\
    m\"\n        (( index++ ))\n    done\n    # Next, we will convert any hundreds\
    \ to Roman numerals.\n    # The Roman numeral for 100 is \"c\", and no more than\
    \ three\n    # \"c\"s are allowed in a row.\n    num=$remainder\n    local -i\
    \ hundreds=$(( num / 100 ))\n    remainder=$(( num % 100 ))\n    index=0\n   \
    \ while (( index < hundreds )); do\n        result+=\"c\"\n        (( index++\
    \ ))\n    done\n    # Next, we will convert any tens to Roman numerals.\n    #\
    \ The Roman numeral for 10 is \"x\", and no more than three\n    # \"x\"s are\
    \ allowed in a row.\n    num=$remainder\n    local -i tens=$(( num / 10 ))\n \
    \   remainder=$(( num % 10 ))\n    index=0\n    while (( index < tens )); do\n\
    \        result+=\"x\"\n        (( index++ ))\n    done\n    # Lastly, we will\
    \ convert any ones to Roman numerals.\n    # The Roman numeral for 1 is \"i\"\
    , and no more than three\n    # \"i\"s are allowed in a row.\n    num=$remainder\n\
    \    local -i ones=$(( num ))\n    index=0\n    while (( index < ones )); do\n\
    \        result+=\"i\"\n        (( index++ ))\n    done\n    # Now, we need to\
    \ account for the Roman numerals 4, 5, 9, 40, 50, 90,\n    # 400, 500, and 900,\
    \ which use special forms", "    declare -A roman_symbols=(\n        [1000]=\"\
    m\" [900]=\"cm\" [500]=\"d\" [400]=\"cd\"\n        [100]=\"c\" [90]=\"xc\" [50]=\"\
    l\" [40]=\"xl\"\n        [10]=\"x\" [9]=\"ix\" [5]=\"v\" [4]=\"iv\"\n        [1]=\"\
    i\"\n    )\n    declare -A values=(\n        [1000]=1 [900]=1 [500]=1 [400]=1\n\
    \        [100]=1 [90]=1 [50]=1 [40]=1\n        [10]=1 [9]=1 [5]=1 [4]=1\n    \
    \    [1]=1\n    )\n    local number=$1\n    local result=\"\"\n    for key in\
    \ ${!values[@]}; do\n        while [ \"$number\" -ge \"$key\" ]; do\n        \
    \    let \"number -= $key\"\n            result=\"${result}${roman_symbols[$key]}\"\
    \n        done\n    done\n    echo \"$result\"", "  [[ $1 =~ ^-?[0-9]+$ ]] ||\
    \ return 1\n  declare -A numeral\n  numeral[1]=\"i\"\n  numeral[5]=\"v\"\n  numeral[10]=\"\
    x\"\n  numeral[50]=\"l\"\n  numeral[100]=\"c\"\n  numeral[500]=\"d\"\n  numeral[1000]=\"\
    m\"\n  roman_int=$1\n  while [[ $roman_int -gt 0 ]]; do\n    # get the magnitude\
    \ of the number\n    mag=$(get_magnitude $roman_int)\n    # divide the number\
    \ by the magnitude\n    roman_int=$((roman_int / mag))\n    # get the remainder\n\
    \    rem=$((roman_int % mag))\n    # repeat the character as many times as the\
    \ magnitude\n    while [[ $mag -gt 0 ]]; do\n      printf \"${numeral[$mag]}\"\
    \n      ((mag--))\n    done\n    # if the remainder is not zero, repeat\n  done",
  "    local n=\"$1\"\n    local m=\"\"\n\n    if [[ $n -lt 1 || $n -gt 1000 ]]; then\n\
    \        echo \"ERROR: input $n outside of range [1, 1000]\" >&2\n        exit\
    \ 1\n    fi\n\n    if (( $n >= 100 )); then\n        m+=\"c\"\n        (( n -=\
    \ 100 ))\n    fi\n\n    if (( $n >= 90 )); then\n        m+=\"xc\"\n        ((\
    \ n -= 90 ))\n    fi\n\n    if (( $n >= 50 )); then\n        m+=\"l\"\n      \
    \  (( n -= 50 ))\n    fi\n\n    if (( $n >= 40 )); then\n        m+=\"xl\"\n \
    \       (( n -= 40 ))\n    fi\n\n    while (( $n >= 10 )); do\n        m+=\"x\"\
    \n        (( n -= 10 ))\n    done\n\n    if (( $n >= 9 )); then\n        m+=\"\
    ix\"\n        (( n -= 9 ))\n    fi\n\n    if (( $n >= 5 )); then\n        m+=\"\
    v\"\n        (( n -= 5 ))\n    fi\n\n    if (( $n >= 4 )); then\n        m+=\"\
    iv\"\n        (( n -= 4 ))\n    fi\n\n    while (( $n >= 1 )); do\n        m+=\"\
    i\"\n        (( n -= 1 ))\n    done\n\n    echo \"$m\"", "    # Convert number\
    \ to roman numeral string\n    local ROMAN=$(int_to_roman $1)\n    # Lowercase\
    \ the roman numeral string\n    echo \"$ROMAN\" | tr '[:upper:]' '[:lower:]'",
  "  # \n  if [[ ! $1 =~ ^[0-9]+$ ]]; then\n    echo \"Input is not a valid integer.\"\
    \n    exit 1\n  fi\n  #\n  if [ $1 -eq 0 ]; then\n    echo \"\"\n    exit 0\n\
    \  fi\n  # \n  if [ $1 -ge 1000 ]; then\n    echo \"Number is larger than 1000.\"\
    \n    exit 1\n  fi\n  #\n  if [ $1 -ge 100 ]; then\n    num=$1\n    m=$((num/100))\n\
    \    num=$((num%100))\n    echo -n $(repeat_string \"c\" $m)\n  fi\n  #\n  if\
    \ [ $num -ge 90 ]; then\n    num=$((num-90))\n    echo -n \"xc\"\n  fi\n  #\n\
    \  if [ $num -ge 50 ]; then\n    num=$((num-50))\n    echo -n \"l\"\n  fi\n  #\n\
    \  if [ $num -ge 40 ]; then\n    num=$((num-40))\n    echo -n \"xl\"\n  fi\n \
    \ #\n  if [ $num -ge 10 ]; then\n    num=$((num%10))\n    x=$((num/10))\n    num=$((num%10))\n\
    \    echo -n $(repeat_string \"x\" $x)\n  fi\n  #\n  if [ $num -ge 9 ]; then\n\
    \    num=$((num-9))\n    echo -n \"ix\"\n  fi\n  #\n  if [ $num -ge 5 ]; then\n\
    \    num=$((num-5))\n    echo -n \"v\"\n  fi\n  #\n  if [ $num -ge 4 ]; then\n\
    \    num=$((num-4))\n    echo -n \"iv\"\n  fi\n  #\n  if [ $num -ge 1 ]; then\n\
    \    num=$((num%1))\n    i=$((num/1))\n    num=$((num%1))\n    echo -n $(repeat_string\
    \ \"i\" $i)\n  fi\n  #\n  echo \"\"", "  local -A roman_chars\n  roman_chars[1]=\"\
    i\"\n  roman_chars[5]=\"v\"\n  roman_chars[10]=\"x\"\n  roman_chars[50]=\"l\"\n\
    \  roman_chars[100]=\"c\"\n  roman_chars[500]=\"d\"\n  roman_chars[1000]=\"m\"\
    \n\n  local -a nums\n  nums[1]=$(echo \"$1\" | sed -r \"s/^([[:digit:]])([[:digit:]]{0,3})$/\\\
    1 \\2/\")\n  nums[2]=$(echo \"$1\" | sed -r \"s/^([[:digit:]]{0,3})([[:digit:]])$/\\\
    1 \\2/\")\n  nums[3]=$(echo \"$1\" | sed -r \"s/^([[:digit:]]{0,2})([[:digit:]])$/\\\
    1 \\2/\")\n  nums[4]=$(echo \"$1\" | sed -r \"s/^([[:digit:]]{0,1})([[:digit:]])$/\\\
    1 \\2/\")\n\n  local -a out\n  local i\n  for i in 1 2 3 4; do\n    if [ \"${nums[$i]}\"\
    \ -lt 4 ]; then\n      out+=(\"$(printf '%0.s' $(seq 1 ${nums[$i]}))\")\n    elif\
    \ [ \"${nums[$i]}\" -eq 4 ]; then\n      out+=(\"$(printf '%0.s' $(seq 1 ${nums[$i]}))\"\
    )\n    elif [ \"${nums[$i]}\" -lt 9 ]; then\n      out+=(\"$(printf '%0.s' $(seq\
    \ 1 $((5 - ${nums[$i]}))))\")\n      out+=(\"v\")\n    elif [ \"${nums[$i]}\"\
    \ -eq 9 ]; then\n      out+=(\"$(printf '%0.s' $(seq 1 $((10 - ${nums[$i]}))))\"\
    )\n   ", "\tlocal ones five_tens ten_tens\n\n\t# Parse each digit of the given\
    \ integer\n\t# 0-9: I V X\n\t# 10-90: X L C\n\t# 100-900: C D M\n\t[[ \"$1\" =~\
    \ ^([0-9]+)([0-9]{2})([0-9]{3})$ ]] &&\n\t\t\tones=\"${BASH_REMATCH[1]}\"\n\t\t\
    \tfive_tens=\"${BASH_REMATCH[2]}\"\n\t\t\tten_tens=\"${BASH_REMATCH[3]}\"\n\n\t\
    # Function to parse each unit of the integer, which can be single digit,\n\t#\
    \ double digit, or triple digit.\n\t# $1 is a number\n\t# $2 is a roman numeral\n\
    \t# $3 is a roman numeral\n\t# $4 is a roman numeral\n\t# Returns the roman numeral\
    \ equivalent of the given number\n\troman_numeral() {\n\t\tlocal retval=\"\"\n\
    \n\t\tif [[ $1 -eq 9 ]]; then\n\t\t\tretval=\"$3$2\"\n\t\telif [[ $1 -eq 8 ]];\
    \ then\n\t\t\tretval=\"$3$3$2\"\n\t\telif [[ $1 -eq 7 ]]; then\n\t\t\tretval=\"\
    $3$3$2$2\"\n\t\telif [[ $1 -eq 6 ]]; then\n\t\t\tretval=\"$3$3$2\"\n\t\telif [[\
    \ $1 -eq 5 ]]; then\n\t\t\tretval=\"$3\"\n\t\telif [[ $1 -eq 4 ]]; then\n\t\t\t\
    retval=\"$3$2\"\n\t\telif [[ $1 -eq 3 ]]; then\n\t\t\tretval=\"$2$2$2\"\n\t\t\
    elif [[ $1 -eq 2 ]]; then\n\t\t\tretval=\"$2$2\"\n\t\telif [[ $1 -eq 1 ]]; then\n\
    \t\t\tretval=\"$2\"\n\t\tfi\n\n\t\techo \"$retval\"\n\t}\n\n\t# Parse the integer\n\
    \tlocal roman_ones=$(roman", "  local -i num=$1\n  # Obtain each of the individual\
    \ digits in the integer.\n  local -i ones=$(( num % 10 ))\n  local -i tens=$((\
    \ (num / 10) % 10 ))\n  local -i hundreds=$(( (num / 100) % 10 ))\n  local -i\
    \ thousands=$(( (num / 1000) % 10 ))\n  local -i roman_numeral=()\n  # Prepopulate\
    \ with empty strings.\n  for i in {1..4}; do\n    roman_numeral[$i]=\"\"\n  done\n\
    \  # Define an array of strings corresponding to each digit.\n  local -a ones_as_string=(\"\
    \" \"i\" \"ii\" \"iii\" \"iv\" \"v\" \"vi\" \"vii\" \"viii\" \"ix\")\n  local\
    \ -a tens_as_string=(\"\" \"x\" \"xx\" \"xxx\" \"xl\" \"l\" \"lx\" \"lxx\" \"\
    lxxx\" \"xc\")\n  local -a hundreds_as_string=(\"\" \"c\" \"cc\" \"ccc\" \"cd\"\
    \ \"d\" \"dc\" \"dcc\" \"dccc\" \"cm\")\n  local -a thousands_as_string=(\"\"\
    \ \"m\" \"mm\" \"mmm\")\n  # Map each digit to a string.\n  if (( ones > 0 ));\
    \ then\n    roman_numeral[1]=${ones_as_string[$ones]}\n  fi\n  if (( tens > 0\
    \ )); then\n    roman_numeral[2]=${tens_as_string[$tens]}\n  fi\n  if (( hundreds\
    \ > 0 )); then\n    roman_numeral[3]=${hundreds_as_string[$hundreds]}\n  fi\n\
    \  if (( thousands > 0 )); then\n    roman_numeral[4]=${thousands_as_string[$thousands]}\n\
    \  fi\n  # Join the strings.\n  roman_numeral_string=\"${roman_numeral[@]}\"\n\
    \  # Convert to lowercase.\n  printf '%s' \"${roman_numeral_string,,}\"", "  if\
    \ [ -z \"$1\" ]; then\n    echo \"ERROR: Missing required parameter \\$1 (integer).\"\
    \n    exit 1\n  fi\n  local -i num=$1\n  local -a mini_roman=(\n      [1]=\"i\"\
    \ [5]=\"v\" [10]=\"x\" [50]=\"l\" [100]=\"c\" [500]=\"d\" [1000]=\"m\"\n    )\n\
    \  local -a digits=(1000 100 10 1)\n  local -a result=()\n  local -i digit\n \
    \ local -i i\n  for ((i=0; i<4; i++)); do\n    digit=${digits[$i]}\n    if ((num\
    \ >= digit)); then\n      result[${#result[@]}]=$(\n        print_mini_roman \"\
    ${mini_roman[$digit]}\" $((num / digit))\n      )\n      num=$((num % digit))\n\
    \    fi\n  done\n  echo ${result[@]}", "\t# restrinc: 1 <= num <= 1000\n\t# the\
    \ number of \"M\"s we need\n\t# M = 1\n\tcount_M=$(($1 / 1000))\n\t# the number\
    \ of \"C\"s we need\n\t# C = 5\n\tcount_C=$((($1 - $count_M * 1000) / 100))\n\t\
    # the number of \"X\"s we need\n\t# X = 10\n\tcount_X=$((($1 - $count_M * 1000\
    \ - $count_C * 100) / 10))\n\t# the number of \"I\"s we need\n\t# I = 1\n\tcount_I=$(($1\
    \ - $count_M * 1000 - $count_C * 100 - $count_X * 10))\n\t# build up the roman\
    \ numeral\n\troman=\"\"\n\t# MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM",
  "  local roman_numeral=''\n  local decimal=$1\n  local value_to_roman=('i' 'iv'\
    \ 'v' 'ix' 'x' 'xl' 'l' 'xc' 'c' 'cd' 'd' 'cm' 'm')\n  local value_to_decimal=(1\
    \ 4 5 9 10 40 50 90 100 400 500 900 1000)\n  for ((i=${#value_to_decimal[@]}-1;\
    \ i>=0; i--)); do\n    local value=${value_to_decimal[$i]}\n    local numeral=${value_to_roman[$i]}\n\
    \    while (( decimal >= value )); do\n      decimal=$((decimal-value))\n    \
    \  roman_numeral=\"${roman_numeral}${numeral}\"\n    done\n  done\n  echo \"$roman_numeral\"",
  "    local n=$1\n    local -a r=(\n        [1000]=m\n        [900]=cm\n        [500]=d\n\
    \        [400]=cd\n        [100]=c\n        [90]=xc\n        [50]=l\n        [40]=xl\n\
    \        [10]=x\n        [9]=ix\n        [5]=v\n        [4]=iv\n        [1]=i\n\
    \    )\n    local -a k=(1000 900 500 400 100 90 50 40 10 9 5 4 1)\n    local i=$((${#k[@]}\
    \ - 1))\n    local s=\n    local x\n    while ((n)); do\n        x=${k[i]}\n \
    \       if ((n >= x)); then\n            s+=${r[x]}\n            ((n -= x))\n\
    \        else\n            ((i--))\n        fi\n    done\n    echo \"$s\"", " \
    \   local num=$1\n    local res=\"\"\n    local -a roman_numerals=(\n        [1]=\"\
    i\"\n        [5]=\"v\"\n        [10]=\"x\"\n        [50]=\"l\"\n        [100]=\"\
    c\"\n        [500]=\"d\"\n        [1000]=\"m\"\n    )\n    local ones=$((num %\
    \ 10))\n    local tens=$(((num / 10) % 10))\n    local hundreds=$(((num / 100)\
    \ % 10))\n    local thousands=$((num / 1000))\n    local -a ones_arr=($(digit_to_mini_roman\
    \ $ones))\n    local -a tens_arr=($(digit_to_mini_roman $tens))\n    local -a\
    \ hundreds_arr=($(digit_to_mini_roman $hundreds))\n    local -a thousands_arr=($(digit_to_mini_roman\
    \ $thousands))\n    res+=\"${thousands_arr[@]}\"\n    res+=\"${hundreds_arr[@]}\"\
    \n    res+=\"${tens_arr[@]}\"\n    res+=\"${ones_arr[@]}\"\n    echo \"$res\"",
  "    local int=\"$1\"\n    local str=\"\"\n    local numerals=(M CM D CD C XC L\
    \ XL X IX V IV I)\n    local nums=(1000 900 500 400 100 90 50 40 10 9 5 4 1)\n\
    \    local ints=\"\"\n    for ((i=0; i<${#nums[@]}; i++)); do\n        while ((\
    \ int >= nums[i] )); do\n            str=\"${str}${numerals[i]}\"\n          \
    \  int=$((int-nums[i]))\n        done\n    done\n    echo $str", "    local int=$1\n\
    \    local rom=\"\"\n    local arabic=(1000 900 500 400 100 90 50 40 10 9 5 4\
    \ 1)\n    local roman=(m cm d cd c xc l xl x ix v iv i)\n    local i=0\n    while\
    \ (( int > 0 )); do\n        while (( int >= arabic[i] )); do\n            int=$((\
    \ int - arabic[i] ))\n            rom+=${roman[i]}\n        done\n        (( i++\
    \ ))\n    done\n    echo $rom", "    [[ $1 =~ ^[0-9]+$ ]] || {\n        echo \"\
    error: only integers are allowed. $1 is not an integer\"\n        return 1\n \
    \   }\n    [[ \"$1\" -gt 1000 ]] && {\n        echo \"error: max value is 1000\"\
    \n        return 1\n    }\n    [[ \"$1\" -lt 1 ]] && {\n        echo \"error:\
    \ min value is 1\"\n        return 1\n    }\n    local -a ROMAN_NUMERALS=(\"m\"\
    \ \"cm\" \"d\" \"cd\" \"c\" \"xc\" \"l\" \"xl\" \"x\" \"ix\" \"v\" \"iv\" \"i\"\
    )\n    local -a DECIMAL_VALUES=(1000 900 500 400 100 90 50 40 10 9 5 4 1)\n  \
    \  local roman_numeral=\"\"\n    local number=$1\n    for ((i=0; i<${#DECIMAL_VALUES[@]};\
    \ i++)); do\n        while [[ \"$number\" -ge \"${DECIMAL_VALUES[$i]}\" ]]; do\n\
    \            roman_numeral=\"$roman_numeral${ROMAN_NUMERALS[$i]}\"\n         \
    \   number=$((number-${DECIMAL_VALUES[$i]}))\n        done\n    done\n    echo\
    \ \"$roman_numeral\"", "    if [[ ! \"$1\" =~ ^-?[0-9]+$ ]]; then\n        echo\
    \ \"ERROR: $1 is not an integer\" >&2\n        return 1\n    fi\n    local num=\"\
    $1\"\n    local numeral=\"\"\n    while ((num > 0)); do\n        if ((num >= 1000));\
    \ then\n            numeral+=\"m\"\n            ((num -= 1000))\n        elif\
    \ ((num >= 900)); then\n            numeral+=\"cm\"\n            ((num -= 900))\n\
    \        elif ((num >= 500)); then\n            numeral+=\"d\"\n            ((num\
    \ -= 500))\n        elif ((num >= 400)); then\n            numeral+=\"cd\"\n \
    \           ((num -= 400))\n        elif ((num >= 100)); then\n            numeral+=\"\
    c\"\n            ((num -= 100))\n        elif ((num >= 90)); then\n          \
    \  numeral+=\"xc\"\n            ((num -= 90))\n        elif ((num >= 50)); then\n\
    \            numeral+=\"l\"\n            ((num -= 50))\n        elif ((num >=\
    \ 40)); then\n            numeral+=\"xl\"\n            ((num -= 40))\n       \
    \ elif ((num >= 10)); then\n            numeral+=\"x\"\n            ((num -= 10))\n\
    \        elif ((num >= 9)); then\n            numeral+=\"ix\"\n            ((num\
    \ -= 9))\n        elif ((num >= 5)); then\n            numeral+=\"v\"\n      \
    \      ((num -= 5))\n        elif ((num >= 4)); then\n            numeral+=\"\
    iv\"\n            ((num -= 4))\n        else\n            numeral+=\"i\"\n   \
    \         ((num -= 1))\n        fi\n    done\n    echo \"$numeral\"", "    declare\
    \ -a R\n    R[1]=\"i\"\n    R[2]=\"ii\"\n    R[3]=\"iii\"\n    R[4]=\"iv\"\n \
    \   R[5]=\"v\"\n    R[6]=\"vi\"\n    R[7]=\"vii\"\n    R[8]=\"viii\"\n    R[9]=\"\
    ix\"\n    R[10]=\"x\"\n    R[20]=\"xx\"\n    R[30]=\"xxx\"\n    R[40]=\"xl\"\n\
    \    R[50]=\"l\"\n    R[60]=\"lx\"\n    R[70]=\"lxx\"\n    R[80]=\"lxxx\"\n  \
    \  R[90]=\"xc\"\n    R[100]=\"c\"\n    R[200]=\"cc\"\n    R[300]=\"ccc\"\n   \
    \ R[400]=\"cd\"\n    R[500]=\"d\"\n    R[600]=\"dc\"\n    R[700]=\"dcc\"\n   \
    \ R[800]=\"dccc\"\n    R[900]=\"cm\"\n    R[1000]=\"m\"\n    local num=$1\n  \
    \  local roman=''\n    local x\n\n    while [ $num -gt 0 ]; do\n        if [ $num\
    \ -gt 1000 ]; then\n            x=1000\n        elif [ $num -gt 900 ]; then\n\
    \            x=900\n        elif [ $num -gt 800 ]; then\n            x=800\n \
    \       elif [ $num -gt 700 ]; then\n            x=700\n        elif [ $num -gt\
    \ 600 ]; then\n            x=600\n        elif [ $num -gt 500 ]; then\n      \
    \      x=500\n        elif [ $num -gt 400 ]; then\n            x=400\n       \
    \ elif [ $num -gt 300 ]; then\n            x=300\n        elif [ $num -gt 200\
    \ ]; then\n            x=200\n        elif [ $num -gt 100 ]; then\n          \
    \  x=100\n        elif [ $num -gt 90 ]; then\n            x=90\n        elif [\
    \ $num -gt 80 ]; then\n            x=80\n        elif [ $num -gt 70 ]; then\n",
  "  # This function is a binary search over an array of the intervals\n  # (each\
    \ interval contains the numeral, the decimal value at its lower bound,\n  # and\
    \ the decimal value at its upper bound).\n  # The search is performed recursively.\n\
    \  local -r intervals=(\n    (\"m\" 1000 999)\n    (\"cm\" 900 899)\n    (\"d\"\
    \ 500 499)\n    (\"cd\" 400 399)\n    (\"c\" 100 99)\n    (\"xc\" 90 89)\n   \
    \ (\"l\" 50 49)\n    (\"xl\" 40 39)\n    (\"x\" 10 9)\n    (\"ix\" 9 8)\n    (\"\
    v\" 5 4)\n    (\"iv\" 4 3)\n    (\"i\" 1 0)\n  )\n  local -r interval_len=${#intervals[@]}\n\
    \  local -r half_len=$((interval_len / 2))\n  # The number of times the numeral\
    \ is repeated is taken as the difference\n  # between the decimal number and the\
    \ decimal value at the lower bound of\n  # the range where it is contained\n \
    \ local -r n=$(( $1 - ${intervals[$half_len][2]} ))\n  # The value that is greater\
    \ than the decimal number is found\n  local -r upper_bound_dec=${intervals[$half_len][2]}\n\
    \  # The value that is lower than the decimal number is found\n  local -r lower_bound_dec=${intervals[$((\
    \ half_len - 1 ))][1]}\n  if (( n > upper_bound_dec )); then\n    local numeral=${intervals[$half_len][0]}\n\
    \    numeral=$( printf \"%-${n}s\" \"$numeral\" )\n    echo \"${numeral// /${intervals[$half_len][0]}}\"\
    \n  elif (( n < lower_bound_dec )); then\n    # If the interval is not found,\
    \ we look for it in the array's left half\n    int_to_mini_roman \"$1\" \"$half_len\"\
    \ \"$(( half_len - 1 ))\"\n  else\n    # If the interval is not found, we look\
    \ for it in the array's right half\n    int_to_mini_roman \"$1", "  local int=\"\
    $1\"\n  local -a numerals\n\n  if [[ $int -le 0 ]] || [[ $int -gt 1000 ]]; then\n\
    \    return 1\n  fi\n\n  numerals=(I IV V IX X XL L XC C CD D CM M)\n  for ((\
    \ i=12; i>=0; i-=2 )); do\n    if [[ $int -ge ${numerals[i]} ]]; then\n      printf\
    \ \"${numerals[i+1]}\"\n      int=$((int-numerals[i]))\n    fi\n  done\n\n  echo",
  "    [[ -z \"$1\" ]] && printf \"\" && return\n    local num=$1\n    local roman_numeral=\"\
    \"\n    if ((num >= 1000)); then\n        roman_numeral+=\"m\"\n        ((num-=1000))\n\
    \    fi\n    if ((num >= 500)); then\n        roman_numeral+=\"d\"\n        ((num-=500))\n\
    \    fi\n    if ((num >= 100)); then\n        roman_numeral+=\"c\"\n        ((num-=100))\n\
    \    fi\n    if ((num >= 50)); then\n        roman_numeral+=\"l\"\n        ((num-=50))\n\
    \    fi\n    if ((num >= 10)); then\n        roman_numeral+=\"x\"\n        ((num-=10))\n\
    \    fi\n    if ((num >= 5)); then\n        roman_numeral+=\"v\"\n        ((num-=5))\n\
    \    fi\n    if ((num >= 1)); then\n        roman_numeral+=\"i\"\n        ((num-=1))\n\
    \    fi\n    printf \"$roman_numeral\"", "    local num=$1\n    local ret=\"\"\
    \n    local ints=(1000 900 500 400 100 90 50 40 10 9 5 4 1)\n    local romans=(M\
    \ CM D CD C XC L XL X IX V IV I)\n    for (( i=0; i<${#ints[@]}; i++ )); do\n\
    \        while (( num >= ints[i] )); do\n            num=$(( num - ints[i] ))\n\
    \            ret+=${romans[i]}\n        done\n    done\n    echo $ret", "    local\
    \ l1 l2 l3 l4 l5 l6 l7 l8 l9 l10 l11 l12 l13 l14 l15 l16 l17 l18 l19\n    l1=\"\
    i\" l2=\"ii\" l3=\"iii\" l4=\"iv\" l5=\"v\" l6=\"vi\" l7=\"vii\" l8=\"viii\" l9=\"\
    ix\"\n    l10=\"x\" l11=\"xi\" l12=\"xii\" l13=\"xiii\" l14=\"xiv\" l15=\"xv\"\
    \ l16=\"xvi\" l17=\"xvii\" l18=\"xviii\" l19=\"xix\"\n    local l20 l21 l22 l23\
    \ l24 l25 l26 l27 l28 l29\n    l20=\"xx\" l21=\"xxi\" l22=\"xxii\" l23=\"xxiii\"\
    \ l24=\"xxiv\" l25=\"xxv\" l26=\"xxvi\" l27=\"xxvii\" l28=\"xxviii\" l29=\"xxix\"\
    \n    local l30 l31 l32 l33 l34 l35 l36 l37 l38 l39\n    l30=\"xxx\" l31=\"xxxi\"\
    \ l32=\"xxxii\" l33=\"xxxiii\" l34=\"xxxiv\" l35=\"xxxv\" l36=\"xxxvi\" l37=\"\
    xxxvii\" l38=\"xxxviii\" l39=\"xxxix\"\n    local l40 l41 l42 l43 l44 l45 l46\
    \ l47 l48 l49\n    l40=\"xl\" l41=\"xli\" l42=\"xlii\" l43=\"xliii\" l44=\"xliv\"\
    \ l45=\"xlv\" l46=\"xlvi\" l47=\"xlvii\" l48=\"xlviii\" l49=\"xlix\"\n    local\
    \ l50 l51 l52 l53 l54 l55 l56 l57 l58 l59\n    l50=\"l\" l51=\"li\" l52=\"lii\"\
    \ l53=\"liii\" l54=\"liv\" l55=\"lv\" l56=\"lvi\" l57=\"lvii\" l58=\"lviii\" l59=\"\
    lix\"\n    local l60 l61 l62 l63 l64 l65 l", "    local -r int=$1\n    [ \"$int\"\
    \ -gt 0 ] || return\n    [ \"$int\" -le 1000 ] || return\n    local -r ones=$(integer_to_char\
    \ \"$(( $int % 10 ))\" \"\")\n    local -r tens=$(integer_to_char \"$(( $int /\
    \ 10 % 10 ))\" \"x\")\n    local -r hundreds=$(integer_to_char \"$(( $int / 100\
    \ % 10 ))\" \"c\")\n    local -r thousands=$(integer_to_char \"$(( $int / 1000\
    \ % 10 ))\" \"m\")\n    echo \"$thousands$hundreds$tens$ones\"", "    declare\
    \ -A romans=([\"1\"]=\"i\" [\"5\"]=\"v\" [\"10\"]=\"x\" [\"50\"]=\"l\" [\"100\"\
    ]=\"c\" [\"500\"]=\"d\" [\"1000\"]=\"m\")\n    declare -A substractives=([\"4\"\
    ]=\"iv\" [\"9\"]=\"ix\" [\"40\"]=\"xl\" [\"90\"]=\"xc\" [\"400\"]=\"cd\" [\"900\"\
    ]=\"cm\")\n    declare -A substractives_keys=([\"4\"]=\"1\" [\"9\"]=\"1\" [\"\
    40\"]=\"10\" [\"90\"]=\"10\" [\"400\"]=\"100\" [\"900\"]=\"100\")\n    declare\
    \ -A substractives_values=([\"4\"]=\"5\" [\"9\"]=\"10\" [\"40\"]=\"50\" [\"90\"\
    ]=\"100\" [\"400\"]=\"500\" [\"900\"]=\"1000\")\n    int=\"$1\"\n    mini_roman=\"\
    \"\n    while (( int > 0 )); do\n        if (( int >= 1000 )); then\n        \
    \    mini_roman=\"${mini_roman}${romans[1000]}\"\n            (( int -= 1000 ))\n\
    \        elif (( int >= 900 )); then\n            mini_roman=\"${mini_roman}${substractives[900]}\"\
    \n            (( int -= 900 ))\n        elif (( int >= 500 )); then\n        \
    \    mini_roman=\"${mini_roman}${romans[500]}\"\n            (( int -= 500 ))\n\
    \        elif (( int >= 400 )); then\n            mini_roman=\"${mini_roman}${substractives[400]}\"\
    \n            (( int -= 400 ))\n        elif (( int >= 100 )); then\n        \
    \    mini_roman=\"${mini_roman}${romans[100]}\"\n            (( int -= 100 ))\n\
    \        elif (( int >= 90 )); then\n            mini_roman=\"${mini_roman}${substractives[90]}\"\
    \n            (( int -= 90 ))\n        elif (( int >= 50 )); then\n          \
    \  mini_roman=\"${mini_roman}${romans[50]}\"\n            (( int -= 50 ))\n  \
    \      elif (( int >= 40 )); then\n            mini_roman=\"${mini_roman}${substractives[40]}\"\
    \n            (( int -= 40 ))\n        elif (( int >= 10 )); then\n          \
    \  mini_roman=\"${", "    local roman[1]=\"i\"\n    local roman[2]=\"ii\"\n  \
    \  local roman[3]=\"iii\"\n    local roman[4]=\"iv\"\n    local roman[5]=\"v\"\
    \n    local roman[6]=\"vi\"\n    local roman[7]=\"vii\"\n    local roman[8]=\"\
    viii\"\n    local roman[9]=\"ix\"\n    local roman[10]=\"x\"\n    local roman[20]=\"\
    xx\"\n    local roman[30]=\"xxx\"\n    local roman[40]=\"xl\"\n    local roman[50]=\"\
    l\"\n    local roman[60]=\"lx\"\n    local roman[70]=\"lxx\"\n    local roman[80]=\"\
    lxxx\"\n    local roman[90]=\"xc\"\n    local roman[100]=\"c\"\n    local roman[200]=\"\
    cc\"\n    local roman[300]=\"ccc\"\n    local roman[400]=\"cd\"\n    local roman[500]=\"\
    d\"\n    local roman[600]=\"dc\"\n    local roman[700]=\"dcc\"\n    local roman[800]=\"\
    dccc\"\n    local roman[900]=\"cm\"\n    local roman[1000]=\"m\"\n    local num=$1\n\
    \n    echo -n \"${roman[${num}]}\"", "    if [[ -z \"$1\" ]]; then\n        echo\
    \ -e \"usage: $0 <integer>\" >&2\n        return 1\n    fi\n   \n    local -r\
    \ num=$1 \n    if [[ ! \"$num\" =~ ^[0-9]+$ ]]; then\n        echo -e \"error:\
    \ $0 requires an integer\" >&2\n        return 1\n    fi\n   \n    if [[ \"$num\"\
    \ -eq 0 ]]; then\n        echo -n \"\"\n        return 0\n    fi\n   \n    if\
    \ [[ \"$num\" -gt 1000 ]]; then\n        echo -e \"error: $0 can only produce\
    \ roman numerals up to 1000\" >&2\n        return 1\n    fi\n   \n    local -r\
    \ roman_numeral=(\n        [1]=\"i\" [5]=\"v\" [10]=\"x\" [50]=\"l\" [100]=\"\
    c\" [500]=\"d\" [1000]=\"m\"\n    )\n   \n    # get the length of the number\n\
    \    local -r num_length=${#num}\n   \n    # get the number of digits to the right\
    \ of the decimal place\n    local -r decimal_length=$((num_length - 1))\n   \n\
    \    # get the first digit\n    local -r first_digit=$(echo \"$num\" | cut -c1)\n\
    \   \n    # get the second digit (if it exists)\n    local -r second_digit=$(echo\
    \ \"$num\" | cut -c2)\n   \n    # get the third digit (if it exists)\n    local\
    \ -r third_digit=$(echo \"$num\" | cut -c3)\n   \n    # initialize the output\
    \ string\n    local output=\"\"\n   \n    # if there is only one digit\n    if\
    \ [[ \"$num_length\" -eq 1 ]]; then\n        # if that digit is 5 or less\n  \
    \      if [[ \"$first_digit\" -le 5 ]]; then\n            # concatenate that many\
    \ \"i\"s\n            output+=$(printf \"%${first_digit}s\" | tr \" \" \"${roman_numeral[1]}\"\
    )\n        else\n            # else subtract 5, and concatenate that many \"i\"\
    s followed by a \"v\"\n           ", "    local -a roman_numerals=(i iv v ix x\
    \ xl l xc c cd d cm m)\n    local -a divisors=(1 4 5 9 10 40 50 90 100 400 500\
    \ 900 1000)\n    local result=\"\"\n\n    for ((i=${#divisors[@]}-1; i>=0; i--));\
    \ do\n        while (( $1 >= ${divisors[i]} )); do\n            result+=${roman_numerals[i]}\n\
    \            (( $1 -= ${divisors[i]} ))\n        done\n    done\n\n    echo $result",
  "  local result\n  local -i n=$1\n  while (( n > 0 )); do\n    if (( n >= 1000 ));\
    \ then\n      result+=\"m\"\n      (( n -= 1000 ))\n    elif (( n >= 900 )); then\n\
    \      result+=\"cm\"\n      (( n -= 900 ))\n    elif (( n >= 500 )); then\n \
    \     result+=\"d\"\n      (( n -= 500 ))\n    elif (( n >= 400 )); then\n   \
    \   result+=\"cd\"\n      (( n -= 400 ))\n    elif (( n >= 100 )); then\n    \
    \  result+=\"c\"\n      (( n -= 100 ))\n    elif (( n >= 90 )); then\n      result+=\"\
    xc\"\n      (( n -= 90 ))\n    elif (( n >= 50 )); then\n      result+=\"l\"\n\
    \      (( n -= 50 ))\n    elif (( n >= 40 )); then\n      result+=\"xl\"\n   \
    \   (( n -= 40 ))\n    elif (( n >= 10 )); then\n      result+=\"x\"\n      ((\
    \ n -= 10 ))\n    elif (( n >= 9 )); then\n      result+=\"ix\"\n      (( n -=\
    \ 9 ))\n    elif (( n >= 5 )); then\n      result+=\"v\"\n      (( n -= 5 ))\n\
    \    elif (( n >= 4 )); then\n      result+=\"iv\"\n      (( n -= 4 ))\n    else\n\
    \      result+=\"i\"\n      (( n -= 1 ))\n    fi\n  done\n  echo \"$result\"",
  "  local -i x=$1\n  local -a map=([0]=\"\" [1]=\"i\" [2]=\"ii\" [3]=\"iii\" [4]=\"\
    iv\" [5]=\"v\" [6]=\"vi\" [7]=\"vii\" [8]=\"viii\" [9]=\"ix\")\n  printf '%s%s%s'\
    \ \"${map[$((x/100))]}\" \"${map[$((x/10%10))]}\" \"${map[$((x%10))]}\"", "  local\
    \ i=$1\n  if [[ $i -gt 1000 ]]; then\n    echo \"ERROR: given number is greater\
    \ than 1000\" >&2\n    return\n  fi\n  local -a romans=(\n    [1]=\"i\" [2]=\"\
    ii\" [3]=\"iii\" [4]=\"iv\" [5]=\"v\" [6]=\"vi\" [7]=\"vii\" [8]=\"viii\"\n  \
    \  [9]=\"ix\" [10]=\"x\" [20]=\"xx\" [30]=\"xxx\" [40]=\"xl\" [50]=\"l\" [60]=\"\
    lx\"\n    [70]=\"lxx\" [80]=\"lxxx\" [90]=\"xc\" [100]=\"c\" [200]=\"cc\" [300]=\"\
    ccc\"\n    [400]=\"cd\" [500]=\"d\" [600]=\"dc\" [700]=\"dcc\" [800]=\"dccc\"\
    \ [900]=\"cm\"\n    [1000]=\"m\"\n  )\n  local ans=\"\"\n  while [[ $i -gt 0 ]];\
    \ do\n    local -i f=$(( i % 10 ))\n    if [[ $f -gt 0 ]]; then\n      local -i\
    \ r=$(( f * 10 ** ((${#i} - 1))))\n      ans=\"${romans[$r]}$ans\"\n    fi\n \
    \   i=$(( i / 10 ))\n  done\n  echo \"$ans\"", "    declare -a ones=(\"i\" \"\
    x\" \"c\" \"m\")\n    declare -a fives=(\"v\" \"l\" \"d\")\n    declare -a tens=(\"\
    x\" \"c\" \"m\")\n    declare -a tens_nth=(\"x\" \"cc\" \"ccc\" \"cd\" \"d\" \"\
    dc\" \"dcc\" \"dccc\" \"cm\")\n    declare n\n    declare nth\n    declare index\n\
    \    declare ones_digit\n    declare tens_digit\n    declare hundreds_digit\n\
    \    declare thousands_digit\n    declare thousands_nth\n    declare tens_nth_digit\n\
    \    declare tens_nth_index\n    declare tens_nth_char\n    declare res\n    if\
    \ [[ \"$1\" =~ ^0*([1-9][0-9]{0,3})$ ]]; then\n        res=\"\"\n        n=\"\
    ${BASH_REMATCH[1]}\"\n        ones_digit=\"${n: -1}\"\n        tens_digit=\"${n:\
    \ -2: 1}\"\n        hundreds_digit=\"${n: -3: 1}\"\n        thousands_digit=\"\
    ${n: -4: 1}\"\n        # 4th digit\n        [[ \"$thousands_digit\" != \"0\" ]]\
    \ && \\\n            res+=\"$(int_to_mini_roman \"$thousands_digit\")m\"\n   \
    \     # 3rd digit\n        [[ \"$hundreds_digit\" != \"0\" ]] && \\\n        \
    \    res+=\"$(int_to_mini_roman \"$hundreds_digit\")c\"\n        # 2nd digit\n\
    \        if [[ \"$tens_digit\" != \"0\" ]]; then\n            if [[ \"$tens_digit\"\
    \ == [1-9] ]]; then\n                tens_nth_digit=\"$(($tens_digit - 1))\"\n\
    \                tens_nth_index=\"$(($tens_nth_digit * 2))\"\n               \
    \ tens_nth_char=\"${tens_nth[$tens_nth_index]}\"\n                res+=\"$tens_nth_char\"\
    \n            else\n                res+=\"${tens[1]}\"\n            fi\n    \
    \    fi\n        # 1st digit"]
stop_tokens:
- "\n}"
