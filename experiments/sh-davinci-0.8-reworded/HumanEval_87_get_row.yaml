name: HumanEval_87_get_row
language: sh
prompt: "#!/bin/bash\n# You are given a 2 dimensional data, as a nested lists,\n#\
  \ which is similar to matrix, however, unlike matrices,\n# each row may contain\
  \ a different number of columns.\n# Given lst, and integer x, find integers x in\
  \ the list,\n# and return list of lists, [(x1, y1), (x2, y2) ...] such that\n# each\
  \ list is a coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
  \ by rows in ascending order.\n# Also, sort coordinates of the row by columns in\
  \ descending order.\n# Examples:\n# >>> $(get_row \"1 2 3 4 5 6\\n1 2 3 4 1 6\\\
  n1 2 3 4 5 1\" \"1\")\n# [['\"0\"', '\"0\"'], ['\"1\"', '\"4\"'], ['\"1\"', '\"\
  0\"'], ['\"2\"', '\"5\"'], ['\"2\"', '\"0\"']]\n# >>> $(get_row \"\" \"1\")\n# []\n\
  # >>> $(get_row \"\\n1\\n1 2 3\" \"3\")\n# [['\"2\"', '\"2\"']]\n#\n# $1 is a newline-separated,\
  \ space-separated list\n# $2 is an integer\nget_row() {\n"
tests: "}\n\ncandidate() {\n    get_row \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
  \ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1 4\\\
  n1 0\\n2 5\\n2 0\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4\
  \ 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\" \"2\") = \"0 1\\n1 1\\n2 1\\n3\
  \ 1\\n4 1\\n5 1\" ]]\n    [[ $(candidate \"1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 1 3 4 5\
  \ 6\\n1 2 1 4 5 6\\n1 2 3 1 5 6\\n1 2 3 4 1 6\\n1 2 3 4 5 1\" \"1\") = \"0 0\\n1\
  \ 0\\n2 1\\n2 0\\n3 2\\n3 0\\n4 3\\n4 0\\n5 4\\n5 0\\n6 5\\n6 0\" ]]\n    [[ $(candidate\
  \ \"\" \"1\") = \"\" ]]\n    [[ $(candidate \"1\" \"2\") = \"\" ]]\n    [[ $(candidate\
  \ \"\\n1\\n1 2 3\" \"3\") = \"2 2\" ]]\n}\n\nrun_test"
completions: ["  # Put your code here\n  echo '[]'", "    local data=\"$1\"\n    local\
    \ pattern=\"$2\"\n    local IFS='\n'\n    local -a rows\n    local -a results\n\
    \    rows=($data)\n    local row_count=${#rows[@]}\n    local i=0\n    while [\
    \ $i -lt $row_count ]; do\n        local row=\"${rows[$i]}\"\n        local -a\
    \ cols\n        local -a cols\n        cols=($row)\n        local col_count=${#cols[@]}\n\
    \        local j=0\n        while [ $j -lt $col_count ]; do\n            local\
    \ col=\"${cols[$j]}\"\n            if [ \"$col\" = \"$pattern\" ]; then\n    \
    \            local pair=\"[\\\"$i\\\", \\\"$j\\\"]\"\n                results=(${results[@]}\
    \ $pair)\n            fi\n            j=$(($j + 1))\n        done\n        i=$(($i\
    \ + 1))\n    done\n    # sort results\n    local -a sorted_results\n    local\
    \ -a sorted_results\n    sorted_results=($(for r in ${results[@]}; do echo $r;\
    \ done | sort -r))\n    local result_str=\"[\"\n    for r in ${sorted_results[@]};\
    \ do\n        result_str=\"$result_str $r,\"\n    done\n    result_str=\"${result_str%\\\
    ,} ]\"\n    echo \"$result_str\"", "  if [[ -z \"$1\" ]]; then\n    printf \"\
    []\"\n    return\n  fi\n  local row=0\n  local res\n  for line in $1; do\n   \
    \ local col=0\n    for word in $line; do\n      if [[ \"$word\" == \"$2\" ]];\
    \ then\n        res+=($(printf \"[\\\"%s\\\", \\\"%s\\\"]\" \"$row\" \"$col\"\
    ))\n      fi\n      ((col++))\n    done\n    ((row++))\n  done\n  printf \"[%s]\"\
    \ \"$(IFS=,; echo \"${res[*]}\")\"", "    # Your code here\n    d=$(printf \"\
    $1\" | tr ' ' '\\n')\n    #echo $d\n    #echo $1\n    #echo $2\n    j=0\n    for\
    \ i in $d\n    do\n        #echo $i\n        if [ $i -eq $2 ]\n        then\n\
    \            #echo $(echo $j%$(echo $1 | wc -w) | bc)\n            echo -n \"\
    [\"\n            echo -n \"[\\\"\"\n            echo -n $((j/($(echo $1 | wc -w))))\n\
    \            echo -n \"\\\"\"\n            echo -n \", \\\"\"\n            echo\
    \ -n $(echo $j%$(echo $1 | wc -w) | bc)\n            echo -n \"\\\"]\"\n     \
    \       echo -n \",\"\n        fi\n        j=$((j+1))\n    done\n    #echo -n\
    \ \"[\"\n    #echo -n \"[\\\"\"\n    #echo -n $((j/($(echo $1 | wc -w))))\n  \
    \  #echo -n \"\\\"\"\n    #echo -n \", \\\"\"\n    #echo -n $(echo $j%$(echo $1\
    \ | wc -w) | bc)\n    #echo -n \"\\\"]\"\n    #echo -n \"]\"\n    echo", "  row=0\n\
    \  printf '%s\\n' \"$1\" | while read line; do\n    col=0\n    for element in\
    \ $line; do\n      if [ \"$element\" = \"$2\" ]; then\n        printf '[\"%s\"\
    , \"%s\"]\\n' \"$row\" \"$col\"\n      fi\n      col=$((col + 1))\n    done\n\
    \    row=$((row + 1))\n  done | sort -k 1 -t '\"' -g -k 2 -t '\"' -nr", "    local\
    \ ARRAY=()\n    while read -r line; do\n        ARRAY+=(\"$line\")\n    done <<<\
    \ \"$1\"\n    local r=0\n    local l=0\n    local x=$2\n    local LENGTH=${#ARRAY[@]}\n\
    \    local -a COORD=()\n    while [ $r -lt $LENGTH ]; do\n        local row=${ARRAY[$r]}\n\
    \        local -a row_array=($row)\n        local row_length=${#row_array[@]}\n\
    \        while [ $l -lt $row_length ]; do\n            if [ ${row_array[$l]} -eq\
    \ $x ]; then\n                COORD+=(\"['\\\"$r\\\"'\", \"'\\\"$l\\\"']\")\n\
    \            fi\n            l=$((l+1))\n        done\n        l=0\n        r=$((r+1))\n\
    \    done\n    local COORD_LENGTH=${#COORD[@]}\n    if [ $COORD_LENGTH -eq 0 ];\
    \ then\n        echo \"[]\"\n    else\n        sort -n -t '\"' -k 1 <<< ${COORD[@]}\n\
    \    fi", "  local lst=\"$1\"\n  local x=\"$2\"\n  local result=\"\"\n  while\
    \ read -r line; do\n    local x_index=0\n    for i in $line; do\n      if [[ \"\
    $i\" == \"$x\" ]]; then\n        result=\"$result $x_index\"\n      fi\n     \
    \ ((x_index++))\n    done\n  done <<< \"$lst\"\n  result=\"$(tr ' ' '\\n' <<<\
    \ \"$result\" | sort -r | xargs)\"\n  if [[ \"$result\" != \"\" ]]; then\n   \
    \ echo \"[$result]\"\n  else\n    echo \"[]\"\n  fi", "    echo '['\n    get_row_inner\
    \ $1 $2 | while read -r line; do\n        echo \"    [$line],\"\n    done\n  \
    \  echo ']'", "    awk -v x=\"$2\" 'BEGIN {RS=\" \"}  {for (i=1; i<=NF; i++) if\
    \ ($i == x) print \"[\\\"\" NR-1 \"\\\", \\\"\" i-1 \"\\\"]\"}' <<< \"$1\" | sort\
    \ -t',' -k1 -k2", "  lst=\"$1\"\n  x=\"$2\"\n  echo \"$lst\" | grep -n -w \"$x\"\
    \ | awk -F: '{printf \"[[\\\"%s\\\", \\\"%s\\\"]]\", $1 - 1, $(NF - 1)}' | tr\
    \ \"\\n\" \" \"", "    # Place your code here\n    # Please use echo for printing\
    \ each row\n    # as well as echo for printing the final output\n    x=\"$2\"\n\
    \    result=\"\"\n    for i in `echo \"$1\" | awk '{print $1}'`; do\n        if\
    \ [ \"$i\" = \"$x\" ]; then\n            result=\"$result\"\" [\\\"$(echo \"$1\"\
    \ | wc -l)\\\"\"\", \"$(echo \"$1\" | awk '{print $1}' | grep -nx \"$x\" | cut\
    \ -d\":\" -f1)\"\"]\"\n        fi\n        shift\n    done\n    echo \"$result\"",
  "  local input=\"$1\"\n  local num=\"$2\"\n  local row=\"$(jq -Mnr \"select(index([$input]\
    \ | transpose | map(contains([$num])) | index($num)) != null)\")\"\n  jq -Mnr\
    \ \"def f: map(split(\\\" \\\") | index($num) | if . == null then -1 else . end);\
    \ def col: [$input | transpose | map(contains([$num])) | index($num)]; def row:\
    \ [$input | f]; map(zip(row, col)) | select(.[1] != -1) | sort_by(.[0], .[1])\
    \ | map(. | tostring) | add\"", "  declare -i n=0\n  declare -i m=0\n  declare\
    \ -i i=0\n  declare -a l=()\n  declare -a t=()\n  declare -a a=()\n  while read\
    \ -r; do\n    while read -r; do\n      [ \"$REPLY\" = \"$2\" ] && a[i]=\"\\\"\
    $n\\\" \\\"$m\\\"\" && ((i++))\n      ((m++))\n    done <<< \"$REPLY\"\n    ((n++))\n\
    \    m=0\n  done <<< \"$1\"\n  for ((i=0; i<${#a[@]}; i++)); do\n    IFS=\" \"\
    \ read -r r c <<< \"${a[i]}\"\n    l[i]=$(($r*10+$c))\n  done\n  IFS=$'\\n' sorted=($(sort\
    \ <<<\"${l[*]}\"))\n  IFS=$'\\n'\n  for i in \"${sorted[@]}\"; do\n    IFS=\"\"\
    \n    t[i]=${a[i]}\n  done\n  echo \"[${t[*]}]\"", "  __lst=${1//\\n/ }\n  __x=$2\n\
    \  echo -n \"[\"\n  __j=0\n  for __i in $__lst; do\n    if [[ $__i == $__x ]];\
    \ then\n      echo -n \"[\\\"$__j\\\", \\\"$__k\\\"], \"\n    fi\n    let __k++\n\
    \    if [[ $__i == \"\" ]]; then\n      let __j++\n      __k=0\n    fi\n  done\n\
    \  echo -n \"]\"", "    [[ -z \"${1}\" ]] && echo \"[]\" && return\n    local\
    \ -r lst=\"${1}\"\n    local -r x=\"${2}\"\n    local -r rows=\"$(echo \"${lst}\"\
    \ | wc -l)\"\n    local -r cols=\"$(echo \"${lst}\" | head -n 1 | wc -w)\"\n \
    \   local -r x_idx=\"$(echo \"${lst}\" | grep -nF \"${x}\" | cut -d \":\" -f 1)\"\
    \n    [[ -z \"${x_idx}\" ]] && echo \"[]\" && return\n    local -a res\n    for\
    \ idx in ${x_idx}; do\n        res+=($((${idx}-1)) $(echo \"${lst}\" | head -n\
    \ ${idx} | tail -n 1 | grep -nF \"${x}\" | cut -d \":\" -f 1 | xargs -I {} echo\
    \ $((cols - {}))))\n    done\n    echo \"${res[@]}\" | xargs -n 2 | sort -n |\
    \ xargs -n 2 -I {} echo \"[{}]\"", "  local lst=\"$1\"\n  local x=\"$2\"\n  local\
    \ -i i=0\n  local -i j=0\n  echo \"[\"$(while read -r row; do\n    j=0\n    while\
    \ read -r e; do\n      if [[ \"$e\" == \"$x\" ]]; then\n        echo \"[\\\"$i\\\
    \", \\\"$j\\\"],\"\n      fi\n      ((j++))\n    done <<< \"$row\"\n    ((i++))\n\
    \  done <<< \"$lst\" | sort -g | sed 's/\\(.*\\),/\\1 /g' | sort -nr | sed 's/\
    \ //g')\"]\"", "    local -a ListMatrix\n    local -a CoordList\n    local -a\
    \ NoLeadingBlank\n    local RowNum\n    local ColNum\n    local -i i j\n    local\
    \ -i LongestRow\n    i=0\n    while read -r line; do\n        NoLeadingBlank=(${line})\n\
    \        if [[ ${#NoLeadingBlank[@]} -gt 0 ]]; then\n            ListMatrix[i]=\"\
    ${NoLeadingBlank[@]}\"\n            ((++i))\n        fi\n    done <<< \"${1}\"\
    \n    ((LongestRow=${#ListMatrix[@]}-1))\n    for ((i=0; i<=LongestRow; ++i));\
    \ do\n        for ((j=0; j<${#ListMatrix[i]}; ++j)); do\n            if [[ ${ListMatrix[i][j]}\
    \ -eq $2 ]]; then\n                RowNum=$i\n                ColNum=$j\n    \
    \            CoordList+=(\"[\\\"${RowNum}\\\" \\\"${ColNum}\\\"]\")\n        \
    \    fi\n        done\n    done\n    IFS=$'\\n'\n    CoordList=($(sort -t ' '\
    \ -k 1n,1 -k 2nr <<< \"${CoordList[*]}\"))\n    echo \"${CoordList[*]}\"", " \
    \   lst=''\n    IFS=$'\\n'\n    for i in $(echo -e \"$1\"); do\n        j=0\n\
    \        IFS=' '\n        for k in $i; do\n            if [ \"$k\" == \"$2\" ];\
    \ then\n                lst+=\"[\\\"$i\\\", \\\"$j\\\"] \"\n            fi\n \
    \           j=$((j+1))\n        done\n    done\n    echo -e $lst", "  local row=0\
    \ col=0\n  declare -A map\n  for pair in ${1// /$'\\n'}; do\n    if [[ $pair ==\
    \ $2 ]]; then\n      map[$row,$col]=1\n    fi\n    col=$((col+1))\n    if [[ $pair\
    \ == $'\\n' ]]; then\n      col=0\n      row=$((row+1))\n    fi\n  done\n  num_rows=$row\n\
    \  row=0\n  while [[ $row -lt $num_rows ]]; do\n    num_cols=0\n    while [[ -n\
    \ ${map[$row,$num_cols]} ]]; do\n      num_cols=$((num_cols+1))\n    done\n  \
    \  col=0\n    while [[ $col -lt $num_cols ]]; do\n      if [[ -n ${map[$row,$col]}\
    \ ]]; then\n        echo \"[\\\"$row\\\", \\\"$col\\\"]\"\n      fi\n      col=$((col+1))\n\
    \    done\n    row=$((row+1))\n  done", "  local arr=()\n  read -a arr <<< \"\
    $(echo \"$1\" | awk -v x=\"$2\" '{for(i=1;i<=NF;i++) if($i==x) print NR\"\\t\"\
    i}')\"\n  if [ ${#arr[@]} -gt 0 ]; then\n    IFS=\"\\t\" arr=($(echo \"${arr[*]}\"\
    \ | sort -k1,1n -k2,2nr))\n    IFS=\"\\n\" output=(\"[$(for row in \"${arr[@]}\"\
    ; do echo \"[\\\"${row//$'\\t'/\\\", \\\"}\\\"]\"; done)]\")\n    echo \"${output[*]}\"\
    \n  else\n    echo \"[]\"\n  fi"]
stop_tokens:
- "\n}"
