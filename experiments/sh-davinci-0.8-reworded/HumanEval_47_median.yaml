name: HumanEval_47_median
language: sh
prompt: "#!/bin/bash\n# Return median of elements in the list l.\n# >>> $(median \"\
  3 1 2 4 5\")\n# \"3\"\n# >>> $(median \"-10 4 6 1000 10 20\")\n# \"15.0\"\n#\n#\
  \ $1 is a space-separated list\nmedian() {\n"
tests: "}\n\ncandidate() {\n    median \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
  \ \"3 1 2 4 5\") = \"3\" ]]\n    [[ $(candidate \"-10 4 6 1000 10 20\") = \"8.0\"\
  \ ]]\n    [[ $(candidate \"5\") = \"5\" ]]\n    [[ $(candidate \"6 5\") = \"5.5\"\
  \ ]]\n    [[ $(candidate \"8 1 3 9 9 2 7\") = \"7\" ]]\n}\n\nrun_test"
completions: ["    local n=$(echo \"$1\" | wc -w)\n    if [ $(($n % 2)) -eq 1 ]; then\n\
    \        echo \"$1\" | awk '{ split($0,a); asort(a); print a[int(length(a)/2)+1]\
    \ }'\n    else\n        echo \"$1\" | awk '{ split($0,a); asort(a); print (a[int(length(a)/2)]+a[int(length(a)/2)+1])/2\
    \ }'\n    fi", "    awk '{a[NR]=$1; s+=$1} END {print (NR%2)?a[(NR+1)/2]:(a[NR/2]+a[NR/2+1])/2}'\
    \ <<< \"$1\"", "    _arr=($1)\n    _arr_len=${#_arr[@]}\n    _median_idx=$((_arr_len\
    \ / 2))\n    _arr_sorted=($(echo \"${_arr[@]}\" | tr ' ' '\\n' | sort -n))\n \
    \   echo ${_arr_sorted[$_median_idx]}", "  # Split input into an array\n  split=($1)\n\
    \  # Find the middle value of the array\n  arr_len=${#split[@]}\n  i=$((arr_len/2))\n\
    \  # Sort the array\n  sort=($(printf '%s\\n' \"${split[@]}\" | sort -n))\n  #\
    \ Return the middle value\n  # if there are an even number of values\n  # then\
    \ the median is the average of the two middle values\n  if (( arr_len % 2 == 0\
    \ )); then\n    echo \"$(echo \"scale=1; (${sort[$i-1]} + ${sort[$i]})/2\" | bc\
    \ -l)\"\n  else\n    echo \"${sort[$i]}\"\n  fi", "\tl=($(echo \"$1\" | sed 's/\
    \ /\\n/g' | sort -n))\n\tl=($(echo \"$1\" | sed 's/ /\\n/g' | sort -n))\n\t[ ${#l[@]}\
    \ -eq 0 ] && echo 0 && return\n\t[ ${#l[@]} -eq 1 ] && echo \"${l[0]}\" && return\n\
    \tl=($(echo \"$1\" | sed 's/ /\\n/g' | sort -n))\n\t[ ${#l[@]} -eq 0 ] && echo\
    \ 0 && return\n\t[ ${#l[@]} -eq 1 ] && echo \"${l[0]}\" && return\n\tmid=$(((${#l[@]}\
    \ + 1) / 2))\n\tif (($((${#l[@]} % 2)) == 0)); then\n\t\techo $(echo \"scale=1;\
    \ (${l[mid]} + ${l[mid-1]})/2\" | bc)\n\telse\n\t\techo \"${l[mid-1]}\"\n\tfi",
  "  local l=$1\n  s=($l)\n  s=($(echo ${s[*]} | tr ' ' '\\n' | sort -n))\n  local\
    \ m=${#s[@]}\n  let m=(m+1)/2\n  echo ${s[$m-1]}", "  awk -v LIST=\"$*\" '\n \
    \   { for (i=1; i<=NF; i++) l[i]=$i; }\n    END {\n      asort(l)\n      n = asorti(l)\n\
    \      if (n % 2 == 1)\n        # Length is odd, return the middle element.\n\
    \        print l[int((n+1)/2)]\n      else\n        # Length is even, return the\
    \ average of the two middle elements.\n        print (l[int(n/2)] + l[int(n/2)+1])\
    \ / 2\n    }\n  '", "    # List of values\n    l=$1\n    # Sorted list of values\n\
    \    l_sorted=($(echo \"$l\" | tr ' ' '\\n' | sort -n))\n    # Position of middle\
    \ element\n    middle=$(( ${#l_sorted[@]} / 2 ))\n    # If number of elements\
    \ is odd\n    if (( ${#l_sorted[@]} % 2 == 1 )); then\n        median=${l_sorted[$middle]}\n\
    \    # Else number of elements is even\n    else\n        median=$(echo \"scale=1;\
    \ (${l_sorted[$middle]} + ${l_sorted[$(( $middle - 1 ))]}) / 2\" | bc)\n    fi\n\
    \    echo \"$median\"", "    if [[ $# -eq 0 ]]; then\n        echo \"Empty list\"\
    \ >&2\n        return 1\n    fi\n    local vals=\"$@\"\n    local n=$(echo \"\
    $vals\" | wc -w)\n    local i=0\n    local sum=0\n    local val\n    for val in\
    \ $vals; do\n        sum=$(echo \"scale=9; $sum + $val\" | bc)\n    done\n   \
    \ local mean=$(echo \"scale=9; $sum / $n\" | bc)\n    local diffs=\n    for val\
    \ in $vals; do\n        local diff=$(echo \"scale=9; $val - $mean\" | bc)\n  \
    \      diffs=\"$diffs $diff\"\n    done\n    local diffs_sorted=$(echo \"$diffs\"\
    \ | sort -g)\n    local ind=$(echo \"scale=9; $n / 2\" | bc)\n    local ind_1=$(echo\
    \ \"scale=9; $ind - 1\" | bc)\n    local median\n    if [[ $n -gt 1 ]]; then\n\
    \        median=$(echo \"$diffs_sorted\" | awk 'NR=='\"$ind\" || NR=='\"$ind_1\"\
    \ | bc)\n        median=$(echo \"scale=9; $median / 2\" | bc)\n    else\n    \
    \    median=$(echo \"$diffs_sorted\" | awk 'NR=='\"$ind\")\n    fi\n    median=$(echo\
    \ \"scale=9; $median + $mean\" | bc)\n    echo \"$median\"", "    l=($(echo \"\
    $1\" | tr \" \" \"\\n\" | sort -n))\n    n=$((${#l[@]}-1))\n    s=0\n    m=$((($n+1)/2))\n\
    \    if [ $n -eq 0 ]; then\n        echo ${l[0]}\n    elif [ $((n%2)) -eq 0 ];\
    \ then\n        echo $(((${l[$m]}+${l[$m-1]})/2))\n    else\n        echo ${l[$m]}\n\
    \    fi", "    # Input array: 0 1 2 3 4 5 6 7\n    # Lowest elements: 0 1 2 3\
    \ 4 5 6 7\n    # Highest elements: 7 6 5 4 3 2 1 0\n    # Sorted array:    0 1\
    \ 2 3 4 5 6 7\n    local mid=${#@/2}\n    local l=(\"$@\")\n    med=$(printf '%s\\\
    n' \"${l[@]}\" | sort -n | awk \"NR==$mid{print;exit}\")\n    printf '%.1f\\n'\
    \ \"$med\"", "  readarray -t elems <<< \"$1\"\n  num_elem=${#elems[@]}\n  if ((\
    \ $num_elem % 2 == 1 )); then\n    # Odd number of elements\n    mid=$(( num_elem\
    \ / 2 ))\n    sort -n <<< \"$1\" | sed -n \"$((mid + 1))p\"\n  else\n    # Even\
    \ number of elements\n    mid1=$(( num_elem / 2 - 1 ))\n    mid2=$(( num_elem\
    \ / 2 ))\n    sort -n <<< \"$1\" | sed -n \"$((mid1 + 1)),$((mid2 + 1))p\" |\n\
    \      awk '{ sum += $1 } END { print sum / 2 }'\n  fi", "    local l=($(sort\
    \ -n <<<\"$1\"))\n    echo $l\n    local n=$((${#l[@]} / 2))\n    local r=($(echo\
    \ \"${l[$n]}\" | sed 's/ /\\n/g'))\n    echo $r\n    if (( ${#l[@]} % 2 )); then\n\
    \        echo \"${r[0]}\"\n    else\n        echo \"$((${r[0]} + ${r[1]}))\"\n\
    \    fi", "\tsorted=($(echo $1 | tr ' ' '\\n' | sort -n))\n\tlen=${#sorted[@]}\n\
    \tmid=`expr $len / 2`\n\tif [[ $len%2 -eq 0 ]]; then\n\t\techo $(echo \"scale=1;\
    \ (${sorted[$mid]} + ${sorted[$mid - 1]})/2\" | bc)\n\telse\n\t\techo ${sorted[$mid]}\n\
    \tfi", "  local n=$(echo $1 | wc -w)\n  if [ $((n % 2)) -eq 1 ]; then\n    echo\
    \ $(echo $1 | tr ' ' '\\n' | sort -n | head -n $((n / 2 + 1)) | tail -n 1)\n \
    \ else\n    echo $(echo $1 | tr ' ' '\\n' | sort -n | head -n $((n / 2)) | tail\
    \ -n 1)\n  fi", "    case $# in\n        0) # empty list -> \"-\"\n          \
    \  echo \"-\"\n            ;;\n        1) # singleton list -> $1\n           \
    \ echo \"$1\"\n            ;;\n        *) # list of at least two elements\n  \
    \          l=$(echo \"$@\" | tr ' ' '\\n' | sort -n)\n            n=$(echo \"\
    $l\" | wc -l)\n            if [ $(($n % 2)) -eq 1 ]; then\n                # odd\
    \ number of elements\n                echo \"$l\" | sed -n \"$(($n/2+1))p\"\n\
    \            else\n                # even number of elements -> return the average\
    \ of the two middle ones\n                v1=$(echo \"$l\" | sed -n \"$(($n/2))p\"\
    )\n                v2=$(echo \"$l\" | sed -n \"$((1+$n/2))p\")\n             \
    \   echo \"scale=1;(($v1+$v2)/2)\" | bc\n            fi\n            ;;\n    esac",
  "    # sort into ascending order\n    local p=$(echo $1 | sed -e 's/ /\\n/g' | sort\
    \ -n)\n    # count number of items in the list\n    local c=$(echo $p | wc -w)\n\
    \    # if number of items is odd, return middle item\n    if [ $(($c % 2)) -eq\
    \ 1 ]; then\n        echo $p | cut -d' ' -f$(($c / 2 + 1))\n    # if number of\
    \ items is even, return average of middle items\n    else\n        local m=$(($c\
    \ / 2))\n        local l=$(echo $p | cut -d' ' -f$m)\n        local r=$(echo $p\
    \ | cut -d' ' -f$(($m + 1)))\n        echo \"$(($l + $r)) / 2.0\" | bc -l\n  \
    \  fi", "    l=($1)\n    ll=${#l[@]}\n    if (( $ll > 0 )); then\n        s=(\"\
    ${l[@]}\")\n        if (( $ll > 1 )); then\n            unset 's[0]'\n       \
    \     s=($(echo \"${l[0]}\" $(echo \"${s[@]}\" | tr ' ' '\\n' | sort -n | tr '\\\
    n' ' ')))\n        fi\n        l_2=$(( $ll / 2 ))\n        if (( $ll % 2 == 1\
    \ )); then\n            echo \"${s[$l_2]}\"\n        else\n            echo \"\
    scale=1; (${s[$l_2]} + ${s[$(( $l_2 + 1 ))]}) / 2\" | bc\n        fi\n    fi",
  "    echo $(IFS=\" \"; printf \"%.1f\\n\" $(awk '{ print $1 }' <(sort -n <<<$1)\
    \ | awk 'NR%2{print -1*$0} NR%2==0{print+$0}'))", "  local l=$1\n  local n=$(echo\
    \ \"$l\" | wc -w)\n  local srt=$(echo \"$l\" | tr ' ' '\\n' | sort -n)\n  local\
    \ i=$((n/2))\n  if ((n%2 == 0)); then\n    echo \"($(echo \"$srt\" | head -n $i\
    \ | tail -n 1) + $(echo \"$srt\" | head -n $((i+1)) | tail -n 1))/2\" | bc -l\n\
    \  else\n    echo \"$srt\" | head -n $((i+1)) | tail -n 1\n  fi"]
stop_tokens:
- "\n}"
