name: HumanEval_47_median
language: sh
prompt: "#!/bin/bash\n# Return median of elements in the list l.\n# >>> $(median \"\
  3 1 2 4 5\")\n# \"3\"\n# >>> $(median \"-10 4 6 1000 10 20\")\n# \"15.0\"\n#\n#\
  \ $1 is a space-separated list\nmedian() {\n"
tests: "}\n\ncandidate() {\n    median \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
  \ \"3 1 2 4 5\") = \"3\" ]]\n    [[ $(candidate \"-10 4 6 1000 10 20\") = \"8.0\"\
  \ ]]\n    [[ $(candidate \"5\") = \"5\" ]]\n    [[ $(candidate \"6 5\") = \"5.5\"\
  \ ]]\n    [[ $(candidate \"8 1 3 9 9 2 7\") = \"7\" ]]\n}\n\nrun_test"
completions: ["    local n=$(echo \"$1\" | wc -w)\n    if [ $(($n % 2)) -eq 1 ]; then\n\
    \        echo \"$1\" | awk '{ split($0,a); asort(a); print a[int(length(a)/2)+1]\
    \ }'\n    else\n        echo \"$1\" | awk '{ split($0,a); asort(a); print (a[int(length(a)/2)]+a[int(length(a)/2)+1])/2\
    \ }'\n    fi", "    awk '{a[NR]=$1; s+=$1} END {print (NR%2)?a[(NR+1)/2]:(a[NR/2]+a[NR/2+1])/2}'\
    \ <<< \"$1\"", "    _arr=($1)\n    _arr_len=${#_arr[@]}\n    _median_idx=$((_arr_len\
    \ / 2))\n    _arr_sorted=($(echo \"${_arr[@]}\" | tr ' ' '\\n' | sort -n))\n \
    \   echo ${_arr_sorted[$_median_idx]}", "  # Split input into an array\n  split=($1)\n\
    \  # Find the middle value of the array\n  arr_len=${#split[@]}\n  i=$((arr_len/2))\n\
    \  # Sort the array\n  sort=($(printf '%s\\n' \"${split[@]}\" | sort -n))\n  #\
    \ Return the middle value\n  # if there are an even number of values\n  # then\
    \ the median is the average of the two middle values\n  if (( arr_len % 2 == 0\
    \ )); then\n    echo \"$(echo \"scale=1; (${sort[$i-1]} + ${sort[$i]})/2\" | bc\
    \ -l)\"\n  else\n    echo \"${sort[$i]}\"\n  fi", "\tl=($(echo \"$1\" | sed 's/\
    \ /\\n/g' | sort -n))\n\tl=($(echo \"$1\" | sed 's/ /\\n/g' | sort -n))\n\t[ ${#l[@]}\
    \ -eq 0 ] && echo 0 && return\n\t[ ${#l[@]} -eq 1 ] && echo \"${l[0]}\" && return\n\
    \tl=($(echo \"$1\" | sed 's/ /\\n/g' | sort -n))\n\t[ ${#l[@]} -eq 0 ] && echo\
    \ 0 && return\n\t[ ${#l[@]} -eq 1 ] && echo \"${l[0]}\" && return\n\tmid=$(((${#l[@]}\
    \ + 1) / 2))\n\tif (($((${#l[@]} % 2)) == 0)); then\n\t\techo $(echo \"scale=1;\
    \ (${l[mid]} + ${l[mid-1]})/2\" | bc)\n\telse\n\t\techo \"${l[mid-1]}\"\n\tfi",
  "  local l=$1\n  s=($l)\n  s=($(echo ${s[*]} | tr ' ' '\\n' | sort -n))\n  local\
    \ m=${#s[@]}\n  let m=(m+1)/2\n  echo ${s[$m-1]}", "  awk -v LIST=\"$*\" '\n \
    \   { for (i=1; i<=NF; i++) l[i]=$i; }\n    END {\n      asort(l)\n      n = asorti(l)\n\
    \      if (n % 2 == 1)\n        # Length is odd, return the middle element.\n\
    \        print l[int((n+1)/2)]\n      else\n        # Length is even, return the\
    \ average of the two middle elements.\n        print (l[int(n/2)] + l[int(n/2)+1])\
    \ / 2\n    }\n  '", "    # List of values\n    l=$1\n    # Sorted list of values\n\
    \    l_sorted=($(echo \"$l\" | tr ' ' '\\n' | sort -n))\n    # Position of middle\
    \ element\n    middle=$(( ${#l_sorted[@]} / 2 ))\n    # If number of elements\
    \ is odd\n    if (( ${#l_sorted[@]} % 2 == 1 )); then\n        median=${l_sorted[$middle]}\n\
    \    # Else number of elements is even\n    else\n        median=$(echo \"scale=1;\
    \ (${l_sorted[$middle]} + ${l_sorted[$(( $middle - 1 ))]}) / 2\" | bc)\n    fi\n\
    \    echo \"$median\"", "    if [[ $# -eq 0 ]]; then\n        echo \"Empty list\"\
    \ >&2\n        return 1\n    fi\n    local vals=\"$@\"\n    local n=$(echo \"\
    $vals\" | wc -w)\n    local i=0\n    local sum=0\n    local val\n    for val in\
    \ $vals; do\n        sum=$(echo \"scale=9; $sum + $val\" | bc)\n    done\n   \
    \ local mean=$(echo \"scale=9; $sum / $n\" | bc)\n    local diffs=\n    for val\
    \ in $vals; do\n        local diff=$(echo \"scale=9; $val - $mean\" | bc)\n  \
    \      diffs=\"$diffs $diff\"\n    done\n    local diffs_sorted=$(echo \"$diffs\"\
    \ | sort -g)\n    local ind=$(echo \"scale=9; $n / 2\" | bc)\n    local ind_1=$(echo\
    \ \"scale=9; $ind - 1\" | bc)\n    local median\n    if [[ $n -gt 1 ]]; then\n\
    \        median=$(echo \"$diffs_sorted\" | awk 'NR=='\"$ind\" || NR=='\"$ind_1\"\
    \ | bc)\n        median=$(echo \"scale=9; $median / 2\" | bc)\n    else\n    \
    \    median=$(echo \"$diffs_sorted\" | awk 'NR=='\"$ind\")\n    fi\n    median=$(echo\
    \ \"scale=9; $median + $mean\" | bc)\n    echo \"$median\"", "    l=($(echo \"\
    $1\" | tr \" \" \"\\n\" | sort -n))\n    n=$((${#l[@]}-1))\n    s=0\n    m=$((($n+1)/2))\n\
    \    if [ $n -eq 0 ]; then\n        echo ${l[0]}\n    elif [ $((n%2)) -eq 0 ];\
    \ then\n        echo $(((${l[$m]}+${l[$m-1]})/2))\n    else\n        echo ${l[$m]}\n\
    \    fi", "    # Input array: 0 1 2 3 4 5 6 7\n    # Lowest elements: 0 1 2 3\
    \ 4 5 6 7\n    # Highest elements: 7 6 5 4 3 2 1 0\n    # Sorted array:    0 1\
    \ 2 3 4 5 6 7\n    local mid=${#@/2}\n    local l=(\"$@\")\n    med=$(printf '%s\\\
    n' \"${l[@]}\" | sort -n | awk \"NR==$mid{print;exit}\")\n    printf '%.1f\\n'\
    \ \"$med\"", "  readarray -t elems <<< \"$1\"\n  num_elem=${#elems[@]}\n  if ((\
    \ $num_elem % 2 == 1 )); then\n    # Odd number of elements\n    mid=$(( num_elem\
    \ / 2 ))\n    sort -n <<< \"$1\" | sed -n \"$((mid + 1))p\"\n  else\n    # Even\
    \ number of elements\n    mid1=$(( num_elem / 2 - 1 ))\n    mid2=$(( num_elem\
    \ / 2 ))\n    sort -n <<< \"$1\" | sed -n \"$((mid1 + 1)),$((mid2 + 1))p\" |\n\
    \      awk '{ sum += $1 } END { print sum / 2 }'\n  fi", "    local l=($(sort\
    \ -n <<<\"$1\"))\n    echo $l\n    local n=$((${#l[@]} / 2))\n    local r=($(echo\
    \ \"${l[$n]}\" | sed 's/ /\\n/g'))\n    echo $r\n    if (( ${#l[@]} % 2 )); then\n\
    \        echo \"${r[0]}\"\n    else\n        echo \"$((${r[0]} + ${r[1]}))\"\n\
    \    fi", "\tsorted=($(echo $1 | tr ' ' '\\n' | sort -n))\n\tlen=${#sorted[@]}\n\
    \tmid=`expr $len / 2`\n\tif [[ $len%2 -eq 0 ]]; then\n\t\techo $(echo \"scale=1;\
    \ (${sorted[$mid]} + ${sorted[$mid - 1]})/2\" | bc)\n\telse\n\t\techo ${sorted[$mid]}\n\
    \tfi", "  local n=$(echo $1 | wc -w)\n  if [ $((n % 2)) -eq 1 ]; then\n    echo\
    \ $(echo $1 | tr ' ' '\\n' | sort -n | head -n $((n / 2 + 1)) | tail -n 1)\n \
    \ else\n    echo $(echo $1 | tr ' ' '\\n' | sort -n | head -n $((n / 2)) | tail\
    \ -n 1)\n  fi", "    case $# in\n        0) # empty list -> \"-\"\n          \
    \  echo \"-\"\n            ;;\n        1) # singleton list -> $1\n           \
    \ echo \"$1\"\n            ;;\n        *) # list of at least two elements\n  \
    \          l=$(echo \"$@\" | tr ' ' '\\n' | sort -n)\n            n=$(echo \"\
    $l\" | wc -l)\n            if [ $(($n % 2)) -eq 1 ]; then\n                # odd\
    \ number of elements\n                echo \"$l\" | sed -n \"$(($n/2+1))p\"\n\
    \            else\n                # even number of elements -> return the average\
    \ of the two middle ones\n                v1=$(echo \"$l\" | sed -n \"$(($n/2))p\"\
    )\n                v2=$(echo \"$l\" | sed -n \"$((1+$n/2))p\")\n             \
    \   echo \"scale=1;(($v1+$v2)/2)\" | bc\n            fi\n            ;;\n    esac",
  "    # sort into ascending order\n    local p=$(echo $1 | sed -e 's/ /\\n/g' | sort\
    \ -n)\n    # count number of items in the list\n    local c=$(echo $p | wc -w)\n\
    \    # if number of items is odd, return middle item\n    if [ $(($c % 2)) -eq\
    \ 1 ]; then\n        echo $p | cut -d' ' -f$(($c / 2 + 1))\n    # if number of\
    \ items is even, return average of middle items\n    else\n        local m=$(($c\
    \ / 2))\n        local l=$(echo $p | cut -d' ' -f$m)\n        local r=$(echo $p\
    \ | cut -d' ' -f$(($m + 1)))\n        echo \"$(($l + $r)) / 2.0\" | bc -l\n  \
    \  fi", "    l=($1)\n    ll=${#l[@]}\n    if (( $ll > 0 )); then\n        s=(\"\
    ${l[@]}\")\n        if (( $ll > 1 )); then\n            unset 's[0]'\n       \
    \     s=($(echo \"${l[0]}\" $(echo \"${s[@]}\" | tr ' ' '\\n' | sort -n | tr '\\\
    n' ' ')))\n        fi\n        l_2=$(( $ll / 2 ))\n        if (( $ll % 2 == 1\
    \ )); then\n            echo \"${s[$l_2]}\"\n        else\n            echo \"\
    scale=1; (${s[$l_2]} + ${s[$(( $l_2 + 1 ))]}) / 2\" | bc\n        fi\n    fi",
  "    echo $(IFS=\" \"; printf \"%.1f\\n\" $(awk '{ print $1 }' <(sort -n <<<$1)\
    \ | awk 'NR%2{print -1*$0} NR%2==0{print+$0}'))", "  local l=$1\n  local n=$(echo\
    \ \"$l\" | wc -w)\n  local srt=$(echo \"$l\" | tr ' ' '\\n' | sort -n)\n  local\
    \ i=$((n/2))\n  if ((n%2 == 0)); then\n    echo \"($(echo \"$srt\" | head -n $i\
    \ | tail -n 1) + $(echo \"$srt\" | head -n $((i+1)) | tail -n 1))/2\" | bc -l\n\
    \  else\n    echo \"$srt\" | head -n $((i+1)) | tail -n 1\n  fi", "    (\n   \
    \     IFS=' ' read -r -a array <<< \"$1\"\n        arr=($(printf '%f\\n' \"${array[@]}\"\
    \ | sort -n))\n        printf '%.0f\\n' \"${arr[${#arr[@]}/2]}\"\n    )", "  \
    \  l=($1)\n    n=${#l[@]}\n    i=$(($n/2))\n    if [ $((n%2)) -eq 0 ]; then\n\
    \        echo \"$((${l[$i]}+${l[$((i-1))]}))/2.0\" | bc -l\n    else\n       \
    \ echo \"${l[$i]}\"\n    fi", "    echo $(echo $1 | tr \" \" \"\\n\" | sort -n\
    \ | awk '\n        BEGIN {\n            t = 0\n        }\n        {\n        \
    \    a[t++] = $1\n        }\n        END {\n            if (t%2 == 1) {\n    \
    \            print a[int(t/2)]\n            } else {\n                print (a[t/2]\
    \ + a[t/2-1])/2\n            }\n        }\n    ')", "  local l=($1)\n  printf\
    \ \"%.1f\" $(awk '\n    BEGIN {\n      # bubble sort from https://stackoverflow.com/a/34073963/1420243\n\
    \      for (i = 1; i <= length(a); i++) {\n        for (j = 1; j <= length(a);\
    \ j++) {\n          if (a[j] > a[j+1]) {\n            tmp = a[j]\n           \
    \ a[j] = a[j+1]\n            a[j+1] = tmp\n          }\n        }\n      }\n \
    \     if (length(a) % 2 == 0) {\n        # even\n        print (a[length(a)/2]\
    \ + a[length(a)/2+1]) / 2\n      } else {\n        # odd\n        print a[(length(a)+1)/2]\n\
    \      }\n    }\n    { a[length(a)+1] = $1 }\n  ' <<< \"${l[*]}\")", "    L=$@\n\
    \    n=$(echo $L | tr ' ' '\\n' | wc -l)\n    nhalf=$((n/2))\n    echo $L | tr\
    \ ' ' '\\n' | sort -n | head -n $nhalf | tail -n 1", "    median=\"$( echo \"\
    $@\" | tr ' ' '\\n' | sort -n | awk 'NR%2==0{print($0+$(NR-1))/2;exit}' )\"\n\
    \    echo \"$median\"", "  local l=(${*// / })\n  local list=$(echo \"${l[*]}\"\
    \ | tr ' ' '\\n' | sort -n)\n  local i\n  local m=$(( ${#l[@]} / 2 ))\n  IFS='\
    \ ' read -r -a array <<< \"$list\"\n  if (( ${#l[@]} % 2 == 1 )); then\n    echo\
    \ \"${array[$m]}\"\n  else\n    echo \"$( echo \"scale=1; (${array[$m-1]} + ${array[$m]})/2\"\
    \ | bc )\"\n  fi", "  l=($1)\n  if [ -z \"$l\" ]; then\n    echo \"0\"\n  else\n\
    \    # sort elements in increasing order\n    sorted=($(echo ${l[@]} | tr ' '\
    \ '\\n' | sort -n))\n    count=${#sorted[@]}\n    if [ $(($count % 2)) -eq 1 ];\
    \ then\n      # If length is odd, return middle element.\n      echo ${sorted[$(($count\
    \ / 2))]}\n    else\n      # If length is even, return average of middle two elements.\n\
    \      echo $((${sorted[$(($count / 2))]} + ${sorted[$(($count / 2 - 1))]}))\n\
    \      #echo $(echo \"${sorted[$(($count / 2))]} + ${sorted[$(($count / 2 - 1))]}\"\
    \ | bc -l)\n    fi\n  fi", "    local l=($(sort -n <<< \"$1\"))\n    local n=$((\
    \ ${#l[@]} / 2 ))\n    echo \"${l[$n]}\"", "  local values=$(echo \"$1\" | tr\
    \ ' ' '\\n' | sort -n)\n  local len=$(echo \"$values\" | wc -l)\n  if [ \"$(($len\
    \ % 2))\" = \"0\" ]; then\n    echo \"$(echo \"$values\" | head -n $(($len / 2))\
    \ | tail -n 1)\";\n  else\n    echo \"$(($(echo \"$values\" | head -n $(($len\
    \ / 2 + 1)) | tail -n 1) + $(echo \"$values\" | head -n $(($len / 2)) | tail -n\
    \ 1))) / 2.0\";\n  fi", "    local m\n    m=$((${#1}/2))\n    local sorted=($(sort\
    \ <<< \"$1\"))\n    local middle=\"${sorted[m]}\"\n    local lower=\"${sorted[$(($m-1))]}\"\
    \n    if (( ${#1} % 2 == 0 )); then\n        # even\n        echo \"$(echo \"\
    $lower+$middle\" | bc -l)/2\"\n    else\n        # odd\n        echo \"$middle\"\
    \n    fi", "    local list=\"\"\n    local i=\"\"\n    for i in $@; do\n     \
    \   list+=\" $i\"\n    done\n    list=$(echo $list | tr ' ' '\\n' | sort -n |\
    \ awk '\n    {\n        if (NR == 1) {\n            min = $1;\n            max\
    \ = $1;\n            len = 1;\n            sum = $1;\n        } else {\n     \
    \       if ($1 > max) max = $1;\n            if ($1 < min) min = $1;\n       \
    \     len++;\n            sum += $1;\n        }\n    }\n    END {\n        if\
    \ (len % 2 == 1) {\n            print $1;\n        } else {\n            print\
    \ (sum - min - max) / (len - 2);\n        }\n    }\n')", "    local l=$1\n   \
    \ local r=\"\"\n    local m=\"\"\n    local i=\"\"\n    local n=\"\"\n    local\
    \ tmp=\"\"\n    # Copy the list and sort it\n    r=$(echo \"$l\" | tr ' ' '\\\
    n' | sort -n)\n    n=$(echo \"$r\" | wc -l)\n    # Handle even number of elements\n\
    \    if [[ $((n % 2)) == 0 ]]; then\n        tmp=$(echo \"$r\" | tail -n $(($n\
    \ / 2)))\n        i=$(echo \"$tmp\" | head -n 1)\n        m=$(echo \"$tmp\" |\
    \ tail -n 1)\n        echo $(echo \"scale=1; ($i + $m) / 2\" | bc)\n    # Handle\
    \ odd number of elements\n    else\n        m=$(echo \"$r\" | tail -n $(($n /\
    \ 2 + 1)))\n        echo \"$m\"\n    fi", "    echo \"$1\" | python -c \"import\
    \ sys; print('%.1f' % (sorted(map(float, sys.stdin.read().split()))[int(len(sys.stdin.read().split())/2)]))\"",
  "  local -a list\n  read -a list <<< \"$1\"\n  list=(\"${list[@]/#/-n}\")\n  list=(\"\
    ${list[@]/%/ | sort -n}\")\n  list=$(echo \"${list[*]}\")\n  printf %.1f $(($list\
    \ | awk '{print $int(($NF+1)/2)}'))", "    l=(\"$@\")\n    # sort\n    for ((i=0;\
    \ i<$#; i++)); do\n        for ((j=i+1; j<=$#; j++)); do\n            [[ ${l[j]}\
    \ < ${l[i]} ]] && tmp=${l[i]} && l[i]=${l[j]} && l[j]=$tmp\n        done\n   \
    \ done\n    # get median\n    if (( $# % 2 == 1 )); then\n        echo ${l[$((\
    \ $# / 2 ))]}\n    else\n        echo \"$(echo \"scale=1; ${l[$(( $# / 2 - 1 ))]}\
    \ + ${l[$(( $# / 2 ))]} / 2\" | bc)\"\n    fi", "    l=($1)\n    # len(l)\n  \
    \  n=$(echo \"${#l[@]}\")\n    # sort(l)\n    IFS=$'\\n' sorted=($(sort <<<\"\
    ${l[*]}\"))\n    unset IFS\n    # index of middle element\n    middle=$((n/2))\n\
    \    # mean of two middle element if len(l) is even\n    if ((n%2==0)); then\n\
    \        echo $(((sorted[middle-1]+sorted[middle])/2))\n    else\n        echo\
    \ ${sorted[middle]}\n    fi", "    local l=${1}\n    local t\n    local m\n  \
    \  t=($(echo \"${l}\" | xargs -n1 | sort -n))\n    m=$((${#t[@]} / 2))\n    if\
    \ ((${#t[@]} % 2 == 0)); then\n        echo \"scale=2;(${t[m-1]} + ${t[m]}) /\
    \ 2\" | bc\n    else\n        echo \"${t[m]}\"\n    fi", "  arr=($@)\n  sz=${#arr[@]}\n\
    \  if ((sz == 0)); then\n    echo 0\n    return\n  fi\n  n=$(($sz / 2))\n  if\
    \ ((sz % 2 == 0)); then\n    echo $(awk \"BEGIN {print (${arr[$n]} + ${arr[$((n\
    \ - 1))]})/2 }\")\n  else\n    echo ${arr[$n]}\n  fi", "  l=($1)\n  sort -n \"\
    ${l[@]}\" | awk '{ if(NR%2) printf(\"%s\\n\", $0); else printf(\"%.1f\\n\", ($0+$(NR+1))/2);\
    \ }'", "\tl=(\"$@\")\n\ts=$(for a in \"${l[@]}\"; do echo $a; done | sort -n)\n\
    \techo ${s[$((${#s[@]} / 2))]}", "    l=($(sort -n <<< \"$1\"))\n    n=${#l[@]}\n\
    \    # Odd number of elements?\n    if ((n & 1)); then\n        echo ${l[((n /\
    \ 2))]}\n    else\n        # Even number of elements: take the average of the\
    \ two middle values\n        ((ind = n / 2))\n        echo $(((${l[$ind]} + ${l[$((ind\
    \ - 1))]}) / 2))\n    fi", "    echo $(python -c \"\nimport sys\nl = map(int,\
    \ '$1'.split())\nm = len(l) / 2\nl.sort()\nif m * 2 != len(l):\n    print l[m]\n\
    else:\n    print (l[m - 1] + l[m]) / 2.0\n\")", "    sort -n \"$@\" | awk ' {\
    \ a[i++]=$1; } END { print a[int(i/2)]; }'", "    local l=(${1})\n    local m=${#l[@]}\n\
    \    local mid=`echo \"scale=0; $m/2\" | bc`\n    local left=$(($mid-1))\n   \
    \ local right=$(($mid+1))\n    if [ \"$m\" -eq \"1\" ]; then\n        echo ${l[0]}\n\
    \    elif [ \"$m\" -eq \"2\" ]; then\n        echo \"scale=2; (${l[0]}+${l[1]})/2\"\
    \ | bc\n    elif [ \"$m\" -ge \"3\" ]; then\n        l=($(printf '%s\\n' \"${l[@]}\"\
    \ | sort -n))\n        if [ $(($m%2)) -eq \"0\" ]; then\n            echo \"scale=2;\
    \ (${l[$left]}+${l[$right]})/2\" | bc\n        else\n            echo ${l[$mid]}\n\
    \        fi\n    fi", "  # Convert the arguments to an array, avoiding behavior\
    \ of read -a\n  local arg_array=($@)\n  # Sort the elements of the array\n  IFS=$'\\\
    n' sorted=($(sort <<<\"${arg_array[*]}\"))\n  unset IFS\n  # Get the length of\
    \ the array\n  local length=${#sorted[@]}\n  # If the length is odd,\n  if ((\
    \ length % 2 == 1 )); then\n    # Return the element in the middle\n    echo ${sorted[\
    \ $(( length / 2 )) ]}\n  # Otherwise,\n  else\n    # Return the average of the\
    \ two middle elements\n    echo $(( (${sorted[$(( length / 2 - 1 ))]} + ${sorted[$((\
    \ length / 2 ))]}) / 2 ))\n  fi", "    echo \"$@\" |\n    tr ' ' '\\n' |\n   \
    \ sort -n |\n    perl -e '$n=<>;@a=<>;$med=(($n%2)==1)?$a[int($n/2)]:(($a[$n/2]+$a[$n/2-1])/2);print\
    \ \"$med\\n\"'", "    # Sort into non-decreasing order.\n    local l=$(echo $*\
    \ | tr ' ' '\\n' | sort -n)\n    local len=$(echo $l | wc -w)\n    # Median is\
    \ an element in the middle.\n    if [ $(($len % 2)) == 1 ]; then\n        echo\
    \ $l | cut -d \" \" -f $(($len/2+1))\n    # Median is the average of the two middle\
    \ elements.\n    else\n        echo $(($(echo $l | cut -d \" \" -f $(($len/2)))+$(echo\
    \ $l | cut -d \" \" -f $(($len/2+1))))) | awk '{printf \"%.1f\", $1/2}'\n    fi",
  "    if [[ $# = 0 ]]; then\n        echo \"0\"\n    elif [[ $# = 1 ]]; then\n  \
    \      echo \"$1\"\n    else\n        s=(\"$@\")\n        sa=$( IFS=$'\\n'; echo\
    \ \"${s[*]}\" | sort -n )\n        n=$( IFS=$'\\n'; echo \"${s[*]}\" | wc -l )\n\
    \        if (( n % 2 == 1 )); then\n            echo \"$sa\" | sed -n \"$(( n\
    \ / 2 + 1 ))p\"\n        else\n            echo \"$sa\" | sed -n \"$(( n / 2 ))p\"\
    \ | awk '{ print $1 + 0.5 * ($2 - $1) }'\n        fi\n    fi", "    local arr\
    \ l=$1\n    arr=(${l})\n    arr=($(for i in \"${arr[@]}\"; do\n        echo \"\
    $i\"\n    done | sort -n))\n    nel=${#arr[@]}\n    if (( $nel % 2 == 1 )); then\
    \     # Odd number of elements\n        val=\"${arr[ $(($nel/2)) ]}\"\n    else\
    \                            # Even number of elements\n        (( j=nel/2 ))\n\
    \        (( k=j-1 ))\n        (( val=(${arr[j]} + ${arr[k]})/2))\n    fi\n   \
    \ echo $val", "    printf \"%.1f\" $(echo \"$1\" | tr ' ' '\\n' | sort -n | awk\
    \ '{ a[i++]=$1; } END { print (a[int(i/2)] + a[int(i/2-1)])/2; }')", "  echo $(echo\
    \ $1 | tr \" \" \"\\n\" | sort -n | awk '\n  {\n    N=NR-1\n    if(N%2==0) {\n\
    \      a[N/2];\n      next\n    }\n    a[(N+1)/2]\n  }\n  END {print (a[NR/2-1]+a[NR/2])/2}')",
  "  local a=$(echo \"$@\" | tr ' ' '\\n' | sort -n | sed 's/$/ +/' | tr -d '\\n')\n\
    \  echo $(( $a 0 ))", "  local l=$1\n  # get the list in ascending order\n  l=$(echo\
    \ \"$l\" | tr ' ' '\\n' | sort -n)\n  # get the size of the list\n  len=$(echo\
    \ \"$l\" | wc -w)\n  # if list has odd length\n  if [ \"$(($len%2))\" = \"1\"\
    \ ]; then\n    # get the middle value\n    mid=$(echo \"$l\" | tr ' ' '\\n' |\
    \ sed -n \"$(($len/2+1))p\")\n  else\n    # otherwise, get the sum of the two\
    \ values in the middle\n    mid=$(echo \"$l\" | tr ' ' '\\n' | sed -n \"$(($len/2))p\"\
    )\n    mid=$(echo \"$mid + $(echo \"$l\" | tr ' ' '\\n' | sed -n \"$(($len/2+1))p\"\
    )\" | bc)\n    # then, get the average\n    mid=$(echo \"scale=1; $mid/2\" | bc)\n\
    \  fi\n  echo \"$mid\"", "    l=($@)\n    echo $@\n    len=${#l[@]}\n    if ((\
    \ $len % 2 == 1 )); then\n        let mid=len/2\n        echo \"len=$len mid=$mid\"\
    \n        echo ${l[$mid]}\n    else\n        let mid=(len-1)/2\n        echo \"\
    (${l[$mid]} + ${l[$mid+1]})/2\" | bc -l\n    fi", "    local l s=()\n    read\
    \ -ra l <<<\"$1\"\n    for v in \"${l[@]}\"; do s+=($v); done\n    sort -n <<<\"\
    ${s[*]}\" |\n        perl -nle '\n            @a=sort{$a<=>$b} split;\n      \
    \      $m=int(@a/2);\n            print $a[$m];\n            if(@a%2==0){print\
    \ ($a[$m-1]+$a[$m])/2}'", "    l=($@)\n    echo ${l[*]} | tr ' ' '\\n' | sort\
    \ -n | awk '\n    BEGIN { n = 0 }\n    { v[n++] = $1 }\n    END {\n        if\
    \ (n % 2 == 1) {\n            print v[int(n/2)]\n        } else {\n          \
    \  print (v[n/2-1] + v[n/2]) / 2\n        }\n    }'", "    echo $@ | awk '{ a[i++]=$1;\
    \ } END { print \"sorted: \" a[int((i+1)/2)] \" \" a[int(i/2)]; print \"original:\
    \ \" (a[int((i+1)/2)] + a[int(i/2)])/2; }'", "  t=$(mktemp)\n  for i in $1; do\n\
    \    echo \"$i\" >> $t\n  done\n  sort -n $t | awk ' { a[i++]=$1; } END { print\
    \ a[int(i/2)]; }'\n  rm $t", "  local m=$1\n  shift\n  local l=(\"$@\")\n  local\
    \ tmp\n  local m_idx\n  local len\n\n  len=${#l[@]}\n  if (($len == 0)); then\n\
    \    m=0\n  elif (($len == 1)); then\n    m=${l[0]}\n  else\n    m_idx=$((len\
    \ / 2))\n    if (($len % 2 == 0)); then\n      m=$(echo \"scale=1; (${l[$m_idx\
    \ - 1]} + ${l[$m_idx]}) / 2\" | bc)\n    else\n      m=${l[$m_idx]}\n    fi\n\
    \  fi\n  echo $m", "  local m l=(\"$@\")\n  (( ${#l[@]} == 0 )) && return\n  echo\
    \ \"${l[@]}\" | tr ' ' '\\n' | sort -n | awk '{l[NR]=$0}END{m=NR%2;a=int(NR/2);print\
    \ (m?l[a+1]:(l[a]+l[a+1])/2)}'", "    local l=(\"$@\")\n    local i j m=$(( ($#+1)/2\
    \ ))\n\n    # A `quicksort' implementation.\n    for ((i=0; i<$#; i++)); do\n\
    \        for ((j=i; j<$#; j++)); do\n            if [[ ${l[j]} -lt ${l[i]} ]];\
    \ then\n                local x=${l[i]}\n                l[i]=${l[j]}\n      \
    \          l[j]=$x\n            fi\n        done\n    done\n\n    echo ${l[$m]}",
  "    if [ $# -gt 1 ]; then\n        export LC_ALL=C # make sure sort uses decimal\
    \ points\n        arr=($(echo $@ | tr \" \" \"\\n\" | sort -n))\n        n=$#\n\
    \        result=$(echo \"scale=1; ( ${arr[$(($n/2))]} + ${arr[$(($n/2 - 1))]}\
    \ ) / 2\" | bc)\n        echo $result\n    else\n        echo $1\n    fi", " \
    \ local mid=$(( ($(wc -w <<<\"$1\") + 1) / 2 ))\n  local sorted=$(echo \"$1\"\
    \ | tr ' ' '\\n' | sort -n)\n  i=1\n  while read -r num; do\n    if [ \"$i\" -eq\
    \ \"$mid\" ]; then\n      echo \"$num\"\n      break\n    fi\n    i=$((i + 1))\n\
    \  done <<<\"$sorted\"", "    local l=($(echo \"$*\" | tr ' ' '\\n' | sort -n))\n\
    \    local mid=${#l[@]}/2\n    local median\n    if (( $mid*2 == ${#l[@]} ));\
    \ then\n        # Even number of elements\n        local m1=${l[$mid]}\n     \
    \   local m2=${l[$mid-1]}\n        median=$(echo \"scale=4;($m1+$m2)/2\" | bc)\n\
    \    else\n        # Odd number of elements\n        median=${l[$mid]}\n    fi\n\
    \    echo \"$median\"", "    # Store elements in a bash array.\n    local array=(\
    \ $1 )\n    # Sort the array in ascending order.\n    array=( $(printf \"%s\\\
    n\" \"${array[@]}\" | sort -n) )\n    # If number of elements is odd, return the\
    \ middle element.\n    if (( ${#array[@]} % 2 == 1 )); then\n        local index=$((\
    \ ${#array[@]} / 2 ))\n        echo ${array[$index]}\n    # If number of elements\
    \ is even, return the average of the middle two elements.\n    else\n        local\
    \ index1=$(( ${#array[@]} / 2 - 1 ))\n        local index2=$(( ${#array[@]} /\
    \ 2 ))\n        local r=$(echo \"scale=3; (${array[$index1]} + ${array[$index2]})\
    \ / 2\" | bc)\n        echo $r\n    fi", "\tlocal y=$(echo $1 | awk '{print $1}')\n\
    \tlocal n=$(echo $1 | wc -w)\n\tif (( n == 1 )); then\n\t\techo $y\n\telse\n\t\
    \tlocal list=($(echo $1 | awk '{for(i=1;i<=NF;i++) if (i != (NF+1)/2) printf(\"\
    %s \", $i)}'))\n\t\ty=$(median \"${list[@]}\")\n\t\techo \"$(echo \"$1\" | awk\
    \ -v y=$y '{s=s+$1; print s/NF}' | sort -n | awk '{print $((NF+1)/2)}')\"\n\t\
    fi", "  l=($(echo \"$1\" | tr ' ' '\\n' | sort -n))\n  # odd number of elements\n\
    \  if (( ${#l[@]} % 2 )); then\n    echo ${l[((${#l[@]} + 1) / 2 - 1)]}\n  # even\
    \ number of elements\n  else\n    echo $(echo \"scale=2; (${l[${#l[@]} / 2 - 1]}\
    \ + ${l[${#l[@]} / 2]}) / 2\" | bc)\n  fi", "    l=$1\n    s=`echo $l | wc -w`\n\
    \    if [ $((s % 2)) -eq 0 ]; then\n        # for even number of elements, take\
    \ the mean of the two middle elements\n        # take the middle elements\n  \
    \      sl=`echo $l | cut -d ' ' -f $(((s/2)-1))-`\n        s=`echo $sl | wc -w`\n\
    \        # take the first s/2 elements\n        x=`echo $sl | cut -d ' ' -f -$((s/2))`\n\
    \        # take the last s/2 elements\n        y=`echo $sl | cut -d ' ' -f $((s/2+1))-`\n\
    \        # average of the two middle values\n        echo $((($x+$y)/2))\n   \
    \ else\n        # for odd number of elements, just take the middle element\n \
    \       echo $l | cut -d ' ' -f $((s/2+1))\n    fi", "    l=($1)\n    n=${#l[@]}\n\
    \    n_2=$((n/2))\n    # Sort list.\n    # This may be slow if the list is very\
    \ large.\n    l_sort=($(for ((i=0; i<$n; i++)); do\n        echo ${l[i]}\n   \
    \ done | sort -n))\n    if (($n%2 == 0)); then\n        # If even number of elements,\
    \ return the mean of the two middle elements.\n        echo \"$(((l_sort[n_2-1]+l_sort[n_2])/2))\"\
    \n    else\n        # If odd number of elements, return the middle element.\n\
    \        echo \"${l_sort[n_2]}\"\n    fi", "    l=$1\n    n=$(echo \"$l\" | wc\
    \ -w)\n    m=$(python -c \"print(int(($n + 1) / 2))\")\n    if [ \"$((m * 2))\"\
    \ -eq \"$((n + 1))\" ]; then\n        # $n is odd\n        echo \"$l\" | awk '{\
    \ print $'$m' }'\n    else\n        # $n is even\n        x=$(echo \"$l\" | awk\
    \ '{ print $'$m' }')\n        y=$(echo \"$l\" | awk '{ print $'$((m + 1))' }')\n\
    \        echo \"$(bc -l <<< \"($x + $y) / 2\")\"\n    fi", "   \n   local -a m\n\
    \   for x in $1; do m+=($x); done # fill the array\n   mlength=${#m[@]} # length\
    \ of array m\n   if (( $mlength == 0 )); then\n      echo 0\n      return\n  \
    \ fi\n   m=($(printf '%f\\n' \"${m[@]}\" | sort -n)) # sort the array\n   if ((\
    \ $mlength % 2 == 1 )); then # odd number of elements\n      echo ${m[$((mlength/2))]}\n\
    \   else # even number of elements\n      echo \"scale=1; (${m[$((mlength/2-1))]}\
    \ + ${m[$((mlength/2))]})/2\" | bc\n   fi", "    local -a l=$1\n    # Sort elements\
    \ of list l\n    s=$(echo \"${l[@]}\" | tr ' ' '\\n' | sort -n)\n    # Return\
    \ median\n    n=$(echo \"$s\" | wc -l)\n    if ((n % 2 == 1)); then\n        #\
    \ Odd number of elements\n        # Return element at position n // 2\n      \
    \  echo \"$s\" | sed -n \"$((n / 2 + 1))p\"\n    else\n        # Even number of\
    \ elements\n        # Return mean of element at positions n // 2 - 1 and n //\
    \ 2\n        s2=$(echo \"$s\" | sed -n \"$((n / 2))p\")\n        s1=$(echo \"\
    $s\" | sed -n \"$((n / 2 + 1))p\")\n        echo \"scale=1; ( $s1 + $s2 ) / 2\"\
    \ | bc\n    fi", "    local l=$1\n    if [ $# -eq 0 ]; then\n        echo \"Argument\
    \ error\"\n        return\n    fi\n    local list=($l)\n    local lsort=($(printf\
    \ \"%s\\n\" \"${list[@]}\" | sort -n))\n    local idx=$((${#lsort[@]} / 2))\n\
    \    printf \"%s\\n\" \"${lsort[idx]}\"", "    l=($(echo $@ | tr ' ' '\\n' | sort\
    \ -n))\n    # $(()) is a declaration of arithmetic expression. In this context,\n\
    \    # 0.5 * $# + 0.5 means half of the elements of l.\n    n=$((${#l[@]}/2))\n\
    \    if (($#%2==1)); then\n        # If the length of l is odd, return the median,\
    \ i.e., $n.\n        echo ${l[$n]}\n    else\n        # If the length of l is\
    \ even, return the mean of the medians.\n        # From $n and $((n-1)), we can\
    \ obtain the number of the first median,\n        # and from $((n+1)) and $((n+2)),\
    \ we can obtain the number of the\n        # second median.\n        echo $(((${l[$n]}+${l[$((n-1))]})/2))\n\
    \    fi", "    local list=($1)\n    local i\n    local -a sorted\n    for ((i=0;\
    \ i<${#list[@]}; i++)); do\n        sorted[i]=${list[i]}\n    done\n    IFS=$'\\\
    n' sorted=($(sort -n <<<\"${sorted[*]}\"))\n    unset IFS\n    local len=${#sorted[@]}\n\
    \    local middle=$((len/2))\n    if ((len % 2 == 0)); then\n        local res=$(echo\
    \ \"scale=1; (${sorted[middle-1]} + ${sorted[middle]})/2\" | bc)\n    else\n \
    \       local res=${sorted[middle]}\n    fi\n    echo $res", "  ar=($1)\n  ar_len=${#ar[@]}\n\
    \  mid_idx=$((ar_len / 2))\n  if ((ar_len % 2 == 0)); then\n    echo \"scale=1;\
    \ (${ar[$mid_idx - 1]} + ${ar[$mid_idx]}) / 2\" | bc\n  else\n    echo \"${ar[$mid_idx]}\"\
    \n  fi", "    # use bc for floating point math\n    if [ \"$1\" == \"\" ]; then\n\
    \        echo \"0\"\n    else\n        echo \"$1\" | tr \" \" \"\\n\" | sort -n\
    \ | awk '{ a[i++]=$1; } END { print a[int(i/2)]; }'\n    fi", "  local med=$(echo\
    \ $1 | tr ' ' '\\n' | sort -n | awk '{mid=int(NR/2);if(NR%2==0){med=(arr[mid]+arr[mid+1])/2}else{med=arr[mid]};print\
    \ med}')\n  echo $med", "  local l=($1)\n  echo $(echo ${l[@]} | tr ' ' '\\n'\
    \ | sort -n | awk '\n    {\n      if (NR == 1) { m = $1 }\n      if (NR % 2 ==\
    \ 0) { m = ($1 + m) / 2 }\n      if (NR % 2 == 1) { m = $1 }\n    }\n    END {\
    \ print m }\n  ')", "   awk -v l=\"$1\" 'BEGIN {\n      split(l, t, \" \")\n \
    \     n = asort(t)\n      if (n % 2) print t[(n+1)/2]\n      else print (t[n/2]\
    \ + t[n/2+1]) / 2\n   }'", "    local l=$(for e in $(tr ' ' '\\n' <<< $1 | sort\
    \ -n); do echo $e; done)\n    local len=$(wc -w <<< $l)\n    if (( len % 2 ==\
    \ 1 )); then\n        echo $(awk \"NR==$((len/2+1))\" <<< $l)\n    else\n    \
    \    local l2=$(awk \"NR==$len/2\" <<< $l)\n        local l1=$(awk \"NR==$len/2-1\"\
    \ <<< $l)\n        echo $(echo \"scale=1;($l1+$l2)/2\" | bc)\n    fi", "  # Note:\
    \ as per bash help, the sort function will use the empty string as\n  # the field\
    \ separator.  We need to use the -n option to sort as numbers.\n  # Without it,\
    \ the sort will sort alphabetically.\n  local sort_args=(-n \"$@\")\n  local sorted_args=($(IFS=\\\
    \  ; echo \"${sort_args[*]}\"))\n  local sorted_list=$(printf \"%s\\n\" \"${sorted_args[@]}\"\
    \ | sort ${sort_args[@]})\n  local num_elements=$(echo \"$sorted_list\" | wc -l)\n\
    \  local mid_index=$((num_elements / 2))\n  # To get a float as output, we need\
    \ to tell awk to not only format the\n  # result, but also do the division.\n\
    \  echo \"$sorted_list\" | awk \"NR==$mid_index { print $1 / 1 }\"", "  local\
    \ l=\"$@\"\n  # sort numerically\n  local sorted=\"$(echo \"$l\" | sed 's/ /\\\
    n/g' | sort -n)\"\n  local len=\"$(echo \"$sorted\" | wc -l)\"\n  local res\n\
    \  # if len is odd, return middle element.\n  # else, return the sum of the middle\
    \ two elements divided by 2.\n  # `echo \"1/2\" | bc` evaluates to 0.5 as expected.\n\
    \  if [[ $((len % 2)) -eq 1 ]]; then\n    res=\"$(echo \"$sorted\" | awk \"NR==$((len\
    \ / 2 + 1))\")\"\n  else\n    res=\"$(echo \"$sorted\" | awk \"NR==$((len / 2))+1\
    \ {print \\$1 + \\$2; exit}\")\"\n    res=\"$(echo \"$res / 2\" | bc -l)\"\n \
    \ fi\n  echo \"$res\"", "\tl=(${1})\n\ts=$((${#l[@]} - 1))\n\tc=$(($s / 2))\n\t\
    m=$(printf \"%d\" \"$c\")\n\techo \"${l[$m]}\"", "  local -a l=()\n  local m\n\
    \  local -i i im i1 i2\n  for n in $1; do\n    l[${#l[@]}]=$n\n  done\n  for ((\
    \ i=1; i<${#l[@]}; i++ )); do\n    for (( j=0; j<${#l[@]}-i; j++ )); do\n    \
    \  if (( $(echo \"${l[j]} > ${l[j+1]}\" | bc -l) )); then\n        m=${l[j]}\n\
    \        l[j]=${l[j+1]}\n        l[j+1]=$m\n      fi\n    done\n  done\n  if ((\
    \ ${#l[@]} % 2 == 1 )); then\n    echo ${l[$(( ${#l[@]} / 2 ))]}\n  else\n   \
    \ i1=$(( ${#l[@]} / 2 - 1 ))\n    i2=$(( ${#l[@]} / 2 ))\n    echo $(echo \"scale=1;\
    \ (${l[i1]} + ${l[i2]}) / 2\" | bc -l)\n  fi", "    l=($(echo $1 | tr ' ' '\\\
    n' | sort -n))\n    echo $1 | tr ' ' '\\n' | sort -n | awk \"{print $(((${#l[@]}+1)/2))}\"",
  "  local l=( $1 )\n  local h=${#l[@]}\n  local mi=0\n  for ((i=0; i<h; i++)); do\n\
    \    for ((j=i; j<h; j++)); do\n      (( ${l[j]} < ${l[mi]} )) && mi=$j\n    done\n\
    \    temp=${l[i]} l[i]=${l[mi]} l[mi]=$temp\n  done\n  (( $h % 2 )) && printf\
    \ %.1f ${l[$((h/2))]} || printf %.1f $(( (${l[$((h/2))]} + ${l[$((h/2-1))]})/2\
    \ ))", "\tlocal m=$(((`wc -w <<<\"$1\"` + 1) / 2))\n\tlocal s=`sort -n <<<\"$1\"\
    `\n\tlocal i=1\n\tfor n in $s; do\n\t\tif [ $i = $m ]; then\n\t\t\techo $n\n\t\
    \t\tbreak\n\t\tfi\n\t\ti=$((i + 1))\n\tdone", "  local row\n  local arr\n  local\
    \ len\n  local max\n  local med\n  local i\n\n  row=$(echo \"$1\" | tr ' ' '\\\
    n' | sort -n)\n  arr=($row)\n  len=${#arr[@]}\n  max=$((len - 1))\n\n  if ((len\
    \ == 0)); then\n    echo 0\n  elif ((len == 1)); then\n    echo ${arr[0]}\n  elif\
    \ ((len % 2 == 1)); then\n    echo ${arr[$((len / 2))]}\n  else\n    i=$((len\
    \ / 2))\n    med=$(echo \"${arr[$i]}+${arr[$((i - 1))]}\" | bc)\n    echo $(echo\
    \ \"scale=1;$med/2\" | bc)\n  fi", "    local -a r\n    local n\n    r=($(echo\
    \ $@ | tr ' ' '\\n' | sort -n))\n    n=$((${#r[@]}/2))\n    if [ $((${#r[@]}%2))\
    \ = 1 ]; then\n        echo \"${r[$n]}\"\n    else\n        echo \"$(echo \"scale=1;\
    \ (${r[$n-1]}+${r[$n]})/2\" | bc)\"\n    fi", "    out=($(echo \"$1\" | sed 's/^\
    \ *//;s/ *$//;s/ /\\n/g' | sort -n))\n    len=${#out[@]}\n    half=$(( $len /\
    \ 2 ))\n    if (( $len % 2 == 0 )); then\n        sum=$((${out[$half-1]} + ${out[$half]}))\n\
    \        echo \"$(echo \"$sum / 2\" | bc -l)\"\n    else\n        echo \"${out[$half]}\"\
    \n    fi", "    local median temp i=0\n    IFS=$' ' # Split on space.\n    arr=($1)\n\
    \    IFS=$'\\n' # Split on newline.\n    arr=($(sort -n <<<\"${arr[*]}\"))\n \
    \   if [ ${#arr[@]} -eq 0 ]; then\n        median=0\n    elif [ $((${#arr[@]}\
    \ % 2)) -eq 0 ]; then\n        # Take average of two middle numbers.\n       \
    \ temp=$((${#arr[@]} / 2))\n        median=$(echo \"scale=1;(${arr[$temp]} + ${arr[$((temp\
    \ - 1))]})/2\" | bc)\n    else\n        median=${arr[$((${#arr[@]} / 2))]}\n \
    \   fi\n    echo $median", "\tarray=($1)\n\tn=${#array[@]}\n\tprintf \"%0.1f\"\
    \ $(echo \"scale=1;$(IFS=\"+\"; echo \"${array[*]}\" | bc)/$n\" | bc)", "    local\
    \ m=()\n    for v in $@; do\n        m+=($v)\n    done\n    local l=${#m[@]}\n\
    \    [[ $l -eq 0 ]] && { echo 0; return; }\n    sort -n <<< \"${m[*]}\" | awk\
    \ -v l=$l '{m[NR]=$1} END {if (l%2==1) print m[int(l/2)+1]; else print (m[l/2]+m[l/2+1])/2.0}'",
  "  local _l=`echo $* | awk '{l=NF/2;s=0;for(i=1;i<=NF;i++){s+=$i};if(NF%2){print\
    \ $l}else{print (s-($l-1)-$l)/2}}'`\n  echo \"$_l\"", "    local arr\n    arr=($(echo\
    \ $1 | awk '{\n        for (i=1; i<=NF; i++) {\n            if (a[i] != \"\")\
    \ a[i] = a[i] \" \" $i;\n            else a[i] = $i;\n        }\n        max =\
    \ i;\n    } END {\n        for (i=1; i<=max; i++) {\n            printf(\"%s\\\
    n\", a[i]);\n        }\n    }' | sort -n | awk '{ print $1 }'))\n    mid=${#arr[@]}\n\
    \    echo ${arr[$(( $mid / 2 ))]}", "  if [ $# -eq 0 ]; then\n    echo 'ERR: median():\
    \ no arguments'\n    return 1\n  fi\n  IFS=$'\\n' sorted=($(sort -n <<<\"$*\"\
    ))\n  unset IFS\n  n=$((${#sorted[@]} / 2))\n  if (( $# % 2 == 1 )); then\n  \
    \  echo \"${sorted[$n]}\"\n  else\n    echo \"$(bc -l <<<\"scale=1; (${sorted[$n-1]}\
    \ + ${sorted[$n]}) / 2\")\"\n  fi", "    l=${1// /$'\\n'}\n    echo \"$l\" | awk\
    \ '\n        {\n            a[i++]=$0;\n        }\n        END {\n           \
    \ asort(a);\n            if (i%2==1) {\n                print a[(i+1)/2];\n  \
    \          } else {\n                print (a[i/2]+a[i/2+1])/2;\n            }\n\
    \        }\n    '", "    v=($@)\n    n=${#v[@]}\n    if ((n == 0)); then\n   \
    \     echo \"\"\n        return\n    fi\n    if ((n == 1)); then\n        echo\
    \ \"${v[0]}\"\n        return\n    fi\n    v1=(\"${v[@]}\")\n    v2=(\"${v[@]}\"\
    )\n    unset v1[$((n - 1))]\n    unset v2[0]\n    if ((n % 2 == 1)); then\n  \
    \      echo \"$(median \"${v1[@]}\")\"\n    else\n        echo \"$(bc -l <<< \"\
    scale=1; ($(median \"${v1[@]}\") + $(median \"${v2[@]}\")) / 2\")\"\n    fi",
  "  # Returns a space-separated string of n evenly spaced numbers between $1 and\
    \ $2.\n  # >>> $(seq \"0\" \"1\" \"10\")\n  # \"0 1 2 3 4 5 6 7 8 9 10\"\n  #\n\
    \  # $1 is the start of the range.\n  # $2 is the step size.\n  # $3 is the end\
    \ of the range.\n  seq() {\n    # Note: seq is a built-in shell command in zsh\
    \ and bash.\n    # But other shells like sh and csh have no built-in support for\
    \ it.\n    local start=$1\n    local step=$2\n    local end=$3\n    local res=\"\
    $start\"\n    while (( $start < $end )); do\n      start=$(( $start + $step ))\n\
    \      res=\"$res $start\"\n    done\n    echo \"$res\"\n  }\n\n  # Returns a\
    \ space-separated list of the elements in the list l that are less than or equal\
    \ to the median of l.\n  # >>> $(echo \"$(medianle \"3 1 2 4 5\")\")\n  # \"1\
    \ 2 3\"\n  # >>> $(echo \"$(medianle \"-10 4 6 1000 10 20\")\")\n  # \"-10 4 6\
    \ 10\"\n  #\n  # $1 is a space-separated list\n  medianle() {\n    local l=\"\
    $1\"\n    local m=$(median \"$l\")\n    echo \"$l\" | xargs -n1 | awk -v m=\"\
    $m\" '$1 <= m { print $1 }'\n  }\n\n  # Returns a space-separated list of the\
    \ elements in the list l that are greater than or equal to the median of l.\n\
    \  # >>> $(echo \"$(mediangt \"3 1 2 4 5\")\")\n  # \"4 5\"\n  # >>> $(echo \"\
    $(mediangt \"-10 4 6 1000 10 20\")\")\n  # \"1000 20\"\n  #\n  # $1 is a space-separated\
    \ list\n  mediangt() {\n    local l=\"$1\"\n    local m=$(median \"$l\")\n   \
    \ echo \"$l\" | xargs -n1 | awk -v m=\"$m\" '$1", "  local -r list=$1\n  local\
    \ -r elements=$(echo \"$list\" | awk '{print NF}')\n  local -r index=$(echo \"\
    ($elements+1)/2\" | bc)\n  echo \"$list\" | tr ' ' '\\n' | sort -n | sed -n \"\
    ${index}p\"", "    [ -z \"$1\" ] && return 1\n    local all=( $1 )\n    local\
    \ n=${#all[@]}\n    local half=$(( n / 2 ))\n    # Sort the list\n    all=( $(IFS=$'\\\
    n'; echo \"${all[*]}\" | sort -n) )\n    # Even or odd?\n    if [ $(( n % 2 ))\
    \ -eq 0 ]; then\n        # even\n        echo \"scale=1; (${all[$half]} + ${all[$((\
    \ half - 1 ))]}) / 2\" | bc\n    else\n        # odd\n        echo \"${all[$half]}\"\
    \n    fi", "\tlocal median n sorted middle\n\t\n\tmedian=0\n\tn=$#\n\tif (( n\
    \ == 0 )); then\n\t\treturn 0\n\tfi\n\t\n\tfor (( i = 1; i <= n; i++ )); do\n\t\
    \tsorted[i]=$1\n\t\tshift\n\tdone\n\t\n\tfor (( i = 1; i <= n; i++ )); do\n\t\t\
    for (( j = 1; j <= n - i; j++ )); do\n\t\t\tif (( ${sorted[j]} > ${sorted[j +\
    \ 1]} )); then\n\t\t\t\ttemp=${sorted[j]}\n\t\t\t\tsorted[j]=${sorted[j + 1]}\n\
    \t\t\t\tsorted[j + 1]=$temp\n\t\t\tfi\n\t\tdone\n\tdone\n\t\n\tmiddle=$(( n /\
    \ 2 ))\n\tif (( n % 2 == 0 )); then\n\t\tmedian=$(echo \"scale=2;(${sorted[middle]}\
    \ + ${sorted[middle + 1]})/2\" | bc)\n\telse\n\t\tmedian=${sorted[middle + 1]}\n\
    \tfi\n\t\n\tprintf %f \"$median\"", "    s=$(echo \"$1\" | sed -e 's/^[[:space:]]*//'\
    \ -e 's/[[:space:]]*$//')\n    l=$(echo \"$s\" | tr ' ' '\\n' | sort -n)\n   \
    \ size=$(echo \"$l\" | wc -l)\n    if (( $size % 2 == 1 )); then\n        # Odd\
    \ number of elements.\n        n=$(( $size / 2 + 1 ))\n        el=$(echo \"$l\"\
    \ | head -n $n | tail -n 1)\n    else\n        # Even number of elements.\n  \
    \      n=$(( $size / 2 ))\n        el_1=$(echo \"$l\" | head -n $n | tail -n 1)\n\
    \        el_2=$(echo \"$l\" | head -n $(( $n + 1 )) | tail -n 1)\n        el=$(echo\
    \ \"$el_1 + $el_2\" | bc -l)\n        el=$(echo \"$el / 2\" | bc -l)\n    fi\n\
    \    echo \"$el\"", "  local list=($1)\n  local sorted=($(echo \"${list[*]}\"\
    \ | tr ' ' '\\n' | sort -n))\n  local i=$(( ${#sorted[*]} / 2 ))\n  echo ${sorted[$i]}",
  "    numbers=( $(echo $1 | tr \" \" \"\\n\" | sort -n) ) # sort numbers\n    middle=${#numbers[@]}/2\
    \ \t\t            # find middle\n\n    if (( $middle * 2 == ${#numbers[@]} ));\
    \ then\n        # there is an even number of elements, \n        # return mean\
    \ of two elements in the middle\n        echo \"scale=2; (${numbers[$middle]}\
    \ + ${numbers[$middle-1]})/2\" | bc\n    else\n        # return middle element\n\
    \        echo ${numbers[$middle]}\n    fi", "    printf '%g\\n' $(awk '{c[NR]=$1;s+=$1}END{asort(c);if(NR%2==1){print\
    \ c[(NR+1)/2]}else{print (c[NR/2]+c[NR/2+1])/2}}' <<< \"$1\")", "    declare -a\
    \ l=(\"$@\")\n    l=($(printf '%f\\n' \"${l[@]}\" | sort -n))\n    # Get the element\
    \ in the middle.\n    local l_len=${#l[@]}\n    local middle=$(( l_len / 2 ))\n\
    \    if (( l_len % 2 == 0 )); then\n        # If there are two elements in the\
    \ middle, return their average.\n        echo \"$(echo \"${l[$middle - 1]} + ${l[$middle]}\"\
    \ | bc -l) / 2\" | bc -l\n    else\n        echo \"${l[$middle]}\"\n    fi", " \
    \   local m=$(sort -n <<< \"$1\" | sed -n $(printf '%dp' $((${#1[@]}/2+1)))p)\n\
    \    printf %f \"$m\"", "    l=($(echo $1 | tr ' ' '\\n' | sort -n))\n    n=${#l[@]}\n\
    \    i=$(( $n/2 ))\n    if [ $(( $n%2 )) -eq 0 ]; then\n        bc -l <<< \"scale=1;\
    \ (${l[$i-1]}+${l[$i]})/2\"\n    else\n        echo ${l[$i]}\n    fi", "    num=$(echo\
    \ $1 | wc -w)\n    echo $1 | xargs -n $num | \\\n        sort -n | \\\n      \
    \  if test $(($num % 2)) -eq 0\n        then\n            # Even number of elements\n\
    \            awk '{print ($1 + $2) / 2.0}'\n        else\n            # Odd number\
    \ of elements\n            awk '{print $('$(($num / 2 + 1))')}'\n        fi",
  "    local -a l=($1)\n    local -a sorted=()\n    copy_array sorted l\n    # Sort\
    \ the array in ascending order\n    quicksort sorted 0 $((${#sorted[@]} - 1))\n\
    \    if ((${#sorted[@]} % 2 == 1)); then\n        echo ${sorted[$(((${#sorted[@]}\
    \ + 1) / 2 - 1))]}\n    else\n        echo $(((${sorted[$(((${#sorted[@]} + 1)\
    \ / 2 - 1))]} \\\n                + ${sorted[$(((${#sorted[@]} + 1) / 2))]}) /\
    \ 2))\n    fi", "  l=($(sort -n <<< \"$1\"))\n  len=${#l[@]}\n  m=$((($len+1)/2-1))\n\
    \  if (( $len % 2 == 1 )); then\n    echo ${l[$m]}\n  else\n    echo $(((${l[$m]}+${l[$m+1]})/2))\n\
    \  fi", "    local l=(${@})\n    l=(\"${l[@]}\" \"${l[@]}\" \"${l[@]}\")\n   \
    \ l=(\"${l[@]}\" \"${l[@]}\" \"${l[@]}\")\n    l=(\"${l[@]}\" \"${l[@]}\" \"${l[@]}\"\
    )\n    l=(\"${l[@]}\" \"${l[@]}\" \"${l[@]}\")\n    l=(\"${l[@]}\" \"${l[@]}\"\
    \ \"${l[@]}\")\n    l=(\"${l[@]}\" \"${l[@]}\" \"${l[@]}\")\n    l=(\"${l[@]}\"\
    \ \"${l[@]}\" \"${l[@]}\")\n    l=(\"${l[@]}\" \"${l[@]}\" \"${l[@]}\")\n    l=(\"\
    ${l[@]}\" \"${l[@]}\" \"${l[@]}\")\n    l=(\"${l[@]}\" \"${l[@]}\" \"${l[@]}\"\
    )\n    l=(\"${l[@]}\" \"${l[@]}\" \"${l[@]}\")\n    l=(\"${l[@]}\" \"${l[@]}\"\
    \ \"${l[@]}\")\n    l=(\"${l[@]}\" \"${l[@]}\" \"${l[@]}\")\n    l=(\"${l[@]}\"\
    \ \"${l[@]}\" \"${l[@]}\")\n    l=(\"${l[@]}\" \"${l[@]}\" \"${l[@]}\")\n    l=(\"\
    ${l[@]}\" \"${l[@]}\" \"${l[@]}\")\n    l=(\"${l[@]}\" \"${l[@]}\" \"${l[@]}\"\
    )\n    l=(\"${l[@]}\" \"${l[@]}\" \"${l[@]}\")\n    l=(\"${l[@]}\" \"${l[@]}\"\
    \ \"${l[@]}\")\n    l=(\"${l[@]}\" \"${l[@]}\" \"${l[@]}\")\n    l=", "    l=($1)\n\
    \    echo ${l[`((${#l[@]}-1))/2`]}", "\t# Sort the list into ascending order.\n\
    \tlocal l=($(echo \"$1\" | sort -n))\n\tlocal n=\"${#l[@]}\"\n\t(( n % 2 == 0\
    \ )) && local m=$(( n / 2 )) || local m=$(( (n + 1) / 2 ))\n\tlocal e=\"${l[$m]}\"\
    \n\tlocal f=\"${l[$((m - 1))]}\"\n\t(( n % 2 == 0 )) && echo \"scale=1;($e + $f)\
    \ / 2\" | bc -l || echo \"$e\"", "  local -a a\n  while IFS= read -r n; do\n \
    \   a=(\"${a[@]}\" \"$n\")\n  done <<< \"$1\"\n  if (( ${#a[@]} == 0 )); then\n\
    \    echo -n 0\n  else\n    echo -n \"$(\n      printf \"%s\\n\" \"${a[@]}\" |\
    \ sort -n | awk \\\n        'NR % 2 == 0 { printf(\"%.1f\\n\", ($1 + $2) / 2);\
    \ }\n           NR % 2 == 1 { print $1; }'\n    )\"\n  fi", "  local l=$(echo\
    \ \"$1\" | tr ' ' '\\n' | sort -n)\n  local count=$(echo \"$l\" | wc -l)\n  echo\
    \ $l\n  echo $count\n  if [ $(expr $count % 2) -eq 0 ]; then\n    echo \"$(expr\
    \ $count / 2)\"\n    # even\n    local l1=$(echo \"$l\" | sed -n $(expr $count\
    \ / 2)p)\n    local l2=$(echo \"$l\" | sed -n $(expr $count / 2 + 1)p)\n    echo\
    \ $(bc -l <<< \"($l1 + $l2) / 2\")\n  else\n    # odd\n    echo \"$(expr $count\
    \ / 2 + 1)\"\n    echo \"$l\" | sed -n $(expr $count / 2 + 1)p\n  fi", "    local\
    \ l=($(echo $1 | tr ' ' '\\n' | sort -n))\n    echo \"${l[${#l[@]}/2]}\"", " \
    \   # Sort elements in list in ascending order.\n    l=($(echo \"$1\" | tr ' '\
    \ '\\n' | sort -n))\n    n=$(echo \"$1\" | wc -w)\n\n    # Odd number of elements:\
    \ middle element\n    if (( $n % 2 == 1 ))\n    then\n        echo ${l[$(( $n\
    \ / 2 ))]}\n    # Even number of elements: average of two middle elements\n  \
    \  else\n        echo $(( (${l[$(( $n / 2 - 1 ))]} + ${l[$(( $n / 2 ))]}) / 2.0\
    \ ))\n    fi", "  l=$(printf '%s\\n' \"$1\" | sed '/^$/d' | sort -n)\n  n=$(printf\
    \ '%s\\n' \"$l\" | wc -l)\n  n=$((n / 2))\n  (printf '%s\\n' \"$l\" | sed -n ${n}p;\
    \ printf '%s\\n' \"$l\" | sed -n $((n + 1))p) | awk '{print ($1 + $2) / 2}'",
  "    l=(${1// / })\n    l=(\"${l[@]/#/0}\")\n    l=(\"${l[@]/%/0}\")\n    l=(\"\
    ${l[@]/#-/0}\")\n    l=(\"${l[@]/%/-0}\")\n    l=(\"${l[@]/%\\./0}\")\n    l=(\"\
    ${l[@]/#\\./0.}\")\n    l=(\"${l[@]/%e/-0e}\")\n    l=(\"${l[@]/#e/0e}\")\n  \
    \  l=(\"${l[@]/#inf/9223372036854775807}\")\n    l=(\"${l[@]/%inf/-9223372036854775807}\"\
    )\n    l=(\"${l[@]/#nan/0}\")\n    IFS=$'\\n' sorted=($(sort -n <<<\"${l[*]}\"\
    )); unset IFS\n    nel=${#sorted[@]}\n    if (( $nel % 2 == 1 )); then     # Odd\
    \ number of elements\n        val=\"${sorted[ $(($nel/2)) ]}\"\n    else     \
    \                       # Even number of elements\n        (( j=nel/2 ))\n   \
    \     (( k=j-1 ))\n        (( val=(${sorted[j]} + ${sorted[k]})/2 ))\n    fi\n\
    \    echo $val", "    local l=$1\n    local m=0\n    local a\n    a=($l)\n   \
    \ if (( ${#a[@]} % 2 == 1 )); then\n        m=$(echo -e \"${l}\" | sed -e 's/\
    \ /\\n/g' | sort -n | awk '{if(NR=='$(((${#a[@]}+1)/2))'){print;exit}}')\n   \
    \ else\n        m=$(echo -e \"${l}\" | sed -e 's/ /\\n/g' | sort -n | awk '{if(NR=='$(((${#a[@]})/2))'){print;exit}}')\n\
    \        m=$(echo \"scale=1; ($m+$(echo -e \"${l}\" | sed -e 's/ /\\n/g' | sort\
    \ -n | awk '{if(NR=='$(((${#a[@]})/2+1))'){print;exit}}'))/2\" | bc)\n    fi\n\
    \    echo $m", "  local l=($1)\n  local median\n  if (( ${#l[@]} == 1 )); then\n\
    \    median=${l[0]}\n  else\n    local tmp\n    local c=($(printf \"%s\\n\" \"\
    ${l[@]}\" | sort -n | sed 's/^/-/'))\n    local len=${#c[@]}\n    local mid=$((len\
    \ / 2))\n    ((len % 2 == 0)) &&\n      median=$(echo \"${c[mid-1]} + ${c[mid]}\"\
    \ | bc -l) &&\n      median=$(echo \"scale=1;$median / 2\" | bc -l) ||\n     \
    \ median=${c[mid]}\n  fi\n  echo $median", "    # if number of elements is odd,\
    \ median is the middle element\n    if [ $# -eq 3 ]; then\n        echo $2\n \
    \       return\n    fi\n\n    local l1=\"$(echo $@ | tr ' ' '\\n' | sort -n |\
    \ head -n $((($#+1)/2)) | tail -n 1)\"\n    local l2=\"$(echo $@ | tr ' ' '\\\
    n' | sort -n | head -n $((($#+2)/2)) | tail -n 1)\"\n    echo \"$(echo \"scale=1;\
    \ ($l1+$l2)/2\" | bc)\"", "    local l=$@\n    local med=\n    local -a new_list\n\
    \    local -i count\n    local -i ii\n    local -i len\n    local -i mid\n   \
    \ local -i mid_plus_one\n    local -i num\n    local -r separator=' '\n\n    new_list=($l)\n\
    \    len=${#new_list[@]}\n    for ((ii=0; ii<len; ii++)); do\n        num=${new_list[ii]}\n\
    \        ((num > 0)) && ((count++))\n    done\n    ((count > 0)) || { echo 0;\
    \ return 0; }\n    ((count == 1)) && { echo ${new_list[0]}; return 0; }\n    if\
    \ ((count % 2 == 0)); then\n        ((mid = count / 2))\n        ((mid_plus_one\
    \ = mid + 1))\n        med=$(echo \"scale=1; (${new_list[mid]} + ${new_list[mid_plus_one]})/2\"\
    \ | bc)\n    else\n        ((mid = count / 2))\n        med=${new_list[mid]}\n\
    \    fi\n    echo $med", "  echo \"$1\" | tr ' ' '\\n' | sort -n | awk '{ a[i++]=$1;\
    \ } END { print a[int(i/2)]; }'", "  l=($(eval echo $1))\n  local s=${#l[@]}\n\
    \  ((s%2==0)) && {\n    echo $(( (${l[$(($s/2))]} + ${l[$(($s/2-1))]}) / 2.0 ))\n\
    \  } || {\n    echo ${l[$(($s/2))]}\n  }", "    echo $(echo $1 | awk '{split($0,a);asort(a);print(a[int(NR/2)])}')",
  "    local l=$1\n    local m=$(( ${#l[@]} / 2 ))\n    l=( $(printf \"%s\\n\" $l\
    \ | sort -n) )\n    if (( ${#l[@]} % 2 )); then\n        echo ${l[$m]}\n    else\n\
    \        echo $(( ( ${l[$m]} + ${l[$((m-1))]} ) / 2 ))\n    fi", "    local l=($@)\n\
    \    local s=${#l[@]}\n    if (( s == 0 )); then\n        echo \"\"\n        return\n\
    \    fi\n    local mi=$((s/2))\n    l=($(printf \"%s\\n\" \"${l[@]}\" | sort -n))\n\
    \    ((s % 2)) && echo ${l[$mi]} || echo $(((${l[$mi-1]}+${l[$mi]})/2.0))", " \
    \ local l=($1)\n  local n=${#l[@]}\n  local m=$(( n / 2 ))\n  local x=`echo ${l[@]}\
    \ | tr ' ' '\\n' | sort -n | awk \"NR==$m\"`\n  if (( n % 2 == 0 )); then\n  \
    \  local y=`echo ${l[@]} | tr ' ' '\\n' | sort -n | awk \"NR==$(( m + 1 ))\"`\n\
    \    echo \"$(( ( x + y ) / 2 ))\"\n  else\n    echo \"$x\"\n  fi", "    local\
    \ m\n    m=$(echo $1 | tr \" \" \"\\n\" | sort -n | head -n $(($(echo $1 | wc\
    \ -w)+1)/2) | tail -n 1)\n    if (( $(echo $1 | wc -w)%2==0 )); then\n       \
    \ echo $(bc -l <<< \"scale=1; ($m+$(echo $1 | tr \" \" \"\\n\" | sort -n | head\
    \ -n $(($(echo $1 | wc -w)/2+1)) | tail -n 1))/2\")\n    else\n        echo $m\n\
    \    fi", "    awk '{arr[NR]=$1} END {if (NR%2==1) print arr[(NR+1)/2]; else print\
    \ (arr[NR/2]+arr[NR/2+1])/2}'", "  local list=($1)\n  local len=${#list[@]}\n\
    \  local med=0\n  # make a copy of the list, we sort in place\n  local copy=(\"\
    ${list[@]}\")\n  local t=0\n  # do not use 'sort' command, it sorts lexicographically\n\
    \  # instead, we use 'bc' to sort numerically\n  IFS=$'\\n' copy=($(for i in \"\
    ${copy[@]}\"; do echo \"$i\"; done | sort -n | tr '\\n' ' '))\n  unset IFS\n \
    \ # in case of an even number of elements, we take the average of\n  # the two\
    \ middle elements\n  if [ $(( len % 2 )) -eq 0 ]; then\n    med=$(echo \"${copy[$((len/2-1))]}\
    \ + ${copy[$((len/2))]}\" | bc -l)\n    med=$(echo \"scale=1; $med / 2\" | bc\
    \ -l)\n  else\n    med=${copy[$((len/2))]}\n  fi\n  echo \"$med\"", "  m=()\n\
    \  for i in $1; do\n    m+=($i)\n  done\n  if [ $(( ${#m[@]} % 2 )) -eq 0 ]; then\n\
    \    echo $(bc -l <<< \"${m[$(( ${#m[@]} / 2 - 1 ))]} + ${m[$(( ${#m[@]} / 2 ))]}\
    \ / 2\")\n  else\n    echo $(bc -l <<< \"${m[$(( ${#m[@]} / 2 ))]}\")\n  fi",
  "    local l=($1)\n    local mlen=${#l[@]}\n    local newl=()\n    for i in ${l[@]};\
    \ do\n        [[ $i =~ ^-?[0-9]+\\.[0-9]+$ ]] && newl=(${newl[@]} $i)\n    done\n\
    \    l=(${newl[@]})\n    mlen=${#l[@]}\n    local i=$((($mlen + 1) / 2 - 1))\n\
    \    local t\n    for ((i; i > 0; i--)); do\n        for ((j = 0; j < i; j++));\
    \ do\n            if [[ ${l[j]} -gt ${l[j + 1]} ]]; then\n                t=${l[j]}\n\
    \                l[j]=${l[j + 1]}\n                l[j + 1]=$t\n            fi\n\
    \        done\n    done\n    local m\n    if (($mlen % 2 == 0)); then\n      \
    \  m=$((${l[i]} + ${l[i + 1]}))\n        echo \"scale=1; $m / 2\" | bc\n    else\n\
    \        echo ${l[i]}\n    fi", "\tlocal m len rem\n\tlocal -a l=($1)\n\tIFS=$'\\\
    n'\n\t# Skip sorting if there are only one element\n\tif (( ${#l[@]} > 1 )); then\n\
    \t\tlen=${#l[@]}\n\t\tm=$(( len / 2 ))\n\t\t(( len % 2 )) && { rem=1; }\n\t\t\
    IFS=$' '\n\t\tl=($(sort -n <<<\"${l[*]}\"))\n\t\tIFS=$'\\n'\n\t\t(( rem )) &&\
    \ echo \"${l[$m]}\" || echo \"scale=1; (${l[$(( m - 1 ))]} + ${l[$m]}) / 2\" |\
    \ bc\n\telse\n\t\techo \"${l[*]}\"\n\tfi", "    IFS=$' '\n    local L=($1)\n \
    \   unset IFS\n    # This is not strictly necessary, but if the list has an odd\
    \ number of elements\n    # the line below removes the element in the middle of\
    \ the list.\n    L=(\"${L[@]:0:$((${#L[@]} - 1))}\")\n    local m=$((${#L[@]}\
    \ / 2))\n    echo $(echo ${L[@]} | tr ' ' '\\n' | sort -n | sed -n \"$(($m + 1))p;$(($m\
    \ + 2))p\" | awk '{print ($1 + $2) / 2}')", "  # sort descending\n  local arr=($(for\
    \ el in $1; do echo $el; done | sort -nr))\n  local mid=$(( ${#arr[@]} / 2 ))\n\
    \  # odd number of elements\n  if (( ${#arr[@]} % 2 == 1 )); then\n    echo \"\
    ${arr[$mid]}\"\n  # even number of elements\n  else\n    echo \"$(bc -l <<< \"\
    scale=1;(${arr[$mid-1]} + ${arr[$mid]}) / 2\")\"\n  fi", "    local sorted=$(echo\
    \ $1 | tr ' ' '\\n' | sort -n | tr '\\n' ' ')\n    local count=$(echo $sorted\
    \ | wc -w)\n    if (( $count % 2 == 1 )); then\n        echo \"$sorted\" | cut\
    \ -d ' ' -f $(( ($count + 1) / 2 ))\n    else\n        local i=$(( $count / 2\
    \ ))\n        local a=$(echo $sorted | cut -d ' ' -f $i)\n        local b=$(echo\
    \ $sorted | cut -d ' ' -f $(( $i + 1 )))\n        echo \"scale=1; ($a + $b) /\
    \ 2\" | bc\n    fi", "    local s=($1)\n    local mid=$(( ${#s[@]} / 2 ))\n  \
    \  local sorted=($(for i in \"${s[@]}\"; do echo \"$i\"; done | sort -n))\n  \
    \  if (( ${#s[@]} % 2 == 0 )); then\n        echo $(( (sorted[mid-1] + sorted[mid])\
    \ / 2 ))\n    else\n        echo ${sorted[mid]}\n    fi", "    local array=($1)\n\
    \    local m\n    local lower_idx\n    local upper_idx\n    local sorted\n   \
    \ read -a sorted <<<$(sort -n <<<\"${array[*]}\")\n    m=$(echo \"${#sorted[@]}\
    \ / 2\" | bc)\n    m=$(echo \"($m % 2 == 0) ? $m : ($m + 1) / 2\" | bc)\n    upper_idx=$(echo\
    \ \"${#sorted[@]} / 2\" | bc)\n    upper_idx=$(echo \"($upper_idx % 2 == 0) ?\
    \ $upper_idx - 1 : $upper_idx\" | bc)\n    lower_idx=$(echo \"$upper_idx - 1\"\
    \ | bc)\n    if [ $lower_idx -eq -1 ]; then\n        echo \"${sorted[$upper_idx]}\"\
    \n    else\n        echo \"$(echo \"${sorted[$lower_idx]} + ${sorted[$upper_idx]}\
    \ / 2\" | bc -l)\"\n    fi", "  for e in $(echo $1 | tr ' ' '\\n' | sort -n);\
    \ do\n    list=\"$list $e\"\n  done\n  set $list\n  #\n  # get middle element\n\
    \  #\n  count=$#\n  mid=$((count/2))\n  if (( count%2 == 1 )); then\n    echo\
    \ \"${!mid}\"\n  else\n    med=$(echo \"${!mid} + ${!mid+1}\" | bc -l)\n    med=$(echo\
    \ \"$med / 2\" | bc -l)\n    echo \"$med\"\n  fi", "  local s=(\"$@\")\n  local\
    \ l=${#s[@]}\n  printf \"%.1f\" $(echo \"${s[*]}\" |\n    tr ' ' '\\n' |\n   \
    \ sort -n |\n    awk ' { a[i++]=$1; } END { x=int((i+1)/2); if (x < (i+1)/2) print\
    \ (a[x-1]+a[x])/2; else print a[x-1]; }'\n  )", "    local vals=($(echo $1 | tr\
    \ \" \" \"\\n\" | sort -n))\n    local nb_vals=${#vals[@]}\n    local nb_mid=$(echo\
    \ \"$nb_vals/2\" | bc)\n    if [[ $(( $nb_vals % 2 )) -eq 0 ]]; then\n       \
    \ echo $(echo \"scale=1; (${vals[$nb_mid]} + ${vals[$nb_mid - 1]}) / 2\" | bc)\n\
    \    else\n        echo ${vals[$nb_mid]}\n    fi", "    l=($@)\n    is=($(iota\
    \ ${#l[@]}))\n    srt_is=($(echo \"${is[@]}\" | tr ' ' '\\n' | sort -n | tr '\\\
    n' ' '))\n    n2=${#l[@]}\n    if [ $((n2 % 2)) -eq 0 ]; then\n        srt_is=($(echo\
    \ \"${srt_is[@]}\" | tr ' ' '\\n' | sed \"s/$(($n2 / 2))d;//\"))\n        srt_is=($(echo\
    \ \"${srt_is[@]}\" | tr ' ' '\\n' | sed \"s/$(($n2 / 2 + 1))d;//\"))\n       \
    \ echo \"${l[@]}\" | tr ' ' '\\n' | sed \"$(($n2 / 2))d;s/$/;/;s/$/\\n$(($n2 /\
    \ 2 + 1))d;/\" | sed '$s/;$//' | tr '\\n' ' ' | bc -l | sed 's/^/scale=1;/'\n\
    \    else\n        echo \"${l[@]}\" | tr ' ' '\\n' | sed \"$(($n2 / 2 + 1))d;s/$/;/\"\
    \ | tr '\\n' ' ' | bc -l | sed 's/^/scale=1;/'\n    fi", "    l=($1)\n    len=${#l[@]}\n\
    \    if (( $len == 0 )); then\n        echo 0\n    else\n        nums=`echo ${l[@]}\
    \ | tr ' ' '\\n' | sort -n`\n        mid=$(( $len / 2 ))\n        if (( $len %\
    \ 2 == 0 )); then\n            echo \"$(( ( ${nums[$mid]} + ${nums[$(( $mid -\
    \ 1 ))]} ) / 2 ))\"\n        else\n            echo \"${nums[$mid]}\"\n      \
    \  fi\n    fi", "    awk '{ asort($0); m[NR]=$((NR%2?$(int(NR/2)+1):($(int(NR/2))+$(int(NR/2)+1))/2));\
    \ } END { for (i=1;i<=NR;i++) print m[i]; }' <<< \"$1\"", "  echo $(echo $1 |\
    \ tr ' ' '\\n' | sort -n | awk '{a[i++]=$0} END {print a[int(i/2)]}')", "  local\
    \ l=($1)\n  l=($(for e in \"${l[@]}\"; do echo $e; done | sort -n))\n  local m=$((${#l[@]}/2))\n\
    \  if (( ${#l[@]} % 2 == 0 )); then\n    echo $(( (${l[$m-1]} + ${l[$m]})/2 ))\n\
    \  else\n    echo ${l[$m]}\n  fi", "    local l=$1\n    local s=$(echo \"$l\"\
    \ | wc -w)\n    local h=$(( ($s + 1) / 2 ))\n    local a=($l)\n    echo ${a[$h]}",
  "  local lst=\"\"\n  local median=\"\"\n  lst=$(echo \"$*\" | tr \" \" \"\\n\" |\
    \ sort -n)\n  if [[ $(echo \"$lst\" | wc -l)%2 == 0 ]]; then\n    median=$(echo\
    \ \"$lst\" | awk -F \" \" '{print ($(NF/2)+$(NF/2+1))/2}')\n  else\n    median=$(echo\
    \ \"$lst\" | awk -F \" \" '{print $(NF/2+1)}')\n  fi\n  echo \"$median\"", " \
    \   local -n arr=\"$1\"\n    local result=\"\"\n    local n\n    IFS=\" \" read\
    \ -r -a arr <<< \"${arr}\"\n    n=${#arr[@]}\n    if (( $n == 0 )); then\n   \
    \     result=\"0\"\n    elif (( $n == 1 )); then\n        result=\"${arr[0]}\"\
    \n    else\n        arr=($(printf '%f\\n' \"${arr[@]}\" | sort -n))\n        #\
    \ Index of mid-point.\n        ((i = (n-1)/2))\n        # Two elements?\n    \
    \    if (( $n % 2 == 0 )); then\n            # Average of two middle values.\n\
    \            (( j = i + 1 ))\n            result=$(bc -l <<< \"${arr[$i]} + ${arr[$j]}\"\
    )\n            result=$(bc -l <<< \"scale=1; ${result} / 2\")\n        else\n\
    \            result=\"${arr[$i]}\"\n        fi\n    fi\n    echo \"$result\"",
  "    l=($1)\n    n=$((${#l[@]} - 1))\n    s=()\n    for ((i = 0; i <= n; i++));\
    \ do\n        s+=($(printf \"%.3f\" $(echo \"${l[$i]}\" | bc -l)))\n    done\n\
    \    IFS=$'\\n' s=($(sort <<<\"${s[*]}\"))\n    unset IFS\n    if (((n + 1) %\
    \ 2 == 1)); then\n        echo \"${s[$((n / 2))]}\"\n    else\n        echo \"\
    $(bc -l <<<\"scale=2;(${s[$((n / 2))]} + ${s[$((n / 2 - 1))]}) / 2\")\"\n    fi",
  "  declare -a A=(\"$@\")\n  declare -a B=(\"$@\")\n  quicksort B 0 $((${#B[@]} -\
    \ 1))\n  # -1 is no element; -2 means 1 element, etc.\n  if ((${#B[@]} < 1));\
    \ then\n    echo -1\n  elif ((${#B[@]} == 1)); then\n    echo ${B[0]}\n  elif\
    \ ((${#B[@]}%2 == 1)); then\n    echo ${B[$((${#B[@]}/2))]}\n  else\n    a=$((${#B[@]}/2\
    \ - 1))\n    b=$((${#B[@]}/2))\n    echo $(echo \"${B[$a]} + ${B[$b]}\" | bc -l\
    \ | sed 's/^\\./0./')\n  fi", "  local mid=$(echo \"$1\" | wc -w | awk '{print\
    \ int($1/2)}')\n  echo \"$1\" | tr ' ' '\\n' | sort -n | head -$mid | tail -1",
  "    local l=($(echo \"$1\" | xargs -n1 | sort -n))\n    if (( ${#l[@]} == 0 ));\
    \ then\n        echo \"$(nan)\"\n        return 1\n    fi\n    local i=$(( ${#l[@]}\
    \ / 2 ))\n    echo \"${l[$i]}\"", "  l=($(sort -n <<< \"$@\"))\n  mid=$(((${#l[@]}\
    \ + 1) / 2))\n  if (($# % 2 == 0)); then\n    echo \"scale=2; (${l[$((mid - 1))]}\
    \ + ${l[$mid]}) / 2\" | bc\n  else\n    echo ${l[$((mid - 1))]}\n  fi", "    l=($1)\n\
    \    l=(\"${l[@]}\" \"${l[@]}\" \"${l[@]}\")\n    l=($(printf \"%s\\n\" \"${l[@]}\"\
    \ | sort -n))\n    size=${#l[@]}\n    p=$((size / 2))\n    e1=${l[$p]}\n    if\
    \ [ $((size % 2)) -eq 0 ]; then\n        p=$((p - 1))\n        e2=${l[$p]}\n \
    \       result=$(echo \"scale=1; ($e1 + $e2) / 2\" | bc)\n    else\n        result=$e1\n\
    \    fi\n    echo $result", "    l=( $1 )\n    printf \"%s\\n\" \"${l[@]}\" |\
    \ sort -n | perl -pe 's/\\s+/\\n/g' | awk '{ count[NR] = $1 } END { if (NR % 2)\
    \ { print count[(NR + 1) / 2] } else { print (count[(NR / 2)] + count[(NR / 2)\
    \ + 1]) / 2.0 } }'", "    local sorted=$(for i in $1; do\n        echo $i\n  \
    \  done | sort -n)\n    n=$(echo $sorted | wc -w)\n    s=$(echo $sorted | cut\
    \ -d \" \" -f $(((n+1)/2))-$(((n+2)/2)))\n    echo $(echo $s | awk '{ print ($1\
    \ + $2) / 2; }')", "    local l=\"$@\"\n    IFS=$'\\n' a=($(sort <<<\"${l}\"))\n\
    \    unset IFS\n    (( ${#a[@]}%2 )) && echo \"${a[${#a[@]}/2]}\" || echo \"$(echo\
    \ \"scale=1;(${a[$((${#a[@]}/2-1))]}+${a[$((${#a[@]}/2))]})/2\" | bc -l)\"", " \
    \ # Convert to an array\n  # https://stackoverflow.com/a/14367368/4126114\n  arr=($1)\n\
    \  arr=(\"${arr[@]}\" \"${arr[@]}\" \"${arr[@]}\") # 3 times\n  # Sort array\n\
    \  arr=($(printf '%s\\n' \"${arr[@]}\"|sort -n))\n  # Return middle element\n\
    \  echo \"${arr[${#arr[@]}/3]}\"", "  l=$@\n  count=$(echo $l | wc -w)\n  if ((\
    \ count == 1 )); then\n    echo $l\n  else\n    l=$(echo \"$l\" | tr ' ' '\\n'\
    \ | sort -n)\n    if (( count % 2 == 1 )); then\n      echo $(echo \"$l\" | sed\
    \ -n \"$((count / 2 + 1))p\")\n    else\n      first=$(echo \"$l\" | sed -n \"\
    $((count / 2))p\")\n      second=$(echo \"$l\" | sed -n \"$((count / 2 + 1))p\"\
    )\n      echo $(echo \"$first + $second\" | bc -l)\n    fi\n  fi", "  local l=()\n\
    \  local sum=0\n  local n=0\n  local m\n  for i in $1; do\n    l+=($i)\n    sum=$(bc\
    \ <<< \"$sum + $i\")\n    ((n++))\n  done\n  l=($(echo \"${l[@]}\" | tr ' ' '\\\
    n' | sort -n | tr '\\n' ' '))\n  m=$(bc <<< \"scale=0; ($n - 1) / 2\")\n  if ((\
    \ $n % 2 == 1 )); then\n    echo \"${l[$m]}\"\n  else\n    bc <<< \"scale=1; (${l[$m]}\
    \ + ${l[$m + 1]}) / 2\"\n  fi", "    local l=${@// / }  # remove spaces\n    IFS=$'\\\
    n' l=($(sort -n <<< \"$l\"))\n    printf '%.1f' \"${l[ $((${#l[@]}/2)) ]}\"",
  "  awk '\n    BEGIN {\n      OFMT = \"%.1f\"\n    }\n    {\n      a[NR] = $1\n \
    \   }\n    END {\n      if (NR % 2 == 1) {\n        print a[(NR + 1) / 2]\n  \
    \    } else {\n        print (a[NR / 2] + a[NR / 2 + 1]) / 2\n      }\n    }\n\
    \  ' <<< $1", "  sort -n $1 | awk '{if(NR%2) print $1}'", "    echo \"$1\" | awk\
    \ '{ print $2 }'", "\tl=($@) # array\n\tsz=${#l[@]} # length\n\todd=$((sz%2))\
    \ # 1 if odd, 0 if even\n\n\t# sort\n\tIFS=$'\\n' sorted=($(sort <<<\"${l[*]}\"\
    ))\n\tunset IFS\n\n\t# if odd, return middle element\n\tif [ $odd -eq 1 ]; then\n\
    \t\techo ${sorted[$((sz/2))]}\n\telse\n\t\t# if even, return average of middle\
    \ elements\n\t\tv1=${sorted[$((sz/2-1))]}\n\t\tv2=${sorted[$((sz/2))]}\n\t\techo\
    \ $(((v1+v2)/2))\n\tfi", "    local array=($1)\n    local length=${#array[@]}\n\
    \    local sorted=($(\n        printf \"%s\\n\" \"${array[@]}\" | sort -n\n  \
    \  ))\n    local mid=$(( length / 2 + length % 2))\n    if (( length % 2 == 0\
    \ )); then\n        echo $(echo \"${sorted[$((mid - 1))]} + ${sorted[$mid]}\"\
    \ | bc -l) / 2\n    else\n        echo ${sorted[$((mid - 1))]}\n    fi", "  IFS=$'\\\
    n' sorted=($(sort -n <<<\"${1}\"))\n  unset IFS\n  nel=${#sorted[@]}\n  if ((\
    \ $nel % 2 == 1 )); then     # Odd number of elements\n    val=\"${sorted[ $(($nel/2))\
    \ ]}\"\n  else                            # Even number of elements\n    (( j=nel/2\
    \ ))\n    (( k=j-1 ))\n    (( val=(${sorted[j]} + ${sorted[k]})/2 ))\n  fi\n \
    \ echo \"$val\"", "    # Split $1 into an array\n    local -a l=(\"$@\")\n   \
    \ # Sort the array\n    bubble-sort \"${l[@]}\"\n\n    # Get the middle element\
    \ (or the average of the two middle elements)\n    local mid=$((${#l[@]} / 2))\n\
    \    local median=${l[$mid]}\n    if (($# % 2 == 0)); then\n        median=$(echo\
    \ \"$median + ${l[$mid - 1]}\" | bc -l)\n        median=$(echo \"$median / 2\"\
    \ | bc -l)\n    fi\n\n    echo \"$median\"", "  local c l\n  c=$(wc -w <<<\"$1\"\
    )\n  (( c & 1 )) && { echo \"Odd number of elements in list.\" >&2; return 1;\
    \ }\n  l=($1)\n  sort -n <<<\"${l[*]}\" | sed -n $(printf '%sp' \"$((c / 2 - 1))\"\
    ),$(printf '%sp' \"$((c / 2)))\")", "    if [ ! \"$#\" -eq 1 ]; then\n       \
    \ echo \"usage: median \\\"1 2 3\\\"\" >&2\n        return 1\n    fi\n    local\
    \ list=($1)\n    local idx=(\"${!list[@]}\")\n    local mid=$(( ${#list[@]} /\
    \ 2 ))\n    local l_val\n    local r_val\n    local l\n    local r\n    function\
    \ median_cmp() {\n        #echo \"median_cmp $1 $2\"\n        if [ \"$1\" -lt\
    \ \"$2\" ]; then\n            return -1\n        elif [ \"$1\" -gt \"$2\" ]; then\n\
    \            return 1\n        else\n            return 0\n        fi\n    }\n\
    \    while true; do\n        idx=(\"${!list[@]}\")\n        if [ \"${#idx[@]}\"\
    \ -eq 1 ]; then\n            echo \"${list[${idx[0]}]}\"\n            return 0\n\
    \        fi\n        if [ \"$(( ${#idx[@]} % 2 ))\" -eq 0 ]; then\n          \
    \  # even\n            l=$(( ${#idx[@]} / 2 - 1 ))\n            r=$(( ${#idx[@]}\
    \ / 2 ))\n            median_cmp \"${list[${idx[$l]}]}\" \"${list[${idx[$r]}]}\"\
    \n            if [ \"$?\" -eq -1 ]; then\n                idx=(\"${idx[@]:0:$l}\"\
    )\n            elif [ \"$?\" -eq 1 ]; then\n                idx=(\"${idx[@]:$r}\"\
    )\n            else\n                # median is mean of l and r\n           \
    \     echo \"$(echo \"scale=1; (${list[${idx[$l]}]} + ${list[${idx[$r]}]})/2\"\
    \ | bc)\"\n                return 0\n            fi\n        else\n          \
    \  # odd\n            mid=$(( ${#idx[@]} / 2 ))\n            echo \"${list[${idx[$mid]}]}\"\
    \n            return 0\n        fi\n    }", "  local l\n  l=$(echo \"$1\" | sed\
    \ 's/[^0-9.-]/ /g' | awk '{for(i=1;i<=NF;i++)a[i]=a[i]+$i}END{if(NR==0)print \"\
    0\";if(NR%2==1)print a[int(NR/2)+1];if(NR%2==0)print (a[NR/2]+a[NR/2+1])/2}')\n\
    \  echo $l", "    # declare -a v=$1\n    v=$1\n    #  Need to handle odd and even\
    \ number of elements.\n    #\n    #  3 elements:\n    #  middle element\n    #\n\
    \    #  4 elements:\n    #  middle two elements, average\n    #\n    #  5 elements:\n\
    \    #  middle element\n    #\n    #  6 elements:\n    #  middle two elements,\
    \ average\n    #\n    #  7 elements:\n    #  middle element\n    #\n    #  8 elements:\n\
    \    #  middle two elements, average\n    #\n    #  etc.\n    #\n    #  Size of\
    \ $v is the number of elements.\n    n=$(echo $v | wc -w)\n    # Median\n    if\
    \ (( n % 2 == 1 )); then\n        # Odd number of elements\n        echo $v |\
    \ cut -d' ' -f $(((n + 1) / 2))\n    else\n        # Even number of elements\n\
    \        # Average of middle two elements\n        mid=$((n / 2))\n        echo\
    \ \"scale=10;($(echo $v | cut -d' ' -f $mid) + $(echo $v | cut -d' ' -f $((mid\
    \ + 1)))) / 2\" | bc\n    fi", "    # convert $1 to array\n    local list=()\n\
    \    for i in $1; do\n        list+=($i)\n    done\n\n    # check number of elements\n\
    \    if [ ${#list[@]} -eq 0 ]; then\n        echo \"Array is empty\"\n       \
    \ return 1\n    fi\n\n    # sort\n    local left=()\n    local right=()\n    while\
    \ [ ${#list[@]} -gt 1 ]; do\n        local key=${list[0]}\n        unset list[0]\n\
    \        for i in ${list[@]}; do\n            if [ $i -le $key ]; then\n     \
    \           left+=($i)\n            else\n                right+=($i)\n      \
    \      fi\n        done\n        list=(\"${left[@]}\" \"${right[@]}\")\n     \
    \   left=()\n        right=()\n    done\n\n    # print median\n    echo ${list[0]}",
  "    list=$1\n    len=$(wc -w <<< \"$list\")\n    # If odd number of elements.\n\
    \    if (( $len % 2 )); then\n        echo $(awk -v l=\"$list\" '\nBEGIN {\n \
    \   a[i++] = $1\n    for (i = 2; i <= NF; i++) {\n        for (j = 0; j < i-1;\
    \ j++) {\n            if ($i <= a[j]) {\n                for (k = i-1; k >= j;\
    \ k--) {\n                    a[k+1] = a[k]\n                }\n             \
    \   a[j] = $i\n                break\n            }\n        }\n        if (j\
    \ == i-1) {\n            a[i-1] = $i\n        }\n    }\n    print a[int(i/2)]",
  "    local l=\"\"\n    for x in $@; do\n        l=\"$l $x\"\n    done\n    echo\
    \ \"$l\" | sort -n | awk '{ c = (NR + 1) / 2; \n                             \
    \  if ( c == int(c) ) { printf(\"%s\", $c) } \n                              \
    \ else if ( c < int(c) + 0.5 ) { printf(\"%s\", $c) } \n                     \
    \          else { printf(\"%s\", $(c+1)) } }'", "  if [ $# -eq 0 ]; then return;\
    \ fi\n  s=$(echo \"$@\" | tr ' ' '\\n' | sort -n)\n  echo $(echo \"$s\" | awk\
    \ '{a[i++]=$0} END {print a[int(i/2)]}')", "  local l=($(sort -n <<< \"$1\"))\n\
    \  local m=$(( ${#l[@]} / 2 ))\n  if (( ${#l[@]} % 2 == 0 )); then\n    echo \"\
    scale=1; (${l[$m-1]} + ${l[$m]}) / 2\" | bc\n  else\n    echo \"${l[$m]}\"\n \
    \ fi", "  l=($(echo \"$1\" | tr \" \" \"\\n\" | sort -n))\n  let n=(${#l[@]}-1)/2\n\
    \  [[ ${#l[@]} -eq 1 ]] && echo \"${l[0]}\" && return\n  let n1=n/2+n%2\n  let\
    \ n2=n/2\n  echo $(bc -l <<< \"${l[$n1]}+${l[$n2]}\")/2", "    input=($1)\n  \
    \  mid=$(((${#input[@]}-1)/2))\n    # https://www.linuxquestions.org/questions/programming-9/sorting-integer-array-bash-222939/\n\
    \    # `sort -n` sorts the array numerically, `cut -d\" \" -f$mid` cuts out the\
    \ middle element\n    # (or the two middle elements and averages them for odd\
    \ numbers of elements).\n    # In bash, `sort -n` sorts the array by alphabetical\
    \ order, with 0 < 1 < 10, so\n    # we have to use `sort -g` instead (which sorts\
    \ numerically with 0 < 1 < 10).\n    if (( $# % 2 == 1 )); then\n        echo\
    \ \"$(printf \"%0.1f\" $(echo \"${input[@]}\" | tr \" \" \"\\n\" | sort -g | cut\
    \ -d\" \" -f$mid))\"\n    else\n        echo \"$(printf \"%0.1f\" $(echo \"${input[@]}\"\
    \ | tr \" \" \"\\n\" | sort -g | cut -d\" \" -f$mid-`expr $mid + 1` | awk '{ print\
    \ $1 + $2 / 2 }'))\"\n    fi", "    local -a a=($(echo \"$1\" | tr ' ' '\\n' |\
    \ sort -n))\n    local -i m=$(( ${#a[@]} / 2 ))\n    if (( ${#a[@]} % 2 )); then\n\
    \        echo ${a[$m]}\n    else\n        echo \"scale=1; (${a[$m-1]} + ${a[$m]})/2\"\
    \ | bc\n    fi", "    # Sort the list\n    l=($(echo \"$1\" | tr ' ' '\\n' | sort\
    \ -n))\n    # If number of elements is odd\n    if [ $(( ${#l[@]} % 2 )) -eq 1\
    \ ]; then\n        # Return middle element\n        echo ${l[ $(( (${#l[@]}+1)/2-1\
    \ )) ]}\n    else\n        # Return mean of two elements\n        echo \"scale=1;\
    \ (${l[ $(( (${#l[@]})/2-1 )) ]} + ${l[ $(( (${#l[@]})/2 )) ]}) / 2\" | bc\n \
    \   fi", "    local l=\"\"\n    local l_size=\"\"\n    local l_median=\"\"\n \
    \   local l_median_index=\"\"\n    local sum=\"\"\n    local c=\"\"\n    local\
    \ median_value=\"\"\n\n    # We need at least three elements to have a median.\n\
    \    l_size=\"$(echo $1 | wc -w)\"\n    if [[ \"$l_size\" -lt \"3\" ]]; then\n\
    \        echo \"$1\"\n        return 0\n    fi\n\n    # Generate a sorted list\
    \ of the elements.\n    l=\"$(echo $1 | tr \" \" \"\\n\" | sort -n)\"\n\n    #\
    \ Odd size. Median is the middle element.\n    if [[ \"$l_size\" -eq \"3\" ]];\
    \ then\n        echo \"$l\" | tr \" \" \"\\n\" | sed -n '2p'\n        return 0\n\
    \    fi\n\n    # Even size. Median is the average of the two middle elements.\n\
    \    if [[ \"$l_size\" -gt \"3\" ]]; then\n        # We're interested in the two\
    \ elements in the middle,\n        # but with an array index of 1.\n        let\
    \ l_median_index=($l_size/2)\n        l_median=\"$(echo \"$l\" | tr \" \" \"\\\
    n\" | sed -n \"${l_median_index}p\")\"\n        let l_median_index=($l_median_index+1)\n\
    \        l_median=\"$l_median $(echo \"$l\" | tr \" \" \"\\n\" | sed -n \"${l_median_index}p\"\
    )\"\n        sum=0\n        for c in $l_median; do\n            let sum=$sum+$c\n\
    \        done\n        let median_value=$sum/2\n        echo $median_value\n \
    \       return 0\n    fi", "    med=$(sort -n <<<\"$1\" | awk '{a[i++]=$1;};END{print\
    \ (a[int(i/2)]+a[int((i-1)/2)])/2}')\n    echo $med", "  local median\n  local\
    \ array=($1)\n  local n=${#array[@]}\n  local i\n  local j\n  # Sort the list\
    \ in ascending order.\n  for ((i=0; i<n; i++)); do\n    for ((j=i+1; j<n; j++));\
    \ do\n      if (($(echo \"${array[i]} > ${array[j]}\" | bc -l))); then\n     \
    \   # Swap the two values.\n        local temp=${array[i]}\n        array[i]=${array[j]}\n\
    \        array[j]=$temp\n      fi\n    done\n  done\n  if (($(echo \"$n % 2 ==\
    \ 0\" | bc -l))); then\n    # n is even.\n    # Median is the mean of the middle\
    \ two elements.\n    # (Note: in this case, the array has n+1 elements)\n    local\
    \ m1=${array[$(($n/2))]}\n    local m2=${array[$(($n/2 - 1))]}\n    median=$(echo\
    \ \"scale=1;($m1 + $m2) / 2\" | bc -l)\n  else\n    # n is odd.\n    # Median\
    \ is the middle element.\n    median=${array[$(($n/2))]}\n  fi\n  echo $median",
  "    local l=($@)\n    sort -n $l\n    # l=$(sort -n <<<\"$l\") # alternative\n\
    \    local m=${#l[@]}\n    [[ $((m % 2)) -eq 1 ]] && echo \"${l[$((m / 2))]}\"\
    \ || \\\n        echo \"$(echo \"scale=1; (${l[$((m / 2 - 1))]} + ${l[$((m / 2))]})\
    \ / 2\" | bc -l)\"", "  local _value\n  local -a _sorted\n  local -i _middle _median_index\n\
    \  _sorted=($(echo \"$1\" | tr ' ' '\\n' | sort -n))\n  _middle=$(( ${#_sorted[@]}\
    \ / 2 ))\n  _median_index=$(( ${#_sorted[@]} % 2 ))\n  if (( _median_index ));\
    \ then\n    _value=\"${_sorted[$_middle]}\"\n  else\n    _value=$(echo \"scale=1;\
    \ (${_sorted[$_middle - 1]} + ${_sorted[$_middle]}) / 2\" | bc)\n  fi\n  echo\
    \ \"$_value\"", "    c=0\n    for x in $1; do\n        if [ \"$x\" != '' ]; then\n\
    \            c=$((c+1))\n        fi\n    done\n    if [ $c -eq 0 ]; then\n   \
    \     echo \"0\"\n        return 0\n    fi\n    if [ $c -eq 1 ]; then\n      \
    \  echo \"$x\"\n        return 0\n    fi\n    a=($1)\n    if [ $((c%2)) -eq 1\
    \ ]; then\n        ((d=(c-1)/2))\n        echo \"${a[$d]}\"\n    else\n      \
    \  ((d=(c/2)-1))\n        echo \"scale=2; (${a[$d]}+${a[$d+1]})/2\" | bc\n   \
    \ fi", "    if [[ $# == 0 ]]; then\n        echo \"\"\n        return\n    fi\n\
    \    local m=( $(sorted \"$*\") )\n    local len=$(echo ${#m[@]})\n    if (($len\
    \ % 2 == 1)); then\n        echo ${m[$((($len-1)/2))]}\n    else\n        echo\
    \ $(echo ${m[$((($len-1)/2))]} + ${m[$((($len-1)/2+1))]} | bc -l)\n    fi", " \
    \   local l=($(echo \"$@\" | tr ' ' '\\n' | sort -n))\n    local count=${#l[@]}\n\
    \    local middle=$((count / 2))\n    echo ${l[$middle]}", "  l=($(echo $1 | tr\
    \ ' ' '\\n' | sort -n))\n  m=${#l[@]}\n  ((i = m / 2))\n  ((m % 2 == 0)) && {\n\
    \    echo $(echo \"${l[i - 1]} + ${l[i]}\" | bc -l) / 2 | bc -l\n  } || {\n  \
    \  echo ${l[i]}\n  }", "    local count=$(echo $1 | wc -w)\n    local m=$(((count+1)/2))\n\
    \    local sorted=$(printf \"%s\\n\" $1 | sort -n)\n    # printf \"count=%s, m=%s,\
    \ sorted=%s\\n\" $count $m \"$sorted\"\n    if (( m*2 == count )); then\n    \
    \    echo \"$(printf \"%s\\n\" $sorted | sed -n $m'p;'$((m+1))'p' | awk '{print\
    \ ($1+$2)/2}')\"\n    else\n        echo \"$(printf \"%s\\n\" $sorted | sed -n\
    \ $m'p')\"\n    fi", "    local l=($1)\n    local i=0\n    local cmp=()\n    local\
    \ i1\n    local i2\n    local mi\n    local mi1\n    local mi2\n    local sums\n\
    \    local sums1\n    local sums2\n    local avg\n    local avg1\n    local avg2\n\
    \    local median\n\n    # Find median\n    while [ ${#l[@]} -gt 1 ]; do\n   \
    \     # even\n        if [ $((${#l[@]} % 2)) -eq 0 ]; then\n            i1=$((${#l[@]}\
    \ / 2 - 1))\n            i2=$((${#l[@]} / 2))\n            sums1=$((${l[$i1]}\
    \ + ${l[$i2]}))\n            avg1=$(echo \"$sums1 / 2\" | bc -l)\n           \
    \ l=(${l[@]:0:$i1} $avg1 ${l[@]:$(($i2 + 1))})\n        # odd\n        else\n\
    \            i=$((${#l[@]} / 2))\n            avg=${l[$i]}\n            l=(${l[@]:0:$i}\
    \ ${l[@]:$(($i + 1))})\n        fi\n    done\n\n    # print median\n    echo ${l[0]}",
  "    l=($(echo \"$@\" | tr ' ' '\\n' | sort -n))\n    n=$((${#l[@]}-1))\n    if\
    \ (($n<0)); then\n        echo \"0\"\n    elif (($n%2==0)); then\n        echo\
    \ $(echo \"${l[$(($n/2))]} + ${l[$(($n/2+1))]}\" | bc -l)\n    else\n        echo\
    \ \"${l[$(($n/2))]}\"\n    fi"]
stop_tokens:
- "\n}"
