name: HumanEval_34_unique
language: sh
prompt: "#!/bin/bash\n# Return sorted unique elements in a list\n# >>> $(unique \"\
  5 3 5 2 3 3 9 0 123\")\n# ['\"0\"', '\"2\"', '\"3\"', '\"5\"', '\"9\"', '\"123\"\
  ']\n#\n# $1 is a space-separated list\nunique() {\n"
tests: "}\n\ncandidate() {\n    unique \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
  \ \"5 3 5 2 3 3 9 0 123\") = \"0 2 3 5 9 123\" ]]\n}\n\nrun_test"
completions: ["    list=($(for e in \"$@\"; do echo \"$e\"; done | sort -u))\n   \
    \ echo \"[$(for e in \"${list[@]}\"; do echo \"\\\"$e\\\"\"; done | paste -sd\
    \ ',')]\"", "  echo \"$@\" | tr ' ' '\\n' | sort -u | tr '\\n' ' '", "  local\
    \ array=$1\n  local -a newArray\n  for i in ${array}; do\n    if [[ ! \" ${newArray[@]}\
    \ \" =~ \" ${i} \" ]]; then\n      newArray+=(\"${i}\")\n    fi\n  done\n  echo\
    \ ${newArray[@]}", "  # For each entry of the given list\n  while [ \"$#\" -gt\
    \ 0 ]; do\n    # There is no current element?\n    if [ -z \"${CURRENT_ELEMENT}\"\
    \ ]; then\n      # Set the first element\n      CURRENT_ELEMENT=\"$1\"\n    #\
    \ The current element is a new one?\n    elif [ \"${CURRENT_ELEMENT}\" != \"$1\"\
    \ ]; then\n      # Set the new element\n      CURRENT_ELEMENT=\"$1\"\n      #\
    \ Add the current element to the result list\n      printf '%s' \"${CURRENT_ELEMENT}\"\
    \n      printf ' '\n    fi\n    # Next entry\n    shift\n  done", "  eval '\n\
    \    declare -a list=($1)\n    sorted=($(printf \"%s\\n\" \"${list[@]}\" | sort\
    \ -r))\n    for i in \"${sorted[@]}\"; do\n      if [[ -z $unique ]]; then\n \
    \       unique=$i\n      elif [[ \"$unique\" != *\"$i\"* ]]; then\n        unique+=\"\
    \ $i\"\n      fi\n    done\n    echo \"$unique\"\n  '", "    sorted=$(echo \"\
    $*\" | tr ' ' '\\n' | sort -u | tr '\\n' ' ')\n    if [ -z \"$sorted\" ]; then\n\
    \        echo \"''\"\n    else\n        echo \"'$sorted'\"\n    fi", '    python
    -c "import sys; sorted(set(sys.argv[1:]))" $*', '    echo "$1" | sort -u | xargs
    -n1', '    echo "$(sort -n -u <<<"$1")"', "    _list=\"$1\"\n    _list=${_list//\
    \ /' '}\n    echo \"[$(printf '\"%s\" ' $(printf '%s\\n' \"${_list[@]}\" | sort\
    \ -u))]\"", "    python -c \"print ' '.join(sorted(set(\\\"$1\\\".split())))\"",
  "    if [[ -z \"$1\" ]]; then\n        return\n    fi\n    echo \"$1\" | \\\n  \
    \      tr \" \" \"\\n\" | \\\n        sort -n | \\\n        uniq | \\\n      \
    \  jq -Rc '.[]' | \\\n        jq -s 'sort'", "    echo \"$(echo \"$1\" | awk '{\
    \ for (i = 1; i <= NF; i++) { print $i } }' | sort -u | tr '\\n' ' ')\"", "  for\
    \ i in $1; do\n    echo \"$i\"\n  done | sort -n | uniq", "    tr ' ' '\\n' <<<\
    \ \"$@\" | sort -n | uniq", "  local LIST=\"$@\"\n  local UNIQUE\n  local ARRAY=()\n\
    \  for ELEMENT in $LIST; do\n    if [[ -z \"$(echo \"${ARRAY[@]}\" | grep -o \"\
    $ELEMENT\")\" ]]; then\n      ARRAY+=(\"$ELEMENT\")\n    fi\n  done\n  IFS=$'\\\
    n' SORTED=($(sort <<<\"${ARRAY[*]}\"))\n  unset IFS\n  echo \"${SORTED[*]}\"",
  "  local n=$'\\n' IFS=$' '\n  printf \"[%s]\" $(printf \"%s\\n\" \"$*\" | sort -n\
    \ | uniq | sed -e 's/^/\"/' -e 's/$/\"/' -e \"s/^$n//\" -e \"s/$n$//\")", "  local\
    \ _line=\"${1}\"\n  _line=${_line// /\\\\n}\n  _line=${_line//\\'/\\'\\\"\\'\\\
    \"\\'}\n  echo -n \"[\"\n  paste -sd, <(printf %s \"${_line}\" | sort -u) | sed\
    \ 's/^/\"/;s/$/\"/'\n  echo -n \"]\"", "  local list=$1\n  local result=()\n \
    \ for item in $list; do\n    if [[ ! \" ${result[@]} \" =~ \" ${item} \" ]]; then\n\
    \      result=(\"${result[@]}\" \"$item\")\n    fi\n  done\n  IFS=$'\\n' sorted=($(sort\
    \ <<<\"${result[*]}\"))\n  echo \"${sorted[*]}\"", "    (\n        IFS=$'\\n'\
    \ sorted=($(sort <<<\"$*\"))\n        unset IFS\n        printf \"%s\\n\" \"${sorted[@]}\"\
    \n    ) | uniq", "    python -c \"\n#!/usr/bin/env python\nl = ['\\\"{}\\\"'.format(x)\
    \ for x in sorted(set([int(i) for i in '$1'.split()]))]\nprint('[{}]'.format(',\
    \ '.join(l)))\n\"", "    local -a list\n    local -a unique\n    local -i i\n\
    \    IFS=' ' read -r -a list <<< \"$1\"\n    unique=(\"${list[0]}\")\n    for\
    \ ((i=1; i<${#list[@]}; i++)); do\n        [[ ! \" ${unique[*]} \" =~ \" ${list[i]}\
    \ \" ]] && unique+=(\"${list[i]}\")\n    done\n    # NOTE: Double quotes to prevent\
    \ word splitting.\n    printf '\"%s\" ' \"${unique[@]}\"", "  local list=\"\"\n\
    \n  while read -r element; do\n    list=\"$list $element\"\n  done <<< \"$1\"\n\
    \n  local unique=\"$(tr ' ' '\\n' <<< \"$list\" | sort -n | uniq | tr '\\n' '\
    \ ')\"\n\n  while read -r element; do\n    echo -n '\"'$element'\"'\n  done <<<\
    \ \"$unique\"", "    local sorted_array=($(for i in $1; do echo $i; done | sort\
    \ -n))\n    local old_element=\"\"\n    local new_array=()\n    for element in\
    \ ${sorted_array[@]}; do\n        [[ $element != $old_element ]] && new_array+=(\"\
    $element\")\n        old_element=$element\n    done\n    echo ${new_array[@]}",
  "    echo -n \"$(xargs echo | tr ' ' '\\n' | sort -n | uniq | xargs)\"", "    echo\
    \ \"$@\" | tr ' ' '\\n' | sort -u | tr '\\n' ' '", "  local list=($@)\n  local\
    \ unique_list=()\n  local checked=()\n  local element=\n  local idx=\n\n  for\
    \ element in \"${list[@]}\"; do\n    idx=$(value_index \"$element\" \"${checked[@]}\"\
    )\n    if [ \"$idx\" == -1 ]; then\n      checked+=(\"$element\")\n      unique_list+=(\"\
    $element\")\n    fi\n  done\n\n  for element in \"${unique_list[@]}\"; do\n  \
    \  echo \"$element\"\n  done", "    declare -a unique\n    declare -a list=($1)\n\
    \    for element in \"${list[@]}\"; do\n        if [[ ! \"${unique[@]}\" =~ \"\
    ${element}\" ]]; then\n            unique+=(\"${element}\")\n        fi\n    done\n\
    \    IFS=$'\\n' sorted=($(sort <<<\"${unique[*]}\"))\n    echo \"${sorted[*]}\"",
  '  echo $1 | tr " " "\n" | sort -u | tr "\n" " "', "  local -a input=($1)\n  local\
    \ -a output=($(echo ${input[@]} | tr ' ' '\\n' | sort -r | uniq | sort -r))\n\
    \  echo -n ${output[@]}", "  echo -n \"[\"\n  local OLDIFS=$IFS; IFS=$' '\n  for\
    \ i in $1; do\n    if ! [[ $i =~ (^| )$i($| ) ]]; then\n      echo -n '\"'$i'\"\
    '\n    fi\n  done | sort -u\n  IFS=$OLDIFS\n  echo -n \"]\"", "    echo $(echo\
    \ $1 | sed -e 's/ /\\n/g' | sort -u | sed -e 's/$/\",/g' | sed -e 's/^/\"/g')",
  "  # delete duplicates and sort by value\n  echo -n \"$1\" | sed -e 's/ /\\n/g'\
    \ | sort -u", "    for v in $1; do\n        printf '\"%s\" ' \"$v\"\n    done\
    \ | sort -u | tr -d '[:space:]'", '  echo $1 | xargs -n1 | sort -u | xargs', '  uniq
    -u | sort -n | xargs', "  awk 'BEGIN {\n    split(ARGV[1], list, \" \")\n    for\
    \ (i in list) {\n      seen[list[i]]++\n    }\n    for (s in seen) {\n      print\
    \ s\n    }\n  }' \"$@\" | sort -n", '  echo "$1" | tr " " "\n" | sort -u | tr
    "\n" " "', "  local __items=($1)\n  printf '%s\\n' \"${__items[@]}\" | sort -u",
  "    local x\n    for x in $1; do\n        echo \"$x\"\n    done | sort -u", '    echo
    $1 | xargs -n1 | sort -u | xargs', "    readarray -t arr < <(printf \"%s\\n\"\
    \ \"$1\" | sort -u)\n    printf \"%s\\n\" \"${arr[@]}\"", '    echo $(echo $1
    | tr " " "\n" | sort -u | tr "\n" " ")', "  echo \"$1\" | tr ' ' '\\n' | sort\
    \ -u | tr '\\n' ' ' | sed 's/^[ \\t]*//;s/[ \\t]*$//'", "  items=()\n  for item\
    \ in $1; do\n    if [[ ! \"${items[@]}\" =~ \"$item\" ]]; then\n      items+=($item)\n\
    \    fi\n  done\n  # sort the items in ascending order\n  items=($(for item in\
    \ ${items[@]}; do echo $item; done | sort -n))\n  # echo the JSON representation\
    \ of the array\n  echo \"[$(IFS=,; echo \"${items[*]}\")]\"", "  echo \"$1\" |\
    \ tr ' ' '\\n' | sort -u | tr '\\n' ' '", "    echo \"$1\" | tr ' ' '\\n' | sort\
    \ -n | uniq | tr '\\n' ' '", "  local IFS=$'\\n'  # Set Internal Field Separator\
    \ to newline\n  echo $1 | awk '!a[$0]++' | sed 's/^/\"/g' | sed 's/$/\"/g' | paste\
    \ -s -d ','", "    echo $(echo $1 | tr ' ' '\\n' | sort -n | uniq | tr '\\n' '\
    \ ')", "    local list=\"$1\"\n    local i sorted_list=\"\"\n    for i in $list;\
    \ do\n        if [[ \"$sorted_list\" != *\" $i \"* ]]; then\n            sorted_list=\"\
    $sorted_list $i\"\n        fi\n    done\n    sorted_list=$(echo $sorted_list |\
    \ sed 's/^ //')\n    echo $sorted_list", "    local n=0\n    local arr=()\n  \
    \  for i in $1; do\n        local is_new=true\n        for j in \"${arr[@]}\"\
    ; do\n            if [[ \"$i\" == \"$j\" ]]; then\n                is_new=false\n\
    \                break\n            fi\n        done\n        if $is_new; then\n\
    \            arr[n]=$i\n            n=$((n+1))\n        fi\n    done\n    echo\
    \ ${arr[@]}", "  ARRAY=$(echo $1 | tr \" \" \"\\n\" | sort -u | tr \"\\n\" \"\
    \ \")\n  echo $ARRAY", "  IFS=\" \"\n  echo $(for i in $1; do echo \"$i\"; done\
    \ | sort -u | xargs)", "  echo \"[$(echo \"$1\" | sed 's/ /\",\"/g' | xargs -n1\
    \ | sort -u | xargs | sed 's/ /\",\"/g')]\"", "    echo \"$1\" | tr ' ' '\\n'\
    \ | sort -u | tr '\\n' ' '", "  for i in $1; do\n    echo \"$i\"\n  done | sort\
    \ -u", '    echo $1 | xargs -n1 | sort -u | xargs', "    arr=(\"$@\")\n    arr=($(printf\
    \ \"%s\\n\" \"${arr[@]}\" | sort -u | tr '\\n' ' '))\n    if [ -z \"$arr\" ];\
    \ then\n        echo \"[]\"\n    else\n        echo \"[${arr[@]}]\"\n    fi",
  "    local __l=($1)\n    local __n=(\"${__l[@]}\")\n    local __i\n    local __d\n\
    \    local __r=()\n    local __x\n\n    for (( __i=0; __i<${#__l[@]}; __i++ ));\
    \ do\n        __x=${__l[$__i]}\n        if [[ -z \"${__d}\" ]]; then\n       \
    \     __d=(\"$__x\")\n        else\n            if ! echo \"${__d[@]}\" | grep\
    \ -q -E \"(^| )$__x($| )\"; then\n                __d=(\"${__d[@]}\" \"$__x\"\
    )\n            fi\n        fi\n    done\n\n    for (( __i=0; __i<${#__d[@]}; __i++\
    \ )); do\n        __x=${__d[$__i]}\n        __r=(\"${__r[@]}\" \"$__x\")\n   \
    \ done\n\n    echo \"${__r[@]}\"", "  local elements=(\"$@\")\n  if [ ${#elements[@]}\
    \ -gt 0 ]; then\n    echo \"[\"$(printf '\"%s\" ' \"${elements[@]}\" | sed -e\
    \ 's/ /\", \"/g')\"]\"\n  fi", "  # Write each element in the list on a separate\
    \ line\n  # Sort lines\n  # Eliminate lines that are duplicates of the line above\n\
    \  # Convert newline-separated list back to space-separated list\n  echo \"$1\"\
    \ |\n    tr ' ' '\\n' |\n    sort |\n    uniq |\n    tr '\\n' ' '", "    printf\
    \ '%s\\n' \"$*\" | sort -u | xargs -I{} echo '\"{}\"'", "  declare -a array=(\"\
    $@\")\n  sorted=($(printf \"%s\\n\" \"${array[@]}\" | sort -n))\n  printf '%s\\\
    n' \"${sorted[@]}\" | uniq", "    local i\n    for i in $1; do\n        echo $i\n\
    \    done | sort -u", "    local list\n    list=$(echo \"$1\" | tr ' ' '\\n' |\
    \ sort -n | uniq)\n    echo \"[\\\"${list//$'\\n'/\\\", \\\"}\\\"]\"", "    echo\
    \ \"[`echo $1 | tr ' ' '\\n' | sort -u | xargs -i echo -n '\"{}\" '`]\"", "  \
    \  echo \"$1\" | tr ' ' '\\n' | sort -n | uniq | tr '\\n' ' '", "    local __resultvar=$1\n\
    \    local result=''\n    local elements=(${*:2})\n    elements=($(printf \"%s\\\
    n\" \"${elements[@]}\" | sort -u))\n    local IFS=$'\\n'\n    result=$(printf\
    \ \"%s\" \"${elements[*]}\")\n    result=${result// /'\", \"'}\n    result='[\"\
    '$result'\"]'\n    if [[ \"$__resultvar\" ]]; then\n        eval $__resultvar=\"\
    '$result'\"\n    else\n        echo \"$result\"\n    fi", "    local list=$1\n\
    \    local elements=($list)\n    local unique_elements=()\n    local elem\n  \
    \  for elem in \"${elements[@]}\"; do\n        if [ \"$elem\" != '' ]; then\n\
    \            unique_elements+=($elem)\n        fi\n    done\n    echo \"${unique_elements[@]}\"\
    \ | tr ' ' '\\n' | sort -u | tr '\\n' ' '", "  if [ $# -eq 0 ]; then\n    echo\
    \ \"No argument provided\"\n    return 1\n  fi\n  # Trim whitespace, sort and\
    \ remove duplicates\n  echo \"$@\" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//'\
    \ | tr ' ' '\\n' | sort -u", '  echo "\"$( echo "$1" | tr " " "\n" | sort -n |
    uniq | tr "\n" "\" \"" )\""', "    echo $1 | tr ' ' '\\n' | sort -u | tr '\\n'\
    \ ' ' | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//'", "    echo $1 | tr\
    \ ' ' '\\n' | sort -nu | tr '\\n' ' '", "    local l=\"$1\"\n    local unique_list=()\n\
    \    while read e; do\n        if ! in_list \"$e\" \"${unique_list[@]}\"; then\n\
    \            unique_list+=(\"$e\")\n        fi\n    done <<< \"$l\"\n    echo\
    \ \"[$(json_join \"${unique_list[@]}\")]\"", "    [ $# -eq 0 ] && return\n   \
    \ echo \"$@\" | tr ' ' '\\n' | sort -u | tr '\\n' ' '", "  echo \"[$(printf '\"\
    %s\" ' \"$@\" | sort -u | tr '\\n' ' ')]\"", "    local arr\n    arr=($1)\n\n\
    \    (IFS=$'\\n'; echo \"${arr[*]}\") | sort -u | tr '\\n' ' '", "    echo \"\
    [$(printf '\"%s\",' $1 | xargs -n1 | sort -u | xargs)]\"", '  echo $1 | tr " "
    "\n" | sort -u | xargs -n1 | xargs -I{} echo \"{}\"', "    echo \"[\"$(echo $1\
    \ | tr \" \" \"\\n\" | sort -n | uniq | sed 's/.*/\"&\"/g' | tr \"\\n\" \",\"\
    \ | sed \"s/,$//\")\"]\"", "    echo -n $1 | tr ' ' '\\n' | sort -u | tr '\\n'\
    \ ' '", "  python -c \"print(sorted(set(map(int, '$1'.split()))))\"", "  tr '\
    \ ' '\\n' <<< \"$1\" |\n  sort -u |\n  awk '{printf \"\\\"%s\\\" \", $0}'", " \
    \   echo $(echo \"$1\" | awk '{ for (i=1; i<=NF; i++) print $i }' | sort -u)",
  "  # This is not optimal. Perhaps: printf \"%s\\n\" \"$@\" | sort -u\n  echo $(echo\
    \ $1 | tr \" \" \"\\n\" | sort -n | uniq | tr \"\\n\" \" \")", "  # remove all\
    \ duplicates\n  local data=$(tr ' ' '\\n' <<< \"$1\" | sort -u)\n  # a nice and\
    \ clean output\n  tr '\\n' ' ' <<< \"$data\"", "    local i\n    for i in \"$@\"\
    ; do\n        echo \"[\\\"$i\\\"]\"\n    done | sort -u | xargs", "    local list=\"\
    $*\"\n    echo \"$list\" | xargs -n1 | sort -u | xargs", "  declare -a tmp\n \
    \ while IFS= read -r -d '' element; do\n    if ! has \"$element\" \"${tmp[@]}\"\
    ; then\n      tmp+=(\"$element\")\n    fi\n  done < <(echo \"$1\" | sort -z |\
    \ tr \" \" \"\\0\")\n  echo \"${tmp[@]}\"", "    for i in $1; do\n        echo\
    \ $i\n    done | sort -u", "    local result=\"\"\n    for i in $1; do\n     \
    \   if [[ $result != *\"$i\"* ]]; then\n            result+=\"$i \"\n        fi\n\
    \    done\n    echo \"[${result// /, }]\"", "    jq -ncM --argjson a \"$(echo\
    \ $1 | jq -Rnc --argjson a \"[]\")\" 'unique_by(length)[a]'", "    local -a elems=($1)\n\
    \    local -A unique_elems\n    for elem in \"${elems[@]}\"; do\n        unique_elems[$elem]=0\n\
    \    done\n    sorted_elems=()\n    for elem in \"${!unique_elems[@]}\"; do\n\
    \        sorted_elems+=(\"$elem\")\n    done\n    echo \"$(IFS=$'\\n'; echo \"\
    ${sorted_elems[*]}\")\"", "    local ret=\"$1\"\n    ret=\"${ret// /\\ }\"  #\
    \ Replace spaces with literal spaces.\n    ret=\"[${ret// /, }]\"\n    ret=\"\
    $(jq -sR . <<< \"$ret\" | jq -s unique)\"\n    ret=\"${ret//, }\"\n    ret=\"\
    ${ret// /, }\"\n    ret=\"${ret:2:$((${#ret}-4))}\"\n    echo \"$ret\"", "   \
    \ echo \"[$(echo \"$1\" | tr ' ' '\\n' | sort -u | sed 's/^/\"/g' | sed 's/$/\"\
    /g' | tr '\\n' ',' | sed 's/,$//g')]\"", "  local a\n  for e in $1; do\n    if\
    \ [[ $e =~ ^[+-]?[0-9]+([.][0-9]+)?$ ]]; then\n      e=\"$e\"\n    else\n    \
    \  e=\"\\\"$e\\\"\"\n    fi\n    a[$e]=$e\n  done\n  echo ${a[@]} | tr ' ' '\\\
    n' | sort -V | tr '\\n' ' '", "    printf '[%s]' \"$(sort -u -g <<<\"$1\" | sed\
    \ -E 's/^\\s+//;s/\\s+$//;s/\\s+/, /g')\"", "    echo \"$1\" | tr ' ' '\\n' |\
    \ sort -u | tr '\\n' ' ' | sed -E 's/^(.*)$/[\\1]/'", "    local list=$1\n   \
    \ list=$(echo $list | tr \" \" \"\\n\")\n    list=$(echo -e \"$list\" | sort -n\
    \ | uniq)\n    list=$(echo -e \"$list\" | tr \"\\n\" \" \")\n    echo -e \"$list\"",
  "    printf \"[%s]\" \"$(for el in $1; do\n        ! [[ \"$(printf \",%s\" \"${_uniq[@]}\"\
    )\" =~ \",$el\" ]] && _uniq+=($el)\n    done; printf '\"%s\" ' \"${_uniq[@]}\"\
    )\"", "    echo $1 | tr ' ' '\\n' | sort -u | tr '\\n' ' '", "    local x=\"\"\
    \n    for j in $1; do\n        if [ -z \"$(echo \"$x\" | grep \"$j\")\" ]; then\n\
    \            x=\"$x $j\"\n        fi\n    done\n    echo \"$x\"", "  items=($@)\n\
    \  unset result\n  for item in ${items[@]}; do\n    if [[ \" ${result[@]} \" =~\
    \ \" ${item} \" ]]; then\n      :\n    else\n      result=(\"${result[@]}\" \"\
    ${item}\")\n    fi\n  done\n  printf '%s\\n' \"${result[@]}\"", "  echo $(echo\
    \ \"$1\" | tr ' ' '\\n' | sort -u | tr '\\n' ' ')", "    echo \"$(echo $@ | tr\
    \ ' ' '\\n' | sort -n | uniq | tr '\\n' ' ')\"", "  echo \"[$(echo $@ | sed -e\
    \ 's/ /\", \"/g')]\" | sed -e 's/^\\[\", //' -e 's/\", \"\\]$//' | sort -n | uniq\
    \ | sed -e 's/\\([^\"0-9][0-9]*\\)\\(.*\\)/\"\\1\"\\2/'", "    echo \"$@\" | tr\
    \ ' ' '\\n' | sort -u", "    echo $(echo \"$1\" | sort -u | sed 's/ /\", \"/g')",
  "    local elements\n    if [ $# -eq 0 ]; then\n        elements=\"$(cat)\"\n  \
    \  else\n        elements=\"$*\"\n    fi\n    echo \"$elements\" | tr ' ' '\\\
    n' | sort -u | tr '\\n' ' '", '    echo $(printf "%s\n" $1 | sort -u | jq -R .)',
  "  echo -n \"[\"\n  for i in $(echo $1 | tr \" \" \"\\n\" | sort -u); do\n    echo\
    \ -n \\\"$i\\\",\n  done\n  echo -n \"]\"", '    echo "$1" | tr " " "\n" | sort
    -u | tr "\n" " "', "  python3 -c \"import sys; print(' '.join(sorted(set(sys.argv[1:]))))\"\
    \ $@", "  set -f; IFS=' '\n  tmp=$(printf \"%s\\n\" \"$@\" | sort -u | tr '\\\
    n' ' ');\n  set +f; IFS=$' \\t\\n'\n  printf \"[%s]\" \"${tmp% }\"", "    echo\
    \ -n \"[\"\n    echo \"$1\" | tr \" \" \"\\n\" | sort -g | uniq | while read -r\
    \ i; do\n        echo -n '\"'$i'\"'\n        echo -n \", \"\n    done | head -c\
    \ -2\n    echo -n \"]\"", "    echo $1 | tr ' ' '\\n' | sort -u | tr '\\n' ' '",
  "    echo \"$1\" | tr ' ' '\\n' | sort -n | uniq | awk '{printf(\"\\\"%s\\\" \"\
    , $0)}'", "    local list=$1\n    local uniq=()\n    for word in $list; do\n \
    \       if ! contains \"$word\" \"${uniq[@]}\"; then\n            uniq=(\"${uniq[@]}\"\
    \ \"$word\")\n        fi\n    done\n    # NB, sort() will sort strings in alphabetical\
    \ order\n    # if you want numeric sort, you need to convert the\n    # values\
    \ to int, sort, then convert back to string\n    echo $(sort \"${uniq[@]}\")",
  '    echo -n $1 | tr " " "\n" | sort -u | tr "\n" " "', "    echo -e \"[$(tr ' '\
    \ '\\n' <<< \"$1\" | sort -n | uniq | tr '\\n' ' ')]\"", "  printf \"[\"\n  printf\
    \ \"%s, \" $(echo $1 | tr \" \" \"\\n\" | sort -n | uniq)\n  printf \"]\"", '    echo
    "$@" | xargs -n1 | sort -u', "    # Usage check\n    if [[ -z \"$1\" ]]; then\n\
    \        return\n    fi\n\n    # If the only arg is a hyphen, read from stdin\n\
    \    if [[ \"$1\" == \"-\" ]]; then\n        read -a input\n    else\n       \
    \ # Read args as an array\n        input=($*)\n    fi\n\n    # Initialize an associative\
    \ array\n    declare -A output\n\n    # Loop through input array, adding elements\
    \ to the output array\n    for i in \"${input[@]}\"; do\n        output[$i]=$i\n\
    \    done\n\n    # Create a new array with the contents of the output array\n\
    \    output=(${output[@]})\n\n    # Output the result\n    echo ${output[@]}",
  "  local list=($1)\n  local unique_list=($(printf \"%s\\n\" \"${list[@]}\" | sort\
    \ -u))\n  echo \"${unique_list[@]}\"", "    local list=\"$@\"\n    local t=\"\
    $(mktemp)\"\n    local arr\n    local i\n    local c=0\n    readarray -t arr <<<\"\
    $list\"\n    IFS=$'\\n' sorted=($(sort <<<\"${arr[*]}\"))\n    IFS=$' '\n    for\
    \ i in \"${sorted[@]}\"; do\n        [ \"$i\" != \"${sorted[$c-1]}\" ] && printf\
    \ \"%s\\n\" \"$i\"\n        ((c++))\n    done | xargs -n1 | tr '\\n' ' ' | head\
    \ -c-1\n    rm -f \"$t\"", "  local list\n  list=($(echo \"$1\" | tr ' ' '\\n'\
    \ | sort -n))\n  echo \"${list[@]}\" | tr ' ' '\\n' | uniq", "    local list=$(echo\
    \ \"$1\" | sed 's/\\s\\+/\\n/g' | sort -Vu)\n    echo \"$list\"", "    echo \"\
    ${1}\" | sort -n | uniq | tr '\\n' ' ' | sed 's/[ \\t]*$//g'", "    local list=()\n\
    \    IFS=' ' read -r -a list <<< \"$1\"\n    echo \"${list[@]}\" | tr ' ' '\\\
    n' | sort -n | uniq", '  echo "$1" | tr " " "\n" | sort -u', "  # We can't do\
    \ this in the function, as we need to set it back to the\n  # shell's IFS\n  IFS=\"\
    \ \"\n  # Read in the list, and sort it\n  read -a values <<< $(sort $1)\n  #\
    \ Set IFS back to newline, for array\n  IFS=$'\\n'\n  # Make a string to use uniq\
    \ on, with newlines\n  unique_string=$(printf \"${values[*]}\\n\")\n  # Read that\
    \ into an array, uniq with newlines\n  read -a unique_values <<< $(uniq -c <<<\
    \ \"$unique_string\")\n  # Set IFS back to space\n  IFS=\" \"\n  # Make a string\
    \ for the output, ignoring the uniq counter\n  output=\"\"\n  for line in \"${unique_values[@]}\"\
    ; do\n    read -a pair <<< $line\n    output+=$(printf \"%s \" \"\\\"${pair[1]}\\\
    \"\")\n  done\n  # Remove trailing space\n  output=${output% }\n  # Return\n \
    \ echo $output", "    local list=$1\n    shift\n    echo \"${list}\" | xargs -n1\
    \ | sort -u", '  echo $(echo "$1" | xargs -n1 | sort -u | xargs)', "    # list\
    \ \"5 3 5 2 3 3 9 0 123\"\n    list=\"$*\"\n    # list_array ['5', '3', '5', '2',\
    \ '3', '3', '9', '0', '123']\n    list_array=(${list})\n    # sorted_array ['\"\
    0\"', '\"2\"', '\"3\"', '\"3\"', '\"3\"', '\"5\"', '\"5\"', '\"9\"', '\"123\"\
    ']\n    sorted_array=($(sort <<< ${list_array[*]}))\n    # unique_array ['\"0\"\
    ', '\"2\"', '\"3\"', '\"5\"', '\"9\"', '\"123\"']\n    unique_array=($(uniq <<<\
    \ ${sorted_array[*]}))\n    echo ${unique_array[*]}", "    local list=$1\n   \
    \ [[ ! $list ]] && return 1\n    echo $list | sed -e 's/ /\\n/g' | sort -u | xargs",
  '  echo "$1" | xargs -n1 | sort -u | xargs', "    if [[ $# -ne 1 ]]; then\n    \
    \    printf \"Usage: unique 'a b c'\"\n        return 1\n    fi\n    printf \"\
    [\"\n    printf '\"%s\" ' $(echo \"$1\" | tr ' ' '\\n' | sort -nu | tr '\\n' '\
    \ ')\n    printf \"]\"", "  arg=\"$*\"\n  echo \"$arg\" | tr ' ' '\\n' | sort\
    \ -u | tr '\\n' ' '", "    local data=($1)\n    printf '[\"%s\"]' \"${data[@]}\"\
    \ | jq -r 'group_by(.)[]' | jq -r '.[0]' | jq -sRr '.'", "  echo \"$1\" | tr '\
    \ ' '\\n' | sort -n | uniq | tr '\\n' ' '", "  local list=\"$1\"\n  echo $(echo\
    \ $list | tr ' ' '\\n' | sort -u | tr '\\n' ' ')", "    # 1. split the space-separated\
    \ list into an array of elements\n    # 2. sort the array\n    # 3. remove duplicates\n\
    \    echo -n \"[\"\n    local u=($(echo -n \"$1\" | tr \" \" \"\\n\" | sort -n\
    \ | uniq))\n    local i=0\n    local last=${#u[@]}\n    while [ $i -lt $last ];\
    \ do\n        echo -n \"\\\"${u[$i]}\\\"\"\n        if [ $i -lt $((last - 1))\
    \ ]; then\n            echo -n \", \"\n        fi\n        i=$((i + 1))\n    done\n\
    \    echo -n \"]\"", "    while [ \"$1\" != \"\" ]; do\n        echo $1\n    \
    \    shift\n    done | sort -u | sed 's/^/\"/;s/$/\"/'", "    declare -a tmp=($@)\n\
    \    echo -n \"[\"\n    printf -v tmp '%q ' \"${tmp[@]}\"\n    echo \"${tmp[@]}\"\
    \ | tr ' ' '\\n' | sort -u | tr '\\n' ' '\n    echo \"]\"", "  result=\"$(tr \"\
    \ \" \"\\n\" <<< \"$1\" | sort -V | uniq)\"\n  echo \"$result\"", "    echo -n\
    \ \"$1\" | tr ' ' '\\n' | sort -u | tr '\\n' ' ' | sed 's/ $//'", "  local x=$1\n\
    \  shift\n  echo $x | tr \" \" \"\\n\" | sort -u | tr \"\\n\" \" \"", "  echo\
    \ \"$1\" | tr ' ' '\\n' | sort -u | xargs", "    echo \"[$(echo \"$@\" | sed -e\
    \ 's/ /\", \"/g')]\" | xargs -n1 | sort -u | xargs", "    local list=\"$1\"\n\
    \    local res=()\n    local IFS=\" \"\n    for i in ${list}; do\n        if [[\
    \ ! \"${res[*]}\" =~ \"${i}\" ]]; then\n            res+=(${i})\n        fi\n\
    \    done\n    echo \"${res[*]}\" | tr \" \" \"\\n\" | sort | tr \"\\n\" \" \"",
  "  declare -A array\n  local string\n  for string in $1; do\n    array[$string]=1\n\
    \  done\n  echo \"${!array[@]}\" | tr ' ' '\\n' | sort", "    local __OUT=$(jq\
    \ -n --arg _input \"$*\" 'split(\" \") | unique | .[]')\n    eval \"$__OUT\"",
  '    echo "$(echo "$1" | tr " " "\n" | sort -u)"', "    echo \"$1\" | tr ' ' '\\\
    n' | sort -u | tr '\\n' ' '", "    echo \"$1\" | awk '{split($0,a,\" \"); asort(a);\
    \ for (i in a) print a[i]}' | uniq", "    echo \"$1\" |\n    awk '{\n        for\
    \ (i = 1; i <= NF; i++) {\n            if (!a[$i]++) {\n                if (i\
    \ == 1) {\n                    print $i\n                } else {\n          \
    \          printf(\" %s\", $i)\n                }\n            }\n        }\n\
    \    }' | sort", "  local list=\"$1\"\n  local sorted=\"$(echo $list | xargs -n1\
    \ | sort -u | xargs)\"\n  echo \"[${sorted// /\\\", \\\"}]\"", "    echo \"$1\"\
    \ | tr ' ' '\\n' | sort -n | uniq | tr '\\n' ' ' | sed -e 's/\\(.*\\)/[\\1]/'",
  '    echo $1 | tr " " "\n" | sort -u | tr "\n" " "', '    printf "%s\n" "$1" | sort
    -u | tr "\n" " "', "  local list=\"$*\"\n  # shellcheck disable=SC2207\n  local\
    \ sorted=($(echo \"$list\" | tr ' ' '\\n' | sort -n | uniq))\n  echo \"${sorted[*]}\"",
  "    echo $1 | awk '{split($0,a,\" \"); asort(a); for(i in a) printf(\"%s \",a[i])}'",
  '    echo $(echo $1 | tr " " "\n" | sort -n | uniq | tr "\n" " ")', "    echo \"\
    [$(echo \"$1\" | xargs -n1 | sort -u | awk '{printf \"\\\"%s\\\", \", $0}')]\"",
  "  echo $(\n    # convert items to string\n    map 'str($_)' <<< \"$1\" |\n    #\
    \ build list from strings\n    from_json |\n    # sort\n    sort |\n    # unique\n\
    \    unique |\n    # convert to json\n    to_json\n  )", '  echo $1 | tr " " "\n"
    | sort -n | uniq', "    echo $1 | tr ' ' '\\n' | sort -nu | tr '\\n' ' '", " \
    \ ( IFS=$'\\n'; echo -e \"$*\" | sort -u -f )", "    local SEPARATOR=' '\n   \
    \ if [[ $2 ]]; then\n        SEPARATOR=$2\n    fi\n    echo $(echo $1 | tr \"\
    $SEPARATOR\" '\\n' | sort -nu | tr '\\n' \"$SEPARATOR\")", "  local arr=()\n \
    \ for i in $@; do\n    if [[ \" ${arr[@]} \" =~ \" ${i} \" ]]; then\n      continue\n\
    \    fi\n    arr=(\"${arr[@]}\" \"${i}\")\n  done\n  echo ${arr[@]}", "    echo\
    \ \"$1\" | tr ' ' '\\n' | sort -u | sed -e 's/^/\"/' -e 's/$/\"/'", "    local\
    \ arr arr_len i j\n    arr=($1)\n    arr_len=${#arr[@]}\n    # Ascending sort\n\
    \    for ((i=0; i<$arr_len; i++)); do\n        for ((j=i+1; j<$arr_len; j++));\
    \ do\n            if [ \"${arr[$i]}\" -gt \"${arr[$j]}\" ]; then\n           \
    \     tmp=${arr[$i]}\n                arr[$i]=${arr[$j]}\n                arr[$j]=$tmp\n\
    \            fi\n        done\n    done\n    # Remove duplicates\n    for ((i=0;\
    \ i<$arr_len; i++)); do\n        for ((j=i+1; j<$arr_len; j++)); do\n        \
    \    if [ \"${arr[$i]}\" == \"${arr[$j]}\" ]; then\n                unset arr[$j]\n\
    \            fi\n        done\n    done\n    # Format output as a space-separated\
    \ list\n    local str=''\n    for ((i=0; i<$arr_len; i++)); do\n        str=\"\
    $str \\\"${arr[$i]}\\\"\"\n    done\n    echo -n $str", "  echo \"$1\" | tr \"\
    \ \" \"\\n\" | sort -n | uniq | tr \"\\n\" \" \" | sed 's/^\\|$/\"/g'", "    python\
    \ -c \"print(sorted(set(list(map(int, '$1'.split())))))\"", "    local a\n   \
    \ a=$(echo \"$1\" | tr ' ' '\\n' | sort -u)\n    echo \"[$(printf \"\\\"%s\\\"\
    , \" $a)]\"", "  local args=$@\n  echo $args | tr ' ' '\\n' | sort -n | uniq |\
    \ tr '\\n' ' '", "    array=($1)\n    for ((i=0; i<${#array[@]}; i++)); do\n \
    \       for ((j=i+1; j<${#array[@]}; j++)); do\n            if [[ \"${array[$i]}\"\
    \ == \"${array[$j]}\" ]]; then\n                unset \"array[$j]\"\n        \
    \    fi\n        done\n    done\n    echo ${array[@]}", "  declare -A u\n  for\
    \ x in $1; do\n    u[$x]=1\n  done\n  echo \"${!u[@]}\" | tr ' ' $'\\n' | sort\
    \ -n", "    # Split the incoming argument list into an array,\n    # sort it,\
    \ and remove duplicates\n    local list=($1)\n    local result=($(printf \"%s\\\
    n\" \"${list[@]}\" | sort -u))\n\n    # Convert result array to JSON list\n  \
    \  local result=$(echo ${result[@]} | jq -R . | jq -s .)\n\n    # Return unique\
    \ elements\n    echo $result", '  echo "$(tr " " "\n" <<< "$1" | sort -u)"', " \
    \   local array=()\n    local retval=\"\"\n    while read -r -d \" \"; do\n  \
    \      array+=(\"$REPLY\")\n    done <<< $1\n    IFS=$'\\n'\n    retval=($(sort\
    \ -u <<< \"${array[*]}\"))\n    echo \"${retval[*]}\"", '  echo "$1" | xargs -n1
    | sort -u | xargs', "    echo $1 | tr \" \" \"\\n\" | sort -u | tr \"\\n\" \"\
    \ \" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//'", "    # [[]] \u5728\
    [[]]\u4E2D [[]]\u4ECD\u7136\u662F\u4E00\u4E2A\u62EC\u53F7\u8868\u8FBE\u5F0F \u548C\
    [ ]\u4E00\u6837\n    [[ $# == 0 ]] && error \"unique: expects arguments\" && return\
    \ 1\n    # mapfile is not available in BSD\n    mapfile -t unique_array < <(echo\
    \ \"$*\" | tr ' ' '\\n' | sort -u)\n    echo \"${unique_array[@]}\"", '    printf
    "%s\n" "$1" | sort -u', "    local list=$1\n    echo \"[$(printf \"%s\\n\" $list\
    \ | sort -u | xargs -n1 printf '\"%s\" ')]\"", "    local -r __FUNCTION_NAME=unique\n\
    \    local -r __DOC__='Return sorted unique elements in a list'\n    local -r\
    \ __USAGE__='$(unique \"5 3 5 2 3 3 9 0 123\")'\n    local -r __EXAMPLE__='['\"\
    '\"'0'\"'\"', '\"'\"'2'\"'\"', '\"'\"'3'\"'\"', '\"'\"'5'\"'\"', '\"'\"'9'\"'\"\
    ', '\"'\"'123'\"'\"']'\n    $(is_help_requested) && { print_usage $__FUNCTION_NAME\
    \ \"$__DOC__\" \"$__USAGE__\" \"$__EXAMPLE__\"; return; }\n\n    # Check if arguments\
    \ are supplied\n    local -r list=$1\n    [[ -z $list ]] && { print_error \"At\
    \ least one argument must be provided\" \"$__USAGE__\"; return; }\n\n    # Check\
    \ if all arguments are integers\n    local is_int=true\n    for item in $list;\
    \ do\n        [[ ! $item =~ ^[0-9]+$ ]] && { is_int=false; break; }\n    done\n\
    \    [[ $is_int = false ]] && { print_error \"All items in the list must be integers\"\
    \ \"$__USAGE__\"; return; }\n\n    # Convert space-separated list to newline-separated\
    \ list\n    IFS=$'\\n'\n    local -r newline_list=( $(print_list $list) )\n  \
    \  unset IFS\n\n    # Sort list numerically\n    local -r sorted_list=( $(print_sorted_list\
    \ \"${newline_list[@]}\") )\n\n    # Return unique items in the list\n    echo\
    \ $(print_unique_list \"${sorted_list[@]}\")", "    local list=($1)\n    for index\
    \ in \"${!list[@]}\"; do\n        local item=\"${list[$index]}\"\n        local\
    \ found=true\n        for cmp_index in \"${!list[@]}\"; do\n            local\
    \ cmp_item=\"${list[$cmp_index]}\"\n            [[ \"$index\" == \"$cmp_index\"\
    \ ]] && continue\n            [[ \"$item\" == \"$cmp_item\" ]] && found=false\n\
    \        done\n        [[ \"$found\" == true ]] && printf '\"%s\" ' \"$item\"\n\
    \    done", "    local sorted\n    sorted=$(echo \"$1\" | tr ' ' '\\n' | sort\
    \ -n | uniq)\n    echo \"$sorted\"", "  local text=\"$*\"\n  echo ${text} | tr\
    \ ' ' '\\n' | sort -u | tr '\\n' ' '", '  echo $1 | tr " " "\n" | sort -u | tr
    "\n" " "', "  # Work on a copy, leave the original untouched\n  local list=\"\
    $1\"\n  # Save the original Internal Field Separator (IFS) value\n  local old_ifs=\"\
    $IFS\"\n  # Set the IFS to space and newline characters only to avoid splitting\n\
    \  # $list on spaces. This is what we want to do, the opposite of\n  # `lines_to_list`,\
    \ `unique_lines` and `unique_elements`.\n  IFS=$' \\n'\n  local -a uniq_elements=()\n\
    \  for element in $list; do\n    # Ignore empty elements\n    if [ -n \"$element\"\
    \ ]; then\n      # Keep track of uniq elements in `uniq_elements`\n      if !\
    \ list_has_element \"$element\" \"${uniq_elements[@]}\"; then\n        uniq_elements+=(\"\
    $element\")\n      fi\n    fi\n  done\n  # Restore the original IFS value\n  IFS=\"\
    $old_ifs\"\n  # Sort the elements\n  sort_list \"${uniq_elements[@]}\"", "   \
    \ local string=\"$*\"\n    local -a array=(${string// / })\n    local -a seen=()\n\
    \    local -a uniq=()\n    for e in \"${array[@]}\"; do\n\tlocal ok=true\n\tfor\
    \ x in \"${seen[@]}\"; do\n\t    if [[ \"$x\" == \"$e\" ]]; then\n\t\tok=false\n\
    \t\tbreak\n\t    fi\n\tdone\n\tif $ok; then\n\t    uniq+=(\"$e\")\n\t    seen+=(\"\
    $e\")\n\tfi\n    done\n    echo \"[$(join ', ' \"${uniq[@]}\")]\"", "    echo\
    \ $(printf '%s\\n' \"$1\" | sort -u)", '    echo $(for i in $1; do echo $i; done
    | sort -u)', "  IFS=$' ' read -r -a arr <<< \"$1\"\n  printf '%s\\n' \"${arr[@]}\"\
    \ | sort -u |\n    sed 's/\\(^\"\\|\"$\\)//g' | awk '{print \"\\\"\"$0\"\\\"\"\
    }' |\n    tr '\\n' ' ' | sed 's/.$//'", "    printf \"[\"\n    echo \"$@\" | tr\
    \ ' ' '\\n' | sort -u | while read line; do\n        printf '\"%s\", ' \"$line\"\
    \n    done | sed 's/.$//'\n    printf \"]\"", "  # @ref https://stackoverflow.com/a/18663878/248616\n\
    \  echo -n \"$(echo \"$1\" | tr ' ' '\\n' | sort -V | uniq | tr '\\n' ' ')\"",
  '    echo $1 | tr " " "\n" | sort -u | paste -s -d " "', "    echo \"[`echo \"$@\"\
    \ | tr ' ' '\\n' | sort -u | sed 's/.*/\"&\"/' | tr '\\n' ',' | sed 's/.$//'`]\""]
stop_tokens:
- "\n}"
