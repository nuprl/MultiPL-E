name: HumanEval_131_digits
language: sh
prompt: "#!/bin/bash\n# Given a positive integer n, return the product of the odd\
  \ digits.\n# Return 0 if all digits are even.\n# For example:\n# >>> $(digits \"\
  1\")\n# \"1\"\n# >>> $(digits \"4\")\n# \"0\"\n# >>> $(digits \"235\")\n# \"15\"\
  \n#\n# $1 is an integer\ndigits() {\n"
tests: "}\n\ncandidate() {\n    digits \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
  \ \"5\") = \"5\" ]]\n    [[ $(candidate \"54\") = \"5\" ]]\n    [[ $(candidate \"\
  120\") = \"1\" ]]\n    [[ $(candidate \"5014\") = \"5\" ]]\n    [[ $(candidate \"\
  98765\") = \"315\" ]]\n    [[ $(candidate \"5576543\") = \"2625\" ]]\n    [[ $(candidate\
  \ \"2468\") = \"0\" ]]\n}\n\nrun_test"
completions: ["  local res=1\n  local digit\n  local str=$1\n  for (( i=0; i<${#str};\
    \ i++ )); do\n    digit=${str:$i:1}\n    if (( $digit%2 != 0 )); then\n      res=$((res*digit))\n\
    \    fi\n  done\n  echo $res", "  local num=\"$1\"\n  local res=1\n  if [[ $num\
    \ =~ ^[0-9]+$ ]]; then\n    while [ $num -gt 0 ]; do\n      local last_digit=$((num\
    \ % 10))\n      if [ $((last_digit % 2)) -ne 0 ]; then\n        res=$((res * last_digit))\n\
    \      fi\n      num=$((num / 10))\n    done\n  fi\n  echo \"$res\"", "  local\
    \ sum=1\n  local num\n  for num in $(echo \"$1\" | fold -w1); do\n    ((num %\
    \ 2 == 1)) && ((sum *= num))\n  done\n  echo \"$sum\"", "  local -i s=0\n  local\
    \ p=1\n  local c\n  while (( $1 > 0 )); do\n    c=$(( $1 % 10 ))\n    if (( c\
    \ % 2 == 1 )); then\n      p=$(( p * c ))\n    fi\n    s=$(( s + c ))\n    1=$((\
    \ $1 / 10 ))\n  done\n  printf \"%d\" $p", "  a=0\n  for (( i=0; i<${#1}; i++\
    \ )); do\n    (( $(( ${1:$i:1} % 2 )) == 1 )) && (( a+=$(( ${1:$i:1} * 10**i ))\
    \ ))\n  done\n  echo \"$a\"", "  local int=\"$1\"\n  local odd_product=1\n  local\
    \ digit\n  while (( int > 0 )); do\n    digit=$(( int % 10 ))\n    if (( digit\
    \ % 2 == 1 )); then\n      odd_product=$(( odd_product * digit ))\n    fi\n  \
    \  int=$(( int / 10 ))\n  done\n  echo \"$odd_product\"", "    # TODO: implement\
    \ a solution here\n    #\n    # Note: The solution must use the following types\
    \ of statements:\n    #\n    # * The arithmetic operator `*` (multiply)\n    #\
    \ * The arithmetic operator `%` (modulo)\n    # * The `expr` command with the\
    \ `--` option\n    # * A `while` loop\n    # * A `for` loop\n    # * The conditional\
    \ statement `if`\n    # * A function definition\n    #\n    # Note: You can assume\
    \ $1 is a positive integer.", "    declare -i product=1\n    for i in $(seq 1\
    \ ${#1}); do\n        if (($(echo \"${1:i-1:1} % 2\" | bc -l) != 0)); then\n \
    \           product=$(($product * ${1:i-1:1}))\n        fi\n    done\n    echo\
    \ \"$product\"", "    # Initialize result variable to an empty string\n    local\
    \ result=\"\"\n    # Loop through each digit\n    for ((i=0; i<${#1}; i++)); do\n\
    \        # If the digit is odd, add it to result\n        [[ $(( ${1:$i:1} % 2\
    \ )) -ne 0 ]] && result+=\"${1:$i:1}\"\n    done\n    # If result is empty, set\
    \ it to 0\n    [[ -z $result ]] && result=\"0\"\n    # Return the product of the\
    \ digits\n    echo \"$result\"", "  # $(tr -d \"23456789\" <(echo \"$1\"))\n \
    \ # $(echo \"$1\" | tr -d \"23456789\")\n  # $(tr -d \"23456789\" <<< \"$1\")\n\
    \  # echo \"$1\" | tr -d \"23456789\"\n  echo \"$1\" | tr -d \"23456789\"", " \
    \   local -i n=0\n    local i\n    local -i t\n\n    if [[ \"$1\" =~ ^[0-9]+$\
    \ ]]; then\n        for (( i=0; i<${#1}; i++ )); do\n            t=${1:$i:1}\n\
    \            if (( (t % 2) == 1 )); then\n                (( n = n * t ))\n  \
    \          fi\n        done\n    fi\n    echo \"$n\"", "  local n=$1\n  local\
    \ product=1\n  for i in $(echo \"$n\" | grep -o .); do\n    if [[ $((i % 2)) -eq\
    \ 1 ]]; then\n      product=$((product * i))\n    fi\n  done\n  if [[ $product\
    \ -eq 1 ]]; then\n    echo 0\n  else\n    echo $product\n  fi", "    if [[ $1\
    \ =~ ^[0-9]+$ ]]; then\n        echo $1 | tr -d [:even:] | tr -d 0 | awk '{ if\
    \ (length($0) > 0) {print $0;} else {print \"0\"}}' | tr -d '\\n'\n    else\n\
    \        echo \"Invalid input.\"\n    fi", "  # if all digits are even then return\
    \ 0\n  # else return product of odd digits\n  local number=\"$1\"\n  local answer=1\n\
    \  local all_even=1\n  for (( i=0; i<${#number}; i++ )); do\n    local digit=\"\
    ${number:$i:1}\"\n    if [[ $((digit % 2)) -ne 0 ]]; then\n      all_even=0\n\
    \      answer=$((answer * digit))\n    fi\n  done\n  if [[ $all_even -eq 1 ]];\
    \ then\n    echo 0\n  else\n    echo $answer\n  fi", "    local prod=1\n    local\
    \ prod_flag=false\n    for ((i=0; i<${#1}; i++)); do\n        local digit=\"${1:$i:1}\"\
    \n        if (( digit % 2 == 1 )); then\n            prod=$((prod * digit))\n\
    \            prod_flag=true\n        fi\n    done\n    if [ \"$prod_flag\" = false\
    \ ]; then\n        prod=0\n    fi\n    echo \"$prod\"", "  echo \"$1\" | grep\
    \ -o \"[13579]\" | tr -d '\\n' | awk '{print $0+0}'", "  local integer=\"$1\"\n\
    \  local odd_digits=\"\"\n  local even_digits=\"\"\n  local result=\"\"\n  for\
    \ digit in $(echo $integer | sed 's/./& /g'); do\n    if [ $(echo $digit | bc)\
    \ -eq 0 ]; then\n      continue\n    fi\n    if [ $(($digit % 2)) -eq 0 ]; then\n\
    \      even_digits=\"$even_digits $digit\"\n    else\n      odd_digits=\"$odd_digits\
    \ $digit\"\n    fi\n  done\n  result=$(echo $odd_digits | sed 's/ /\\*/g')\n \
    \ if [ -z \"$result\" ]; then\n    result=\"0\"\n  fi\n  echo $result", "    local\
    \ answer=$(echo ${1} | sed -r 's/\\B[02468]/0/g' | sed -r 's/[^0]/&*/g' | sed\
    \ -r 's/\\*$//')\n    echo $answer", "    local DIGITS=$(echo $1 | fold -w1)\n\
    \    local RESULT=1\n    for DIGIT in $DIGITS; do\n        if [ $(($DIGIT % 2))\
    \ -ne 0 ]; then\n            RESULT=$(($RESULT * $DIGIT))\n        fi\n    done\n\
    \    if [ $RESULT -eq 1 ]; then\n        RESULT=0\n    fi\n    echo $RESULT",
  "  echo \"$1\" | grep -o '[13579]' | tr -d '\\n' | awk '{print length($0) ? $0 :\
    \ 0}'"]
stop_tokens:
- "\n}"
