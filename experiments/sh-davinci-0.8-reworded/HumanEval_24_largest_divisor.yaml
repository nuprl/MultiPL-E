name: HumanEval_24_largest_divisor
language: sh
prompt: "#!/bin/bash\n# For a given number n, find the largest number that divides\
  \ n evenly, smaller than n\n# >>> $(largest_divisor \"15\")\n# \"5\"\n#\n# $1 is\
  \ an integer\nlargest_divisor() {\n"
tests: "}\n\ncandidate() {\n    largest_divisor \"$@\"\n}\n\nset -e\nrun_test() {\n\
  \    [[ $(candidate \"3\") = \"1\" ]]\n    [[ $(candidate \"7\") = \"1\" ]]\n  \
  \  [[ $(candidate \"10\") = \"5\" ]]\n    [[ $(candidate \"100\") = \"50\" ]]\n\
  \    [[ $(candidate \"49\") = \"7\" ]]\n}\n\nrun_test"
completions: ["  #[[ $1 =~ ^[1-9]+$ ]] && {\n  [[ $1 =~ ^[0-9]+$ ]] && {\n    if [[\
    \ $1 -lt 2 ]]; then\n      echo \"1\"\n    else\n      # Get the list of the prime\
    \ factors of a given number\n      factor $1 > /dev/null\n      # Reduce the number\
    \ until we get the largest one that divides the number\n      x=$(factor $1 |\
    \ cut -d \":\" -f 2 | tr -d \" \" | sed 's/[0-9]//g' | sed 's/x/ * /g' | tr \"\
    *\" \"\\n\" | sort -nr)\n      for i in $x; do\n        if [[ $(( $1 % $i )) ==\
    \ 0 ]]; then\n          echo $i\n          break\n        fi\n      done\n   \
    \ fi\n  } || echo \"0\"", "  for (( i=$1-1; i > 0; i-- )); do\n    if [[ $(( $1\
    \ % $i )) -eq 0 ]]; then\n      echo $i\n      break\n    fi\n  done", "    local\
    \ n=\"$1\"\n    local i=\"$n\"\n    while [ \"$i\" -gt \"0\" ]; do\n        if\
    \ [ $((n % i)) -eq 0 ]; then\n            echo \"$i\"\n            return\n  \
    \      fi\n        i=$((i - 1))\n    done", "    for number in $(seq 1 $1); do\n\
    \        if [[ $(( $1 % $number )) -eq 0 ]]; then\n            echo $number\n\
    \        fi\n    done | sort -nr | head -n 1", "  local largest_divisor=1\n  local\
    \ i=2\n  while [ $i -lt $1 ]; do\n    if [ $(bc <<< \"$1 % $i\") -eq 0 ]; then\n\
    \      largest_divisor=$i\n    fi\n    i=$(( i + 1 ))\n  done\n  echo $largest_divisor",
  "    largest_divisor=$1\n    while [ $((largest_divisor - 1)) -gt 0 ]; do\n    \
    \    if [ $((1 % largest_divisor)) -eq 0 ]; then\n            echo $largest_divisor\n\
    \            return 0\n        fi\n        largest_divisor=$((largest_divisor\
    \ - 1))\n    done\n    return 1", "    for (( i=$1-1; i>0; i-- ))\n    do\n  \
    \      if [[ $(is_evenly_divisible $1 $i) == \"1\" ]]\n        then\n        \
    \    echo $i\n            return\n        fi\n    done", "  if [[ $1 =~ ^[0-9]+$\
    \ ]]; then\n    for i in $(seq $1 -1 1); do\n      if (( $1 % $i == 0 )); then\n\
    \        echo $i\n        break\n      fi\n    done\n  else\n    echo \"Not an\
    \ integer.\"\n  fi", "    local n=\"$1\"\n\n    for i in $(seq \"$n\" -1 1); do\n\
    \        if [ $(( n % i )) -eq 0 ]; then\n            echo \"$i\"\n          \
    \  return\n        fi\n    done", "  local n=$1\n  local ld=2\n  while [ $(remainder_divide\
    \ \"$n\" \"$ld\") -ne 0 ]; do\n    ld=$(($ld + 1))\n  done\n  echo $ld", '  echo
    $(echo $1 | xargs -I{} jot -r 1 1 {})', "  local num=\"$1\"\n  local max=`sqrt\
    \ $num`\n  for divisor in `seq 1 $max`; do\n    if [ `is_integer $(echo \"$num/$divisor\"\
    \ | bc -l)` == \"True\" ]; then\n      echo \"$divisor\"\n      return\n    fi\n\
    \  done", "    # Check input is a number\n    [[ \"$1\" =~ ^[0-9]+$ ]] || error_exit\
    \ \"largest_divisor requires an integer\" 1\n\n    # Check for trivial case\n\
    \    if [ \"$1\" -le 2 ]; then\n        echo \"1\"\n        return\n    fi\n\n\
    \    # Because we are searching for a non-trivial factor, the largest possible\
    \ factor\n    # is half of the number. For example, if n = 100, the largest possible\
    \ factor\n    # will be 50 (100 / 2). Therefore we can start checking numbers\
    \ at the floor of\n    # n / 2, and work backwards. The first number we find that\
    \ divides evenly will\n    # be the largest.\n    floor=$(echo \"$1/2\" | bc)\n\
    \    for (( i=$floor; i > 1; i-- ))\n    do\n        remainder=$(echo \"$1 % $i\"\
    \ | bc)\n        if [ \"$remainder\" -eq 0 ]; then\n            echo \"$i\"\n\
    \            return\n        fi\n    done", "  local n=$1\n  local divisor=$((n\
    \ - 1))\n  while [[ $((n % divisor)) -ne 0 ]]; do\n    divisor=$((divisor - 1))\n\
    \  done\n  echo \"$divisor\"", "    divisor=\"$1\"\n    n=\"$1\"\n    while [\
    \ $divisor -gt 1 ]; do\n        n=$((n-1))\n        if [ $(($1 % $n)) -eq 0 ];\
    \ then\n            divisor=$n\n        fi\n    done\n    echo \"$divisor\"",
  "    for (( i=2; i<$1; i++ )); do\n        if [ $(( $1 % $i )) -eq 0 ]; then\n \
    \           # If the modulus is 0, then print the greatest factor and stop\n \
    \           echo \"$i\"\n            break\n        fi\n    done", "  for (( i=2;\
    \ i<${1}; i++ )); do\n    if [[ $((${1} % ${i})) -eq 0 ]]; then\n      echo \"\
    ${i}\"\n      return\n    fi\n  done", "    IFS=' ' read -r -a prime_factors <<<\
    \ $(prime_factors \"$1\")\n    echo \"${prime_factors[-1]}\"", "  local n=\"$1\"\
    \ # given integer\n  local divisor=2\n  while (( divisor <= n/2 ))\n  do\n   \
    \ if (( n % divisor == 0 )); then\n      echo \"$divisor\"\n      break\n    fi\n\
    \    (( divisor++ ))\n  done", "    local n=\"$1\"\n    local max=\"$((n-1))\"\
    \n    for i in $(seq 2 \"$max\"); do\n        if [ \"$((n%i))\" -eq 0 ]; then\n\
    \            echo \"$i\"\n            return\n        fi\n    done", "    if !\
    \ is_numeric \"$1\"; then\n        echo \"largest_divisor: the argument passed\
    \ must be an integer\"\n        exit 1\n    fi\n\n    local largest=0\n    local\
    \ var=$1\n    local divisor=2\n\n    while ((divisor <= var)); do\n        if\
    \ ((var % divisor == 0)); then\n            largest=$divisor\n            var=$((var\
    \ / divisor))\n        else\n            divisor=$((divisor + 1))\n        fi\n\
    \    done\n\n    echo \"$largest\"", "    if ! [[ \"$1\" =~ ^[0-9]+$ ]]; then\n\
    \        echo \"Not an integer\"\n        return 1\n    fi\n    local input=$1\n\
    \    if [[ $input -eq 0 ]]; then\n        echo \"0\"\n        return 0\n    fi\n\
    \    for (( i=input-1; i>0; i-- )); do\n        if [[ $(( input % i )) -eq 0 ]];\
    \ then\n            echo \"$i\"\n            return 0\n        fi\n    done\n\
    \    return 1", '    echo $1 | tr -d "[2-9]" || echo "1"', "    for (( i=1; i<$1;\
    \ i++ )); do\n        # shellcheck disable=SC2048\n        # shellcheck disable=SC2086\n\
    \        if [[ $(($1 % $i)) -eq 0 ]]; then\n            echo \"$i\"\n        fi\n\
    \    done", "  local number=$1\n  local divisor=2\n  # Divide by 2 until it is\
    \ not evenly divisible anymore\n  until [[ $((number % divisor)) != 0 ]]; do\n\
    \    number=$((number / divisor))\n  done\n  echo \"$number\"", "    local n=$1\n\
    \    local i=2\n    local j=1\n    local largest=1\n    for i in $(seq \"$n\"\
    ); do\n        if (( n % i == 0 )); then\n            largest=$i\n        fi\n\
    \    done\n    echo \"$largest\"", "    local n=$1\n    local largest_divisor=1\n\
    \    for (( i=2; i < n; i++ )); do\n        if [[ $(($n % $i)) -eq 0 ]]; then\n\
    \            largest_divisor=$i\n        fi\n    done\n    echo $largest_divisor",
  "    local largest_divisor=2\n    local largest_mod=1\n    local current_divisor=1\n\
    \    local current_mod=1\n    while [[ $current_divisor -lt $1 ]]; do\n      \
    \  let current_divisor++\n        let current_mod=$1%$current_divisor\n      \
    \  if [[ $current_mod -eq 0 ]]; then\n            if [[ $current_divisor -gt $largest_divisor\
    \ ]]; then\n                largest_divisor=$current_divisor\n            fi\n\
    \        fi\n    done\n    echo $largest_divisor", "    local -r n=$1\n    local\
    \ largest=0\n    for i in $(seq 1 $((n - 1))); do\n        if [[ $((n % i)) -eq\
    \ 0 ]]; then\n            largest=$i\n        fi\n    done\n    echo \"$largest\"",
  "    if [[ $# -ne 1 ]]; then\n        echo \"$(basename \"$0\") expected 1 argument,\
    \ got $#\"\n        exit 1\n    fi\n\n    local number=\"$1\"\n    local x=2\n\
    \    while [[ $((x*x)) -le \"$number\" ]]; do\n        while [[ $((number%x))\
    \ -eq 0 ]]; do\n            number=$((number/x))\n        done\n        x=$((x+1))\n\
    \    done\n    echo \"$number\"", "    val=$1\n    ret=$(seq -s \" \" 1 $(( $val-1\
    \ )) | awk -v val=$val '{ if (val % $1 == 0) print $1}' | sort -n | tail -n 1)\n\
    \    echo $ret", "    echo $1 | awk '{\n        max = int($1 / 2)\n        for\
    \ (divisor = max; divisor > 0; divisor -= 1) {\n            if ($1 % divisor ==\
    \ 0) {\n                print divisor\n                exit\n            }\n \
    \       }\n    }'", "    local -i n=$1\n    for (( i=n-1; i>0; i-- ))\n    do\n\
    \        (( n % i == 0 )) && { echo \"$i\"; return; }\n    done", "    n=$1\n\
    \    i=$(($n - 1))\n    while [ $(($n % $i)) -ne 0 ]; do\n        i=$(($i - 1))\n\
    \    done\n    echo $i", "    declare -i n=$1\n    declare -i i=2\n    while [\
    \ \"$i\" -lt \"$n\" ]; do\n        (( n % i == 0 )) && echo \"$i\" && return\n\
    \        ((i++))\n    done", "  for ((num=$1 - 1; num > 0; num--)); do\n    if\
    \ [[ $(( $1 % $num )) -eq 0 ]]; then\n      echo $num\n      break\n    fi\n \
    \ done", "  local -i n=$1\n  local -i i\n\n  if [ $n -lt 0 ]; then\n    n=$((-n))\n\
    \  fi\n\n  if [ $n -eq 0 ]; then\n    echo \"0\"\n    return 0\n  fi\n\n  if [\
    \ $n -eq 1 ]; then\n    echo \"1\"\n    return 0\n  fi\n\n  for ((i=n-1; i>=2;\
    \ i--)); do\n    if [ $((n%i)) -eq 0 ]; then\n      echo \"$i\"\n      return\
    \ 0\n    fi\n  done\n\n  echo \"1\"\n  return 0", "    local -i num=$1 i\n   \
    \ local -i divisor_index=0 divisor[20]\n\n    # Adding divisors to array\n   \
    \ for ((i=1; i<=$num; i++)); do\n        if [[ $((num % i)) -eq 0 ]]; then\n \
    \           divisor[$divisor_index]=$i\n            ((divisor_index++))\n    \
    \    fi\n    done\n\n    # Printing the largest number\n    echo ${divisor[((divisor_index-1))]}",
  "    local n=$1\n    local dividend=$(largest_factor_less_than $n)\n    local divisor=1\n\
    \    for ((;dividend>1;dividend--)); do\n        local rem=$((n % dividend))\n\
    \        if [ $rem -eq 0 ]; then\n            divisor=$dividend\n            break\n\
    \        fi\n    done\n    echo $divisor", '  echo "($1-1)" | bc', "    for ((\
    \ i=$1-1; i>0; i-- )); do\n        if [ $(( $1 % $i )) == 0 ]; then\n        \
    \    echo $i\n            break\n        fi\n    done", "  if [[ $1 =~ ^[0-9]+$\
    \ ]]; then\n    printf \"%s\\n\" \"$(( $(($1 - 1)) / 2 ))\"\n  else\n    echo\
    \ \"err\"\n  fi", "    local divisor=2\n    local largest=1\n    local number=$1\n\
    \    # We can't divide by 1 or by itself\n    while [ $divisor -lt $number ]\n\
    \    do\n        if [ $(($number % $divisor)) -eq 0 ]\n        then\n        \
    \    largest=$divisor\n        fi\n        divisor=$(($divisor + 1))\n    done\n\
    \    echo $largest", "    [ $1 -gt 0 ] || return 1\n    [ $1 -eq 1 ] && echo 1\
    \ && return 0\n    local n=$1\n    while true; do\n        [ $(( n / 2 )) -eq\
    \ 0 ] && break\n        n=$(( n / 2 ))\n    done\n    echo $n", "  local n=$1\n\
    \  local d=$((n-1))\n  while [ $((n%d)) -ne 0 ]; do\n    d=$((d-1))\n  done\n\
    \  echo $d", "  local input\n  local result\n\n  if ! valid_int \"$1\"; then\n\
    \    echo \"Error: '$1' is not a valid integer\"\n    return 1\n  fi\n\n  input=\"\
    $1\"\n  result=\"$(truncate \"$input\" -1)\"\n  while ! (is_integer \"$result\"\
    \ && ((\"$input\" % \"$result\" == 0))); do\n    result=\"$(truncate \"$result\"\
    \ -1)\"\n  done\n\n  echo \"$result\"", "  for ((i=$1-1; i>0; i--)); do\n    if\
    \ [ $(($1 % $i)) -eq 0 ]; then\n      echo $i\n      break\n    fi\n  done", '    python
    -c "print($1/2)"', "    local n=$1\n    local d=$((n-1))\n    for (( ; d>0; d--\
    \ )); do\n        if (( n % d == 0 )); then\n            echo $d\n           \
    \ return\n        fi\n    done", "    local n=$1\n    local largest_divisor=1\n\
    \    for divisor in $(seq 2 \"$n\"); do\n        if [ $((n % divisor)) -eq 0 ];\
    \ then\n            largest_divisor=$divisor\n        fi\n    done\n    echo \"\
    $largest_divisor\"", "  if [ \"$1\" -eq 0 ]; then\n    echo \"0\"\n  else\n  \
    \  echo $(( $1-1 ))\n  fi", "  local n=$1\n  local i=$((n-1))\n  while (( $i >\
    \ 0 )) ; do\n    if (( $n % $i == 0 )) ; then\n      echo $i\n      return\n \
    \   fi\n    i=$((i-1))\n  done", "    for (( i=$1-1; i>0; i-- )) ; do\n      \
    \  if [ $(($1 % $i)) -eq 0 ] ; then\n            echo $i\n            break\n\
    \        fi\n    done", "    local integer_regex='^[0-9]+$'\n    if ! [[ $1 =~\
    \ $integer_regex ]]; then\n        echo \"$1 is not an integer\"\n        return\
    \ 1\n    fi\n\n    local -i i=2\n    local -i n=$1\n    while ((n > i)); do\n\
    \        (( i++ ))\n        if ((n % i == 0)); then\n            ((n = n / i))\n\
    \            ((i = 2))\n        fi\n    done\n    echo \"$n\"", "    local n=$1\n\
    \    for (( d=n-1; d>1; d-- )); do\n        (( n % d == 0 )) && echo $d && return\n\
    \    done\n    echo 1", "    local i=$1\n    while [ $((i--)) -gt 0 ]; do\n  \
    \      if [[ $(($1 % $i)) -eq 0 ]]; then\n            echo $i\n            return\n\
    \        fi\n    done", "    local num=\"$1\"\n    local limit=\"$((num/2))\"\n\
    \    local divisor=1\n    while [ \"$divisor\" -le \"$limit\" ]; do\n        if\
    \ [ \"$((num%divisor))\" == \"0\" ]; then\n            echo \"$divisor\"\n   \
    \         break\n        fi\n        divisor=$((divisor+1))\n    done", "  n=$1\n\
    \  i=$(expr $n - 1)\n  while [[ $i -gt 1 ]]; do\n    if [[ $n % $i -eq 0 ]]; then\n\
    \      break\n    fi\n    i=$(expr $i - 1)\n  done\n  echo $i", "  test -z \"\
    $1\" && echo \"Usage: largest_divisor <number>\" && return 1\n  test \"$1\" -lt\
    \ 1 && echo \"Error: Number must be greater than zero.\" && return 1\n  local\
    \ largest_divisor=1\n  local number=$1\n  # No divisor greater than n/2 can divide\
    \ n\n  # So iterate over [2, n/2]\n  for (( num=2; num <= $(( number / 2 )); num++\
    \ )); do\n    test $(( number % num )) -eq 0 && largest_divisor=$num\n  done\n\
    \  echo $largest_divisor", "    local _number=$1\n    local i=2\n\n    while ((\
    \ i < $_number )); do\n        if [[ $(( $_number % i )) -eq 0 ]]; then\n    \
    \        printf \"$i\"\n            return\n        fi\n        i=$(( $i + 1 ))\n\
    \    done", "    for n in $(seq ${1} -1 1); do\n        if [ $(bc <<< \"${1} %\
    \ ${n}\") -eq 0 ]; then\n            echo \"${n}\"\n            break\n      \
    \  fi\n    done", "  local n=$1\n\n  local d=2\n  while [ $d -lt $n ]; do\n  \
    \  if [[ \"$(($n % $d))\" -eq 0 ]]; then\n      # This is the largest possible\
    \ divisor\n      echo $d\n      return\n    fi\n    ((d=d+1))\n  done", "    for\
    \ (( i=${1}-1; i>1; i-- )); do\n        if [[ $(( ${1} % i )) -eq 0 ]]; then\n\
    \            echo ${i}\n            break\n        fi\n    done", "    local n=\"\
    $1\"\n\n    local max_factor=\"$((n / 2))\"\n    local i\n    for ((i = max_factor;\
    \ i > 0; i--)); do\n        if [[ $((n % i)) -eq 0 ]]; then\n            echo\
    \ \"$i\"\n            return\n        fi\n    done", '    echo "$(( $1-1 ))"',
  "    for i in $(seq 2 $(($1-1))); do\n        if [ $(( $1 % $i )) -eq 0 ]; then\n\
    \            echo $i\n            break\n        fi\n    done", "    local result=$(divisors\
    \ $1 | sort -n | tail -n 1)\n    echo \"$result\"", "  number=$1\n  # Write your\
    \ code here\n  for ((i=number-1; i>=1; i--)); do\n    if [[ $((number%i)) -eq\
    \ 0 ]]; then\n      echo $i\n      break\n    fi\n  done", "  local i=\"$1\"\n\
    \  while [[ $((i)) -ne 1 ]]; do\n    [[ $((n % i)) -eq 0 ]] && break\n    i=$((i\
    \ - 1))\n  done\n  echo \"$i\"", "    local n=$1\n\n    local x=1\n    while [\
    \ $((n % x)) -eq 0 ]; do\n        x=$((x+1))\n    done\n    echo $((x-1))", " \
    \ local -i num=$1\n  local -i half=$(divide $num 2)\n  local -i count=1\n  local\
    \ -i remainder\n  local -i largest=1\n\n  while [ $count -le $half ]; do\n   \
    \ remainder=$(divide $num $count)\n    if [ $remainder -eq 0 ]; then\n      largest=$count\n\
    \    fi\n    count=$(($count + 1))\n  done\n\n  echo \"$largest\"", "  local integer=$1\n\
    \  local divisor=0\n  while [[ $divisor -lt $integer ]]; do\n    ((divisor++))\n\
    \    if [[ $((integer % divisor)) == 0 ]]; then\n      printf \"$divisor\"\n \
    \     return\n    fi\n  done", "    if [[ $1 -lt 1 ]]; then\n        echo \"ERROR:\
    \ Argument must be greater than 0\"\n        return 1\n    fi\n\n    local largest_divisor=0\n\
    \    for ((i = 1; i < $1; i++)); do\n        if [[ $(( $1 % $i )) -eq 0 ]]; then\n\
    \            largest_divisor=$i\n        fi\n    done\n\n    echo $largest_divisor",
  "    local num=$1\n    local max_divisor=$(($num-1))\n    while [ $(($num % $max_divisor))\
    \ -ne 0 ]; do\n        max_divisor=$(($max_divisor-1))\n    done\n    echo $max_divisor",
  "  if (( $1 % 2 == 0 ))\n  then\n    # bash cannot divide by a float, cast to int\n\
    \    echo $(( $1 / 2 ))\n  else\n    echo $(( ($1 + 1) / 2 ))\n  fi", "  local\
    \ n=$1\n  # handle trivial case\n  if [[ \"$n\" -eq \"1\" ]]; then\n    echo \"\
    1\"\n    return\n  fi\n  # there's gotta be a better way to do this\n  for ((\
    \ i=$n-1; i > 0; i-- )); do\n    # shellcheck disable=SC2048\n    if [[ $(( n\
    \ % i )) -eq 0 ]]; then\n      echo \"$i\"\n      return\n    fi\n  done", '    echo
    "$(($1-1))"', "    echo $1 | awk '{ for ( i = $1/2; i > 0; i-- ) { if ( $1 % i\
    \ == 0 ) { print i; break } } }'", "    local -r num=$1\n    local -i i=0\n\n\
    \    for ((i = num - 1; i > 0; i--)); do\n        if [[ $(($num % $i)) -eq 0 ]];\
    \ then\n            break\n        fi\n    done\n\n    echo \"$i\"", "  local\
    \ largest_divisor\n  largest_divisor=1\n  for ((i=2; i<=${1}; i++)); do\n    if\
    \ [ $(( $1 % $i )) -eq 0 ]; then\n      largest_divisor=$i\n    fi\n  done\n \
    \ echo \"$largest_divisor\"", "  for n in $(seq \"$1\" -1 1); do\n    if [ $((\
    \ $1 % $n )) -eq 0 ]; then\n      echo \"$n\"\n      break\n    fi\n  done", " \
    \   integer=\"$1\"\n    i=1\n    while [ \"$i\" -lt \"$integer\" ]; do\n     \
    \   if [ \"$(($integer % $i))\" -eq 0 ]; then\n            last_divisor=\"$i\"\
    \n        fi\n        i=$(($i + 1))\n    done\n    echo \"$last_divisor\"", " \
    \   local number=${1}\n    local test_number=2\n    while [ ${test_number} -lt\
    \ ${number} ]; do\n        if [ $((number % test_number)) -eq 0 ]; then\n    \
    \        echo ${test_number}\n            return\n        fi\n        ((test_number++))\n\
    \    done\n    # number is prime, can't be divided\n    echo ${number}", "   \
    \ local n=\"$1\"\n    local i=2\n    while [ $i -lt $n ]; do\n        if [ $((n\
    \ % i)) -eq 0 ]; then\n            echo \"$i\"\n            break\n        fi\n\
    \        ((i++))\n    done", '  echo "scale=0; $1/2" | bc', "    # shellcheck\
    \ disable=SC2034\n    local list=()\n    local i\n    # shellcheck disable=SC2034\n\
    \    local n=$1\n    local j\n    local result\n\n    for ((i=1; i<\"$n\"; i++));\
    \ do\n        if ! (( n % i )); then\n            list+=( \"$i\" )\n        fi\n\
    \    done\n\n    result=${list[0]}\n    for ((j=1; j<${#list[@]}; j++)); do\n\
    \        if (( ${list[j]} > result )); then\n            result=${list[j]}\n \
    \       fi\n    done\n\n    echo \"$result\"", "    divisor=1\n    for (( d=2;\
    \ d<$1; d++ )); do\n        # check if $1 is divisible by $d\n        if (( $1\
    \ % d == 0 )); then\n            divisor=$d\n        fi\n    done\n    echo $divisor",
  "  num=$1\n  i=$((num-1))\n  while [[ $i -gt 0 ]]; do\n    if [[ $(($num % $i))\
    \ -eq 0 ]]; then\n      break\n    fi\n    i=$((i-1))\n  done\n  echo $i", " \
    \ local i=$1\n  while (( i > 1 )); do\n    if (( \"$1\" % i == 0 )); then\n  \
    \    echo \"$i\"\n      return\n    fi\n    (( i-- ))\n  done", "    # If a second\
    \ arg is given, it is used as the divisor limit, but not smaller than 2\n    if\
    \ [[ $# -eq 2 ]]; then\n        local L=$2\n    else\n        local L=1\n    fi\n\
    \    local N=$1\n    local D=$((N - 1))\n    while [[ $D -ge $L ]]; do\n     \
    \   [[ $((N % D)) -eq 0 ]] && break\n        D=$((D - 1))\n    done\n    echo\
    \ $D", "    local num=\"$1\"\n\n    for ((i = $num - 1; i > 0; i--)); do\n   \
    \     ((num % i == 0)) && echo \"$i\" && break\n    done", '    awk "BEGIN { n
    = $1; for (i = n - 1; i > 0; i--) { if (n % i == 0) { print i; exit 0; } } print
    \"0\"; }"', "    echo \">\" $(factor $1 | awk '{print $2}')", "    numbers=$1\n\
    \    if [[ \"$numbers\" -eq 0 ]]; then\n        echo \"0\"\n    else\n       \
    \ if [[ \"$numbers\" -eq 1 ]]; then\n            echo \"1\"\n        else\n  \
    \          divisor=2\n            while [[ \"$numbers\" -ne 1 ]]; do\n       \
    \         while [[ \"$numbers\" -ne 0 ]]; do\n                    if [[ \"$numbers\"\
    \ -eq 1 ]]; then\n                        echo \"$divisor\"\n                \
    \        break\n                    fi\n                    if [[ $(($numbers\
    \ % $divisor)) -eq 0 ]]; then\n                        numbers=$(($numbers / $divisor))\n\
    \                        if [[ \"$numbers\" -eq 1 ]]; then\n                 \
    \           echo \"$divisor\"\n                            break\n           \
    \             fi\n                    else\n                        break\n  \
    \                  fi\n                done\n                divisor=$(($divisor\
    \ + 1))\n            done\n        fi\n    fi", "  local -i x=\"$1\"\n  local\
    \ -i i\n  for ((i = x-1; i > 0; i--)); do\n    if ((x % i == 0)); then\n     \
    \ printf \"%d\" \"$i\"\n      return 0\n    fi\n  done\n  # The number itself\
    \ is the largest factor\n  printf \"%d\" \"$x\"", "    local n=$1\n    local max=$((\
    \ n/2 ))\n    local i\n    for (( i=2; i<=max; i++ )); do\n        if [[ $(( n\
    \ % i )) -eq 0 ]]; then\n            echo $i\n            return\n        fi\n\
    \    done\n    echo 1", "  local num=$1\n  local guess=$num\n  while [ $(($guess\
    \ % 2)) -eq 0 ]; do\n    ((guess /= 2))\n  done\n  echo \"$guess\"", "    local\
    \ range=`seq 1 $1`\n    local range=`echo $range | awk '{for (i=NF; i>0; i--)\
    \ print $i}'`\n    local factor=1\n    local found=false\n    while [[ \"$found\"\
    \ == \"false\" ]]; do\n        echo \"$range\" | while read -r number; do\n  \
    \          if (( $1 % $number == 0 )); then\n                factor=$number\n\
    \                found=true\n                break\n            fi\n        done\n\
    \    done\n    echo $factor", '  echo "($1-1)/2" | bc', "  local divisor=2\n \
    \ while [[ $(( $1 % $divisor )) -ne 0 ]]; do\n    (( divisor++ ))\n  done\n  echo\
    \ $(( $divisor ))", "    local n=\"$1\"\n\n    for ((i=n-1; i>=2; i--)); do\n\
    \        if [[ $(($n % $i)) -eq 0 ]]; then\n            echo \"$i\"\n        \
    \    return\n        fi\n    done", "  if [[ \"$1\" =~ ^[0-9]+$ ]]; then\n   \
    \ echo \"$1\"\n  else\n    return 1\n  fi", "    if [[ ! $1 =~ ^[0-9]+$ ]]; then\n\
    \        echo \"Argument must be an integer.\"\n        return 1\n    fi\n\n \
    \   declare -i n=${1}\n    declare -i m\n    for ((m = n - 1; m > 0; m--)); do\n\
    \        if [[ $((n % m)) -eq 0 ]]; then\n            echo \"$m\"\n          \
    \  return 0\n        fi\n    done\n    echo \"No divisor smaller than $n was found.\"\
    \n    return 1", "    local integer=$1\n    local current_divisor=1\n    local\
    \ largest_divisor=1\n    while [ $current_divisor -lt $integer ]; do\n       \
    \ if [ $(bc <<< \"$integer % $current_divisor\") == 0 ]; then\n            largest_divisor=$current_divisor\n\
    \        fi\n        current_divisor=$((current_divisor + 1))\n    done\n    echo\
    \ $largest_divisor", '    echo $1 | gawk -f "$DIR/awk/largest_divisor.awk"', " \
    \   echo \"$1\" | awk 'BEGIN {max = 0} {for (i = $1-1; i >= 1; i--) {if ($1 %\
    \ i == 0) {max = i; break}}} END {print max}'", "  n=$1\n  for ((i=$n; i>0; i--));\
    \ do\n    if [[ $((n%i)) == 0 ]]; then\n      echo $i\n      break\n    fi\n \
    \ done", "  _result=1\n  if [ $1 -eq 1 ]; then\n    echo $_result\n    return\n\
    \  fi\n  # if the number is even\n  if [ $(expr $1 % 2) -eq 0 ]; then\n    while\
    \ [ $(expr $1 % 2) -eq 0 ]; do\n      _result=$(expr $1 / 2)\n      _n=$_result\n\
    \    done\n  else\n    _n=$1\n  fi\n  _i=3\n  while [ $(expr $_n % $_i) -eq 0\
    \ ]; do\n    _result=$(expr $_n / $_i)\n    _n=$_result\n    _i=$(expr $_i + 2)\n\
    \  done\n  echo $_result", "    # Use bc to find the square root of n and convert\
    \ that back to an integer\n    n=$1\n    root=$(echo \"sqrt($n)\" | bc | xargs\
    \ printf \"%.0f\")\n    for (( i=2; i<=root; i++ )); do\n        if [[ $(( n %\
    \ i )) -eq 0 ]]; then\n            echo \"$i\"\n            break\n        fi\n\
    \    done", "  local number=$1\n  local largest_divisor=1\n  if [ $number -gt\
    \ 2 ]; then\n    for (( i=2; i<$number; i++ ))\n    do\n      (( $number % $i\
    \ == 0 )) && largest_divisor=$i\n    done\n  fi\n  echo $largest_divisor", " \
    \   local n=$1\n    while [ $(is_multiple \"$n\" \"$n\") = \"false\" ]; do\n \
    \       let n=$n-1\n    done\n    echo \"$n\"", "    if [[ -z \"$1\" ]]; then\n\
    \        echo \"\"\n        return 1\n    fi\n\n    local -i max\n    local -i\
    \ i\n\n    max=1\n    for ((i = 2; i < $1; i++)); do\n        if (($1 % i == 0));\
    \ then\n            max=$i\n        fi\n    done\n\n    echo \"$max\"", "    local\
    \ number=$1\n    local divisor=2\n    local largest_divisor=1\n    local max_test_divisor=$(printf\
    \ \"%.0f\" $(echo \"sqrt($number)\" | bc -l))\n\n    while [[ $divisor -le $max_test_divisor\
    \ ]]; do\n        if [[ $(($number % $divisor)) -eq 0 ]]; then\n            largest_divisor=$divisor\n\
    \        fi\n        divisor=$(($divisor + 1))\n    done\n\n    echo $largest_divisor",
  "  current_divisor=2\n  while [[ $(( $1 % $current_divisor )) -eq 0 ]]; do\n   \
    \ current_divisor=$(( $current_divisor + 1 ))\n  done\n  echo $(( $current_divisor\
    \ - 1 ))", "  local i\n  local n=\"$1\"\n  # Local variables are scoped to the\
    \ nearest block or function, unlike global variables\n  # which are scoped to\
    \ the entire running shell process. Any reference to a variable\n  # that has\
    \ not previously been declared, whether it be a function argument,\n  # variable\
    \ assignment, or a subshell, automatically declares the variable as a global variable.\n\
    \  # Local variables are a great way to avoid variable name collisions.\n  # If\
    \ you have a loop that uses a variable named I and you want to create a function\
    \ that\n  # also uses a variable named I, you can make the function variable local\
    \ to ensure that\n  # the variable used inside the function is separate from the\
    \ variable used in the loop.\n  for ((i = \"$((n - 1))\"; i > 0; i--)); do\n \
    \   if ((n % i == 0)); then\n      echo \"$i\"\n      return\n    fi\n  done",
  "    # All numbers are divisible by 1\n    echo \"1\"", "  for n in $(seq 1 \"$(($1-1))\"\
    ); do\n    if [ $(($1 % $n)) == 0 ]; then\n      echo \"$n\"\n    fi\n  done |\
    \ sort -nr | head -n 1", "    local n=\"$1\"\n    while [ $(($n % 2)) -eq 0 ];\
    \ do\n        n=$(($n / 2))\n    done\n    echo $n", "  if [[ \"$1\" = \"0\" ]];\
    \ then\n    echo 'number is zero'\n    return\n  fi\n  if [[ \"$1\" = \"1\" ]];\
    \ then\n    echo \"1\"\n    return\n  fi\n  for ((i = $1 - 1; i > 0; i--)); do\n\
    \    if (($1 % i == 0)); then\n      echo \"$i\"\n      return\n    fi\n  done",
  "  local -r number=\"$1\"\n  local -i largest=0\n  for (( i=1; i<=$number; i++ ));\
    \ do\n    if [[ $(($number % $i)) -eq 0 ]]; then\n      largest=$i\n    fi\n \
    \ done\n  echo \"$largest\"", "    i=2\n    val=$1\n    while [[ $((val % i))\
    \ -eq 0 ]]; do\n        val=$((val / i))\n    done\n    echo $val", "    n=\"\
    $1\"\n    for i in $(seq 2 $((n-1))); do\n        if [ $((n % i)) -eq 0 ]; then\n\
    \            echo $i\n            break\n        fi\n    done", "    (( $1 % 2\
    \ == 0 )) && echo 2 && return\n    (( $1 % 3 == 0 )) && echo 3 && return\n   \
    \ local t=$(($1/4))\n    for ((i=5; i <= t; i+=6)); do\n        (( $1 % i == 0\
    \ )) && echo $i && return\n        (( $1 % (i+2) == 0 )) && echo $((i+2)) && return\n\
    \    done\n    echo $1", '  # Write your code here', "    max=1\n    for((i=2;\
    \ i<$1; i++)); do\n        if [ $(( $1 % $i )) == 0 ]; then\n            max=$i\n\
    \        fi\n    done\n    echo $max", "    local n=$1\n    local largest_divisor=1\n\
    \    for (( i=2; i<n; i++ )); do\n        if [ $(expr $n % $i) == 0 ]; then\n\
    \            largest_divisor=$i\n        fi\n    done\n    echo $largest_divisor",
  "  number=$1\n  max=$((${number}-1))\n  for ((i=2; i<=${max}; i++)); do\n    if\
    \ (($((${number}%${i})) == 0)); then\n      echo ${i}\n      return\n    fi\n\
    \  done", "  local number=$1\n  local divisor=1\n  while [[ $divisor -lt $number\
    \ ]]; do\n    if [[ $(($number % $divisor)) -eq 0 ]]; then\n      echo $divisor\n\
    \    fi\n    divisor=$(($divisor + 1))\n  done", "  for (( i=$1-1; i>0; i-- ))\n\
    \  do\n    if [ $(( $1 % $i )) -eq 0 ]\n    then\n      echo $i\n      break\n\
    \    fi\n  done", "  local n=\"$1\"\n  # Take half of the value of n, and look\
    \ for odd numbers that divide n evenly, starting from odd value\n  local d=$((n/2))\n\
    \  while [ $((n%d)) -ne 0 ]; do\n    d=$((d-2))\n  done\n  echo \"$d\"", "  n=$1\n\
    \  d=2\n  until [ $((n % d)) -eq 0 ]; do\n    d=$((d + 1))\n  done\n  echo \"\
    $d\"", "    local max_divisor=0\n    for divisor in $(seq 1 $1); do\n        [[\
    \ $(( $1 % $divisor )) -eq 0 ]] && {\n            max_divisor=$divisor\n     \
    \   }\n    done\n    echo $max_divisor", "  integer=$1\n  if [[ $integer -eq 1\
    \ ]]; then\n    echo \"1\"\n  else\n    divisor=$(echo $integer | awk '{print\
    \ int($1 / 2)}')\n    while [[ $(( $integer % $divisor )) -ne 0 ]]; do\n     \
    \ divisor=$(( $divisor - 1 ))\n    done\n    echo $divisor\n  fi", "    local\
    \ n=$1\n    local high=$((n/2))\n    local guess=$high\n    local divisor=1\n\
    \    while [ $guess -gt 0 ]; do\n        if [ $((n%guess)) -eq 0 ]; then\n   \
    \         divisor=$guess\n            break\n        fi\n        guess=$((guess-1))\n\
    \    done\n    echo $divisor", "  # Assume that the largest divisor is 1 smaller\
    \ than the number\n  local max=1\n  local i=2\n  # Keep looping until we reach\
    \ the number, or we find a match\n  while [ \"$i\" -lt \"$1\" ]\n  do\n    # Check\
    \ if the number is evenly divisible\n    if [ $(( $1 % $i )) -eq 0 ]\n    then\n\
    \      # If so, save the new maximum\n      max=$i\n    fi\n    i=$(( $i + 1 ))\n\
    \  done\n  echo \"$max\"", "  local n=$1\n  let half_n=$((n/2))\n  for i in $(seq\
    \ 2 $half_n); do\n    let r=$((n%i))\n    if [ $r -eq 0 ]; then\n      let q=$((n/i))\n\
    \      echo $q\n      return\n    fi\n  done\n  echo $n", "    echo \"$1\" | awk\
    \ '{for(i=1;i<=$1;i++) if($1%i==0) printf i\" \"; print \"\"}' | sort -rn | head\
    \ -n1", "  ld=0\n  for ((i=1; i<$1; i++)); do\n    mod=$(($1 % $i))\n    if [\
    \ $mod -eq 0 ]; then\n      ld=$i\n    fi\n  done\n  echo $ld", "    local max=$1\n\
    \n    for ((i=2; i < max; i++)); do\n        (( $max % i == 0 )) && echo $i &&\
    \ break\n    done", "  n=\"$1\"\n  ## Take half-1 of it's value\n  ceiling=\"\
    $(( n / 2 - 1 ))\"\n  for i in $(seq \"$ceiling\" 1); do\n    remainder=\"$((\
    \ n % i ))\"\n    if [[ \"$remainder\" == \"0\" ]]; then\n      # found it!\n\
    \      echo \"$i\"\n      return\n    fi\n  done\n  # Oops. \"1\" is the largest.\n\
    \  echo \"1\"", "  local INTEGER=\"$1\"\n  local BOUND=$((INTEGER-1))\n  local\
    \ RESULT=1\n  while [[ \"$BOUND\" -gt 1 ]]; do\n    if [[ $((INTEGER%BOUND)) -eq\
    \ 0 ]]; then\n      RESULT=\"$BOUND\"\n      break\n    fi\n    BOUND=$((BOUND-1))\n\
    \  done\n  echo \"$RESULT\"", "    local n=$1 i=2\n    while [ $i -lt $n ]; do\n\
    \        if [ $(($n % $i)) -eq 0 ]; then\n            echo $i\n            return\n\
    \        fi\n        i=$(($i + 1))\n    done", "  # First we find the divisors\n\
    \  divisors=($(divisors \"$1\"))\n  # Then sort them\n  sorted=($(sort_numbers\
    \ \"${divisors[@]}\"))\n  # Finally, we get the last element\n  echo \"${sorted[-1]}\"",
  "  if [[ $1 =~ ^-?[0-9]+$ ]]; then\n    printf \"%s\\n\" $(/usr/bin/factor \"$1\"\
    \ | grep -Eo '[0-9]+$')\n  else\n    printf \"%s\\n\" \"Not an integer\"\n  fi",
  "    [[ $1 =~ ^[0-9]+$ ]] || { echo \"Invalid number.\"; return 1; }\n    max=$1\n\
    \    for (( i=2; i<=$max; i++ )); do\n        if [[ $(( $max % $i )) == 0 ]];\
    \ then\n            largest_divisor=$i\n            max=$(( $max / $i ))\n   \
    \         i=1\n        fi\n    done\n    echo $largest_divisor", "    divisor=$(($1-1))\n\
    \    while [[ $(($1 % $divisor)) -ne 0 ]]; do\n        divisor=$(($divisor-1))\n\
    \    done\n    echo $divisor", "  local num=$1\n  local div=$((num/2))\n  while\
    \ [[ $((num%div)) -ne 0 ]]; do\n    div=$((div-1))\n  done\n  echo $div", "  \
    \  local number=$1\n    local count=2\n    local largest_divisor=1\n    while\
    \ [ $count -lt $number ]; do\n        if [ $(($number % $count)) -eq 0 ]; then\n\
    \            largest_divisor=$count\n        fi\n        count=$(($count + 1))\n\
    \    done\n    echo $largest_divisor", "  set -o pipefail\n  for n in $(seq 2\
    \ $1); do\n    if echo \"$1 % $n\" | bc -l | grep '^0$' &> /dev/null; then\n \
    \     echo $n\n      break\n    fi\n  done", "    echo $1 | awk '{\n    c=1\n\
    \    while (c < $1) {\n        if ($1%c == 0) {\n            res=c\n        }\n\
    \        c++\n    }\n    print res\n    }'", "  integer_is_greater_than 0 \"$1\"\
    \n  max_divisor=$(number_of_digits \"$1\")\n  (( max_divisor -= 1 ))\n  largest_divisor=1\n\
    \  for (( i=2; i<=$max_divisor; i++ )); do\n    if divisible_by \"$1\" \"$i\"\
    ; then\n      largest_divisor=$i\n    fi\n  done\n  echo \"$largest_divisor\"",
  "    local max_divisor=$(($1 - 1))\n    while [ $max_divisor -gt 1 ]; do\n     \
    \   local remainder=$(($1 % $max_divisor))\n        if [ $remainder -eq 0 ]; then\n\
    \            echo $max_divisor\n            return\n        fi\n        max_divisor=$(($max_divisor\
    \ - 1))\n    done\n    echo 1", "  for i in $(seq 1 \"$1\"); do\n    if [[ $(($1\
    \ % $i)) -eq 0 ]]; then\n      echo $i\n    fi\n  done | sort -nr | head -n 1",
  "  local n=\"$1\"\n  local ld=2\n  local d=2\n  while ((d * d <= n)); do\n    while\
    \ ((n % d == 0)); do\n      ld=$d\n      n=$((n / d))\n    done\n    d=$((d +\
    \ 1))\n  done\n  echo $((n > ld ? n : ld))", "    local n=$1\n    # Iterate over\
    \ the range [1, n)\n    for ((i=n-1; i>0; i--)); do\n        # If n is divisible\
    \ by i, then i is the largest divisor smaller than n\n        if [[ $((n % i))\
    \ -eq 0 ]]; then\n            echo $i\n            return\n        fi\n    done",
  "    # validating argument\n    _int_regex='^[0-9]+$'\n    if ! [[ $1 =~ $_int_regex\
    \ ]] ; then\n        echo \"error: Not a number\" >&2; exit 1\n    fi\n\n    #\
    \ finding factors\n    local factors=()\n    for ((i=1; i<$1; i++)); do\n    \
    \    if [[ $(($1 % $i)) == 0 ]]; then\n            factors+=($i)\n        fi\n\
    \    done\n\n    # finding maximum number\n    printf \"%s\\n\" \"${factors[@]}\"\
    \ | sort -nr | head -n1", "  local n=0\n  echo \"${1}\" | rev | grep -ob '^0*1'\
    \ | rev | cut -d: -f1", "    local -i num=$1\n    local -i divisor=1\n    while\
    \ [ $divisor -lt $num ]; do\n        if [ $(($num % $divisor)) -eq 0 ]; then\n\
    \            echo \"$divisor\"\n        fi\n        divisor=$(($divisor + 1))\n\
    \    done", "    local r=$1\n    for (( i = r - 1; i > 0; i-- )); do\n       \
    \ if [[ $(( r % i )) == 0 ]]; then\n            echo \"$i\"\n            return\n\
    \        fi\n    done", "    local number=$1\n    local factors=$(factor $number)\n\
    \    echo \"$factors\" | sed -n '$p' | awk '{print $2}'", "    echo $1 | grep\
    \ '^[0-9]*$' || {\n        echo \"Error: '$1' is not an integer\" >&2\n      \
    \  return 1\n    }\n    [ $1 -eq 1 ] && echo \"1\" || {\n        local n=$1; shift\n\
    \        while [ $n -gt 1 ]; do\n            if [ $(($n % 2)) -eq 0 ]; then\n\
    \                n=$(($n / 2))\n            else\n                n=$(($n - 1))\n\
    \            fi\n        done\n        echo $n\n    }", "    local -r num=$1\n\
    \    local -r sqrt_num=$(echo \"sqrt($num)\" | bc)\n    local divisor=2\n    while\
    \ ((divisor <= sqrt_num)); do\n        ((num % divisor == 0)) && break\n     \
    \   ((divisor++))\n    done\n    echo $divisor", "  n=$1\n\n  while [ $((n-1))\
    \ -gt 0 ]; do\n    n=$((n-1))\n    if [ $(( $1 % $n )) -eq 0 ]; then\n      echo\
    \ $n\n      return\n    fi\n  done", "    local num=${1:-1}\n    local div=$((num-1))\n\
    \    while [ $((num%div)) -ne 0 ]; do\n        div=$((div-1))\n    done\n    echo\
    \ $div", "    local n=$1\n\n    if [ $((n % 2)) -eq 0 ]; then\n        echo $((n\
    \ / 2))\n    else\n        local i\n        for ((i=3; i<=$((n / 2)); i++)); do\n\
    \            if [ $((n % i)) -eq 0 ]; then\n                echo $((n / i))\n\
    \                return\n            fi\n        done\n        echo \"1\"\n  \
    \  fi", "  local n=$1\n  local max_num=$((n-1))\n  echo \"$(factor $n | awk '{$1=\"\
    \"; print $0}' | awk '{$NF=\"\"; print $0}' | awk '{$(NF-1)=\"\"; print $0}' |\
    \ awk '{$NF=\"\"; print $0}' | awk '{$(NF-1)=\"\"; print $0}' | awk '{print $NF}')\"",
  "  local -i num=\"$1\"\n  local -i factor=2\n\n  while (( num % factor != 0 ));\
    \ do\n    (( factor++ ))\n  done\n\n  echo \"$factor\"", "    local i j\n    for\
    \ i in $(seq $1 -1 1); do\n        (( i % $1 == 0 )) && break\n    done\n    echo\
    \ $i", "    local -i n=\"$1\"\n    local i\n    for ((i=n/2; i > 0; i--)); do\n\
    \        if (((n % i) == 0)); then\n            echo \"$i\"\n            return\n\
    \        fi\n    done", "  [[ $1 -gt 0 ]] || exit 1\n  local max_factor=\"$1\"\
    \n  local factor=2\n  while [[ $factor -lt $max_factor ]]; do\n    if [[ $(( $1\
    \ % $factor )) -eq 0 ]]; then\n      max_factor=$factor\n    fi\n    factor=$((\
    \ $factor + 1 ))\n  done\n  echo \"$max_factor\"", "    if [[ $1 -eq 1 ]]; then\n\
    \        echo 1\n    else\n        echo $(($1 / 2))\n    fi", "  if ! [[ \"$1\"\
    \ =~ ^[0-9]+$ ]]; then\n    echo \"Invalid input: $1\"\n    return 0\n  fi\n\n\
    \  local input=$1\n  local last_divisor=$input\n  let last_divisor-=1\n\n  while\
    \ [ \"$last_divisor\" -gt \"0\" ]; do\n    let \"remainder = $input % $last_divisor\"\
    \n    if [ \"$remainder\" -eq \"0\" ]; then\n      echo \"$last_divisor\"\n  \
    \    return 0\n    fi\n    let last_divisor-=1\n  done", "  n=$1\n  # Divide n\
    \ by 2, then by 3, and so on, until n is no longer evenly divisible\n  # by that\
    \ number\n  for i in $(seq 2 $n); do\n    if (( $n % $i == 0 )); then\n      if\
    \ (( $i == $n )); then\n        echo $i\n      else\n        largest_divisor $i\n\
    \      fi\n      return 0\n    fi\n  done", "  [ \"$#\" -ne 1 ] && echo \"Provide\
    \ a single number\" && return 1\n  local n=1\n  for (( i=n; i<\"$1\"; i++ ));\
    \ do\n    # n divides evenly\n    [ $(( i % n )) -eq 0 ] && echo \"$i\"\n  done",
  "    if [ $1 -eq 1 ]; then\n        echo $1\n    else\n        j=1\n        for\
    \ ((i=2; i<$1; i++)); do\n            if [ $(($1 % $i)) -eq 0 ]; then\n      \
    \          j=$i\n            fi\n        done\n        echo $j\n    fi", "   \
    \ local n=$1\n    local divisor=$((n-1))\n    while [ $((n%divisor)) -ne 0 ];\
    \ do\n        ((divisor-=1))\n    done\n    echo $divisor", "    local divisor=1\n\
    \    for (( divisor=1; divisor<=${1}; divisor++ ))\n    do\n        if [ $(( ${1}\
    \ % ${divisor} )) -eq 0 ]\n        then\n            local largest_divisor=${divisor}\n\
    \        fi\n    done\n    echo ${largest_divisor}", "    if [[ ! \"$1\" =~ ^[0-9]+$\
    \ ]]; then\n        echo \"$1 is not an integer\" >&2\n        return 1\n    fi\n\
    \n    local number=\"$1\"\n    while (( --number > 0 )); do\n        if (( number\
    \ % $1 == 0 )); then\n            echo \"$number\"\n            return 0\n   \
    \     fi\n    done", "  if [[ ! $1 =~ ^[0-9]+$ ]]; then\n    printf \"error: largest_divisor:\
    \ argument to largest_divisor must be an integer\\n\"\n    return 1\n  fi\n\n\
    \  local max_divisor=$(( $1 / 2 ))\n  for (( i=max_divisor; i > 0; i-- )); do\n\
    \    if [[ $(( $1 % $i )) == 0 ]]; then\n      echo $i\n      return 0\n    fi\n\
    \  done", "  local max=$1\n  local i=2\n  local result=0\n  while [ $i -lt $max\
    \ ]; do\n    if [ $((max % i)) -eq 0 ]; then\n      result=$i\n    fi\n    i=$((i\
    \ + 1))\n  done\n  echo $result", "    local LARGEST_DIVISOR=\"1\"\n    for ((\
    \ i=2; i<$1; i++ )); do\n        if [ $(($1 % $i)) -eq 0 ]; then\n           \
    \ if [ $i -gt $LARGEST_DIVISOR ]; then\n                LARGEST_DIVISOR=$i\n \
    \           fi\n        fi\n    done\n    echo $LARGEST_DIVISOR", "  local largest=1\n\
    \  while [ \"$(( $1 % 2 ))\" -eq 0 ]; do\n    let \"largest = $1 / 2\"\n    let\
    \ \"largest_divisor = $1 / 2\"\n  done\n  echo \"$largest\"", "    local number=$1\n\
    \    for (( d = number - 1; d > 0; d-- )); do\n        if [[ $(expr $number %\
    \ $d) -eq 0 ]]; then\n            echo $d\n            return\n        fi\n  \
    \  done", '    echo $1', "  local i=1\n  local n=$1\n  local max_i\n  while [\
    \ \"$i\" -lt \"$n\" ]; do\n    if [ $((n % i)) -eq 0 ]; then\n      max_i=$i\n\
    \    fi\n    i=$((i + 1))\n  done\n  echo \"$max_i\"", "    local number=\"$1\"\
    \n    local factor=2\n    while [ $(( number % factor )) -eq 0 ]; do\n       \
    \ echo $factor\n        number=$(( number / factor ))\n    done\n    if [ $number\
    \ -gt 1 ]; then\n        echo $number\n    fi", "  local number=\"$1\"\n  local\
    \ largest=\"$number\"\n  local i\n\n  for ((i = 2; i < number; i++)); do\n   \
    \ if [[ $((number % i)) == 0 ]]; then\n      largest=\"$i\"\n    fi\n  done\n\n\
    \  echo \"$largest\"", "    for ((i=$1/2; i>1; i--)); do\n        if (( $1 % $i\
    \ == 0 )); then\n            echo $i\n            return\n        fi\n    done\n\
    \    echo \"1\"", "  local NUMBER=$1\n  local LARGEST_DIVISOR=0\n  local CURRENT_DIVISOR=1\n\
    \  while [ $CURRENT_DIVISOR -lt $NUMBER ]; do\n    if [ $((NUMBER % CURRENT_DIVISOR))\
    \ -eq 0 ]; then\n      LARGEST_DIVISOR=$CURRENT_DIVISOR\n    fi\n    CURRENT_DIVISOR=$((CURRENT_DIVISOR\
    \ + 1))\n  done\n  echo $LARGEST_DIVISOR", "  num=$1\n  i=$((num-1))\n  while\
    \ [ $i -gt 1 ]; do\n    if [ $(($num % $i)) -eq 0 ]; then\n      echo $i\n   \
    \   break\n    fi\n    i=$((i-1))\n  done", "    local N=$1\n    local IFS=.\n\
    \    local -a arr=($N)\n    if [[ $N == *.* ]]; then\n        echo \"Number must\
    \ be an integer.\"\n        return 1\n    fi\n    local SMALLEST=$N\n    for ((i=2;\
    \ i<=N; i++)); do\n        if [[ $(bc <<< \"$N % $i\") == 0 ]]; then\n       \
    \     if [[ $i -lt $SMALLEST ]]; then\n                SMALLEST=$i\n         \
    \   fi\n        fi\n    done\n    echo $SMALLEST", "    local i j\n    for ((i=2;\
    \ i<=$1; i++)); do\n        if [ $((i*i)) -gt $1 ]; then\n            break\n\
    \        fi\n        if [ $((i*i)) -eq $1 ]; then\n            echo $i\n     \
    \       break\n        fi\n        for ((j=2; j<i; j++)); do\n            if [\
    \ $((i*j)) -eq $1 ]; then\n                echo $i\n                break\n  \
    \          fi\n        done\n    done", "    local n=\"$1\"\n    # Check if n\
    \ is a valid positive integer\n    local n_is_positive_integer=false\n    [[ $n\
    \ =~ ^[0-9]+$ ]] && n_is_positive_integer=true\n\n    if $n_is_positive_integer;\
    \ then\n        local i=\"$n\"\n        while true; do\n            if (( i%n\
    \ == 0 )); then\n                echo \"$i\"\n                break\n        \
    \    fi\n            (( i-- ))\n        done\n    else\n        echo \"Error:\
    \ argument is not a positive integer\" >&2\n        return 1\n    fi", "    local\
    \ number=$1\n\n    if [[ ! $number =~ ^[0-9]+$ ]]; then\n        echo \"Error:\
    \ largest_divisor expects only integers\" >&2\n        return 1\n    fi\n\n  \
    \  for ((i = $number - 1; i > 0; i--)); do\n        [[ $((number % i)) -eq 0 ]]\
    \ && echo $i && return 0\n    done\n\n    return 1", "  # We can't find a divisor\
    \ that's greater than n, so start at n and move downwards\n  divisor=$1\n  # Keep\
    \ checking if this number is a divisor until we find one.\n  while [ \"$(( $1\
    \ % $divisor ))\" -ne 0 ]; do\n    # If not, we haven't found one yet, so keep\
    \ moving downward\n    divisor=$(( $divisor - 1 ))\n  done\n  # When we exit the\
    \ loop, we've found the greatest number that divides n evenly\n  echo $divisor",
  "    local target=$1\n    local largest_divisor=1\n    local i\n    for i in $(seq\
    \ 1 $((target-1))); do\n        local remainder=$((target % i))\n        if [[\
    \ $remainder -eq 0 ]]; then\n            largest_divisor=$i\n        fi\n    done\n\
    \    echo $largest_divisor", "    for (( i=1; i<$1; i++ ))\n    do\n        if\
    \ [[ $(( $1 % $i )) -eq 0 ]]\n        then\n            divisor=$i\n        fi\n\
    \    done\n    echo $divisor", "  local n=$1\n  local i=$((n - 1))\n  while [\
    \ $i -gt 1 ]; do\n    if [ $(($n % $i)) -eq 0 ]; then\n      echo $i\n      return\n\
    \    fi\n    i=$((i - 1))\n  done\n  echo 1", "  local num=$1\n  # no divide by\
    \ zero\n  if [ $num -le 0 ]; then\n    echo \"Error: Please supply a positive\
    \ integer\"\n    return\n  fi\n  # divide by two as long as it's even\n  while\
    \ [ $(expr $num % 2) -eq 0 ]; do\n    num=$(expr $num / 2)\n  done\n  # special\
    \ case for 3, 5 and 7\n  case $num in\n    3|5|7)\n      echo $num\n      return\n\
    \      ;;\n  esac\n  # start at 3, and step by 2, until num is reached\n  # each\
    \ number will be prime, because if it was not, it would have been divided by a\
    \ smaller number\n  i=3\n  local largest=2\n  while [ $i -lt $num ]; do\n    if\
    \ [ $(expr $num % $i) -eq 0 ]; then\n      largest=$i\n    fi\n    i=$(expr $i\
    \ + 2)\n  done\n  echo $largest", "  local INTEGER=\"$1\"\n  local LARGEST_DIVISOR=1\n\
    \  local CURRENT_DIVISOR=2\n  while [ \"$CURRENT_DIVISOR\" -lt \"$INTEGER\" ];\
    \ do\n    if [ \"$(($INTEGER % $CURRENT_DIVISOR))\" -eq 0 ]; then\n      LARGEST_DIVISOR=\"\
    $CURRENT_DIVISOR\"\n    fi\n    CURRENT_DIVISOR=$(($CURRENT_DIVISOR + 1))\n  done\n\
    \  echo \"$LARGEST_DIVISOR\""]
stop_tokens:
- "\n}"
