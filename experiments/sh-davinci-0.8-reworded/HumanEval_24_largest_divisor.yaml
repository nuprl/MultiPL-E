name: HumanEval_24_largest_divisor
language: sh
prompt: "#!/bin/bash\n# For a given number n, find the largest number that divides\
  \ n evenly, smaller than n\n# >>> $(largest_divisor \"15\")\n# \"5\"\n#\n# $1 is\
  \ an integer\nlargest_divisor() {\n"
tests: "}\n\ncandidate() {\n    largest_divisor \"$@\"\n}\n\nset -e\nrun_test() {\n\
  \    [[ $(candidate \"3\") = \"1\" ]]\n    [[ $(candidate \"7\") = \"1\" ]]\n  \
  \  [[ $(candidate \"10\") = \"5\" ]]\n    [[ $(candidate \"100\") = \"50\" ]]\n\
  \    [[ $(candidate \"49\") = \"7\" ]]\n}\n\nrun_test"
completions: ["  #[[ $1 =~ ^[1-9]+$ ]] && {\n  [[ $1 =~ ^[0-9]+$ ]] && {\n    if [[\
    \ $1 -lt 2 ]]; then\n      echo \"1\"\n    else\n      # Get the list of the prime\
    \ factors of a given number\n      factor $1 > /dev/null\n      # Reduce the number\
    \ until we get the largest one that divides the number\n      x=$(factor $1 |\
    \ cut -d \":\" -f 2 | tr -d \" \" | sed 's/[0-9]//g' | sed 's/x/ * /g' | tr \"\
    *\" \"\\n\" | sort -nr)\n      for i in $x; do\n        if [[ $(( $1 % $i )) ==\
    \ 0 ]]; then\n          echo $i\n          break\n        fi\n      done\n   \
    \ fi\n  } || echo \"0\"", "  for (( i=$1-1; i > 0; i-- )); do\n    if [[ $(( $1\
    \ % $i )) -eq 0 ]]; then\n      echo $i\n      break\n    fi\n  done", "    local\
    \ n=\"$1\"\n    local i=\"$n\"\n    while [ \"$i\" -gt \"0\" ]; do\n        if\
    \ [ $((n % i)) -eq 0 ]; then\n            echo \"$i\"\n            return\n  \
    \      fi\n        i=$((i - 1))\n    done", "    for number in $(seq 1 $1); do\n\
    \        if [[ $(( $1 % $number )) -eq 0 ]]; then\n            echo $number\n\
    \        fi\n    done | sort -nr | head -n 1", "  local largest_divisor=1\n  local\
    \ i=2\n  while [ $i -lt $1 ]; do\n    if [ $(bc <<< \"$1 % $i\") -eq 0 ]; then\n\
    \      largest_divisor=$i\n    fi\n    i=$(( i + 1 ))\n  done\n  echo $largest_divisor",
  "    largest_divisor=$1\n    while [ $((largest_divisor - 1)) -gt 0 ]; do\n    \
    \    if [ $((1 % largest_divisor)) -eq 0 ]; then\n            echo $largest_divisor\n\
    \            return 0\n        fi\n        largest_divisor=$((largest_divisor\
    \ - 1))\n    done\n    return 1", "    for (( i=$1-1; i>0; i-- ))\n    do\n  \
    \      if [[ $(is_evenly_divisible $1 $i) == \"1\" ]]\n        then\n        \
    \    echo $i\n            return\n        fi\n    done", "  if [[ $1 =~ ^[0-9]+$\
    \ ]]; then\n    for i in $(seq $1 -1 1); do\n      if (( $1 % $i == 0 )); then\n\
    \        echo $i\n        break\n      fi\n    done\n  else\n    echo \"Not an\
    \ integer.\"\n  fi", "    local n=\"$1\"\n\n    for i in $(seq \"$n\" -1 1); do\n\
    \        if [ $(( n % i )) -eq 0 ]; then\n            echo \"$i\"\n          \
    \  return\n        fi\n    done", "  local n=$1\n  local ld=2\n  while [ $(remainder_divide\
    \ \"$n\" \"$ld\") -ne 0 ]; do\n    ld=$(($ld + 1))\n  done\n  echo $ld", '  echo
    $(echo $1 | xargs -I{} jot -r 1 1 {})', "  local num=\"$1\"\n  local max=`sqrt\
    \ $num`\n  for divisor in `seq 1 $max`; do\n    if [ `is_integer $(echo \"$num/$divisor\"\
    \ | bc -l)` == \"True\" ]; then\n      echo \"$divisor\"\n      return\n    fi\n\
    \  done", "    # Check input is a number\n    [[ \"$1\" =~ ^[0-9]+$ ]] || error_exit\
    \ \"largest_divisor requires an integer\" 1\n\n    # Check for trivial case\n\
    \    if [ \"$1\" -le 2 ]; then\n        echo \"1\"\n        return\n    fi\n\n\
    \    # Because we are searching for a non-trivial factor, the largest possible\
    \ factor\n    # is half of the number. For example, if n = 100, the largest possible\
    \ factor\n    # will be 50 (100 / 2). Therefore we can start checking numbers\
    \ at the floor of\n    # n / 2, and work backwards. The first number we find that\
    \ divides evenly will\n    # be the largest.\n    floor=$(echo \"$1/2\" | bc)\n\
    \    for (( i=$floor; i > 1; i-- ))\n    do\n        remainder=$(echo \"$1 % $i\"\
    \ | bc)\n        if [ \"$remainder\" -eq 0 ]; then\n            echo \"$i\"\n\
    \            return\n        fi\n    done", "  local n=$1\n  local divisor=$((n\
    \ - 1))\n  while [[ $((n % divisor)) -ne 0 ]]; do\n    divisor=$((divisor - 1))\n\
    \  done\n  echo \"$divisor\"", "    divisor=\"$1\"\n    n=\"$1\"\n    while [\
    \ $divisor -gt 1 ]; do\n        n=$((n-1))\n        if [ $(($1 % $n)) -eq 0 ];\
    \ then\n            divisor=$n\n        fi\n    done\n    echo \"$divisor\"",
  "    for (( i=2; i<$1; i++ )); do\n        if [ $(( $1 % $i )) -eq 0 ]; then\n \
    \           # If the modulus is 0, then print the greatest factor and stop\n \
    \           echo \"$i\"\n            break\n        fi\n    done", "  for (( i=2;\
    \ i<${1}; i++ )); do\n    if [[ $((${1} % ${i})) -eq 0 ]]; then\n      echo \"\
    ${i}\"\n      return\n    fi\n  done", "    IFS=' ' read -r -a prime_factors <<<\
    \ $(prime_factors \"$1\")\n    echo \"${prime_factors[-1]}\"", "  local n=\"$1\"\
    \ # given integer\n  local divisor=2\n  while (( divisor <= n/2 ))\n  do\n   \
    \ if (( n % divisor == 0 )); then\n      echo \"$divisor\"\n      break\n    fi\n\
    \    (( divisor++ ))\n  done", "    local n=\"$1\"\n    local max=\"$((n-1))\"\
    \n    for i in $(seq 2 \"$max\"); do\n        if [ \"$((n%i))\" -eq 0 ]; then\n\
    \            echo \"$i\"\n            return\n        fi\n    done"]
stop_tokens:
- "\n}"
