name: HumanEval_16_count_distinct_characters
language: sh
prompt: "#!/bin/bash\n# Given a string, find out how many distinct characters (regardless\
  \ of case) does it consist of\n# >>> $(count_distinct_characters \"xyzXYZ\")\n#\
  \ \"3\"\n# >>> $(count_distinct_characters \"Jerry\")\n# \"4\"\n#\n# $1 is a string\n\
  count_distinct_characters() {\n"
tests: "}\n\ncandidate() {\n    count_distinct_characters \"$@\"\n}\n\nset -e\nrun_test()\
  \ {\n    [[ $(candidate \"\") = \"0\" ]]\n    [[ $(candidate \"abcde\") = \"5\"\
  \ ]]\n    [[ $(candidate \"abcdecadeCADE\") = \"5\" ]]\n    [[ $(candidate \"aaaaAAAAaaaa\"\
  ) = \"1\" ]]\n    [[ $(candidate \"Jerry jERRY JeRRRY\") = \"5\" ]]\n}\n\nrun_test"
completions: ["  (\n    if [ $# -ne 1 ]; then\n      echo \"Error: No string to count\"\
    \n      exit\n    fi\n    str=\"$1\"\n    lower_str=\"$(tr '[:upper:]' '[:lower:]'\
    \ <<< \"$str\")\"\n    echo \"$lower_str\" | grep -o . | sort | uniq | wc -l\n\
    \  )", "    echo \"$1\" | tr '[:upper:]' '[:lower:]' | fold -w1 | sort | uniq\
    \ | wc -l", "    printf -v s \"%s\" \"${1,,}\"\n    echo -n \"${s//[^$s]}\" |\
    \ wc -c", "  if [[ $# -ne 1 ]]; then\n    echo \"Usage: count_distinct_characters\
    \ STRING\"\n    return 1\n  fi\n\n  echo -n $1 | tr '[:upper:]' '[:lower:]' |\
    \ fold -w1 | sort | uniq | wc -l", "    echo -n \"$1\" | tr '[:upper:]' '[:lower:]'\
    \ | fold -w1 | sort | uniq | wc -l", "  if [ $# -ne 1 ]; then\n    return\n  fi\n\
    \  echo $(echo $1 | grep -o -i \"[a-zA-Z]\" | sort | uniq | wc -l)", "    if [\
    \ -z \"$1\" ]; then\n        return 0\n    fi\n    echo \"$1\" | grep -oP '[a-zA-Z]'\
    \ | sort -u | wc -l", "    local string=\"$1\"\n    local count=0\n    # Convert\
    \ to lowercase\n    string=\"${string,,}\"\n    local -a characters=($(echo \"\
    $string\" | fold -w1))\n    local -A character_map\n    for character in \"${characters[@]}\"\
    ; do\n        if [[ \"${character_map[$character]}\" == \"\" ]]; then\n      \
    \      character_map[$character]=1\n            count=$((count + 1))\n       \
    \ fi\n    done\n    echo \"$count\"", '    echo "${1,,}" | fold -w1 | sort | uniq
    | wc -l', "    if [[ -z \"$1\" ]]; then\n        error \"Pass a string.\"\n  \
    \      return 1\n    fi\n\n    echo \"$1\" | tr '[:upper:]' '[:lower:]' | grep\
    \ -o . | sort | uniq | wc -l", "    local str=$1\n    local num=$(echo \"$str\"\
    \ | grep -io '\\S' | sort -u | wc -l)\n    echo \"$num\"", "    echo \"${1,,}\"\
    \ | grep -o '.' | sort | uniq | wc -l", "  local string=\"$1\"\n  echo \"${string}\"\
    \ | tr '[:upper:]' '[:lower:]' | fold -w1 | sort | uniq | wc -l", "    echo \"\
    $1\" | tr -d '\\n' | fold -w1 | sort -fu | wc -l", "  $(echo \"$1\" | tr '[:upper:]'\
    \ '[:lower:]' | fold -w1 | sort | uniq | wc -l)", "    local str=$1\n    declare\
    \ -A char_map\n    local i\n    for ((i=0; i<${#str}; i++)); do\n        local\
    \ this_char=${str:$i:1}\n        local char_map_index=${this_char,,}\n       \
    \ char_map[$char_map_index]=1\n    done\n    echo \"${#char_map[@]}\"", '    echo
    $1 | grep -o "[[:alpha:]]" | sed "s/\(.\)/\1\n/g" | tr "[:upper:]" "[:lower:]"
    | uniq | wc -l', "    echo \"$1\" | \\\n        tr [:upper:] [:lower:] | \\\n\
    \        sort | \\\n        uniq | \\\n        wc -l", "    local string=\"$1\"\
    \n    local lowercase_string=$(echo \"$string\" | tr '[:upper:]' '[:lower:]')\n\
    \    echo \"$lowercase_string\" | fold -w1 | sort | uniq | wc -l", '    echo "${1}"
    | tr "[:upper:]" "[:lower:]" | fold -w1 | sort | uniq | wc -l']
stop_tokens:
- "\n}"
