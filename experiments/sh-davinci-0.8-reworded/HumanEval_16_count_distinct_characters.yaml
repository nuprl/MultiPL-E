name: HumanEval_16_count_distinct_characters
language: sh
prompt: "#!/bin/bash\n# Given a string, find out how many distinct characters (regardless\
  \ of case) does it consist of\n# >>> $(count_distinct_characters \"xyzXYZ\")\n#\
  \ \"3\"\n# >>> $(count_distinct_characters \"Jerry\")\n# \"4\"\n#\n# $1 is a string\n\
  count_distinct_characters() {\n"
tests: "}\n\ncandidate() {\n    count_distinct_characters \"$@\"\n}\n\nset -e\nrun_test()\
  \ {\n    [[ $(candidate \"\") = \"0\" ]]\n    [[ $(candidate \"abcde\") = \"5\"\
  \ ]]\n    [[ $(candidate \"abcdecadeCADE\") = \"5\" ]]\n    [[ $(candidate \"aaaaAAAAaaaa\"\
  ) = \"1\" ]]\n    [[ $(candidate \"Jerry jERRY JeRRRY\") = \"5\" ]]\n}\n\nrun_test"
completions: ["  (\n    if [ $# -ne 1 ]; then\n      echo \"Error: No string to count\"\
    \n      exit\n    fi\n    str=\"$1\"\n    lower_str=\"$(tr '[:upper:]' '[:lower:]'\
    \ <<< \"$str\")\"\n    echo \"$lower_str\" | grep -o . | sort | uniq | wc -l\n\
    \  )", "    echo \"$1\" | tr '[:upper:]' '[:lower:]' | fold -w1 | sort | uniq\
    \ | wc -l", "    printf -v s \"%s\" \"${1,,}\"\n    echo -n \"${s//[^$s]}\" |\
    \ wc -c", "  if [[ $# -ne 1 ]]; then\n    echo \"Usage: count_distinct_characters\
    \ STRING\"\n    return 1\n  fi\n\n  echo -n $1 | tr '[:upper:]' '[:lower:]' |\
    \ fold -w1 | sort | uniq | wc -l", "    echo -n \"$1\" | tr '[:upper:]' '[:lower:]'\
    \ | fold -w1 | sort | uniq | wc -l", "  if [ $# -ne 1 ]; then\n    return\n  fi\n\
    \  echo $(echo $1 | grep -o -i \"[a-zA-Z]\" | sort | uniq | wc -l)", "    if [\
    \ -z \"$1\" ]; then\n        return 0\n    fi\n    echo \"$1\" | grep -oP '[a-zA-Z]'\
    \ | sort -u | wc -l", "    local string=\"$1\"\n    local count=0\n    # Convert\
    \ to lowercase\n    string=\"${string,,}\"\n    local -a characters=($(echo \"\
    $string\" | fold -w1))\n    local -A character_map\n    for character in \"${characters[@]}\"\
    ; do\n        if [[ \"${character_map[$character]}\" == \"\" ]]; then\n      \
    \      character_map[$character]=1\n            count=$((count + 1))\n       \
    \ fi\n    done\n    echo \"$count\"", '    echo "${1,,}" | fold -w1 | sort | uniq
    | wc -l', "    if [[ -z \"$1\" ]]; then\n        error \"Pass a string.\"\n  \
    \      return 1\n    fi\n\n    echo \"$1\" | tr '[:upper:]' '[:lower:]' | grep\
    \ -o . | sort | uniq | wc -l", "    local str=$1\n    local num=$(echo \"$str\"\
    \ | grep -io '\\S' | sort -u | wc -l)\n    echo \"$num\"", "    echo \"${1,,}\"\
    \ | grep -o '.' | sort | uniq | wc -l", "  local string=\"$1\"\n  echo \"${string}\"\
    \ | tr '[:upper:]' '[:lower:]' | fold -w1 | sort | uniq | wc -l", "    echo \"\
    $1\" | tr -d '\\n' | fold -w1 | sort -fu | wc -l", "  $(echo \"$1\" | tr '[:upper:]'\
    \ '[:lower:]' | fold -w1 | sort | uniq | wc -l)", "    local str=$1\n    declare\
    \ -A char_map\n    local i\n    for ((i=0; i<${#str}; i++)); do\n        local\
    \ this_char=${str:$i:1}\n        local char_map_index=${this_char,,}\n       \
    \ char_map[$char_map_index]=1\n    done\n    echo \"${#char_map[@]}\"", '    echo
    $1 | grep -o "[[:alpha:]]" | sed "s/\(.\)/\1\n/g" | tr "[:upper:]" "[:lower:]"
    | uniq | wc -l', "    echo \"$1\" | \\\n        tr [:upper:] [:lower:] | \\\n\
    \        sort | \\\n        uniq | \\\n        wc -l", "    local string=\"$1\"\
    \n    local lowercase_string=$(echo \"$string\" | tr '[:upper:]' '[:lower:]')\n\
    \    echo \"$lowercase_string\" | fold -w1 | sort | uniq | wc -l", '    echo "${1}"
    | tr "[:upper:]" "[:lower:]" | fold -w1 | sort | uniq | wc -l', "    echo $1 |\
    \ sed -r 's/(.)/\\L\\1/g' | sort | uniq | wc -l", '    echo -n $1 | grep -o -i
    . | sort | uniq | wc -l', '  echo $1 | fold -w1 | sort -u | wc -l', "    local\
    \ characters=$(tr 'a-z' 'A-Z' <<< \"$1\")\n    local unique_characters=$(tr -d\
    \ '[:digit:]' <<< \"$characters\")\n    unique_characters=$(tr -d ' ' <<< \"$unique_characters\"\
    )\n    echo $(echo -n \"$unique_characters\" | fold -w1 | sort -u | wc -l)", " \
    \   local num_characters=\"$(tr -d '[:digit:]\\n' <<< $1 | wc -m)\"\n    echo\
    \ $num_characters", '    [[ "$1" =~ ^[a-zA-Z]+$ ]] && echo -n "${#1}" || echo
    -n "0"', "    local inputString=$1\n    local length=${#inputString}\n    if [[\
    \ $length -gt 0 ]]; then\n        local -a charArray=($(echo $inputString | grep\
    \ -o . | sort -u | tr -d \"\\n\"))\n        local len=${#charArray[@]}\n     \
    \   echo $len\n    else\n        echo \"0\"\n    fi", "    if [ $# -ne 1 ]; then\n\
    \        echo \"Usage: $0 <string>\" >&2\n        return 1\n    fi\n\n    if [\
    \ -z \"$1\" ]; then\n        echo 0\n        return 0\n    fi\n\n    # The string\
    \ is not empty.\n    echo -n \"$1\" | tr -c '[:alnum:]' '\\n' | tr '[:upper:]'\
    \ '[:lower:]' | sort | uniq | wc -l", "    echo \"$1\" | tr -cd '[:alnum:]' |\
    \ wc -c", "    echo $(echo \"$1\" | tr '[:upper:]' '[:lower:]' | fold -w1 | sort\
    \ | uniq | wc -l)", "    echo $1 | tr '[:upper:]' '[:lower:]' | fold -w1 | sort\
    \ | uniq | wc -l", "    # First convert the given string to lowercase\n    local\
    \ lowercase=$(echo \"$1\" | tr \"[:upper:]\" \"[:lower:]\")\n    # Obtain the\
    \ distinct characters\n    local distinct=$(echo $lowercase | grep -o .)\n   \
    \ # Count the number of characters\n    local count=$(echo $distinct | wc -c)\n\
    \    # Return the count\n    echo $count", '    echo "$1" | grep -o . | sort -u
    | wc -l', "    echo -n $1 | tr -d -c '[:alpha:]' | wc -c", "  if [ -z \"$1\" ];\
    \ then\n    echo 0\n  else\n    local -n array_of_chars=$1\n    echo ${#array_of_chars[@]}\n\
    \  fi", "    echo $1 | grep -o -i -E '\\w' | sort -u | wc -l", '    echo $(echo
    "$1" | tr [:upper:] [:lower:] | sort | uniq | wc -l)', "    local characters=$(echo\
    \ \"$1\" | tr '[:upper:]' '[:lower:]' | sort | uniq | sed '/^$/d')\n    echo \"\
    ${#characters}\"", "    local STRING=\"$1\"\n    local CHARACTERS=$(echo \"$STRING\"\
    \ | grep -oP \".\" | tr \"[:upper:]\" \"[:lower:]\" | sort | uniq)\n    echo \"\
    $CHARACTERS\" | wc -l", "    local string=\"$1\"\n    local str_lower=$(echo \"\
    $string\" | tr '[:upper:]' '[:lower:]')\n    local str_unique=$(echo \"$str_lower\"\
    \ | fold -w1 | sort -u | tr -d \"\\n\")\n    echo \"${#str_unique}\"", "    echo\
    \ $1 | sed 's/\\(.\\)/\\1\\n/g' | tr '[:upper:]' '[:lower:]' | sort | uniq | wc\
    \ -l", "    local s=\"$1\"\n    echo \"${s,,}\" | fold -w1 | sort | uniq | wc\
    \ -l", "    if [ \"$#\" -ne 1 ]; then\n        echo -e \"[$RED_COLOR$BOLD_TEXT$(basename\
    \ $0)$RESET_COLOR]: usage: $(basename $0) string\"\n        return 1\n    fi\n\
    \n    echo $1 | tr -dc '[:alpha:]' | tr '[:upper:]' '[:lower:]' | fold -w1 | sort\
    \ | uniq | wc -l", "    if [ $# -ne 1 ]; then\n        echo \"missing argument\"\
    \ >&2\n        return 1\n    fi\n\n    # use awk to convert a string to a single\
    \ line and then count the number of fields\n    echo $1 | awk '{print tolower($0)}'\
    \ | awk '{for (i=1; i<=NF; i++) print $i}' | sort | uniq | wc -l", "    if [ -z\
    \ \"$1\" ]; then\n        echo \"0\"\n    else\n        echo -n \"$1\" | tr -cd\
    \ \"[:alnum:]\" | wc -c\n    fi", "  echo \"${1}\" | grep -Eo '[a-zA-Z]' | tr\
    \ '[:upper:]' '[:lower:]' | sort | uniq | wc -l", '    echo $(printf $1 | fold
    -w1 | sort -u | wc -l)', '    echo "$1" | tr -d -c "a-zA-Z" | wc -c', "  echo\
    \ -n \"$1\" |\n  tr '[:upper:]' '[:lower:]' |\n  fold -w1 |\n  sort |\n  uniq\
    \ |\n  wc -l", "    echo \"$1\" | tr -d '\\n' | tr '[:upper:]' '[:lower:]' | \\\
    \n        fold -w1 | sort | uniq | wc -l", '    echo $1 | grep -o "." | sort |
    uniq | wc -l', "    echo \"$1\" | tr -dc 'A-Za-z' | uniq | wc -l", "    echo \"\
    $1\" |\n    awk '{\n        len = length($0)\n        for (i = 1; i <= len; i++)\
    \ {\n            char = substr($0, i, 1)\n            if (dict[char] == 0) {\n\
    \                dict[char] = 1\n            }\n        }\n    }\n    END {\n\
    \        count = 0\n        for (char in dict) {\n            count++\n      \
    \  }\n        print count\n    }'", "  echo \"$1\" | tr '[:upper:]' '[:lower:]'\
    \ | fold -w1 | sort | uniq | wc -l", "    echo $(echo $1 | grep -o . | sed 's/./\\\
    L&/g' | sort | uniq | wc -l)", '  printf "$1" | fold -w1 | sort -u | wc -l', '    echo
    "$1" | fold -w1 | sort -u | wc -l', '  echo "$1" | grep -o "" | sort -u | wc -l',
  "    input=\"$1\"\n    (\n    for i in `echo $input | sed -E 's/([[:alpha:]])/\\\
    1\\n/g' | tr '[:upper:]' '[:lower:]' | sort -u`; do\n        echo $i\n    done\n\
    \    ) | wc -l", "    echo \"$1\" | tr '[:upper:]' '[:lower:]' | fold -w1 | sort\
    \ | uniq | wc -l", "    echo $1 | sed -e 's/[^[:alpha:]]//g' | tr -cd '[:alpha:]'\
    \ | awk '{print length}'", "  # use tr to remove duplicates from string and get\
    \ the length\n  echo -n $1 | tr -d -c \"a-zA-Z\" | wc -c", '  echo "$1" | fold
    -w1 | sort -u | wc -l', "  echo $1 | fold -w1 | sort -u | tr -d '\\n' | wc -c",
  "    for ((i=0; i<${#1}; i++)); do\n        j=${1:i:1}\n        if [[ $j =~ [a-z]\
    \ ]]; then\n            char=${j^^}\n        else\n            char=$j\n     \
    \   fi\n        if [[ $chars != *$char* ]]; then\n            chars=$chars$char\n\
    \        fi\n    done\n    echo ${#chars}", "    local str=$1\n    echo \"${str,,}\"\
    \ | grep -o . | sort | uniq | wc -l", "  if [ -z \"$1\" ]; then\n    echo \"0\"\
    \n  else\n    echo \"$1\" | grep -o \"[A-Za-z]\" | sort | uniq | wc -l\n  fi",
  "  local string=\"$1\"\n  local upper_case_string=$(echo \"$string\" | tr '[:lower:]'\
    \ '[:upper:]')\n  echo \"${#upper_case_string}\"", "  tr -dc '[:alnum:]' <<< \"\
    $1\" | tr '[:upper:]' '[:lower:]' | grep -v -E '^$' | sort | uniq | wc -l", " \
    \   echo -n \"$1\" | fold -w1 | sort -u | tr -d '\\n' | wc -c", '    echo "${1,,}"
    | fold -w1 | sort | uniq | wc -l', "    echo -n \"$1\" | grep -Eo '[a-zA-Z]' |\
    \ tr '[:upper:]' '[:lower:]' | sort | uniq | wc -l", "  local str=$1\n  local\
    \ lower=${str,,}\n  local count=0\n  for ((i=0; i<${#lower}; i++)); do\n    str=${lower:i+1}\n\
    \    if [[ $str != *${lower:i:1}* ]]; then\n      ((count++))\n    fi\n  done\n\
    \  echo $count", "  lower_chars=$(echo \"$1\" | tr '[:upper:]' '[:lower:]')\n\
    \  echo -n \"$lower_chars\" | fold -w1 | sort | uniq | wc -l", "  echo \"$1\"\
    \ | awk '{ print length($0) }'", "    local str\n    str=\"$1\"\n    local result\n\
    \    result=\"$(echo $str | tr '[:upper:]' '[:lower:]' | fold -w1 | sort | uniq\
    \ | wc -l)\"\n    echo \"$result\"", "    local string=\"$1\"\n    local lower_case=\"\
    $(tr '[:upper:]' '[:lower:]' <<< \"$string\")\"\n    local unique_chars=\"$(tr\
    \ -dc '[:alpha:]' <<< \"$lower_case\")\"\n    local distinct_chars=\"$(echo -n\
    \ \"$unique_chars\" | fold -w1 | sort -u | tr -d '\\n')\"\n    echo \"${#distinct_chars}\"",
  '    echo $1 | fold -w1 | sort -u | wc -l', "  echo \"$1\" | grep -o '[a-zA-Z]'\
    \ | sort | uniq | wc -l", "  tr '[:upper:]' '[:lower:]' <<< $1 | uniq | wc -c",
  '    echo $(echo "$1" | fold -w1 | sort | uniq | wc -l)', "    echo \"$1\" | grep\
    \ -o -i '' | sort -u | wc -l", "  local string=\"$1\"\n  local upper_case=${string^^}\n\
    \  local lower_case=${string,,}\n  local distinct_characters=${upper_case//[^$upper_case]/}\n\
    \  local distinct_characters=\"${distinct_characters//[^$lower_case]/}\"\n  echo\
    \ ${#distinct_characters}", '    echo $(eval echo $1 | grep -o . | sort -u | wc
    -l)', "    echo -n $1 | sed 's/\\(.\\)/\\1\\n/g' | sort | uniq | wc -l", "  declare\
    \ -A char_map\n  str_len=${#1}\n  for ((i=0; i<str_len; i++)); do\n    char=${1:i:1}\n\
    \    char_map[$char]=1\n  done\n  echo \"${#char_map[@]}\"", '  echo "$1" | tr
    [:upper:] [:lower:] | fold -w1 | sort | uniq | wc -l', "    echo $(echo \"$1\"\
    \ | tr '[:upper:]' '[:lower:]' | fold -w1 | sort | uniq | wc -l)", "    local\
    \ char_count=0\n    for (( i=0; i<${#1}; i++ )); do\n        if [[ -z $(expr index\
    \ \"${char_count_map[@]}\" \"${1:$i:1}\") ]]; then\n            char_count_map[$char_count]=${1:$i:1}\n\
    \            (( char_count++ ))\n        fi\n    done\n    echo $char_count",
  "  string=\"$1\"\n  tr -cd '[:alpha:]' <<< \"$string\" | wc -c", '    echo "${1,,}"
    | fold -w1 | sort | uniq | wc -l', "  if [[ \"$1\" != \"\" ]]; then\n    # make\
    \ input string lowercase\n    lower_case=$(echo \"$1\" | tr '[:upper:]' '[:lower:]')\n\
    \    # make a string of unique characters\n    unique_lower_case=$(echo \"$lower_case\"\
    \ | fold -w1 | sort -u | tr -d \"\\n\")\n    # count unique characters\n    echo\
    \ -n \"${#unique_lower_case}\"\n  fi", "  echo \"$1\" | tr -dc '[:alnum:]' | tr\
    \ '[:upper:]' '[:lower:]' | wc -m", "  local str=\"$1\"\n  echo $str | tr '[:upper:]'\
    \ '[:lower:]' | grep -o . | sort | uniq | wc -l", "  echo -n \"$1\" | tr -dc '[:alnum:]'\
    \ | tr '[:upper:]' '[:lower:]' | sort | uniq | wc -c", "    local l c\n    l=\"\
    $1\"\n    c=0\n    while [ \"$l\" != \"\" ]; do\n        # if \"$l\" contains\
    \ at least one character left,\n        # then the first character is distinct.\n\
    \        c=$((c+1))\n        # Remove all occurences of the first character from\
    \ \"$l\".\n        l=\"${l%${l:0:1}*}\"\n    done\n    echo \"$c\"", "    # To\
    \ lower\n    local input=\"$(tr [:upper:] [:lower:] <<< \"$1\")\"\n    # Remove\
    \ duplicates\n    local temp=\"$(cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold\
    \ -w 32 | head -n 1)\"\n    local input_no_duplicates=\"$(tr -d \"${temp}\" <<<\
    \ \"$input\")\"\n    local count=\"$(echo -n \"$input_no_duplicates\" | wc -m)\"\
    \n    echo \"$count\"", "    echo $1 | \n    fold -w1 | \n    sort | \n    uniq\
    \ | \n    wc -l", '    echo "$1" | tr "[:upper:]" "[:lower:]" | fold -w1 | sort
    | uniq | wc -l', "    # TODO\n    # echo \"a\" | sort | uniq | wc -l\n    length=$(echo\
    \ -n $1 | wc -m)\n    # echo $length\n    # echo $1 | fold -w 1 | sort | uniq\
    \ | wc -l\n    fold -w 1 $1 | sort | uniq | wc -l", "    echo \"$1\" | grep -o\
    \ '[A-Za-z]' | grep -v '[0-9]' | sort | uniq | wc -l", "  local string=\"$1\"\n\
    \  printf \"%s\" \"${string,,}\" | sed 's/\\(.\\)/\\1\\n/g' | sort | uniq | wc\
    \ -l", '    echo "${1,,}" | grep -o . | sort | uniq | wc -l', "  local string=\"\
    $1\"\n  echo \"$string\" | tr -d ' ' | tr '[:upper:]' '[:lower:]' | sort | uniq\
    \ | wc -l", "    echo -n \"$1\" | grep -o . | tr '[:upper:]' '[:lower:]' | sort\
    \ | uniq | wc -l", "    echo \"$1\" | sed 's/[^[:alpha:]]//g' | tr -d '\\n' |\
    \ tr -s '[:upper:]' '[:lower:]' | wc -m", "    echo \"$1\" | grep -o \"[[:alpha:]]\"\
    \ | tr '[:upper:]' '[:lower:]' | sort | uniq | wc -l", "    echo \"$1\" | grep\
    \ -o -i '[a-z]' | sort | uniq | wc -l", '  echo $1 | tr -d "[:space:]" | grep
    -o . | sort | uniq | wc -l', "    echo -n $1 | tr '[:upper:]' '[:lower:]' | fold\
    \ -w1 | sort | uniq | wc -l", "  local u=$(echo $1 | tr '[:lower:]' '[:upper:]')\n\
    \  local l=$(echo $1 | tr '[:upper:]' '[:lower:]')\n  local diff=$(diff <(echo\
    \ $l) <(echo $u) | grep -Po '([^>])\\w+' | tr -d '[:space:]')\n  echo ${#diff}",
  "    echo $(echo $1 | tr '[:upper:]' '[:lower:]' | grep -o -E '[a-z]' | sort | uniq\
    \ | wc -l)", "    echo \"${1,,}\" | sed 's/\\(.\\)/\\1\\n/g' | sort | uniq | wc\
    \ -l", '    echo $(printf "%s" "$1" | tr "[:upper:]" "[:lower:]" | grep -o . |
    sort | uniq | wc -l)', '  echo $1 | grep -o . | sort | uniq | wc -l', "  echo\
    \ -n \"$1\" | tr '[:upper:]' '[:lower:]' | fold -w1 | sort | uniq | wc -l", " \
    \   echo $(tr -dc '[:alnum:]' <<< \"$1\" | tr '[:upper:]' '[:lower:]' | wc -m)",
  "    echo \"$1\" | tr 'a-zA-Z' '\\n' | grep -v '^$' | sort | uniq | wc -l", '    echo
    "$1" | grep -o -i -E "[a-zA-Z0-9]" | sort | uniq | wc -l', "  local string=$1\n\
    \n  echo $string | grep -o -i . | sort | uniq | wc -l", '  echo "${1,,}" | fold
    -w1 | sort | uniq | wc -l', '  echo "${1,,}" | grep -o . | sort | uniq | wc -l',
  "    echo -n \"$1\" | tr -s '[:space:]' '\\n' | tr '[:upper:]' '[:lower:]' | sort\
    \ | uniq | wc -l", "  echo $(tr '[:upper:]' '[:lower:]' <<< \"$1\" | fold -w1\
    \ | sort -u | wc -l)", "  for c in {a..z} {A..Z}; do\n    [[ $1 =~ $c ]] && echo\
    \ -n \"$c\"\n  done | sort -u | wc -c", "    echo \"$1\" | tr -d '\\n' | tr '[:upper:]'\
    \ '[:lower:]' | fold -w1 | sort | uniq | wc -l", "    local string=$1\n    echo\
    \ ${string,,} | fold -w1 | sort | uniq | wc -l", "    tr -cd \"[:alnum:]\" <<<\
    \ ${1} | tr '[:upper:]' '[:lower:]' | fold -w1 | sort | uniq | wc -l", '    echo
    "$1" | fold -w1 | sort -u | wc -l', "    echo -n \"$1\" | tr -dc '[:alnum:]' |\
    \ tr '[:upper:]' '[:lower:]' | fold -w1 | sort -u | wc -l", "    echo \"$1\" |\n\
    \    grep -o . |\n    tr [:upper:] [:lower:] |\n    sort |\n    uniq |\n    wc\
    \ -l", "  echo -n \"$1\" | tr -d '\\n' | tr -s '[:upper:]' '[:lower:]' | grep\
    \ -o . | sort | uniq | wc -l", "    echo \"${1}\" | tr '[:upper:]' '[:lower:]'\
    \ | fold -w1 | sort | uniq | wc -l", "  # Insert your code here\n  input=$1\n\
    \  lower=$(echo \"$input\" | awk '{print tolower($0)}')\n  echo -n \"$lower\"\
    \ | fold -w1 | sort | uniq | wc -l", "  # TODO: Write your code here\n  echo -n\
    \ \"\"", "    echo \"${1}\" | grep -o \"[a-zA-Z]\" | tr '[:upper:]' '[:lower:]'\
    \ | sort | uniq | wc -l", "    local input=\"$1\"\n    echo $(tr '[:upper:]' '[:lower:]'\
    \ <<< \"$input\" | fold -w1 | sort | uniq | wc -l)", "    echo $1 | sed 's/[^a-zA-Z]//g'\
    \ | tr '[:upper:]' '[:lower:]' | sort | uniq | wc -l", '    echo $(echo "$1" |
    tr "[:upper:]" "[:lower:]" | fold -w1 | sort | uniq | wc -l)', "    echo $(echo\
    \ $1 | sed -e 's/\\(.\\)/\\1\\n/g' | sort | uniq | wc -l)", "  # Write your solution\
    \ here\n  if [[ -z $1 ]]; then\n    echo 0\n  else\n    local lower=\"$(echo $1\
    \ | tr '[:upper:]' '[:lower:]')\"\n    echo ${#lower}\n  fi", '    echo $1 | fold
    -w1 | sort -u | wc -l', "    echo -n \"$1\" | tr '[:upper:]' '[:lower:]' | fold\
    \ -w1 | sort | uniq | wc -l", "  # bash 4.0 or higher is required for this to\
    \ work\n  if [[ $BASH_VERSINFO -ge 4 ]]; then\n    echo ${#1}\n  else\n    echo\
    \ \"Bash 4.0 or higher is required to count distinct characters\"\n  fi", '    echo
    $1 | tr A-Z a-z | fold -w1 | sort | uniq | wc -l', "  local input=\"$1\"\n  local\
    \ -a char_array\n  local char\n\n  i=0\n  for (( i=0; i<${#input}; i++ )); do\n\
    \    char=${input:$i:1}\n    [[ ${char_array[*]} =~ $char ]] || char_array[${#char_array[@]}]=$char\n\
    \  done\n\n  echo ${#char_array[@]}", '    echo $1 | grep -o -i . | sort | uniq
    | wc -l', "    local characters_seen=\"$(echo $1 | fold -w1 | sort | uniq)\"\n\
    \    echo ${#characters_seen}", '    echo "${1,,}" | grep -o . | sort | uniq |
    wc -l', "    if [ $# -ne 1 ]; then\n        echo \"Usage: $0 string\" >&2\n  \
    \      return 1\n    fi\n\n    echo \"$1\" | tr -d \"\\n\" | tr -s '[:lower:]'\
    \ '[:upper:]' | sed 's/\\(.\\)/\\1\\n/g' | sort | uniq | wc -l", "  echo -n \"\
    $1\" | tr '[:upper:]' '[:lower:]' | fold -w1 | sort | uniq | wc -l", '  echo "${1,,}"
    | grep -o . | sort | uniq | wc -l', '    echo "$1" | grep -o "[a-zA-Z]" | sort
    | uniq | wc -l', "  if [ -z \"$1\" ]; then\n    echo 0\n  else\n    echo \"$1\"\
    \ | tr 'a-zA-Z' '\\n' | tr '[:upper:]' '[:lower:]' | sort | uniq | wc -l\n  fi",
  "    if [[ -z \"$1\" ]]; then\n        echo \"Usage: $0 <string>\"\n        return\
    \ 1\n    fi\n\n    echo \"${1,,}\" | grep -o . | sort | uniq | wc -l", "    echo\
    \ \"${1}\" |\n    fold -w1 |\n    grep -v '[^a-zA-Z]' |\n    sort |\n    uniq\
    \ |\n    wc -l", "    LOWER_CASE=$(echo \"$1\" | tr '[:upper:]' '[:lower:]')\n\
    \    echo \"$LOWER_CASE\" | fold -w1 | sort | uniq | wc -l", "    # Pre-process\
    \ the string\n    local str=$(echo \"$1\" | tr '[:upper:]' '[:lower:]')\n    #\
    \ Get the distinct characters\n    # ${str//[^$chars]} removes the characters\
    \ that are not in the set $chars\n    local distinct=$(echo \"${str//[^$str]}\"\
    \ | fold -w1 | sort | uniq)\n    # Get the length of the string\n    echo -n ${#distinct}",
  "    echo -n \"$1\" | tr -d \"[:digit:]\" | sed -r \"s/\\s+//g\" | tr '[:upper:]'\
    \ '[:lower:]' | grep -o . | sort | uniq | wc -l", "    local input=$1\n    local\
    \ length=$(printf \"%s\" \"$input\" | wc -c)\n    local distinct=1\n    local\
    \ current\n    local i\n\n    for i in $(seq 1 $length); do\n        current=$(printf\
    \ \"%s\" \"$input\" | cut -c$i)\n        if ! [[ $(printf \"%s\" \"$input\" |\
    \ cut -c-$i | grep -o \"$current\") =~ \"$current\" ]]; then\n            distinct=$((distinct\
    \ + 1))\n        fi\n    done\n\n    printf \"%s\" \"$distinct\"", '  echo $1
    | wc -m', '  echo "$1" | grep -o -i "[a-z]" | sort | uniq | wc -l', "    printf\
    \ \"${1}\" | grep -o -i '[a-zA-Z]' | sort | uniq | wc -l", "  local str=\"$1\"\
    \n  # your solution here\n  str=$(echo \"${str}\" | tr 'A-Z' 'a-z')\n  local result=$(echo\
    \ \"${str}\" | fold -w1 | sort | uniq | wc -l)\n  echo \"${result}\"", "    echo\
    \ \"$1\" | grep -oI \"[[:alpha:]]\" | tr -d \"[:space:]\" | tr '[:upper:]' '[:lower:]'\
    \ | sort | uniq | wc -l", "  if [ $# -ne 1 ]; then\n    echo \"Usage: count_distinct_characters\
    \ <string>\"\n    return 1\n  fi\n\n  local str=\"$1\"\n  local char_count=0\n\
    \  local char_check=''\n  for (( i=0; i<${#str}; i++ )); do\n    char_check=$(echo\
    \ ${str:$i:1} | tr '[:upper:]' '[:lower:]')\n    if [[ ! \"${char_check}\" =~\
    \ [${char_count}] ]]; then\n      char_count=$char_count$char_check\n    fi\n\
    \  done\n  echo ${#char_count}", '    echo "${1,,}" | fold -w1 | sort | uniq |
    wc -l', "  # tr -d '\\n' replace all newlines with spaces\n  # tr -s ' ' replace\
    \ spaces with a single space\n  # tr '[:upper:]' '[:lower:]' replace upper case\
    \ letters with lower case letters\n  # tr -c ' ' keep only spaces\n  # wc -c count\
    \ the number of chars\n  echo -n $1 | tr -d '\\n' | tr -s ' ' | tr '[:upper:]'\
    \ '[:lower:]' | tr -c ' ' | wc -c", "    str_array=()\n    for ((i=0; i<${#1};\
    \ i++)); do\n        str_array[i]=${1:i:1}\n    done\n    unique_array=($(echo\
    \ \"${str_array[@]}\" | tr ' ' '\\n' | sort -u | tr '\\n' ' '))\n    echo ${#unique_array[@]}",
  "    echo $1 | tr -dc '[:alnum:]' | tr '[:upper:]' '[:lower:]' | fold -w1 | sort\
    \ -u | wc -l", '  echo "$1" | tr -d -c "[:alpha:]" | wc -c', '  printf "$1" |
    grep -io "[a-z]" | sort | uniq | wc -l', "  echo -n \"$1\" | tr -d '\\n' | tr\
    \ '[:upper:]' '[:lower:]' | fold -w1 | sort | uniq | wc -l", "  echo -n $1 | sed\
    \ -e 's/\\(.\\)/\\1\\n/g' | sort | uniq | wc -l", "    # Tr is a useful utility\
    \ that you can use to translate characters\n    echo \"$1\" | tr -dc \"[:alpha:]\"\
    \ | wc -m", "  if [[ $# -eq 0 ]]; then\n    return 1\n  fi\n  echo $1 | grep -o\
    \ . | sort | uniq | wc -l", "  echo $1 | tr '[:upper:]' '[:lower:]' | fold -w1\
    \ | sort | uniq | wc -l", "    echo -n \"$1\" | tr -d [:punct:] | tr -d [:space:]\
    \ | tr '[:upper:]' '[:lower:]' | fold -w1 | sort | uniq | wc -l", "  echo $(echo\
    \ $1 | tr '[:upper:]' '[:lower:]' | fold -w1 | sort | uniq | wc -l)", '  echo
    "${1,,}" | grep -o . | sort | uniq | wc -l', '    echo $(fold -w1 <<< "$1" | sort
    -u | wc -l)', '    echo "$1" | tr [:upper:] [:lower:] | fold -w1 | sort | uniq
    | wc -l', "  if [ -z \"$1\" ]; then\n    echo \"usage: count_distinct_characters\
    \ STRING\"\n    return 1\n  fi\n  echo -n \"$1\" | awk '{print tolower($0)}' |\
    \ sed 's/ //g' | sort | uniq | wc -l", '    echo "${1,,}" | fold -w1 | sort |
    uniq | wc -l', '    echo "$1" | fold -w1 | sort -fu | wc -l', "  declare -u input=\"\
    $1\"\n  echo \"${input}\" | fold -w1 | sort | uniq | wc -l", "    echo \"$1\"\
    \ | grep -o '[A-Za-z]' | sort | uniq | wc -l", "    echo \"$1\" | grep -o . |\
    \ tr '[:upper:]' '[:lower:]' | sort | uniq | wc -l", "  echo $(echo $1 | grep\
    \ -o '[A-Za-z]' | sort | uniq | wc -l)", "    local string=\"$1\"\n    for ((\
    \ i=0; i<${#string}; i++ )); do\n        if [[ \"${distinct_characters}\" == *\"\
    ${string:$i:1}\"* ]]; then\n            continue\n        else\n            distinct_characters+=\"\
    ${string:$i:1}\"\n        fi\n    done\n    echo \"${#distinct_characters}\"",
  "  local _STRING=$1\n  local _COUNT=${#_STRING}\n  local _DISTINCT_CHARS=`echo \"\
    ${_STRING}\" | sed 's/\\(.\\)/\\1\\n/g' | sort | uniq -i | wc -l`\n  echo ${_DISTINCT_CHARS}",
  "  echo \"$1\" | tr '[:upper:]' '[:lower:]' | fold -w1 | sort | uniq | wc -l", " \
    \   echo $(count_characters $1 | sed 's/ //g' | tr -d '[:space:]' | sort -u |\
    \ wc -c)", "  echo \"$1\" | tr '[:upper:]' '[:lower:]' | grep -o . | sort | uniq\
    \ | wc -l", "  echo $1 | tr -s ' ' | wc -w", "    echo $1 | sed 's/\\(.\\)/\\\
    1\\n/g' | tr \"[:upper:]\" \"[:lower:]\" | sort | uniq | wc -l", "  local str=$1\n\
    \  echo \"${str,,}\" | grep -o . | sort | uniq | wc -l", "  echo \"$1\" | tr -s\
    \ '[:lower:]' '[:upper:]' | wc -m", "    if [ \"$#\" -ne 1 ]; then\n        echo\
    \ \"Usage: $(basename $0) <string>\" >&2\n        return 1\n    fi\n\n    # NOTE:\
    \ for upper and lower case letters, their ASCII code difference is exactly 32\n\
    \    #       so that 'A' is equivalent to 'a'\n    echo \"$1\" | tr '[:upper:]'\
    \ '[:lower:]' | fold -w1 | sort | uniq | wc -l", "    echo -n $1 | grep -o -i\
    \ -E '[[:alpha:]]' | sort | uniq | wc -l"]
stop_tokens:
- "\n}"
