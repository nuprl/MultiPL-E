name: HumanEval_161_solve
language: sh
prompt: "#!/bin/bash\n# You are given a string s.\n# if s[i] is a letter, reverse\
  \ its case from lower to upper or vise versa, \n# otherwise keep it as it is.\n\
  # If the string contains no letters, reverse the string.\n# The function should\
  \ return the resulted string.\n# Examples\n# >>> $(solve \"1234\")\n# \"4321\"\n\
  # >>> $(solve \"ab\")\n# \"AB\"\n# >>> $(solve \"#a@C\")\n# \"#A@c\"\n#\n# $1 is\
  \ a string\nsolve() {\n"
tests: "}\n\ncandidate() {\n    solve \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
  \ \"AsDf\") = \"aSdF\" ]]\n    [[ $(candidate \"1234\") = \"4321\" ]]\n    [[ $(candidate\
  \ \"ab\") = \"AB\" ]]\n    [[ $(candidate \"#a@C\") = \"#A@c\" ]]\n    [[ $(candidate\
  \ \"#AsdfW^45\") = \"#aSDFw^45\" ]]\n    [[ $(candidate \"#6@2\") = \"2@6#\" ]]\n\
  \    [[ $(candidate \"#\\$a^D\") = \"#\\$A^d\" ]]\n    [[ $(candidate \"#ccc\")\
  \ = \"#CCC\" ]]\n}\n\nrun_test"
completions: ["    local -a l=()\n    local -a u=()\n    local -a r=()\n    for ((i=0;\
    \ i<${#1}; i++)); do\n        [[ \"${1:$i:1}\" =~ [a-z] ]] && l+=(\"${1:$i:1}\"\
    )\n        [[ \"${1:$i:1}\" =~ [A-Z] ]] && u+=(\"${1:$i:1}\")\n        [[ \"${1:$i:1}\"\
    \ =~ [^a-zA-Z] ]] && r+=(\"${1:$i:1}\")\n    done\n    [[ \"${#l[@]}\" -gt 0 ]]\
    \ && l=(\"${l[@]}\" \"${l[@]}\" \"${l[@]}\")\n    [[ \"${#u[@]}\" -gt 0 ]] &&\
    \ u=(\"${u[@]}\" \"${u[@]}\" \"${u[@]}\")\n    [[ \"${#r[@]}\" -gt 0 ]] && r=(\"\
    ${r[@]}\" \"${r[@]}\" \"${r[@]}\")\n    local -a t=(\"${l[@]}\" \"${u[@]}\" \"\
    ${r[@]}\")\n    for ((i=0; i<${#1}; i++)); do\n        [[ \"${1:$i:1}\" =~ [a-z]\
    \ ]] &&\n            echo -n \"${t[$((3*(i+1)))]}\"\n        [[ \"${1:$i:1}\"\
    \ =~ [A-Z] ]] &&\n            echo -n \"${t[$((3*(i+1)))]}\"\n        [[ \"${1:$i:1}\"\
    \ =~ [^a-zA-Z] ]] &&\n            echo -n \"${t[$((3*(i+1)))]}\"\n    done\n \
    \   echo", "    STR=\"$1\"\n    if [[ -z $(sed -e 's/[^[:alpha:]]//g' <<< $STR)\
    \ ]]; then\n        echo \"$STR\" | rev\n    else\n        echo \"$STR\" | sed\
    \ -e 's/\\([[:alpha:]]\\)/\\L\\1/g' \\\n            -e 's/\\([[:alpha:]]\\)/\\\
    L\\1/g' \\\n            -e 's/\\([[:lower:]]\\)/\\U\\1/g' \\\n            -e 's/\\\
    ([[:upper:]]\\)/\\L\\1/g'\n    fi", "    # Write your code here\n    # To print\
    \ results to the standard output you can use echo\n    # Example: echo \"Hello\
    \ world\"\n    echo $1 | tr \"[:lower:]\" \"[:upper:]\" | rev", "  echo $1 | tr\
    \ -d '0-9' | rev", "  # write your code here\n  echo -e \"$1\"", "  local len=$(echo\
    \ $1 | wc -c)\n  local str=\"\"\n  for (( i=1; i<$len; i++ )); do\n    local ch=$(echo\
    \ $1 | cut -c $i)\n    if [ $ch == \"a\" ] || [ $ch == \"b\" ] || [ $ch == \"\
    c\" ] || [ $ch == \"d\" ] ||\n       [ $ch == \"e\" ] || [ $ch == \"f\" ] || [\
    \ $ch == \"g\" ] || [ $ch == \"h\" ] ||\n       [ $ch == \"i\" ] || [ $ch == \"\
    j\" ] || [ $ch == \"k\" ] || [ $ch == \"l\" ] ||\n       [ $ch == \"m\" ] || [\
    \ $ch == \"n\" ] || [ $ch == \"o\" ] || [ $ch == \"p\" ] ||\n       [ $ch == \"\
    q\" ] || [ $ch == \"r\" ] || [ $ch == \"s\" ] || [ $ch == \"t\" ] ||\n       [\
    \ $ch == \"u\" ] || [ $ch == \"v\" ] || [ $ch == \"w\" ] || [ $ch == \"x\" ] ||\n\
    \       [ $ch == \"y\" ] || [ $ch == \"z\" ]; then\n      str=\"$str$(echo $ch\
    \ | tr '[:lower:]' '[:upper:]')\"\n    elif [ $ch == \"A\" ] || [ $ch == \"B\"\
    \ ] || [ $ch == \"C\" ] || [ $ch == \"D\" ] ||\n         [ $ch == \"E\" ] || [\
    \ $ch == \"F\" ] || [ $ch == \"G\" ] || [ $ch == \"H\" ] ||\n         [ $ch ==\
    \ \"I\" ] || [ $ch == \"J\" ] || [ $ch == \"K\" ] || [ $ch == \"L\" ] ||\n   \
    \      [ $ch == \"M\" ] || [ $ch == \"N\" ] || [ $ch == \"O\" ] || [ $ch == \"\
    P\" ] ||\n         [ $ch == \"Q\" ] || [ $ch == \"R\" ] || [ $ch == \"S\" ] ||\
    \ [ $ch", "  s=\"$1\"\n  # Check if the string has a letter.\n  if [[ $s =~ [a-zA-Z]\
    \ ]]; then\n    # Change its case from lower to upper or vise versa\n    echo\
    \ \"$s\" | tr '[:upper:]' '[:lower:]' | tr '[:lower:]' '[:upper:]'\n  else\n \
    \   # Otherwise reverse the string.\n    echo \"$s\" | rev\n  fi", "  local rev\n\
    \  rev=$(tr -cd \"a-z\" <<< \"$1\" | rev)\n  local res=''\n  local i\n  local\
    \ chr\n  local ind\n  for ((i=0; i<${#1}; i++)); do\n    chr=${1:i:1}\n    [[\
    \ $chr =~ [a-z] ]] && {\n      ind=$((${#rev} - ${#res} - 1))\n      chr=${rev:ind:1}\n\
    \    }\n    [[ $chr =~ [A-Z] ]] && chr=$(tr '[:upper:]' '[:lower:]' <<< \"$chr\"\
    )\n    res=\"$res$chr\"\n  done\n  echo \"$res\"", "    [[ $1 =~ [a-zA-Z] ]] &&\
    \ echo \"${1//[a-z]/{}\" | tr \"[A-Z]\" \"[a-z]\" | tr \"{}\" \"[A-Z]\"\n    echo\
    \ $1 | rev", "    if ! [[ $1 =~ [a-zA-Z] ]]; then\n        # No letters in the\
    \ string, reverse the whole string\n        echo $1 | rev\n    else\n        #\
    \ Reverses the case of letters only\n        echo $1 | tr '[a-z]' '[A-Z]' | tr\
    \ '[A-Z]' '[a-z]'\n    fi", "    string=$1\n    count=0\n    for i in $(seq 1\
    \ ${#string}); do\n        char=${string:i-1:1}\n        if [[ $char =~ ^[a-zA-Z]\
    \ ]]; then\n            count=$((count+1))\n        fi\n    done\n    if [ $count\
    \ -gt 0 ]; then\n        echo $(echo \"$1\" | tr '[:upper:]' '[:lower:]' | tr\
    \ '[:lower:]' '[:upper:]')\n    else\n        echo $(echo \"$1\" | rev)\n    fi",
  "    if [[ $1 =~ [a-zA-Z] ]]; then\n        tr [:upper:] [:lower:] <<< \"$1\" |\
    \ tr [:lower:] [:upper:]\n    else\n        rev <<< \"$1\"\n    fi", "    len=${#1}\n\
    \    res=\"\"\n    for (( i=0; i<$len; i++ )); do\n        c=${1:$i:1}\n     \
    \   if [[ $c =~ [a-zA-Z] ]]; then\n            if [[ $c =~ [a-z] ]]; then\n  \
    \              c=${c^^}\n            else\n                c=${c,,}\n        \
    \    fi\n        fi\n        res=$res$c\n    done\n    echo $res", "  printf '%s\\\
    n' \"$1\" | tr '[:upper:]' '[:lower:]' | tr '[:lower:]' '[:upper:]' | tr -d '[:digit:]'\
    \ | rev", "\tif [[ -z $1 ]]; then\n\t\techo ''\n\telse\n\t\tif [[ $1 =~ [A-Za-z]\
    \ ]]; then\n\t\t\techo $1 | tr \"[:upper:]\" \"[:lower:]\" | tr \"[:lower:]\"\
    \ \"[:upper:]\"\n\t\telse\n\t\t\trev <<< \"$1\"\n\t\tfi\n\tfi", "    # your code\
    \ here\n    local out=\"\"\n    local letter=\"\"\n    local char=\"\"\n    local\
    \ start=1\n    local end=\"${#1}\"\n    while (( $start <= $end )); do\n     \
    \   char=\"${1:start-1:1}\"\n        if [[ \"$char\" =~ [a-zA-Z] ]]; then\n  \
    \          letter=\"$( tr '[:lower:]' '[:upper:]' <<< \"$char\" )\"\n        \
    \    if [[ \"$letter\" == \"$char\" ]]; then\n                out+=\"$( tr '[:upper:]'\
    \ '[:lower:]' <<< \"$char\" )\"\n            else\n                out+=\"$letter\"\
    \n            fi\n        else\n            out+=\"$char\"\n        fi\n     \
    \   ((start++))\n    done\n    echo \"$out\"", "  [[ $1 =~ [a-zA-Z] ]] || echo\
    \ -n \"${1//./}\"\n  echo -n \"${1//[^a-zA-Z]/.}\" | tr '[:lower:]' '[:upper:]'\
    \ | tr '[:upper:]' '[:lower:]'", "  [[ $1 =~ [a-zA-Z] ]] && tr '[:upper:]' '[:lower:]'\
    \ <<< $1 || rev <<< $1", "  # write your code here\n  local l=\"\"\n  local ch=\"\
    \"\n  #local re=\"\"\n  for (( i=0; i<${#1}; i++ )); do\n    ch=${1:$i:1}\n  \
    \  if [[ \"$ch\" =~ [a-zA-Z] ]]; then\n      if [[ \"$ch\" =~ [a-z] ]]; then\n\
    \        l=$l$(echo $ch | tr 'a-z' 'A-Z')\n      else\n        l=$l$(echo $ch\
    \ | tr 'A-Z' 'a-z')\n      fi\n    else\n      l=$l$ch\n    fi\n  done\n  echo\
    \ $l", "    echo $1 | grep -q '[a-zA-Z]'\n    if [ $? -eq 0 ]; then\n        echo\
    \ $1 | tr '[:upper:]' '[:lower:]' | tr '[:lower:]' '[:upper:]'\n    else\n   \
    \     echo $1 | rev\n    fi", "  local s=$1\n  local p\n  if [ -z $(egrep \"[a-zA-Z]\"\
    \ <<< \"$s\") ]; then\n    p=$(rev <<< \"$s\")\n  else\n    p=$(egrep -o \"[a-zA-Z]\"\
    \ <<< \"$s\" | tr 'a-zA-Z' 'A-Za-z' | rev)\n    s=$(egrep -o \"[^a-zA-Z]\" <<<\
    \ \"$s\")\n    p=$(paste -d '' <(rev <<< \"$p\") <(rev <<< \"$s\"))\n  fi\n  echo\
    \ \"$p\"", "    echo \"$1\" | sed 's/\\([a-z]\\)/\\U\\1/g' | sed 's/\\([A-Z]\\\
    )/\\L\\1/g' | rev", "  local letters=$(echo $1 | tr -dc [:alpha:])\n  local reversed_letters=$(echo\
    \ $letters | rev)\n  local c=0\n\n  if [ -z \"$letters\" ]; then\n    echo $1\
    \ | rev\n  else\n    for (( i=0; i<${#1}; i++ )); do\n      if [[ ${1:$i:1} =~\
    \ [:alpha:] ]]; then\n        printf \"%s\" \"${reversed_letters:$c:1}\"\n   \
    \     c=$((c+1))\n      else\n        printf \"%s\" \"${1:$i:1}\"\n      fi\n\
    \    done\n  fi", "    if [ -z $(echo $1 | grep -E '[a-zA-Z]') ]; then\n     \
    \   echo $(echo $1 | rev)\n    else\n        echo $(echo $1 | tr a-zA-Z n-za-mN-ZA-M)\n\
    \    fi", "  # Write your code here\n  # To print results to the standard output\
    \ you can use echo\n  # Example: echo \"Hello world\"", "    awk '\n    {\n  \
    \      # For each letter\n        gsub(/[a-zA-Z]/,\n            # if it is lower\
    \ case, transform it to upper case\n            # otherwise, if it is upper case,\
    \ transform it to lower case\n            # otherwise, keep it as it is.\n   \
    \         function (c) {\n                if(c ~ /[a-z]/) { return toupper(c)\
    \ }\n                else if(c ~ /[A-Z]/) { return tolower(c) }\n            \
    \    else { return c }\n            }\n        )\n        # If the string contains\
    \ no letters, reverse the string.\n        if(!match($0, /[a-zA-Z]/)) {\n    \
    \        printf(rev($0))\n        }\n        else {\n            printf($0)\n\
    \        }\n    }\n    ' <<< \"$1\"", "\tlocal -i i x=0\n\tlocal len=${#1}\n\t\
    local res\n\tres=$(echo $1 | sed 's/[a-z]/\\u&/g;s/[A-Z]/\\l&/g')\n\techo $res",
  "  local s=\"\"\n  local c=\"\"\n  local a=\"\"\n  local l=\"\"\n  local rs=\"\"\
    \n  local i=\"\"\n  s=$1\n  l=${#s}\n  rs=\"\"\n  for ((i=l-1; i>=0; i--)); do\n\
    \    c=${s:$i:1}\n    a=$(echo $c | tr '[:upper:]' '[:lower:]')\n    if [ \"$c\"\
    \ != \"$a\" ]; then\n      rs=\"$rs$a\"\n    else\n      a=$(echo $c | tr '[:lower:]'\
    \ '[:upper:]')\n      if [ \"$c\" != \"$a\" ]; then\n        rs=\"$rs$a\"\n  \
    \    else\n        rs=\"$rs$c\"\n      fi\n    fi\n  done\n  echo $rs", "  if\
    \ [[ \"$1\" =~ [A-Za-z] ]]; then\n    tr '[:upper:]' '[:lower:]' <<< \"$1\" |\
    \ tr '[:lower:]' '[:upper:]'\n  else\n    tr '[:digit:]' '[:digit:]' <<< \"$1\"\
    \ | tr '[:digit:]' '[:digit:]'\n  fi", "  if [[ ! $1 =~ [a-zA-Z] ]]; then\n  \
    \  rev <<< $1\n  else\n    echo $1 | tr 'A-Za-z' 'a-zA-Z'\n  fi", "    local string=$1\n\
    \    local local s=${string//[^a-zA-Z]/}\n    if [[ -z $s ]]; then\n        echo\
    \ $string | rev\n    else\n        echo $string | tr 'A-Za-z' 'a-zA-Z'\n    fi",
  "    re='^[0-9]+$'\n    if [[ $1 =~ $re ]] ; then\n        echo $1 | rev\n    else\n\
    \        echo \"$1\" | tr '[:upper:]' '[:lower:]' | tr -d '[0-9]' | rev\n    fi",
  "  local res=$(printf \"$1\" | tr 'a-zA-Z' 'A-Za-z')\n  [ -z \"$res\" ] && res=$(printf\
    \ \"$1\" | rev)\n  echo \"$res\"", "    local t=0\n    while [ $t -lt ${#1} ];\
    \ do\n        if [[ ${1:$t:1} =~ [a-zA-Z] ]]; then\n            # The char is\
    \ a letter, so reverse its case\n            [ $(echo ${1:$t:1} | tr A-Z a-z)\
    \ = ${1:$t:1} ] && 1=${1:$t:1} | tr a-z A-Z\n        else\n            # The char\
    \ is not a letter, keep it as it is\n            1=${1:$t:1}\n        fi\n   \
    \     echo -n \"$1\"\n        t=$((t+1))\n    done\n    echo", "    local str=\"\
    $1\"\n    if [[ ! \"$str\" =~ [a-zA-Z] ]]; then \n        echo \"${str//./}\"\n\
    \    else\n        printf '%s\\n' \"${str^^}\" | tr '[:upper:]' '[:lower:]'\n\
    \    fi", "    s=$1\n    [[ \"$s\" == \"\" ]] && return\n    # check if s has\
    \ no letters\n    [[ $s =~ [a-zA-Z] ]] || { echo \"$s\" | rev; return; }\n   \
    \ # flip case of all the letters\n    out=\"\"\n    for (( i=0; i<${#s}; i++ ));\
    \ do\n        c=${s:$i:1}\n        out+=$( [ \"$c\" = \"${c,,}\" ] && echo \"\
    ${c^^}\" || echo \"${c,,}\" )\n    done\n    echo \"$out\"", "    local -a c i=1\n\
    \    for c in $(echo $1 | fold -w1); do\n        if [[ $c =~ ^[a-zA-Z]$ ]]; then\n\
    \            c=\"$(echo $c | tr '[:lower:]' '[:upper:]')\"\n        fi\n     \
    \   echo -n \"$c\"\n    done\n    echo", "    if [[ $1 =~ [a-zA-Z] ]]; then\n\
    \        echo \"${1,,}\" | tr '[:lower:]' '[:upper:]'\n    else\n        rev <<<\
    \ \"$1\"\n    fi", "    local string=${1}\n    local result=\"\"\n    local i=0\n\
    \    for (( i=0; i<${#string}; i++ )); do\n        local char=${string:$i:1}\n\
    \        if [[ $char =~ [a-zA-Z] ]]; then\n            if [[ $char =~ [a-z] ]];\
    \ then\n                char=$(echo $char | tr a-z A-Z)\n            else\n  \
    \              char=$(echo $char | tr A-Z a-z)\n            fi\n        fi\n \
    \       result=\"$result$char\"\n    done\n    echo $result", "    # write your\
    \ solution here\n    if [ -z \"$1\" ]; then\n        echo \"\"\n    else\n   \
    \     arr=($(echo \"$1\" | grep -o .))\n        ans=''\n        for i in ${arr[@]};\
    \ do\n            if [[ $i =~ [a-zA-Z] ]]; then\n                ans+=$(echo \"\
    $i\" | tr [a-z] [A-Z])\n            else\n                ans+=$i\n          \
    \  fi\n        done\n        echo \"$ans\"\n    fi", "  local s=\"\"\n  for ((i=0;\
    \ i<${#1}; i++)); do\n    c=${1:i:1}\n    if [[ \"$c\" =~ [a-zA-Z] ]]; then\n\
    \      s=$s$(echo $c | tr [a-z] [A-Z])\n    else\n      s=$s$c\n    fi\n  done\n\
    \  echo $s", "  local s=''\n  for ((i=0; i<${#1}; i++)); do\n    local char=${1:i:1}\n\
    \    if [[ $char =~ [a-zA-Z] ]]; then\n      s+=$(tr '[:lower:]' '[:upper:]' <<<\
    \ $char)\n    else\n      s+=$char\n    fi\n  done\n  echo ${s:-$1} | rev", " \
    \   echo \"$1\" |\n    sed 's/[a-z]/\\U&/g;s/[A-Z]/\\L&/g;' |\n    if [[ ! $1\
    \ =~ [[:alpha:]] ]]; then\n        rev\n    fi", "    s=`echo $1 | sed 's/./&\\\
    n/g' | grep \"[a-zA-Z]\" | tr \"[:upper:]\" \"[:lower:]\" | tr -d \"[:lower:]\"\
    \ | sed 's/./\\u&/g' | tr -d \"[:upper:]\"`\n    echo $1 | sed \"s/[a-zA-Z]/$s/g\"",
  "  for((i=0;i<${#1};i++)); do\n    if [[ ${1:$i:1} =~ [a-zA-Z] ]]; then\n      s+=\"\
    ${1:$i:1}\";\n    else\n      if [[ ${1:$i:1} =~ [a-z] ]]; then\n        s+=\"\
    ${1:$i:1^^}\";\n      else\n        s+=\"${1:$i:1,,}\";\n      fi\n    fi\n  done\n\
    \  echo ${s:-$1};", "  if [[ ! $1 =~ [a-zA-Z] ]]; then\n    echo \"$1\" | rev\n\
    \  else\n    echo \"$1\" | sed 's/\\([A-Z]\\)/\\L\\1/g; s/\\([a-z]\\)/\\U\\1/g'\n\
    \  fi", "    (\n        set -f\n        while read -r -n1 char; do\n         \
    \   if [[ $char =~ [a-zA-Z] ]]; then\n                echo -n \"${char^}\"\n \
    \           else\n                echo -n \"$char\"\n            fi\n        done\n\
    \    ) <<< $1 | rev", "    var=$1\n    local s=\"\"\n    if [[ \"$var\" =~ [[:alpha:]]\
    \ ]]; then\n        for (( i=0; i<${#var}; i++ )); do\n            local c=\"\
    ${var:$i:1}\"\n            if [[ \"$c\" =~ [[:lower:]] ]]; then\n            \
    \    c=$(echo \"$c\" | tr [:lower:] [:upper:])\n            elif [[ \"$c\" =~\
    \ [[:upper:]] ]]; then\n                c=$(echo \"$c\" | tr [:upper:] [:lower:])\n\
    \            fi\n            s=\"$s$c\"\n        done\n    else\n        s=\"\
    $(rev <<< \"$var\")\"\n    fi\n    echo \"$s\"", '    echo "$1" | tr "[:lower:]"
    "[:upper:]" | tr "[:upper:]" "[:lower:]" | tr -d "[0-9]" | rev', "    local input=$1\n\
    \    if [[ \"$input\" =~ [a-zA-Z] ]]; then\n        echo \"$input\" | tr '[:upper:]'\
    \ '[:lower:]' | tr '[:lower:]' '[:upper:]'\n    else\n        echo \"$input\"\
    \ | rev\n    fi", "\tlocal str=\"$1\"\n\t[[ \"$str\" =~ [a-zA-Z] ]] || echo \"\
    $str\" | rev\n\t# if [[ \"$str\" =~ [a-zA-Z] ]]; then\n\t# \techo $str | rev\n\
    \t# else\n\t# \techo \"$str\"\n\t# fi", "  echo $1 | tr '[:upper:]' '[:lower:]'\
    \ | rev | tr '[:lower:]' '[:upper:]'", "  local i=\"\"\n  # Check if string is\
    \ empty, then reverse it\n  [ -z \"$1\" ] && echo \"$1\" | rev && return 0\n \
    \ for ((i=0; i<${#1}; i++)); do\n    if [[ ${1:$i:1} =~ [a-zA-Z] ]]; then\n  \
    \    # If letter, then swap it with tr command\n      echo \"${1:$i:1}\" | tr\
    \ \"[:lower:]\" \"[:upper:]\" | tr \"[:upper:]\" \"[:lower:]\"\n    else\n   \
    \   # Otherwise keep it\n      echo \"${1:$i:1}\"\n    fi\n  done", "    local\
    \ str=$1\n    local has_letter=$(echo $str | grep -i '[a-zA-Z]')\n    if [ ! -z\
    \ \"$has_letter\" ]; then\n        # if there are letters, reverse only letters\n\
    \        echo $(echo $str | tr '[:upper:]' '[:lower:]' | tr '[:lower:]' '[:upper:]')\n\
    \    else\n        # otherwise, reverse whole string\n        echo $(echo $str\
    \ | rev)\n    fi", "  echo $1 | tr '[:upper:]' '[:lower:]' | tr '[:lower:]' '[:upper:]'",
  "    local str=\"$1\"\n    if [[ $str =~ [[:alpha:]] ]]; then\n        echo \"${str}\"\
    \ | tr [:lower:] [:upper:] | tr [:upper:] [:lower:]\n    else\n        echo \"\
    ${str}\" | rev\n    fi", '    # write your code', "  # if it is empty\n  if [\
    \ -z \"$1\" ]; then\n    # reverse the string and print to stdout\n    echo $(rev\
    \ <<< \"$1\")\n  else\n    # reverse and print the string, skipping non alpha\
    \ characters\n    echo $(rev <<< \"$1\" | tr -cd \"[:alpha:]\")\n  fi", "    local\
    \ -u string=\"$1\"\n    local alphabet='ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    echo\
    \ \"${string//[^$alphabet]/}\" | tr \"$alphabet\" \"${alphabet,,}\"", "    [ -z\
    \ \"$1\" ] && return 0\n    [ -z \"$(echo \"$1\" | tr -d '[:digit:]')\" ] && echo\
    \ \"$1\" | tr -d '[:digit:]' | rev\n    echo \"$1\" | sed 's/./\\l&/;s/./\\u&/;s/./\\\
    l&/'", "    local out str result\n    str=$1\n    if [[ ! ${str} =~ [a-zA-Z] ]];\
    \ then\n        result=$(printf \"%s\" \"${str}\" | rev)\n    else\n        out=''\n\
    \        for (( i=0; i<${#str}; i++ )); do\n            if [[ ${str:$i:1} =~ [a-z]\
    \ ]]; then\n                out+=\"${str:$i:1^^}\"\n            elif [[ ${str:$i:1}\
    \ =~ [A-Z] ]]; then\n                out+=\"${str:$i:1,,}\"\n            else\n\
    \                out+=\"${str:$i:1}\"\n            fi\n        done\n        result=${out}\n\
    \    fi\n    printf \"%s\" \"${result}\"", "    printf '%s\\n' \"$1\" |\n    tr\
    \ [:lower:] [:upper:] |\n    tr [:upper:] [:lower:] |\n    rev", "    # your code\
    \ here\n    return $?", "    local str=\"$1\"\n    local len=${#str}\n    local\
    \ out=\"\"\n    local i=0\n    while [ $i -lt $len ]; do\n        local char=\"\
    ${str:$i:1}\"\n        if [[ $char =~ [a-zA-Z] ]]; then\n            out+=\"${char^^}\"\
    \n        else\n            out+=\"$char\"\n        fi\n        ((i++))\n    done\n\
    \    echo \"$out\"", "    for ((i=0; i<${#1}; i++)); do\n        ch=${1:$i:1}\n\
    \        (( ${ch/[a-z]/} )) && ch=${ch^^} || ch=${ch,,}\n        res+=${ch}\n\
    \    done\n    echo $res", "  local s=${1,,}\n  local r=\n  for((i=0;i<${#s};i++));\
    \ do\n    #echo $i ${s:$i:1} ${s:$i:1} | grep -qE \"[a-z]\"\n    #echo $i ${s:$i:1}\
    \ ${s:$i:1} | grep -qE \"[^[:alpha:]]\"\n    if [[ \"${s:$i:1}\" =~ [a-z] ]];\
    \ then\n      r=\"${r}${s:$i:1^}\"\n    else\n      r=\"${r}${s:$i:1}\"\n    fi\n\
    \  done\n  echo $r", "  echo \"$1\" | rev | tr 'A-Za-z' 'a-zA-Z'", "    if [[\
    \ ! $1 =~ [a-zA-Z] ]]; then\n        echo $1 | rev\n    else\n        echo $1\
    \ | tr '[:upper:]' '[:lower:]' | tr '[:lower:]' '[:upper:]'\n    fi", "\t# TODO:\
    \ The script should solve the problem\n\t# If there is no letter, reverse it\n\
    \tif [[ \"$1\" =~ [a-zA-Z] ]]; then\n\t\techo \"$1\" | tr [a-zA-Z] [A-Za-z]\n\t\
    else\n\t\techo \"$1\" | rev\n\tfi", "  local -i len\n  local -i i\n  local new_s\n\
    \  local char\n  len=${#1}\n  for ((i=0; i<len; i++)); do\n    char=${1:i:1}\n\
    \    case $char in\n      [a-z]) new_s+=\"${char^^}\";;\n      [A-Z]) new_s+=\"\
    ${char,,}\";;\n      *) new_s+=\"$char\";;\n    esac\n  done\n  if [[ ! \"$new_s\"\
    \ =~ [a-zA-Z] ]]; then\n    echo \"${new_s::-1}\" | rev\n  else\n    echo \"$new_s\"\
    \n  fi", "  local str=${1//[^[:alpha:]]/}\n  if [[ -z $str ]]; then\n    echo\
    \ $1 | rev\n  else\n    echo $1 | tr 'a-zA-Z' 'A-Za-z'\n  fi", "\tlocal str=${1,,}\n\
    \tlocal rev=`echo $str | rev`\n\tif [[ $str == $rev ]]; then\n\t\techo $str |\
    \ tr '[:lower:]' '[:upper:]'\n\telse\n\t\techo $str | tr '[:upper:]' '[:lower:]'\n\
    \tfi", "  # echo $(echo $1 | tr -s \"[a-zA-Z]\" \"[A-Za-z]\")\n  # or\n  local\
    \ IFS=\n  echo $1 | tr -s '[:lower:]' '[:upper:]' | tr -s '[:upper:]' '[:lower:]'",
  "  if [[ $1 =~ [a-zA-Z] ]]; then\n    echo ${1//[a-z]/\\U&} | tr '[A-Z]' '[a-z]'\n\
    \  else\n    echo ${1//./-}\n  fi", "    perl -lpe's/[a-z]/\\U$&/g;s/[A-Z]/\\\
    L$&/g;y/0-9/1234567890/;y/1234567890/0123456789/' <<< \"$1\"", "    case $1 in\n\
    \        # if string have no letters\n        *[![:alpha:]]*) echo $1 | rev ;;\n\
    \        # if string have letters\n        *) echo $1 | tr '[:upper:]' '[:lower:]'\
    \ | tr '[:lower:]' '[:upper:]' ;;\n    esac", "\tif [[ $1 =~ [a-zA-Z] ]]; then\n\
    \t\techo $1 | tr -s '[:lower:]' '[:upper:]' | tr -s '[:upper:]' '[:lower:]'\n\t\
    else\n\t\techo \"$1\" | rev\n\tfi", "    local ret=\"\"\n    local letter=\"\"\
    \n    for ((i=0; i<${#1}; i++)); do\n        letter=${1:$i:1}\n        # Using\
    \ regular expression to check if is a letter\n        # [:alpha:] also works but\
    \ not portable\n        if [[ $letter =~ [a-zA-Z] ]]; then\n            # Using\
    \ awk to convert lower to upper case\n            if [[ $letter =~ [a-z] ]]; then\n\
    \                ret=$ret$(echo $letter | awk '{print toupper($0)}')\n       \
    \     else\n                ret=$ret$(echo $letter | awk '{print tolower($0)}')\n\
    \            fi\n        else\n            ret=$ret$letter\n        fi\n    done\n\
    \    echo $ret", "    if [[ ! -z $(echo $1 | tr -d ' ' | grep -E '[a-zA-Z]') ]];\
    \ then\n        echo $(echo $1 | tr \"[:upper:]\" \"[:lower:]\" | tr \"[:lower:]\"\
    \ \"[:upper:]\")\n    else\n        echo $(echo $1 | rev)\n    fi", "    for ((i=0;\
    \ i<${#1}; i++)); do\n        [[ ${1:$i:1} =~ [a-z] ]] && echo -n \"${1:$i:1^^}\"\
    \ || echo -n \"${1:$i:1,,}\"\n    done\n    echo", "  local str=\"\"\n  for ((\
    \ i=0; i<${#1}; i++ )); do\n    if [[ ${1:$i:1} =~ [a-zA-Z] ]]; then\n      str+=\"\
    ${1:$i:1}\"\n    else\n      str+=${1:$i:1}\n    fi\n  done\n  if [[ $str =~ [a-zA-Z]\
    \ ]]; then\n    echo \"${str,,}\" | tr '[:lower:]' '[:upper:]'\n  else\n    echo\
    \ \"${1}\" | rev\n  fi", "    local str=$1\n    local i str2\n    str2=\n    for\
    \ ((i=0; i<${#str}; i++)); do\n        case ${str:$i:1} in\n            [[:lower:]])\
    \ str2+=${str:$i:1^} ;;\n            [[:upper:]]) str2+=${str:$i:1,} ;;\n    \
    \        *) str2+=${str:$i:1} ;;\n        esac\n    done\n    echo \"$str2\"",
  '    # Write here your code...', "  s=\"$1\"\n  for ((i=0; i<${#s}; i++)); do\n\
    \    if [[ ${s:$i:1} =~ [a-zA-Z] ]]; then\n      if [[ ${s:$i:1} =~ [a-z] ]];\
    \ then\n        s=\"${s:0:$i}$(echo ${s:$i:1} | tr [a-z] [A-Z])${s:$((i+1))}\"\
    \n      else\n        s=\"${s:0:$i}$(echo ${s:$i:1} | tr [A-Z] [a-z])${s:$((i+1))}\"\
    \n      fi\n    fi\n  done\n  echo \"$s\"", "  str=${1}\n  str=$(tr '[:upper:]'\
    \ '[:lower:]' <<< \"${str}\")\n  str=$(tr '[:lower:]' '[:upper:]' <<< \"${str}\"\
    )\n  rev <<< ${str}", "\ts=$1\n\tletters=${s//[^a-zA-Z]/}\n\t# if the string contains\
    \ no letters, reverse the string.\n\tif [ ${#letters} == 0 ]; then\n\t\techo \"\
    $s\" | rev\n\telse\n\t\t# reverse case\n\t\techo \"$s\" | tr '[:upper:]' '[:lower:]'\
    \ | tr '[:lower:]' '[:upper:]'\n\tfi", "  echo $1 | tr -s '[:upper:]' '[:lower:]'\
    \ | tr '[:lower:]' '[:upper:]'", "  if [ \"${1//[a-zA-Z]/}\" != \"$1\" ]; then\n\
    \    echo \"$1\" | tr [:upper:] [:lower:] | tr [:lower:] [:upper:]\n  else\n \
    \   echo \"$1\" | rev\n  fi", "    if [ -z \"$(tr -d '[:digit:]' <<<\"$1\")\"\
    \ ]; then\n        echo \"$1\" | rev\n    else\n        echo \"$1\" | tr '[:upper:]'\
    \ '[:lower:]' | tr '[:lower:]' '[:upper:]'\n    fi", "\tlocal string=$1\n\tlocal\
    \ string_len=${#string}\n\tlocal string_new=\"\"\n\tfor ((i=0; i<$string_len;\
    \ i++)); do\n\t\tlocal char=${string:$i:1}\n\t\tlocal char_encoded=$(echo $char\
    \ | tr '[a-z]' '[A-Z]')\n\t\tif [[ $char_encoded == $char ]]; then\n\t\t\tchar_encoded=$(echo\
    \ $char | tr '[A-Z]' '[a-z]')\n\t\tfi\n\t\tstring_new+=$char_encoded\n\tdone\n\
    \techo $string_new", "    # Complete the function\n    str=$1\n    result=''\n\
    \    for (( i=0; i<${#str}; i++ )); do\n        if [[ \"${str:$i:1}\" =~ [a-zA-Z]\
    \ ]]; then\n            (( i%2 )) && result+=\"${str:$i:1}\" || result+=\"${str:$i:1}\"\
    \ | tr a-z A-Z\n        else\n            result+=\"${str:$i:1}\"\n        fi\n\
    \    done\n    echo $result", "    local s i\n    s=\"$1\"\n    i=0\n    while\
    \ (( i < ${#s} )); do\n        if [[ \"${s:$i:1}\" =~ [a-zA-Z] ]]; then\n    \
    \        if [[ \"${s:$i:1}\" =~ [a-z] ]]; then\n                s=\"${s:0:$i}$(echo\
    \ \"${s:$i:1}\" | tr a-z A-Z)${s:$i+1}\"\n            else\n                s=\"\
    ${s:0:$i}$(echo \"${s:$i:1}\" | tr A-Z a-z)${s:$i+1}\"\n            fi\n     \
    \   fi\n        ((i+=1))\n    done\n    [[ \"$s\" =~ [a-zA-Z] ]] && echo \"$s\"\
    \ || echo \"$(echo \"$s\" | rev)\"", "  local len_str=$(expr length \"$1\")\n\
    \  local result=\"\"\n  local i=0\n  local tmp_char\n  for (( i=0; i<len_str;\
    \ i++ ))\n  do\n    tmp_char=$(expr substr \"$1\" \"$((i+1))\" 1)\n    if [[ \"\
    $tmp_char\" =~ [a-zA-Z] ]]\n    then\n      result=$result$(tr \"$tmp_char\" \"\
    [a-z]\" \"[A-Z]\")\n    else\n      result=$result$tmp_char\n    fi\n  done\n\
    \  echo \"$result\"", "\t# base case\n\t[[ $1 == \"\" ]] && echo \"\" && return\
    \ 0\n\t\n\t# the whole string should be reversed,\n\t# if it contains no letter\n\
    \t[[ $1 =~ [a-zA-Z] ]] || {\n\t\tfor ((i=${#1}; i>0; i--)); do\n\t\t\tprintf \"\
    %s\" \"${1:i-1:1}\"\n\t\tdone\n\t\techo\n\t\treturn 0\n\t}\n\n\t# case of a letter\n\
    \tif [[ $1 =~ [a-z] ]]; then\n\t\tprintf \"%s\" \"${1^}\"\n\telse\n\t\tprintf\
    \ \"%s\" \"${1,,}\"\n\tfi\n\n\tsolve \"${1:1}\"", '    # Implemnet the solution',
  "    s=$1\n    [[ -z \"$s\" ]] && return 1\n    if [[ $s =~ [a-zA-Z] ]]; then\n\
    \        echo $s | tr '[:upper:]' '[:lower:]' | tr '[:lower:]' '[:upper:]'\n \
    \   else\n        echo $s | rev\n    fi", "  # Write your code here\n  # To print\
    \ results to the standard output you can use echo\n  # Example: echo \"Hello world\"\
    \n  echo \"Hello world\"", "  local result=\"\"\n  if [[ $1 =~ [[:alpha:]] ]];\
    \ then\n    result=$(echo \"$1\" | tr '[:upper:]' '[:lower:]' | tr '[:lower:]'\
    \ '[:upper:]')\n  else\n    result=$(echo \"$1\" | rev)\n  fi\n  echo \"$result\"",
  "    local x=$1\n    local l=${#x}\n    local i\n    if [[ $l -eq 0 ]]; then\n \
    \       echo ''\n        return\n    fi\n    local z\n    local ch\n    z=''\n\
    \    for ((i=0; i<$l; i++)); do\n        ch=${x:$i:1}\n        if [[ $ch =~ [a-zA-Z]\
    \ ]]; then\n            if [[ $ch =~ [a-z] ]]; then\n                ch=${ch^^}\n\
    \            else\n                ch=${ch,,}\n            fi\n        fi\n  \
    \      z=$z$ch\n    done\n    echo $z", "    if [ -z \"$1\" ]; then\n        echo\
    \ \"\"\n        return\n    fi\n    str=`echo $1 | tr [a-z] [A-Z]`\n    if [ $str\
    \ == $1 ]; then\n        echo $1 | tr [A-Z] [a-z]\n    else\n        echo $str\n\
    \    fi", "    if ! [[ $1 =~ [a-zA-Z] ]]; then\n\techo \"$1\" | rev\n    else\n\
    \tfor (( i=0; i<${#1}; i++ )); do\n\t    if [[ ${1:$i:1} =~ [a-z] ]]; then\n\t\
    \techo -n \"${1:$i:1}\" | tr 'a-z' 'A-Z'\n\t    elif [[ ${1:$i:1} =~ [A-Z] ]];\
    \ then\n\t\techo -n \"${1:$i:1}\" | tr 'A-Z' 'a-z'\n\t    else\n\t\techo -n \"\
    ${1:$i:1}\"\n\t    fi\n\tdone\n\techo\n    fi", "    s=\"$1\"\n    local i=0\n\
    \    local l=${#s}\n    local ans=\"\"\n    local c\n    while [ $i -lt $l ];\
    \ do\n        c=${s:$i:1}\n        if [[ \"$c\" =~ [a-zA-Z] ]]; then\n       \
    \     if [[ \"$c\" =~ [a-z] ]]; then\n                c=${c^^}\n            else\n\
    \                c=${c,,}\n            fi\n        fi\n        ans+=\"$c\"\n \
    \       i=$((i+1))\n    done\n    echo \"$ans\"", "  str=$1\n  newstr=\"\"\n \
    \ for (( i=0; i<${#str}; i++ )); do\n    c=${str:$i:1}\n    if [[ $c =~ [a-zA-Z]\
    \ ]]; then\n      newstr=\"$newstr$(tr '[:upper:]' '[:lower:]' <<< $c)\"\n   \
    \ else\n      newstr=\"$newstr$c\"\n    fi\n  done\n  echo $newstr", "    # write\
    \ your code here\n    s=$1\n    if [[ $s =~ [[:alpha:]] ]]; then\n        echo\
    \ \"$s\" | tr a-zA-Z n-za-mN-ZA-M\n    else\n        echo \"$s\" | rev\n    fi",
  "  (($# == 1)) || exit 1 # check if there is only one argument\n  # s can be empty,\
    \ so check if s has letters first\n  [[ -z $(sed -n \"/[A-Za-z]/p\" <<< \"$1\"\
    ) ]] && sed -r \"s/./&\\n/g\" <<< \"$1\" | tac | tr -d \"\\n\"\n  # if s has letters,\
    \ replace [A-Za-z] with its reversed case, then replace other char to itself\n\
    \  # and replace [] with itself\n  sed -r \"s/[A-Za-z]/\\L\\0/g;s/[A-Za-z]/\\\
    U\\0/g;s/[^A-Za-z]/&/g;s/[]^[]/&/g\" <<< \"$1\"", "  local word=$1\n  local new_word=''\n\
    \  local i=0\n  local alpha\n  alpha=\"a b c d e f g h i j k l m n o p q r s t\
    \ u v w x y z A B C D E F G H I J K L M N O P Q R S T U V W X Y Z\"\n  while [\
    \ $i -lt ${#word} ]; do\n    local j=0\n    local new_char=\"\"\n    local is_alpha=\"\
    \"\n    while [ $j -lt ${#alpha} ]; do\n      if [ \"${word:$i:1}\" == \"${alpha:$j:1}\"\
    \ ]; then\n        if [ \"${word:$i:1}\" == \"${word:$i:1^^}\" ]; then\n     \
    \     new_char=\"${word:$i:1^^}\"\n        else\n          new_char=\"${word:$i:1,,}\"\
    \n        fi\n        is_alpha=\"yes\"\n        break\n      fi\n      j=$((j+1))\n\
    \    done\n    if [ \"$is_alpha\" == \"yes\" ]; then\n      new_word+=\"$new_char\"\
    \n    else\n      new_word+=\"${word:$i:1}\"\n    fi\n    i=$((i+1))\n  done\n\
    \  if [ \"${new_word:0:1}\" == \"${new_word:0:1^^}\" ]; then\n    echo $new_word\
    \ | rev\n  else\n    echo $new_word\n  fi", "    local s=$1\n    s=$(echo \"$s\"\
    \ | sed 's/[A-Z]/\\L&/g;s/[a-z]/\\U&/g')\n    echo \"$s\"", "  if [[ -z $1 ]];\
    \ then\n    return\n  fi\n  local ans\n  local c\n  ans=\n  for (( i=0; i<${#1};\
    \ i++ )); do\n    c=${1:i:1}\n    if [[ $c =~ [a-zA-Z] ]]; then\n      if [[ $c\
    \ =~ [a-z] ]]; then\n        ans+=$(echo $c | tr 'a-z' 'A-Z')\n      else\n  \
    \      ans+=$(echo $c | tr 'A-Z' 'a-z')\n      fi\n    else\n      ans+=$c\n \
    \   fi\n  done\n  echo $ans", "\ts=\"$1\"\n\tl=$(echo \"$s\" | grep -i '[a-z]'\
    \ | wc -c)\n\tif [ $l -eq 0 ]; then\n\t\techo \"$s\" | rev\n\telse\n\t\techo \"\
    $s\" | tr \"[:lower:]\" \"[:upper:]\" | tr \"[:upper:]\" \"[:lower:]\"\n\tfi",
  "    echo $1 | tr -s '[:alnum:]' '\\n' | tr '[:lower:]' '[:upper:]' | rev | tr -d\
    \ '\\n'", "  echo $1 | tr -c '[:alnum:]' 'A-Za-z' | rev", "\t# TODO:\n\techo \"\
    \"", "  echo $1 | tr '[:lower:]' '[:upper:]' | tr '[:upper:]' '[:lower:]'", " \
    \   local s=\"$1\"\n    # the main logic here!", "  echo $1 | tr '[:lower:]' '[:upper:]'\
    \ | tr '[:upper:]' '[:lower:]'", "\tlocal -i res=0\n\tfor i in `seq 0 $((${#1}-1))`;\
    \ do\n\t\tif [[ \"${1:$i:1}\" =~ [a-zA-Z] ]]; then\n\t\t\tres=1\n\t\t\tbreak\n\
    \t\tfi\n\tdone\n\tif [[ res -eq 0 ]]; then\n\t\treversed=`echo $1 | rev`\n\t\t\
    echo $reversed\n\telse\n\t\ttr '[a-z]' '[A-Z]' <<< \"$1\" | tr '[A-Z]' '[a-z]'\n\
    \tfi", "    # first check if the string is empty\n    if [ -z \"$1\" ]; then\n\
    \        echo \"The string is empty!\"\n        exit 1\n    fi\n    # initialize\
    \ a reverse string\n    reverse=\"\"\n    # iterate over the string\n    for ((\
    \ i=${#1}; i>0; i-- )); do\n        # get the first character\n        char=${1:i-1:1}\n\
    \        # convert the first character to a number\n        num=$(printf \"%d\"\
    \ \"'$char\")\n        # check if the first character is a letter\n        if\
    \ [ $num -ge 97 ] && [ $num -le 122 ]; then\n            # change the case from\
    \ lower to upper\n            char=$(printf \\\\$(printf \"%03o\" $((num-32))))\n\
    \        elif [ $num -ge 65 ] && [ $num -le 90 ]; then\n            # change the\
    \ case from upper to lower\n            char=$(printf \\\\$(printf \"%03o\" $((num+32))))\n\
    \        fi\n        # append the reversed character to the result\n        reverse=$reverse$char\n\
    \    done\n    # echo the result\n    echo $reverse", "    echo $1 | tr '[a-zA-Z]'\
    \ '[A-Za-z]'", "    res=$(echo \"$1\" | tr -s \"[:upper:]\" \"[:lower:]\" | tr\
    \ -s \"[:lower:]\" \"[:upper:]\")\n    [[ \"$res\" =~ ^[[:digit:]]*$ ]] && echo\
    \ \"$res\" | rev || echo \"$res\"", "  if [ -z \"$1\" ]; then\n    echo \"Please\
    \ provide a string\"\n    return 1\n  fi\n  output=\"\"\n  for (( i=0; i<${#1};\
    \ i++ )); do\n    if [[ ${1:$i:1} =~ [a-zA-Z] ]]; then\n      output=\"$output${1:$i:1}\"\
    '\\'\n    else\n      output=\"$output${1:$i:1}\"\n    fi\n  done\n  if [ -z \"\
    $output\" ]; then\n    echo \"$1\" | rev\n  else\n    echo \"$1\" | rev | tr $output\
    \ \"[:upper:][:lower:]\" | rev\n  fi", "  echo $1 | tr '[:lower:]' '[:upper:]'\
    \ | tr '[:upper:]' '[:lower:]'", "    local out=\"\"\n    local i=0\n    local\
    \ c=\"\"\n    local tmp=\"\"\n    if [ -z $1 ]; then\n        return 1\n    fi\n\
    \    if [ $(echo $1 | grep -o \"a-zA-Z\" | wc -l) -eq 0 ]; then\n        echo\
    \ $1 | rev\n        return 0\n    fi\n    while [ $i -lt ${#1} ]; do\n       \
    \ c=${1:$i:1}\n        if [[ $c =~ ^[a-zA-Z] ]]; then\n            tmp=$(echo\
    \ $c | tr [a-z] [A-Z])\n            if [ \"$tmp\" == \"$c\" ]; then\n        \
    \        tmp=$(echo $c | tr [A-Z] [a-z])\n            fi\n            out+=$tmp\n\
    \        else\n            out+=$c\n        fi\n        i=$((i+1))\n    done\n\
    \    echo $out", "  [[ -z \"${1//[a-zA-Z]}\" ]] && echo \"$1\" | rev \\\n    ||\
    \ echo \"$1\" | tr [:lower:] [:upper:] | rev | tr [:upper:] [:lower:]", "\ts=$1\n\
    \tcount=0\n\tfor (( i=0; i<${#s}; i++ ))\n\tdo\n\t\tc=${s:$i:1}\n\t\tcase $c in\n\
    \t\t\t[a-zA-Z])\n\t\t\t\tchar=$(tr [a-z] [A-Z] <<< \"$c\")\n\t\t\t\tif [ \"$char\"\
    \ == \"$c\" ]; then\n\t\t\t\t\tchar=$(tr [A-Z] [a-z] <<< \"$c\")\n\t\t\t\tfi\n\
    \t\t\t\tt=${s:0:$i}$char${s:$((i+1))}\n\t\t\t\ts=$t\n\t\t\t\tcount=$((count+1))\n\
    \t\t\t\t;;\n\t\tesac\n\tdone\n\tif [ $count -gt 0 ]; then\n\t\techo $s\n\telse\n\
    \t\ts=$(echo $s | rev)\n\t\techo $s\n\tfi", "  echo $1 | tr '[:upper:]' '[:lower:]'\
    \ | tr '[:lower:]' '[:upper:]'", "    echo \"$1\" | tr -d '[0-9]' | rev | tr '[:upper:]'\
    \ '[:lower:]' | tr '[:lower:]' '[:upper:]'", "\t[ \"$1\" ] || return\n\techo \"\
    $1\" | tr '[:lower:]' '[:upper:]' | tr '[:upper:]' '[:lower:]'", "    echo \"\
    $1\" | tr '[:upper:]' '[:lower:]' | rev | tr '[:lower:]' '[:upper:]'", "    if\
    \ [ $# -eq 0 ]; then\n        echo \"You must give me a string\"\n        exit\
    \ 1\n    fi\n    tr \"[a-z]\" \"[A-Z]\" <<< $1 | tr \"[A-Z]\" \"[a-z]\"", "\t\
    echo \"${1//[a-z]/}\"", "  local result=\"\"\n  local i\n  for ((i=0; i<${#1};\
    \ i++)); do\n    if [[ ${1:$i:1} =~ [a-zA-Z] ]]; then\n      # If the current\
    \ char is a letter, reverse its case\n      if [[ ${1:$i:1} =~ [a-z] ]]; then\n\
    \        result+=\"${1:$i:1^^}\"\n      else\n        result+=\"${1:$i:1,,}\"\n\
    \      fi\n    else\n      # If the current char is not a letter, just append\
    \ it to the result\n      result+=\"${1:$i:1}\"\n    fi\n  done\n  echo \"$result\"",
  "    if [[ \"$1\" =~ [a-zA-Z] ]]; then\n        echo \"$1\" | tr '[a-z]' '[A-Z]'\
    \ | tr '[A-Z]' '[a-z]'\n    else\n        echo \"$1\" | rev\n    fi", "  if [\
    \ -z $(echo $1 | tr -d '[:digit:]') ]; then\n    echo $1 | rev\n  else\n    echo\
    \ $1 | tr '[:upper:]' '[:lower:]' | tr '[:lower:]' '[:upper:]'\n  fi", "    #\
    \ exit with an error code on any error\n    set -e\n    # exit code if no arguments\
    \ are given\n    test $# -gt 0 || exit 2\n    declare -a str=()\n    for ((i=0;\
    \ i<${#1}; i++)); do\n        char=${1:$i:1}\n        if [[ $char =~ [a-zA-Z]\
    \ ]]; then\n            [[ $char =~ [a-z] ]] && char=${char^^} || char=${char,,}\n\
    \        fi\n        str+=($char)\n    done\n    echo \"${str[@]}\"", "    local\
    \ str=\"\"\n    local i=\"\"\n    local n=\"\"\n    for ((i=${#1}-1; i>=0; i--));\
    \ do\n        n=\"${1:$i:1}\"\n        if [[ \"$n\" =~ [a-zA-Z] ]]; then\n   \
    \         str+=\"${n^^}\"\n        else\n            str+=\"$n\"\n        fi\n\
    \    done\n    echo \"$str\"", "\t\n\t# loop over every char in the string\n\t\
    for (( i=0; i<${#1}; i++ )); do\n\t\t\n\t\tchar=${1:$i:1}\n\t\t# test if the character\
    \ is a letter\n\t\tif [[ \"$char\" =~ ^[a-zA-Z]$ ]]; then\n\t\t\t\n\t\t\tif [[\
    \ \"$char\" =~ ^[a-z]$ ]]; then\n\t\t\t\t# make the character upper case\n\t\t\
    \t\tresult+=${char^^}\n\t\t\telse\n\t\t\t\t# make the character lower case\n\t\
    \t\t\tresult+=${char,,}\n\t\t\tfi\n\t\telse\n\t\t\t# append the character as it\
    \ is\n\t\t\tresult+=$char\n\t\tfi\n\tdone\n\t\n\t# return the string\n\techo $result",
  "    [ -z $1 ] && echo && return\n    count=${#1}\n    for (( i=0; i<count; i++\
    \ )); do\n        ch=${1:$i:1}\n        [ \"$ch\" != \"${ch,,}\" ] && ch=\"${ch,,}\"\
    \ || ch=\"${ch^^}\"\n        echo -n \"$ch\"\n    done\n    echo", "    if echo\
    \ \"$1\" | grep -q \"[a-zA-Z]\"; then\n        echo \"$1\" | tr '[a-zA-Z]' '[A-Za-z]'\n\
    \    else\n        echo \"$1\" | rev\n    fi", "  # Your code here\n  if [[ \"\
    $1\" == *[a-zA-Z]* ]]; then\n    echo \"$1\" | tr '[:upper:]' '[:lower:]' | tr\
    \ '[:lower:]' '[:upper:]'\n  else\n    echo \"$1\" | rev\n  fi", "  if [ -z \"\
    $(echo $1 | grep '[a-zA-Z]')\" ]; then \n    echo $1 | rev\n  else\n    echo $1\
    \ | tr '[:upper:]' '[:lower:]' | tr '[:lower:]' '[:upper:]'\n  fi", "    if [[\
    \ ! -z \"$(echo \"$1\" | grep -E '[a-zA-Z]')\" ]]; then\n        echo \"$(tr '[:upper:]'\
    \ '[:lower:]' <<< \"$1\")\" | tr '[:lower:]' '[:upper:]'\n    else\n        echo\
    \ \"$1\" | rev\n    fi", "    echo $1 | sed 's/[a-z]/\\U&/;s/[A-Z]/\\L&/'", " \
    \ echo -n \"$1\" | sed -r 's/([a-zA-Z])/\\U\\1/g' | rev", "  local s=$1;\n  if\
    \ [[ $s =~ [a-zA-Z] ]]; then\n    echo \"$s\" | tr \"[a-zA-Z]\" \"[A-Za-z]\"\n\
    \  else\n    echo \"$s\" | rev\n  fi", "    local s=$1\n    local tmp=\"\"\n \
    \   local i=0\n    local j=0\n    local len=${#s}\n    while read -rn1 char; do\n\
    \        if [[ $char =~ [a-zA-Z] ]]; then\n            if [[ $char =~ [a-z] ]];\
    \ then\n                tmp[$i]=$(echo $char | tr [a-z] [A-Z])\n            else\n\
    \                tmp[$i]=$(echo $char | tr [A-Z] [a-z])\n            fi\n    \
    \        i=$((i+1))\n        fi\n    done <<< $s\n    if [[ $i -gt 0 ]]; then\n\
    \        for ((j=$i-1; j>=0; j--)); do\n            echo -n ${tmp[$j]}\n     \
    \   done\n    else\n        for ((j=$len-1; j>=0; j--)); do\n            echo\
    \ -n ${s:$j:1}\n        done\n    fi\n    echo", "  echo \"$1\" | tr '[:lower:]'\
    \ '[:upper:]' | tr '[:upper:]' '[:lower:]'", '  [[ $1 =~ [a-zA-Z] ]] && tr "[a-zA-Z]"
    "[A-Za-z]" <<< $1 || rev <<< $1', "  local s\n  s=$(echo \"$1\" | tr '[:upper:]'\
    \ '[:lower:]' | tr -d '[:digit:]')\n  if [[ -z \"$s\" ]]; then\n    echo \"$1\"\
    \ | rev\n  else\n    echo \"$1\" | tr '[:lower:]' '[:upper:]' | tr '[:upper:]'\
    \ '[:lower:]'\n  fi", "    string=\"$1\"\n    if [[ $string =~ [a-zA-Z] ]]; then\n\
    \        awk '{\n            for (i=1; i<=length($0); i++) {\n               \
    \ if ($0 ~ /[a-z]/) {\n                    printf(\"%s\", toupper(substr($0, i,\
    \ 1)));\n                } else if ($0 ~ /[A-Z]/) {\n                    printf(\"\
    %s\", tolower(substr($0, i, 1)));\n                } else {\n                \
    \    printf(\"%s\", substr($0, i, 1));\n                }\n            }\n   \
    \     }' <<< $string\n    else\n        echo $string | rev\n    fi", "    res=\"\
    \"\n    # Your solution starts from here\n    for i in $(seq 0 $((${#1}-1)));\
    \ do\n        char=${1:$i:1}\n        if [[ $char =~ [a-zA-Z] ]]; then\n     \
    \       if [[ $char =~ [a-z] ]]; then\n                char=$(echo $char | tr\
    \ [a-z] [A-Z])\n            else\n                char=$(echo $char | tr [A-Z]\
    \ [a-z])\n            fi\n        fi\n        res+=$char\n    done\n    # Your\
    \ solution ends\n    echo $res", "    # replace all non-alpha characters with\
    \ empty string\n    # then invert uppercase and lowercase\n    echo \"$1\" | tr\
    \ -s -c '[:alpha:]' '\\n' | tr '[:upper:]' '[:lower:]'", "    echo $1 | tr '[:lower:]'\
    \ '[:upper:]' | tr '[:upper:]' '[:lower:]'", "  ! [[ $1 =~ [a-zA-Z] ]] && rev\
    \ <<< $1 || tr '[:upper:]' '[:lower:]' <<< $1 | rev", "    local s=$1\n    if\
    \ [[ ! $s =~ [a-zA-Z] ]]; then\n        echo \"$s\" | rev\n    else\n        echo\
    \ \"$s\" | sed -e 's/\\([a-z]\\)/\\U\\1/g' -e 's/\\([A-Z]\\)/\\L\\1/g'\n    fi",
  "    if [[ $1 =~ [a-zA-Z] ]]; then\n        echo $1 | tr '[a-zA-Z]' '[A-Za-z]'\n\
    \    else\n        echo $1 | rev\n    fi", "  local s=$1\n  local d=\"\"\n  local\
    \ x=\"\"\n  local t=\"\"\n  local i=\"\"\n  d=$(echo $s | grep \"[a-zA-Z]\")\n\
    \  [[ $d ]] && {\n    for ((i=0; i<${#s}; i++)); do\n      x=${s:$i:1}\n     \
    \ [[ $x =~ [a-z] ]] && t+=$(echo $x | tr a-z A-Z)\n      [[ $x =~ [A-Z] ]] &&\
    \ t+=$(echo $x | tr A-Z a-z)\n      [[ $x =~ [0-9] ]] && t+=$x\n      [[ $x =~\
    \ [^0-9a-zA-Z] ]] && t+=$x\n    done\n    echo $t\n  } || {\n    for ((i=${#s}-1;\
    \ i>=0; i--)); do\n      t+=$(echo $s | cut -c $i)\n    done\n    echo $t\n  }",
  "    case $1 in\n    \"\")\n        printf '%s\\n' \"$1\"\n        ;;\n    *)\n\
    \        printf '%s\\n' \"$1\" | tr '[:upper:]' '[:lower:]' | tr '[:lower:]' '[:upper:]'\n\
    \        ;;\n    esac", "  # Your code here\n  len=$((${#1}-1))\n  if [ $len -eq\
    \ 0 ]; then\n    echo \"$1\"\n  else\n    for i in $(seq 0 $len); do\n      if\
    \ [[ ${1:$i:1} =~ [A-Za-z] ]]; then\n        if [[ ${1:$i:1} =~ [A-Z] ]]; then\n\
    \          lower=$(echo ${1:$i:1} | tr 'A-Z' 'a-z')\n          result=\"$result$lower\"\
    \n        else\n          upper=$(echo ${1:$i:1} | tr 'a-z' 'A-Z')\n         \
    \ result=\"$result$upper\"\n        fi\n      else\n        result=\"$result${1:$i:1}\"\
    \n      fi\n    done\n    echo \"$result\"\n  fi", "  local str=$1;\n  #case $str\
    \ in\n  #  [a-z]* ) echo $str | tr '[:lower:]' '[:upper:]';;\n  #  [A-Z]* ) echo\
    \ $str | tr '[:upper:]' '[:lower:]';;\n  #  *) echo $str | rev;;\n  #esac\n  local\
    \ n=\"${#str}\"\n  local res=\"\"\n  for (( i=0; i<n; i++ )); do\n    local c=${str:$i:1}\n\
    \    if [[ \"$c\" =~ [a-z] ]]; then\n      res+=\"${c^^}\"\n    elif [[ \"$c\"\
    \ =~ [A-Z] ]]; then\n      res+=\"${c,,}\"\n    else\n      res+=\"$c\"\n    fi\n\
    \  done\n  [[ \"$res\" =~ [a-zA-Z] ]] && echo \"$res\" || echo \"${res::-1}\"\
    \ | rev", "  local res=\"\"\n  local s=\"$1\"\n  local i\n  local char\n  local\
    \ -i slen=${#s}\n  local -i noletters=1\n  for ((i=0; i<slen; i++)); do\n    char=\"\
    ${s:i:1}\"\n    if [[ $char =~ [a-zA-Z] ]]; then\n      noletters=0\n      if\
    \ [[ $char =~ [a-z] ]]; then\n        char=$(echo $char | tr '[a-z]' '[A-Z]')\n\
    \      else\n        char=$(echo $char | tr '[A-Z]' '[a-z]')\n      fi\n    fi\n\
    \    res+=$char\n  done\n  if [[ $noletters -eq 1 ]]; then\n    echo \"$res\"\
    \ | rev\n  else\n    echo \"$res\"\n  fi", "    if [[ -z $1 ]]; then\n       \
    \ echo \"Empty string\"\n        return 1\n    fi\n    if [[ -z $(sed -n \"/[a-zA-Z]/p\"\
    \ <<< $1) ]]; then\n        # if no letters\n        rev <<< $1\n    else\n  \
    \      sed \"y/[a-z]/[A-Z]/; y/[A-Z]/[a-z]/\" <<< $1\n    fi", "  local OUTPUT\n\
    \  if [[ $1 =~ [[:alpha:]] ]]; then\n    OUTPUT=$(echo $1 | tr '[:upper:]' '[:lower:]'\
    \ | tr '[:lower:]' '[:upper:]')\n  else\n    OUTPUT=$(echo $1 | rev)\n  fi\n \
    \ echo $OUTPUT", "  str=\"$1\"\n  num_of_letters=$(echo \"$str\" | grep -o \"\
    [a-zA-Z]\" | wc -l)\n  if [ \"$num_of_letters\" -eq 0 ]; then\n    echo \"$str\"\
    \ | rev\n  else\n    echo \"$str\" | tr \"a-zA-Z\" \"A-Za-z\"\n  fi", "    local\
    \ -a str_arr=(\"$@\")\n    local -a result_arr=()\n    local res=\"\"\n    local\
    \ len=${#str_arr[*]}\n    local i=0\n    local j=0\n    local k=0\n    while ((\
    \ i < len ))\n    do\n        if [[ ${str_arr[i]} =~ [a-zA-Z] ]]\n        then\n\
    \            if [[ ${str_arr[i]} =~ [a-z] ]]\n            then\n             \
    \   result_arr[j]=$(echo ${str_arr[i]} | tr '[:lower:]' '[:upper:]')\n       \
    \     else\n                result_arr[j]=$(echo ${str_arr[i]} | tr '[:upper:]'\
    \ '[:lower:]')\n            fi\n            j=$((j+1))\n        else\n       \
    \     k=$((k+1))\n        fi\n        i=$((i+1))\n    done\n    if (( k == len\
    \ ))\n    then\n        for (( i = len-1; i >= 0; i-- ))\n        do\n       \
    \     res=${res}${str_arr[i]}\n        done\n    else\n        for (( i = 0; i\
    \ < len; i++ ))\n        do\n            res=${res}${result_arr[i]}\n        done\n\
    \    fi\n    echo $res", '    sed -r "s/([a-z])/\U\1/g;s/([A-Z])/\L\1/g;t;h;x;s/[^[:alpha:]]/./g;s/(.)(.*)/\2\1/g"
    <<< "$1"', "\t:", "    answer=''\n    if [ -z \"$1\" ]; then\n        echo \"\
    $1\"\n        return\n    fi\n    for (( i=0; i<${#1}; i++ )); do\n        if\
    \ [[ ${1:$i:1} =~ [a-zA-Z] ]]; then\n            if [[ ${1:$i:1} =~ [a-z] ]];\
    \ then\n                answer=\"$answer$(echo ${1:$i:1} | tr a-z A-Z)\"\n   \
    \         else\n                answer=\"$answer$(echo ${1:$i:1} | tr A-Z a-z)\"\
    \n            fi\n        else\n            answer=\"$answer${1:$i:1}\"\n    \
    \    fi\n    done\n    echo \"$answer\"", "    if [[ \"$1\" =~ [a-zA-Z] ]]; then\n\
    \        echo \"$1\" | tr '[:upper:]' '[:lower:]' | tr '[:lower:]' '[:upper:]'\n\
    \    else\n        echo \"$1\" | rev\n    fi", "    [ ${#1} -eq 0 ] && echo \"\
    \" && return 0\n    # Convert string to lowercase\n    string=\"${1,,}\"\n   \
    \ # Echo the string, replacing all letters with the reversed case\n    echo \"\
    ${string//[a-z]/${string//[A-Z]/\\L}}\"", "\tif [[ -z \"$1\" ]]; then\n\t\techo\
    \ ''\n\telse\n\t\tfor (( i=0; i<${#1}; i++ )); do\n\t\t\tchar=${1:$i:1}\n\t\t\t\
    if [[ \"$char\" =~ [a-z] ]]; then\n\t\t\t\techo -n \"${char^^}\"\n\t\t\telif [[\
    \ \"$char\" =~ [A-Z] ]]; then\n\t\t\t\techo -n \"${char,,}\"\n\t\t\telse\n\t\t\
    \t\techo -n \"$char\"\n\t\t\tfi\n\t\tdone\n\t\techo ''\n\tfi", "\tlocal string=\"\
    $1\"\n\t# TODO: $string is a string, please reverse its case from lower to upper\
    \ and\n\t# vise versa.\n\t# Hint: first use 'grep' to filter all the letters,\
    \ then reverse the case\n\t# of them by using 'tr'. \n\t# Hint: use '-o' option\
    \ of 'grep' to only print the matched letters,\n\t# and then concatenate them\
    \ with the remaining parts of the string\n\t# Hint: use the following command\
    \ to convert A to a\n\t# echo A | tr '[:upper:]' '[:lower:]'\n\t# Hint: use the\
    \ following command to convert a to A\n\t# echo a | tr '[:lower:]' '[:upper:]'\n\
    \t# Hint: use the following command to reverse the cases of string s\n\t# echo\
    \ s | tr '[:upper:]' '[:lower:]' | tr '[:lower:]' '[:upper:]'\n\t# Hint: use 'grep'\
    \ with regular expression to only match the letters\n\t# \"^[A-Za-z]*$\"\n\t#\
    \ Hint: use the following command to split a string into two parts:\n\t# part1,\
    \ part2 = $(echo str | grep -o --color=never \"p1.*p2\")\n\t# Tip: you can use\
    \ echo to print a variable, e.g.\n\t# echo $string\n\t# Tip: you can use printf\
    \ \"%q\" to print a variable with single quotes, e.g.\n\t# printf \"%q\" $string\n\
    \t# Tip: you can use printf \"%s\" to print a variable without any quote, e.g.\n\
    \t# printf \"%s\" $string\n\t# Tip: you can use echo \"${#v}\" to print the length\
    \ of variable v, e.g.\n\t# echo \"${#string}\"\n\t# Tip: use sed to replace the\
    \ matched string with new string, e.g.\n\t# echo \"abc def ghi\" | sed 's/abc/ABC/'\n\
    \t# Tip: the space is not a letter, the following regex will match the\n\t# letters\
    \ and space\n\t# echo \"abc def ghi\" | grep -o --color=never \"[[:alpha:]]",
  "    echo \"$1\" | LC_ALL=C sed -r 's/(.)/\\U\\1/g;s/(.)/\\L\\1/g'", "\tif [[ $1\
    \ =~ [[:alpha:]] ]]; then\n\t\techo $1 | tr 'A-Za-z' 'a-zA-Z'\n\telse\n\t\techo\
    \ $1 | rev\n\tfi", "    string=$1\n    re='^[a-zA-Z]+$'\n    if [[ $string =~\
    \ $re ]]; then\n        echo \"$string\" | tr '[:upper:]' '[:lower:]' | tr '[:lower:]'\
    \ '[:upper:]'\n    else\n        echo \"$string\" | rev\n    fi", "    if [[ \"\
    $1\" =~ [a-zA-Z] ]]; then\n        tr '[:upper:]' '[:lower:]' <<< \"$1\" | tr\
    \ '[:lower:]' '[:upper:]'\n    else\n        rev <<< \"$1\"\n    fi", "    local\
    \ result=\"\"\n    local s=$1\n    local c\n    for ((i=0; i<${#s}; i++)); do\n\
    \        c=${s:$i:1}\n        if [[ $c =~ [a-zA-Z] ]]; then\n            c=${c^^}\n\
    \            result=$result${c,,}\n        else\n            result=$result$c\n\
    \        fi\n    done\n    echo $result", "  if [[ $1 =~ [a-zA-Z] ]]; then\n \
    \   echo \"$1\" | tr \"[:lower:]\" \"[:upper:]\" | tr \"[:upper:]\" \"[:lower:]\"\
    \n  else\n    echo \"$1\" | rev\n  fi", "    printf \"%s\\n\" \"$1\" |\n    tr\
    \ '[:lower:]' '[:upper:]' |\n    tr '[:upper:]' '[:lower:]' |\n    tr -d '[:punct:]'\
    \ |\n    tr -d '[:digit:]' |\n    rev", "    # get the length of the string\n\
    \    i=${#1}\n    # initialize the result string\n    r=\"\"\n    # loop over\
    \ each character in the string\n    while [ $i -gt 0 ]; do\n        # get the\
    \ ith character in the string\n        c=${1:$i-1:1}\n        # compare the character\
    \ to lower case alphabet, \n        # if it's lower case, then convert it to upper\
    \ case\n        # else convert it to lower case\n        if [[ $c =~ [a-z] ]];\
    \ then\n            r=$r${c^^}\n        elif [[ $c =~ [A-Z] ]]; then\n       \
    \     r=$r${c,,}\n        else\n            r=$r$c\n        fi\n        # decrease\
    \ i\n        i=$((i-1))\n    done\n    # print the result\n    echo $r", '  #
    Write your code here.', "  if [[ ! \"$1\" =~ [a-zA-Z] ]]; then\n    echo \"$1\"\
    \ | rev\n  else\n    echo \"$1\" | tr '[:upper:]' '[:lower:]' | tr 'a-z' 'A-Z'\n\
    \  fi", "  #echo \"Input:\"\n  #echo \"  $1\"\n  #echo \"Output:\"\n  s=${1//[0-9]/}\n\
    \  if [ -z \"$s\" ]; then\n    echo $1 | rev\n  else\n    echo \"${1//[a-z]/`echo\
    \ ${1//[a-z]/}`}\" | tr '[:upper:]' '[:lower:]'\n  fi", "    temp=\"$(echo $1\
    \ | tr a-z A-Z | tr 0-9 A-Z)\"\n    # If $temp is empty\n    if [ \"$temp\" ==\
    \ \"\" ]; then\n        # Reverse the string\n        echo \"$1\" | rev\n    else\n\
    \        # Otherwise print the string\n        echo \"$temp\"\n    fi", "  if\
    \ [[ $1 =~ [a-zA-Z] ]]; then\n    echo $1 | tr 'a-zA-Z' 'A-Za-z'\n  else\n   \
    \ echo $1 | rev\n  fi", "    sed -e 's/[a-z]/\\U&/g' -e 's/[A-Z]/\\L&/g' <<< $1",
  "\ts=$1\n\techo \"$s\" | grep -q '[a-zA-Z]'\n\tif [ $? -eq 0 ]; then\n\t\techo \"\
    $s\" | tr '[:upper:]' '[:lower:]' | tr '[:lower:]' '[:upper:]'\n\telse\n\t\techo\
    \ \"$s\" | rev\n\tfi", "    if [[ $1 =~ [a-zA-Z] ]]; then\n        echo \"$1\"\
    \ | tr '[:upper:]' '[:lower:]' | tr '[:lower:]' '[:upper:]'\n    else\n      \
    \  echo \"$1\" | rev\n    fi", "  local s=\"$1\"\n  # TODO:\n  # 1. if the string\
    \ contains no letters, reverse the string.\n  [[ \"$s\" =~ [A-Za-z] ]] || echo\
    \ \"$s\" | rev\n  # 2. if the string contains letters, reverse its case from lower\
    \ to upper or vise versa.\n  [[ \"$s\" =~ [A-Za-z] ]] && echo \"$s\" | tr '[:upper:]'\
    \ '[:lower:]' | tr '[:lower:]' '[:upper:]'", "    #printf \"function solve is\
    \ not implemented\\n\"\n    local str=$1\n    printf \"$str\" | grep -q \"[a-zA-Z]\"\
    \n    [ $? -eq 0 ] && str=$(echo \"$str\" | tr '[:upper:]' '[:lower:]' | rev |\
    \ tr '[:lower:]' '[:upper:]') || str=$(echo \"$str\" | rev)\n    printf \"$str\"",
  "    # pattern : [a-z]\n    # notation : \\l\n    # shell : [[:lower:]]\n    # from\
    \ lower to upper : tr\n    local s=$1\n    local oldS=${s}\n    local l=$(echo\
    \ ${s} | tr [[:lower:]] [[:upper:]])\n    local u=$(echo ${s} | tr [[:upper:]]\
    \ [[:lower:]])\n    s=$(echo ${s} | tr -d [[:alpha:]])\n    if [[ ${#s} -eq 0\
    \ ]]; then\n        echo ${oldS} | rev\n    else\n        echo ${s} | tr [[:alpha:]]\
    \ -s ${l}${u}\n    fi", "  # sed -r is for extended regular expressions\n  # in\
    \ range [a-zA-Z]\n  # [:upper:] to uppercase and [:lower:] to lowercase\n  # g\
    \ is for global search \n  echo $1 | sed -r 's/[a-zA-Z]/\\L\\0/g' | sed -r 's/[a-zA-Z]/\\\
    U\\0/g'", "\tlocal res=\"\"\n\tlocal -i i\n\tlocal len\n\tlen=${#1}\n\tfor ((i=0;\
    \ i<len; i++)); do\n\t\tif [[ \"${1:$i:1}\" =~ [a-zA-Z] ]]; then\n\t\t\tres+=\"\
    ${1:$i:1}\" | tr \"[:lower:]\" \"[:upper:]\"\n\t\telse\n\t\t\tres+=\"${1:$i:1}\"\
    \n\t\tfi\n\tdone\n\tif [[ \"$res\" =~ [a-zA-Z] ]]; then\n\t\techo \"$res\" | rev\n\
    \telse\n\t\techo \"$res\"\n\tfi", "    string=\"$1\"\n    # Change this line\n\
    \    reversed=\"\"\n    # End of the changes\n    echo \"$reversed\"", "  local\
    \ s=\"$1\"\n  local r=''\n  for ((i=0; i<${#s}; i++)); do\n    c=${s:$i:1}\n \
    \   case $c in\n      [[:upper:]]) r=\"${r}$(echo $c | tr '[:upper:]' '[:lower:]')\"\
    \ ;;\n      [[:lower:]]) r=\"${r}$(echo $c | tr '[:lower:]' '[:upper:]')\" ;;\n\
    \      *) r=\"${r}$c\" ;;\n    esac\n  done\n  if [[ -z \"$(sed -n 's/[A-Za-z]//p'\
    \ <<< $r)\" ]]; then\n    echo $r | rev\n  else\n    echo $r\n  fi", "\tstr=$1\n\
    \tstr=\"${str//[[:digit:]]/}\"\n\n\tif [ -z \"$str\" ]; then\n\t\techo \"$1\"\
    \ | rev\n\telse\n\t\techo \"$1\" | tr \"a-zA-Z\" \"A-Za-z\"\n\tfi", "    local\
    \ str=$1\n    # the solution is here\n    # write your code here\n    local string=\"\
    \"\n    for (( i=0; i<${#str}; i++ )); do\n        if [[ \"${str:$i:1}\" =~ [a-z]\
    \ ]]; then\n            string+=\"${str:$i:1^^}\"\n        elif [[ \"${str:$i:1}\"\
    \ =~ [A-Z] ]]; then\n            string+=\"${str:$i:1,,}\"\n        else\n   \
    \         string+=\"${str:$i:1}\"\n        fi\n    done\n    echo $string", " \
    \ local solution=\"\"\n  for ((i=0; i<${#1}; i++)); do\n    c=${1:$i:1}\n    if\
    \ [[ $c =~ [a-zA-Z] ]]; then\n      if [[ $c =~ [a-z] ]]; then\n        solution=\"\
    $solution$(tr [a-z] [A-Z] <<< $c)\"\n      else\n        solution=\"$solution$(tr\
    \ [A-Z] [a-z] <<< $c)\"\n      fi\n    else\n      solution=\"$solution$c\"\n\
    \    fi\n  done\n  echo $solution", "    len=${#1}\n    for ((i=0; i<len; i++));\
    \ do\n        if [[ ${1:i:1} =~ [a-zA-Z] ]]; then\n            if [[ ${1:i:1}\
    \ =~ [a-z] ]]; then\n                res+=${1:i:1^^}\n            else\n     \
    \           res+=${1:i:1,,}\n            fi\n        else\n            res+=${1:i:1}\n\
    \        fi\n    done\n    echo $res", "   # Write your solution here\n  ln=`echo\
    \ $1 | grep -o \"[a-z]\" | wc -l`\n  lc=`echo $1 | grep -o \"[A-Z]\" | wc -l`\n\
    \  if [[ ln -gt 0 ]]; then\n     echo $1 | tr [a-z] [A-Z]\n  elif [[ lc -gt 0\
    \ ]]; then\n     echo $1 | tr [A-Z] [a-z]\n  else\n     echo $1 | rev\n  fi",
  "  local temp\n  local str=\n  for ((i=0; i<${#1}; i++)); do\n    temp=\"${1:$i:1}\"\
    \n    if [[ \"$temp\" =~ [a-zA-Z] ]]; then\n      str+=\"${temp^^}\"\n    else\n\
    \      str+=\"$temp\"\n    fi\n  done\n  printf \"%s\\n\" \"${str//[A-Z]/}\""]
stop_tokens:
- "\n}"
