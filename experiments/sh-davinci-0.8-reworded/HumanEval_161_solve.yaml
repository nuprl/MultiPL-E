name: HumanEval_161_solve
language: sh
prompt: "#!/bin/bash\n# You are given a string s.\n# if s[i] is a letter, reverse\
  \ its case from lower to upper or vise versa, \n# otherwise keep it as it is.\n\
  # If the string contains no letters, reverse the string.\n# The function should\
  \ return the resulted string.\n# Examples\n# >>> $(solve \"1234\")\n# \"4321\"\n\
  # >>> $(solve \"ab\")\n# \"AB\"\n# >>> $(solve \"#a@C\")\n# \"#A@c\"\n#\n# $1 is\
  \ a string\nsolve() {\n"
tests: "}\n\ncandidate() {\n    solve \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
  \ \"AsDf\") = \"aSdF\" ]]\n    [[ $(candidate \"1234\") = \"4321\" ]]\n    [[ $(candidate\
  \ \"ab\") = \"AB\" ]]\n    [[ $(candidate \"#a@C\") = \"#A@c\" ]]\n    [[ $(candidate\
  \ \"#AsdfW^45\") = \"#aSDFw^45\" ]]\n    [[ $(candidate \"#6@2\") = \"2@6#\" ]]\n\
  \    [[ $(candidate \"#\\$a^D\") = \"#\\$A^d\" ]]\n    [[ $(candidate \"#ccc\")\
  \ = \"#CCC\" ]]\n}\n\nrun_test"
completions: ["    local -a l=()\n    local -a u=()\n    local -a r=()\n    for ((i=0;\
    \ i<${#1}; i++)); do\n        [[ \"${1:$i:1}\" =~ [a-z] ]] && l+=(\"${1:$i:1}\"\
    )\n        [[ \"${1:$i:1}\" =~ [A-Z] ]] && u+=(\"${1:$i:1}\")\n        [[ \"${1:$i:1}\"\
    \ =~ [^a-zA-Z] ]] && r+=(\"${1:$i:1}\")\n    done\n    [[ \"${#l[@]}\" -gt 0 ]]\
    \ && l=(\"${l[@]}\" \"${l[@]}\" \"${l[@]}\")\n    [[ \"${#u[@]}\" -gt 0 ]] &&\
    \ u=(\"${u[@]}\" \"${u[@]}\" \"${u[@]}\")\n    [[ \"${#r[@]}\" -gt 0 ]] && r=(\"\
    ${r[@]}\" \"${r[@]}\" \"${r[@]}\")\n    local -a t=(\"${l[@]}\" \"${u[@]}\" \"\
    ${r[@]}\")\n    for ((i=0; i<${#1}; i++)); do\n        [[ \"${1:$i:1}\" =~ [a-z]\
    \ ]] &&\n            echo -n \"${t[$((3*(i+1)))]}\"\n        [[ \"${1:$i:1}\"\
    \ =~ [A-Z] ]] &&\n            echo -n \"${t[$((3*(i+1)))]}\"\n        [[ \"${1:$i:1}\"\
    \ =~ [^a-zA-Z] ]] &&\n            echo -n \"${t[$((3*(i+1)))]}\"\n    done\n \
    \   echo", "    STR=\"$1\"\n    if [[ -z $(sed -e 's/[^[:alpha:]]//g' <<< $STR)\
    \ ]]; then\n        echo \"$STR\" | rev\n    else\n        echo \"$STR\" | sed\
    \ -e 's/\\([[:alpha:]]\\)/\\L\\1/g' \\\n            -e 's/\\([[:alpha:]]\\)/\\\
    L\\1/g' \\\n            -e 's/\\([[:lower:]]\\)/\\U\\1/g' \\\n            -e 's/\\\
    ([[:upper:]]\\)/\\L\\1/g'\n    fi", "    # Write your code here\n    # To print\
    \ results to the standard output you can use echo\n    # Example: echo \"Hello\
    \ world\"\n    echo $1 | tr \"[:lower:]\" \"[:upper:]\" | rev", "  echo $1 | tr\
    \ -d '0-9' | rev", "  # write your code here\n  echo -e \"$1\"", "  local len=$(echo\
    \ $1 | wc -c)\n  local str=\"\"\n  for (( i=1; i<$len; i++ )); do\n    local ch=$(echo\
    \ $1 | cut -c $i)\n    if [ $ch == \"a\" ] || [ $ch == \"b\" ] || [ $ch == \"\
    c\" ] || [ $ch == \"d\" ] ||\n       [ $ch == \"e\" ] || [ $ch == \"f\" ] || [\
    \ $ch == \"g\" ] || [ $ch == \"h\" ] ||\n       [ $ch == \"i\" ] || [ $ch == \"\
    j\" ] || [ $ch == \"k\" ] || [ $ch == \"l\" ] ||\n       [ $ch == \"m\" ] || [\
    \ $ch == \"n\" ] || [ $ch == \"o\" ] || [ $ch == \"p\" ] ||\n       [ $ch == \"\
    q\" ] || [ $ch == \"r\" ] || [ $ch == \"s\" ] || [ $ch == \"t\" ] ||\n       [\
    \ $ch == \"u\" ] || [ $ch == \"v\" ] || [ $ch == \"w\" ] || [ $ch == \"x\" ] ||\n\
    \       [ $ch == \"y\" ] || [ $ch == \"z\" ]; then\n      str=\"$str$(echo $ch\
    \ | tr '[:lower:]' '[:upper:]')\"\n    elif [ $ch == \"A\" ] || [ $ch == \"B\"\
    \ ] || [ $ch == \"C\" ] || [ $ch == \"D\" ] ||\n         [ $ch == \"E\" ] || [\
    \ $ch == \"F\" ] || [ $ch == \"G\" ] || [ $ch == \"H\" ] ||\n         [ $ch ==\
    \ \"I\" ] || [ $ch == \"J\" ] || [ $ch == \"K\" ] || [ $ch == \"L\" ] ||\n   \
    \      [ $ch == \"M\" ] || [ $ch == \"N\" ] || [ $ch == \"O\" ] || [ $ch == \"\
    P\" ] ||\n         [ $ch == \"Q\" ] || [ $ch == \"R\" ] || [ $ch == \"S\" ] ||\
    \ [ $ch", "  s=\"$1\"\n  # Check if the string has a letter.\n  if [[ $s =~ [a-zA-Z]\
    \ ]]; then\n    # Change its case from lower to upper or vise versa\n    echo\
    \ \"$s\" | tr '[:upper:]' '[:lower:]' | tr '[:lower:]' '[:upper:]'\n  else\n \
    \   # Otherwise reverse the string.\n    echo \"$s\" | rev\n  fi", "  local rev\n\
    \  rev=$(tr -cd \"a-z\" <<< \"$1\" | rev)\n  local res=''\n  local i\n  local\
    \ chr\n  local ind\n  for ((i=0; i<${#1}; i++)); do\n    chr=${1:i:1}\n    [[\
    \ $chr =~ [a-z] ]] && {\n      ind=$((${#rev} - ${#res} - 1))\n      chr=${rev:ind:1}\n\
    \    }\n    [[ $chr =~ [A-Z] ]] && chr=$(tr '[:upper:]' '[:lower:]' <<< \"$chr\"\
    )\n    res=\"$res$chr\"\n  done\n  echo \"$res\"", "    [[ $1 =~ [a-zA-Z] ]] &&\
    \ echo \"${1//[a-z]/{}\" | tr \"[A-Z]\" \"[a-z]\" | tr \"{}\" \"[A-Z]\"\n    echo\
    \ $1 | rev", "    if ! [[ $1 =~ [a-zA-Z] ]]; then\n        # No letters in the\
    \ string, reverse the whole string\n        echo $1 | rev\n    else\n        #\
    \ Reverses the case of letters only\n        echo $1 | tr '[a-z]' '[A-Z]' | tr\
    \ '[A-Z]' '[a-z]'\n    fi", "    string=$1\n    count=0\n    for i in $(seq 1\
    \ ${#string}); do\n        char=${string:i-1:1}\n        if [[ $char =~ ^[a-zA-Z]\
    \ ]]; then\n            count=$((count+1))\n        fi\n    done\n    if [ $count\
    \ -gt 0 ]; then\n        echo $(echo \"$1\" | tr '[:upper:]' '[:lower:]' | tr\
    \ '[:lower:]' '[:upper:]')\n    else\n        echo $(echo \"$1\" | rev)\n    fi",
  "    if [[ $1 =~ [a-zA-Z] ]]; then\n        tr [:upper:] [:lower:] <<< \"$1\" |\
    \ tr [:lower:] [:upper:]\n    else\n        rev <<< \"$1\"\n    fi", "    len=${#1}\n\
    \    res=\"\"\n    for (( i=0; i<$len; i++ )); do\n        c=${1:$i:1}\n     \
    \   if [[ $c =~ [a-zA-Z] ]]; then\n            if [[ $c =~ [a-z] ]]; then\n  \
    \              c=${c^^}\n            else\n                c=${c,,}\n        \
    \    fi\n        fi\n        res=$res$c\n    done\n    echo $res", "  printf '%s\\\
    n' \"$1\" | tr '[:upper:]' '[:lower:]' | tr '[:lower:]' '[:upper:]' | tr -d '[:digit:]'\
    \ | rev", "\tif [[ -z $1 ]]; then\n\t\techo ''\n\telse\n\t\tif [[ $1 =~ [A-Za-z]\
    \ ]]; then\n\t\t\techo $1 | tr \"[:upper:]\" \"[:lower:]\" | tr \"[:lower:]\"\
    \ \"[:upper:]\"\n\t\telse\n\t\t\trev <<< \"$1\"\n\t\tfi\n\tfi", "    # your code\
    \ here\n    local out=\"\"\n    local letter=\"\"\n    local char=\"\"\n    local\
    \ start=1\n    local end=\"${#1}\"\n    while (( $start <= $end )); do\n     \
    \   char=\"${1:start-1:1}\"\n        if [[ \"$char\" =~ [a-zA-Z] ]]; then\n  \
    \          letter=\"$( tr '[:lower:]' '[:upper:]' <<< \"$char\" )\"\n        \
    \    if [[ \"$letter\" == \"$char\" ]]; then\n                out+=\"$( tr '[:upper:]'\
    \ '[:lower:]' <<< \"$char\" )\"\n            else\n                out+=\"$letter\"\
    \n            fi\n        else\n            out+=\"$char\"\n        fi\n     \
    \   ((start++))\n    done\n    echo \"$out\"", "  [[ $1 =~ [a-zA-Z] ]] || echo\
    \ -n \"${1//./}\"\n  echo -n \"${1//[^a-zA-Z]/.}\" | tr '[:lower:]' '[:upper:]'\
    \ | tr '[:upper:]' '[:lower:]'", "  [[ $1 =~ [a-zA-Z] ]] && tr '[:upper:]' '[:lower:]'\
    \ <<< $1 || rev <<< $1", "  # write your code here\n  local l=\"\"\n  local ch=\"\
    \"\n  #local re=\"\"\n  for (( i=0; i<${#1}; i++ )); do\n    ch=${1:$i:1}\n  \
    \  if [[ \"$ch\" =~ [a-zA-Z] ]]; then\n      if [[ \"$ch\" =~ [a-z] ]]; then\n\
    \        l=$l$(echo $ch | tr 'a-z' 'A-Z')\n      else\n        l=$l$(echo $ch\
    \ | tr 'A-Z' 'a-z')\n      fi\n    else\n      l=$l$ch\n    fi\n  done\n  echo\
    \ $l", "    echo $1 | grep -q '[a-zA-Z]'\n    if [ $? -eq 0 ]; then\n        echo\
    \ $1 | tr '[:upper:]' '[:lower:]' | tr '[:lower:]' '[:upper:]'\n    else\n   \
    \     echo $1 | rev\n    fi"]
stop_tokens:
- "\n}"
