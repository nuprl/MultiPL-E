name: HumanEval_154_cycpattern_check
language: sh
prompt: "#!/bin/bash\n# You are given 2 words. You need to return true if the second\
  \ word or any of its rotations is a substring in the first word\n# >>> $(cycpattern_check\
  \ \"abcd\" \"abd\")\n# \"false\"\n# >>> $(cycpattern_check \"hello\" \"ell\")\n\
  # \"true\"\n# >>> $(cycpattern_check \"whassup\" \"psus\")\n# \"false\"\n# >>> $(cycpattern_check\
  \ \"abab\" \"baa\")\n# \"true\"\n# >>> $(cycpattern_check \"efef\" \"eeff\")\n#\
  \ \"false\"\n# >>> $(cycpattern_check \"himenss\" \"simen\")\n# \"true\"\n#\n# $1\
  \ is a string\n# $2 is a string\ncycpattern_check() {\n"
tests: "}\n\ncandidate() {\n    cycpattern_check \"$@\"\n}\n\nset -e\nrun_test() {\n\
  \    [[ $(candidate \"xyzw\" \"xyw\") = \"false\" ]]\n    [[ $(candidate \"yello\"\
  \ \"ell\") = \"true\" ]]\n    [[ $(candidate \"whattup\" \"ptut\") = \"false\" ]]\n\
  \    [[ $(candidate \"efef\" \"fee\") = \"true\" ]]\n    [[ $(candidate \"abab\"\
  \ \"aabb\") = \"false\" ]]\n    [[ $(candidate \"winemtt\" \"tinem\") = \"true\"\
  \ ]]\n}\n\nrun_test"
completions: ['    echo $1 | grep $2 &> /dev/null && echo "true" || echo "false"',
  "    if [ \"$#\" -ne 2 ]; then\n\techo \"Usage: $0 <string> <string>\"\n\texit 1\n\
    \    fi\n    local str1=$1\n    local str2=$2\n    local len2=${#str2}\n    local\
    \ len1=${#str1}\n    if [ \"$len2\" -gt \"$len1\" ]; then\n\treturn 1\n    fi\n\
    \    local i\n    for ((i=0; i<len2; i++)); do\n\tlocal match=\"${str1%${str2:0:len2-i}*}${str2:len2-i}\"\
    \n\tif [ \"$match\" == \"$str1\" ]; then\n\t    return 0\n\tfi\n    done\n   \
    \ return 1", "    local target=$1\n    local pattern=$2\n    local TARLEN=${#target}\n\
    \    local PATLEN=${#pattern}\n    local i=0\n\n    if [[ $TARLEN -lt $PATLEN\
    \ ]]; then\n        echo \"false\"\n        return\n    fi\n\n    while [[ $i\
    \ -lt $TARLEN ]]; do\n        if [[ ${target:$i:$PATLEN} == $pattern ]]; then\n\
    \            echo \"true\"\n            return\n        fi\n        i=$((i+1))\n\
    \    done\n\n    echo \"false\"", "  [[ -z \"$1\" || -z \"$2\" ]] && echo \"true\"\
    \ && return 0\n  [[ \"$1\" =~ $2 ]] && echo \"true\" && return 0\n  for ((i=1;\
    \ i<${#2}; i++)); do\n    local tmp=${2:$i}\n    local tmp2=${2:0:$i}\n    local\
    \ tmp3=\"$tmp$tmp2\"\n    [[ \"$1\" =~ $tmp3 ]] && echo \"true\" && return 0\n\
    \  done\n  echo \"false\"", "  local word=$1\n  local pattern=$2\n  local rotated_word\n\
    \  local i\n  local word_length=${#word}\n  local pattern_length=${#pattern}\n\
    \  for ((i=0; i<=word_length; i++)); do\n    rotated_word=${word:$i:$word_length}${word:0:$i}\n\
    \    if [[ \"$rotated_word\" == *\"$pattern\"* ]]; then\n      echo \"true\"\n\
    \      return\n    fi\n  done\n  echo \"false\"", "    local word=\"$1\"\n   \
    \ local pat=\"$2\"\n    # check if pattern is a substring of the first word\n\
    \    echo \"$word\" | grep -q -w \"$pat\"\n    if [[ $? -eq 0 ]]; then\n     \
    \   echo \"true\"\n        return\n    fi\n    # rotate pattern and check if it\
    \ is a substring of the first word\n    local counter=1\n    for (( counter=1;\
    \ counter<=${#pat}; counter++ )); do\n        pat=\"${pat:1}${pat:0:1}\"\n   \
    \     echo \"$word\" | grep -q -w \"$pat\"\n        if [[ $? -eq 0 ]]; then\n\
    \            echo \"true\"\n            return\n        fi\n    done\n    echo\
    \ \"false\"", "  if [ \"$#\" -ne 2 ]; then\n    printf \"cycpattern_check requires\
    \ two arguments\\n\"\n    return 1\n  fi\n  if [ -z \"$1\" ] || [ -z \"$2\" ];\
    \ then\n    printf \"cycpattern_check requires non-empty arguments\\n\"\n    return\
    \ 1\n  fi\n  local sub=\"$2\"\n  local len_sub=\"${#sub}\"\n  local i=0\n  while\
    \ [ \"$i\" -lt \"$len_sub\" ]; do\n    if [[ \"$1\" == *\"$sub\"* ]]; then\n \
    \     printf \"true\"\n      return 0\n    fi\n    sub=\"${sub:1}${sub:0:1}\"\n\
    \    (( i++ ))\n  done\n  printf \"false\"\n  return 0", "    word=$1\n    pattern=$2\n\
    \    # your code here\n    length=${#pattern}\n    for (( i=0; i<$length; i++\
    \ ))\n    do\n        pattern=${pattern:1}${pattern:0:1}\n        if [[ $word\
    \ == *$pattern* ]]\n        then\n            echo \"true\"\n            exit\
    \ 0\n        fi\n    done\n    echo \"false\"", "  local -r word1=\"$1\"\n  local\
    \ -r word2=\"$2\"\n  local check\n  local pattern\n  for check in $(echo \"$word2\"\
    \ | awk '{\n    for (i=1; i<=length($0); i++)\n    {\n      print substr($0,i,length($0))\
    \ substr($0,1,i-1)\n    }\n  }'); do\n    pattern=\"$word1\"\n    if [[ \"$pattern\"\
    \ =~ .*\"$check\".* ]]; then\n      echo 'true'\n      break\n    fi\n  done\n\
    \  echo 'false'", "    if (( $# != 2 ))\n    then\n        echo \"Wrong number\
    \ of arguments\"\n        exit 1\n    fi\n    if [[ ! \"$1\" =~ ^[a-z]+$ ]]\n\
    \    then\n        echo \"Illegal argument 1\"\n        exit 1\n    fi\n    if\
    \ [[ ! \"$2\" =~ ^[a-z]+$ ]]\n    then\n        echo \"Illegal argument 2\"\n\
    \        exit 1\n    fi\n    local word=\"$1\"\n    local substring=\"$2\"\n \
    \   for (( i=0; i<${#substring}; i++ ))\n    do\n        local result=$(echo \"\
    $word\" | grep -o \"$substring\")\n        if [ -n \"$result\" ]\n        then\n\
    \            echo \"true\"\n            return 0\n        fi\n        substring=\"\
    ${substring:1}${substring:0:1}\"\n    done\n    echo \"false\"", "    if [[ \"\
    ${#1}\" -lt \"${#2}\" ]]; then\n        echo \"false\"\n        return 0\n   \
    \ fi\n    if [[ \"${1:0:${#2}}\" == \"$2\" ]]; then\n        echo \"true\"\n \
    \       return 0\n    fi\n    cycpattern_check \"${1:1}${1:0:1}\" \"$2\"", " \
    \   if [[ \"${#1}\" -lt \"${#2}\" ]]; then\n        echo \"false\"\n        return\n\
    \    fi\n    first_string=$1\n    second_string=$2\n    count=0\n    while [[\
    \ ${count} -lt ${#second_string} ]]; do\n        if [[ \"${first_string}\" ==\
    \ *\"${second_string}\"* ]]; then\n            echo \"true\"\n            return\n\
    \        fi\n        second_string=${second_string:1}${second_string:0:1}\n  \
    \      count=$(( count + 1 ))\n    done\n    echo \"false\"", "    str1=$1\n \
    \   str2=$2\n    for (( i=0; i<${#str2}; i++ )); do\n        # slide str2 by 1\
    \ position each time\n        if [[ $str1 == *\"${str2:$i:${#str2}}\"* ]]; then\n\
    \            echo \"true\"\n            return\n        fi\n    done\n    echo\
    \ \"false\"", '  echo "true"', "  s1=$1\n  s2=$2\n  len=${#s2}\n  for (( i=0;\
    \ i<len; i++ )); do\n    s2=$(rotate_string \"$s2\")\n    [[ \"$s1\" =~ \"$s2\"\
    \ ]] && echo \"true\" && return\n  done\n  echo \"false\"", "  if [[ \"$1\" =~\
    \ \"$2\" ]]; then\n    echo \"true\"\n  else\n    echo \"false\"\n  fi", "   \
    \ word=\"$1\"\n    pattern=\"$2\"\n    len=$(echo \"${#pattern}\")\n    min_len=$(echo\
    \ \"${#word}\")\n    if [ $len -gt $min_len ]; then\n        echo \"false\"\n\
    \        return\n    fi\n    res=\"true\"\n    #echo \"len=$len\"\n    #echo \"\
    word=$word\"\n    #echo \"pattern=$pattern\"\n    for i in $(seq 0 $((len-1)));\
    \ do\n        newword=$(echo \"${word:$i:$min_len}\")\n        if [[ \"$newword\"\
    \ =~ $pattern ]]; then\n            res=\"true\"\n            break\n        else\n\
    \            res=\"false\"\n        fi\n    done\n    echo \"$res\"", '    [[
    $1 =~ $(cycpattern_generate $2) ]] && echo "true" || echo "false"', "  local str1=$1\n\
    \  local str2=$2\n  local len=$(len $str2)\n  local begin=0\n  while [ $begin\
    \ -lt $len ]; do\n    local tail=$(tail -c +$((begin+1)) <<< $str2)\n    local\
    \ head=$(head -c $begin <<< $str2)\n    if [[ $str1 == *$tail$head* ]]; then\n\
    \      echo \"true\"\n      return\n    fi\n    ((begin++))\n  done\n  echo \"\
    false\"", "  local word=$1\n  local pattern=$2\n  local word_len=${#word}\n  local\
    \ pattern_len=${#pattern}\n  local diff=$(( word_len - pattern_len ))\n  local\
    \ new_word\n  for (( i=0; i<=diff; i++ )); do\n    new_word=${word:i:pattern_len}\n\
    \    if [ $new_word == $pattern ]; then\n      echo \"true\"\n      return\n \
    \   fi\n  done\n  echo \"false\""]
stop_tokens:
- "\n}"
