name: HumanEval_2_truncate_number
language: sh
prompt: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
  \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
  # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
  # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
  \ {\n"
tests: "}\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n\
  \    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\"\
  \ ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
completions: ["  echo $1 | awk '{n=split($1,a,\".\"); print a[2]}'", "    local number=$1\n\
    \    number=${number%.*}\n    echo $number", "    local num=$1\n    local -i intPart\n\
    \    intPart=${num%.*}\n    echo $((num-intPart))", "    local float=$1\n    local\
    \ decimal=$(awk -v float=$float 'BEGIN {\n        split(float, array, \".\")\n\
    \        printf \"%s\", array[2]\n    }')\n    echo $decimal", "    truncate=\"\
    ${1%.*}\"\n    printf \"%0.2f\" $(echo \"$1 - $truncate\" | bc -l)", "    echo\
    \ $1 | awk '{split($1,a,\".\"); print a[2]}'", '    printf "%.*f\n" 0 $1', " \
    \ local number=\"$1\"\n  local integer_part=$(echo \"$number\" | cut -d'.' -f1)\n\
    \  local decimal_part=$(echo \"$number\" | cut -d'.' -f2)\n  if [ -z \"$decimal_part\"\
    \ ]; then\n    echo \"0\"\n  else\n    echo \"0.$decimal_part\"\n  fi", "  number=${1}\n\
    \  echo \"${number}\" | grep -o \"^[0-9]*\\.[0-9]*\"", "  local INTEGER=$(echo\
    \ $1 | cut -d. -f1)\n  local NUMBER=\"0.$(echo $1 | cut -d. -f2)\"\n  local FLOAT=$(python\
    \ -c \"print float($NUMBER)\")\n  echo $FLOAT", "    echo \"$1\" | awk '{printf(\"\
    %0.2f\", $1)}'", "    echo \"$1\" | awk '{printf \"%f\", $1}' | awk -F\".\" '{print\
    \ \"0.\"$2}'", "    if [ $# -ne 1 ]; then\n        error \"truncate_number():\
    \ requires 1 argument\"\n        return 1\n    fi\n    if ! check_is_float \"\
    $1\"; then\n        error \"truncate_number(): argument \\\"$1\\\" is not a float\"\
    \n        return 1\n    fi\n    local x=\"$1\"\n    local integral=${x%.*}\n \
    \   local decimal=${x#*.}\n    local result=$(echo \"scale=4; $decimal / 1\" |\
    \ bc)\n    echo $result", "    float=\"$1\"\n    integer_part=$(python3 -c \"\
    print(int($float))\")\n    float=$(python3 -c \"print($float - $integer_part)\"\
    )\n    echo \"$float\"", "    # Assume number is of the form 0.xxx\n    DECIMAL_PART=$(echo\
    \ $1 | cut -d \".\" -f 2)\n    echo \"0.$DECIMAL_PART\"", '  echo $(bc -l <<<
    "$1 - $(echo "$1" | cut -d "." -f 1)" | bc -l)', "    local number=\"$1\"\n  \
    \  # Let's use awk...\n    echo \"$number\" | awk '{ printf \"%.3f\", $1 - int($1)\
    \ }'", "    echo $1 | cut -d '.' -f 2", "  if [[ \"$1\" =~ ^[+-]?[0-9]+\\.?[0-9]*$\
    \ ]]; then\n    # drop the integer part\n    echo \"$1\" | grep -o -E '\\.[0-9]+'\
    \ | sed 's/^\\.//'\n  else\n    echo \"$1\"\n  fi", "    local -r number=\"$1\"\
    \n    local -r integer_part=\"${number%.*}\"\n\n    printf \"%0.3f\" $(bc <<<\
    \ \"$number - $integer_part\")", "  float=\"$1\"\n  if [ ! -z \"$(echo \"$float\"\
    \ | grep -o \"^[0-9]\\+\\.[0-9]\\+$\")\" ]; then\n    # command substitution;\
    \ bc is an arbitrary precision calculator.\n    # Use a 0.0 divisor to obtain\
    \ the decimals part\n    decimals=$(echo \"scale=2; $float-($float/1)\" | bc)\n\
    \    echo \"$decimals\"\n  else\n    # $float is not a number (we assume it can\
    \ be converted to a number,\n    # so no need to check for characters other than\
    \ 0-9, dot and minus)\n    echo \"error\"\n  fi", "    if (( $(echo \"scale=10;\
    \ ($1 - $(echo \"scale=10; $1/1\" | bc) ) > 0\" | bc -l) )); then\n        echo\
    \ \"scale=10; ($1 - $(echo \"scale=10; $1/1\" | bc) )\" | bc -l\n    else\n  \
    \      echo \"0\"\n    fi", "    if [[ \"$1\" =~ ^[0-9]+\\.[0-9]+$ ]]; then\n\
    \        printf %.3f \"$(bc <<< \"scale=3; $1 - int($1)\")\"\n    else\n     \
    \   echo 0\n    fi", "    echo $1 | awk '{printf \"%.1f\", $1 - int($1)}'", " \
    \   echo \"$1\" | awk '{print $1-int($1)}'", '    printf "%0.0f" "$1"', "    local\
    \ number=\"$1\"\n    printf \"%.1f\" $number", "    local number=$1\n    local\
    \ integer_part=\"${number%%.*}\"\n    local decimal_part=\"${number#*.}\"\n  \
    \  echo \"${decimal_part:0:${#decimal_part}}\"", '    awk "BEGIN { print $1 -
    int($1) }"', "    number=$1\n    (echo $number | awk '{printf \"%.2f\", $1 - int($1)}')",
  "  local number=\"$1\"\n  local result=\"$(echo \"${number}\" | awk '{ print $1\
    \ - int($1) }')\"\n  echo \"${result}\"", "    echo \"$1\" | awk '{print $1-\"\
    int($1)\"}'", "    echo $1 | awk '{print $1-int($1)}'", "  # Get decimal part\
    \ of the number (multiply $1 by 10^3, so that decimal part\n  # is the integer\
    \ part, then get the last three digits, if they are all zeros\n  # then the decimal\
    \ part is 0, if not then substract this number from $1\n  # and get the result\
    \ as a string.\n  local DECIMAL_PART=$(($(($1*1000)) % 1000))\n  if [ $DECIMAL_PART\
    \ -eq 0 ]; then\n    echo \"0\"\n  else\n    # Get result as a string.\n    #\
    \ http://stackoverflow.com/questions/5517597/bash-string-removal-concatenation\n\
    \    local RESULT=$(echo $1-$DECIMAL_PART | bc)\n    echo $RESULT\n  fi", "  #\
    \ echo \"scale=4; $1 - int($1)\" | bc\n  echo \"scale=4; $1 - $(int $1)\" | bc",
  "    # echo \"$1\"\n    echo \"$1\" | awk '{ printf \"%0.3f\", $1 - int($1) }'",
  "    local float=${1}\n    local int=${float%.*}\n    echo $((float-int))", "  \
    \  echo \"${1}\" | awk '{ print $1 - int($1) }'", "    [[ $1 =~ ([0-9]+)\\.([0-9]+)\
    \ ]]\n    printf %s \"${BASH_REMATCH[2]}\"", '    echo "${1} - $(printf "%.0f"
    "${1}")" | bc -l', "    echo $1 | awk '{print substr($1, index($1, \".\") + 1)}'",
  "    local number=$1\n    local integer_part=${number%%.*}\n    local truncated_number=$(echo\
    \ $number - $integer_part | bc)\n    echo $truncated_number", '    printf "%.4f"
    $(bc -l <<< "scale=4; $1 % 1.0")', "    echo \"$1\" | awk '{printf \"%.2f\", $1\
    \ - int($1)}'", "  if ! echo \"$1\" | grep -Eq '^[0-9]+\\.[0-9]+$'; then\n   \
    \ echo \"ERROR: bad input '$1'\"\n    exit 1\n  fi\n  echo \"$1\" | cut -d. -f2",
  "    echo $(echo $1 | sed 's/^\\([0-9]*\\).*/\\1/')", '  echo $(bc -l <<< "$1 %
    1")', "  echo $(echo $1 | awk '{ print $1 - int($1) }')", "    num=$1\n    i=$(echo\
    \ $num | cut -d'.' -f1)\n    f=$(echo $num | cut -d'.' -f2)\n    res=$(echo \"\
    0.$f\" | bc)\n    echo $res", "    echo \"$1\" | awk '{printf(\"%f\", $1-int($1))}'",
  '  bc -l <<< "scale=10; $1 % 1"', "  echo $1 | awk '{ print $1 - int($1) }'", " \
    \   if [[ $1 =~ ^[0-9]+[.][0-9]+$ ]]; then\n        local INT=${1%.*}\n      \
    \  local FLOAT=${1#*.}\n        echo \"0.${FLOAT}\"\n    else\n        echo \"\
    ERROR: $1 is not a float\"\n        return 1\n    fi", "    echo \"$1\" | awk\
    \ '{ print $1 - int($1) }'", "    local -r number=\"$1\"\n    echo \"$number\"\
    \ | cut -d. -f2", "    local number=$1\n    local integ=${number%.*}\n    local\
    \ decim=$(echo \"scale=2; $number - $integ\" | bc)\n    decim=${decim:2}\n   \
    \ echo $decim", '    printf "%f" "$1" | cut -d. -f2', "    number=$1\n    set\
    \ -f\n    set -- $number\n    number=$2\n    echo $number", '    echo "${1#*.*}"',
  "  local -r value=$1\n  printf \"%f\" \"${value##*.}\"", "  local _number=\"$1\"\
    \n  local _integer_part=\"${_number%.*}\"\n  local _decimal_part=\"${_number#*.}\"\
    \n  local _result=\"\"\n  local _number_length=\"\"\n  # Add leading zeros to\
    \ _decimal_part\n  _number_length=\"${#_decimal_part}\"\n  if [[ $_number_length\
    \ -lt 2 ]]; then\n    _result=\".0${_decimal_part}\"\n  else\n    _result=\".${_decimal_part}\"\
    \n  fi\n  echo $_result", "    echo $(python -c \"print( '{:.20f}'.format($1-int($1))\
    \ )\")", "    echo \"$1\" | awk '{split($1,a,\".\"); print a[2]/10^length(a[2])}'",
  "    number=\"$1\"\n    # Get the integer part of the number\n    int_part=\"${number%.*}\"\
    \n    # Get the decimals part of the number\n    dec_part=\"${number#*.}\"\n \
    \   # Remove leading zeros\n    dec_part=\"${dec_part#0}\"\n    # If the number\
    \ has only integer part, return 0\n    if [ \"$dec_part\" == \"\" ]; then\n  \
    \      dec_part=\"0\"\n    fi\n    # Return the decimals part of the number\n\
    \    echo \"0.$dec_part\"", '    echo "${1} - ${1%.*}" | bc', "    echo \"$1\"\
    \ | awk '{print $1 - int($1)}'", "    printf \"%0.2f\" $1 | sed 's/[^.]*\\.//'",
  "  local number=$1\n\n  # Take the decimal part\n  local decimal_part=$(echo \"\
    $number\" | cut -d '.' -f 2)\n\n  # Take the integer part\n  local integer_part=$(echo\
    \ \"$number\" | cut -d '.' -f 1)\n\n  # Take the decimal part\n  local decimal_part=$(echo\
    \ \"$number - $integer_part\" | bc)\n\n  echo \"$decimal_part\"", "    # check\
    \ $1 is a number and remove trailing zeros\n    if [ -z $(echo \"$1\" | grep -E\
    \ \"^[0-9]+\\.?[0-9]*$\") ]; then\n        echo \"0\"\n    else\n        echo\
    \ \"$1\" | awk '{ print $1 - int($1) }'\n    fi", "    local -r num=\"$1\"\n \
    \   echo \"${num}\" | awk -F \".\" '{ print $2 }'", "    echo \"$1\" | sed 's/\\\
    .[0-9]*//'", "    truncate_number=\"${1##*.}\"\n    echo \"$truncate_number\"",
  '    echo ${1#*.*}', "  if [[ $1 =~ ^[0-9]+\\.[0-9]+$ ]]; then\n    echo \"$1\"\
    \ | awk -F '.' '{print $2}'\n  else\n    echo \"ERROR: Argument '$1' is not a\
    \ valid floating point number.\"\n    exit 1\n  fi", "  echo \"$1\" | awk '{ split($1,\
    \ parts, \".\"); print \"0.\" parts[2] }'", "    [ \"$#\" -ne 1 ] && echo \"decimal_part:\
    \ invalid number of arguments\" && exit 1\n    echo $1 | awk -F \".\" '{print\
    \ $2}'", "    local number=${1}\n    local integer_part=$(cut -d \".\" -f 1 <<<\
    \ \"${number}\")\n    local decimal_part=$(cut -d \".\" -f 2 <<< \"${number}\"\
    )\n    if [ \"${decimal_part}\" = \"${number}\" ]; then\n        decimal_part=\"\
    0\"\n    fi\n    echo \"${decimal_part}\"", "    a=\"$1\"\n    echo \"($a - $(printf\
    \ \"%.0f\" $a))\" | bc -l | tr -d \"\\n\"", "    printf %.3f $(echo \"$1\" | awk\
    \ '{print $1 - int($1)}')", '    echo $1 | cut -d . -f 2 | head -c 2', "  # Using\
    \ printf and awk\n  printf %.6f $(echo \"$1\" | awk '{print $1 - int($1)}')",
  '  bc -l <<< "${1}-(${1}%1)"', "  echo \"$1\" | awk 'BEGIN {FS=\".\"}{print $2}'",
  "    # python '%f' fromatting discards the decimal part if it's 0\n    # example:\
    \ 1.0\n    local number=$(python -c \"print('%.10f' % ($1 - int($1)))\")\n   \
    \ if [ \"$number\" == '0.0000000000' ]; then\n        echo '0'\n    else\n   \
    \     echo \"$number\"\n    fi", "    echo \"$1\" | tr -d '-' | cut -d '.' -f\
    \ 2", '  echo "${1##*.}"', "    echo $1 | awk '{print substr($1, index($1, \"\
    .\") + 1)}'", "    echo $1 | awk '{\n        match($1, /^([[:digit:]]*)\\.([[:digit:]]*)$/,\
    \ m)\n        printf(\"0.%s\", m[2])\n    }'", "    local NUMBER=\"$1\"\n    echo\
    \ \"${NUMBER}\" | gawk 'match($0, /[0-9]+\\.[0-9]+/, ary) {print ary[0]}'", '  printf
    %.2f $(bc -l <<< "$1- ${1%.*}")', "  local fp=$1\n  local ip=$(printf \"%.0f\"\
    \ $fp)\n\n  echo $(echo \"$fp - $ip\" | bc -l)", "  echo \"$1 - $(echo \"$1\"\
    \ | awk '{printf(\"%d\", $1)}')\" | bc -l", '    echo "$1 - ${1%.*}" | bc -l',
  "    if [[ ! \"$1\" =~ ^[0-9]+([.][0-9]+)?$ ]]; then\n        echo -1\n        return\
    \ 1\n    fi\n    echo \"$1\" | awk -F'.' '{print $2}'", "    number=$1\n    c_number=${number%.*}\n\
    \    d_number=${number#*.}\n    result=\"0.${d_number}\"\n    echo \"$result\"",
  "    # TODO: when possible use bash math\n    local INTEGER=$(echo $1 | awk '{print\
    \ int($1)}')\n    echo $(echo \"$1 - $INTEGER\" | bc -l)", '    printf %.0f "$1"',
  "  echo $1 | awk '{print $1 - int($1)}'", '  echo ${1%.*}', "    echo $(echo $1\
    \ | sed -e 's/\\([0-9]*\\)\\..*/\\1/')", "  echo \"$1\" | gawk '{print $1-int($1)}'",
  "  local raw_result=\"$(echo \"$1\" | cut -d'.' -f 2)\"\n  local result=$(echo \"\
    $raw_result\" | tail -c 1)\n  if [ \"$result\" == \"0\" ]; then\n    result=$(echo\
    \ \"$raw_result\" | tail -c 2)\n  fi\n  echo \"$result\"", '  echo "${1##*.}"',
  "    number=\"$1\"\n    echo $(echo $number | cut -d '.' -f 2)", "  local number=\"\
    $1\"\n  echo \"$number\" | awk '{printf \"%s\", $1 - int($1)}'", "    num=$1\n\
    \    if [ -z \"$num\" ]; then\n        error \"truncate_number() requires a floating\
    \ point number\"\n        return 1\n    fi\n    # Get the integer part\n    int_part=$(echo\
    \ $num | cut -d '.' -f 1)\n    # Get the decimal part\n    decimal_part=$(echo\
    \ $num | cut -d '.' -f 2)\n    if [ -z \"$decimal_part\" ]; then\n        decimal_part=\"\
    0\"\n    fi\n    # Return the decimal part\n    echo $decimal_part", "    echo\
    \ \"$1\" | awk '{ printf(\"%s\", $1 - int($1)) }'", "    local number=\"$1\"\n\
    \    local integer_part=\"${number%.*}\"\n    local decimal_part=\"${number##*.}\"\
    \n    echo \"0.${decimal_part}\"", "    echo $1 | awk '{split($1,a,\".\"); print\
    \ \"0.\"a[2]}'", "    echo $1 | cut -d'.' -f2", '  echo "$1 - ${1%.*}" | bc -l',
  "    # Use bash builtin to truncate and get the integer part\n    local int_part=$(printf\
    \ \"%.0f\" \"$1\")\n    # Get the decimal part by substracting the integer part\n\
    \    echo \"$(bc <<< \"scale=1; $1 - $int_part\")\"", "    local result=$(echo\
    \ $1 | cut -d'.' -f2)\n    echo \"$result\"", "  local INTEGER=${1%.*}\n  local\
    \ FLOAT=$(echo $1-$INTEGER | bc)\n  echo $FLOAT", "  echo \"$1\" | awk '{printf\
    \ \"%.*f\",0,$1}'", "  float=$1\n  if [[ ${float//[0-9]/} == '.' ]]; then\n  \
    \  echo $float\n  else\n    echo ${float:0:$((${#float} - ${#1%.*}))}\n  fi",
  '    printf %.2f $(echo "scale=2; $1 - $(printf %.0f $1)" | bc)', "    local number\n\
    \    number=\"$1\"\n    local int_part\n    int_part=\"${number%.*}\"\n    echo\
    \ \"${number##$int_part}\"", "    local number=$1\n    echo $number | cut -d \"\
    .\" -f 2", "    echo $1 | awk '{printf \"%.*f\", 2, $1 - int($1)}'", "    if [[\
    \ $1 =~ ^[0-9]+\\.[0-9]+$ ]]; then\n        echo \"$1\" | sed 's/^[0-9]*\\.//'\n\
    \    else\n        echo 0\n    fi", "  if [ \"$#\" -ne 1 ]; then\n    echo \"\
    ERROR: $# illegal number of parameters\"\n    exit 1\n  fi\n  if ! [[ \"$1\" =~\
    \ ^[0-9]+([.][0-9]+)?$ ]]; then\n    echo \"ERROR: $1 is not a number\"\n    exit\
    \ 1\n  fi\n  echo $(echo \"$1\" | awk '{match($0,/[.]/); print substr($0,RSTART)}')",
  "  if [[ $1 =~ ^[0-9]+([.][0-9]+)?$ ]]; then\n    echo $1\n  else\n    echo '0'\n\
    \  fi", "    local number=\"$1\"\n    local -i integer_part decimal_part\n   \
    \ printf -v integer_part %.0f \"$number\"\n    decimal_part=$((number - integer_part))\n\
    \    printf %.2f \"$decimal_part\"", '    printf "%.4f" $1 | cut -d. -f2', '  echo
    $1 | grep -oP "^[0-9]+[.][0-9]+" | grep -oP "[.][0-9]+"', "  # create tmpfile\
    \ to store output\n  local TMP_FILE=$(mktemp)\n  local NUMBER=\"$1\"\n  # truncate\
    \ to int, then subtract from original number\n  echo \"$NUMBER\" | awk '{print\
    \ int($1)}' > $TMP_FILE\n  local INTEGER=$(cat $TMP_FILE)\n  local DECIMAL=$(echo\
    \ \"$NUMBER-$INTEGER\" | bc)\n  # return decimal part\n  echo \"$DECIMAL\"\n \
    \ # remove tmpfile\n  rm -f $TMP_FILE", "  echo $1 | sed -e 's/^[0-9]*\\.//'",
  '  printf "%.*f\n" 0 "$1"', "  echo \"$1\" | awk '{split($1,a,\".\"); print \"0.\"\
    a[2]}'", "    if [[ \"${1}\" == \"\" ]]; then\n        echo \"0\"\n    else\n\
    \        echo \"${1}\" | awk '{print $1 - int($1)}'\n    fi", "    if [ -z \"\
    $1\" ]; then\n        echo $1\n        return\n    fi\n    echo $(python -c \"\
    print '{0:.16f}'.format(float('$1')%1)\")", "    local -r number=\"$1\"\n    echo\
    \ \"${number}\" | awk -F \".\" '{ print $2 }'", "    echo \"$1\" | cut -d. -f2\
    \ | sed 's/^0*//'", "  number=$1\n  int_part=${number%.*}\n  decimal_part=${number#*.}\n\
    \  echo \"0.${decimal_part}\"", "  local n=\"$1\"\n  local truncated=\"${n%.*}\"\
    \n  local decimal=$(bc <<< \"scale=10; $n - $truncated\")\n  echo \"$decimal\"",
  "    local number=\"$1\"\n    local result=$(echo \"$number\" | awk '{split($0,a,\"\
    .\"); print a[2]}')\n    echo \"$result\"", "    declare -i DECIMAL_PART=${1#*.}\n\
    \    DECIMAL_PART=${DECIMAL_PART:-0}\n    echo \"0.$DECIMAL_PART\"", '    printf
    %.2f $(echo "scale=2; $1 - ${1%.*}" | bc);', "  echo $1 | cut -d '.' -f 2", '    printf
    "%.2f" "$(bc -l <<< "$1 - ${1/.*}")"', '  echo $1 - $(floor $1)', "    if [[ -z\
    \ \"$1\" ]]; then\n        return\n    fi\n    # Truncate the number (thanks to\
    \ absolute value) before decimal separator\n    # and subtract it from the original\
    \ number.\n    # We don't have to worry about negatives signs since absolute value\
    \ always\n    # returns positive numbers.\n    local truncated_value=$(echo \"\
    $1\" | awk '{printf(\"%.0f\", $1)}')\n    local result=$(echo \"scale=10; $1 -\
    \ $truncated_value\" | bc)\n    # Truncate decimals to avoid appending \"0.0000000001\"\
    \n    echo \"$result\" | awk '{printf(\"%.10f\", $1)}'", "    local num=${1}\n\
    \    local int_part=$(echo ${num} | cut -d \".\" -f 1)\n    local decimal_part=$(echo\
    \ ${num} | cut -d \".\" -f 2)\n    local decimals=\".${decimal_part}\"\n    echo\
    \ ${decimals}", '  printf "%.*f\n" 0 $1', "  local floating_point\n  floating_point=\"\
    $1\"\n  # echo \"$(($floating_point - ${floating_point%.*}))\"\n  echo \"$(echo\
    \ \"$floating_point - ${floating_point%.*}\" | bc)\"", '    printf "%0.3f" $(echo
    "$1 - $(printf "%d" $1)" | bc)', "  if [[ $1 =~ ^-?[0-9]+\\.?[0-9]*$ ]]; then\n\
    \    echo \"$1\" | awk -F. '{print $2}'\n  else\n    echo \"truncate_number: '$1'\
    \ is not a number\"\n    exit 1\n  fi", "    # First find integer part, then subtract\
    \ it from the original number\n    # (float - int = float)\n    echo $1 | awk\
    \ '{printf \"%f\", $1}' | awk '{printf \"%.*f\", split($1, arr, \".\"), $1 - arr[1]}'",
  "    echo \"$1\" | awk '{ split($1,a,\".\"); print \"0.\"a[2] }'", "    if [ $(is_number\
    \ \"$1\") -eq 0 ]; then\n        if [ $(is_float \"$1\") -eq 0 ]; then\n     \
    \       echo \"$1\" | awk -F. '{ print $2 }'\n        else\n            return\
    \ 1\n        fi\n    else\n        return 1\n    fi", "    integer_part=$(echo\
    \ \"$1\" | cut -d. -f1)\n    echo \"$1 - $integer_part\" | bc", "  if [ $# -eq\
    \ 0 ]; then\n    echo \"truncate_number requires one argument\"\n    exit\n  fi\n\
    \  echo \"$1\" | cut -d '.' -f 2", "  echo ${1} | awk '{print $1-int($1)}'", " \
    \   local number=\"$1\"\n    echo \"$number\" | awk '{ print $1 - int($1) }'",
  "  local truncated_part\n  truncated_part=$(echo $1 | awk '{print $1 - int($1)}')\n\
    \  echo $truncated_part", "    echo \"$1\" | awk '{ printf \"%s\\n\", $1 - int($1)\
    \ }'", "    local NUM=\"$1\"\n    local FLOOR_PART=\"$(floor_number \"$NUM\")\"\
    \n    local DECIMAL_PART=\"$(echo \"$NUM - $FLOOR_PART\" | bc -l)\"\n    echo\
    \ \"$DECIMAL_PART\"", "  if [[ \"$1\" =~ \".\" ]]; then\n    echo $1 | cut -d.\
    \ -f2\n  else\n    echo \"0\"\n  fi", '    printf %.2f $(echo "$1 % 1" | bc -l)',
  "    integer_part=$(echo \"$1\" | awk '{split($1,a,\".\"); print a[1]}')\n    local\
    \ remainder=$(echo \"$1 - $integer_part\" | bc)\n    printf %.4f \"$remainder\"",
  "  local number=\"$1\"\n  local integer_part=$(awk -v number=\"$number\" 'BEGIN\
    \ { print int(number); }')\n  local decimal_part=$(awk -v number=\"$number\" -v\
    \ integer_part=\"$integer_part\" 'BEGIN { print number - integer_part; }')\n \
    \ echo \"$decimal_part\"", "    echo $1 | awk '{split($1, a, \".\"); print \"\
    0.\"a[2]}'", "  local floating_number=\"$1\"\n  echo ${floating_number} | awk\
    \ -F \".\" '{print $2}'", "    number=$1\n    integer_part=${number%.*}\n    decimal_part=${number#*.}\n\
    \    echo \"$decimal_part\"", "    if [[ $1 =~ ([0-9]*)\\.([0-9]+) ]]; then\n\
    \        echo 0.${BASH_REMATCH[2]}\n    else\n        echo \"0.0\"\n    fi", " \
    \   printf \"%.3f\" $(bc -l <<< \"scale=3; $1-(${1%.*})\" | tr -d '\\n')", " \
    \ if [[ $1 == *.* ]]; then\n    local -i integer=${1%.*}\n    local decimals=$(echo\
    \ \"$1 - $integer\" | bc)\n    echo \"$decimals\"\n  else\n    echo \"0\"\n  fi",
  "    local number=\"$1\"\n    local integer_part=\"${number%.*}\"\n    local decimals=\"\
    $(bc <<< \"scale=2; $number - $integer_part\")\"\n    echo \"$decimals\"", " \
    \   echo $1 | awk '{ printf \"%.4f\", $1 - int($1) }'", "  local float_number=${1}\n\
    \  echo ${float_number} | sed -E 's/^[^.]+\\.//'", "    set +u\n    if [[ -z \"\
    $1\" ]]; then\n        echo \"No number provided\" >&2\n        exit 1\n    fi\n\
    \    set -u\n    local number=\"$1\"\n    local integer_part=$(echo $number |\
    \ awk -F'.' '{print $1}')\n    local decimal_part=$(echo $number | awk -F'.' '{print\
    \ $2}')\n    local decimal_part_dec=\"0.$decimal_part\"\n    echo \"$decimal_part_dec\"",
  "    echo \"$1\" | tr \",\" \".\" | awk '{if ($1>=0) printf \"%.4f\", $1-(int($1));\
    \ else printf \"%.4f\", $1-(int($1)-1);}'", "  local D=$(echo \"$1\" | sed -e\
    \ 's/\\.[0-9]*//g')\n  local I=$(echo \"$1 - $D\" | bc)\n  echo \"$I\"", '    awk
    "BEGIN { printf \"%.2f\", $1 - int($1) }"', "  local i\n  for i in {1..10}; do\n\
    \    number=$(echo \"$1 - $i\" | bc)\n    if [[ \"$number\" == *.* ]]; then\n\
    \      continue\n    else\n      echo \"$1 - $i\" | bc\n      break\n    fi\n\
    \  done", "    echo $1 | awk '{print $1 - int($1)}'", "    # Get integer part\n\
    \    # Transform to integer\n    # Subtract from $1\n    printf %.2f \"$(echo\
    \ \"($1 - $(echo $1 | cut -d . -f 1))\" | bc -l)\"", "  local number=$1\n  number=$(echo\
    \ \"$number\" | cut -d\".\" -f2)\n  echo \"$number\"", '  echo "${1##*.}"', " \
    \ local decimals=$(echo \"scale=10;$1-($1|0)\" | bc)\n  echo $decimals", "  echo\
    \ $(awk -v num=\"$1\" 'BEGIN{print num-int(num)}')", "    local float_num\n  \
    \  float_num=\"$1\"\n    echo $float_num | awk '{printf \"%.*f\", 0, $1}'", " \
    \   echo \"$1\" | awk '{ split($1, a, \".\"); printf(\"0.%s\", a[2]); }'", '    echo
    $1 - $(printf "%.0f" $1)', '    printf "%0.f" $1', "    local i=\"${1}\"\n   \
    \ echo -n \"${i}\" | awk '{printf \"%f\", $1 - int($1)}'", "  local number=$1\n\
    \  local integer_part=$(echo \"${number}\" | cut -d \".\" -f 1)\n  local decimals=$(echo\
    \ \"${number}\" | cut -d \".\" -f 2)\n  local n=$(echo \"${number} - ${integer_part}\"\
    \ | bc)\n  echo \"${n}\"", '  echo $1 | cut -d "." -f 2', "    local num=$1\n\
    \    local int_part=$(int_part \"$num\")\n    local dec_part=$(echo \"$num - $int_part\"\
    \ | bc)\n    if [ \"$dec_part\" == \"0\" ]; then\n        echo \"0\"\n    else\n\
    \        echo \"$dec_part\"\n    fi", "  local truncated_number\n  truncated_number=$(echo\
    \ $1 | awk '{printf(\"%f\",$1 - int($1))}')\n  echo \"$truncated_number\"", '  echo
    "${1##*.}"', "    local value=$1\n    local truncated=$(echo $value | cut -d '.'\
    \ -f 1)\n    local remain=$(echo $value | cut -d '.' -f 2)\n    # Check if no\
    \ decimal part is present\n    if [ -z \"$remain\" ]; then\n        echo \"0\"\
    \n    else\n        echo \"0.$remain\"\n    fi", "  local -r number=$1\n  echo\
    \ \"$number\" | awk -F '.' '{print $2}'", '  echo "$1 - $(printf "%.0f" $1)" |
    bc', "    echo \"$1\" | awk '{ printf \"%.*f\", NF-1, $0 }'", "    local -r number=$1\n\
    \    local -r int_part=${number%.*}\n    local -r decimal_part=${number#$int_part}\n\
    \    echo $decimal_part", '  echo $(bc -l <<< "$1 - ${1%.*}")', '  echo ${1%.*}',
  "    local number=$1\n    local int_part=$(int_part \"$number\")\n    local dec_part=$(dec_part\
    \ \"$number\")\n    echo $dec_part"]
stop_tokens:
- "\n}"
