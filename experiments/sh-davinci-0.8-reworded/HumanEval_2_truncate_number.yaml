name: HumanEval_2_truncate_number
language: sh
prompt: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
  \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
  # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
  # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
  \ {\n"
tests: "}\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n\
  \    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\"\
  \ ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
completions: ["  echo $1 | awk '{n=split($1,a,\".\"); print a[2]}'", "    local number=$1\n\
    \    number=${number%.*}\n    echo $number", "    local num=$1\n    local -i intPart\n\
    \    intPart=${num%.*}\n    echo $((num-intPart))", "    local float=$1\n    local\
    \ decimal=$(awk -v float=$float 'BEGIN {\n        split(float, array, \".\")\n\
    \        printf \"%s\", array[2]\n    }')\n    echo $decimal", "    truncate=\"\
    ${1%.*}\"\n    printf \"%0.2f\" $(echo \"$1 - $truncate\" | bc -l)", "    echo\
    \ $1 | awk '{split($1,a,\".\"); print a[2]}'", '    printf "%.*f\n" 0 $1', " \
    \ local number=\"$1\"\n  local integer_part=$(echo \"$number\" | cut -d'.' -f1)\n\
    \  local decimal_part=$(echo \"$number\" | cut -d'.' -f2)\n  if [ -z \"$decimal_part\"\
    \ ]; then\n    echo \"0\"\n  else\n    echo \"0.$decimal_part\"\n  fi", "  number=${1}\n\
    \  echo \"${number}\" | grep -o \"^[0-9]*\\.[0-9]*\"", "  local INTEGER=$(echo\
    \ $1 | cut -d. -f1)\n  local NUMBER=\"0.$(echo $1 | cut -d. -f2)\"\n  local FLOAT=$(python\
    \ -c \"print float($NUMBER)\")\n  echo $FLOAT", "    echo \"$1\" | awk '{printf(\"\
    %0.2f\", $1)}'", "    echo \"$1\" | awk '{printf \"%f\", $1}' | awk -F\".\" '{print\
    \ \"0.\"$2}'", "    if [ $# -ne 1 ]; then\n        error \"truncate_number():\
    \ requires 1 argument\"\n        return 1\n    fi\n    if ! check_is_float \"\
    $1\"; then\n        error \"truncate_number(): argument \\\"$1\\\" is not a float\"\
    \n        return 1\n    fi\n    local x=\"$1\"\n    local integral=${x%.*}\n \
    \   local decimal=${x#*.}\n    local result=$(echo \"scale=4; $decimal / 1\" |\
    \ bc)\n    echo $result", "    float=\"$1\"\n    integer_part=$(python3 -c \"\
    print(int($float))\")\n    float=$(python3 -c \"print($float - $integer_part)\"\
    )\n    echo \"$float\"", "    # Assume number is of the form 0.xxx\n    DECIMAL_PART=$(echo\
    \ $1 | cut -d \".\" -f 2)\n    echo \"0.$DECIMAL_PART\"", '  echo $(bc -l <<<
    "$1 - $(echo "$1" | cut -d "." -f 1)" | bc -l)', "    local number=\"$1\"\n  \
    \  # Let's use awk...\n    echo \"$number\" | awk '{ printf \"%.3f\", $1 - int($1)\
    \ }'", "    echo $1 | cut -d '.' -f 2", "  if [[ \"$1\" =~ ^[+-]?[0-9]+\\.?[0-9]*$\
    \ ]]; then\n    # drop the integer part\n    echo \"$1\" | grep -o -E '\\.[0-9]+'\
    \ | sed 's/^\\.//'\n  else\n    echo \"$1\"\n  fi", "    local -r number=\"$1\"\
    \n    local -r integer_part=\"${number%.*}\"\n\n    printf \"%0.3f\" $(bc <<<\
    \ \"$number - $integer_part\")"]
stop_tokens:
- "\n}"
