name: HumanEval_48_is_palindrome
language: sh
prompt: "#!/bin/bash\n# Checks if given string is a palindrome\n# >>> $(is_palindrome\
  \ \"\")\n# \"true\"\n# >>> $(is_palindrome \"aba\")\n# \"true\"\n# >>> $(is_palindrome\
  \ \"aaaaa\")\n# \"true\"\n# >>> $(is_palindrome \"zbcd\")\n# \"false\"\n#\n# $1\
  \ is a string\nis_palindrome() {\n"
tests: "}\n\ncandidate() {\n    is_palindrome \"$@\"\n}\n\nset -e\nrun_test() {\n\
  \    [[ $(candidate \"\") = \"true\" ]]\n    [[ $(candidate \"aba\") = \"true\"\
  \ ]]\n    [[ $(candidate \"aaaaa\") = \"true\" ]]\n    [[ $(candidate \"zbcd\")\
  \ = \"false\" ]]\n    [[ $(candidate \"xywyx\") = \"true\" ]]\n    [[ $(candidate\
  \ \"xywyz\") = \"false\" ]]\n    [[ $(candidate \"xywzx\") = \"false\" ]]\n}\n\n\
  run_test"
completions: ["    local string=$1\n    local i=0\n    local j=$((${#string} - 1))\n\
    \    while [ $i -lt $j ]; do\n        [ \"${string:$i:1}\" == \"${string:$j:1}\"\
    \ ] || return 1\n        i=$((i + 1))\n        j=$((j - 1))\n    done\n    return\
    \ 0", "  local str=$1\n  if [ -z \"$str\" ]; then\n    echo \"true\"\n  else\n\
    \    local fst=$(echo \"$str\" | head -c 1)\n    local lst=$(echo \"$str\" | tail\
    \ -c 2)\n    if [ \"$fst\" == \"$lst\" ]; then\n      local middle=$(echo \"$str\"\
    \ | tail -c +2 | head -c -1)\n      $(is_palindrome \"$middle\")\n    else\n \
    \     echo \"false\"\n    fi\n  fi", "  set +e\n  local string=\"$1\"\n  local\
    \ result=\"true\"\n  local first_half=\"\"\n  local second_half=\"\"\n  # check\
    \ for empty string\n  if [ -z \"$string\" ]; then\n    result=\"true\"\n  # check\
    \ if number of letters is odd\n  elif [ $(( ${#string} % 2 )) -eq 1 ]; then\n\
    \    first_half=$(echo \"$string\" | sed 's/^\\(.\\{1\\}\\).*$/\\1/')\n    second_half=$(echo\
    \ \"$string\" | sed 's/^.\\{1\\}\\(.*\\)$/\\1/')\n    second_half=$(echo \"$second_half\"\
    \ | rev)\n    if [ \"$first_half\" != \"$second_half\" ]; then\n      result=\"\
    false\"\n    fi\n  # check if number of letters is even\n  else\n    first_half=$(echo\
    \ \"$string\" | sed 's/^\\(.\\{1\\}\\).*$/\\1/')\n    second_half=$(echo \"$string\"\
    \ | sed 's/^.\\{1\\}\\(.*\\)$/\\1/')\n    second_half=$(echo \"$second_half\"\
    \ | rev)\n    if [ \"$first_half\" != \"$second_half\" ]; then\n      result=\"\
    false\"\n    fi\n  fi\n  set -e\n  echo \"$result\"", "  if [ -z \"$1\" ]; then\n\
    \    echo \"true\"\n  else\n    local first=$(echo \"$1\" | cut -c 1)\n    local\
    \ last=$(echo \"$1\" | cut -c $(expr $(expr length \"$1\") - 1) || echo ' ')\n\
    \    if [ \"$first\" != \"$last\" ]; then\n      echo \"false\"\n    else\n  \
    \    is_palindrome \"$(echo \"$1\" | cut -c 2-$(expr $(expr length \"$1\") - 2))\"\
    \n    fi\n  fi", "  if [ -z \"$1\" ]; then\n    echo \"true\"\n  else\n    local\
    \ first_char=\"${1:0:1}\"\n    local last_char=\"${1: -1}\"\n    if [ \"$first_char\"\
    \ != \"$last_char\" ]; then\n      echo \"false\"\n    else\n      local remaining=\"\
    ${1:1: -1}\"\n      is_palindrome \"$remaining\"\n    fi\n  fi", "    input=\"\
    $1\"\n    if [[ -z \"${input}\" ]]; then\n        echo \"true\"\n    elif [[ \"\
    ${input:0:1}\" == \"${input:${#input}-1:1}\" ]]; then\n        is_palindrome \"\
    ${input:1:${#input}-2}\"\n    else\n        echo \"false\"\n    fi", "  local\
    \ input=$1\n\n  for (( i=0; i<${#input}/2; i++ )); do\n    if [[ \"${input:$i:1}\"\
    \ != \"${input: -$(( $i + 1 )):1}\" ]]; then\n      echo \"false\"\n      return\n\
    \    fi\n  done\n\n  echo \"true\"", "    string=$1\n    len=${#string}\n    if\
    \ [ \"$len\" -eq 0 ]; then\n        echo \"true\"\n        return\n    fi\n  \
    \  if [ \"$len\" -eq 1 ]; then\n        echo \"true\"\n        return\n    fi\n\
    \    if [ \"$len\" -eq 2 ]; then\n        echo \"$(is_equal_char \"${string:0:1}\"\
    \ \"${string:1:1}\")\"\n        return\n    fi\n    if [ \"$(is_equal_char \"\
    ${string:0:1}\" \"${string:$(($len-1)):1}\")\" == \"false\" ]; then\n        echo\
    \ \"false\"\n        return\n    fi\n    echo \"$(is_palindrome \"${string:1:$(($len-2))}\"\
    )\"", "  local original=${1}\n  local reverse=$(echo ${original} | rev)\n  if\
    \ [[ \"${original}\" == \"${reverse}\" ]]; then\n    echo \"true\"\n  else\n \
    \   echo \"false\"\n  fi", "    local rev_str=$(reverse_string \"$1\")\n    [\
    \ \"$1\" == \"$rev_str\" ] && echo \"true\" || echo \"false\"", "    local string=\"\
    $1\"\n    local reversed_string=$(reverse_string \"$string\")\n    [[ \"$string\"\
    \ == \"$reversed_string\" ]] && echo \"true\" || echo \"false\"", "  # remove\
    \ all non-word characters from the string\n  # e.g. a comma, space or dot is removed\n\
    \  local normalized_string=\"$(echo \"$1\" | sed -E 's/[^[:alnum:]]//g')\"\n \
    \ # convert the string to lowercase\n  local lower_string=\"$(echo \"$normalized_string\"\
    \ | tr '[:upper:]' '[:lower:]')\"\n  # reverse the string\n  local reversed_string=\"\
    $(echo \"$lower_string\" | rev)\"\n  # compare the original string with the reversed\
    \ string\n  if [ \"$lower_string\" == \"$reversed_string\" ]; then\n    echo \"\
    true\"\n  else\n    echo \"false\"\n  fi", "    # You'll need to modify this function\n\
    \    if [[ \"${1:0:1}\" == \"${1: -1}\" ]]; then\n        echo \"true\"\n    else\n\
    \        echo \"false\"\n    fi", "    s=$1\n    for (( i=0; i<${#s}/2; i++ ));\
    \ do\n        [[ \"${s:i:1}\" != \"${s: -i-1:1}\" ]] && return 1\n    done\n \
    \   return 0", "    check_not_empty \"$1\"\n    local _string=$1\n    local _reverse=\"\
    \"\n    for (( i=${#_string}-1; i>=0; i-- )); do\n        _reverse+=${_string:$i:1}\n\
    \    done\n    if [[ \"$_string\" == \"$_reverse\" ]]; then\n        echo \"true\"\
    \n    else\n        echo \"false\"\n    fi", "    local str=$1;\n    local end=${#str};\n\
    \    local i=0;\n    local mid=0;\n    local has_odd_chars=0;\n    if [[ $(($end\
    \ % 2)) -ne 0 ]]; then\n        has_odd_chars=1;\n    fi;\n    if [[ $end -eq\
    \ 0 ]]; then\n        echo \"true\";\n        return;\n    fi;\n    mid=$(($end\
    \ / 2));\n    for ((i=0; i<mid; i++)); do\n        if [[ ${str:$i:1} != ${str:$((end\
    \ - i - 1)):1} ]]; then\n            echo \"false\";\n            return;\n  \
    \      fi;\n    done;\n    if [[ $has_odd_chars -eq 1 ]]; then\n        mid=$(($mid\
    \ + 1));\n    fi;\n    for ((i=mid; i<end; i++)); do\n        if [[ ${str:$i:1}\
    \ != ${str:$((end - i - 1)):1} ]]; then\n            echo \"false\";\n       \
    \     return;\n        fi;\n    done;\n    echo \"true\";", "    local str=$1\n\
    \    local len=${#str}\n    local idx\n    local char\n\n    for ((idx=0; idx<len/2;\
    \ idx++)); do\n        char=${str:idx:1}\n        if [[ $char != ${str:$((len-idx-1)):1}\
    \ ]]; then\n            echo \"false\"\n            return\n        fi\n    done\n\
    \n    echo \"true\"", "  _is_palindrome_val=\"$1\"\n  if [[ \"${_is_palindrome_val}x\"\
    \ == \"x\" ]]; then\n    echo \"true\"\n  else\n    if [[ \"${_is_palindrome_val}\"\
    \ == \"$(rev <<< \"${_is_palindrome_val}\")\" ]]; then\n      echo \"true\"\n\
    \    else\n      echo \"false\"\n    fi\n  fi", "    local reverse=$(rev <<< \"\
    $1\")\n    if [[ \"$1\" == \"$reverse\" ]]; then\n        echo \"true\"\n    else\n\
    \        echo \"false\"\n    fi", "  if [ $# -ne 1 ]; then\n    echo \"Usage:\
    \ is_palindrome <string>\" >&2\n    return 1\n  fi\n\n  local s=$1\n  local len=${#s}\n\
    \  local mid=$(( len / 2 ))\n  local reversed=$(rev <<< \"$s\")\n\n  for (( i\
    \ = 0; i < mid; i++ )); do\n    if [ \"${s:$i:1}\" != \"${reversed:$i:1}\" ];\
    \ then\n      echo \"false\"\n      return\n    fi\n  done\n\n  echo \"true\""]
stop_tokens:
- "\n}"
