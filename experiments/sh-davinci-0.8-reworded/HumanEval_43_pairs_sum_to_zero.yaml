name: HumanEval_43_pairs_sum_to_zero
language: sh
prompt: "#!/bin/bash\n# pairs_sum_to_zero takes a list of integers as an input.\n\
  # it returns true if there are two distinct elements in the list that\n# sum to\
  \ zero, and false otherwise.\n# >>> $(pairs_sum_to_zero \"1 3 5 0\")\n# \"false\"\
  \n# >>> $(pairs_sum_to_zero \"1 3 -2 1\")\n# \"false\"\n# >>> $(pairs_sum_to_zero\
  \ \"1 2 3 7\")\n# \"false\"\n# >>> $(pairs_sum_to_zero \"2 4 -5 3 5 7\")\n# \"true\"\
  \n# >>> $(pairs_sum_to_zero \"1\")\n# \"false\"\n#\n# $1 is a space-separated list\n\
  pairs_sum_to_zero() {\n"
tests: "}\n\ncandidate() {\n    pairs_sum_to_zero \"$@\"\n}\n\nset -e\nrun_test()\
  \ {\n    [[ $(candidate \"1 3 5 0\") = \"false\" ]]\n    [[ $(candidate \"1 3 -2\
  \ 1\") = \"false\" ]]\n    [[ $(candidate \"1 2 3 7\") = \"false\" ]]\n    [[ $(candidate\
  \ \"2 4 -5 3 5 7\") = \"true\" ]]\n    [[ $(candidate \"1\") = \"false\" ]]\n  \
  \  [[ $(candidate \"-3 9 -1 3 2 30\") = \"true\" ]]\n    [[ $(candidate \"-3 9 -1\
  \ 3 2 31\") = \"true\" ]]\n    [[ $(candidate \"-3 9 -1 4 2 30\") = \"false\" ]]\n\
  \    [[ $(candidate \"-3 9 -1 4 2 31\") = \"false\" ]]\n}\n\nrun_test"
completions: ["    if [[ $# -eq 0 ]]; then\n        return\n    fi\n    if [[ $# -eq\
    \ 1 ]]; then\n        echo \"false\"\n        return\n    fi\n    local sum=$1\n\
    \    shift\n    pairs_sum_to_zero_helper $sum $@", "    if [[ $# -lt 2 ]]; then\n\
    \        echo false\n        return\n    fi\n    list=$(echo $@ | tr ' ' '\\n'\
    \ | sort -n)\n    head=$(echo \"$list\" | head -n 1)\n    tail=$(echo \"$list\"\
    \ | tail -n +2)\n    if [[ \"$head\" == \"0\" ]]; then\n        echo true\n  \
    \      return\n    fi\n    if [[ \"$head\" -lt 0 ]]; then\n        pairs_sum_to_zero\
    \ $(echo \"$tail\" | tr '\\n' ' ')\n    else\n        if [[ $(echo \"$tail\" |\
    \ grep -c -w \"$((-1 * $head))\") -gt 0 ]]; then\n            echo true\n    \
    \        return\n        else\n            pairs_sum_to_zero $(echo \"$tail\"\
    \ | tr '\\n' ' ')\n        fi\n    fi", "  if [[ $# -eq 0 ]]; then\n    echo false\n\
    \    return 0\n  fi\n  for (( i = 1; i < $#; i++ )); do\n    for (( j = i+1; j\
    \ <= $#; j++ )); do\n      if [[ $((${@:i:1} + ${@:j:1})) -eq 0 ]]; then\n   \
    \     echo true\n        return 0\n      fi\n    done\n  done\n  echo false",
  '  # TODO: your code here', "  LIST=( $1 )\n  for i in \"${LIST[@]}\"; do\n    for\
    \ j in \"${LIST[@]}\"; do\n      if [ $(($i + $j)) -eq 0 ] && [ $i -ne $j ]; then\n\
    \        echo \"true\"\n        return\n      fi\n    done\n  done\n  echo \"\
    false\"", "  sort_items=$(echo $1 | tr \" \" \"\\n\" | sort -n)\n  items=($sort_items)\n\
    \  length=${#items[@]}\n  min_index=0\n  max_index=$((length - 1))\n  while ((\
    \ $min_index < $max_index )); do\n    # echo ${items[$min_index]} ${items[$max_index]}\n\
    \    sum=$((items[$min_index] + items[$max_index]))\n    if (( sum == 0 )); then\n\
    \      echo \"true\"\n      return\n    elif (( sum < 0 )); then\n      min_index=$((min_index\
    \ + 1))\n    else\n      max_index=$((max_index - 1))\n    fi\n  done\n  echo\
    \ \"false\"", "  # loop through the numbers\n  for i in $1; do\n    # loop through\
    \ the remaining numbers\n    for j in $1; do\n      # if a pair sums to zero and\
    \ they are distinct\n      if [[ $((i + j)) -eq 0 && $i -ne $j ]]; then\n    \
    \    # print \"true\" and exit\n        echo \"true\"\n        exit\n      fi\n\
    \    done\n  done\n  # print \"false\" and exit\n  echo \"false\"\n  exit", " \
    \   pos_nums=$(echo $1 | tr \" \" \"\\n\" | grep -E \"^[0-9]+$\" | sort -n)\n\
    \    neg_nums=$(echo $1 | tr \" \" \"\\n\" | grep -E \"^-[0-9]+$\" | sort -r -n)\n\
    \    while [[ \"$pos_nums\" != \"\" && \"$neg_nums\" != \"\" ]]; do\n        pos_num=$(echo\
    \ $pos_nums | cut -d\" \" -f1)\n        neg_num=$(echo $neg_nums | cut -d\" \"\
    \ -f1)\n        if [ $pos_num -eq $((0 - $neg_num)) ]; then\n            echo\
    \ \"true\"\n            return\n        elif [ $pos_num -gt $((0 - $neg_num))\
    \ ]; then\n            neg_nums=$(echo $neg_nums | cut -d\" \" -f2-)\n       \
    \ else\n            pos_nums=$(echo $pos_nums | cut -d\" \" -f2-)\n        fi\n\
    \    done\n    echo \"false\"", "    # YOUR CODE HERE\n    for i in $1\n    do\n\
    \        if [[ $(echo $1 | grep -o -w -e $i | wc -l) -gt 1 ]]\n        then\n\
    \            if [[ $(echo \"scale=1; $i/2\" | bc) -eq $(echo $i/2 | bc) ]]\n \
    \           then\n                return 1\n            fi\n        fi\n    done\n\
    \    return 0", "\t# parse the input string into an array of integers\n\tin_array=($1)\n\
    \t# sort the array\n\tin_array_sorted=($(echo ${in_array[@]} | tr \" \" \"\\n\"\
    \ | sort -n))\n\t# use a binary search to find the complements of the elements\n\
    \t# in the array.\n\tfor elem in ${in_array_sorted[@]}; do\n\t\tcomplement=$((0\
    \ - elem))\n\t\tif binary_search ${complement} ${in_array_sorted[@]}; then\n\t\
    \t\treturn 0\n\t\tfi\n\tdone\n\treturn 1", "  sum=0\n  for i in $1; do\n    #\
    \ TODO: Task 1: write a loop that scans the input string to see\n    # if it contains\
    \ any pair of elements that sum to zero\n    # If you find a pair of elements\
    \ that sum to zero, set the\n    # 'sum' variable to zero and break out of the\
    \ loop.\n    ...\n  done\n  if [ $sum -eq 0 ]; then\n    echo \"true\"\n  else\n\
    \    echo \"false\"\n  fi", "    pairs_sum_to_zero_helper() {\n        if [ \"\
    $#\" -eq 1 ]; then\n            return 1\n        fi\n        target=$1\n    \
    \    shift\n        for n in $@; do\n            if [ $n -eq $target ]; then\n\
    \                continue\n            fi\n            if [ $n -eq $((-1 * $target))\
    \ ]; then\n                return 0\n            fi\n        done\n        return\
    \ 1\n    }\n    for n in $@; do\n        pairs_sum_to_zero_helper $n $@\n    \
    \    if [ $? -eq 0 ]; then\n            echo \"true\"\n            return\n  \
    \      fi\n    done\n    echo \"false\"", "  target=$1\n  shift\n  while test\
    \ $# -gt 0; do\n    if test -n \"$(echo \"$target\" | grep -w $((-$1)))\"\n  \
    \  then\n      echo \"true\"\n      return\n    fi\n    shift\n  done\n  echo\
    \ \"false\"", "    # Write your implementation below\n    local input=\"$1\"\n\
    \    local all_nums=(${input})\n    local len=${#all_nums[@]}\n    local neg_arr=()\n\
    \    local pos_arr=()\n    local hash_table=()\n    local hash_table_neg=()\n\
    \    local cur_num=0\n    local cur_neg_num=0\n    local ans=false\n    for ((i=0;\
    \ i<$len; i++)); do\n        cur_num=${all_nums[$i]}\n        if [ $cur_num -lt\
    \ 0 ]; then\n            hash_table_neg[$cur_num]=$i\n            neg_arr=(\"\
    ${neg_arr[@]}\" $cur_num)\n        else\n            hash_table[$cur_num]=$i\n\
    \            pos_arr=(\"${pos_arr[@]}\" $cur_num)\n        fi\n    done\n    for\
    \ ((i=0; i<${#neg_arr[@]}; i++)); do\n        cur_neg_num=${neg_arr[$i]}\n   \
    \     if [ -n \"${hash_table[$((-1*$cur_neg_num))]}\" ]; then\n            ans=true\n\
    \            break\n        fi\n    done\n    if [ \"$ans\" = true ]; then\n \
    \       echo \"true\"\n    else\n        echo \"false\"\n    fi", "  # This function\
    \ will only work for integers in the range of (-2^32, 2^32)\n  # as bash does\
    \ not support 64 bit integers\n  #\n  # This is probably the easiest solution\
    \ that avoids loops in bash,\n  # and is still pretty fast. It's not the most\
    \ readable solution, though.\n  #\n  # First, we take the list of integers, and\
    \ sort them numerically.\n  # Then, we pipe that list of sorted integers into\n\
    \  # `awk` which runs an awk script.\n  # The awk script we're using is one that\
    \ I wrote that you can find\n  # in this repo. The script takes a list of integers\
    \ as an input,\n  # and outputs true if there are two distinct elements in the\
    \ list that\n  # sum to zero, and false otherwise.\n  #\n  # The awk script itself\
    \ is a one-liner.\n  # It's pretty fast, and it's easier than trying to do it\
    \ all in bash.\n  #\n  # This script is using two commands that are not enabled\
    \ by default in\n  # the OSX version of awk.\n  # It does run on Linux, though.\n\
    \  # It's a little bit faster in awk on linux, but not by a lot.\n  #\n  # This\
    \ is the fastest way I could think of to write this.\n  # It's not too much slower\
    \ than the python version.\n  # You can run `bash time.sh` to see how it compares\
    \ on your machine.\n  #\n  # Given more time, I'd probably write a C program that\
    \ would run this.\n  # It would be the fastest. It would be quite a bit of work,\
    \ though.\n  echo \"$1\" | tr ' ' '\\n' | sort -n | \\\n    awk -f ./pairs_sum_to_zero.awk",
  "    local input=($1)\n    local hash_map\n    local sum=0\n    local len=${#input[@]}\n\
    \    local i=0\n    while (( i < len )); do\n        ((sum=input[i]))\n      \
    \  if [[ ${hash_map[sum]} ]]; then\n            return 0\n        fi\n       \
    \ ((hash_map[-sum]=1))\n        ((i++))\n    done\n    return 1", "    while [\
    \ -n \"$1\" ]; do\n        n=$1\n        (( l=$n * -1 ))\n        shift\n    \
    \    for i in $@; do\n            if [ \"$i\" -eq \"$l\" ]; then\n           \
    \     echo \"true\"\n                return\n            fi\n        done\n  \
    \  done\n    echo \"false\"", "\tlocal arr\n\tIFS=' ' read -r -a arr <<< \"$1\"\
    \n\tlocal len=${#arr[@]}\n\tfor i in $(seq 0 $((len-1))); do\n\t\tfor j in $(seq\
    \ 0 $((len-1))); do\n\t\t\tif [ $i -ne $j ] && (( ${arr[$i]} + ${arr[$j]} == 0\
    \ )); then\n\t\t\t\techo \"true\"\n\t\t\t\treturn\n\t\t\tfi\n\t\tdone\n\tdone\n\
    \techo \"false\"", "  # TODO: your code here\n  local status\n  status=\"false\"\
    \n  for i in \"$@\"\n  do\n    for j in \"$@\"\n    do\n      if [ $((i+j)) -eq\
    \ 0 ] && [ $i -ne $j ]\n      then\n        status=\"true\"\n      fi\n    done\n\
    \  done\n  echo \"$status\"", "  declare -A ints\n\n  for i in $1; do\n    ints[$i]=1\n\
    \  done\n\n  for i in $1; do\n    if [[ \"${ints[-$i]}\" == \"1\" ]]; then\n \
    \     echo \"true\"\n      return\n    fi\n  done\n\n  echo \"false\""]
stop_tokens:
- "\n}"
