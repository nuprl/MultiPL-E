name: HumanEval_77_iscube
language: sh
prompt: "#!/bin/bash\n# Write a function that takes an integer a and returns true\
  \ \n# if this ingeger is a cube of some integer number.\n# Note: you may assume\
  \ the input is always valid.\n# Examples:\n# >>> $(iscube \"1\")\n# \"true\"\n#\
  \ >>> $(iscube \"2\")\n# \"false\"\n# >>> $(iscube \"-1\")\n# \"true\"\n# >>> $(iscube\
  \ \"64\")\n# \"true\"\n# >>> $(iscube \"0\")\n# \"true\"\n# >>> $(iscube \"180\"\
  )\n# \"false\"\n#\n# $1 is an integer\niscube() {\n"
tests: "}\n\ncandidate() {\n    iscube \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
  \ \"1\") = \"true\" ]]\n    [[ $(candidate \"2\") = \"false\" ]]\n    [[ $(candidate\
  \ \"-1\") = \"true\" ]]\n    [[ $(candidate \"64\") = \"true\" ]]\n    [[ $(candidate\
  \ \"180\") = \"false\" ]]\n    [[ $(candidate \"1000\") = \"true\" ]]\n    [[ $(candidate\
  \ \"0\") = \"true\" ]]\n    [[ $(candidate \"1729\") = \"false\" ]]\n}\n\nrun_test"
completions: ["\ta=$1\n\tif [ $a -le 0 ]; then\n\t\techo \"true\"\n\telse\n\t\tt=$(echo\
    \ \"scale=2;sqrt($a)\" | bc)\n\t\tt1=$(echo \"$t*$t*$t\" | bc)\n\t\tif [ $t1 ==\
    \ $a ]; then\n\t\t\techo \"true\"\n\t\telse\n\t\t\techo \"false\"\n\t\tfi\n\t\
    fi", "    local integer=$1\n    if [[ $integer -eq 0 ]]; then\n        echo \"\
    true\"\n    elif [[ $integer -lt 0 ]]; then\n        # Cube of an integer can't\
    \ be negative.\n        echo \"false\"\n    else\n        # Check if cube root\
    \ of the integer is a whole number.\n        local root=$(bc <<< \"scale=0; ($integer)^(1/3)\"\
    )\n        local cube=$(bc <<< \"$root*$root*$root\")\n        [[ $cube -eq $integer\
    \ ]] && echo \"true\" || echo \"false\"\n    fi", "    num=$1\n    if [ $num -eq\
    \ 0 ]; then\n        echo \"true\"\n    else\n        if [ $num -gt 0 ]; then\n\
    \            (( num = sqrt(num) ))\n            (( num = num * num * num ))\n\
    \            if [ $num -eq $1 ]; then\n                echo \"true\"\n       \
    \     else\n                echo \"false\"\n            fi\n        else\n   \
    \         (( num = sqrt(-num) ))\n            (( num = num * num * num ))\n  \
    \          if [ $num -eq $1 ]; then\n                echo \"true\"\n         \
    \   else\n                echo \"false\"\n            fi\n        fi\n    fi",
  "    # Write your solution here\n    number=$1\n    if [ $number -le 0 ]; then\n\
    \        echo true\n    else\n        if [[ $number -eq $(echo \"scale=10; $number\
    \ ^ (1/3)\" | bc) ]]; then\n            echo true\n        else\n            echo\
    \ false\n        fi\n    fi", "\tif (( (($1 ** (1 / 3)) * ($1 ** (1 / 3)) * ($1\
    \ ** (1 / 3))) == $1 )); then\n\t\techo true\n\telse\n\t\techo false\n\tfi", " \
    \ # Write your script here\n  local i\n  local m=1\n  for ((i=1; i<$1; i++));\
    \ do\n    m=$(($m+1))\n    if [[ $((i*i*i)) -eq $1 ]]; then\n      echo \"true\"\
    \n      break\n    elif [[ $((i*i*i)) -gt $1 ]]; then\n      echo \"false\"\n\
    \      break\n    fi\n  done", "    local x=$1\n    if [[ $x -eq 0 ]]; then\n\
    \        echo \"true\"\n    else\n        local y=$((x ** (1 / 3)))\n        if\
    \ [[ $((y * y * y)) -eq $x ]]; then\n            echo \"true\"\n        else\n\
    \            echo \"false\"\n        fi\n    fi", "    local input=$1\n    local\
    \ x=0\n    local result=0\n    local ret=\"false\"\n    while [[ $result -le $input\
    \ ]]; do\n        (( result = x*x*x ))\n        if [[ $result -eq $input ]]; then\n\
    \            ret=\"true\"\n            break\n        fi\n        (( x++ ))\n\
    \    done\n    echo $ret", "\tif [[ $1 -eq 0 ]]; then\n\t\techo \"true\"\n\t\t\
    return\n\tfi\n\tif (( $1 < 0 )); then\n\t\ta=$((-$1))\n\telse\n\t\ta=$1\n\tfi\n\
    \ti=0\n\twhile (( $((i*i*i)) < $a )); do\n\t\t((i++))\n\tdone\n\tif (( $((i*i*i))\
    \ == $a )); then\n\t\techo \"true\"\n\telse\n\t\techo \"false\"\n\tfi", "    #\
    \ Write your code here\n    result=$(echo \" scale=3; $1 == 0\" | bc)\n    if\
    \ [[ $result -eq 1 ]]; then\n        echo \"true\"\n    else\n        result=$(echo\
    \ \" scale=3; $1 < 0\" | bc)\n        if [[ $result -eq 1 ]]; then\n         \
    \   #echo \"true\"\n            integer_square=$(echo \"scale=2; sqrt(($1 * -1))\"\
    \ | bc)\n            float_square=$(echo \"scale=2; sqrt(($1 * -1))\" | bc -l)\n\
    \            result=$(echo \" scale=3; $integer_square != $float_square\" | bc)\n\
    \            if [[ $result -eq 1 ]]; then\n                echo \"false\"\n  \
    \          else\n                echo \"true\"\n            fi\n        else\n\
    \            integer_square=$(echo \"scale=2; sqrt($1)\" | bc)\n            float_square=$(echo\
    \ \"scale=2; sqrt($1)\" | bc -l)\n            result=$(echo \" scale=3; $integer_square\
    \ != $float_square\" | bc)\n            if [[ $result -eq 1 ]]; then\n       \
    \         echo \"false\"\n            else\n                echo \"true\"\n  \
    \          fi\n        fi\n    fi", "\t# TODO: complete this function\n\tif [\
    \ \"$1\" -lt \"0\" ]; then\n\t\techo \"true\"\n\telif [ \"$1\" -eq \"0\" ]; then\n\
    \t\techo \"true\"\n\telse\n\t\tfor i in `seq 1 $(($1/2))`;\n\t\tdo\n\t\t\tif [\
    \ $(($i*$i*$i)) -eq \"$1\" ]; then\n\t\t\t\techo \"true\"\n\t\t\t\treturn\n\t\t\
    \tfi\n\t\tdone\n\t\techo \"false\"\n\tfi", "    # Check if $1 is a perfect cube.\n\
    \    cube=$(awk -v num=$1 'BEGIN {print num^(1/3)}')\n    if [[ $cube =~ ^[0-9]+\\\
    .0*$ ]]; then\n        echo \"true\"\n    else\n        echo \"false\"\n    fi",
  "\tlocal x=$1\n\tlocal temp=`bc <<< \"sqrt($x)\"`\n\tlocal temp1=`bc <<< \"$temp^3\"\
    `\n\tif [ $temp1 -eq $x ];then\n\t\techo \"true\"\n\telse\n\t\techo \"false\"\n\
    \tfi", "    case $1 in\n        0)\n            echo \"true\"\n            ;;\n\
    \        *)\n            x=$(bc -l <<< \"s( $1 ^ (1/3) )\")\n            if [[\
    \ \"$x\" == *.* ]]; then\n                echo \"false\"\n            else\n \
    \               echo \"true\"\n            fi\n            ;;\n    esac", "  \
    \  # Assume the input is always valid, not to deal with edge cases\n    # However,\
    \ just in case\n    if [[ $1 -eq 0 ]]; then\n        echo true\n        return\n\
    \    fi\n    local x=1\n    while [[ $((x*x*x)) -lt $1 ]]; do\n        ((x++))\n\
    \    done\n    # If there is an x such that x*x*x=a, then $x*$x*$x and $1 should\
    \ be equal\n    if [[ $((x*x*x)) -eq $1 ]]; then\n        echo true\n    else\n\
    \        echo false\n    fi", "    local inp=$1\n    local cube=$(bc <<< \"scale=4;\
    \ $inp^(1/3)\")\n    [ \"$(echo $cube | cut -d '.' -f 2)\" == \"0000\" ] && echo\
    \ \"true\" || echo \"false\"", "    if [ \"$1\" -lt 0 ]; then\n        (( sqrt=$1*-1\
    \ ))\n    else\n        sqrt=$1\n    fi\n    max=$sqrt\n    if [ \"$max\" -eq\
    \ 0 ]; then\n        echo \"true\"\n        return 0\n    fi\n    min=1\n    while\
    \ [ \"$min\" -le \"$max\" ]; do\n        mid=$(( (min+max)/2 ))\n        if [\
    \ \"$(( mid**3 ))\" -eq \"$sqrt\" ]; then\n            echo \"true\"\n       \
    \     return 0\n        elif [ \"$(( mid**3 ))\" -lt \"$sqrt\" ]; then\n     \
    \       min=$(( mid+1 ))\n        else\n            max=$(( mid-1 ))\n       \
    \ fi\n    done\n    echo \"false\"", "    declare -i sqrt=$(echo \"sqrt($1)\"\
    \ | bc)\n    declare -i power=$(echo \"$sqrt*$sqrt*$sqrt\" | bc)\n    [ $power\
    \ -eq $1 ] && echo \"true\" || echo \"false\"", "  local i=1\n  if [[ $(( i **\
    \ 3 )) -eq $1 ]]; then\n    echo \"true\"\n  else\n    echo \"false\"\n  fi",
  "    # x is the cube root of $1\n    local x=$(echo \"scale=0; $1^(1/3)\" | bc)\n\
    \    # x^3 will change the decimals to integers\n    local y=$(echo \"scale=0;\
    \ $x^3\" | bc)\n    if [ $1 -eq $y ]; then\n        echo \"true\"\n    else\n\
    \        echo \"false\"\n    fi"]
stop_tokens:
- "\n}"
