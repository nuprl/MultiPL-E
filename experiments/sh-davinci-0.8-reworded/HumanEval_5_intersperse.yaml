name: HumanEval_5_intersperse
language: sh
prompt: "#!/bin/bash\n# Insert a number 'delimeter' between every two consecutive\
  \ elements of input list `numbers'\n# >>> $(intersperse \"\" \"4\")\n# []\n# >>>\
  \ $(intersperse \"1 2 3\" \"4\")\n# ['\"1\"', '\"4\"', '\"2\"', '\"4\"', '\"3\"\
  ']\n#\n# $1 is a space-separated list\n# $2 is an integer\nintersperse() {\n"
tests: "}\n\ncandidate() {\n    intersperse \"$@\"\n}\n\nset -e\nrun_test() {\n  \
  \  [[ $(candidate \"\" \"7\") = \"\" ]]\n    [[ $(candidate \"5 6 3 2\" \"8\") =\
  \ \"5 8 6 8 3 8 2\" ]]\n    [[ $(candidate \"2 2 2\" \"2\") = \"2 2 2 2 2\" ]]\n\
  }\n\nrun_test"
completions: ["    local numbers=\"$1\"\n    local delimeter=\"$2\"\n    local result=\"\
    \"\n    for x in $numbers; do\n        result=\"$result $x $delimeter\"\n    done\n\
    \    echo $result", "  local IFS=$' '\n  local numbers=($1)\n  local delimeter=$2\n\
    \  local result=\"\"\n  for (( i=0; i<${#numbers[@]}; i++ )); do\n    if [[ \"\
    $i\" -ne \"0\" ]]; then\n      result+=\" \\\"$delimeter\\\"\"\n    fi\n    result+=\"\
    \ \\\"${numbers[$i]}\\\"\"\n  done\n  printf \"%s\" \"$result\"", "  if [ \"$#\"\
    \ -ne 2 ]; then\n    echo \"Usage: intersperse LIST DELIMITER\"\n    exit 1\n\
    \  fi\n  local numbers=$1\n  local delimeter=$2\n  local res=\"\"\n  IFS=' ' read\
    \ -r -a nums <<< $numbers\n  for i in \"${!nums[@]}\"; do\n    if [ \"$i\" -gt\
    \ 0 ]; then\n      res+=\"${delimeter} \"\n    fi\n    res+=\"${nums[$i]}\"\n\
    \  done\n  echo $res", "    input=\"$1\"\n    delimiter=\"$2\"\n    output=\"\"\
    \n    for item in $input; do\n        output=\"$output \\\"$item\\\" \\\"$delimiter\\\
    \"\"\n    done\n    echo \"[$output]\"", "  local numbers=$1\n  local delimeter=$2\n\
    \  local num_list=()\n  while read -r number; do\n    num_list+=($number)\n  done\
    \ <<< \"$numbers\"\n  local len=${#num_list[@]}\n  local result=\"\"\n  if [ $len\
    \ -gt 0 ]; then\n    result+='\"'${num_list[0]}'\"'\n    for i in $(seq 1 $((len-1)));\
    \ do\n      result+=', \"'$delimeter'\", \"'${num_list[$i]}'\"'\n    done\n  fi\n\
    \  echo \"[$result]\"", "    numbers=$1\n    delimeter=$2\n    for number in $numbers;\
    \ do\n        echo -n ${number}\n        if [[ ! $number == $(tail -n 1 <<< $numbers)\
    \ ]]; then\n            echo -n ${delimeter}\n        fi\n    done", "  local\
    \ numbers=$1\n  local delimeter=$2\n  local result=\"\"\n  if [ -z \"${numbers}\"\
    \ ]; then\n    echo \"[]\"\n  else\n    local count=1\n    for number in ${numbers};\
    \ do\n      if [ \"${count}\" -eq 1 ]; then\n        result=\"${result}\\\"${number}\\\
    \"\"\n      else\n        result=\"${result}, \\\"${delimeter}\\\", \\\"${number}\\\
    \"\"\n      fi\n      count=$((count + 1))\n    done\n    echo \"[${result}]\"\
    \n  fi", "    local a\n    local b\n    local c\n    a=$(echo ${1} | tr \" \"\
    \ \"\\n\")\n    for b in ${a}; do\n        c=${c}\" \\\"${b}\\\" \\\"${2}\\\"\"\
    \n    done\n    echo ${c}", "    eval \"set -- $1\"\n    args=$#\n    [ $args\
    \ -gt 0 ] && awk -v n=\"$args\" -v d=\"$2\" 'BEGIN { for (i=1; i<=n; i++) printf\
    \ \"%s%s\", a[i], d }' \"$@\"", "  if [ $# -ne 2 ]; then\n    echo \"Illegal number\
    \ of parameters.\"\n    exit 1\n  fi\n\n  local list=\"$1\"\n  local delim=\"\
    $2\"\n  local result=\n\n  if [ -z \"$list\" ]; then\n    echo \"[]\"\n    return\n\
    \  fi\n\n  local delim=$(echo \"$delim\" | sed -e 's/\\\\/\\\\\\\\/g')\n  local\
    \ delim=$(echo \"$delim\" | sed -e 's/\"/\\\\\"/g')\n  local delim=\"\\\"$delim\\\
    \"\"\n\n  result=$(echo \"$list\" | sed -e \"s/ /,$delim,/g\")\n  result=\"[$delim$result$delim]\"\
    \n  echo \"$result\"", "  local numbers=${1}\n  local delimeter=${2}\n  local\
    \ numbersList=(${numbers})\n  for (( i=0; i<${#numbersList[@]}; i++ ))\n  do\n\
    \    [ -z ${numbersList[i+1]} ] && break\n    # shellcheck disable=SC2059\n  \
    \  printf \"%s%d%s\" \"${numbersList[i]}\" \"${delimeter}\" \"${numbersList[i+1]}\"\
    \n  done", "  if [ -z \"$1\" ]; then\n    echo []\n  else\n    echo -n '['; head\
    \ -c -1 <(paste -sd\", \"$2 <(echo $1)); echo ']'\n  fi", "    local -a numbers=$1\n\
    \    local delimeter=$2\n    local -a new_list=()\n    for number in $numbers;\
    \ do\n        new_list+=(\"\\\"$number\\\"\")\n        new_list+=(\"\\\"$delimeter\\\
    \"\")\n    done\n    unset new_list[-1] # remove last element of list\n    echo\
    \ ${new_list[@]}", "  local -a numbers=($1)\n  local n=${#numbers[@]}\n  if [\
    \ $n -eq 0 ]; then\n    echo -n \"[]\"\n  else\n    printf '[\"%s\"' \"${numbers[0]}\"\
    \n    for ((i=1; i<n; i++)); do\n      printf ',\"%s\"' \"$2\"\n      printf ',\"\
    %s\"' \"${numbers[i]}\"\n    done\n    echo \"]\"\n  fi", "  local numbers=\"\
    $1\"\n  local delimeter=\"$2\"\n  local -a R\n  while read -ra V; do\n    R=(\"\
    ${R[@]}\" \"${V[@]}\")\n  done <<< \"$numbers\"\n  if [ ${#R[@]} -eq 0 ]; then\n\
    \    echo \"[]\"\n  else\n    local output=\"[$(printf '\"%s\"\\n' \"${R[@]}\"\
    \ | xargs -n2 | xargs -I{} echo '\"'$delimeter'\"' {})${R[-1]}]\"\n    echo \"\
    $output\"\n  fi", "  numbers=\"$1\"\n  delimeter=\"$2\"\n  set -- $numbers\n \
    \ res=\"\"\n  for var in \"$@\"; do\n    res+=\" $var $delimeter\"\n  done\n \
    \ # remove the last delimeter\n  echo \"${res%$delimeter*}\"", "  local numbers=$1\n\
    \  local delimeter=$2\n  local result\n  local size=${#numbers[@]}\n  local last=$((size\
    \ - 1))\n  for i in ${!numbers[@]}; do\n    result=\"$result ${numbers[$i]}\"\n\
    \    if [[ $i -ne $last ]]; then\n      result=\"$result $delimeter\"\n    fi\n\
    \  done\n  echo $result", "    local numbers=\"$1\"\n    local delimeter=\"$2\"\
    \n    local output=\"\"\n    for number in $numbers; do\n        output=\"$output$number$delimeter\"\
    \n    done\n    output=\"[$output]\"\n    echo $output", "    local list=\"$1\"\
    \n    local elem=\"$2\"\n    local -a array=(\"$(echo $list | tr \" \" \"\\n\"\
    )\")\n    local -a result=()\n    for i in \"${!array[@]}\"; do\n        if [[\
    \ $i -gt 0 ]]; then\n            result+=(\"\\\"$elem\\\"\")\n        fi\n   \
    \     result+=(\"\\\"${array[$i]}\\\"\")\n    done\n    echo \"[\"$(IFS=,; echo\
    \ \"${result[*]}\")\"]\"", "    local IFS=$'\\n'\n    local r=$(printf \"%s\\\
    n\" \"$1\" | sed \"s/.*/& $2/\")\n    echo ${r::-1}"]
stop_tokens:
- "\n}"
