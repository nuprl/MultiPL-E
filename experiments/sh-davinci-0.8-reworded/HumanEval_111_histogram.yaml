name: HumanEval_111_histogram
language: sh
prompt: "#!/bin/bash\n# Given a string representing a space separated lowercase letters,\
  \ return a CSV\n# of the letter with the most repetition and containing the corresponding\
  \ count.\n# If several letters have the same occurrence, return all of them.\n#\
  \ Example:\n# >>> $(histogram \"a b c\")\n# {'\"a\"': '\"1\"', '\"b\"': '\"1\"',\
  \ '\"c\"': '\"1\"'}\n# >>> $(histogram \"a b b a\")\n# {'\"a\"': '\"2\"', '\"b\"\
  ': '\"2\"'}\n# >>> $(histogram \"a b c a b\")\n# {'\"a\"': '\"2\"', '\"b\"': '\"\
  2\"'}\n# >>> $(histogram \"b b b b a\")\n# {'\"b\"': '\"4\"'}\n# >>> $(histogram\
  \ \"\")\n# {}\n#\n# $1 is a string\nhistogram() {\n"
tests: "}\n\ncandidate() {\n    histogram \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
  \ $(candidate \"a b b a\") = \"a,2\\nb,2\" ]]\n    [[ $(candidate \"a b c a b\"\
  ) = \"a,2\\nb,2\" ]]\n    [[ $(candidate \"a b c d g\") = \"a,1\\nb,1\\nc,1\\nd,1\\\
  ng,1\" ]]\n    [[ $(candidate \"r t g\") = \"r,1\\nt,1\\ng,1\" ]]\n    [[ $(candidate\
  \ \"b b b b a\") = \"b,4\" ]]\n    [[ $(candidate \"r t g\") = \"r,1\\nt,1\\ng,1\"\
  \ ]]\n    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"a\") = \"a,1\" ]]\n\
  }\n\nrun_test"
completions: ["  if [[ $# -ne 1 ]]; then\n    echo \"histogram: invalid number of\
    \ arguments\" >&2\n    return 1\n  fi\n  local result=\"\"\n  local max_repeated_letters=\"\
    \"\n  local max_repeated_count=0\n  local value\n  local count\n  for letter in\
    \ $(echo $1 | tr \" \" \"\\n\"); do\n    value=\"\\\"$letter\\\"\"\n    count=$(echo\
    \ $1 | tr \" \" \"\\n\" | grep \"$letter\" | wc -l)\n    if [[ $count -eq $max_repeated_count\
    \ ]]; then\n      max_repeated_letters=\"$max_repeated_letters $value\"\n    elif\
    \ [[ $count -gt $max_repeated_count ]]; then\n      max_repeated_letters=\"$value\"\
    \n      max_repeated_count=$count\n    fi\n  done\n  for letter in $max_repeated_letters;\
    \ do\n    result=\"$result$letter: \\\"$max_repeated_count\\\", \"\n  done\n \
    \ echo \"{$(echo \"$result\" | sed 's/, $//')}\"", '    histogram_of "$1" | csv_letter_count',
  "  local word\n  for word in $1; do\n    (( words[$word] += 1 ))\n  done\n  for\
    \ word in \"${!words[@]}\"; do\n    if (( ${words[$word]} > max )); then\n   \
    \   max=${words[$word]}\n      most_repeated_words=()\n    fi\n    if (( ${words[$word]}\
    \ == max )); then\n      most_repeated_words+=($word)\n    fi\n  done\n  printf\
    \ '{\"%s\": \"%s\"}' \"${most_repeated_words[@]}\" \"$max\"", "    local -A frequency\n\
    \    local count\n    local key\n    if [ \"$#\" != \"1\" ]; then\n        echo\
    \ \"histogram usage: $0 STRING\" >&2\n        return 1\n    fi\n    while read\
    \ -r key; do\n        count=\"${frequency[$key]}\"\n        if [ -z \"$count\"\
    \ ]; then\n            count=0\n        fi\n        frequency[$key]=$((++count))\n\
    \    done < <(grep -o . <<<\"$1\")\n    awk -v OFS='\"': '\n        function jsonize(value)\
    \ {\n            gsub(/\"/, \"\\\\\"\", value)\n            return \"\\\"\" value\
    \ \"\\\"\"\n        }\n        BEGIN {\n            print \"{\"\n        }\n \
    \       {\n            if (first) {\n                first = 0\n            }\
    \ else {\n                print \", \"\n            }\n            print jsonize($1),\
    \ \": \", jsonize($2)\n        }\n        END {\n            print \"}\"\n   \
    \     }\n    ' <<<\"$(\n        while read -r key; do\n            echo \"$key\"\
    \ \"${frequency[$key]}\"\n        done < <(sort <<<\"${!frequency[@]}\")\n   \
    \ )\"", "    for ((i=0; i<26; i++)); do\n        char=$(printf \"\\\\$(printf\
    \ %o $(($i+97)))\" 2> /dev/null)\n        if [[ $1 =~ $char ]]; then\n       \
    \     printf '%s' \"\\\"$char\\\"\"\n            printf ': '\n            printf\
    \ '%s' \"\\\"$(grep -o $char <<< \"$1\" | wc -l)\\\"\"\n            ((i<25)) &&\
    \ printf ', '\n        fi\n    done", "    echo \"{$(\n    echo \"$1\" | tr '\
    \ ' '\\n' | sort | uniq -c | sed 's/^[ \\t]*//' | tr '\\n' ',' | sed 's/,$//'\
    \ |\n    sed 's/\\([[:alnum:]]\\) \\([[:digit:]]\\)/\\1\": \"\\2,/g' | sed 's/\\\
    (^.*\\),$/\\1}/'\n    )}\"", "  echo \"$1\" | tr ' ' '\\n' | sort | uniq -c |\
    \ awk '{print $2, $1}' | \\\n    awk 'BEGIN {FS=\" \"; OFS=\": \"; print \"{\"\
    } {print \"'\\''\\\"\" $1 \"\\\"'\\'', '\\''\\\"\" $2 \"\\\"'\\'', \"} END {print\
    \ \"}\"}'", "    # $1 is a string\n    local histogram=\"\"\n    if [[ -z \"$1\"\
    \ ]]; then\n        histogram=\"{}\"\n    else\n        local max_letter=\"\"\n\
    \        local max_count=0\n        for letter in $(echo $1 | tr \" \" \"\\n\"\
    ); do\n            local count=$(echo $1 | tr \" \" \"\\n\" | grep -c $letter)\n\
    \            if [[ \"$count\" -gt \"$max_count\" ]]; then\n                max_count=$count\n\
    \                max_letter=$letter\n            fi\n        done\n        histogram=\"\
    {\\\"$max_letter\\\": \\\"$max_count\\\"}\"\n    fi\n    echo \"$histogram\"",
  "    local -a letters=()\n    local -a counts=()\n    local letter\n    local count\n\
    \    local max_count=0\n    local -i i=0\n\n    for letter in $1; do\n       \
    \ i=0\n        while [[ $i -lt ${#letters[@]} ]]; do\n            if [[ ${letters[$i]}\
    \ == $letter ]]; then\n                let counts[$i]++\n                if [[\
    \ ${counts[$i]} -gt $max_count ]]; then\n                    max_count=${counts[$i]}\n\
    \                fi\n                break\n            fi\n            let i++\n\
    \        done\n        if [[ $i -eq ${#letters[@]} ]]; then\n            letters[$i]=$letter\n\
    \            counts[$i]=1\n        fi\n    done\n\n    echo -n \"{\"\n    i=0\n\
    \    while [[ $i -lt ${#letters[@]} ]]; do\n        if [[ ${counts[$i]} -eq $max_count\
    \ ]]; then\n            echo -n \"\\\"${letters[$i]}\\\": \\\"${counts[$i]}\\\"\
    \"\n            if [[ $i -lt $(( ${#letters[@]} - 1 )) ]]; then\n            \
    \    echo -n \", \"\n            fi\n        fi\n        let i++\n    done\n \
    \   echo \"}\"", "    echo \"$1\" | tr ' ' '\\n' | sort | uniq -c | sed 's/ *\\\
    ([a-z]\\) \\([0-9]\\)/{\"\\1\": \"\\2\"}/' | awk 'BEGIN { ORS = \"\" } { print\
    \ $0, \",\" }' | sed 's/,$//'", "    if [ -z \"$1\" ]; then\n        echo \"{}\"\
    \n        return\n    fi\n    local -r __data=\"$(echo \"$1\" | tr ' ' '\\n' |\
    \ sort)\"\n    local -r __num_characters=\"$(echo \"$__data\" | wc -l)\"\n   \
    \ local -r __max_histogram_key=\"$(echo \"$__data\" | tail -n 1)\"\n    # Use\
    \ an associative array to track the histogram\n    local -A __histogram\n    #\
    \ Iterate through the sorted list of letters and\n    # add each letter in the\
    \ histogram.\n    for ((i=0; i<=\"$__num_characters\"; i++)); do\n        local\
    \ -r __char=\"$(echo \"$__data\" | sed -n \"$((i+1))\"p)\"\n        # Add one\
    \ to the current histogram value for the character.\n        ((__histogram[\"\
    $__char\"]++))\n    done\n    # Use another associative array to track the histogram\n\
    \    # of the histogram keys.\n    local -A __histogram_histogram\n    # Iterate\
    \ through the letters of the histogram and\n    # build the histogram of the histogram.\n\
    \    for ((i=0; i<=\"$__num_characters\"; i++)); do\n        local -r __char=\"\
    $(echo \"$__data\" | sed -n \"$((i+1))\"p)\"\n        # Add one to the current\
    \ histogram value for the character.\n        ((__histogram_histogram[\"${__histogram[\"\
    $__char\"]}\"]++))\n    done\n    # Use another associative array to track the\
    \ histogram\n    # of the histogram values that are the maximum.\n    local -A\
    \ __histogram_histogram_max\n    local -r __max_histogram_key_histogram=\"$(echo\
    \ \"$__data\" | tail -n 1)\"\n    # Iterate through the letters of the histogram\
    \ and\n    # build the histogram of the histogram.\n    for ((i=0; i<=\"$__num_characters\"\
    ; i++)); do\n        local -r __char=\"$(echo \"$__data\" | sed -n \"$((i+1))\"",
  "  local histogram=()\n  for char in $(echo $1); do\n    index=$(echo \"${histogram[@]}\"\
    \ | grep -n \"^${char}=*\" | cut -d: -f1)\n    if [ -z \"$index\" ]; then\n  \
    \    index=${#histogram[@]}\n      histogram[$index]=\"$char=1\"\n    else\n \
    \     let histogram[$index]++\n    fi\n  done\n  histogram=$(IFS=,; echo \"${histogram[*]}\"\
    )\n  echo \"{\"$(for hist in $(echo $histogram); do\n    key=$(echo $hist | cut\
    \ -d= -f1)\n    echo \"'\\\"$key\\\"': '\\\"$(echo $hist | cut -d= -f2)\\\"'\"\
    \n  done | tr '\\n' ',' | sed 's/,$//')\"}\"", "  local histogram_RESULT\n\n \
    \ # Your solution goes here\n  # Write a function to take input and return output.\n\
    \  # Strip leading and trailing `echo` when you are done.\n  histogram_RESULT=$(echo\
    \ \"Dummy\")\n  \n  echo \"$histogram_RESULT\"", "    local -A letters\n    for\
    \ letter in $1; do\n        ((++letters[$letter]))\n    done\n    for letter in\
    \ \"${!letters[@]}\"; do\n        ((letters[$letter] > max_count)) && {\n    \
    \        max_count=${letters[$letter]}\n            max_letters=\"$letter\"\n\
    \        } || {\n            ((letters[$letter] == max_count)) && max_letters+=\"\
    \ $letter\"\n        }\n    done\n    echo \"{$(tr ' ' ',' <<< $max_letters |\
    \ sed -e 's/\\(.\\)/\"\\1\"/g')}\"", "    local count\n    for letter in $(echo\
    \ \"$1\" | tr -cs \"[:alpha:]\" \" \"); do\n        ((count[$letter]++))\n   \
    \ done\n    # get the max value\n    local max=$(echo \"${count[@]}\" | tr -cs\
    \ \"[:digit:]\" \" \" | sort -n | tail -n 1)\n    # check the number of values\
    \ equal to the max\n    local num=$(echo \"${count[@]}\" | tr -cs \"[:digit:]\"\
    \ \" \" | grep -c $max)\n    if [ $num -eq 1 ]; then\n        # only one, find\
    \ the key\n        for key in ${!count[@]}; do\n            if [ ${count[$key]}\
    \ -eq $max ]; then\n                echo \"{\\\"$key\\\": \\\"$max\\\"}\"\n  \
    \          fi\n        done\n    else\n        # more than one, find the key for\
    \ each max\n        echo -n \"{\"\n        for key in ${!count[@]}; do\n     \
    \       if [ ${count[$key]} -eq $max ]; then\n                echo -n \"\\\"$key\\\
    \": \\\"$max\\\",\"\n            fi\n        done\n        echo -n \"}\"\n   \
    \ fi", "    (\n        if [ -z \"$1\" ]; then\n            echo '{}'\n       \
    \ else\n            echo $(awk 'BEGIN { FS = \" \" } { print $0 }' <<< \"$1\"\
    \ | sort | uniq -c | sort -n -r | awk '{print \"\\\"\"$2\"\\\": \\\"\"$1\"\\\"\
    \"}' | head -n 1)\n            echo $(awk 'BEGIN { FS = \" \" } { print $0 }'\
    \ <<< \"$1\" | sort | uniq -c | sort -n -r | awk '{print \"\\\"\"$2\"\\\": \\\"\
    \"$1\"\\\"\"}' | tail -n +2)\n        fi\n    ) | paste -sd \",\" -", "    local\
    \ letters=(${1// / })\n    local -A letter_counts\n    for letter in \"${letters[@]}\"\
    ; do\n        if [ -z \"${letter_counts[$letter]}\" ]; then\n            letter_counts[$letter]=1\n\
    \        else\n            letter_counts[$letter]=$((letter_counts[$letter] +\
    \ 1))\n        fi\n    done\n    if [ ${#letter_counts[@]} -eq 0 ]; then\n   \
    \     echo '{}'\n        return\n    fi\n    local max_count=0\n    for count\
    \ in \"${letter_counts[@]}\"; do\n        if [ $count -gt $max_count ]; then\n\
    \            max_count=$count\n        fi\n    done\n    local max_letters\n \
    \   for letter in \"${!letter_counts[@]}\"; do\n        if [ ${letter_counts[$letter]}\
    \ -eq $max_count ]; then\n            max_letters=\"$max_letters$letter,\"\n \
    \       fi\n    done\n    echo \"{\\\"${max_letters%,}\\\": \\\"$max_count\\\"\
    }\"", "    local line=\"$1\"\n    local input=()\n\n    while read -r -d $'\\\
    n' -a input; do\n        echo -n \"{\\\"\"\n        for i in ${input[@]}; do\n\
    \            echo -n $i\n            echo -n \"\\\": \\\"\"\n            echo\
    \ -n $(echo \"$line\" | grep -o $i | wc -l)\n            echo -n \"\\\", \\\"\"\
    \n        done | sed 's/, $//'\n        echo -n \"}\"\n    done <<< \"$line\"",
  "  local result=$(printf \"%s\" \"$1\" | sed 's/ //g' | grep -o . | sort | uniq\
    \ -c | awk '{print \"\\\"\"$2\"\\\":\\\"\"$1\"\\\"\"}' | xargs | sed 's/ /, /g')\n\
    \  if [ -z \"$result\" ]; then\n    echo \"{}\"\n  else\n    echo \"{$result}\"\
    \n  fi", "  if [ -z \"$1\" ]; then\n    echo \"{}\"\n    return\n  fi\n  local\
    \ input=\"$1\"\n  local -A histogram\n  local letter\n  local value\n  local -a\
    \ output\n  local -a letters\n  local -a values\n  local -a max_values\n  local\
    \ max_value\n  local max_value_index\n  local -i i\n  local -i j\n  local -i n\n\
    \  local -i n_max\n  local -i n_values\n  local -i n_letters\n  # Build histogram\
    \ associative array\n  for letter in $input; do\n    let histogram[$letter]+=$((histogram[$letter]+1))\
    \ || histogram[$letter]=1\n  done\n  # Find maximum value in histogram\n  max_value=0\n\
    \  for value in \"${histogram[@]}\"; do\n    if [ $value -gt $max_value ]; then\n\
    \      max_value=$value\n    fi\n  done\n  # Build max_values array from max_value\n\
    \  n_max=0\n  for value in \"${histogram[@]}\"; do\n    if [ $value -eq $max_value\
    \ ]; then\n      max_values[$n_max]=$value\n      let n_max++\n    fi\n  done\n\
    \  # Build letters and values arrays\n  n_letters=0\n  n_values=0\n  for letter\
    \ in \"${!histogram[@]}\"; do\n    letters[$n_letters]=$letter\n    let n_letters++\n\
    \    values[$n_values]=${histogram[$letter]}\n    let n_values++\n  done\n  #\
    \ Sort letters and values arrays by keys\n  for ((i=0; i<n_letters; i++)); do\n\
    \    max_value_index=$i\n    for ((j=i+1; j<n_letters; j++)); do\n      if [ ${values[$j]}\
    \ -gt ${values[$max_value_index]} ]; then\n        max_value_index=$j\n      fi\n\
    \    done\n    if [ $max_value_index -ne $i ]; then\n      temp_value=${values[$i]}\n\
    \     "]
stop_tokens:
- "\n}"
