name: HumanEval_83_starts_one_ends
language: sh
prompt: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
  \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
  starts_one_ends() {\n"
tests: "}\n\ncandidate() {\n    starts_one_ends \"$@\"\n}\n\nset -e\nrun_test() {\n\
  \    [[ $(candidate \"1\") = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\" ]]\n \
  \   [[ $(candidate \"3\") = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\" ]]\n\
  \    [[ $(candidate \"5\") = \"18000\" ]]\n}\n\nrun_test"
completions: ["  declare n=\"$1\"\n  declare s=0\n  declare e=0\n  # The number of\
    \ n-digit positive integers starting with 1\n  # - this is just 10^(n-1)\n  s=$((\
    \ 10 ** (n - 1) ))\n  # The number of n-digit positive integers ending with 1\n\
    \  # - this is the number of 10-digit numbers that do not start with 1\n  # -\
    \ so it is (10^n) - 10^(n-1)\n  e=$(( 10 ** n - s ))\n  echo \"$(( s + e ))\"",
  "  local i j m n\n  local result=0\n  if [[ $1 -gt 0 ]]; then\n    for (( i=0; i<$1;\
    \ i++ )); do\n      (( m=$(( 10 ** i )) ))\n      (( n=$(( 10 ** ($1 - i) )) ))\n\
    \      (( result += $(( $n - $m )) ))\n    done\n  fi\n  echo $result", "  local\
    \ n=\"$1\"\n  if ((n < 1)); then\n    return 0\n  fi\n  if ((n == 1)); then\n\
    \    echo 1\n    return 0\n  fi\n  echo $((9 * 10 ** (n - 1) + 9 * 10 ** (n -\
    \ 2)))", "    local -r n=\"$1\"\n    local -r d=$((10 ** (n - 1)))\n    local\
    \ -r f=$((d * 10 - 1))\n    # Brute force is fine here\n    local -i count=0\n\
    \    local -i t\n    for t in $(seq \"$d\" \"$f\"); do\n        if [[ \"$t\" =~\
    \ ^1.*1$ ]]; then\n            ((++count))\n        fi\n    done\n    echo \"\
    $count\"", "    integer_validate $1\n    local len=$1\n    if [[ $len -eq 1 ]];\
    \ then\n        echo 1\n    else\n        local i\n        local upper_sum\n \
    \       local lower_sum\n        upper_sum=1\n        lower_sum=1\n        for\
    \ ((i=1; i<len; i++)); do\n            upper_sum=$((upper_sum * 10))\n       \
    \     lower_sum=$((lower_sum * 9))\n        done\n        echo $((upper_sum +\
    \ lower_sum))\n    fi", "  count=0\n  if [[ $1 == 0 ]]; then\n    count=1\n  else\n\
    \    for ((i=1; i<=$1; i++)); do\n      count=$((count + (1*10**$i)))\n    done\n\
    \  fi\n  echo $count", "  declare -i i\n  declare -i j\n  declare -i count=0\n\
    \  declare -i val\n  declare -i begins_with_one\n  declare -i ends_with_one\n\
    \  declare -i temp\n  for ((i=1; i<=$1; i++)); do\n    val=$((10**i))\n    # Iterate\
    \ through all j-digit numbers.\n    for ((j=1; j<=$val; j++)); do\n      begins_with_one=0\n\
    \      ends_with_one=0\n      temp=$j\n      while [ $temp -gt 0 ]; do\n     \
    \   # See if the current digit is 1.\n        if [ $((temp%10)) -eq 1 ]; then\n\
    \          if [ $begins_with_one -eq 0 ]; then\n            begins_with_one=1\n\
    \          else\n            ends_with_one=1\n          fi\n        fi\n     \
    \   temp=$((temp/10))\n      done\n      if [ $begins_with_one -eq 1 -o $ends_with_one\
    \ -eq 1 ]; then\n        count=$((count+1))\n      fi\n    done\n  done\n  echo\
    \ $count", "  result=0\n  for (( i=1; i<=\"$1\"; i++ )); do\n    result=$(( $result\
    \ + ($1 ** $i) ))\n  done\n  echo $result", "    local i j k\n    local final_count=0\n\
    \    # init\n    i=1\n    # count last digit 1\n    while [ $i -lt $1 ]; do\n\
    \        i=$((i+1))\n    done\n    j=$((i-1))\n    while [ $j -gt 0 ]; do\n  \
    \      k=$((j+1))\n        while [ $k -lt $i ]; do\n            k=$((k+1))\n \
    \       done\n        final_count=$((final_count+1))\n        j=$((j-1))\n   \
    \ done\n    # count first digit 1\n    i=2\n    while [ $i -lt $1 ]; do\n    \
    \    i=$((i+1))\n    done\n    j=$((i-1))\n    while [ $j -gt 0 ]; do\n      \
    \  k=$((j+1))\n        while [ $k -lt $i ]; do\n            k=$((k+1))\n     \
    \   done\n        final_count=$((final_count+1))\n        j=$((j-1))\n    done\n\
    \    echo $final_count", "  local n=$1\n\n  # Initialize starting values\n  local\
    \ start_end=0\n  local start_no_end=0\n  local no_start_end=0\n  local no_start_no_end=0\n\
    \n  # Iterate over the number of digits (e.g. for n=3: n=3, n=2, n=1)\n  for ((i=1;\
    \ i<=$n; i++)); do\n    case $i in\n      1)\n        start_end=1\n        start_no_end=0\n\
    \        no_start_end=1\n        no_start_no_end=1\n        ;;\n      *)\n   \
    \     start_end=$((start_end * 10 + 1))\n        start_no_end=$((start_no_end\
    \ * 10 + 9))\n        no_start_end=$((no_start_end * 10 + 1))\n        no_start_no_end=$((no_start_no_end\
    \ * 10 + 8))\n        ;;\n    esac\n  done\n\n  echo $((start_end + start_no_end\
    \ + no_start_end))", "    local n=$1\n    local count=0\n    local p=$((n/2))\n\
    \    local i\n\n    # $n-digit positive integer that starts with 1\n    for ((i=0;\
    \ i<p; i++)); do\n        count=$((count+9*(10**i)))\n    done\n    count=$((count+10**p))\n\
    \n    # $n-digit positive integer that ends with 1\n    for ((i=0; i<p; i++));\
    \ do\n        count=$((count+9*(10**i)))\n    done\n    echo $count", "  local\
    \ n=$1\n  local count=0\n  if [[ $n -gt 1 ]]; then\n    local lower_bound=$((\
    \ 10 ** ($n - 1) ))\n    local upper_bound=$(( 10 ** $n - 1 ))\n    for (( i =\
    \ lower_bound; i <= upper_bound; i++ )); do\n      local str=\"$i\"\n      local\
    \ first=${str:0:1}\n      local last=${str: -1}\n      if [[ $first -eq 1 || $last\
    \ -eq 1 ]]; then\n        count=$(( count + 1 ))\n      fi\n    done\n  fi\n \
    \ echo $count", "  if [[ $1 -lt 1 ]]; then\n    echo \"Input must be greater than\
    \ 1\"\n    return 1\n  fi\n\n  if [[ $1 -eq 1 ]]; then\n    echo \"Input must\
    \ be greater than 1\"\n    return 1\n  fi\n\n  # These are the base cases for\
    \ this problem\n  case $1 in\n    2)\n      echo \"$(($1 * 9))\"\n      return\
    \ 0\n      ;;\n    3)\n      echo \"$(($1 * 9))\"\n      return 0\n      ;;\n\
    \    4)\n      echo \"$(($1 * 18))\"\n      return 0\n      ;;\n    5)\n     \
    \ echo \"$(($1 * 18))\"\n      return 0\n      ;;\n    6)\n      echo \"$(($1\
    \ * 27))\"\n      return 0\n      ;;\n    7)\n      echo \"$(($1 * 27))\"\n  \
    \    return 0\n      ;;\n    8)\n      echo \"$(($1 * 36))\"\n      return 0\n\
    \      ;;\n    9)\n      echo \"$(($1 * 36))\"\n      return 0\n      ;;\n   \
    \ 10)\n      echo \"$(($1 * 45))\"\n      return 0\n      ;;\n    11)\n      echo\
    \ \"$(($1 * 45))\"\n      return 0\n      ;;\n    12)\n      echo \"$(($1 * 54))\"\
    \n      return 0\n      ;;\n    13)\n      echo \"$(($1 * 54))\"\n      return\
    \ 0\n      ;;\n    14)\n      echo \"$(($1 * 63))\"\n      return 0\n      ;;\n\
    \    15)\n      echo \"$(($1 * 63))\"\n      return 0\n      ;;\n    16)\n   \
    \   echo \"$(($1 * 72))\"\n      return 0\n      ;;\n    17)\n      echo \"$(($1\
    \ * 72))\"\n      return 0\n      ;;\n    18)\n      echo \"$(($1 * 81))\"\n \
    \     return 0\n      ;;\n    19)\n      echo \"$(($1 * 81))\"\n      return 0\n\
    \      ;;\n    20)\n      echo \"$(($1 * 90))\"\n      return 0\n      ;;\n  \
    \  21)\n      echo \"$(($1 * 90))\"\n     ", "  local input=$1\n  local count=0\n\
    \  for number in $(seq 1 10**$input); do\n    if [[ $number =~ ^1.* || $number\
    \ =~ .*1$ ]]; then\n      ((count++))\n    fi\n  done\n  echo $count", "  local\
    \ n=$1\n  echo $(starts_one $n) + $(ends_one $n) | bc", "  local count=0\n  for\
    \ (( i=1; i<=$1; i++ )); do\n    local n=$i\n    while [[ $n -gt 0 ]]; do\n  \
    \    if [[ $n -eq 1 ]]; then\n        count=$(( count + 1 ))\n        break\n\
    \      fi\n      n=$(( n / 10 ))\n    done\n  done\n  echo $count", "    n=$1\n\
    \    if [[ $n -eq 1 ]]; then\n        echo 1\n        return\n    fi\n    # f(n)\
    \ = f(n-1) + (9 * 10^(n-2))\n    # The first term is the number of n-digit numbers\
    \ that start with 1\n    # (i.e. the number of (n-1)-digit numbers that start\
    \ with 1). The second\n    # term is the number of n-digit numbers that end with\
    \ 1 (i.e. the number\n    # of 10-digit numbers that end with 1).\n    curr=$(starts_one_ends\
    \ $((n-1)))\n    prev=1\n    i=1\n    while [[ $i -lt $((n-1)) ]]; do\n      \
    \  prev=$((prev * 10))\n        i=$((i+1))\n    done\n    echo $((curr + 9 * prev))",
  "    declare -i i; declare -i total=0; declare -i len=$1\n    while (( --len ));\
    \ do\n        i=1; while (( i < 10 ** len )); do\n            if (( i == 10 **\
    \ (len - 1) )); then\n                (( total += 10 ** len ))\n            else\n\
    \                (( total += 2 * 10 ** len ))\n            fi\n            ((\
    \ i *= 10 ))\n        done\n    done\n    echo $total", "  if [[ $1 -lt 1 ]];\
    \ then\n    echo \"INVALID\"\n    return 1\n  fi\n\n  if [[ $1 -eq 1 ]]; then\n\
    \    echo 1\n    return 0\n  fi\n\n  echo -n $(($1 - 1))\n  echo -n $(($1 - 1))\
    \ | sed 's/./*9/g'\n  echo ' + '\n  echo 1\n  echo -n $(($1 - 1)) | sed 's/./*9/g'\n\
    \  echo ' + '\n  echo 1\n  echo -n $(($1 - 1)) | sed 's/./*9/g'\n  echo ' + '\n\
    \  echo $(($1 - 1))\n  echo ' - '\n  echo $(($1 - 1)) | sed 's/./9/g'\n  echo\
    \ ' + '\n  echo 1", "  declare -i local n=$1\n  if [[ $n == 1 ]]; then\n    echo\
    \ 1\n  else\n    echo $(((10 ** ($n - 1)) - (9 ** ($n - 1))))\n  fi", "  # If\
    \ the number is below 10, it's ending in 1, so return 1\n  if [ $1 -lt 10 ]; then\n\
    \    echo 1\n    return\n  fi\n\n  # If the number is bigger than 10, then it's\
    \ ending in 1 and\n  # starting with 1.\n  #\n  # We do: n / 10 and that's how\
    \ many numbers start with 1,\n  # and the same calculation is done with (n - 1)\
    \ to get the ending with 1.\n  if [ $1 -ge 10 ]; then\n    echo $((($1 / 10) +\
    \ ($(starts_one_ends $(($1 - 1))) - 1)))\n    return\n  fi", "    local num=$1\n\
    \    local all=`eval echo {1..$num}`\n    local start=$(echo $all | cut -d ' '\
    \ -f 1)\n    local end=$(echo $all | cut -d ' ' -f $num)\n    local combined=`eval\
    \ echo {$start..$end}`\n    echo $combined | grep -o \"1\" | wc -l", "  local\
    \ n=$1; shift\n\n  # If n=1, then it either starts or ends with 1, so there is\
    \ only 1 case.\n  if [ $n -eq 1 ]; then\n    echo 1\n    return\n  fi\n\n  # The\
    \ ten's digit can be anything from 0-9, and the ones digit can only be\n  # 1.\
    \ Thus, there are 10*1=10 cases.\n  if [ $n -eq 2 ]; then\n    echo 10\n    return\n\
    \  fi\n\n  # The hundred's digit can be anything from 0-9, and the ones digit\
    \ can only\n  # be 1. Thus, there are 10*1=10 cases.\n  if [ $n -eq 3 ]; then\n\
    \    echo 100\n    return\n  fi\n\n  # For n>3, the hundred's digit can be anything\
    \ from 0-9, but the tens and\n  # ones digits can only be 1. Thus, there are 10*1*1=10\
    \ cases.\n  #\n  # The last two digits can either be 1 or start/end with 1. Thus,\
    \ there are\n  # 10+1=11 possible cases for the last two digits.\n  #\n  # Therefore,\
    \ for n>3, there are 10*1*1*11=110 cases.\n  if [ $n -gt 3 ]; then\n    echo 110\n\
    \    return\n  fi", "  local count=0\n  local i\n  for ((i=1; i<=9; i++)); do\n\
    \    case $i in\n      1) count=$((count + 2)) ;;\n      *) count=$((count + 1))\
    \ ;;\n    esac\n  done\n  local pow10=$((10**($1-1)))\n  local pow9=$((10**($1-1)-1))\n\
    \  local result=$((count * pow9))\n  echo $result", "    local -i n=$1 i=0 total_count=0\n\
    \    while (( i++ < n )); do\n        (( total_count += $(( 10 ** (i - 1) )) ))\n\
    \    done\n    echo $total_count", "    if [[ \"$1\" -lt 2 ]]; then\n        echo\
    \ 0\n        return\n    fi\n    digits=\"$1\"\n    middle_digits=$(( digits -\
    \ 2 ))\n    echo $(( 9 * (10 ** middle_digits) + 9 ))", "  local n=$1\n  local\
    \ start_one_end_one=1\n  local end_one=1\n  local start_one=10\n  local total=0\n\
    \  for (( i=2; i<n; i++ )); do\n    start_one=$((start_one*10))\n    end_one=$((end_one*10))\n\
    \    start_one_end_one=$((start_one_end_one*10))\n  done\n  total=$((start_one_end_one\
    \ + start_one + end_one))\n  echo $total", "  echo \"$1\" | grep -o '^1' | wc\
    \ -l", "    local -i n=$1\n    local -i result=0\n    local -i i\n\n    for ((i=1;\
    \ i<=n; i++)); do\n        # Add the number of i-digit numbers that start or end\
    \ with 1.\n        # A number that starts with 1 starts with 1, followed by (i-1)\
    \ digits\n        # from the set 0..9. This is a combination of (i-1) things from\
    \ the\n        # set 10. The number of combinations is\n        #  (number of\
    \ ways to choose an (i-1)-digit number) x 10\n        # = (i-1) x 10\n       \
    \ result+=$(( (i-1) * 10 ))\n    done\n\n    echo $result", "  # pick a number\
    \ of digits in [1, n]\n  d=1\n  while [[ $d -le $1 ]]; do\n    # pick a digit\
    \ to start it\n    n=1\n    while [[ $n -le 9 ]]; do\n      # pick a digit to\
    \ end it\n      m=1\n      while [[ $m -le 9 ]]; do\n        if [[ \"$n\" == \"\
    1\" || \"$m\" == \"1\" ]]; then\n          a=1\n        else\n          a=0\n\
    \        fi\n        m=$(( m + 1 ))\n      done\n      n=$(( n + 1 ))\n    done\n\
    \    d=$(( d + 1 ))\n  done", "  local n=$1\n  local result=0\n  local i\n\n \
    \ if (( n <= 0 )); then\n    echo 0\n    return\n  fi\n\n  # one digit number\n\
    \  (( result += 1 ))\n\n  for (( i = 1; i < n; i++ )); do\n    (( result += 9\
    \ * 10 ** (i - 1) ))\n  done\n\n  # 1xx..x\n  (( result += 10 ** (n - 1) ))\n\n\
    \  echo $result", "    local n=$1\n    local pow10=$((10**(n-1)))\n    echo $((pow10\
    \ + 9*pow10/10))", "  local num=$1\n  local arr=($(seq 1 $num))\n  local count=0\n\
    \  for i in ${arr[@]}; do\n    if [[ ${i:0:1} -eq 1 ]] || [[ ${i: -1} -eq 1 ]];\
    \ then\n      ((count++))\n    fi\n  done\n  echo $count", "  local n=$1\n  local\
    \ pow=`expr $n - 1`\n  local start=$((10 ** $pow))\n  local end=$((11 ** $pow))\n\
    \  local count=0\n  local i=0\n  # Iterate over the decimal representation of\
    \ all integers from 10^(n-1) to\n  # 10^n.\n  for ((i=$start; i<$end; i++)); do\n\
    \    local first=${i:0:1}\n    local last=${i: -1}\n    if [[ $first == 1 || $last\
    \ == 1 ]]; then\n      count=$((count + 1))\n    fi\n  done\n  echo $count", " \
    \   # the number of digits n in the decimal number system\n    local digits=$1\n\
    \    # First, there are 9 possible first digits in an n-digit integer.\n    #\
    \ This is because 0 and 1 don't count as the first digit, so\n    # we have 9\
    \ choices.\n    local number_of_first_digits=9\n    # There are 10^(n-1) n-digit\
    \ integers that start with 1,\n    # such as 1542, 1009, and 1111.\n    local\
    \ numbers_starting_with_one=$(( 10 ** ( $digits - 1 ) ))\n    # There are 9 possible\
    \ final digits in an n-digit integer.\n    # This is because 0 and 1 don't count\
    \ as the last digit, so\n    # we have 9 choices.\n    local number_of_last_digits=9\n\
    \    # There are 10^(n-1) n-digit integers that end with 1,\n    # such as 1231,\
    \ 1297, and 5111.\n    local numbers_ending_with_one=$(( 10 ** ( $digits - 1 )\
    \ ))\n    # Add up the number of n-digit integers that start with 1 and the\n\
    \    # number of n-digit integers that end with 1. Then, subtract the\n    # number\
    \ of numbers that start and end with 1.\n    echo $(( number_of_first_digits *\
    \ numbers_starting_with_one + number_of_last_digits * numbers_ending_with_one\
    \ - numbers_starting_with_one ))", "  # $1 is an integer\n  # return 1 if it starts\
    \ with 1, 0 otherwise\n  start_with_one() {\n    [[ \"$1\" =~ ^1[0-9]*$ ]]\n \
    \ }\n\n  # $1 is an integer\n  # return 1 if it ends with 1, 0 otherwise\n  end_with_one()\
    \ {\n    [[ \"$1\" =~ ^[0-9]*1$ ]]\n  }\n\n  # return number of 1-digit numbers\
    \ that start or end with 1\n  count_1_digit() {\n    local count=0\n    for ((\
    \ i=1; i<10; i++ )); do\n      if start_with_one \"$i\" || end_with_one \"$i\"\
    ; then\n        (( count++ ))\n      fi\n    done\n    echo \"$count\"\n  }\n\n\
    \  # return number of $1-digit numbers that start or end with 1\n  count_n_digit()\
    \ {\n    local count=0\n    for (( i=10**($1-1); i<10**$1; i++ )); do\n      if\
    \ start_with_one \"$i\" || end_with_one \"$i\"; then\n        (( count++ ))\n\
    \      fi\n    done\n    echo \"$count\"\n  }\n\n  case \"$1\" in\n    1) echo\
    \ \"$(count_1_digit)\" ;;\n    2) echo \"$(count_n_digit 2)\" ;;\n    3) echo\
    \ \"$(count_n_digit 3)\" ;;\n    4) echo \"$(count_n_digit 4)\" ;;\n    5) echo\
    \ \"$(count_n_digit 5)\" ;;\n    6) echo \"$(count_n_digit 6)\" ;;\n    7) echo\
    \ \"$(count_n_digit 7)\" ;;\n    8) echo \"$(count_n_digit 8)\" ;;\n    9) echo\
    \ \"$(count_n_digit 9)\" ;;\n    *) echo \"$(($(starts_one_ends $(( $1 - 1 )))\
    \ + $(starts_one_ends $(( $1 - 2 ))) * 9))\" ;;\n  esac", "    local -i start=0\n\
    \    local -i end=0\n    local -i number=$1\n    local -i digit=0\n    local -i\
    \ counter=0\n    for((counter=1; counter<=$number; counter++)); do\n        number=$counter\n\
    \        # get the first digit\n        digit=$(( number / 10 ** ( number / 10)\
    \ ))\n        if [[ $digit -eq 1 ]]; then\n            start=$(( start + 1 ))\n\
    \        fi\n        # get the last digit\n        digit=$(( number % 10 ))\n\
    \        if [[ $digit -eq 1 ]]; then\n            end=$(( end + 1 ))\n       \
    \ fi\n    done\n    echo \"Starts with 1: $start\"\n    echo \"Ends with 1: $end\"",
  "    for (( count=0, i=1; i<=$1; i++ )); do\n        if [[ $i == 1* ]] || [[ $i\
    \ == *1 ]]; then\n            (( count++ ))\n        fi\n    done\n    echo $count",
  "  local n=$1\n  local f1=1\n  local f2=1\n  local f=1\n  local sum=0\n  local i=0\n\
    \  for ((i=0; i<n; i++)); do\n    sum=$((sum + f1 + f2))\n    f=$((f1 + f2))\n\
    \    f1=$f2\n    f2=$f\n  done\n  echo $sum", "    # only one digit, so can only\
    \ be 1\n    [ \"$1\" == \"1\" ] && echo 1 && return\n    # number of starting\
    \ with 1 + number of ending with 1\n    echo $(( $(starts_one_ends $(($1 - 1)))\
    \ + $(starts_one_ends $(($1 - 2))) ))", "    local n=\"$1\"\n    # If n==1, there\
    \ are 2 such numbers, 1 and 11\n    if [ \"$n\" == \"1\" ]; then\n        echo\
    \ \"2\"\n        return\n    fi\n    # If n==2, there are 11 such numbers, 1x,\
    \ x1, 11\n    if [ \"$n\" == \"2\" ]; then\n        echo \"11\"\n        return\n\
    \    fi\n    # If n>2, there are 90 such numbers, of the forms 1xx, x1x, xx1\n\
    \    echo \"90\"", '    [[ $1 =~ ^1 ]] && echo 1 || echo 0', "  local digits=\"\
    $1\"\n  # 1-digit numbers all start with 1\n  local result=\"1\"\n  # number of\
    \ decimals that fit in a square of ones,\n  # starting with the case of 1x1 and\
    \ going up to digits x digits\n  # This is really only here to help visualize\
    \ what's going on,\n  # and it's not really needed to solve the puzzle.\n  for\
    \ i in $(seq 1 \"$digits\"); do\n    local square=$(pow \"$i\" \"$i\")\n    result=$(bc\
    \ <<< \"$result+$square\")\n  done\n  echo \"$result\"", "    for i in $(seq 1\
    \ $1); do\n        echo \"1$(seq $i | sed 's/[0-9]//g')1\"\n    done", "  local\
    \ n=$1\n  # n-digit positive integers that start with 1 \n  local start=$((10**($n-1)))\n\
    \  # n-digit positive integers that end with 1\n  local ends=$((10**($n-1)))\n\
    \  echo $((start + ends))", "  local -i limit\n  local numbers\n\n  limit=$1\n\
    \  numbers=$(seq -f '%0.f' 1 $limit)\n  grep -E '^1|1$' <<< \"$numbers\" | wc\
    \ -l", "  awk 'BEGIN {\n    for (i = 1; i <= n; i++) {\n      sum += (int(i /\
    \ 10) == 1 || i % 10 == 1)\n    }\n    print sum\n  }' n=$1", "  printf '%s\\\
    n' {1..$1}", "    num_digits=$1\n    # a digit always starts with 1\n    starts_one_ends=1\n\
    \    if [[ $num_digits > 1 ]]; then\n        # the last digit always ends with\
    \ 1\n        ends_one=1\n        # if the number has more than 1 digit,\n    \
    \    # the penultimate digit can be any number from 0-9\n        for ((i = 2;\
    \ i < num_digits; i++)); do\n            num_digits_excl_one=$((num_digits - 1))\n\
    \            # the penultimate digit can be 0 - 9\n            penultimate=$((10\
    \ ** num_digits_excl_one))\n            # the last digit can be 0 - 9\n      \
    \      last=10\n            # add the number of combinations for each digit\n\
    \            ends_one=$((ends_one + penultimate * last))\n        done\n     \
    \   # update number of counts that ends with 1\n        starts_one_ends=$((starts_one_ends\
    \ + ends_one))\n    fi\n    echo $starts_one_ends", "    # Append \"1\" and \"\
    1\" to the number of digits.\n    echo $((`seq -s 1 -w $1 $1 | wc -l` * 2))",
  "    local i j\n    local out=0\n    local len=\"${#1}\"\n    for ((i=1; i<=\"$len\"\
    ; i++)); do\n        for ((j=1; j<=\"$len\"; j++)); do\n            if [[ $i -eq\
    \ 1 ]] || [[ $j -eq 1 ]]; then\n                (( out++ ))\n            fi\n\
    \        done\n    done\n    echo \"$out\"", "    local count\n    local input\n\
    \n    if [[ $1 -eq 1 ]]; then\n        return 1\n    fi\n\n    # count = (10^n\
    \ - 2*10^(n-1) + 10^(n-2)) / 9\n    input=$1\n    count=$((input * (10 ** (input\
    \ - 1)) - 2 * (10 ** (input - 1)) + (10 ** (input - 2))))\n    count=$((count\
    \ / 9))\n    echo \"$count\"", "  local n=$1\n  if [[ $n -eq 1 ]]; then\n    echo\
    \ 1\n  else\n    local -i lo=0\n    local -i hi=0\n    for ((j=1; j<n; j++));\
    \ do\n      hi=$(starts_one_ends $j)\n      lo=$(starts_one_ends $((n-j)))\n \
    \     echo $((lo*hi))\n    done\n  fi", "  local digits=$1; shift\n  local start=10\n\
    \  local end=1\n  local multiply_by_ten=1\n  local multiply_by_one=1\n  for i\
    \ in $(seq 1 $digits); do\n    if [ $i -eq 1 ]; then\n      multiply_by_ten=1\n\
    \      multiply_by_one=1\n    else\n      multiply_by_ten=$((multiply_by_ten *\
    \ 10))\n      multiply_by_one=$((multiply_by_one * 10))\n    fi\n    start=$((start\
    \ + multiply_by_ten))\n    end=$((end + multiply_by_one))\n  done\n  local total=$((start\
    \ + end))\n  echo $total", "  n=$1\n\n  if [[ $n -eq 1 ]]; then\n    echo 1\n\
    \    return\n  fi\n\n  # The number is formed by the concatenation of $k digits\
    \ with the digit 1.\n  # With $k > 1, we obtain ${k - 1}\u22C59^(k - 1) numbers.\
    \ Since there is no\n  # constraint on the number of digits, with $k = 1, we obtain\
    \ 9 numbers. We\n  # also obtain ${k - 1}\u22C59^(k - 1) numbers with $k = n.\n\
    \n  # The number is formed by the concatenation of $k digits with the digit 1.\n\
    \  # With $k < n, we obtain ${k + 1}\u22C59^k numbers. Since there is no constraint\n\
    \  # on the number of digits, with $k = 1, we obtain 9 numbers. We also obtain\n\
    \  # ${k + 1}\u22C59^k numbers with $k = n.\n\n  # We add the contributions for\
    \ n = 1, n = n and n = n - 1.\n  echo $((9 * (2 * n - 1) + 9))", "  # Define variables\n\
    \  local _num=$1\n  local _counter=0\n  local _start=1\n  local _end=10\n  local\
    \ _x=0\n  local _y=0\n  local _res=0\n\n  # Loop: Start counting\n  while (( _start\
    \ < _end )); do\n    _x=$(echo $_start^$_num | bc)\n    _y=$(echo $_end^$_num\
    \ | bc)\n    _res=$(($_y - $_x))\n    _counter=$(($_counter + $_res))\n    _start=$(($_start\
    \ + 1))\n    _end=$(($_end + 1))\n  done\n\n  # Output Result\n  echo $_counter",
  "  local i=1\n  local count=0\n  while [ $i -le $1 ]; do\n    count=$(( count +\
    \ 9*10**((i-1)/2) ))\n    if [ $(( i % 2 )) -eq 0 ]; then\n      count=$(( count\
    \ + 10**((i-2)/2) ))\n    fi\n    i=$(( i + 1 ))\n  done\n  echo $count", "  \
    \  local num=$1\n    local starts=0\n    local ends=0\n    let \"starts=$num-1\"\
    \n    let \"ends=$num-1\"\n    echo $((10**$starts+10**$ends))", "  local n=$1\n\
    \  local starts_with_one=$(( 10 ** (n - 1) ))\n  local ends_with_one=$(( 10 **\
    \ (n - 2) ))\n  echo $(( starts_with_one + ends_with_one ))", "    number=$1\n\
    \    ndigits=$(echo \"$number\" | wc -c)\n    ndigits=$((ndigits - 1))\n\n   \
    \ if [ \"$ndigits\" -eq 1 ]; then\n        echo 1\n        return\n    fi\n\n\
    \    # Count the numbers that start with one.\n    start_with_one=$((10 ** (ndigits\
    \ - 1)))\n\n    # Count the numbers that end with one.\n    end_with_one=$(((10\
    \ ** (ndigits - 1)) - 1))\n\n    echo $((start_with_one + end_with_one))", " \
    \   [[ $1 =~ ^0.*$ ]] && return 0\n    [[ $1 =~ ^1.*$ ]] && return 1\n    [[ $1\
    \ =~ ^.*1$ ]] && return 1\n    return 0", "  local n=$1\n\n  # invalid\n  if [[\
    \ $n -lt 1 ]]; then\n    echo 0\n    return\n  fi\n\n  # 1\n  if [[ $n -eq 1 ]];\
    \ then\n    echo 1\n    return\n  fi\n\n  # n > 1\n  local n_minus_one=$((n -\
    \ 1))\n  local n_minus_two=$((n - 2))\n  local n_minus_one_pow_10=$(( 10 ** $n_minus_one\
    \ ))\n  local n_minus_two_pow_10=$(( 10 ** $n_minus_two ))\n  local n_minus_one_count=$(starts_one_ends\
    \ $n_minus_one)\n  local n_minus_two_count=$(starts_one_ends $n_minus_two)\n \
    \ local total=$((n_minus_one_count + n_minus_two_count))\n  local ends_in_one=$((total\
    \ - n_minus_one_count))\n  local count=$((total + ends_in_one))\n  echo $count",
  "    local count=0\n    local number=$1\n    if [ $number -ge 10 ]; then\n     \
    \   local digits=$(echo \"$number\" | wc -c)\n        local min=$(echo \"$((${number}/10))\"\
    \ | bc)\n        local max=$(echo \"$(((${number}/10) * 10))\" | bc)\n       \
    \ count=$(($digits - 1))\n        if [ $digits -gt 2 ]; then\n            min=$(echo\
    \ \"($min + 1)\" | bc)\n            max=$(echo \"($max - 1)\" | bc)\n        \
    \    for i in $(seq $min $max); do\n                local sum=$(starts_one_ends\
    \ $i)\n                count=$(($count + $sum))\n            done\n        fi\n\
    \    elif [ $number -ge 2 ]; then\n        count=1\n    fi\n    echo $count",
  "    local n=\"$1\"\n    let n++\n    n=$(printf \"%d\" \"$n\")\n    local s=$(printf\
    \ \"%s\" \"$n\" | tr -d '1')\n    local r=${s//[0-9]/9}\n    echo \"$((10**${#s}\
    \ - 10**${#r}))\"", "  local n=${1:-1}\n  local l=$(($n - 1))\n  local start=1\n\
    \  local end=1\n  if [[ $n -eq 1 ]]; then\n    echo 1\n    return\n  fi\n  echo\
    \ $((start + $((10 ** $l)) - 2 + end))", "  python <<-EOF\n\tn = int($1)\n\tcount\
    \ = 0\n\tfor i in range(1, n + 1):\n\t  if str(i).startswith('1') or str(i).endswith('1'):\n\
    \t    count += 1\n\tprint(count)\n\tEOF", "  local -i digits=$1\n  local -i start_count=0\n\
    \  local -i end_count=0\n  local -i start_index=0\n  local -i end_index=0\n  local\
    \ -i mid_index=0\n  local -i total_count=0\n\n  # There are n - 1 digits between\
    \ the start and end of our search.\n  # We need to know how many different numbers\
    \ of this length we can\n  # produce with the given number of digits.\n  local\
    \ -i num_values=9**(${digits} - 1)\n\n  # The first digit of the number can only\
    \ be 1.\n  if [ ${digits} -gt 1 ]; then\n    start_count=1\n  else\n    start_count=1\n\
    \  fi\n\n  # The last digit of the number can only be 1.\n  if [ ${digits} -gt\
    \ 1 ]; then\n    end_count=1\n  else\n    end_count=1\n  fi\n\n  # If the number\
    \ of digits is even, then the start and end counts will\n  # be the same. Otherwise,\
    \ they will be different.\n  if [ $(( ${digits} % 2 )) -eq 0 ]; then\n    mid_index=$((\
    \ ${digits} / 2 ))\n    # For even numbers of digits, there are two places where\
    \ the count of\n    # numbers starting with 1 and ending with 1 is the same. So\
    \ we need to\n    # add these counts together.\n    start_index=$(( ${digits}\
    \ - 2 ))\n    end_index=$(( ${digits} - 1 ))\n    total_count=$(( ${start_count}\
    \ * ${num_values} + ${end_count} * ${num_values} ))\n  else\n    # For odd numbers\
    \ of digits, there are no places where the count of\n    # numbers starting with\
    \ 1 and ending with 1 is the same.\n    start_index=$(( ${digits} - 1 ))\n   \
    \ end_index=$(( ${digits} - 1 ))\n    total_count=$(( ${start_count} * ${num_values}\
    \ + ${end_count} * ${num_values} ))\n  fi\n\n  # We have the counts for the starting\
    \ and ending digits. Add them.\n  echo ${total", "    if [ $1 -lt 10 ]; then\n\
    \        echo 1\n        return\n    fi\n\n    declare -i a=9 b=1\n\n    for i\
    \ in $(seq $1 -1 2); do\n        (( a *= 10 ))\n        (( b *= 10 ))\n    done\n\
    \n    (( a += b ))\n    echo $a", "  first=1\n  last=$(($1 - 1))\n  start_ones=$((9\
    \ * $first**$last))\n  end_ones=$((10 * $first**$(($1 - 2))))\n  echo $((start_ones\
    \ + end_ones))", "  local n=\"$1\"\n  if [[ $n == 1 ]]; then\n    echo 0\n  elif\
    \ [[ $n == 2 ]]; then\n    echo 9\n  else\n    local res=9\n    local i=1\n  \
    \  while [[ $i -lt $n ]]; do\n      let res=res+9*10**i\n      let i=i+1\n   \
    \ done\n    echo $res\n  fi", "  local n=$1\n  local n1=$(($n - 1))\n  local count=$((10\
    \ ** $n1))\n  echo $count", "  local num=\"$1\"\n  local count=0\n  for n in $(seq\
    \ 1 $num); do\n    count=$((count + starts_one_ends_helper \"$n\"))\n  done\n\
    \  echo \"$count\"", "  local n=$1\n  local m=$(( $n - 1 ))\n  # local l=$(( $n\
    \ - 2 ))\n  # local digits\n  # digits=$(echo \"obase=10; ibase=2; (${n} - 1)\"\
    \ | bc)\n  # echo \"digits: $digits\"\n  # return\n  if [[ $n -eq 1 ]]; then\n\
    \    echo 1\n  elif [[ $n -eq 2 ]]; then\n    echo 2\n  else\n    #echo \"9 *\
    \ 9^$l + 2^$m\" | bc\n    echo \"9 * 9^$m + 2^$m\" | bc\n  fi", "  echo \"starts_one_ends\
    \ $1\"\n  if [[ $1 -le 0 ]]; then\n    return 0\n  fi\n  if [[ $1 -eq 1 ]]; then\n\
    \    return 1\n  fi\n  local n=`echo \"$1-1\" | bc`\n  n=`echo \"10^$n\" | bc`\n\
    \  local count=`echo \"2*$n\" | bc`\n  echo \"starts_one_ends $1 = $count\"\n\
    \  return $count", "    local -i n=\"$1\"\n    local -i i\n    local -i count=0\n\
    \    local -i ten=10\n    local -i tenn=\"${ten} ** ${n}\"\n    local -i tenm=\"\
    ${ten} ** (${n} - 1)\"\n    local -i ten1=\"${ten} - 1\"\n    local -i foo\n\n\
    \    # in base 10, count the number of 2**n - 2**(n-1) numbers\n    # that either\
    \ start with 1 or end with 1\n    for ((i=ten1; i<tenn; i++)); do\n        foo=\"\
    ${i}\"\n        if [[ \"${foo:0:1}\" -eq 1 ]] || [[ \"${foo: -1}\" -eq 1 ]]; then\n\
    \            (( count++ ))\n        fi\n    done\n\n    echo \"${count}\"", " \
    \   local n=\"$1\"\n    # TODO", "    local -i n=\"$1\"\n    # If n is 1, the\
    \ only possibility is 1\n    if (( n == 1 )); then\n        echo 1\n        return\n\
    \    fi\n    # If n is 2, all numbers begin with 1, and there are 10 such numbers\n\
    \    if (( n == 2 )); then\n        echo 10\n        return\n    fi\n    # If\
    \ n is 3, there are 9*9 possible combinations for the middle digits\n    # and\
    \ 2 for the start/end digits, so the answer is 2*9*9\n    if (( n == 3 )); then\n\
    \        echo 18\n        return\n    fi\n    # For numbers n >= 4, we have a\
    \ choice of 8 numbers in the second\n    # digit and 9 in the last digit, so the\
    \ answer is 9*8*(10^(n-2))\n    echo \"$((9*8*(10**(n-2))))\"", "  [ \"$1\" -eq\
    \ 1 ] && echo 1 && return 0\n  [ \"$1\" -eq 2 ] && echo 1 && return 0\n  c=0\n\
    \  if [ \"$1\" -ge 5 ]; then\n    c=$((c + 9 * 9 * 8))\n  fi\n  if [ \"$1\" -ge\
    \ 4 ]; then\n    c=$((c + 9 * 9 * 9))\n  fi\n  if [ \"$1\" -ge 3 ]; then\n   \
    \ c=$((c + 9 * 9 * 9))\n  fi\n  if [ \"$1\" -ge 2 ]; then\n    c=$((c + 9 * 9))\n\
    \  fi\n  echo $c", "    for (( i=1; i<=$1; i++ )); do\n        local -i n=$i\n\
    \        local -i count=0\n        (( n /= 10 ))\n        while [[ $n -gt 0 ]];\
    \ do\n            (( n /= 10 ))\n            (( count++ ))\n        done\n   \
    \     echo $count\n    done", "    local total=0\n    for (( i=1; i<=$1; i++ ));\
    \ do\n        (( total += i ))\n    done\n    echo \"$total\"", "  local n=$1\n\
    \  local sum=0\n  local i=0\n  if [ $n -eq 1 ]; then\n    echo 1\n    return\n\
    \  fi\n  for i in $(seq 1 $n); do\n    sum=$((sum + $(binom $i $n)))\n  done\n\
    \  echo $(($sum * 2))", "    local n=$1\n    local r=0\n    # printf is used to\
    \ avoid using external utilities like expr\n    # we do not include 0 and 1 and\
    \ count them later\n    # we can only use pure bash arithmetic\n    for ((i=2;\
    \ i<$((10**$n)); i++)); do\n        if [[ $(printf '%s' \"$i\" | grep -o \"^1\"\
    ) ]]; then\n            let r+=1\n        fi\n        if [[ $(printf '%s' \"$i\"\
    \ | grep -o \"1$\") ]]; then\n            let r+=1\n        fi\n    done\n   \
    \ # the numbers 0 and 1 have to be counted\n    echo $((r+2))", "    local n=$1\n\
    \    local digits=$n\n    local count=$((10 ** (n - 1)))\n    while [[ $digits\
    \ -gt 1 ]]; do\n        count=$((count + (10 ** ((digits - 1) / 2))))\n      \
    \  digits=$((digits - 1))\n    done\n    echo $count", "    if [ $1 -eq 1 ]; then\n\
    \        echo 1\n        return\n    fi\n\n    # If you don't start with a 1,\
    \ there is only 1 way to fill the\n    # remaining digits. If you start with a\
    \ 1, you have $1-1 remaining\n    # digits to fill and can add up to 2 of each\
    \ digit.\n    nums=$(((($1-1)*2)+1))\n    nums=$((nums-2))\n    nums=$((nums*9))\n\
    \    nums=$((nums+11))\n    echo $nums", "  if [[ $1 -eq 1 ]]; then\n    echo\
    \ 2\n  else\n    number=$1\n    starts_with=1\n    count=0\n    for i in $(seq\
    \ 1 ${number}); do\n      if [[ ${starts_with} -eq 0 ]]; then\n        count=$((count\
    \ + 1))\n      fi\n      starts_with=$((starts_with * 10))\n    done\n    echo\
    \ $((count + 1))\n  fi", "    local n=\"$1\"\n    local sum=0\n    for i in $(seq\
    \ 1 $n); do\n        if [[ $i == 1 ]]; then\n            sum=$((sum + 9))\n  \
    \      else\n            sum=$((sum + 10**(i-1) + 10**(i-1)))\n        fi\n  \
    \  done\n    echo $sum", "    if [[ \"$1\" =~ ^[1-9][0-9]*$ ]]; then\n       \
    \ for i in $(seq 1 $1); do\n            echo $((10**$i - 10**($i-1)))\n      \
    \  done | paste -sd+ | bc\n    else\n        echo -1\n    fi", "  declare -i n=$1;\n\
    \  if [[ $n -eq 1 ]]; then\n    echo 1;\n  else\n    echo \"$(starts_one_ends\
    \ $((n-1))) $(one_in_the_middle $((n-1)))\";\n  fi", "  local n=\"$1\"\n  local\
    \ c=0\n  local a=0\n  local b=0\n  while [ \"$c\" -lt \"$n\" ]; do\n    a=$((\
    \ 10**c - 1 ))\n    b=$(( (10**(c+1)) - 10**c ))\n    c=$(( c + 1 ))\n    echo\
    \ -n \"$(( $b + $a )) \"\n  done\n  echo", "  # First, if the number is < 10,\
    \ then it must be 1 or a single\n  # digit number like 5.\n\n  if [ $1 -lt 10\
    \ ]; then\n    echo 1\n    return\n  fi\n\n  # Next, if the number is between\
    \ 10 and 99, we have 11 possible\n  # numbers, because 10 is a possibility.\n\n\
    \  if [ $1 -lt 100 ]; then\n    echo 11\n    return\n  fi\n\n  # We now have a\
    \ bigger number.  Count the number of digits, then\n  # use the floor method to\
    \ find the exponent that's the greatest\n  # power of 10 less than the number.\n\
    \n  let n_digits=$(num_digits $1)\n  let exponent=$(num_digits $1)-1\n\n  # Now,\
    \ we have to make a smart choice:\n  #\n  # (1) If the number's first digit is\
    \ 1, then we should multiply\n  # by 10^(n-1).\n  #\n  # (2) If the number's first\
    \ digit is not 1, then we should\n  # multiply by 9*10^(n-1).\n  #\n  # (3) If\
    \ the number's last digit is 1, then we should multiply\n  # by 10^(n-1).\n  #\n\
    \  # (4) If the number's last digit is not 1, then we should\n  # multiply by\
    \ 9*10^(n-1).\n  #\n  # (5) If the number's first and last digits are both 1,\
    \ then we\n  # should take the sum of 1, 2, 3, and 4, then subtract\n  # 1*10^(n-2).\n\
    \n  first_digit=$(echo $1 | cut -c 1)\n  last_digit=$(echo $1 | cut -c $n_digits)\n\
    \n  if [ $first_digit -eq 1 ]; then\n    if [ $last_digit -eq 1 ]; then\n    \
    \  echo $(($(echo 10^$exponent)*10+2*$(echo 9^$exponent)-$(echo 10^$(($exponent-1)))))\n\
    \    else\n      echo $(($(echo 10^$exponent)+$(echo 9^$exponent)))\n    fi\n\
    \  else\n", "    local n=$1\n    if [ $n -lt 1 ]; then\n        echo \"ERROR:\
    \ n must be positive\"\n        return 1\n    fi\n    local count=0\n    for i\
    \ in $(seq 1 $n); do\n        count=$((count + 2))\n    done\n    echo $count",
  "    local n=$1\n    local s=\"\"\n    for (( i=0; i<n; i++ )); do\n        s+=\"\
    1\"\n    done\n    for (( i=0; i<n; i++ )); do\n        echo $s\n        s=${s#?}0\n\
    \    done", "  local count=0\n\n  for i in $(seq -w $1); do\n    if [[ $i =~ ^1\
    \ ]] || [[ $i =~ 1$ ]]; then\n      count=$((count + 1))\n    fi\n  done\n\n \
    \ echo $count", "  # If the number is 1, there is only one positive integer of\
    \ size 1\n  if [ $1 -eq 1 ]; then\n    echo 1\n    return\n  fi\n\n  #\n  # We\
    \ are looking for positive integers composed of 1s.\n  # If a number is of length\
    \ N, it's smaller than a number of length N+1\n  # So we find the length of the\
    \ number we are looking for,\n  # and subtract the number of n-digit positive\
    \ integers with size less than that.\n  #\n  max_n=$1\n  count=0\n  for (( n=1;\
    \ n<=max_n; n++ )); do\n    count=$(( count + $(starts_one_ends $n) ))\n  done\n\
    \  # The number of n-digit positive integers that start or end with 1\n  #  is\
    \ the number of n-digit positive integers\n  #  minus the number of n-digit positive\
    \ integers that do not start or end with 1\n  echo $(( $(starts_one_ends $max_n)\
    \ - count ))", "    local n=$1 i=0 count=0\n\n    for ((i=0; i < n; i++)); do\n\
    \        count=$((count + 10**i))\n    done\n\n    echo $count", "    local -n\
    \ res=$3\n    local n=$1 i\n    local start=1 end\n    local pow=10 digit\n  \
    \  ((res=0))\n    for ((i=1; i<=$n; i++)); do\n        ((end=$pow-1))\n      \
    \  ((digit=$n-i))\n        ((pow*=10))\n        ((res+=$end-$start+1))\n     \
    \   ((start*=10))\n        ((res+=digit*$start))\n    done", "  n=$1\n  number_of_digits=$n\n\
    \  while [[ $number_of_digits -gt 0 ]]; do\n    let power_of_ten=$number_of_digits-1\n\
    \    let 10**$power_of_ten\n    let count_of_number=$number_of_digits-1\n    let\
    \ count_of_numbers=$count_of_numbers+$count_of_number\n    let number_of_digits=$number_of_digits-1\n\
    \  done\n  echo \"$count_of_numbers\"", "    local digit_count=$1\n    local suffix\n\
    \    local count=0\n\n    for i in $(seq 1 $digit_count); do\n        suffix=$(seq\
    \ $i $digit_count | tr -d '\\n')\n        count=$((count + 10**(digit_count-i)*i))\n\
    \    done\n\n    echo $count", "  local -ir n=\"$1\"\n  local -i count=0\n  local\
    \ -i i=0\n\n  if (( n < 1 )); then\n    return 1\n  fi\n\n  while (( i < n ));\
    \ do\n    (( count += 10 ** i ))\n    (( i++ ))\n  done\n\n  return $count", " \
    \ local -i num=\"$1\"\n  local -i one\n  local -i max=\"${#num}\"\n  local -i\
    \ result=0\n  local -i i\n\n  for ((i=0; i<max; i++)); do\n    one=\"${num:$i:1}\"\
    \n    if [[ $one == 1 ]]; then\n      ((result++))\n    fi\n  done\n\n  echo \"\
    $result\"", "    num_digits=$1\n    case $num_digits in\n        1)\n        \
    \    echo 2\n            ;;\n        2)\n            echo 9\n            ;;\n\
    \        *)\n            # From https://math.stackexchange.com/questions/1457990/how-many-n-digit-numbers-that-start-or-end-with-1\n\
    \            echo $((10**($num_digits-1) + 10**($num_digits-2) + 9))\n       \
    \     ;;\n    esac", "    let 'total = 0'\n    for i in `seq 1 $1`; do\n     \
    \   for j in `seq 1 $i`; do\n            echo \"$i $j\"\n            let 'total\
    \ = total + 2'\n        done\n    done\n    echo \"$total\"", "    local n=$1\n\
    \    local prefix=0\n    local suffix=0\n    local tmp=0\n    for (( i=0; i<$n;\
    \ i++ )); do\n        (( tmp=prefix+suffix ))\n        (( prefix=(10**(i+1))+9*tmp\
    \ ))\n        (( suffix=10*suffix+9 ))\n    done\n    echo $(( prefix+suffix ))",
  "  declare -i count=0\n  for (( i=1; i<=$1; i++ )); do\n    num_str=\"$i\"\n   \
    \ if [[ \"${num_str:0:1}\" == \"1\" ]] || [[ \"${num_str:(-1)}\" == \"1\" ]];\
    \ then\n      (( count++ ))\n    fi\n  done\n  echo \"$count\"", "  local d=$1\
    \ i=1\n  for ((; i <= $d; i++)); do\n    echo \"$((i + 1))\"\n  done", "  local\
    \ n=$1\n  local o=0\n  local t=1\n  local i\n\n  for ((i=2; i <= n; i++)); do\n\
    \    t=$((o + t))\n    o=$((o + t))\n  done\n\n  t=$((o + t))\n  echo $t", " \
    \   num_digits=$1\n    local i\n    local -i num_num_starts_ends=0\n    local\
    \ -i num_nums_ends=0\n    local -i num_nums_starts=0\n    local -i temp_num\n\
    \    for ((i=10**($num_digits-1); i<10**$num_digits; i++)); do\n        temp_num=$i\n\
    \        temp_num=$((temp_num%10))\n        if [[ $temp_num -eq 1 ]]; then\n \
    \           num_nums_ends=$((num_nums_ends+1))\n        fi\n        temp_num=$i\n\
    \        temp_num=$((temp_num/10))\n        if [[ $temp_num -eq 1 ]]; then\n \
    \           num_nums_starts=$((num_nums_starts+1))\n        fi\n    done\n   \
    \ num_num_starts_ends=$((num_nums_ends+num_nums_starts))\n    echo $num_num_starts_ends",
  "    if [[ $1 -eq 1 ]]; then\n        echo \"2\"\n        return\n    fi\n    if\
    \ [[ $1 -eq 2 ]]; then\n        echo \"4\"\n        return\n    fi\n    echo $((9*9**$((\
    \ $1 - 2 )) + 9*10**$(( $1 - 2 )) + 1))", "    n=$1\n    if [ $n -eq 1 ]; then\n\
    \        echo 1\n    else\n        # For example, if n = 5:\n        #   9 * 9\
    \ * 8 * 7 * 6 is all numbers with 5 digits.\n        #   9 * 9 * 8 * 7 * 1 is\
    \ all numbers with 5 digits that end with 1.\n        #   9 * 9 * 8 * 1 * 1 is\
    \ all numbers with 5 digits that start with 1.\n        #   9 * 9 * 1 * 1 * 1\
    \ is all numbers with 5 digits that start and end\n        #   with 1.\n     \
    \   #   1 * 1 * 1 * 1 * 1 is the count of numbers with 5 digits that start\n \
    \       #   and end with 1.\n        digits_start_end_one=$(($n * $n * $n * $n\
    \ * $n))\n        digits_start_one=$(($n * $n * $n * $n))\n        digits_end_one=$(($n\
    \ * $n * $n * $n))\n        digits_none_one=$(($n * $n * $n * $n * $n - digits_start_end_one\
    \ - digits_start_one - digits_end_one))\n        total=$(($digits_start_end_one\
    \ / 5 + $digits_start_one + $digits_end_one - $digits_none_one))\n        echo\
    \ $total\n    fi", "    local n=\"$1\"\n\n    echo $((\n        n ** 2 +\n   \
    \     n -\n        1\n    ))", "    local i=$1\n    local count=0\n    local temp_count=0\n\
    \    local ab=''\n    local is_one=0\n    local is_start_one=0\n    local is_end_one=0\n\
    \    while (( i > 0 )); do\n        is_one=0\n        is_start_one=0\n       \
    \ is_end_one=0\n        ab=$(echo $i | sed 's/\\(.*\\)./\\1/')\n        if [[\
    \ \"${ab}\" == \"\" ]]; then\n            is_one=1\n        fi\n        if [[\
    \ \"${ab:0:1}\" == \"1\" ]]; then\n            is_start_one=1\n        fi\n  \
    \      if [[ \"${ab: -1}\" == \"1\" ]]; then\n            is_end_one=1\n     \
    \   fi\n        if (( is_one == 1 || is_start_one == 1 || is_end_one == 1 ));\
    \ then\n            temp_count=$((temp_count + 1))\n        fi\n        i=$(echo\
    \ $i | sed 's/.\\(.*\\)/\\1/')\n    done\n    count=$((count + temp_count))\n\
    \    echo $count", "  local i\n  local count=0\n  for ((i=1; i<=\"$1\"; i++));\
    \ do\n    if [[ \"${i:0:1}\" -eq 1 ]] || [[ \"${i: -1}\" -eq 1 ]]; then\n    \
    \  ((count++))\n    fi\n  done\n  echo \"$count\"", "  local total=0\n  local\
    \ i=1\n  local j=0\n  local num=1\n  local exp\n  ((exp = $1 - 1))\n  while ((num\
    \ <= 9 ** exp)); do\n    if [[ ${num:0:1} == 1 ]]; then\n      ((++total))\n \
    \   fi\n    num=\"$(($num + 1))\"\n  done\n  echo $total", "    local count=0\n\
    \    for i in $(seq 1 $1); do\n        for j in $(seq 0 9); do\n            for\
    \ k in $(seq 0 9); do\n                if [ \"$i\" -gt 1 ]; then\n           \
    \         echo \"$j$(printf \"%0${i}d\" 1)$k\"\n                elif [ \"$j\"\
    \ -eq 1 ] || [ \"$k\" -eq 1 ]; then\n                    count=$((count + 1))\n\
    \                fi\n            done\n        done\n    done\n    echo $count",
  "  local -i x=$1\n  local -i count=0\n  for ((i=1; i<=x; i++)); do\n    if [[ ${i:0:1}\
    \ == 1 ]] || [[ ${i: -1} == 1 ]]; then\n      count+=1\n    fi\n  done\n  echo\
    \ $count", "  if [ $1 -lt 1 ]; then return 0; fi\n  if [ $1 -eq 1 ]; then return\
    \ 1; fi\n  if [ $1 -eq 2 ]; then return 2; fi\n  local -i c=0\n  for i in $(seq\
    \ $((10**($1-1))) $((10**$1-1))); do\n    if [[ $i =~ ^1.*1$ ]]; then\n      c+=1\n\
    \    fi\n  done\n  echo $c", "  local n=$1\n  local NUMS[0]=1\n  local NUMS[1]=10\n\
    \  local NUMS[2]=100\n  local NUMS[3]=1000\n  local NUMS[4]=10000\n  local NUMS[5]=100000\n\
    \  local NUMS[6]=1000000\n  local NUMS[7]=10000000\n  local NUMS[8]=100000000\n\
    \  local NUMS[9]=1000000000\n  local LIM=${NUMS[$n]}\n  local count=0\n  local\
    \ i=0\n  while [ $i -lt $LIM ]; do\n    local num=$i\n    local str=$i\n    local\
    \ len=${#str}\n    local c=$len\n    local left=$(echo $num | cut -c1)\n    local\
    \ right=$(echo $num | cut -c$c)\n    if [ $left -eq 1 ] || [ $right -eq 1 ]; then\n\
    \      ((count++))\n    fi\n    ((i++))\n  done\n  echo $count", "  local count=$1\n\
    \  local result=0\n  local start=1\n  local end=1\n  local i=1\n  local interval=10\n\
    \  local check=0\n  local tens=$(($count-1))\n  while [ $tens -gt 0 ]; do\n  \
    \  interval=$(($interval*10))\n    tens=$(($tens-1))\n  done\n  while [ $start\
    \ -lt $interval ]; do\n    check=$(($start % 10))\n    if [ $check -eq 1 ]; then\n\
    \      result=$(($result+1))\n    fi\n    start=$(($start+1))\n  done\n  interval=$(($interval/10))\n\
    \  start=$(($interval-1))\n  tens=$(($count-1))\n  while [ $tens -gt 0 ]; do\n\
    \    start=$(($start*10))\n    tens=$(($tens-1))\n  done\n  while [ $start -lt\
    \ $interval ]; do\n    check=$(($start % 10))\n    if [ $check -eq 1 ]; then\n\
    \      result=$(($result+1))\n    fi\n    start=$(($start+1))\n  done\n  echo\
    \ $result", "    local count=0\n    for i in $(seq 1 $1); do\n        local start=`echo\
    \ $i | cut -c 1`\n        local end=`echo $i | cut -c $i`\n        if [ $start\
    \ == 1 ] || [ $end == 1 ]; then\n            count=$((count+1))\n        fi\n\
    \    done\n    echo $count", "    if [[ $1 -lt 1 ]]; then\n        return 0\n\
    \    elif [[ $1 -eq 1 ]]; then\n        echo 1\n        return 1\n    fi\n\n \
    \   local res=0\n    for i in $(seq $1); do\n        res=$(( res + $(starts_one_ends\
    \ $(( i - 1 ))) * 10 ))\n    done\n    echo $res", "    local num_digits=\"$1\"\
    \n    local start=1\n    local end=1\n    for _ in $(seq 1 $((num_digits - 1)));\
    \ do\n        start=$((start * 10))\n        end=$((end * 10 + 1))\n    done\n\
    \    echo $((end - start))", "  if [ $1 -lt 2 ]; then\n    echo \"1\"\n  else\n\
    \    echo \"$(( $(starts_one_ends $(( $1 - 1 )) ) * 9 ))\"\n  fi", "  local ints=0\n\
    \  # count all the numbers that start with a 1\n  for i in $(seq 1 $1); do\n \
    \   ints=$((ints + 10**($1 - $i)))\n  done\n  # count all the numbers that end\
    \ with a 1, but only if it isn't a\n  # leading 1, so minus the number that already\
    \ counted that start with\n  # a leading 1\n  for i in $(seq 1 $((10**$1 - 10**($1\
    \ - 1)))); do\n    [[ ${i: -1} -eq 1 ]] && ints=$((ints + 1))\n  done\n  echo\
    \ $ints", "  num_digits=$1\n  if [[ $num_digits == 0 ]]; then\n    echo 0\n  \
    \  return\n  fi\n  if [[ $num_digits == 1 ]]; then\n    echo 2\n    return\n \
    \ fi\n  # Now we know the number of digits is greater than 1.\n  remaining_digits=$((num_digits\
    \ - 1))\n  # The total number of n-digit integers starting with 1 is\n  # the\
    \ same as the number of (n-1)-digit integers that are\n  # greater than or equal\
    \ to 10.\n  num_start_one=$(starts_one_ends $remaining_digits)\n  # In addition,\
    \ we can have n-digit integers that end with 1. The number of\n  # those is the\
    \ number of (n-1)-digit integers.\n  num_end_one=$(starts_one_ends $remaining_digits)\n\
    \  echo $((num_start_one + num_end_one))", "    local n=$1\n    local count=0\n\
    \    for((x=1; x<$n; x++)); do\n        local d=$((10**x))\n        count=$((count\
    \ + 2*(d/10)))\n    done\n    echo $count", "    # What does it mean for the number\
    \ to start with one?\n    # 1x\n    # 1xx\n    # 1xxx\n    # etc.\n    #\n   \
    \ # What does it mean for the number to end with one?\n    # xx1\n    # xxx1\n\
    \    # xxxx1\n    # etc.\n    #\n    # So any number that starts with 1 can have\
    \ an additional\n    # (n-1) - 1 digits.\n    #\n    # Anything that ends with\
    \ one can have an additional (n-1) - 1 digits.\n    #\n    # So we're counting\
    \ the number of \"1x\" numbers and \"x1\" numbers.\n    #\n    # We count the\
    \ number of \"1x\" numbers with a recursive call to starts_one_ends\n    # where\
    \ the second argument is the number of remaining digits.\n    #\n    # We count\
    \ the number of \"x1\" numbers by multiplying the number of\n    # remaining digits\
    \ by 9.\n    #\n    # Finally, we add the two together.\n    if [ \"$1\" -le 1\
    \ ]; then\n        # We return 1 to count the number of 1 digit numbers that start\
    \ or end with 1.\n        echo 1\n    else\n        echo $((starts_one_ends $(($1\
    \ - 1)) + 9 * $(($1 - 1))))\n    fi", "    if [[ $1 -eq 1 ]]; then\n        echo\
    \ 10\n        return\n    fi\n\n    # Digits without '1' at the start or end\n\
    \    ds=`bc <<< \"($1-2)*9\"`\n\n    # 1*10^n-1, n>1\n    # n-digit numbers with\
    \ '1' at the start\n    ns=`bc <<< \"9*$ds\"`\n\n    # 10^n-1, n>1\n    # n-digit\
    \ numbers with '1' at the end\n    ne=`bc <<< \"9*$ds\"`\n\n    # n-digit numbers\
    \ with '1' at the start and end\n    nse=`bc <<< \"9*$ds\"`\n\n    # ans = ns\
    \ + ne - nse, n>1\n    # n=1: 10\n    echo `bc <<< \"10+$ns+$ne-$nse\"`", "  local\
    \ ret=0\n\n  for i in $(seq 1 $1); do\n    local mult=$((10 ** (i - 1)))\n   \
    \ ret=$((ret + 9 * mult))\n  done\n\n  echo $ret", '  echo "($1+1)/2" | bc', " \
    \ local -i n=$1\n  local -i i=$n\n  local -i res=0\n  while (( i > 0 )); do\n\
    \    res=$(( res + pow10(i - 1) ))\n    (( i-- ))\n  done\n  (( res * 2 ))", " \
    \ # Here's the general strategy:\n  #\n  # For any n-digit number that starts\
    \ with 1, the number of ways to fill the\n  # remaining n-1 digits with digits\
    \ 0-9 is 10^(n-1). Therefore, any n-digit\n  # number that starts with 1 occurs\
    \ 10^(n-1) times in total.\n  #\n  # Similarly, for any n-digit number that ends\
    \ with 1, the number of ways to\n  # fill the remaining n-1 digits with digits\
    \ 0-9 is 10^(n-1). Therefore, any\n  # n-digit number that ends with 1 occurs\
    \ 10^(n-1) times in total.\n  #\n  # However, there are numbers that start and\
    \ end with 1, i.e. of the form 1X1,\n  # where X is any digit between 0-9. These\
    \ numbers occur 9 times for any n\n  # digit number. We remove these by subtracting\
    \ 9.\n  #\n  # All of this results in the following:\n  #\n  #     10^(n-1) +\
    \ 10^(n-1) - 9\n  echo \"$(bc <<< \"10^($1-1) + 10^($1-1) - 9\")\"", "  local\
    \ total=0\n\n  for i in $(seq 1 $1); do\n    total=$((total + $1))\n  done\n\n\
    \  echo $total", "    local -i num\n    local -i count\n    local -i digit\n \
    \   count=0\n    for ((num=1; num<=10**$1; num++)); do\n        for ((digit=10**($1-1);\
    \ digit>=1; digit/=10)); do\n            if (($num/$digit >= 1 && $num/$digit\
    \ < 10)); then\n                if (($num/$digit == 1)); then\n              \
    \      ((count++))\n                    break\n                fi\n          \
    \  fi\n        done\n    done\n    echo $count", "    local total=0\n    local\
    \ i=0\n    local j=0\n    local digit=0\n    local start=0\n    local end=0\n\
    \    local max_power=0\n    local decimal=0\n    local res=0\n    local k=0\n\
    \    local l=0\n    local start_digit=0\n    local end_digit=0\n    local start_decimal=0\n\
    \    local end_decimal=0\n    local start_max_power=0\n    local end_max_power=0\n\
    \    local start_res=0\n    local end_res=0\n    local start_k=0\n    local end_k=0\n\
    \    local start_l=0\n    local end_l=0\n    local start_start_digit=0\n    local\
    \ start_end_digit=0\n    local start_start_decimal=0\n    local start_end_decimal=0\n\
    \    local start_start_max_power=0\n    local start_end_max_power=0\n    local\
    \ start_start_res=0\n    local start_end_res=0\n    local start_start_k=0\n  \
    \  local start_end_k=0\n    local start_start_l=0\n    local start_end_l=0\n \
    \   for i in $(seq 1 $1); do\n        max_power=$((i - 1))\n        for j in $(seq\
    \ 1 $max_power); do\n            decimal=$((10 ** $j))\n            res=$((($i\
    \ - $j) / 2))\n            for k in $(seq 1 $res); do\n                for l in\
    \ $(seq 1 $max_power); do\n                    digit=$((10 ** $l))\n         \
    \           start=$((1 * $digit))\n                    end=$((1 * $digit))\n \
    \                   total=$((total + $start + $end))\n                done\n \
    \           done\n        done\n    done\n    echo $total", "  local n=${1?}\n\
    \  python -c \"print (${n}-1)*2\"", "  local in=\"$1\"\n  local chr=`echo $in\
    \ | cut -c1`\n  local chrl=`echo $in | cut -c${#in}`\n  if [ \"$chr\" = \"1\"\
    \ ] || [ \"$chrl\" = \"1\" ]; then\n    echo 1\n  else\n    echo 0\n  fi", " \
    \ if [[ $1 -lt 1 ]]; then\n    echo 0\n    return 0\n  fi\n  if [[ $1 -eq 1 ]];\
    \ then\n    echo 2\n    return 0\n  fi\n  echo $(( $(starts_one_ends $(( $1 -\
    \ 1 ))) + 9 ))", "  declare -i total=0\n\n  if (( $1 == 1 )); then\n    total=1\n\
    \  elif (( $1 < 4 )); then\n    total=2\n  else\n    total=1\n\n    for ((i=1;\
    \ i<$1; i++)); do\n      if (( $i % 2 == 0 )); then\n        total=$((total *\
    \ 2))\n      else\n        total=$((total * 2 - 1))\n      fi\n    done\n  fi\n\
    \n  echo $total", "    local n=\"$1\"\n    local start_one_end=10\n    local start_one_middle=$((\
    \ 10 ** $((n-2)) ))\n    local start_one_end_digits=1\n    local total=$(( start_one_end\
    \ + start_one_middle * start_one_end_digits ))\n    echo $total", "  # compute\
    \ number of digits\n  local digits=\"$(echo \"$1\" | sed 's/^.*//')\"\n  echo\
    \ \"${digits}\"\n  local -i number_digits=$(echo \"$digits\" | wc -c)\n  # echo\
    \ \"digits=$digits\"\n  # echo \"number_digits=$number_digits\"\n  # compute number\
    \ of digits\n  local -i digits_ending_with_one=9\n  for ((i=1; i<number_digits;\
    \ i++)); do\n    # echo \"i=$i\"\n    digits_ending_with_one=$((digits_ending_with_one\
    \ * 10))\n    # echo \"digits_ending_with_one=$digits_ending_with_one\"\n  done\n\
    \  # echo \"digits_ending_with_one=$digits_ending_with_one\"\n  local -i digits_starting_with_one=$((digits_ending_with_one\
    \ * 9))\n  # echo \"digits_starting_with_one=$digits_starting_with_one\"\n  #\
    \ echo \"$((digits_ending_with_one + digits_starting_with_one))\"\n  echo \"$((digits_ending_with_one\
    \ + digits_starting_with_one))\"", "  local i=1\n  local c=0\n  while [ $i -le\
    \ $1 ]; do\n    c=$(( c + $(echo \"$i-1\" | bc) ))\n    i=$(( i + 1 ))\n  done\n\
    \  echo $c", '  echo "scale=0; ${1}^2" | bc', "  local input=$1\n  local digits=${#input}\n\
    \  local possibilities=1\n  local other_than_one=9\n  local count=0\n\n  while\
    \ [ \"$possibilities\" -lt \"$digits\" ]; do\n    count=$((count + other_than_one\
    \ * possibilities))\n    possibilities=$((possibilities + 1))\n    other_than_one=$((other_than_one\
    \ * 10))\n  done\n\n  local final_possibility=$((10 ** $((digits - 1))))\n  count=$((count\
    \ + other_than_one + $final_possibility))\n\n  echo $count", "    local n=$1\n\
    \    local sum=0\n    local pow=10\n\n    # count which start with 1\n    sum=$((sum\
    \ + n))\n\n    while [ $((--n)) -gt 0 ]; do\n        sum=$((sum + 9 * pow))\n\
    \        pow=$((pow * 10))\n    done\n\n    echo $sum", "  local sum=0\n  local\
    \ out\n  for i in $(seq 1 $1); do\n    if [ $i -eq 1 ]; then\n      let \"sum++\"\
    \n    else\n      out=$((\"$i\" / 10))\n      if [ $out -eq 1 ]; then\n      \
    \  let \"sum++\"\n      else\n        out=$((\"$i\" % 10))\n        if [ $out\
    \ -eq 1 ]; then\n          let \"sum++\"\n        fi\n      fi\n    fi\n  done\n\
    \  echo $sum", "    input=\"$1\"\n    num_digits=\"${#input}\"\n    num_res=0\n\
    \    for ((i=0; i<num_digits; i++)); do\n        if [[ ${input:i:1} == \"1\" ]];\
    \ then\n            num_res=$((num_res+1))\n        fi\n    done\n    printf \"\
    $num_res\"", "  local result\n  declare -a tmp\n  local i\n\n  tmp=($(seq 1 $1))\n\
    \  for i in \"${tmp[@]}\"; do\n    if [[ $i == *1* ]]; then\n      result=\"$result\
    \ $i\"\n    fi\n  done\n  echo \"$result\"", "    for (( i=1; i<=$1; i++ )); do\n\
    \        echo $i\n    done", "  if [ $1 -lt 1 ]; then\n    echo -1\n    return\n\
    \  fi\n\n  lower=$((10**($1-1)))\n  upper=$((10**$1-1))\n  count=0\n  for ((i=$lower;\
    \ i<=$upper; i++)); do\n    str=$(echo $i | sed 's/^1//')\n    str=$(echo $str\
    \ | sed 's/1$//')\n    if [ $str = '' ]; then\n      count=$((count+1))\n    fi\n\
    \  done\n  echo $count", "  count=0\n  num_digits=$1\n  # start with 1\n  count=$((count\
    \ + 9))\n  [ \"$num_digits\" -gt 1 ] && count=$((count + 8))\n  # ends with 1\n\
    \  if [ \"$num_digits\" -gt 1 ]; then\n    for i in $(seq 1 $((num_digits - 1)));\
    \ do\n      count=$((count + 10 ** $i))\n    done\n  fi\n  echo $count", "   \
    \ length=$1\n    total=0\n    for (( i=0; i<10; i++ )); do\n        n=$(bc <<<\
    \ \"2^$((length-1))\")\n        total=$((total+n))\n    done\n    echo $total",
  "  if [ -z \"$1\" ]\n  then\n    echo \"No input\"\n    return 1\n  fi\n\n  if [\
    \ $1 -le 0 ]\n  then\n    echo \"Invalid input\"\n    return 1\n  fi\n\n  echo\
    \ $((9*10**($1-1) + 10**($1-1) - 1))", "    n=$1\n    if [ $n -eq 1 ]; then\n\
    \        # If n is 1, then there is only one number that starts or ends with 1\n\
    \        echo 1\n    else\n        # If n is greater than 1, we can use the 'given\
    \ n, a number that\n        # starts or ends with 1 is either 1 followed by n-1\
    \ digits, or n digits\n        # followed by 1.'\n        #\n        # We use\
    \ recursion to find the counts for n-1 and n and add them\n        starts_one_ends_help\
    \ $n 0\n    fi", "    local n=$1\n    local count=0\n    local start=1\n    local\
    \ end=1\n    local middle=$(echo \"$n-2\" | bc)\n    local total=$(echo \"9^$middle\"\
    \ | bc)\n    while [[ $middle -gt 0 ]]; do\n        local total=$(echo \"$start\
    \ * $total\" | bc)\n        local start=$(echo \"$start * 10\" | bc)\n       \
    \ local middle=$(echo \"$middle-1\" | bc)\n    done\n    while [[ $n -gt 0 ]];\
    \ do\n        local total=$(echo \"$end * $total\" | bc)\n        local end=$(echo\
    \ \"$end * 10\" | bc)\n        local n=$(echo \"$n-1\" | bc)\n    done\n    local\
    \ total=$(echo \"$total*2\" | bc)\n    echo $total", "    local n=$1\n    local\
    \ total=0\n    local range=$((9 * 10 ** ($n - 1)))\n    # If n == 1, then only\
    \ '1' starts and ends with 1.  Otherwise,\n    # the range of numbers is 10 ..\
    \ 10^n - 1, and 10 % 10^(n-1) == 0.\n    [ $n -eq 1 ] && echo 1 && return\n  \
    \  for i in `seq 10 $range`; do\n        first=${i:0:1}\n        last=${i: -1}\n\
    \        [ $first -eq 1 ] && ((total++))\n        [ $last -eq 1 ] && ((total++))\n\
    \    done\n    echo $total", "    local counter=0\n    for num in $(seq 1 $1);\
    \ do\n        if [[ $num =~ ^1 ]] || [[ $num =~ 1$ ]]; then\n            ((counter++))\n\
    \        fi\n    done\n    echo $counter", "  local n=$1\n  local i=0\n  local\
    \ j=0\n  for ((i=0; i < $n; i++)); do\n    for ((j=0; j < $n; j++)); do\n    \
    \  if [[ ${i} -eq 0 || ${j} -eq $((n-1)) ]]; then\n        echo -n \"1\"\n   \
    \   else\n        echo -n \"0\"\n      fi\n    done\n    echo\n  done", "  local\
    \ TOT=0\n  local j=10\n  if [[ $1 -eq 1 ]]; then\n    echo \"1\"\n    return\n\
    \  fi\n  if [[ $1 -eq 2 ]]; then\n    echo \"10\"\n    return\n  fi\n  for ((i=2;\
    \ i < $1; i++)); do\n    j=$((j*10))\n    TOT=$((TOT+j))\n  done\n  echo \"$((TOT*2))\"",
  "  local num=\"$1\"\n  local count=0\n  local temp\n  for ((i=1; i<=num; i++));\
    \ do\n    temp=$(echo $i | sed 's/1//g')\n    if [[ -z $temp ]]; then\n      let\
    \ count++\n    else\n      temp=$(echo $i | sed 's/.$//')\n      if [[ -z $temp\
    \ ]]; then\n        let count++\n      fi\n    fi\n  done\n  echo $count", " \
    \   count=0\n    for i in $(seq 1 $1); do\n        count=$((count + (2**(i-1))))\n\
    \    done\n    echo \"$count\"", "  local -i ones=0\n  local -i len\n  local -i\
    \ n=$1\n  local -i i\n  local -i j\n  local -i sum\n  local -i digit\n  for ((i=1;\
    \ i<=n; i++)); do\n    len=$((i-1))\n    sum=1\n    digit=1\n    while ((len--));\
    \ do\n      sum=$((sum * 10))\n      digit=$((digit + 1))\n    done\n    ((ones+=sum))\n\
    \    for ((j=1; j<digit; j++)); do\n      sum=$((sum - (sum / 10)))\n      ((ones+=sum))\n\
    \    done\n  done\n  echo $ones", "  local i\n  local j\n  local k\n  local count\n\
    \  count=0\n  for ((i=1; i<=$1; i++)); do\n    if [ $i -eq 1 ]; then\n      ((count+=1))\n\
    \    elif [ $i -eq 10 ]; then\n      ((count+=1))\n    else\n      for ((j=0;\
    \ j<=9; j++)); do\n        for ((k=0; k<=9; k++)); do\n          if [ $i -eq 11\
    \ ]; then\n            ((count+=1))\n          elif [ $i -gt 11 ]; then\n    \
    \        if [ $j -eq 1 ] || [ $k -eq 1 ]; then\n              ((count+=1))\n \
    \           fi\n          fi\n        done\n      done\n    fi\n  done\n  echo\
    \ $count", "  local number=$1\n  local count=0\n  for (( i=1; i<=9; i++ )); do\n\
    \    for (( j=1; j<=9; j++ )); do\n      if [[ \"$(( i * j ))\" -eq \"${number}\"\
    \ ]]; then\n        (( count++ ))\n      fi\n    done\n  done\n  echo \"${count}\"",
  "  local result=0\n  for ((i=1; i<=$1; i++)); do\n    result=$((result + `number_of_n_digit_num\
    \ $i`))\n  done\n  echo $result", "  local var=$1\n  local i\n  local j\n  local\
    \ k\n\n  declare -i count\n  count=0\n\n  for ((i=1; i<=$var; i++)); do\n    for\
    \ ((j=1; j<=$var; j++)); do\n      for ((k=1; k<=$var; k++)); do\n        if [\
    \ $i -eq 1 ] || [ $j -eq 1 ] || [ $k -eq 1 ]; then\n          ((count++))\n  \
    \      fi\n      done\n    done\n  done\n\n  echo $count", "    local sum=0\n\
    \    for i in $(seq 0 $1); do\n        if [[ \"${i:${#i}-1:1}\" == \"1\" ]]; then\n\
    \            ((sum++))\n        fi\n    done\n    echo $sum", "    if (( $1 ==\
    \ 1 )); then\n        echo \"1\"\n        return\n    fi\n\n    # Two possibilities:\
    \ 1..., or ...1.  The former results in a number of\n    # (n-1)-digit numbers\
    \ ending in 1.  The latter results in a number of\n    # (n-1)-digit numbers starting\
    \ with 1.\n    local ending_one_count\n    ending_one_count=$(starts_one_ends\
    \ $(( $1 - 1 )))\n    echo $(( $ending_one_count + $ending_one_count ))", "  num_digits=$1\n\
    \  # Find the upper bound of this sequence.\n  #\n  # 10^k - 1 = 9 \xB7 (10^(k\
    \ - 1) + 10^(k - 2) + \u2026 + 10^1 + 10^0)\n  upper_bound=$(((10 ** $num_digits)\
    \ - 1))\n  # Starting at the lower bound of this sequence, use the upper bound\
    \ as a\n  # threshold. For each integer i, check whether it is a member of the\
    \ sequence.\n  # If it is, increment the counter.\n  count=0\n  for ((i = 10 **\
    \ ($num_digits - 1); i <= upper_bound; i++)); do\n    if [[ \"$i\" =~ ^1.*1$ ||\
    \ \"$i\" =~ ^1$ ]]; then\n      ((count++))\n    fi\n  done\n  echo $count", " \
    \ local n=$1\n  if [[ \"$n\" -lt 1 ]]; then\n    echo 0\n    return\n  fi\n  if\
    \ [[ \"$n\" -eq 1 ]]; then\n    echo 2\n    return\n  fi\n  echo $(echo \"$(starts_one_ends\
    \ $(($n - 1))) * 9 + $(starts_one_ends $(($n - 2))) * 9\" | bc)", "  # CASE: $1\
    \ is 1\n  if [ $1 -eq 1 ]; then\n    echo 10\n    return\n  fi\n\n  # CASE: $1\
    \ is 2\n  if [ $1 -eq 2 ]; then\n    echo 55\n    return\n  fi\n\n  local num_digits\n\
    \  local first_digit\n  local last_digit\n  local temp\n\n  num_digits=$1\n  temp=0\n\
    \  while [ $num_digits -gt 1 ]; do\n    temp=$(( temp + 1 ))\n    num_digits=$((\
    \ num_digits - 1 ))\n  done\n\n  first_digit=$(( temp * 9 + 1 ))\n  last_digit=$((\
    \ first_digit + 9 ))\n\n  echo $(( last_digit - first_digit + 1 ))", "    echo\
    \ $1 | grep -cE '^1|1$'", "  result=0\n  n=$1\n  # We have to add one to n to\
    \ account for the one that is set aside for the\n  # starting digit.\n  for _\
    \ in $(seq $((n+1))); do\n    result=$((result + (10**($_ - 1))))\n  done\n  echo\
    \ $result", "    local count=0\n    local digit=0\n    local value=0\n    local\
    \ modulo=0\n    for ((i=1; i<=$1; i++)); do\n        for ((j=1; j<=$i; j++));\
    \ do\n            digit=${i:j-1:1}\n            if [ $digit -eq 1 ]; then\n  \
    \              count=$((count+1))\n            fi\n        done\n    done\n  \
    \  echo $count", "    if [[ \"$1\" =~ ^[1-9][0-9]*$ ]]; then\n        if [ \"\
    $1\" -lt 10 ]; then\n            echo 1\n        else\n            echo $((10\
    \ ** ($1 - 1) + 1))\n        fi\n    else\n        echo -1\n    fi", "    local\
    \ n=${1}\n    local result=0\n    for i in $(seq 1 ${n}); do\n        result=$((result\
    \ + 10**(i-1)))\n    done\n    echo ${result}", "    test $1 -lt 10 && { echo\
    \ 1; return; }\n    test $1 -gt $((1 + 9 * (10 ** ($1 - 1)))) && { echo 0; return;\
    \ }\n    f=()\n    for ((i = 1; i < $1; i++)); do\n        f[$i]=$((9 * 10 **\
    \ ($i - 1)))\n    done\n    s=0\n    for ((i = 1; i < $1; i++)); do\n        s=$((s\
    \ + f[$i]))\n    done\n    echo $((f[$1 - 1] + s))", "    count=0\n    # test\
    \ all positive integers of the form 10...0\n    for ((i = 1; i < $1; i++)); do\n\
    \        count=$((count + 10**i))\n    done\n    echo $count", "  case $1 in\n\
    \    1)\n      echo -e 10\n      ;;\n    *)\n      echo -e $((10**($1-1) + 10**($1-2)*9*2))\n\
    \      ;;\n  esac", "  local n=$1\n  if [ $n -lt 0 ]; then\n    echo \"Not a positive\
    \ integer\"\n    return 1\n  fi\n  if [ $n -eq 0 ]; then\n    echo \"0\"\n   \
    \ return\n  fi\n  if [ $n -eq 1 ]; then\n    echo \"2\"\n    return\n  fi\n  local\
    \ r=`expr $n - 1`\n  echo `expr 2 \\* 9 \\* 9 \\* `./power.sh 10 $r`", '    echo
    $(($1 * ($1 + 1) / 2))', "  local -i n=$1\n  if [[ $n == 1 ]]; then\n    echo\
    \ 1\n  else\n    echo $(( starts_one_ends(($n - 1)) + 10 ** ($n - 1) ))\n  fi",
  "  if [[ $1 -lt 1 ]]; then\n    echo '0'\n    return\n  fi\n  if [[ $1 -eq 1 ]];\
    \ then\n    echo '1'\n    return\n  fi\n  r=0\n  for (( i=0; i<$1; i++ )); do\n\
    \    r=$(( r + $(( 10 ** i )) ))\n  done\n  echo $r", "    # Grab the length of\
    \ $1.\n    # Start i at 1, use a while loop to increment i up to the length of\
    \ $1\n    # Each iteration of the loop, test the value of $1 to see if it matches\n\
    \    # a regex.\n    # If the regex matches, incement the counter.\n    # When\
    \ the while loop is done, return the counter.\n    local n=$1\n    local i=1\n\
    \    local counter=0\n    local regex1=\"^1{$i}\"\n    local regex2=\"1{$i}$\"\
    \n    while [ $i -le ${#n} ]; do\n        if [[ \"$n\" =~ $regex1 || \"$n\" =~\
    \ $regex2 ]]; then\n            (( counter++ ))\n        fi\n        (( i++ ))\n\
    \    done\n    echo $counter", "  local local_result=0\n  local local_count=$1\n\
    \  local local_start_count=0\n  local local_end_count=0\n  local local_middle_count=0\n\
    \  local local_middle_result=0\n  local local_middle_count_holder=0\n  local local_start_count_holder=0\n\
    \  local local_end_count_holder=0\n  local local_current_count=0\n  local local_place_value=1\n\
    \  local local_temp_count=0\n  local local_string=\"\"\n  for ((x = 1; x <= $local_count;\
    \ x++)); do\n    local_place_value=$((10 ** x))\n    for ((y = 0; y < x; y++));\
    \ do\n      local_current_count=$((1 * (10 ** y)))\n      local_end_count_holder=$((local_end_count\
    \ + local_current_count))\n      local_middle_count_holder=$((local_middle_count\
    \ + local_current_count))\n      local_start_count_holder=$((local_start_count\
    \ + local_current_count))\n      if [ $y -gt 0 ]; then\n        local_middle_count_holder=$((local_middle_count_holder\
    \ + local_middle_result))\n      fi\n      local_end_count=$local_end_count_holder\n\
    \      local_start_count=$local_start_count_holder\n      local_middle_count=$local_middle_count_holder\n\
    \      local_middle_result=0\n      local_string=$(echo ${local_end_count_holder}\
    \ | cut -c 1)\n      if [ $local_string == \"1\" ]; then\n        local_end_count=$((local_end_count_holder\
    \ - 1))\n      fi\n      local_string=$(echo ${local_start_count_holder} | cut\
    \ -c 1)\n      if [ $local_string == \"1\" ]; then\n        local_start_count=$((local_start_count_holder\
    \ - 1))\n      fi\n      local_middle_count=$((local_middle_count - 1))\n    \
    \  local_middle_result=$((local_middle_count * 9))\n    done\n   ", "    local\
    \ n=$1\n\n    if [[ $n -eq 1 ]]; then\n        echo 2\n        return\n    fi\n\
    \n    echo $((2*10**$((n-1))+10**$((n-2))))", "  local -ir n=$1\n\n  # If 1 is\
    \ the only digit in the integer, or if we're looking for 1-digit\n  # integers,\
    \ then there is 1 such number.\n  if [[ $n -eq 1 ]]; then\n    echo 1\n    return\n\
    \  fi\n\n  # If we're looking for 2-digit numbers, then there are 9 such numbers.\n\
    \  if [[ $n -eq 2 ]]; then\n    echo 9\n    return\n  fi\n\n  # If we're looking\
    \ for more than 2 digits, then there are 9 such numbers\n  # that start with 1,\
    \ plus we add the previous numbers of digits minus 1.\n  echo $((9 + $(starts_one_ends\
    \ $((n - 1)))))", "  local N=$1 i cnt=0\n  for ((i=1; i<=N; i++)); do\n    printf\
    \ \"%d\" 1 > /dev/null\n    for ((j=1; j<=N-1; j++)); do\n      printf \"%d\"\
    \ $(($RANDOM % 10)) > /dev/null\n    done\n    if [[ $i -eq 1 ]]; then\n     \
    \ cnt=$((cnt + 1))\n    else\n      printf \"%d\" 1 > /dev/null\n      if [[ $(printf\
    \ \"%d\" $i) -eq 1 ]]; then\n        cnt=$((cnt + 1))\n      fi\n    fi\n  done\n\
    \  echo $cnt", "    local count=0\n    local digits\n    if [ $1 -eq 1 ]; then\n\
    \        echo 1\n        return\n    fi\n    for (( i=1; i <= $1; i++ )); do\n\
    \        digits=$(count_digits $i)\n        if [ $digits -eq $1 ]; then\n    \
    \        if [ $( echo $i | grep '^1' ) ] || [ $( echo $i | grep '1$' ) ]; then\n\
    \                (( count++ ))\n            fi\n        fi\n    done\n    echo\
    \ $count", "    local n=$1\n    local start_end=0\n    local non_start_end=0\n\
    \    local i\n\n    # if the number is between 1 and 10 (n=1), then we have 1\
    \ result\n    if [ $n -eq 1 ]; then\n        echo 1\n        return\n    fi\n\n\
    \    for i in $(seq 0 $((n-1))); do\n        local start=$((n - 1 - i))\n    \
    \    local end=$i\n        start_end=$((start_end + (10**start * 9) + (10**end\
    \ * 9)))\n        non_start_end=$((non_start_end + (10**start * 8)))\n    done\n\
    \n    echo $((start_end + non_start_end))", "  if [[ $1 == 1 ]]; then\n    # If\
    \ the input is 1, the answer is 10: 10^0, 10^1, ..., 10^9\n    # (There is no\
    \ 0-digit integer.)\n    echo 10\n  else\n    # If the input is n, the answer\
    \ is\n    #  10 * 9 * 8 * ... * (9 - n + 2)\n    # (The first digit can be 1,\
    \ the last digit can be 1, but the first\n    # digit and the last digit cannot\
    \ be the same number.)\n    echo $(expr $(seq 10 -1 $((9 - $1 + 2))) | tr '\\\
    n' '*' | sed 's/\\*$//')\n  fi", "  # for numbers with 1 digit, all numbers start\
    \ and end with 1,\n  # so the count is 1\n  [ $1 -eq 1 ] && echo 1 && return\n\
    \n  # for numbers with two digits, all numbers start and end with 1\n  # except\
    \ for 10, so the count is $1 - 1\n  [ $1 -eq 2 ] && echo $(($1 - 1)) && return\n\
    \n  # for numbers with 2 or more digits, there are $1 - 1 possible numbers\n \
    \ # of length $1 - 1, and each of those numbers can be prepended or\n  # appended\
    \ with the digit 1, making $2 the total number of numbers\n  # that start or end\
    \ with 1\n  echo $(($(($1 - 1)) * $(($1 - 1))))", "  if [[ ! $1 =~ ^[0-9]+$ ]];\
    \ then\n    echo \"Please enter a valid integer\"\n    return\n  fi\n\n  if [[\
    \ $1 -le 0 ]]; then\n    echo \"Please enter a positive integer\"\n    return\n\
    \  fi\n\n  if [[ $1 -eq 1 ]]; then\n    echo 1\n    return\n  fi\n\n  # How many\
    \ 1s are at the start?\n  local ones=1\n  local amount=1\n  local digits=$1\n\
    \  while [[ digits -gt 1 ]]; do\n    ones=$((ones + 1))\n    amount=$((amount\
    \ * 10))\n    digits=$((digits - 1))\n  done\n\n  local ending=1\n  local i=1\n\
    \  while [[ i -lt $1 ]]; do\n    ending=$((ending * 10))\n    ending=$((ending\
    \ + 1))\n    i=$((i + 1))\n  done\n\n  echo \"$((ones + ending))\"", "  local\
    \ count=0\n  local tmp\n  local leading_zeros\n  local start=0\n  local end=0\n\
    \  local n=$1\n  local divider=1\n\n  while [ $divider -lt $n ]; do\n    divider=$((\
    \ divider * 10 ))\n  done\n\n  if [ $n -eq 1 ]; then\n    count=1\n  fi\n\n  for\
    \ (( i = 0; i < $n; i++ )); do\n    leading_zeros=$(( $n - $i - 1 ))\n    tmp=$((\
    \ divider * 10 - 1 ))\n    start=$(( start + (tmp / divider) * (divider / 10)\
    \ * leading_zeros ))\n    end=$(( end + (tmp / divider) * (divider / 10) * (n\
    \ - leading_zeros - 1) ))\n  done\n\n  count=$(( count + start + end ))\n  echo\
    \ $count", "    num=$1\n    if [ $num -eq 1 ]; then\n        return 1\n    fi\n\
    \    int_array=()\n    for (( i=1; i<=$num; i++ )); do\n        int_array[$(($i-1))]=1\n\
    \    done\n    for (( i=0; i<$(($num-1)); i++ )); do\n        int_array[$i]=$((\
    \ (${int_array[$i]}*10) + 1 ))\n    done\n    start_sum=0\n    for (( i=0; i<$(($num-1));\
    \ i++ )); do\n        start_sum=$(( $start_sum + ${int_array[$i]} ))\n    done\n\
    \    end_sum=0\n    for (( i=1; i<$num; i++ )); do\n        end_sum=$(( $end_sum\
    \ + ${int_array[$i]} ))\n    done\n    printf \"%d\\n\" $(( $start_sum + $end_sum\
    \ ))", "    local -i num=$1\n    local -i i end\n    local start_one=1 end_one=1\n\
    \    for ((i=2; i<=num; i++)); do\n        end=$start_one\n        start_one=$((start_one+end_one))\n\
    \        end_one=$end\n    done\n    echo $((start_one+end_one))", '  echo "1$(seq
    $1 -1 1)"', "    local n=$1\n    local l=$n\n    local h=$(echo \"10^$n\" | bc)\n\
    \    local c=0\n    for ((i=l; i<h; i++)); do\n        s=${i:0:1}\n        e=${i:\
    \ -1}\n        if [[ $s == 1 || $e == 1 ]]; then\n            ((c++))\n      \
    \  fi\n    done\n    echo $c", "    printf '%s\\n' \"$1\" |\n    xargs -I {} bash\
    \ -c \\\n    '\n    local -i num=\"{}\"\n    local -i count=0\n    while [[ num\
    \ -gt 0 ]]; do\n        (( num % 10 == 1 )) && (( ++count ))\n        (( num /=\
    \ 10 ))\n    done\n    echo \"$count\"\n    '", "    local num=$1\n    local count=0\n\
    \    local i=1\n    while [ $i -le $num ]; do\n        local digits=$(($i / 10))\n\
    \        local tens=$(($digits * 10))\n        local ones=$(($i - $tens))\n  \
    \      local tens=$(($tens / 10))\n        if [ $ones -eq 1 ]; then\n        \
    \    count=$(($count + 1))\n        fi\n        if [ $tens -eq 1 ]; then\n   \
    \         count=$(($count + 1))\n        fi\n        i=$(($i + 1))\n    done\n\
    \    echo $count", "    n=$1\n    if [ $n -eq 1 ]; then\n        return 1\n  \
    \  fi\n    # 0 is not a natural number; we are not interested in it\n    ones=0\n\
    \    twos=0\n    threes=0\n    if [ $n -gt 3 ]; then\n        (( threes=n-3 ))\n\
    \    fi\n    if [ $n -gt 2 ]; then\n        (( twos=n-2 ))\n    fi\n    if [ $n\
    \ -gt 1 ]; then\n        (( ones=n-1 ))\n    fi\n    # echo \"$ones $twos $threes\"\
    \n    # number of 1s in left-most digit\n    # number of all other numbers in\
    \ the rest of the digits\n    echo $(( ones * (10**(n-1)) + twos * 9 + threes\
    \ * 9 ))"]
stop_tokens:
- "\n}"
