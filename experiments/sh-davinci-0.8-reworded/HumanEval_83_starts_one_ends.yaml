name: HumanEval_83_starts_one_ends
language: sh
prompt: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
  \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
  starts_one_ends() {\n"
tests: "}\n\ncandidate() {\n    starts_one_ends \"$@\"\n}\n\nset -e\nrun_test() {\n\
  \    [[ $(candidate \"1\") = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\" ]]\n \
  \   [[ $(candidate \"3\") = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\" ]]\n\
  \    [[ $(candidate \"5\") = \"18000\" ]]\n}\n\nrun_test"
completions: ["  declare n=\"$1\"\n  declare s=0\n  declare e=0\n  # The number of\
    \ n-digit positive integers starting with 1\n  # - this is just 10^(n-1)\n  s=$((\
    \ 10 ** (n - 1) ))\n  # The number of n-digit positive integers ending with 1\n\
    \  # - this is the number of 10-digit numbers that do not start with 1\n  # -\
    \ so it is (10^n) - 10^(n-1)\n  e=$(( 10 ** n - s ))\n  echo \"$(( s + e ))\"",
  "  local i j m n\n  local result=0\n  if [[ $1 -gt 0 ]]; then\n    for (( i=0; i<$1;\
    \ i++ )); do\n      (( m=$(( 10 ** i )) ))\n      (( n=$(( 10 ** ($1 - i) )) ))\n\
    \      (( result += $(( $n - $m )) ))\n    done\n  fi\n  echo $result", "  local\
    \ n=\"$1\"\n  if ((n < 1)); then\n    return 0\n  fi\n  if ((n == 1)); then\n\
    \    echo 1\n    return 0\n  fi\n  echo $((9 * 10 ** (n - 1) + 9 * 10 ** (n -\
    \ 2)))", "    local -r n=\"$1\"\n    local -r d=$((10 ** (n - 1)))\n    local\
    \ -r f=$((d * 10 - 1))\n    # Brute force is fine here\n    local -i count=0\n\
    \    local -i t\n    for t in $(seq \"$d\" \"$f\"); do\n        if [[ \"$t\" =~\
    \ ^1.*1$ ]]; then\n            ((++count))\n        fi\n    done\n    echo \"\
    $count\"", "    integer_validate $1\n    local len=$1\n    if [[ $len -eq 1 ]];\
    \ then\n        echo 1\n    else\n        local i\n        local upper_sum\n \
    \       local lower_sum\n        upper_sum=1\n        lower_sum=1\n        for\
    \ ((i=1; i<len; i++)); do\n            upper_sum=$((upper_sum * 10))\n       \
    \     lower_sum=$((lower_sum * 9))\n        done\n        echo $((upper_sum +\
    \ lower_sum))\n    fi", "  count=0\n  if [[ $1 == 0 ]]; then\n    count=1\n  else\n\
    \    for ((i=1; i<=$1; i++)); do\n      count=$((count + (1*10**$i)))\n    done\n\
    \  fi\n  echo $count", "  declare -i i\n  declare -i j\n  declare -i count=0\n\
    \  declare -i val\n  declare -i begins_with_one\n  declare -i ends_with_one\n\
    \  declare -i temp\n  for ((i=1; i<=$1; i++)); do\n    val=$((10**i))\n    # Iterate\
    \ through all j-digit numbers.\n    for ((j=1; j<=$val; j++)); do\n      begins_with_one=0\n\
    \      ends_with_one=0\n      temp=$j\n      while [ $temp -gt 0 ]; do\n     \
    \   # See if the current digit is 1.\n        if [ $((temp%10)) -eq 1 ]; then\n\
    \          if [ $begins_with_one -eq 0 ]; then\n            begins_with_one=1\n\
    \          else\n            ends_with_one=1\n          fi\n        fi\n     \
    \   temp=$((temp/10))\n      done\n      if [ $begins_with_one -eq 1 -o $ends_with_one\
    \ -eq 1 ]; then\n        count=$((count+1))\n      fi\n    done\n  done\n  echo\
    \ $count", "  result=0\n  for (( i=1; i<=\"$1\"; i++ )); do\n    result=$(( $result\
    \ + ($1 ** $i) ))\n  done\n  echo $result", "    local i j k\n    local final_count=0\n\
    \    # init\n    i=1\n    # count last digit 1\n    while [ $i -lt $1 ]; do\n\
    \        i=$((i+1))\n    done\n    j=$((i-1))\n    while [ $j -gt 0 ]; do\n  \
    \      k=$((j+1))\n        while [ $k -lt $i ]; do\n            k=$((k+1))\n \
    \       done\n        final_count=$((final_count+1))\n        j=$((j-1))\n   \
    \ done\n    # count first digit 1\n    i=2\n    while [ $i -lt $1 ]; do\n    \
    \    i=$((i+1))\n    done\n    j=$((i-1))\n    while [ $j -gt 0 ]; do\n      \
    \  k=$((j+1))\n        while [ $k -lt $i ]; do\n            k=$((k+1))\n     \
    \   done\n        final_count=$((final_count+1))\n        j=$((j-1))\n    done\n\
    \    echo $final_count", "  local n=$1\n\n  # Initialize starting values\n  local\
    \ start_end=0\n  local start_no_end=0\n  local no_start_end=0\n  local no_start_no_end=0\n\
    \n  # Iterate over the number of digits (e.g. for n=3: n=3, n=2, n=1)\n  for ((i=1;\
    \ i<=$n; i++)); do\n    case $i in\n      1)\n        start_end=1\n        start_no_end=0\n\
    \        no_start_end=1\n        no_start_no_end=1\n        ;;\n      *)\n   \
    \     start_end=$((start_end * 10 + 1))\n        start_no_end=$((start_no_end\
    \ * 10 + 9))\n        no_start_end=$((no_start_end * 10 + 1))\n        no_start_no_end=$((no_start_no_end\
    \ * 10 + 8))\n        ;;\n    esac\n  done\n\n  echo $((start_end + start_no_end\
    \ + no_start_end))", "    local n=$1\n    local count=0\n    local p=$((n/2))\n\
    \    local i\n\n    # $n-digit positive integer that starts with 1\n    for ((i=0;\
    \ i<p; i++)); do\n        count=$((count+9*(10**i)))\n    done\n    count=$((count+10**p))\n\
    \n    # $n-digit positive integer that ends with 1\n    for ((i=0; i<p; i++));\
    \ do\n        count=$((count+9*(10**i)))\n    done\n    echo $count", "  local\
    \ n=$1\n  local count=0\n  if [[ $n -gt 1 ]]; then\n    local lower_bound=$((\
    \ 10 ** ($n - 1) ))\n    local upper_bound=$(( 10 ** $n - 1 ))\n    for (( i =\
    \ lower_bound; i <= upper_bound; i++ )); do\n      local str=\"$i\"\n      local\
    \ first=${str:0:1}\n      local last=${str: -1}\n      if [[ $first -eq 1 || $last\
    \ -eq 1 ]]; then\n        count=$(( count + 1 ))\n      fi\n    done\n  fi\n \
    \ echo $count", "  if [[ $1 -lt 1 ]]; then\n    echo \"Input must be greater than\
    \ 1\"\n    return 1\n  fi\n\n  if [[ $1 -eq 1 ]]; then\n    echo \"Input must\
    \ be greater than 1\"\n    return 1\n  fi\n\n  # These are the base cases for\
    \ this problem\n  case $1 in\n    2)\n      echo \"$(($1 * 9))\"\n      return\
    \ 0\n      ;;\n    3)\n      echo \"$(($1 * 9))\"\n      return 0\n      ;;\n\
    \    4)\n      echo \"$(($1 * 18))\"\n      return 0\n      ;;\n    5)\n     \
    \ echo \"$(($1 * 18))\"\n      return 0\n      ;;\n    6)\n      echo \"$(($1\
    \ * 27))\"\n      return 0\n      ;;\n    7)\n      echo \"$(($1 * 27))\"\n  \
    \    return 0\n      ;;\n    8)\n      echo \"$(($1 * 36))\"\n      return 0\n\
    \      ;;\n    9)\n      echo \"$(($1 * 36))\"\n      return 0\n      ;;\n   \
    \ 10)\n      echo \"$(($1 * 45))\"\n      return 0\n      ;;\n    11)\n      echo\
    \ \"$(($1 * 45))\"\n      return 0\n      ;;\n    12)\n      echo \"$(($1 * 54))\"\
    \n      return 0\n      ;;\n    13)\n      echo \"$(($1 * 54))\"\n      return\
    \ 0\n      ;;\n    14)\n      echo \"$(($1 * 63))\"\n      return 0\n      ;;\n\
    \    15)\n      echo \"$(($1 * 63))\"\n      return 0\n      ;;\n    16)\n   \
    \   echo \"$(($1 * 72))\"\n      return 0\n      ;;\n    17)\n      echo \"$(($1\
    \ * 72))\"\n      return 0\n      ;;\n    18)\n      echo \"$(($1 * 81))\"\n \
    \     return 0\n      ;;\n    19)\n      echo \"$(($1 * 81))\"\n      return 0\n\
    \      ;;\n    20)\n      echo \"$(($1 * 90))\"\n      return 0\n      ;;\n  \
    \  21)\n      echo \"$(($1 * 90))\"\n     ", "  local input=$1\n  local count=0\n\
    \  for number in $(seq 1 10**$input); do\n    if [[ $number =~ ^1.* || $number\
    \ =~ .*1$ ]]; then\n      ((count++))\n    fi\n  done\n  echo $count", "  local\
    \ n=$1\n  echo $(starts_one $n) + $(ends_one $n) | bc", "  local count=0\n  for\
    \ (( i=1; i<=$1; i++ )); do\n    local n=$i\n    while [[ $n -gt 0 ]]; do\n  \
    \    if [[ $n -eq 1 ]]; then\n        count=$(( count + 1 ))\n        break\n\
    \      fi\n      n=$(( n / 10 ))\n    done\n  done\n  echo $count", "    n=$1\n\
    \    if [[ $n -eq 1 ]]; then\n        echo 1\n        return\n    fi\n    # f(n)\
    \ = f(n-1) + (9 * 10^(n-2))\n    # The first term is the number of n-digit numbers\
    \ that start with 1\n    # (i.e. the number of (n-1)-digit numbers that start\
    \ with 1). The second\n    # term is the number of n-digit numbers that end with\
    \ 1 (i.e. the number\n    # of 10-digit numbers that end with 1).\n    curr=$(starts_one_ends\
    \ $((n-1)))\n    prev=1\n    i=1\n    while [[ $i -lt $((n-1)) ]]; do\n      \
    \  prev=$((prev * 10))\n        i=$((i+1))\n    done\n    echo $((curr + 9 * prev))",
  "    declare -i i; declare -i total=0; declare -i len=$1\n    while (( --len ));\
    \ do\n        i=1; while (( i < 10 ** len )); do\n            if (( i == 10 **\
    \ (len - 1) )); then\n                (( total += 10 ** len ))\n            else\n\
    \                (( total += 2 * 10 ** len ))\n            fi\n            ((\
    \ i *= 10 ))\n        done\n    done\n    echo $total", "  if [[ $1 -lt 1 ]];\
    \ then\n    echo \"INVALID\"\n    return 1\n  fi\n\n  if [[ $1 -eq 1 ]]; then\n\
    \    echo 1\n    return 0\n  fi\n\n  echo -n $(($1 - 1))\n  echo -n $(($1 - 1))\
    \ | sed 's/./*9/g'\n  echo ' + '\n  echo 1\n  echo -n $(($1 - 1)) | sed 's/./*9/g'\n\
    \  echo ' + '\n  echo 1\n  echo -n $(($1 - 1)) | sed 's/./*9/g'\n  echo ' + '\n\
    \  echo $(($1 - 1))\n  echo ' - '\n  echo $(($1 - 1)) | sed 's/./9/g'\n  echo\
    \ ' + '\n  echo 1", "  declare -i local n=$1\n  if [[ $n == 1 ]]; then\n    echo\
    \ 1\n  else\n    echo $(((10 ** ($n - 1)) - (9 ** ($n - 1))))\n  fi"]
stop_tokens:
- "\n}"
