name: HumanEval_158_find_max
language: sh
prompt: "#!/bin/bash\n# Write a function that accepts a list of strings.\n# The list\
  \ contains different words. Return the word with maximum number\n# of unique characters.\
  \ If multiple strings have maximum number of unique\n# characters, return the one\
  \ which comes first in lexicographical order.\n# >>> $(find_max \"name of string\"\
  )\n# \"string\"\n# >>> $(find_max \"name enam game\")\n# \"enam\"\n# >>> $(find_max\
  \ \"aaaaaaa bb cc\")\n# \"aaaaaaa\"\n#\n# $1 is a space-separated list\nfind_max()\
  \ {\n"
tests: "}\n\ncandidate() {\n    find_max \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
  \ $(candidate \"name of string\") = \"string\" ]]\n    [[ $(candidate \"name enam\
  \ game\") = \"enam\" ]]\n    [[ $(candidate \"aaaaaaa bb cc\") = \"aaaaaaa\" ]]\n\
  \    [[ $(candidate \"abc cba\") = \"abc\" ]]\n    [[ $(candidate \"play this game\
  \ of footbott\") = \"footbott\" ]]\n    [[ $(candidate \"we are gonna rock\") =\
  \ \"gonna\" ]]\n    [[ $(candidate \"we are a mad nation\") = \"nation\" ]]\n  \
  \  [[ $(candidate \"this is a prrk\") = \"this\" ]]\n    [[ $(candidate \"b\") =\
  \ \"b\" ]]\n    [[ $(candidate \"play play play\") = \"play\" ]]\n}\n\nrun_test"
completions: ["    local max_word='' max_unique=0 num_unique=0 word\n\n    for word\
    \ in $1; do\n        num_unique=$(echo \"$word\" | grep -o . | sort | uniq | wc\
    \ -l)\n        if [ $num_unique -gt $max_unique ]; then\n            max_unique=$num_unique\n\
    \            max_word=$word\n        fi\n    done\n\n    echo $max_word", "  \
    \  local best=\"\"\n    local best_len=0\n    for word in $1; do\n        local\
    \ len=$(echo $word | sed -r 's/([^[:space:]])/./g' | tr -d '\\n' | sed 's/\\./\\\
    n/g' | sort | uniq | wc -l)\n        if [[ $len -gt $best_len ]]; then\n     \
    \       best_len=$len\n            best=$word\n        fi\n    done\n    echo\
    \ $best", "    local max_unique=1\n    local max_unique_s=\"\"\n    for s in \"\
    $@\"; do\n        local s_unique=$(echo \"$s\" | fold -w1 | sort -u | wc -l)\n\
    \        if [[ \"$s_unique\" -gt \"$max_unique\" ]]; then\n            max_unique=\"\
    $s_unique\"\n            max_unique_s=\"$s\"\n        elif [[ \"$s_unique\" -eq\
    \ \"$max_unique\" ]]; then\n            if [[ \"$s\" < \"$max_unique_s\" ]]; then\n\
    \                max_unique_s=\"$s\"\n            fi\n        fi\n    done\n \
    \   echo \"$max_unique_s\"", "  # TODO: Implement this function\n  # local max_unique_characters_string_1=\"\
    $1\"\n  # local max_unique_characters_string_2=\"$2\"\n  #\n  # if [[ $max_unique_characters_string_1\
    \ == $max_unique_characters_string_2 ]]; then\n  #   echo $max_unique_characters_string_1\n\
    \  # elif [[ $(echo $max_unique_characters_string_1 < $max_unique_characters_string_2)\
    \ == \"true\" ]]; then\n  #   echo $max_unique_characters_string_2\n  # else\n\
    \  #   echo $max_unique_characters_string_1\n  # fi\n  local max_string=$(echo\
    \ \"$1\" | awk '{\n    print $1\n  }')\n  local max_unique_characters=$(echo \"\
    $max_string\" | grep -o . | sort | uniq | wc -l)\n\n  for string in $(echo \"\
    $1\" | awk '{\n    for (i = 2; i <= NF; i++) {\n      print $i\n    }\n  }');\
    \ do\n    local unique_characters=$(echo \"$string\" | grep -o . | sort | uniq\
    \ | wc -l)\n    if [[ $unique_characters -gt $max_unique_characters ]]; then\n\
    \      max_unique_characters=$unique_characters\n      max_string=$string\n  \
    \  elif [[ $unique_characters -eq $max_unique_characters ]]; then\n      if [[\
    \ $(echo $string < $max_string) == \"true\" ]]; then\n        max_string=$string\n\
    \      fi\n    fi\n  done\n\n  echo $max_string", "    # Define variable.\n  \
    \  local nline=$1\n    local max_char=0\n    local max_str=\"\"\n    local uniq_list=()\n\
    \    # Loop thru every string.\n    for i in $nline; do\n        # Check if the\
    \ string is unique.\n        if [[ $(echo \"$i\" | wc -c) == $(echo \"$i\" | sort\
    \ | uniq | wc -c) ]]; then\n            echo \"$i is unique\"\n            uniq_list=(\"\
    ${uniq_list[@]}\" \"$i\")\n        fi\n    done\n    # Find maximum number of\
    \ characters.\n    for j in ${uniq_list[@]}; do\n        if [[ $(echo \"$j\" |\
    \ wc -c) -gt $max_char ]]; then\n            max_char=$(echo \"$j\" | wc -c)\n\
    \            max_str=\"$j\"\n        fi\n    done\n    echo \"$max_str\"", " \
    \   echo $1 | tr ' ' '\\n' | sort -u | sort -k1,1nr | head -1", "  # Sort the\
    \ words by length\n  # Take only the first\n  # Print without a line break (--zero-terminated)\n\
    \  sort --key=3 --numeric-sort --reverse --zero-terminated -- $1 | head -1", " \
    \ while [[ $# -gt 0 ]]; do\n    local arg=$1\n    local arglen=${#arg}\n    if\
    \ [[ \"$arglen\" -gt \"$maxlen\" ]]; then\n      maxlen=$arglen\n      maxarg=$arg\n\
    \    fi\n    shift\n  done\n  echo $maxarg", "  local res=\n  local -i num_max=0\n\
    \  for word in $*; do\n    local -i num_unique=0\n    for ((i=0; i<${#word}; i++));\
    \ do\n      local -n arr_ref=$(echo \"arr_${word:i:1}\")\n      if [[ -z \"${arr_ref[*]}\"\
    \ ]]; then\n        arr_ref[0]=0\n        ((num_unique++))\n      fi\n    done\n\
    \    if ((num_unique > num_max)); then\n      num_max=$num_unique\n      res=$word\n\
    \    elif ((num_unique == num_max)) &&\n         [[ \"$word\" < \"$res\" ]]; then\n\
    \      res=$word\n    fi\n  done\n  echo \"$res\"", "    local max=0\n    local\
    \ word=\"\"\n    local max_list=\"\"\n    for word in $1; do\n        if (( $(unique_chars_count\
    \ \"$word\") > max )); then\n            max_list=$word\n            max=$(unique_chars_count\
    \ \"$word\")\n        fi\n    done\n    echo \"$max_list\"", "    local str=$1\n\
    \    local max=''\n    local max_num_chars=0\n    for word in $str; do\n     \
    \   if [[ $(echo $word | grep -o . | sort | uniq | wc -l) -gt $max_num_chars ]];\
    \ then\n            max=$word\n            max_num_chars=$(echo $word | grep -o\
    \ . | sort | uniq | wc -l)\n        fi\n    done\n    echo $max", "    max=-1\n\
    \    echo $1 | tr ' ' '\\n' | while read word; do\n        cnt=$(echo $word |\
    \ grep -o . | sort | uniq | wc -l)\n        if [[ $cnt -gt $max ]]; then\n   \
    \         max=$cnt\n            ret=$word\n        fi\n    done\n    echo $ret",
  "  local max=0\n  local max_word=\"\"\n  local max_value=\"\"\n  local word=\"\"\
    \n  local value=\"\"\n  # Iterate through each word\n  for word in $1; do\n  \
    \  # Compute the value of the word\n    value=$(sed 's/\\(.\\)/\\1\\n/g' <<< $word\
    \ | sort | uniq | tr -d '\\n')\n    # Compare with current max\n    if [[ ${#value}\
    \ -gt $max ]]; then\n      max_word=$word\n      max_value=$value\n      max=${#value}\n\
    \    fi\n  done\n  echo $max_word", "  echo \"$1\" | tr ' ' '\\n' | sed 's/.*/&\\\
    t&/' | sort -t$'\\t' -k2r -k1 -u | head -n1 | cut -f1", "    local max_num_uniq\
    \ max_word word num_uniq c\n    max_num_uniq=0\n    for word in $1; do\n     \
    \   num_uniq=0\n        for c in $(echo $word | fold -w1); do\n            if\
    \ ! echo $word | grep -q $c; then\n                ((num_uniq++))\n          \
    \  fi\n        done\n        if ((num_uniq > max_num_uniq)); then\n          \
    \  max_num_uniq=$num_uniq\n            max_word=$word\n        fi\n    done\n\
    \    echo $max_word", "    local max=0\n    local str\n    local n\n\n    while\
    \ read str; do\n        # Count unique characters\n        n=$(echo \"$str\" |\
    \ grep -o . | sort -u | wc -l)\n        [ $n -gt $max ] && max=$n && res=$str\n\
    \    done <<< \"$1\"\n\n    echo \"$res\"", "    # Create a list of words by replacing\
    \ spaces with newlines\n    words=$(echo \"$1\" | tr ' ' '\\n')\n    printf \"\
    %s\" \"$words\" | while read word; do\n        # For each word, count the number\
    \ of unique characters. This is the\n        # length of the output of `tr -d\
    \ <chars_to_delete>`. The string to\n        # delete is all characters in the\
    \ word that are not duplicates. The\n        # pattern `(.)\\\\1*` matches each\
    \ group of duplicates.\n        num_unique=$(printf \"%s\" \"$word\" | tr -d \"\
    $(printf \"%s\" \"$word\" | sed 's/(.)\\\\1*/\\\\1/g')\" | wc -c)\n        echo\
    \ \"$num_unique $word\"\n    done | sort -rn | head -n 1 | cut -d' ' -f2", " \
    \ printf \"%s\\n\" $* | tr \" \" \"\\n\" | awk '{sum=0;for(i=1;i<=length;i++){c=substr($0,i,1);if(!a[c]){a[c]=1;sum+=1}}print\
    \ sum,$0}' | sort -n -k1,1 | tail -1 | cut -d\" \" -f2", "    # 1. Create a list\
    \ of length of unique characters for each word.\n    declare -a uniq_chars\n \
    \   #    - Split the list into an array of words.\n    declare -a words\n    IFS=\"\
    \ \" read -r -a words <<< \"$1\"\n    #    - Store the number of unique characters\
    \ of each word.\n    for word in \"${words[@]}\"; do\n        #    - Remove all\
    \ duplicate characters of each word.\n        uniq_word=$(echo -n \"$word\" |\
    \ fold -w1 | sort | uniq | tr -d \"\\n\")\n        #    - Store the length of\
    \ each word.\n        uniq_chars+=(${#uniq_word})\n    done\n    # 2. Find the\
    \ indices of the words with maximum number of unique characters.\n    #    - Find\
    \ the maximum number of unique characters.\n    max_unique=${uniq_chars[0]}\n\
    \    for word in \"${uniq_chars[@]}\"; do\n        if (( word > max_unique ));\
    \ then\n            max_unique=$word\n        fi\n    done\n    #    - Create\
    \ an array of indices of the words with maximum number of unique characters.\n\
    \    declare -a max_idx\n    for i in \"${!uniq_chars[@]}\"; do\n        if ((\
    \ uniq_chars[i] == max_unique )); then\n            max_idx+=($i)\n        fi\n\
    \    done\n    # 3. Find the first word in lexicographical order.\n    first_word=${words[${max_idx[0]}]}\n\
    \    for word in \"${words[@]}\"; do\n        if [[ \"$word\" < \"$first_word\"\
    \ ]]; then\n            first_word=$word\n        fi\n    done\n    echo -n \"\
    $first_word\"", "    # Write your code here\n    # split the space-separated list\
    \ and store in the array\n    IFS=' ' read -a array <<< \"$1\"\n    max_count=0\n\
    \    max_word=\"\"\n    for word in \"${array[@]}\"\n    do\n        # remove\
    \ duplicate letters of the word and count the number of letters\n        word_count=$(echo\
    \ $word | tr -cd [:alpha:] | sed 's/\\(.\\)/\\1\\n/g' | sort -u | wc -c)\n   \
    \     if [ $word_count -gt $max_count ] || [ $word_count -eq $max_count -a $word\
    \ \\< $max_word ]\n        then\n            max_count=$word_count\n         \
    \   max_word=$word\n        fi\n    done\n    echo $max_word", "    local u_map=()\n\
    \    local max=0\n    local max_word=\"\"\n    local word=\"\"\n    # Compute\
    \ number of unique characters in each word.\n    for word in $1; do\n        if\
    \ [[ -z ${u_map[$word]} ]]; then\n            u_map[$word]=$(echo $word | sed\
    \ 's/./&\\n/g' | sort -u | wc -l)\n        fi\n        if [[ ${u_map[$word]} -gt\
    \ $max ]]; then\n            max_word=$word\n            max=${u_map[$word]}\n\
    \        fi\n    done\n    echo $max_word", "  # Give me the length of the longest\
    \ word in $1\n  local max_length=$(echo \"$1\" | awk '{ max = 0; for (i = 1; i\
    \ <= NF; i++)\n    { if (length($i) > max) max = length($i) } print max }')\n\
    \  #\n  # Now, filter out the longest words and pick the one closest to the beginning\n\
    \  # of the alphabet\n  echo \"$1\" | awk \"{ if (length(\\$1) == $max_length)\
    \ print \\$1; }\" | head -n 1", "    max_len=0\n    max_string=\"\"\n    for string\
    \ in $1; do\n        # Regex: replace repeated characters with single character\n\
    \        uniq_string=$(echo \"$string\" | sed -E \"s/(.)\\1+/\\1/g\")\n      \
    \  uniq_len=${#uniq_string}\n        if [ $uniq_len -gt $max_len ]; then\n   \
    \         max_len=$uniq_len\n            max_string=$string\n        elif [ $uniq_len\
    \ -eq $max_len ]; then\n            if [ \"$string\" \\< \"$max_string\" ]; then\n\
    \                max_string=$string\n            fi\n        fi\n    done\n  \
    \  echo \"$max_string\"", "    # unique_count(word) returns the number of unique\
    \ characters in word\n    unique_count() {\n        echo \"$1\" | tr -d -c \"\
    $1\" | wc -c\n    }\n    # max_len(word1, word2) returns the word with the longer\
    \ length\n    max_len() {\n        if [ $(unique_count \"$1\") -gt $(unique_count\
    \ \"$2\") ]; then\n            echo \"$1\"\n        else\n            echo \"\
    $2\"\n        fi\n    }\n    max=$(echo \"$1\" | cut -d \" \" -f 1)\n    for word\
    \ in $(echo \"$1\" | cut -d \" \" -f 2-); do\n        max=$(max_len \"$max\" \"\
    $word\")\n    done\n    echo \"$max\"", "  if [ -z \"$1\" ]; then\n    return\
    \ 0\n  fi\n  max_word=${1%% *}\n  max_length=${#max_word}\n  for word in $1; do\n\
    \    unique_word=`echo $word | fold -w1 | sort | uniq | tr -d '\\n'`\n    if [\
    \ ${#unique_word} -gt $max_length ]; then\n      max_word=$word\n      max_length=${#unique_word}\n\
    \    fi\n  done\n  echo $max_word", "\t# assume the first word is the winner\n\
    \tbest_word=$(echo $1 | awk '{print $1}')\n\t# assume the number of unique characters\
    \ in it is maximum so far\n\tbest_distinct=$(echo -n $best_word | wc -m)\n\t#\
    \ loop over the rest of the words in the input\n\tfor word in $(echo $1 | awk\
    \ '{for (i=2; i<=NF; i++) print $i}'); do\n\t\t# find the number of distinct characters\
    \ in the current word\n\t\tdistinct=$(echo -n $word | wc -m)\n\t\t# if it's better\
    \ than the current best, update the best\n\t\tif [ $distinct -gt $best_distinct\
    \ ]; then\n\t\t\tbest_distinct=$distinct\n\t\t\tbest_word=$word\n\t\tfi\n\tdone\n\
    \t# return the best word\n\techo $best_word", "    # Write your code here\n  \
    \  len=$(echo $1 | wc -w)\n    list=$(echo $1 | tr ' ' '\\n')\n    name=\"\"\n\
    \    max=0\n    for i in $list\n    do\n        if [ ${#i} -gt $max ]\n      \
    \  then\n            max=${#i}\n            name=$i\n        fi\n    done\n  \
    \  echo $name", "  local IFS=$'\\n' # use newlines as separators\n  local max_count=0\n\
    \  local max_word=\"\"\n  for w in $1\n  do\n    local chars=$(echo \"$w\" | sed\
    \ -r 's/(.).*\\1/\\1/g' | fold -w1)\n    if [[ $(echo \"$chars\" | wc -l) -gt\
    \ $max_count ]]\n    then\n      max_count=$(echo \"$chars\" | wc -l)\n      max_word=\"\
    $w\"\n    fi\n  done\n  echo \"$max_word\"", "\tset -- $1\n\t# array\n\ta=($@)\n\
    \tn=${#a[@]}\n\tmax=0\n\tmax_index=0\n\tfor ((i=0; i<n; i++)); do\n\t\t# number\
    \ of unique characters in a[i]\n\t\tcount=$(echo ${a[i]} | fold -w1 | sort | uniq\
    \ | wc -l)\n\t\tif ((count > max)); then\n\t\t\tmax=$count\n\t\t\tmax_index=$i\n\
    \t\tfi\n\tdone\n\techo ${a[max_index]}", "    local n=\n    local line=\n\n  \
    \  local IFS=$'\\n'\n    local lines=($(echo \"$1\" | tr ' ' '\\n' | sort -u))\n\
    \n    local max=0\n    local max_index=0\n    for n in \"${!lines[@]}\"; do\n\
    \        line=\"${lines[$n]}\"\n        if [[ ${#line} -gt $max ]]; then\n   \
    \         max=${#line}\n            max_index=$n\n        fi\n    done\n\n   \
    \ echo \"${lines[$max_index]}\"", "    local word i max_chars=0\n    for word\
    \ in $1; do\n        unique_chars=0\n        for ((i=0; i<${#word}; i++)); do\n\
    \            if [[ \"${word:i:1}\" != *[${word:0:i}]* ]]; then\n             \
    \   ((unique_chars++))\n            fi\n        done\n        if [[ $unique_chars\
    \ -gt $max_chars ]]; then\n            max_chars=$unique_chars\n            max_word=$word\n\
    \        fi\n    done\n    echo $max_word", "    local max_len\n    local max_string\n\
    \    max_len=0\n    max_string=\"\"\n    while read -r word; do\n        if [\
    \ ${#word} -gt $max_len ]; then\n            max_len=${#word}\n            max_string=$word\n\
    \        fi\n    done <<< \"$1\"\n    echo \"$max_string\"", "    # Check if $1\
    \ is empty\n    if [ -z \"$1\" ]; then\n        echo \"ERROR: Input argument is\
    \ empty.\"\n        return 1\n    fi\n\n    # Create an array. $1 contains space-separated\
    \ strings, so we will use\n    # parameter substitution to split it into an array.\n\
    \    local words=(\"$@\")\n\n    # Iterate over each element of words\n    local\
    \ max_word=\"\"\n    local max_count=0\n    for i in \"${words[@]}\"; do\n   \
    \     # If current word does not have unique characters, then continue\n     \
    \   if [ $(count_unique \"$i\") -eq 0 ]; then\n            continue\n        fi\n\
    \n        # If current word has more unique characters than max_count, then\n\
    \        # set max_word to current word and max_count to the number of unique\n\
    \        # characters in current word\n        if [ $(count_unique \"$i\") -gt\
    \ $max_count ]; then\n            max_word=\"$i\"\n            max_count=$(count_unique\
    \ \"$i\")\n        fi\n    done\n\n    # If no word has unique characters, then\
    \ return the first word\n    if [ -z \"$max_word\" ]; then\n        echo \"${words[0]}\"\
    \n    else\n        echo \"$max_word\"\n    fi", "    # Don't forget to quote\
    \ the string\n    # local input=\"$1\"\n    # This can be done using a built-in\n\
    \    local input=$@\n    # Get number of unique characters in each word, sort\
    \ according to it,\n    # reverse and get the first value\n    echo \"$input\"\
    \ | awk '{print length($0), $0}' | sort -nr | head -1 | awk '{print $2}'", " \
    \   count=$(echo $1 | sed 's/ /\\n/g' | sort -t':' -k2 -rn | head -n1)\n    wc=$(echo\
    \ $count | cut -d':' -f2)\n    word=$(echo $count | cut -d':' -f1)\n    echo $word",
  "    eval \"list=($1)\"\n    max_uniq_chars_count=0\n    max_uniq_chars_word=\"\"\
    \n    for word in \"${list[@]}\"; do\n        word_uniq_chars_count=$(echo \"\
    $word\" | sed -e 's/\\(.\\)/\\1\\n/g' | sort | uniq | wc -l)\n        if [[ \"\
    $word_uniq_chars_count\" -gt \"$max_uniq_chars_count\" ]]; then\n            max_uniq_chars_count=\"\
    $word_uniq_chars_count\"\n            max_uniq_chars_word=\"$word\"\n        fi\n\
    \    done\n    echo \"$max_uniq_chars_word\"", "    local max=0\n    local max_word=\"\
    \"\n    for word in $@; do\n        local unique=$(echo $word | sort | uniq |\
    \ wc -l)\n        if [ $unique -gt $max ]; then\n            max=$unique\n   \
    \         max_word=$word\n        fi\n    done\n    echo $max_word", '    echo
    "Not implemented"', "    # make an array from the list\n    array=($1)\n    #\
    \ get list of words in the array, minus their duplicates\n    for i in ${array[@]};\
    \ do\n        # count the number of unique characters in a word\n        # (make\
    \ sure it prints in a single line)\n        local -a tmp=($(echo $i | grep -o\
    \ . | sort | uniq | tr -d '\\n'))\n        # get the length of the array\n   \
    \     tmp_count=${#tmp[@]}\n        # save the word with max number of unique\
    \ characters\n        if [[ $tmp_count -gt $count ]]; then\n            word=$i\n\
    \            count=$tmp_count\n        fi\n    done\n    echo $word", "  max=0\n\
    \  max_word=\n  while [ $# -gt 0 ]; do\n    word=$1\n    shift\n    len=$(echo\
    \ $word | grep -o . | sort | uniq | wc -l)\n    if [ $len -gt $max ]; then\n \
    \     max=$len\n      max_word=$word\n    fi\n  done\n  echo $max_word", "  max_word=''\n\
    \  max_chars=0\n  for word in $1; do\n    if (( $(echo -n $word | LC_ALL=C sort\
    \ -u | wc -m) > max_chars )); then\n      max_chars=$(echo -n $word | LC_ALL=C\
    \ sort -u | wc -m)\n      max_word=$word\n    fi\n  done\n  echo \"$max_word\"",
  "    echo \"$1\" | tr ' ' '\\n' | sort -u | wc -l | sort -n | head -n 1", "    S=$(echo\
    \ $1 | tr \" \" \"\\n\")\n    for w in $S; do\n        N=$(echo -n $w | wc -c)\n\
    \        UL=$(echo -n $w | grep -o . | sort | uniq | wc -l)\n        if [ $N -eq\
    \ $UL ]; then\n            echo $w\n            return\n        fi\n    done",
  "  local -i max_unique=0\n  local max_word\n  local -i current_unique\n  local current_word\n\
    \  local current_char\n  # Loop through the list of words, building up a dictionary\
    \ of counts\n  # for each character\n  for current_word in $1; do\n    current_unique=0\n\
    \    for current_char in {a..z}; do\n      current_count=$(echo $current_word\
    \ | grep -o $current_char | wc -l)\n      if [[ $current_count -eq 1 ]]; then\n\
    \        current_unique+=1\n      fi\n    done\n    # If the current word's number\
    \ of unique characters is greater than\n    # the current max, store it and its\
    \ uniqueness\n    if [[ $current_unique -gt $max_unique ]]; then\n      max_unique=$current_unique\n\
    \      max_word=$current_word\n    fi\n  done\n  echo $max_word", "    local max_length=0\n\
    \    local max_index=0\n    local i=0\n    local length\n    local word\n\n  \
    \  # Replace the space with newline to make use of word count\n    while read\
    \ word; do\n        length=$(echo -n \"$word\" | tr -dC \"[:alnum:]\" | wc -c)\n\
    \        if [[ \"$length\" -gt \"$max_length\" ]]; then\n            max_length=\"\
    $length\"\n            max_index=\"$i\"\n        fi\n        i=$((i + 1))\n  \
    \  done <<< \"$1\"\n\n    # Get the maximum length string\n    local result=$(echo\
    \ \"$1\" | cut -d' ' -f \"$max_index\")\n    echo \"$result\"", "    # make associative\
    \ array of strings and number of unique characters in\n    # each string\n   \
    \ declare -A string_dict\n    for str in $1; do\n        # make a copy of the\
    \ string\n        tmp=${str}\n        str=''\n        # go through each character\
    \ in the string\n        for char in $(echo $tmp | grep -o .); do\n          \
    \  # if the character is not in the new string, add it\n            if [[ $str\
    \ != *$char* ]]; then\n                str+=$char\n            fi\n        done\n\
    \        # put the string and its number of unique characters in the\n       \
    \ # associative array\n        string_dict[$str]=${#str}\n    done\n    # sort\
    \ the keys of the associative array in descending order of value\n    # we have\
    \ to export the associative array to the `sort` command\n    export string_dict\n\
    \    keys=$(declare -p string_dict | cut -d \" \" -f 3- | sort -t \" \" -k 2 -rn)\n\
    \    # keep only the string (first word in each line)\n    max_strings=$(echo\
    \ \"$keys\" | cut -d \" \" -f 1)\n    # find the first string in lexicographical\
    \ order\n    max_string=$(echo \"$max_strings\" | head -n 1)\n    # find the number\
    \ of unique characters in the string\n    max_string_num_uniq_chars=${string_dict[$max_string]}\n\
    \    # find the number of strings with this number of unique characters\n    max_string_num_matches=$(echo\
    \ \"$max_strings\" | wc -l)\n    # if there are multiple strings with the same\
    \ number of unique characters,\n    # print all of them\n    if [[ $max_string_num_matches\
    \ -gt 1 ]]; then\n        echo \"$max_strings\"\n    else\n        echo \"$max_string\"\
    \n    fi", "    local -a splitStr=($1)\n    local -i maxLength=0\n    local -i\
    \ maxIndex=0\n    local -i strLength=0\n    local -i i=0\n    local j=0\n    local\
    \ uniqueChars=''\n    local char=''\n    local -i strIndex=0\n    local -i uniqueCharIndex=0\n\
    \    local -i isUnique=0\n    local -i k=0\n    local -i isSubstring=0\n    local\
    \ -i substrIndex=0\n    for (( i=0; i<${#splitStr[@]}; i++ )); do\n        strLength=${#splitStr[$i]}\n\
    \        uniqueChars=''\n        #echo \"${splitStr[$i]} has $strLength characters\"\
    \n        for (( j=0; j<$strLength; j++ )); do\n            char=${splitStr[$i]:$j:1}\n\
    \            #echo \"$char\"\n            isUnique=1\n            for (( k=0;\
    \ k<${#uniqueChars}; k++ )); do\n                if [[ $char == ${uniqueChars:$k:1}\
    \ ]]; then\n                    isUnique=0\n                    break\n      \
    \          fi\n            done\n            if [[ $isUnique -eq 1 ]]; then\n\
    \                uniqueChars+=$char\n            fi\n        done\n        if\
    \ [[ ${#uniqueChars} -gt $maxLength ]]; then\n            maxLength=${#uniqueChars}\n\
    \            maxIndex=$i\n        elif [[ ${#uniqueChars} -eq $maxLength ]]; then\n\
    \            isSubstring=0\n            substrIndex=0\n            for (( j=0;\
    \ j<${#splitStr[$i]}; j++ )); do\n                if [[ ${splitStr[$i]:$j:1} ==\
    \ ${splitStr[$maxIndex]:$substrIndex:1} ]]; then\n                    substrIndex+=1\n\
    \                else\n                    isSubstring=1\n                   \
    \ break\n                fi\n            done\n            if [[ $isSubstring\
    \ -eq 0 ]]; then\n                maxIndex=$i\n            fi\n        fi\n  \
    \  done\n    echo \"${splitStr[$maxIndex]}\"", "  local list=$*\n  local max=0\n\
    \  local max_word=\n  for word in $list; do\n    if [ ${#word} -gt $max ]; then\n\
    \      max=${#word}\n      max_word=$word\n    fi\n  done\n  echo $max_word",
  "    # Create an array where each entry is a word from $1\n    local arr=($1)\n\
    \    # Sort the array in lexicographical order\n    sorted=($(printf '%s\\n' \"\
    ${arr[@]}\" | sort))\n    local maxLen=${#sorted[0]}\n    local maxWord=${sorted[0]}\n\
    \    for i in ${sorted[@]}; do\n        local len=${#i}\n        if [[ $len -gt\
    \ $maxLen ]]; then\n            maxLen=$len\n            maxWord=$i\n        fi\n\
    \    done\n    echo $maxWord", "    # start count at 0\n    count=-1\n    # pick\
    \ the first argument (a word)\n    for arg in $1; do\n        # reset count for\
    \ this word\n        count=0\n        # consider each character in the word\n\
    \        for char in $(echo $arg | fold -w1); do\n            # if it is not already\
    \ counted\n            if [[ $unique_chars != *$char* ]]; then\n             \
    \   # count it\n                count=$(($count + 1))\n                # add it\
    \ to the list of counted chars\n                unique_chars=\"$unique_chars$char\"\
    \n            fi\n        done\n        # if this word has the largest number\
    \ of unique chars\n        if [[ $count -gt $max_count ]]; then\n            #\
    \ remember that this word has the largest count\n            max_count=$count\n\
    \            # remember this word\n            max_word=$arg\n        fi\n   \
    \ done\n    # return the max word\n    echo $max_word", "    # Map $1 to an array,\
    \ so we can count the number of elements\n    # without losing the IFS\n    local\
    \ -a array=( $1 )\n    if [ ${#array[@]} -eq 0 ]; then\n        echo '0: ERROR:\
    \ Must provide at least one string'\n        return 1\n    fi\n\n    local max_str=\"\
    \"\n    local max_len=0\n    local length=0\n    local str\n    for str in $1;\
    \ do\n        if [ ${#str} -gt $max_len ]; then\n            max_str=$str\n  \
    \          max_len=${#str}\n        fi\n    done\n\n    echo $max_str", "\tgawk\
    \ '\n\t\tBEGIN {\n\t\t\t# register all functions we use\n\t\t\tFUNCS[\"unique\"\
    ] = unique\n\t\t\tFUNCS[\"length\"] = length\n\t\t\tFUNCS[\"compare\"] = compare\n\
    \t\t\tFUNCS[\"append\"] = append\n\t\t\tFUNCS[\"print\"] = print\n\t\t\tFUNCS[\"\
    compare_result\"] = compare_result\n\t\t\tcompare_result = \"\"\n\t\t}\n\t\t#\
    \ should check if the element is in the array\n\t\t# should check if the element\
    \ is in the array\n\t\t# should check if the element is in the array\n\t\tfunction\
    \ unique(str, arr, len, ret, i) {\n\t\t\t# init return value\n\t\t\tlen = 0\n\t\
    \t\tret = \"\"\n\t\t\t# split str into arr\n\t\t\tsplit(str, arr, \"\")\n\t\t\t\
    # iterate over arr\n\t\t\tfor (i in arr) {\n\t\t\t\t# check if the element is\
    \ in the array\n\t\t\t\tif (!(arr[i] in ret)) {\n\t\t\t\t\t# append the element\
    \ to the return value\n\t\t\t\t\tlen = append(ret, arr[i])\n\t\t\t\t}\n\t\t\t\
    }\n\t\t\treturn len\n\t\t}\n\t\t# append value to s\n\t\tfunction append(s, v,\
    \ len) {\n\t\t\tlen = length(s)\n\t\t\ts = s v\n\t\t\treturn len + 1\n\t\t}\n\t\
    \t# compare two strings\n\t\tfunction compare(a, b, i, len, asc, res) {\n\t\t\t\
    # check if a or b is empty\n\t\t\tif (!a || !b) {\n\t\t\t\t# check if both a and\
    \ b are empty\n\t\t\t\tif (!a && !b) {\n\t\t\t\t\t# 0 == 0\n\t\t\t\t\treturn 0\n\
    \t\t\t\t}\n\t\t\t\t# a == 0\n\t\t\t\tif (!a) {\n\t\t\t\t\t# -1 < 0\n\t\t\t\t\t\
    return -1\n\t\t\t\t}\n\t\t\t\t# 0 <", "  local words=($1)\n  local max_num_unique=0\n\
    \  local max_unique_word=\n  for word in \"${words[@]}\"; do\n    local num_unique=$(echo\
    \ \"$word\" | fold -w1 | sort | uniq | wc -l)\n    if [ $num_unique -gt $max_num_unique\
    \ ]; then\n      max_num_unique=$num_unique\n      max_unique_word=$word\n   \
    \ fi\n  done\n  echo \"$max_unique_word\"", "    echo $1 | tr ' ' '\\n' | sort\
    \ -k 2 -n | tail -n 1", "  if [ $# -ne 1 ]; then\n    echo \"Error: Bad args to\
    \ find_max. Usage: find_max \\\"space separated list\\\"\"\n    return 1\n  fi\n\
    \  # TODO: Write this function\n  # Hint: sort -u sorts the input string in alphabetical\
    \ order\n  # Hint: wc -m counts the characters in the input string\n  for word\
    \ in $1; do\n    if [ $(echo $word | sort -u | wc -m) -gt $max_len ]; then\n \
    \     max_len=$(echo $word | sort -u | wc -m)\n      max_word=$word\n    fi\n\
    \  done\n  echo $max_word", "    # max_cnt holds the maximum unique character\
    \ count\n    # max_str holds the word with this max count\n    local max_cnt=0\
    \ max_str=\"\"\n    for word in $1; do\n        # get the number of unique characters\
    \ in this word\n        # by piping the characters to sort, then uniq -c, then\
    \ awk\n        # awk prints the 2nd field because uniq -c prints two fields\n\
    \        # separated by a space (count followed by the string)\n        # then\
    \ parens make sure this command substitution\n        # returns the number of\
    \ unique characters\n        local num_unique=$(echo \"$word\" |\n           \
    \                sort |\n                           uniq -c |\n              \
    \             awk '{print $2}')\n        # if num_unique is greater than max_cnt,\n\
    \        # update max_cnt and max_str\n        if ((num_unique > max_cnt)); then\n\
    \            max_cnt=$num_unique\n            max_str=$word\n        fi\n    done\n\
    \    # echo the string with the max unique characters\n    echo \"$max_str\"",
  "    max=\"\"\n    length=0\n    for word in $1; do\n        word_length=$(echo\
    \ $word | tr -dc \"a-zA-Z\" | fold -w1 | sort | uniq | wc -l)\n        if [ \"\
    $word_length\" -gt \"$length\" ]; then\n            max=$word\n            length=$word_length\n\
    \        fi\n    done\n    echo $max", "  local max=${1%% *}\n  shift\n  while\
    \ [ -n \"$1\" ]; do\n    local word=$1\n    local chars=$(echo \"$word\" | fold\
    \ -w1 | sort -u | wc -l)\n    if (( $chars > $(echo \"$max\" | fold -w1 | sort\
    \ -u | wc -l) )); then\n      max=$word\n    fi\n    shift\n  done\n  echo \"\
    $max\"", "    local max=''\n    local max_count=0\n    for str in $1; do\n   \
    \     local count=$(echo $str | sed 's/\\(.\\)/\\1\\n/g' | sort -u | wc -l)\n\
    \        if [[ count -gt max_count ]]; then\n            max=$str\n          \
    \  max_count=$count\n        fi\n    done\n    echo $max", "  str_len=($1)\n \
    \ for (( i=0; i<${#str_len[@]}; i++ ))\n  do\n    echo ${str_len[$i]} | awk '{\
    \ print $0, length }'\n  done | sort -k2 -n | awk '{ print $1 }' | uniq -c | sort\
    \ -k1 -n | tail -1 | awk '{ print $2 }'", "  declare -a words=($1)\n  echo ${words[0]}\n\
    \  return 0", "\t# If we have more than one word, we need to sort by length then\
    \ sort\n\t# lexicographically.\n\tif [ $(echo \"$1\" | wc -w) -gt 1 ]; then\n\t\
    \techo \"$1\" | tr ' ' '\\n' | sort -u -k2,2 | sort -r -k1,1 | sed 's/\\([^ ]*\\\
    ) .*/\\1/' | sed -n '1p'\n\telse\n\t\techo \"$1\"\n\tfi", "\tlocal max=0\n\tlocal\
    \ idx=0\n\tlocal max_idx=0\n\tfor word in $1; do\n\t\tlocal count=0\n\t\tlocal\
    \ used=\n\t\tfor ((i=0; i<${#word}; i++)); do\n\t\t\tif [[ ! \"${used}\" =~ \"\
    ${word:$i:1}\" ]]; then\n\t\t\t\tused+=\"${word:$i:1}\"\n\t\t\t\t((count++))\n\
    \t\t\tfi\n\t\tdone\n\t\tif ((count > max)); then\n\t\t\tmax=$count\n\t\t\tmax_idx=$idx\n\
    \t\tfi\n\t\t((idx++))\n\tdone\n\techo \"${1}\" | cut -d \" \" -f ${max_idx}",
  "    local max_word=\"\"\n    local max_count=0\n    for word in $1; do\n      \
    \  count=$(echo $word | fold -w1 | sort | uniq | wc -l)\n        if [ $count -gt\
    \ $max_count ]; then\n            max_count=$count\n            max_word=$word\n\
    \        fi\n    done\n    echo $max_word", "  local result=\"$1\"\n  local current_max=1\n\
    \  for i in $1; do\n    local count=$(echo \"$i\" | grep -o . | sort | uniq |\
    \ wc -l)\n    if [ $count -gt $current_max ]; then\n      current_max=$count\n\
    \      result=\"$i\"\n    fi\n  done\n  echo \"$result\"", "    if [ \"$#\" -eq\
    \ 0 ]; then\n        echo \"0 words received.\"\n        return 1\n    fi\n  \
    \  # Convert to array\n    words=(\"$@\")\n    # Initialize maxLength to 1\n \
    \   maxLength=1\n    # Start at first word, 0th index\n    index=0\n    # Iterate\
    \ over words\n    for word in \"${words[@]}\"; do\n        # Count number of unique\
    \ characters\n        #   sort: sort characters in ascending order\n        #\
    \   uniq: remove duplicates\n        #   wc -l: count number of lines\n      \
    \  currentLength=$(echo \"$word\" | sort | uniq | wc -l)\n        # If this is\
    \ greater than maxLength, update maxLength and record current index\n        if\
    \ [ \"$currentLength\" -gt \"$maxLength\" ]; then\n            maxLength=\"$currentLength\"\
    \n            maxIndex=\"$index\"\n        fi\n        # Increment index to record\
    \ next word\n        ((index++))\n    done\n    # Return word at maxIndex\n  \
    \  echo \"${words[$maxIndex]}\"", "    echo $1 | xargs -n1 | sort -t':' -k2,2nr\
    \ -k1,1 | head -n1 | cut -d':' -f1", "  # your code goes here\n  max=0\n  echo\
    \ $1 | tr ' ' '\\n' | \n  while read string\n  do\n    unique_chars=`echo $string\
    \ | sed 's/\\(.\\)/\\1\\n/g' | sort | uniq | wc -l`\n    echo $unique_chars $string\n\
    \    if [[ $unique_chars -gt $max ]]\n    then\n      max=$unique_chars\n    \
    \  ret_val=$string\n    fi\n  done\n  echo $ret_val", "\tlocal tmpfile\n\ttmpfile=$(mktemp)\n\
    \tlocal cnt=0\n\tlocal n\n\tlocal max\n\tlocal m_l\n\tlocal m_c\n\tlocal l\n\t\
    local i\n\tfor n in $1; do\n\t\techo \"  $(echo $n | wc -c) \\\"$n\\\"\" >> $tmpfile\n\
    \t\t((cnt++))\n\tdone\n\tm_l=$(cat $tmpfile | awk '{l=$1} END {print l}')\n\t\
    m_c=0\n\tfor ((i=1; i<=cnt; i++)); do\n\t\tl=$(cat $tmpfile | awk -v line=$i 'NR==line\
    \ {print $1}')\n\t\tif [ $l -gt $m_l ]; then\n\t\t\tm_l=$l\n\t\t\tm_c=0\n\t\t\
    fi\n\t\tif [ $l -eq $m_l ]; then\n\t\t\t((m_c++))\n\t\tfi\n\tdone\n\ti=1\n\twhile\
    \ [ $m_c -ne 1 ]; do\n\t\tl=$(cat $tmpfile | awk -v line=$i 'NR==line {print $1}')\n\
    \t\tif [ $l -eq $m_l ]; then\n\t\t\t((m_c--))\n\t\tfi\n\t\t((i++))\n\tdone\n\t\
    cat $tmpfile | awk -v line=$i 'NR==line {print $2}'\n\trm $tmpfile", "    local\
    \ max=0\n    local word=''\n    for f in $1; do\n        local len=$(echo $f |\
    \ sed 's/\\(.\\)/\\1\\n/g' | sort -u | wc -l)\n        if [[ $len -gt $max ]];\
    \ then\n            max=$len\n            word=$f\n        fi\n    done\n    echo\
    \ $word", "    max=0;\n    max_word='';\n    for word in $1; do\n        if [[\
    \ \"$word\" != $max_word ]]; then\n            chars=`echo $word | grep -o . |\
    \ sort | uniq | wc -l`\n            if [[ $chars -gt $max ]]; then\n         \
    \       max=$chars;\n                max_word=$word;\n            fi\n       \
    \ fi\n    done\n    echo $max_word;", "    list=($@)\n    uniq_max=0\n    for\
    \ item in ${list[@]}; do\n        uniq=`echo $item | grep -o . | sort | uniq |\
    \ wc -l`\n        if [ $uniq -gt $uniq_max ]; then\n            uniq_max=$uniq\n\
    \            word=$item\n        fi\n    done\n    echo $word", "    for str in\
    \ $1; do\n        # Convert string to array: only unique characters\n        chars=($(echo\
    \ \"$str\" | sed 's/\\(.\\)/\\1\\n/g' | sort -u | tr -d '\\n'))\n        # Calculate\
    \ length of array\n        len=${#chars[@]}\n        # Store maximum length and\
    \ corresponding string\n        if [ \"$len\" -gt \"$max\" ]; then\n         \
    \   max=\"$len\"\n            str_max=\"$str\"\n        fi\n    done\n    echo\
    \ \"$str_max\"", "  local -i max_count=0\n  local max_word=\"\"\n  local -i i\n\
    \  local -i count\n  local word\n  for word in $1; do\n    count=0\n    for ((i=0;\
    \ i<${#word}; i++)); do\n      # echo \"${word:i:1}\"\n      if [[ \"${word:i:1}\"\
    \ != *\"${word:0:i}\"* ]]; then\n        ((count++))\n      fi\n    done\n   \
    \ if ((count > max_count)); then\n      max_count=$count\n      max_word=$word\n\
    \    fi\n  done\n  echo \"$max_word\"", "  local word\n  local word_length\n \
    \ local word_length_tmp\n  local unique_char_tmp\n  local unique_char\n  local\
    \ unique_char_length\n  local unique_char_length_tmp\n  local unique_char_max\n\
    \n  word_length=${#1}\n  if [[ ${word_length} -eq 0 ]]; then\n    echo ''\n  \
    \  return\n  fi\n\n  unique_char=$(echo $1 | head -c 1)\n  unique_char_length=${#unique_char}\n\
    \  unique_char_max=0\n\n  for word in $1; do\n    word_length_tmp=${#word}\n \
    \   unique_char_tmp=$(echo \"${word}\" | fold -w${word_length_tmp} | sort -u |\
    \ tr -d '\\n')\n    unique_char_length_tmp=${#unique_char_tmp}\n    if [[ ${unique_char_length_tmp}\
    \ -gt ${unique_char_max} ]]; then\n      unique_char_max=${unique_char_length_tmp}\n\
    \      unique_char=${unique_char_tmp}\n    fi\n  done\n\n  echo \"${unique_char}\"",
  "\t# Write your code here.\n    list=$1; # Get the first argument\n    max=0;\n\
    \    maxword=\"\";\n    for word in $list; do\n        uniques=$(echo $word |\
    \ grep -o . | sort | uniq | wc -l);\n        if [ $uniques -gt $max ]; then\n\
    \            max=$uniques;\n            maxword=$word;\n        fi\n    done\n\
    \    echo $maxword;", "  words=$1\n  max_length=0\n  # Following for loop iterates\
    \ over each word in the $words\n  for word in $words; do\n    word_length=$(echo\
    \ $word | grep -o . | sort | uniq | wc -l)\n    # If current word has more unique\
    \ characters than the previous one\n    # then it will be assigned to max_length\n\
    \    if [[ $word_length -gt $max_length ]]; then\n      max_length=$word_length\n\
    \      max_word=$word\n    # If two words have same number of unique characters\
    \ then the \n    # word which comes first in lexicographical order will be assigned\n\
    \    # to max_word\n    elif [[ $word_length -eq $max_length ]]; then\n      if\
    \ [[ $word < $max_word ]]; then\n        max_word=$word\n      fi\n    fi\n  done\n\
    \  echo $max_word", "    # Handle empty case\n    if [ -z \"$1\" ]; then\n   \
    \     echo \"\"\n        return\n    fi\n\n    # Generate an array of input strings\n\
    \    read -ra words <<< \"$1\"\n\n    # For each word, sort the characters and\
    \ then remove duplicates to get the\n    # number of unique characters in the\
    \ word. Save the word that has the\n    # highest number of unique characters.\n\
    \    max=0\n    result=\"\"\n    for word in \"${words[@]}\"; do\n        chars=$(echo\
    \ $word | sed -e 's/\\(.\\)/\\1\\n/g' | sort | uniq | tr -d '\\n')\n        num_chars=$(echo\
    \ $chars | wc -c)\n        if (( num_chars > max )); then\n            max=$num_chars\n\
    \            result=$word\n        fi\n    done\n\n    echo $result", "    declare\
    \ -A word_map\n    for word in $1; do\n        word_map[$word]=$(echo $word |\
    \ fold -w1 | sort | uniq | wc -l)\n    done\n    min_cnt=${word_map[$(echo $1\
    \ | cut -d' ' -f1)]}\n    min_word=$(echo $1 | cut -d' ' -f1)\n    for word in\
    \ $1; do\n        if [[ ${word_map[$word]} -lt $min_cnt ]]; then\n           \
    \ min_cnt=${word_map[$word]}\n            min_word=$word\n        fi\n    done\n\
    \    echo $min_word", "    # your code goes here\n    local array=( $1 )\n   \
    \ local max=${array[0]}\n    local max_len=${#max}\n    local current_len\n  \
    \  local current_uniq_len\n    local max_uniq_len=${#max}\n    local i\n\n   \
    \ for word in \"${array[@]}\"; do\n        current_len=${#word}\n        current_uniq_len=$(echo\
    \ -n $word | grep -o . | sort | uniq | wc -c)\n        if [[ ${current_uniq_len}\
    \ -gt ${max_uniq_len} ]]; then\n            max=${word}\n            max_uniq_len=${current_uniq_len}\n\
    \        elif [[ ${current_uniq_len} -eq ${max_uniq_len} ]]; then\n          \
    \  if [[ ${word} < ${max} ]]; then\n                max=${word}\n            fi\n\
    \        fi\n    done\n\n    echo ${max}", "  echo \"Determining the maximum of\
    \ the following words: $1\"\n  res=\"\"\n  max_uniq_chars=0\n  for word in $1;\
    \ do\n    num_uniq_chars=$(echo $word | sed 's/\\(.\\)/\\1\\n/g' | sort | uniq\
    \ | wc -l)\n    if [ $num_uniq_chars -gt $max_uniq_chars ]; then\n      max_uniq_chars=$num_uniq_chars\n\
    \      res=$word\n    fi\n  done\n  echo $res", "    # Array of strings\n    arr=(\"\
    $@\")\n    # Max number of unique characters\n    max=0\n    # Max word\n    max_word=\"\
    \"\n    # For each string\n    for s in \"${arr[@]}\"; do\n        # Number of\
    \ unique characters\n        num=$(echo \"$s\" | tr -cd '\\n' | wc -l)\n     \
    \   # If it's the max one\n        if [ \"$num\" -gt \"$max\" ]; then\n      \
    \      # Update max\n            max=\"$num\"\n            # Update max word\n\
    \            max_word=\"$s\"\n        fi\n    done\n    # Return the max word\n\
    \    echo \"$max_word\"", "    # first sort the words by string length\n    #\
    \ and then sort again by number of unique characters\n    # and then sort again\
    \ by lexicographical order\n    # and then take the first line\n    echo \"$1\"\
    \ | tr ' ' '\\n' | sort -nr -k 1 -k 2 -k 3 | head -n 1", "  # list is passed in\
    \ as $1\n  local list=$1\n  local uniq_max=0\n  local word_max=\"\"\n  local uniq\n\
    \  local word\n  for word in $list; do\n    uniq=$(echo -n $word | fold -w1 |\
    \ sort -u | tr -d '\\n')\n    if [ ${#uniq} -gt $uniq_max ]; then\n      uniq_max=${#uniq}\n\
    \      word_max=$word\n    fi\n  done\n  echo $word_max", "  local max_str=\"\"\
    \n  local max_len=0\n  local str=\"\"\n  local len=0\n  local chars=\"\"\n  local\
    \ ch=\"\"\n  local str_list=$1\n  for str in $str_list; do\n    chars=\"\"\n \
    \   for ch in $(echo $str | grep -o .); do\n      if ! echo $chars | grep -q -w\
    \ $ch; then\n        chars=\"$chars $ch\"\n      fi\n    done\n    len=$(echo\
    \ $chars | wc -w)\n    if [ $len -gt $max_len ]; then\n      max_len=$len\n  \
    \    max_str=$str\n    elif [ $len -eq $max_len ]; then\n      if [ $str \\< $max_str\
    \ ]; then\n        max_str=$str\n      fi\n    fi\n  done\n  echo $max_str", '    echo
    "$1" | tr " " "\n" | sort -Vu | tail -n 1', "\tIFS=' ' read -ra words <<< \"$1\"\
    \n\tmax_unique_chars_count=0\n\tmax_unique_chars_word=\"\"\n\tfor word in \"${words[@]}\"\
    ; do\n\t\tunique_chars_count=$(echo \"$word\" | grep -o . | sort | uniq | wc -l)\n\
    \t\tif [ \"$unique_chars_count\" -gt \"$max_unique_chars_count\" ]; then\n\t\t\
    \tmax_unique_chars_count=$unique_chars_count\n\t\t\tmax_unique_chars_word=\"$word\"\
    \n\t\tfi\n\tdone\n\techo \"$max_unique_chars_word\"", "    set -f\n    set --\
    \ $1\n    max=-1\n    max_word=\n    for arg in \"$@\"; do\n        arg_lower=\"\
    $(echo $arg | tr '[:upper:]' '[:lower:]')\"\n        arg_len=${#arg_lower}\n \
    \       arg_uni_len=$(echo $arg_lower | fold -w1 | sort -u | wc -l)\n        if\
    \ [[ $arg_uni_len -gt $max ]]; then\n            max=$arg_uni_len\n          \
    \  max_word=$arg\n        elif [[ $arg_uni_len -eq $max ]]; then\n           \
    \ if [[ $arg_lower < $max_word ]]; then\n                max_word=$arg\n     \
    \       fi\n        fi\n    done\n    echo $max_word", "  declare -A arr\n  for\
    \ i in ${@}; do\n    local s=$(printf \"%s\" \"$i\" | fold -w1 | sort | uniq |\
    \ wc -c)\n    arr[$i]=$s\n  done\n  local a=${@}\n  local b=${arr[$a]}\n  max=${a[0]}\n\
    \  for i in ${@}; do\n    if [[ ${arr[$i]} -gt $b ]]; then\n      max=$i\n   \
    \   b=${arr[$i]}\n    fi\n  done\n  printf \"%s\" \"$max\"", "  local max_word\n\
    \  local max_chars_count=0\n  for word in $1; do\n    local chars_count=$(echo\
    \ \"$word\" | sed -e 's/\\(.\\)/\\1\\n/g' | sort -u | wc -l)\n    if [[ chars_count\
    \ -gt max_chars_count ]]; then\n      max_chars_count=$chars_count\n      max_word=$word\n\
    \    fi\n  done\n  echo $max_word", "  #check if input is empty, if it is then\
    \ return empty string\n  if [ -z \"$1\" ]; then\n    echo \"\"\n    return\n \
    \ fi\n  #go through each word in the list\n  #find the number of unique characters\
    \ in each word\n  #if word has the maximum number of unique characters, keep track\
    \ of word\n  IFS=\" \" read -r -a STR <<< $1\n  local maxChar=0\n  local maxWord=\"\
    \"\n  for word in \"${STR[@]}\"; do\n    local charCount=$(echo \"$word\" | fold\
    \ -w1 | sort -u | wc -l)\n    if [ $charCount -gt $maxChar ]; then\n      maxChar=$charCount\n\
    \      maxWord=$word\n    fi\n  done\n  echo \"$maxWord\"", "    IFS=' ' read\
    \ -r -a strs <<< \"$1\"\n    max_count=0\n    max_word=\"\"\n    for str in \"\
    ${strs[@]}\"; do\n        for i in $(echo \"$str\" | fold -w1); do\n         \
    \   # Get the length of string array with unique characters\n            # If\
    \ length > max_count, replace max_count and\n            # replace max_word with\
    \ current word\n            if [[ $(echo -n \"$str\" | grep -o \"$i\" | wc -l)\
    \ -gt \"$max_count\" ]]; then\n                max_count=$(echo -n \"$str\" |\
    \ grep -o \"$i\" | wc -l)\n                max_word=\"$str\"\n            fi\n\
    \        done\n    done\n    echo \"$max_word\"", "  word=$(echo $1 | cut -d'\
    \ ' -f1)\n  for i in $1; do\n    if [ $(echo $i | fold -w1 | sort -u | wc -w)\
    \ -gt $(echo $word | fold -w1 | sort -u | wc -w) ]; then\n      word=$i\n    fi\n\
    \  done\n  echo $word", "    input_list=$1\n    for word in $input_list; do\n\
    \        uniq_chars=$(echo $word | fold -w1 | sort | uniq | wc -l)\n        if\
    \ [ $uniq_chars -gt $max_count ]; then\n            max_count=$uniq_chars\n  \
    \          max_word=$word\n        fi\n    done\n    echo $max_word", "    local\
    \ words=($1)\n    echo \"words:\" ${words[@]}\n    local max=${words[0]}\n   \
    \ local max_len=$(echo ${words[0]} | tr -cd '_' | wc -c)\n    echo \"max_len:\"\
    \ $max_len\n    local curr_len=0\n    for w in ${words[@]}; do\n        curr_len=$(echo\
    \ $w | tr -cd '_' | wc -c)\n        echo \"curr_len:\" $curr_len\n        if [[\
    \ $curr_len -gt $max_len ]]; then\n            max=$w\n            max_len=$curr_len\n\
    \        fi\n    done\n    echo $max", "\twhile [ -n \"$1\" ]; do\n\t\tword=$1\n\
    \t\tset -- $(echo $1 | tr -cd '[[:alnum:]]' | fold -w1 | sort | uniq)\n\t\tif\
    \ [ $(echo $#) -gt $(echo $max) ]; then\n\t\t\tmax=$#\n\t\t\tmax_word=$word\n\t\
    \telif [ $(echo $#) -eq $(echo $max) ]; then\n\t\t\tif [ $(echo $word) \\< $(echo\
    \ $max_word) ]; then\n\t\t\t\tmax_word=$word\n\t\t\tfi\n\t\tfi\n\t\tshift\n\t\
    done\n\techo $max_word", "  local str=$1    # list of strings in $1\n  local words=()\
    \  # array of words\n  local count=()  # array of unique char counts\n  local\
    \ max_count=0   # max unique char count\n  local max_index=0   # word index with\
    \ max unique char count\n  local prev_count=0  # stores previous unique char count\n\
    \  local diff=0        # difference between 2 unique char counts\n  local pos=0\
    \         # position in string of unique char count\n\n  # loop through all words\
    \ in list\n  for word in $str\n  do\n    # save each word in words array\n   \
    \ words+=($word)\n\n    # find number of unique characters in each word\n    uniq_count=$(echo\
    \ $word | sed 's/\\(.\\)/\\1\\n/g' | sort | uniq | wc -l)\n\n    # save each count\
    \ in count array\n    count+=($uniq_count)\n\n    # if we are not on the first\
    \ word, find difference between\n    # current count and previous count\n    if\
    \ [ $prev_count -ne 0 ]\n    then\n      diff=$(($uniq_count - $prev_count))\n\
    \    fi\n\n    # save max unique char count and word index\n    if [ $uniq_count\
    \ -gt $max_count ] || \\\n       [ $uniq_count -eq $max_count ] && [ $diff -gt\
    \ 0 ]\n    then\n      max_count=$uniq_count\n      max_index=$pos\n    fi\n\n\
    \    # save current unique char count as previous\n    prev_count=$uniq_count\n\
    \n    # increment position\n    pos=$(($pos + 1))\n  done\n\n  # print word with\
    \ most unique characters\n  echo ${words[$max_index]}", "    max_chars=0\n   \
    \ max_str=\"\"\n    for i in $1; do\n        chars=$(echo -n $i | tr -d '\\n'\
    \ | fold -w1 | sort | uniq | grep -o .)\n        if [ ${#chars} -gt $max_chars\
    \ ]; then\n            max_chars=${#chars}\n            max_str=$i\n        fi\n\
    \    done\n    echo $max_str", "  # Insert your code here\n  declare -a strarr\n\
    \  strarr=($1)\n  # Get max unique\n  declare -a chkarr\n  chkarr=($(echo \"${strarr[@]}\"\
    \ |\n    tr ' ' '\\n' |\n    xargs -I{} echo -n \"{}\" |\n    fold -w1 |\n   \
    \ sort |\n    uniq -u |\n    tr -d '\\n'))\n  maxlen=${#chkarr[@]}\n  maxidx=0\n\
    \  for ((i=0; i<${#strarr[@]}; i++)); do\n    declare -a tmpchkarr\n    tmpchkarr=($(echo\
    \ -n \"${strarr[$i]}\" |\n      fold -w1 |\n      sort |\n      uniq -u |\n  \
    \    tr -d '\\n'))\n    tmplen=${#tmpchkarr[@]}\n    if [ \"$tmplen\" -gt \"$maxlen\"\
    \ ]; then\n      maxlen=$tmplen\n      maxidx=$i\n    elif [ \"$tmplen\" -eq \"\
    $maxlen\" ]; then\n      if [ \"${strarr[$i]}\" \\< \"${strarr[$maxidx]}\" ];\
    \ then\n        maxidx=$i\n      fi\n    fi\n  done\n  echo \"${strarr[$maxidx]}\"",
  "  local word length\n  local max_word max_length=0\n  for word in $1; do\n    #\
    \ find out how many unique characters the word has\n    # if there are duplicate\
    \ characters in the word,\n    # they will be counted as one\n    length=$(echo\
    \ $word | sed 's/\\(.\\)/\\1\\n/g' | sort -u | wc -l)\n    if [ $length -gt $max_length\
    \ ]; then\n      max_length=$length\n      max_word=$word\n    fi\n  done\n  echo\
    \ $max_word", "    local -i max_count=0 # max count of unique chars\n    local\
    \ word=\"\" # the word to return\n    for s in $1; do\n        local -i cnt=0\
    \ # count of unique chars\n        for c in $(echo \"$s\" | grep -o .); do\n \
    \           [[ \"$(echo \"$s\" | grep -o \"$c\" | wc -l)\" -eq 1 ]] && (( cnt++\
    \ ))\n        done\n        if [[ \"$cnt\" -gt \"$max_count\" ]]; then\n     \
    \       max_count=\"$cnt\"\n            word=\"$s\"\n        elif [[ \"$cnt\"\
    \ -eq \"$max_count\" ]]; then\n            [[ \"$word\" -gt \"$s\" ]] && word=\"\
    $s\"\n        fi\n    done\n    echo \"$word\"", "  for word in $1; do\n    unique_letter_count=$(echo\
    \ $word | grep -o . | sort | uniq | wc -l)\n    echo \"$unique_letter_count:$word\"\
    \n  done | sort -k1rn -k2 | head -n1 | cut -d: -f2", "    local max_word=\"$1\"\
    \n    local max_word_count=0\n    local word=\"$1\"\n    local word_count=0\n\
    \    shift\n\n    while [ \"$1\" != \"\" ]; do\n        # Count number of unique\
    \ characters in word $1\n        word_count=$(echo \"$1\" | grep -o -w '[a-zA-Z]'\
    \ | sort | uniq | wc -l)\n        if [ $word_count -gt $max_word_count ]; then\n\
    \            max_word_count=$word_count\n            max_word=\"$1\"\n       \
    \ fi\n        shift\n    done\n\n    echo \"$max_word\"", "  # code here\n  echo\
    \ \"$1\" | tr ' ' '\\n' | sort -u | wc -l", "  echo \"$1\" | tr ' ' '\\n' | sort\
    \ -u | sort -r -n -k 2 | awk '{print $1}' | head -n 1", "  local value=0\n  local\
    \ output=\"\"\n  for word in $1; do\n    local temp=$(echo $word | grep -o . |\
    \ sort | uniq | wc -l)\n    if [ $temp -gt $value ]; then\n      value=$temp\n\
    \      output=$word\n    fi\n  done\n  echo $output", "    local max_word\n  \
    \  max_word=$(echo \"$1\" | tr ' ' '\\n' | tr -d '\\n' | sed 's/ //g' | tr ' '\
    \ '\\n' |\n        sort | uniq -u | tr '\\n' ' ' | sed 's/ //g')\n    if [ -z\
    \ \"$max_word\" ]; then\n        echo \"No word has unique characters\"\n    else\n\
    \        echo \"$max_word\"\n    fi", "\ttr -s \" \" \"\\n\" <<< \"$1\" | {\n\t\
    \tmax_word=\"\"\n\t\tmax_len=0\n\t\twhile read word\n\t\tdo\n\t\t\tword_len=$(tr\
    \ -d -c -s \"$word\" | wc -c)\n\t\t\tif [ \"$word_len\" -gt \"$max_len\" ]\n\t\
    \t\tthen\n\t\t\t\tmax_len=\"$word_len\"\n\t\t\t\tmax_word=\"$word\"\n\t\t\tfi\n\
    \t\tdone\n\t\techo \"$max_word\"\n\t}", "    uniq_chars() {\n        printf '%s'\
    \ \"$1\" |\n        LC_ALL=C sort -u\n    }\n    output=\"\"\n    max_uniq=0\n\
    \    for word in $1; do\n        word_uniq=$(uniq_chars \"$word\")\n        word_uniq_num=$(printf\
    \ '%s' \"$word_uniq\" | wc -m)\n        if [[ word_uniq_num -gt max_uniq ]]; then\n\
    \            max_uniq=$word_uniq_num\n            output=$word\n        fi\n \
    \   done\n    printf '%s' \"$output\"", "    # $1 is a space-separated list\n\
    \    local max_word=''\n    local max_word_len=0\n    for word in $1; do\n   \
    \     # get the length of unique chars\n        local len=`echo $word | sed 's/\\\
    (.\\)/\\1\\n/g' | sort | uniq | wc -l`\n        if [ $len -gt $max_word_len ];\
    \ then\n            max_word_len=$len\n            max_word=$word\n        fi\n\
    \    done\n    echo $max_word", "  # Your code here\n  if [ $# -lt 1 ]; then\n\
    \    echo 'Please pass in arguments!'\n    return\n  fi\n  str_arr=($@)\n  max_len=0\n\
    \  for str in \"${str_arr[@]}\"; do\n    len=`echo $str | grep -o . | sort | uniq\
    \ | wc -l`\n    if [ $len -gt $max_len ]; then\n      max_len=$len\n      max_str=$str\n\
    \    fi\n  done\n  echo $max_str", "    local max_word=\"$1\"\n    local max_num=${#max_word}\n\
    \    local cur_num=0\n    for word in $1; do\n        cur_num=${#word}\n     \
    \   if [ $cur_num -gt $max_num ]; then\n            max_num=$cur_num\n       \
    \     max_word=$word\n        fi\n    done\n    echo $max_word", "    for word\
    \ in $1\n    do\n        uniq_count=`echo $word | grep -o . | sort | uniq | wc\
    \ -l`\n        if [[ \"$uniq_count\" -gt \"$max_count\" ]]\n        then\n   \
    \         max_count=$uniq_count\n            max_word=$word\n        fi\n    done\n\
    \    echo $max_word", "    max_word=\"\"\n    max_unique=0\n    for word in $1;\
    \ do\n        unique=$(echo $word | grep -o . | sort | uniq | wc -l)\n       \
    \ if [ $unique -gt $max_unique ]; then\n            max_unique=$unique\n     \
    \       max_word=$word\n        fi\n    done\n    echo $max_word", "  words=$1\n\
    \  for word in $words; do\n    echo \"$word:$(tr -cd $word < /dev/null | wc -c)\"\
    \n  done | sort -r -k 2 -t: | head -n 1 | cut -d: -f1", "  local max=\"$1\"\n\
    \  for word in $1; do\n    # replace the newline with a space, then check the\
    \ length of the\n    # resulting string\n    if [ \"$(echo \"${word}\" | tr -s\
    \ '[:alpha:]' | tr -d ' ' | wc -c)\" -gt \"$(echo \"${max}\" | tr -s '[:alpha:]'\
    \ | tr -d ' ' | wc -c)\" ]; then\n      max=\"${word}\"\n    fi\n  done\n  echo\
    \ \"${max}\"", "    word_with_max_chars=\"\"\n    max_chars=0\n    for word in\
    \ $@; do\n        num_chars=$(echo $word | grep -o . | sort | uniq | wc -l)\n\
    \        if [ $num_chars -gt $max_chars ]; then\n            max_chars=$num_chars\n\
    \            word_with_max_chars=$word\n        fi\n    done\n    echo $word_with_max_chars",
  "  local max=0\n  local max_word=''\n  for word in $1; do\n    unique=$(echo $word\
    \ | tr -cd '\\n' | wc -l)\n    if [[ $unique -gt $max ]]; then\n      max=$unique\n\
    \      max_word=$word\n    fi\n  done\n  echo $max_word", "    local words=$1\n\
    \    local max=0\n    local best_word=''\n    for word in $words; do\n       \
    \ local chars=${#word}\n        if [ $chars -gt $max ]; then\n            max=$chars\n\
    \            best_word=$word\n        fi\n    done\n    echo $best_word", "  \
    \  declare -a words=(\"$@\")\n    result=\"\"\n    max_count=0\n    for word in\
    \ \"${words[@]}\"; do\n        # Count the number of unique characters.\n    \
    \    # If a character was already seen, it won't be added to the array\n     \
    \   # (using index).\n        declare -A chars=()\n        for ((i=0; i<${#word};\
    \ i++)); do\n            chars[${word:$i:1}]=1\n        done\n        # Is this\
    \ a new max?\n        local count=${#chars[@]}\n        if ((count > max_count));\
    \ then\n            max_count=$count\n            result=$word\n        fi\n \
    \   done\n    echo \"$result\"", '  echo $1 | xargs -n1 | sort -u | sort -k2,2nr
    | head -1', "    local -a words; local -i i=0; local -i j;\n    local -i max_uniq_char=0;\
    \ local -i max_index=-1;\n    for word in $1; do\n        words[i++]=$word\n \
    \   done\n    for ((j=0; j<i; j++)); do\n        local uniq_char=`echo \"${words[j]}\"\
    \ | awk 'BEGIN { FS = \"\" }\n        {\n            for (i = 1; i <= NF; i++)\
    \ {\n                char[$i] = 1\n            }\n            n=0\n          \
    \  for (i in char) {\n                n++\n            }\n            print n\n\
    \        }'`\n        if [[ $uniq_char -gt $max_uniq_char ]]; then\n         \
    \   max_uniq_char=$uniq_char\n            max_index=$j\n        fi\n    done\n\
    \    echo \"${words[max_index]}\"", "    local max=0\n    local max_word=\n  \
    \  for word in $1; do\n        local len=${#word}\n        local char_set=($(echo\
    \ $word | grep -o . | sort -u))\n        local char_set_len=${#char_set[@]}\n\
    \        if [[ \"$char_set_len\" -gt \"$max\" ]]; then\n            max=$char_set_len\n\
    \            max_word=$word\n        elif [[ \"$char_set_len\" -eq \"$max\" ]];\
    \ then\n            if [[ \"$word\" < \"$max_word\" ]]; then\n               \
    \ max_word=$word\n            fi\n        fi\n    done\n    echo $max_word", " \
    \   # Iterate over each string\n    for str in $1; do\n        # Count unique\
    \ characters using tr.\n        # Repeat each character once, then pass to grep\
    \ -c which counts the\n        # number of lines.\n        char_count=$(echo \"\
    $str\" | tr -c -d [:alnum:] | grep -c .)\n        # As the first string is always\
    \ going to be the lexicographically\n        # first if the number of unique characters\
    \ is the same, we will\n        # just update max_char_count and result if char_count\
    \ is higher\n        # than max_char_count\n        if [ $char_count -gt $max_char_count\
    \ ]; then\n            max_char_count=$char_count\n            result=$str\n \
    \       fi\n    done\n    echo $result", "    local result\n    local maxlen=0\n\
    \    local tmp\n    for i in $1\n    do\n        tmp=$(echo $i | uniq | wc -l)\n\
    \        if [[ $tmp -gt $maxlen ]]\n        then\n            maxlen=$tmp\n  \
    \          result=$i\n        fi\n    done\n    echo $result", "    ret=\"\"\n\
    \    max=0\n    while [ $# -gt 0 ]; do\n        if [ ${#1} -gt $max ]; then\n\
    \            ret=$1\n            max=${#1}\n        fi\n        shift\n    done\n\
    \    echo $ret", "\tlocal max_chars=$(echo \"$1\" | sed 's/\\s/\\n/g' | awk '{print\
    \ length($0)}' | sort -n | tail -n 1)\n\techo \"$1\" | sed 's/\\s/\\n/g' | awk\
    \ '{ if (length($0) == '$max_chars') print $0 }' | sort | head -n 1", "    IFS='\
    \ '\n    read -ra words <<<\"$1\"\n    uniq_max=0\n    for w in \"${words[@]}\"\
    ; do\n        uniq_count=$(grep -o . <<<\"$w\" | sort -u | wc -l)\n        if\
    \ [ \"$uniq_count\" -gt \"$uniq_max\" ]; then\n            uniq_max=\"$uniq_count\"\
    \n            result=\"$w\"\n        fi\n    done\n    echo \"$result\"", "  echo\
    \ \"$1\" | awk 'BEGIN { max = -1; max_str = \"\" } { x = length($0); for (i =\
    \ 1; i <= x; i++) { char[substr($0, i, 1)] = 1 }; x = 0; for (key in char) { if\
    \ (char[key] == 1) { x += 1 } }; if (x > max) { max = x; max_str = $0 } }; END\
    \ { print max_str }'", "    echo \"$1\" | awk '{\n        for (i = 1; i <= NF;\
    \ i++) {\n            s = $i\n            n = length(s)\n            for (j =\
    \ 1; j <= n; j++) {\n                char = substr(s, j, 1)\n                if\
    \ (char ~ /[a-zA-Z]/) {\n                    cnt[char]++\n                }\n\
    \            }\n            if (length(cnt) > max) {\n                max = length(cnt)\n\
    \                word = s\n            }\n            delete cnt\n        }\n\
    \        print word\n    }'", "    max=0\n    max_idx=0\n    # Loop over the list\
    \ of strings\n    for ((i=1; i<=$#; i++)); do\n        # Get the length of the\
    \ string\n        len=${#@:i:1}\n        # Get the number of unique characters\n\
    \        num_unique=$(echo ${@:i:1} | sed 's/\\(.\\)/\\1\\n/g' | sort -u | wc\
    \ -l)\n        # Check if the number of unique characters\n        #   is greater\
    \ than the maximum number of unique characters found\n        if [ $num_unique\
    \ -gt $max ]; then\n            max=$num_unique\n            max_idx=$i\n    \
    \    # Check if the number of unique characters\n        #   is the same as the\
    \ maximum number of unique characters found\n        elif [ $num_unique -eq $max\
    \ ]; then\n            # Get the string index with max number of unique characters\n\
    \            prev_max_idx=$max_idx\n            # Compute the lexicographical\
    \ order of the two strings\n            lexicographic_order=$(echo $@ | sed 's/\\\
    (.\\)/\\1\\n/g' | sort -u | tr -d ' ' |\n                                  awk\
    \ '{if ($1>$2) print $1\" is greater\"; else print $2\" is greater\"}')\n    \
    \        # Check which comes first in lexicographical order\n            if [\
    \ \"$lexicographic_order\" == \"${@:i:1} is greater\" ]; then\n              \
    \  max_idx=$i\n            fi\n        fi\n    done\n    # Print the string with\
    \ maximum number of unique characters\n    echo ${@:max_idx:1}", "    local word\n\
    \    local longest=0\n    local longest_word\n    # delete duplicates\n    local\
    \ dict=$(echo \"$1\" | sed -e 's/ /\\n/g' | sort -u)\n    for word in $dict; do\n\
    \        local len=$(echo -n \"$word\" | tr -dc 'a-zA-Z0-9' | wc -c)\n       \
    \ # echo -n \"$word\" | tr -dc 'a-zA-Z0-9'\n        # echo $len\n        if [[\
    \ $len -gt $longest ]]; then\n            longest=$len\n            longest_word=$word\n\
    \        fi\n    done\n    echo $longest_word", "  # Check if empty string\n \
    \ if [ -z \"$1\" ]; then\n    echo \"Input string is empty!\"\n    return\n  fi\n\
    \n  # Convert input to array\n  IFS=' ' read -r -a words <<< \"$1\"\n\n  # Create\
    \ empty words array\n  words_map=()\n\n  # Initialize max value\n  max=0\n\n \
    \ # Traverse input array\n  for word in \"${words[@]}\"; do\n    # Convert word\
    \ to array\n    IFS='' read -r -a word_arr <<< \"$word\"\n\n    # Create empty\
    \ characters array\n    chars=()\n\n    # Traverse the word\n    for (( i=0; i<${#word_arr[@]};\
    \ i++ )); do\n      # Check if char already exists in chars array\n      if [[\
    \ \" ${chars[@]} \" =~ \" ${word_arr[$i]} \" ]]; then\n        # Do nothing\n\
    \        :\n      else\n        # Append to array\n        chars+=(\"${word_arr[$i]}\"\
    )\n      fi\n    done\n\n    # Store the length of chars array in words array\n\
    \    words_map+=(\"${#chars[@]}\")\n  done\n\n  # Traverse the words array\n \
    \ for (( i=0; i<${#words_map[@]}; i++ )); do\n    # Check if length of chars array\
    \ is greater than max\n    if [ ${words_map[$i]} -gt $max ]; then\n      # Update\
    \ max\n      max=${words_map[$i]}\n    fi\n  done\n\n  # Traverse the words array\n\
    \  for (( i=0; i<${#words_map[@]}; i++ )); do\n    # Check if max equals the length\
    \ of chars array\n    if [ $max -eq ${words_map[$i]} ]; then\n      # Print the\
    \ word\n      echo \"${words[$i]}\"\n      return\n    fi\n  done", "    local\
    \ max_word\n    local max_char\n    local word\n\n    for word in $1; do\n   \
    \     local unique_char=$(echo \"$word\" | grep -o - | sort | uniq | wc -l)\n\
    \        if [ -z \"$max_char\" ] || [ \"$unique_char\" -gt \"$max_char\" ]; then\n\
    \            max_char=$unique_char\n            max_word=$word\n        fi\n \
    \   done\n\n    echo \"$max_word\"", '  # TODO: write your solution in this function
    body', "  # local declare variables so they are not exported out\n  local max_length=0\n\
    \  local max_item\n  local cur_length\n  local cur_item\n  # Read all the inputs\
    \ separated by spaces\n  for cur_item in $@; do\n    # Find length of unique characters\
    \ in cur_item\n    cur_length=$(echo $cur_item | grep -o . | sort | uniq | wc\
    \ -l)\n    # If cur_length greater than max_length, set max_length\n    # to cur_length\
    \ and set max_item to cur_item\n    if [ $cur_length -gt $max_length ]; then\n\
    \      max_length=$cur_length\n      max_item=$cur_item\n    # If cur_length is\
    \ same as max_length, compare the two items\n    # using the lexicographical order\n\
    \    elif [ $cur_length -eq $max_length ]; then\n      # Note: awk is used here\
    \ to avoid the if clause in bash\n      # if [[ \"$cur_item\" < \"$max_item\"\
    \ ]]; then\n      if [ $(echo $cur_item $max_item | awk '{ print ($1 < $2) }')\
    \ ]; then\n        max_item=$cur_item\n      fi\n    fi\n  done\n  # Finally,\
    \ print the max_item\n  echo $max_item", "    for w in $1; do\n        # sort:\
    \ sort characters in a string\n        # uniq: unique characters\n        #\n\
    \        # x = number of unique characters\n        x=$(echo $w | grep -o . |\
    \ sort | uniq | wc -l)\n        # array = [word, number of unique characters]\n\
    \        array+=(\"$w $x\")\n    done\n    # sort -n: sort numbers in ascending\
    \ order\n    # sort -k: sort by the first key\n    # sort -r: sort in reverse\n\
    \    max=$(printf \"%s\\n\" \"${array[@]}\" | sort -n -k2 -r | head -n 1)\n  \
    \  echo \"${max/ *}\"", "    # $1 is a space-separated list\n    # list is made\
    \ of words separated by spaces\n    # each word is made of characters\n    # ex:\
    \ \"string of words\" is a list of 3 words:\n    # - string\n    # - of\n    #\
    \ - words\n    # ex: \"enam\" is a list of 1 word:\n    # - enam\n    #\n    #\
    \ the unique characters are the ones that appears only once in a word\n    # ex:\
    \ the unique characters of \"enam\" are:\n    # - e\n    # - n\n    # - a\n  \
    \  # - m\n    # ex: the unique characters of \"name\" are:\n    # - n\n    # -\
    \ a\n    # - m\n    # - e\n    # ex: the unique characters of \"string\" are:\n\
    \    # - s\n    # - t\n    # - r\n    # - i\n    # - n\n    # - g\n    #\n   \
    \ # write a function that counts the number of unique characters of a word\n \
    \   count_unique_characters() {\n        # $1 is a word\n        # counts the\
    \ unique characters of a word\n        echo \"$1\" | sed -e 's/\\(.\\)/\\1\\n/g'\
    \ | sort | uniq | wc -l\n    }\n    # $1 is a space-separated list\n    # split\
    \ list in words\n    words=\"$1\"\n    # get max number of unique characters\n\
    \    max=$(echo \"$words\" | sed -e 's/\\([^ ]*\\)/'\"$(count_unique_characters\
    \ '\\1')\"'/g' | sort -g | tail -n 1)\n    # $1 is a space-separated list\n  \
    \  # find the word with max number of unique characters\n    echo \"$words\" |\
    \ sed -e 's/\\([^ ]*\\)/'\"$(count_unique_characters '\\1')\"' \\1/g' | sort -g\
    \ | tail -n 1 | sed -e 's/[0-9]* //'", "\tmaxlen=0\n\tmaxword=\"\"\n\tfor word\
    \ in $1; do\n\t\techo $word | grep -q -v '[^a-zA-Z]'\n\t\tif [ $? -eq 0 ]; then\n\
    \t\t\tlen=$(echo -n $word | sed 's/[^ ]//g' | wc -m)\n\t\t\techo -n \"word=$word\
    \ len=$len maxlen=$maxlen maxword=$maxword\"\n\t\t\tif [ $len -gt $maxlen ]; then\n\
    \t\t\t\tmaxlen=$len\n\t\t\t\tmaxword=$word\n\t\t\t\techo \" selected\"\n\t\t\t\
    else\n\t\t\t\techo \"\"\n\t\t\tfi\n\t\tfi\n\tdone\n\techo $maxword", "    word_list=$1\n\
    \    max_len=0\n    for word in $word_list; do\n        len=$(echo $word | grep\
    \ -o . | sort | uniq | wc -l)\n        if [[ $len -gt $max_len ]]; then\n    \
    \        max_len=$len\n            max_word=$word\n        fi\n    done\n    echo\
    \ $max_word", "    local max_word=\"\"\n    local max_chars=\"\"\n    local max_len=0\n\
    \    local word=\"\"\n    local len=0\n    local chars=\"\"\n    for word in $1;\
    \ do\n        chars=$(echo \"$word\" | grep -o '.' | sort -u | tr -d '\\n')\n\
    \        len=${#chars}\n        if [[ $len -gt $max_len ]]; then\n           \
    \ max_word=$word\n            max_chars=$chars\n            max_len=$len\n   \
    \     fi\n    done\n    echo \"$max_word\"", "    # Loop over list of strings,\
    \ compute the number of distinct characters\n    # and store that in an array\
    \ of integers\n    # Also, maintain an array of strings (same index as the array\
    \ of\n    # integers)\n    # Finally, find the index of the max in the array of\
    \ integers\n    # and print the corresponding string\n    local n=$#\n    local\
    \ ndistinct=()\n    local word=()\n    local max_ndistinct=0\n    local max_word=\n\
    \    local i=0\n    for str in \"$@\"; do\n        ndistinct[$i]=$(echo \"$str\"\
    \ | grep -o . | sort | uniq | wc -l)\n        word[$i]=\"$str\"\n        if [[\
    \ ${ndistinct[$i]} -gt $max_ndistinct ]]; then\n            max_ndistinct=${ndistinct[$i]}\n\
    \            max_word=\"${word[$i]}\"\n        fi\n        i=$((i+1))\n    done\n\
    \    echo \"$max_word\"", "    echo \"$1\" | tr ' ' '\\n' |\n    awk 'BEGIN {\
    \ FS=\"\"; max = 0 }\n         {\n             if (length > max) {\n         \
    \        max = length;\n                 res = $0;\n             }\n         }\n\
    \         END { print res }'", "  local s\n  declare -i max_len max_i i=0\n  while\
    \ read s; do\n    if [[ $s =~ ^(.).*\\1$ ]]; then\n      continue  # Skip strings\
    \ with duplicate characters.\n    fi\n    # Calculate length, e.g. \"abc\" =>\
    \ 3\n    (($(tr -d -c [:alnum:] <<<\"$s\" | wc -c) > max_len)) \\\n      && max_len=$(tr\
    \ -d -c [:alnum:] <<<\"$s\" | wc -c) && max_i=$i\n    ((i++))\n  done <<<\"$1\"\
    \n  echo \"${1%% *}\" | cut -d ' ' -f $(($max_i + 1))", "    echo \"$1\" | tr\
    \ ' ' '\\n' | sort -u | awk '{\n        match($0, \"\")\n        printf \"%s %d\\\
    n\", $0, RLENGTH-1\n    }' | sort -k2,2nr | head -n1 | cut -d ' ' -f1", "    max_cnt=0\n\
    \    max_str=\"\"\n    for i in ${1}\n    do\n        tmp=${i//[^$i]}\n      \
    \  if [ ${#tmp} -gt ${max_cnt} ]\n        then\n            max_cnt=${#tmp}\n\
    \            max_str=${i}\n        fi\n    done\n    echo ${max_str}", "\tmax_unique_chars=0\n\
    \tlongest_word=\"\"\n\t# Remove any leading spaces\n\tlocal trimmed_string=\"\
    ${1#\"${1%%[![:space:]]*}\"}\"\n\tfor word in $trimmed_string; do\n\t\tif [[ ${#word}\
    \ -gt $max_unique_chars ]]; then\n\t\t\tmax_unique_chars=${#word}\n\t\t\tlongest_word=$word\n\
    \t\telif [[ ${#word} -eq $max_unique_chars ]]; then\n\t\t\tif [[ $word < $longest_word\
    \ ]]; then\n\t\t\t\tlongest_word=$word\n\t\t\tfi\n\t\tfi\n\tdone\n\techo $longest_word",
  "\tlocal max=\"\"\n\tlocal max_count=0\n\tlocal word=\"\"\n\tlocal count=0\n\tfor\
    \ word in $1; do\n\t\tcount=$(echo $word | fold -w1 | sort | uniq | wc -l)\n\t\
    \tif [ $count -gt $max_count ]; then\n\t\t\tmax_count=$count\n\t\t\tmax=$word\n\
    \t\tfi\n\tdone\n\techo $max", "\tmax_word=''\n\tmax_chars=0\n\tmin_lex=''\n\t\
    for word in $1; do\n\t\tchars=\"$(echo -n $word | sed -e 's/\\(.\\)/\\1\\n/g'\
    \ | sort | uniq | wc -l)\"\n\t\tif [ $chars -gt $max_chars ]; then\n\t\t\tmax_chars=$chars\n\
    \t\t\tmax_word=$word\n\t\t\tmin_lex=$word\n\t\telif [ $chars -eq $max_chars ];\
    \ then\n\t\t\t[[ $word < $min_lex ]] && min_lex=$word\n\t\tfi\n\tdone\n\techo\
    \ $min_lex", "  echo $1 | awk '{\n    for (i=1; i<=NF; i++) {\n      for (j=1;\
    \ j<=length($i); j++) {\n        letter = substr($i, j, 1)\n        if (!dict[letter])\
    \ {\n          dict[letter] = 1\n        } else {\n          dict[letter]++\n\
    \        }\n      }\n      if (max == 0 || length(dict) > max) {\n        max\
    \ = length(dict)\n        word = $i\n      }\n      delete dict\n    }\n    print\
    \ word\n  }'", "\tmax_unique=0\n\tmax_word=\"\"\n\tfor word in $1; do\n\t\tnum_unique=$(echo\
    \ $word | tr -cd \"[[:alnum:]]\" | wc -c)\n\t\tif [[ $num_unique -gt $max_unique\
    \ ]]; then\n\t\t\tmax_unique=$num_unique\n\t\t\tmax_word=$word\n\t\tfi\n\tdone\n\
    \techo $max_word", "    max_word=\n    max_word_len=0\n    for word in $1; do\n\
    \        word_len=${#word}\n        if [ $word_len -gt $max_word_len ]; then\n\
    \            max_word_len=$word_len\n            max_word=$word\n        fi\n\
    \    done\n    echo $max_word", '    :', "    # set the internal field separator\
    \ (IFS) to space to use as delimiter for for loop\n    OLDIFS=$IFS\n    IFS=\"\
    \ \"\n    # read the arguments into an array\n    words=($1)\n    # set IFS back\
    \ to what it was\n    IFS=$OLDIFS\n    # declare variables\n    max_length=0\n\
    \    max_index=0\n    # iterate over the array of words\n    for (( i=0; i<${#words[@]};\
    \ i++ )); do\n        # get the length of unique characters in the current word,\n\
    \        # putting the result in ${words[$i]}_length to avoid overwriting ${words[$i]}\n\
    \        eval \"${words[$i]}_length=${#(M)$(echo ${words[$i]} | fold -w1 | sort\
    \ -u | tr -d \"\\n\")}\"\n        # compare the unique character length of the\
    \ current word with the current max\n        if (( ${words[$i]}_length > max_length\
    \ )); then\n            # update the max length with the current word's length\n\
    \            max_length=${words[$i]}_length\n            # save the index of the\
    \ word with the max length\n            max_index=$i\n        # if the current\
    \ word's length equals the max length\n        elif (( ${words[$i]}_length ==\
    \ max_length )); then\n            # compare the current word and the word with\
    \ the max length and determine which comes first in lexicographical order\n  \
    \          if [[ ${words[$i]} < ${words[$max_index]} ]]; then\n              \
    \  # save the index of the word that comes first in lexicographical order\n  \
    \              max_index=$i\n            fi\n        fi\n    done\n    # print\
    \ the word with the max length\n    echo ${words[$max_index]}", "  for x in $1\n\
    \  do\n    echo \"$x $(echo $x | sed -e 's/\\(.\\)/\\1\\n/g' | sort | uniq | wc\
    \ -l)\"\n  done | sort -k2,2 -k1,1 -n | tail -1 | cut -d ' ' -f 1", "  for word\
    \ in $1; do\n    unique_letters=$(echo $word | fold -w1 | sort | uniq | wc -w)\n\
    \    if [[ -z $max_word || $unique_letters -gt $max_unique_letters ]]; then\n\
    \      max_word=$word\n      max_unique_letters=$unique_letters\n    fi\n  done\n\
    \  echo $max_word", "    # Write your solution here\n    # Convert the input string\
    \ to an array using space as the delimiter\n    IFS=\" \" read -r -a arr <<< \"\
    $1\"\n    # Iterate through the list to find the string with maximum number of\n\
    \    # unique characters\n    max_count=0\n    max_item=\"\"\n    for item in\
    \ \"${arr[@]}\"; do\n        count=$(echo -n \"$item\" | fold -w1 | sort -u |\
    \ wc -l)\n        if [ \"$count\" -gt \"$max_count\" ]; then\n            max_count=$count\n\
    \            max_item=$item\n        fi\n    done\n    echo \"$max_item\"", " \
    \ target=$1\n  max=0\n  # magic sauce\n  for word in $target; do\n    unique_count=`echo\
    \ $word | fold -w1 | sort | uniq | wc -l`\n    if [[ $unique_count -gt $max ]];\
    \ then\n      max=$unique_count\n      max_word=$word\n    fi\n  done\n  echo\
    \ $max_word", "  result=\"\"\n  num=\"\"\n  for word in $@; do\n    count=$(printf\
    \ \"%s\" \"$word\" | fold -w1 | sort -u | wc -l)\n    if [ -z \"$num\" ] || [\
    \ \"$count\" -gt \"$num\" ]; then\n      result=\"$word\"\n      num=\"$count\"\
    \n    fi\n  done\n  printf \"%s\" \"$result\"", "  # YOUR CODE HERE\n  if [ $#\
    \ -ne 1 ]; then\n    echo \"Must supply a single string of words as a parameter\"\
    \n    return\n  fi\n  current_max_word=\"\"\n  current_max_count=0\n  for word\
    \ in $1; do\n    current_count=$(echo $word | grep -o . | sort | uniq | wc -l)\n\
    \    if [ $current_count -gt $current_max_count ]; then\n      current_max_count=$current_count\n\
    \      current_max_word=$word\n    fi\n  done\n  echo $current_max_word", "  local\
    \ arg=\"$1\"\n  local sorted=$(echo \"$arg\" | tr ' ' '\\n' | sort -f)\n  local\
    \ max_word=''\n  local max_len=0\n  for word in $sorted; do\n    local len=$(echo\
    \ -n \"$word\" | grep -o . | sort -u | tr -d '\\n' | wc -c)\n    if [[ $len -gt\
    \ $max_len ]]; then\n      max_len=$len\n      max_word=$word\n    fi\n  done\n\
    \  echo \"$max_word\"", "  local count=0 max=\"\" word=\"\" word_count=0\n  for\
    \ word in $1; do\n    word_count=$(echo $word | grep -o . | sort | uniq | wc -l)\n\
    \    if [[ $word_count -gt $count ]]; then\n      count=$word_count\n      max=$word\n\
    \    fi\n  done\n  echo $max", "\t# Create an associative array mapping each word\
    \ to a count of its unique\n\t# characters.\n\tdeclare -A words\n\tfor word in\
    \ $@; do\n\t\twords[$word]=$(echo \"$word\" | grep -o - | wc -l)\n\tdone\n\n\t\
    # Find the word with the largest count of unique characters.\n\tmax_word=\n\t\
    max_count=0\n\tfor word in ${!words[@]}; do\n\t\tcount=${words[$word]}\n\t\tif\
    \ [[ -z $max_word || $count -gt $max_count ]]; then\n\t\t\tmax_word=$word\n\t\t\
    \tmax_count=$count\n\t\telif [[ $count -eq $max_count ]]; then\n\t\t\t# Break\
    \ ties by choosing the earlier word.\n\t\t\tif [[ $word < $max_word ]]; then\n\
    \t\t\t\tmax_word=$word\n\t\t\tfi\n\t\tfi\n\tdone\n\n\techo $max_word", "    max=0\n\
    \    word=\n    for test in $1; do\n        uniques=$(echo $test | fold -w1 |\
    \ sort | uniq -c | wc -l)\n        if [ $uniques -gt $max ]; then\n          \
    \  max=$uniques\n            word=$test\n        fi\n    done\n    echo $word",
  "    local max_string=\"\"\n    local max_string_len=0\n    local max_string_last_char=\"\
    \"\n    local current_string=\"\"\n    local current_string_len=0\n    local current_string_first_char=\"\
    \"\n    local current_string_last_char=\"\"\n    for current_string in $1; do\n\
    \        current_string_len=$(echo -n \"$current_string\" | tr -cd \"[:alpha:]\"\
    \ | wc -c)\n        if [ \"$current_string_len\" -gt \"$max_string_len\" ]; then\n\
    \            max_string=\"$current_string\"\n            max_string_len=\"$current_string_len\"\
    \n            max_string_last_char=$(echo -n \"$current_string\" | tail -c 1)\n\
    \        elif [ \"$current_string_len\" -eq \"$max_string_len\" ]; then\n    \
    \        current_string_first_char=$(echo -n \"$current_string\" | head -c 1)\n\
    \            if [ \"$current_string_first_char\" \\< \"$max_string_last_char\"\
    \ ]; then\n                max_string=\"$current_string\"\n                max_string_len=\"\
    $current_string_len\"\n                max_string_last_char=$(echo -n \"$current_string\"\
    \ | tail -c 1)\n            fi\n        fi\n    done\n    echo \"$max_string\"",
  "  min=0\n  word=\"\"\n  for i in $1; do\n    len=${#i}\n    uchars=$(echo $i |\
    \ grep -o . | sort | uniq | tr -d \"\\n\")\n    uchars_len=${#uchars}\n    if\
    \ [[ $uchars_len -gt $min ]]; then\n      min=$uchars_len\n      word=$i\n   \
    \ elif [[ $uchars_len -eq $min ]]; then\n      if [[ $i < $word ]]; then\n   \
    \     word=$i\n      fi\n    fi\n  done\n  echo $word", "  if [ -z \"$1\" ]; then\n\
    \    return\n  fi\n  echo $1 | tr ' ' '\\n' | sort -nr | uniq -c | sort -n | head\
    \ -n 1 | tail -c +2", '  # TODO: Place your code here', "  echo $1 | tr ' ' '\\\
    n' | awk '{print length($0)\" \"length(gensub(/(.).*\\1/, \"\", \"g\", $0))}'\
    \ | sort -k2 -rn | head -1 | awk '{print $1}'", "    # create an associative array\n\
    \    declare -A array\n    # for each word in $1\n    for i in $1; do\n      \
    \  # we're going to create a key for it in the associative array\n        # and\
    \ we're going to put the number of unique characters in the\n        # value for\
    \ this key\n        #\n        # here's the command we'll run:\n        #\n  \
    \      # echo $i | grep -o . | sort | uniq | wc -l\n        #\n        # this\
    \ will count the number of unique characters in $i\n        #\n        # now run\
    \ the command and put the result in an associative array\n        array[$i]=$(echo\
    \ $i | grep -o . | sort | uniq | wc -l)\n    done\n    # now we've got an associative\
    \ array that looks like this:\n    #\n    # {\n    #     word1: 3\n    #     word2:\
    \ 4\n    #     word3: 1\n    # }\n    #\n    # we now need to find the maximum\
    \ value\n    #\n    # the for loop (below) loops through the values in the array\n\
    \    for i in ${array[@]}; do\n        # if the value for the key is bigger than\
    \ $max\n        if [ $i -gt $max ]; then\n            # we replace $max with the\
    \ new value\n            max=$i\n        fi\n    done\n    # $max contains the\
    \ number of unique characters in the word with the\n    # most unique characters\n\
    \    #\n    # now we've got to find out what word that is\n    #\n    # the for\
    \ loop (below) loops through the keys in the array\n    for i in ${!array[@]};\
    \ do\n        # if the value for the key is equal to $max\n        if [ ${array[$i]}\
    \ -eq $max ]; then\n            # we print the key and quit.\n            echo\
    \ $i\n            exit\n        fi\n    done", "   # FIXME\n   s=($1)\n   max=0\n\
    \   for i in \"${s[@]}\"; do\n      len=$(echo $i | wc -c)\n      if [ $len -gt\
    \ $max ]; then\n         max=$len\n         maxString=$i\n      fi\n   done\n\
    \   echo $maxString", "  IFS=$' ' read -ra array <<< \"$1\"\n  local -i i=0 j=0\
    \ jMax=0 indexMax=0\n  while [[ $i -lt ${#array[@]} ]]; do\n    (( j = 0 ))\n\
    \    local uniqueCharacters=\"\"\n    while [[ $j -lt ${#array[$i]} ]]; do\n \
    \     char=${array[$i]:$j:1}\n      if [[ ! $uniqueCharacters =~ $char ]]; then\n\
    \        uniqueCharacters=\"$uniqueCharacters$char\"\n      fi\n      (( j +=\
    \ 1 ))\n    done\n    (( j = ${#uniqueCharacters} ))\n    if [[ $j -gt $jMax ]];\
    \ then\n      (( jMax = j ))\n      (( indexMax = i ))\n    fi\n    (( i += 1\
    \ ))\n  done\n  echo \"${array[$indexMax]}\"", "    # Generate word-length mapping\
    \ (key: value) for each word in $1\n    # --> \"string:6\"\n    # --> \"name:4\"\
    \n    #\n    # -o: output\n    # 's/.*/&:$(echo $& | tr -dc [[:alnum:]] | uniq\
    \ | wc -c)/': select all strings,\n    #                                     \
    \                      output string + number of unique characters\n    # -n:\
    \ disable auto-printing\n    # 's/.*/&:&/': select all strings, output string\
    \ twice\n    # 'sort -t: -nk2': sort output strings by the number of unique characters\
    \ (numeric k2)\n    # 'tail -n1': select last string\n    for line in $(echo $1\
    \ | tr ' ' '\\n' | sed -o 's/.*/&:$(echo $& | tr -dc [[:alnum:]] | uniq | wc -c)/'\
    \ -n 's/.*/&:&/' | sort -t: -nk2 | tail -n1); do\n        word=${line%%:*}\n \
    \       number=${line##*:}\n        echo $word\n    done", "\t# Write your code\
    \ here\n\tfor i in $1\n\tdo\n\t\tif [ $i -gt $max ]\n\t\tthen\n\t\t\tmax=$i\n\t\
    \tfi\n\tdone\n\techo $max", "\t# split $1 into list of strings\n\tlocal strings=\"\
    $1\"\n\t# variables to hold the current max string, number of unique characters\n\
    \t# in current max string\n\tlocal current_max_string=\"\"\n\tlocal current_max_string_unique_char_count=0\n\
    \t# for each string in the list\n\tfor s in $strings; do\n\t\t# number of unique\
    \ characters in current string\n\t\tcurrent_string_unique_char_count=$(echo $s\
    \ | sed -e 's/\\(.\\)/\\1\\n/g' | sort | uniq | wc -l)\n\t\t# update max string\
    \ and corresponding unique char count\n\t\tif [ $current_string_unique_char_count\
    \ -gt $current_max_string_unique_char_count ]; then\n\t\t\tcurrent_max_string=$s\n\
    \t\t\tcurrent_max_string_unique_char_count=$current_string_unique_char_count\n\
    \t\t# if there is a tie, return the earlier string\n\t\telif [ $current_string_unique_char_count\
    \ -eq $current_max_string_unique_char_count ]; then\n\t\t\tif [ $s < $current_max_string\
    \ ]; then\n\t\t\t\tcurrent_max_string=$s\n\t\t\t\tcurrent_max_string_unique_char_count=$current_string_unique_char_count\n\
    \t\t\tfi\n\t\tfi\n\tdone\n\t# return the max string with corresponding unique\
    \ char count\n\techo \"$current_max_string\"", "    local max_len=0 max_word=''\n\
    \    for word in $1; do\n        local len=0\n        for ((i=0; i<${#word}; i++));\
    \ do\n            if [[ \"${word:i:1}\" != *[A-Za-z]* ]]; then\n             \
    \   continue\n            fi\n            if [[ ${word:i:1} != *[${word:0:i}]*\
    \ ]]; then\n                len=$((len+1))\n            fi\n        done\n   \
    \     if [[ $len -gt $max_len ]]; then\n            max_len=$len\n           \
    \ max_word=$word\n        fi\n    done\n    echo $max_word", "  local temp i max_index\
    \ max_uniq_count max_word\n  local -a arr\n  mapfile -t arr < <(echo $1)\n  for\
    \ ((i=0; i<${#arr[@]}; i++)); do\n    temp=$(echo ${arr[$i]} | grep -o . | sort\
    \ | uniq | tr -d '\\n')\n    temp=${#temp}\n    if [[ -z $max_uniq_count || $temp\
    \ -gt $max_uniq_count ]]; then\n      max_uniq_count=$temp\n      max_index=$i\n\
    \    fi\n  done\n  echo ${arr[$max_index]}", "    echo \"$*\" | tr \" \" \"\\\
    n\" | {\n        local max_word=\"\"\n        local max_chars=0\n        local\
    \ max_word_tmp=\"\"\n        local max_chars_tmp=0\n        while read word; do\n\
    \            max_chars_tmp=$(echo \"$word\" | sed 's/\\(.\\)/\\1\\n/g' | sort\
    \ | uniq | wc -l)\n            if [ $max_chars_tmp -gt $max_chars ]; then\n  \
    \              max_chars=$max_chars_tmp\n                max_word=$word\n    \
    \        fi\n        done\n        echo \"$max_word\"\n    }", "    local input=($1)\n\
    \    local length=${#input[@]}\n    local i j k\n    local curr max max_index=0\n\
    \    local curr_word=\"\"\n    local max_word=\"\"\n    for((i=0; i<length; i++));\
    \ do\n        curr_word=${input[$i]}\n        curr=0\n        for((j=0; j<${#curr_word};\
    \ j++)); do\n            for((k=0; k<curr; k++)); do\n                if [[ ${curr_word:$j:1}\
    \ == ${unique_letters:$k:1} ]]; then\n                    break\n            \
    \    fi\n            done\n            if [[ $k == $curr ]]; then\n          \
    \      unique_letters+=${curr_word:$j:1}\n                ((++curr))\n       \
    \     fi\n        done\n        if [[ $curr -gt $max ]]; then\n            max=$curr\n\
    \            max_index=$i\n        fi\n        unique_letters=\"\"\n    done\n\
    \    max_word=${input[$max_index]}\n    echo $max_word", "  for i in $1; do\n\
    \    echo \"$(echo $i | tr -cd [:alpha:] | tr -d '[:space:]' | grep -o . | sort\
    \ | uniq | wc -l) $i\"\n  done | sort -nr | head -1 | awk '{print $2}'", "   \
    \ echo \"$1\" | tr ' ' '\\n' |\n    awk '\n    {\n        chars[length($0)] =\
    \ chars[length($0)] $0\n    }\n    END {\n        n = asort(chars)\n        nmax\
    \ = n\n        for (i = n; i > 0; i--) {\n            if (length(chars[i]) > 1)\
    \ {\n                split(chars[i], list, \" \")\n                asort(list)\n\
    \                print list[1]\n                exit\n            }\n        }\n\
    \        print chars[nmax]\n    }\n    '", "  local most=0\n  local result=\"\"\
    \n  local length\n  local word\n  for word in $1; do\n    length=$(echo $word\
    \ | awk '{ print length; }')\n    unique=$(echo $word | awk '{ print length($0);\
    \ }')\n    if [ $unique -gt $most ]; then\n      most=$unique\n      result=$word\n\
    \    elif [ $unique -eq $most ]; then\n      if [ $word \\< $result ]; then\n\
    \        result=$word\n      fi\n    fi\n  done\n  echo $result", "\tlocal max_word=\n\
    \tlocal max_num=0\n\tlocal word=\n\tfor word in $1; do\n\t\tnum=$(echo \"$word\"\
    \ | awk '{ for (i=1; i<=length; i++) if (substr($0, i, 1) == substr($0, i+1, 1))\
    \ next; print i }')\n\t\tif [[ $num -gt $max_num ]]; then\n\t\t\tmax_num=$num\n\
    \t\t\tmax_word=$word\n\t\tfi\n\tdone\n\techo $max_word", "    max_word=\"\"\n\
    \    max_unique=0\n    for i in $@; do\n        unique=$(echo $i | fold -w1 |\
    \ sort | uniq | wc -l)\n        if [ $unique -gt $max_unique ]; then\n       \
    \     max_unique=$unique\n            max_word=$i\n        fi\n    done\n    echo\
    \ $max_word", "    local word=$1\n    local word_max=\n    local max=0\n    local\
    \ -i curr\n    for word in $word; do\n        curr=$(echo $word | grep -o . |\
    \ sort | uniq | wc -c)\n        ((curr>max)) && { max=$curr; word_max=$word; }\n\
    \    done\n    echo $word_max", "  if [ $# -ne 1 ]; then\n    return 1\n  fi\n\
    \  for w in $1; do\n    echo $w $(echo $w | grep -o . | sort | uniq | wc -c)\n\
    \  done | sort -k2 -nr | awk '!a[$1]++' | awk '{print $1}' | head -n 1", "   \
    \ # First, get the list of strings\n    words=$1\n    # Then, process each word,\
    \ one by one\n    for word in $words; do\n        word_count=$(echo $word | grep\
    \ -o . | sort | uniq | wc -l)\n        if [[ $word_count -gt $max_count ]]; then\n\
    \            max_count=$word_count\n            max_word=$word\n        fi\n \
    \   done\n    echo $max_word", "    if [ $# -eq 0 ]; then\n        return\n  \
    \  fi\n    max_chars=$(echo $1 | wc -m)\n    max_word=$1\n    for word in $*;\
    \ do\n        word_chars=$(echo $word | wc -m)\n        if [ $word_chars -gt $max_chars\
    \ ]; then\n            max_chars=$word_chars\n            max_word=$word\n   \
    \     fi\n    done\n    echo $max_word", "\techo \"$@\" | tr \" \" \"\\n\" | awk\
    \ '{print length($0), $0}' | sort -n -r | awk '{if (length($0) == length($2))\
    \ print $2}' | head -n 1", "  local len\n  for str in $1; do\n    local count=$(echo\
    \ $str | sed 's/\\(.\\)/\\1\\n/g' | sort | uniq | wc -l)\n    if [[ $count -gt\
    \ $len ]]; then\n      len=$count\n      echo $str\n    fi\n  done", "\t## Write\
    \ your code below\n\tmax=0\n\tn=0\n\tfor word in $1\n\tdo\n\t\ttmp=0\n\t\tfor\
    \ (( i=0; i<${#word}; i++ )); do\n\t\t\tchar=${word:$i:1}\n\t\t\tif [[ ! ${uniq[*]}\
    \ =~ $char ]]; then\n\t\t\t\tuniq[$tmp]=$char\n\t\t\t\t((tmp++))\n\t\t\tfi\n\t\
    \tdone\n\t\tif [[ $tmp -gt $max ]]; then\n\t\t\tmax=$tmp\n\t\t\tmax_w=$word\n\t\
    \t\tmax_n=$n\n\t\telif [[ $tmp -eq $max ]]; then\n\t\t\tif [[ $word < ${word[$max_n]}\
    \ ]]; then\n\t\t\t\tmax_w=$word\n\t\t\t\tmax_n=$n\n\t\t\tfi\n\t\tfi\n\t\tunset\
    \ uniq\n\t\t((n++))\n\tdone\n\techo $max_w", "\tmax_len=0\n\tmax_el=\"\"\n\tfor\
    \ word in $1; do\n\t\tlen=${#word}\n\t\tif [ $len -gt $max_len ]; then\n\t\t\t\
    max_len=$len\n\t\t\tmax_el=$word\n\t\tfi\n\tdone\n\techo $max_el", "  max=\"\"\
    \n  while read word; do\n    if [[ -z $max ]]; then\n      max=$word\n    elif\
    \ [[ \"${#word}\" -gt \"${#max}\" ]]; then\n      max=$word\n    fi\n  done <<<\
    \ \"$1\"\n  echo \"$max\"", "    local max_count=0\n    local res=\"\"\n    for\
    \ word in $1; do\n        unique_count=0\n        for (( i=0; i<${#word}; i++\
    \ )); do\n            [[ ! $word =~ ${word:$i:1} ]] && let unique_count++\n  \
    \      done\n        if [[ $unique_count -gt $max_count ]]; then\n           \
    \ max_count=$unique_count\n            res=$word\n        fi\n    done\n    echo\
    \ $res", "    set -f\n    # get the word with the maximum number of unique characters\n\
    \    echo \"$1\" | awk 'BEGIN {max=0; i=1}\n    {\n        # $i is a word\n  \
    \      for (j=1; j<=length($i); j++) {\n            # $j is a character in $i\n\
    \            if (!a[$j]++) {\n                b[i]++\n            }\n        }\n\
    \        if (b[i] > max) {\n            max = b[i]\n            pos = i\n    \
    \    }\n        i++\n    }\n    END {print $pos}'\n    set +f", "\tlocal max_len=0\
    \ max_word\n\tfor word in $1; do\n\t\tlocal len=$(echo $word | awk '{for(i=1;i<=length;i++)seen[substr($0,i,1)]++}END{print\
    \ length(seen)}')\n\t\t[ $len -gt $max_len ] && max_len=$len && max_word=$word\n\
    \tdone\n\techo $max_word", "    max_characters=0\n    max_index=0\n    index=0\n\
    \    for word in $1; do\n        set -- $word\n        # If we have multiple strings\
    \ with maximum number of unique\n        # characters, return the one which comes\
    \ first in lexicographical\n        # order.\n        if [ $(( $(echo $1 | grep\
    \ -o . | sort | uniq | wc -l) )) -gt \\\n            $max_characters ]; then\n\
    \            max_characters=$(( $(echo $1 | grep -o . | sort | uniq | wc -l) ))\n\
    \            max_index=$index\n        fi\n        index=$(( $index + 1 ))\n \
    \   done\n    index=0\n    for word in $1; do\n        if [ $index -eq $max_index\
    \ ]; then\n            echo $word\n        fi\n        index=$(( $index + 1 ))\n\
    \    done", "    #read the list of the word and store it in the $string\n    string=$1\n\
    \    # split the list into words using space as delimiter and store it in $array\n\
    \    array=($string)\n    # count the number of words in $array and store it in\
    \ $count\n    count=${#array[@]}\n    # this variable store the maximum unique\
    \ number of words\n    max_unique=0\n    # this variable store the maximum unique\
    \ words\n    max_unique_string=\"\"\n    # for loop to check if the number of\
    \ unique words is maximum\n    for i in \"${array[@]}\"\n    do\n        # this\
    \ variable stores the number of unique words in the $i string\n        no_unique=$(echo\
    \ $i | grep -o . | sort | uniq | wc -l)\n        # if the number of unique words\
    \ in $i is greater than the current maximum unique\n        # number, then replace\
    \ it\n        if [ $no_unique -gt $max_unique ]\n        then\n            max_unique=$no_unique\n\
    \            max_unique_string=$i\n        fi\n    done\n    # if the number of\
    \ unique words in $i is equal to the current maximum unique\n    # number, then\
    \ check the lexicographical order\n    if [ $max_unique -eq $no_unique ]\n   \
    \ then\n        if [ $max_unique_string \\> $i ]\n        then\n            max_unique_string=$i\n\
    \        fi\n    fi\n    # print the string with maximum unique words and return\
    \ 0\n    echo $max_unique_string\n    return 0", "\t# get the list of unique characters\
    \ from each word\n\t# sort it using cut, then get the highest value\n\t# and pass\
    \ it to awk\n\tawk '{\n\t\tif ($1 == max) {\n\t\t\tif ($0 < max_word) {\n\t\t\t\
    \tmax_word = $0\n\t\t\t}\n\t\t} else if ($1 > max) {\n\t\t\tmax = $1\n\t\t\tmax_word\
    \ = $0\n\t\t}\n\t} END {\n\t\tprint max_word\n\t}' <<< \"$(\n\tfor arg in $1;\
    \ do\n\t\tcut -d \"\" -f 1-$(tr -dc \"$arg\" | wc -c <<< \"$arg\") <<< \"$arg\"\
    \n\tdone | sort | uniq | wc -c\n\t)\"", "    # NOTE: this implementation is suboptimal\
    \ as it relies on uniq and sort\n    # tools. A better implementation would not\
    \ use any external tools.\n    local max_uniq_len=0\n    local max_uniq_str=\"\
    \"\n    local current_str=\"\"\n    for current_str in $1; do\n        local current_uniq_len=$(echo\
    \ \"$current_str\" | grep -o . | sort | uniq | wc -l)\n        # echo \"current_str=$current_str,\
    \ current_uniq_len=$current_uniq_len\"\n        if [ $current_uniq_len -gt $max_uniq_len\
    \ ]; then\n            max_uniq_len=$current_uniq_len\n            max_uniq_str=$current_str\n\
    \        fi\n    done\n    echo \"$max_uniq_str\""]
stop_tokens:
- "\n}"
