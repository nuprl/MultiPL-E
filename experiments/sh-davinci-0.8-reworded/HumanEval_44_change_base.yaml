name: HumanEval_44_change_base
language: sh
prompt: "#!/bin/bash\n# Change numerical base of input number x to base.\n# return\
  \ string representation after the conversion.\n# base numbers are less than 10.\n\
  # >>> $(change_base \"8\" \"3\")\n# \"22\"\n# >>> $(change_base \"8\" \"2\")\n#\
  \ \"1000\"\n# >>> $(change_base \"7\" \"2\")\n# \"111\"\n#\n# $1 is an integer\n\
  # $2 is an integer\nchange_base() {\n"
tests: "}\n\ncandidate() {\n    change_base \"$@\"\n}\n\nset -e\nrun_test() {\n  \
  \  [[ $(candidate \"8\" \"3\") = \"22\" ]]\n    [[ $(candidate \"9\" \"3\") = \"\
  100\" ]]\n    [[ $(candidate \"234\" \"2\") = \"11101010\" ]]\n    [[ $(candidate\
  \ \"16\" \"2\") = \"10000\" ]]\n    [[ $(candidate \"8\" \"2\") = \"1000\" ]]\n\
  \    [[ $(candidate \"7\" \"2\") = \"111\" ]]\n    [[ $(candidate \"2\" \"3\") =\
  \ \"2\" ]]\n    [[ $(candidate \"3\" \"4\") = \"3\" ]]\n    [[ $(candidate \"4\"\
  \ \"5\") = \"4\" ]]\n    [[ $(candidate \"5\" \"6\") = \"5\" ]]\n    [[ $(candidate\
  \ \"6\" \"7\") = \"6\" ]]\n    [[ $(candidate \"7\" \"8\") = \"7\" ]]\n}\n\nrun_test"
completions: ["    a=$1\n    b=$2\n    output=\"\"\n    while [ $a -gt 0 ]; do\n \
    \       rem=$((a % b))\n        a=$((a / b))\n        output=\"$rem$output\"\n\
    \    done\n    if [ -z \"$output\" ]; then\n        output=\"0\"\n    fi\n   \
    \ echo \"$output\"", "    # check base is a number less than 10.\n    if [ \"\
    $2\" -lt \"10\" ]; then\n        # set default divisor\n        divisor=$2\n \
    \       # set default quotient\n        quotient=0\n        # init output variable\n\
    \        output=\"\"\n        # iterate until quotient is 0\n        while [ \"\
    $quotient\" -ne \"0\" ]; do\n            # get new quotient and remainder by dividing\
    \ the current divisor.\n            quotient=$(expr \"$1\" / \"$divisor\")\n \
    \           remainder=$(expr \"$1\" % \"$divisor\")\n            # add quotient\
    \ to output\n            output=\"$remainder$output\"\n            # set new divisor\n\
    \            divisor=$quotient\n        done\n        # print output\n       \
    \ echo \"$output\"\n    else\n        echo \"base is not less than 10\"\n    fi",
  "\tpython3 -c \"print('{0:b}'.format($1).replace('1', '$2').replace('0', '$(($2-1))'))\"",
  "    local x=\"$1\"\n    local base=\"$2\"\n    local r\n    if (( x < base ));\
    \ then\n        echo \"$x\"\n    else\n        r=$(( x % base ))\n        change_base\
    \ $(( x / base )) $base\n        echo \"$r\"\n    fi", "    if [[ $1 == 0 ]];\
    \ then\n        echo 0\n        return\n    fi\n    local ret\n    local x=$1\n\
    \    local b=$2\n    local rest\n    local digits\n    rest=$((x % b))\n    digits=$(change_base\
    \ $((x / b)) $b)\n    ret=\"$digits$rest\"\n    echo $ret", "  local result=\"\
    \"\n  local x=\"$1\"\n  local base=\"$2\"\n  local remain=0\n  local temp_x=0\n\
    \  local i=0\n  local length=0\n  local index=0\n  local flag=0\n  local digit_map_table=(0\
    \ 1 2 3 4 5 6 7 8 9)\n  # TODO: define digit_map_table and assign value when base\
    \ is bigger than 10\n  while [ \"$x\" -gt 0 ]; do\n    if [ \"$x\" -lt \"$base\"\
    \ ]; then\n      result=\"${digit_map_table[$x]}$result\"\n      break\n    fi\n\
    \    remain=$((x % base))\n    temp_x=$((x / base))\n    result=\"${digit_map_table[$remain]}$result\"\
    \n    x=$temp_x\n  done\n  # TODO: add leading zeros in the result number\n  #\
    \ if the base is more than 10, add leading zeros to the result string.\n  #\n\
    \  # >>> $(change_base \"8\" \"11\")\n  # \"8\"\n  # >>> $(change_base \"8\" \"\
    16\")\n  # \"8\"\n  #\n  # >>> $(change_base \"8\" \"26\")\n  # \"8\"\n  # >>>\
    \ $(change_base \"8\" \"35\")\n  # \"8\"\n  echo \"$result\"", "    local -i x=$1\n\
    \    local -i base=$2\n    local -i tmp\n    local output=''\n    local digit\n\
    \    for ((tmp=x;tmp>0;tmp=tmp/base)); do\n        digit=$((tmp%base))\n     \
    \   output=$digit$output\n    done\n    echo $output", "    local x=\"$1\"\n \
    \   local base=\"$2\"\n    declare -i b=0\n    local res=\"\"\n    while [ \"\
    $x\" -ne 0 ]; do\n        declare -i b=$(($x % $base))\n        x=$(($x / $base))\n\
    \        res=\"$b$res\"\n    done\n    echo \"$res\"", '  echo "obase=$2; $1"
    | bc', "    if [ -z \"$1\" ] || [ -z \"$2\" ]; then\n        printf \"Error: Input\
    \ arguments are empty\\n\" >&2\n        exit 1\n    fi\n    if [ \"$2\" -lt 2\
    \ ] || [ \"$2\" -gt 9 ]; then\n        printf \"Error: Invalid argument: base\
    \ = %s\\n\" \"$2\" >&2\n        exit 1\n    fi\n    x=$1\n    base=$2\n    while\
    \ [ \"$x\" -gt 0 ]; do\n        printf \"%s\" \"$(($x % base))\"\n        x=$(($x\
    \ / base))\n    done\n    printf \"\\n\"", "    local n=$1\n    local base=$2\n\
    \    local d\n    if [ \"$n\" -lt \"$base\" ]; then\n        d=$n\n    else\n\
    \        d=$(($n%$base))\n        change_base $(($n/$base)) $base\n    fi\n  \
    \  echo -n $d", "    local x=$1\n    local base=$2\n    local res=''\n    while\
    \ [ \"$x\" -gt 0 ]; do\n        y=$((x % base))\n        x=$((x / base))\n   \
    \     res=\"$y$res\"\n    done\n    echo \"$res\"", "\t# set x, then convert to\
    \ binary\n\tlocal x=\"$1\"\n\tlocal base=\"$2\"\n\tlocal ret=\"\"\n\tlocal x_div_base=\"\
    \"\n\tlocal x_mod_base=\"\"\n\tlocal digit=\"\"\n\twhile [[ \"$x\" -gt 0 ]]; do\n\
    \t\t# need x, base, x_div_base, x_mod_base, digit\n\t\tx_div_base=$(($x / $base))\n\
    \t\tx_mod_base=$(($x % $base))\n\t\tdigit=\"$x_mod_base\"\n\t\tret=\"$digit$ret\"\
    \n\t\tx=\"$x_div_base\"\n\tdone\n\techo \"$ret\"", "    echo $1 | awk '{printf(\"\
    %s\", $1)}' |\\\n        gawk 'BEGIN{printf(\"\")}\n                {while ($1>0)\
    \ {printf(\"%d\", $1%'$2'); $1=int($1/'$2')}}\n              END{printf(\"\\n\"\
    )}' | rev", "    num=$1\n    base=$2\n    new_num=\"\"\n    while [ \"$num\" -ne\
    \ 0 ]; do\n        left=$(($num % $base))\n        num=$(($num / $base))\n   \
    \     new_num=\"$left$new_num\"\n    done\n    echo $new_num", "  x=$1\n  base=$2\n\
    \  res=\"\"\n  while [ \"$x\" -ne 0 ]; do\n    res=$(($x % $base))$res\n    x=$(($x\
    \ / $base))\n  done\n  echo $res", "    int_input=\"$1\"\n    int_base=\"$2\"\n\
    \    if [ \"${int_input}\" == \"0\" ]; then\n        str_conv=\"0\"\n    else\n\
    \        remainder=\"${int_input}\"\n        str_conv=\"\"\n        while [ \"\
    ${remainder}\" != \"0\" ]; do\n            remainder=$((remainder % int_base))\n\
    \            str_conv=\"${remainder}${str_conv}\"\n            remainder=$((remainder\
    \ / int_base))\n        done\n    fi\n    echo \"${str_conv}\"", "  local x=$1\n\
    \  local base=$2\n  local n=$x\n  local r=0\n  local result=\"\"\n  while [[ \"\
    $n\" -gt 0 ]]; do\n    r=$(( n % base ))\n    n=$(( n / base ))\n    result=\"\
    $r$result\"\n  done\n  echo \"$result\"", "  local string=$1\n  local base=$2\n\
    \  local tmp_string=$string\n  local result=\"\"\n  while true; do\n    result=\"\
    $(($tmp_string % $base))${result}\"\n    tmp_string=$(($tmp_string / $base))\n\
    \    [[ $tmp_string -eq 0 ]] && break\n  done\n  echo $result", "    python3 -c\
    \ \"print(''.join(str(int($1 % $2)) for x in range(int($1/$2), -1, -1)))\"", " \
    \   local x=$1; local base=$2\n    local result=''\n    local mod=0\n    local\
    \ x_rest=$x\n    while [ $x_rest -gt 0 ]; do\n        mod=$(( $x_rest % $base\
    \ ))\n        x_rest=$(( $x_rest / $base ))\n        result=$mod$result\n    done\n\
    \    echo $result", "    number=$1\n    base=$2\n    while [ \"$number\" -ge \"\
    $base\" ]; do\n        value=$(($number % $base))\n        echo -n \"$value\"\n\
    \        number=$(($number / $base))\n    done\n    echo \"$number\"", "    n=$1\n\
    \    b=$2\n    if [[ \"$n\" -lt \"10\" ]]; then\n        echo \"$n\"\n    else\n\
    \        remainder=$((n % b))\n        new_n=$((n / b))\n        echo \"$(change_base\
    \ \"$new_n\" \"$b\")\"\"$remainder\"\n    fi", "    if [[ $# -ne 2 ]]; then\n\
    \        echo \"Usage: $0 <num> <base>\"\n        return 1\n    fi\n    local\
    \ num=$1\n    local base=$2\n    local res=\"\"\n    local q=0\n    local r=0\n\
    \    local tmp=0\n    local mul=0\n    local i=0\n    if [[ $num -eq 0 ]]; then\n\
    \        echo \"0\"\n        return 0\n    fi\n    mul=1\n    i=0\n    while [[\
    \ $mul -le $num ]]; do\n        i=$((i+1))\n        mul=$((mul*base))\n    done\n\
    \    for ((j=$i-1; j>=0; j--)); do\n        mul=$((mul/base))\n        r=$((num/mul))\n\
    \        res=$res$r\n        q=$((num%mul))\n        num=$q\n    done\n    echo\
    \ $res", "  local x=$1\n  local base=$2\n  local s=\"\"\n  local q=0\n  local\
    \ r=0\n  while [ \"$x\" -gt 0 ]; do\n    let \"q = $x / $base\"\n    let \"r =\
    \ $x % $base\"\n    s=$(echo $s$r)\n    x=$q\n  done\n  echo \"$s\"", "    local\
    \ x=$1\n    local base=$2\n    if [[ $x -lt 0 ]]; then\n        x=$((-$x))\n \
    \       echo -$(change_base $x $base)\n    else\n        local remainder=$(($x\
    \ % $base))\n        local quotient=$(($x / $base))\n        if [[ $quotient -eq\
    \ 0 ]]; then\n            echo $remainder\n        else\n            echo $(change_base\
    \ $quotient $base)$remainder\n        fi\n    fi", "    local base=$2\n    local\
    \ x=$1\n    local remainder\n    local result\n    local temp\n    while [ \"\
    $x\" -gt \"0\" ]; do\n        remainder=$(( x % base ))\n        x=$(( x / base\
    \ ))\n        temp=$result\n        result=\"$remainder$temp\"\n    done\n   \
    \ if [ -z \"$result\" ]; then\n        result=\"0\"\n    fi\n    echo \"$result\"",
  "  # Implement your code here.\n  # num: input number\n  # base: base number\n \
    \ # k: sub result when the input number is divided by the base\n  # r: remainder\
    \ when the input number is divided by the base\n  # q: quotient when the input\
    \ number is divided by the base\n  # ret: return value.\n  #\n  # and you can\
    \ use \"echo\" for printing.\n  #\n  # echo \"ret is $ret\"\n  #\n  # This is\
    \ a hint.\n  #\n  # get $1 and $2 from the input.\n  #\n  # echo \"num is $num\"\
    \n  # echo \"base is $base\"\n  #\n  # convert from decimal to base.\n  #\n  #\
    \ echo \"k is $k\"\n  # echo \"r is $r\"\n  # echo \"q is $q\"\n  # echo \"ret\
    \ is $ret\"\n  #\n  # return the result.\n  echo 0", "    printf \"%d\" $1 | awk\
    \ -v base=$2 '{printf(\"%d\",$1)}' | tr 0123456789 \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\"",
  "    local x=$1 base=$2\n    local result=\"\"\n    local remainder=0\n\n    if\
    \ [ \"$x\" -eq 0 ]; then\n        echo 0\n        return\n    fi\n\n    while\
    \ [ \"$x\" -gt 0 ]; do\n        remainder=$(( x % base ))\n        x=$(( x / base\
    \ ))\n        result=\"$remainder$result\"\n    done\n\n    echo $result", "\t\
    local base=$2\n\tlocal target=$1\n\tlocal result=\"\"\n\twhile [ $target -ne 0\
    \ ]; do\n\t\ttemp=$(( $target % $base ))\n\t\tresult=\"$temp$result\"\n\t\ttarget=$((\
    \ $target / $base ))\n\tdone\n\techo $result", '  echo $(awk "BEGIN { print strtonum(\"$1\")\"#\"$2
    }")', "    x=$1\n    base=$2\n    power=0\n    result=\"\"\n    while [ $x -gt\
    \ 0 ]; do\n        t=$(($x%$base))\n        result=\"$t$result\"\n        x=$(($x/$base))\n\
    \    done\n    if [ \"$result\" == \"\" ]; then\n        result=\"0\"\n    fi\n\
    \    echo $result", "  local n=\"$1\"\n  local base=\"$2\"\n  local res=\"\"\n\
    \  local digit=\"\"\n  # if input number is not a number, return empty string\n\
    \  if ! [[ \"$n\" =~ ^[0-9]+$ ]]; then\n    echo \"\"\n    return\n  fi\n  # if\
    \ input base is not a number, return empty string\n  if ! [[ \"$base\" =~ ^[0-9]+$\
    \ ]]; then\n    echo \"\"\n    return\n  fi\n  # if input base is bigger than\
    \ 10, return empty string\n  if [ \"$base\" -gt 10 ]; then\n    echo \"\"\n  \
    \  return\n  fi\n  # if input base is less than 1, return empty string\n  if [\
    \ \"$base\" -lt 1 ]; then\n    echo \"\"\n    return\n  fi\n  # if input number\
    \ is negative, return empty string\n  if [ \"$n\" -lt 0 ]; then\n    echo \"\"\
    \n    return\n  fi\n  while [ \"$n\" -gt 0 ]; do\n    digit=$((n % base))\n  \
    \  res=\"$digit$res\"\n    n=$((n / base))\n  done\n  echo \"$res\"", "    local\
    \ x=\"$1\"\n    local base=\"$2\"\n    local result=\"\"\n    while (( x > 0 ));\
    \ do\n        local rest=$(( x % base ))\n        x=$(( x / base ))\n        result=\"\
    $rest$result\"\n    done\n    echo \"$result\"", "  # string representation of\
    \ input number\n  local result=\"\"\n  # the number to convert\n  local number=${1}\n\
    \  # the base to convert to\n  local base=${2}\n  # the quotient of the number\
    \ and the base\n  local quotient=$((number / base))\n  # the remainder of the\
    \ number and the base\n  local remainder=$((number % base))\n  if [ $quotient\
    \ -gt 0 ]; then\n    result=$(change_base $quotient $base)\n  fi\n  echo \"${result}${remainder}\"",
  '  echo "obase=$2;ibase=10;$1" | bc', "  local x=$1\n  local base=$2\n  while ((x\
    \ > 0)); do\n    rem=$((x % base))\n    x=$((x / base))\n    ans=\"$rem$ans\"\n\
    \  done\n  echo \"$ans\"", "    local number=$1\n    local base=$2\n    local\
    \ base_number\n    local result_number=0\n    local i=0\n    while (( $number\
    \ > 0 )); do\n        base_number=$(( $number % $base ))\n        number=$(( $number\
    \ / $base ))\n        result_number=$(( $result_number + ($base_number * $((10\
    \ ** $i))) ))\n        i=$(( $i + 1 ))\n    done\n    echo $result_number", " \
    \   # get the length of the number $1\n    l=$(echo \"$1\" | wc -c)\n    # make\
    \ an integer copy of $1\n    declare -i ival=$1\n    # make a string copy of $1\n\
    \    sval=\"$1\"\n    # while ival is not zero\n    while ((ival != 0)); do\n\
    \        # declare -i rem=$((ival % $2))\n        # convert number $1 to base\
    \ $2 and make a string\n        sval=$(echo \"$((ival % $2))\"\"$sval\")\n   \
    \     ival=$((ival / $2))\n    done\n    # return the string\n    echo \"$sval\"",
  "    local x=$1 base=$2 result=\n    local d quotient=0 remainder=0 remainder_tmp=\n\
    \n    if [[ \"$x\" -lt \"$base\" ]]; then\n        echo \"$x\"\n        return\n\
    \    fi\n\n    while [[ \"$quotient\" -ne \"0\" ]]; do\n        quotient=$((x\
    \ / base))\n        remainder=$((x % base))\n        if [[ \"$remainder\" -eq\
    \ \"0\" ]]; then\n            remainder=\n        fi\n        if [[ -n \"$remainder_tmp\"\
    \ ]]; then\n            remainder=$remainder_tmp$remainder\n        fi\n     \
    \   result=$remainder$result\n        x=$quotient\n        remainder_tmp=\n  \
    \  done\n    echo \"$result\"", "    if [ \"$#\" -ne 2 ]; then\n        echo \"\
    usage: change_base <x> <base>\"\n        return\n    fi\n    if [ \"$2\" -ge 10\
    \ ]; then\n        echo \"usage: base should be less than 10.\"\n        return\n\
    \    fi\n    local n=$1\n    local base=$2\n    local ret=\"\"\n    local rem\n\
    \    local a\n    while [ $n -gt 0 ]; do\n        rem=$((n % base))\n        a=${alpha[$rem]}\n\
    \        ret=$a$ret\n        n=$((n / base))\n    done\n    echo $ret", "  local\
    \ x=\"$1\"\n  local b=\"$2\"\n  local y\n  local q\n  local r\n  local result=()\n\
    \  local i\n  for ((i=0; i<=${#x}; i++)); do\n    # set y to zero padded x\n \
    \   y=$(printf \"%0${#x}d\" $x)\n    # set r to last digit of y, set q to the\
    \ rest of y\n    r=$(expr $y % 10)\n    q=$(expr $y / 10)\n    # add r to result\n\
    \    result+=($r)\n    # set x to q, next loop starts from this new x\n    x=$q\n\
    \  done\n  # join numbers of result array with \"\", reverse result array\n  result=($(printf\
    \ \"%s\" \"${result[@]}\" | rev))\n  # join numbers of result array with \"\"\
    , replace 10 to \"A\", 11 to \"B\"\n  result=$(printf \"%s\" \"${result[@]}\"\
    \ | sed -e \"s/10/A/g\" -e \"s/11/B/g\")\n  echo \"$result\"", "  (( $2 < 10 ))\
    \ || echo \"usage: change_base x base\" >&2\n  echo \"obase=$2; ibase=10; $1\"\
    \ | bc", "    local num=$1\n    local base=$2\n    local calc=${base}\n    local\
    \ result=\"\"\n    local product=1\n    local digit=0\n    # echo \"num is $num\"\
    \n    # echo \"base is $base\"\n    while [ ${num} -gt 0 ]; do\n        # echo\
    \ \"num is $num\"\n        product=$((${num} % ${calc}))\n        # echo \"product\
    \ is $product\"\n        result=${product}${result}\n        num=$((${num} / ${calc}))\n\
    \        # echo \"result is $result\"\n    done\n    echo ${result}", "    local\
    \ -r x=\"$1\" base=\"$2\"\n    local result=\"\"\n    local q=\"\"\n    local\
    \ r=\"\"\n    local i=\"\"\n    local n=\"\"\n    if [ \"$x\" -lt \"$base\" ];\
    \ then\n        echo \"$x\"\n        return\n    fi\n    q=$(( x / base ))\n \
    \   r=$(( x % base ))\n    if [ \"$r\" -eq 0 ]; then\n        r=\"0\"\n    fi\n\
    \    result=\"$r\"\n    while [ \"$q\" -gt 0 ]; do\n        q=$(( q / base ))\n\
    \        r=$(( q % base ))\n        if [ \"$r\" -eq 0 ]; then\n            r=\"\
    0\"\n        fi\n        result=\"$r$result\"\n    done\n    echo \"$result\"",
  "    # > 10\n    if [ \"$1\" -ge 10 ]; then\n        echo \"$1\"\n        return\n\
    \    fi\n    # == 0\n    if [ \"$1\" -eq 0 ]; then\n        echo \"$1\"\n    \
    \    return\n    fi\n    # 0 < $1 < 10\n    if [ \"$1\" -lt 10 ]; then\n     \
    \   change_base $(($1 / $2)) $2\n        echo $(($1 % $2))\n        return\n \
    \   fi", "    local num=$1;\n    local base=$2;\n    local result=\"\";\n    local\
    \ rem=0;\n    local quotient=0;\n    local map=(0 1 2 3 4 5 6 7 8 9);\n    # initial\
    \ remainder is\n    rem=$(( $num % $base ))\n    # initial quotient is\n    quotient=$((\
    \ $num / $base ))\n    result=${map[$rem]}${result}\n    # loop until quotient\
    \ becomes zero\n    while [[ $quotient -ne 0 ]]; do\n        rem=$(( $quotient\
    \ % $base ))\n        quotient=$(( $quotient / $base ))\n        result=${map[$rem]}${result}\n\
    \    done\n    echo $result", "  # Print error if $1 or $2 is not an integer\n\
    \  if ! [[ \"$1\" =~ ^[0-9]+$ ]]; then\n    echo -e \"\\033[1;31m$1 is not an\
    \ integer\\033[0m\" >&2\n    return 1\n  fi\n  if ! [[ \"$2\" =~ ^[0-9]+$ ]];\
    \ then\n    echo -e \"\\033[1;31m$2 is not an integer\\033[0m\" >&2\n    return\
    \ 1\n  fi\n  local number=\"$1\"\n  local base=\"$2\"\n  # Print error if $base\
    \ is greater than 10\n  if [ \"$base\" -gt 10 ]; then\n    echo -e \"\\033[1;31mbase\
    \ ($base) is greater than 10\\033[0m\" >&2\n    return 1\n  fi\n  local remainder=\"\
    \"\n  local result=\"\"\n  # Iterate until $number is 0\n  while [ \"$number\"\
    \ -gt 0 ]; do\n    remainder=$((number % base))\n    number=$((number / base))\n\
    \    result=\"$remainder$result\"\n  done\n  echo \"$result\"", "    declare -i\
    \ x=$1\n    declare -i base=$2\n    declare -i quotient\n    declare -i remainder\n\
    \    declare -i power=1\n    declare -i new_x=0\n    while [[ $x -gt 0 ]]; do\n\
    \        # get the remainder of $x divided by $base\n        remainder=$((x %\
    \ base))\n        # add the remainder, multiplied by the current power of $base,\
    \ to the new number\n        new_x=$((new_x + remainder * power))\n        # update\
    \ the power of $base\n        power=$((power * 10))\n        # get the quotient\n\
    \        quotient=$((x / base))\n        # update $x\n        x=$quotient\n  \
    \  done\n    echo $new_x", '  echo "obase=$2; ibase=10; $1" | bc', "    local\
    \ i x base\n    x=$1\n    base=$2\n    while [ $x -gt 0 ]; do\n        i=$(( $x\
    \ % $base ))\n        x=$(( $x / $base ))\n        echo -n \"$i\"\n    done",
  "    local x=\"$1\"\n    local base=\"$2\"\n    local y=$((x % base))\n    x=$((x\
    \ / base))\n    local t=\n    if [[ $x != 0 ]]; then\n        t=$(change_base\
    \ \"$x\" \"$base\")\n    fi\n    echo \"$t$y\"", "    if [[ $1 == 0 ]]; then\n\
    \        echo 0\n        return\n    fi\n    local n=\"\"\n    local r=\"\"\n\
    \    local q=$1\n    local r_=\"$(($q % $2))\"\n    while [[ $q -ne 0 ]]; do\n\
    \        if [[ $r_ -lt 10 ]]; then\n            r+=$r_\n        else\n       \
    \     case $r_ in\n                10) r+=\"a\" ;;\n                11) r+=\"\
    b\" ;;\n                12) r+=\"c\" ;;\n                13) r+=\"d\" ;;\n   \
    \             14) r+=\"e\" ;;\n                15) r+=\"f\" ;;\n             \
    \   16) r+=\"g\" ;;\n                17) r+=\"h\" ;;\n                18) r+=\"\
    i\" ;;\n                19) r+=\"j\" ;;\n                20) r+=\"k\" ;;\n   \
    \             21) r+=\"l\" ;;\n                22) r+=\"m\" ;;\n             \
    \   23) r+=\"n\" ;;\n                24) r+=\"o\" ;;\n                25) r+=\"\
    p\" ;;\n                26) r+=\"q\" ;;\n                27) r+=\"r\" ;;\n   \
    \             28) r+=\"s\" ;;\n                29) r+=\"t\" ;;\n             \
    \   30) r+=\"u\" ;;\n                31) r+=\"v\" ;;\n                32) r+=\"\
    w\" ;;\n                33) r+=\"x\" ;;\n                34) r+=\"y\" ;;\n   \
    \             35) r+=\"z\" ;;\n            esac\n        fi\n        q=$(($q /\
    \ $2))\n        r_=\"$(($q % $2))\"\n    done\n    for (( i=${#r}-1; i>=0; i--\
    \ )); do\n        n+=${r:$i:1}\n    done\n    echo $n", "    input_number=\"$1\"\
    \n    base=\"$2\"\n    result=\"\"\n    while [ \"$input_number\" -gt \"0\" ];\
    \ do\n        # result $result + $(input_number % base)\n        result=\"$(echo\
    \ \"$result$(($input_number % $base))\")\"\n        input_number=$(($input_number\
    \ / $base))\n    done\n    echo \"$result\"", "    n=\"$1\"\n    base=\"$2\"\n\
    \    stack=()\n    result=\"\"\n    while [[ \"$n\" -gt 0 ]]; do\n        r=$((n\
    \ % base))\n        stack+=($r)\n        n=$((n / base))\n    done\n    for r\
    \ in \"${stack[@]}\"; do\n        result=\"$result$r\"\n    done\n    echo \"\
    $result\"", '  echo "obase=$2; ibase=10; $1" | bc', "    x=$1\n    base=$2\n \
    \   v=$x\n    s=\"\"\n    while (( v >= base )); do\n        let \"v = v / base\"\
    \n        let \"s = (v % base) + s\"\n    done\n    let \"s = x + s\"\n    echo\
    \ $s", "    local x=\"$1\"\n    local base=\"$2\"\n    local len=${#x}\n    local\
    \ output=''\n    local pow=0\n    local d=0\n    local i=0\n    local curr=0\n\
    \    while [ $pow -lt $len ]; do\n        curr=0\n        for (( i = $pow; i <\
    \ $len; i++ )); do\n            # d is digit after converting from string to int.\n\
    \            d=$((${x:$i:1} + 0))\n            curr=$(($curr * 10 + $d))\n   \
    \     done\n        curr=$(($curr % $base))\n        pow=$(($pow + 1))\n     \
    \   output=\"$curr$output\"\n    done\n    echo \"$output\"", "    # use bc to\
    \ get the answer\n    echo \"obase=$2; ibase=10; $1\" | bc", "  for i in $(seq\
    \ $(($2-1)) -1 0); do\n    tmp=$(($1 % $2))\n    if [ $tmp == 0 ]; then\n    \
    \  tmp=$2\n    fi\n    result=${tmp}${result}\n    tmp=$((($1-$tmp)/$2))\n   \
    \ if [ $tmp == 0 ]; then\n      break\n    fi\n  done\n  echo $result", "    value=$1\n\
    \    base=$2\n    result=\"\"\n    quotient=$value\n    tmp=\"\"\n    while [\
    \ $quotient -gt 0 ]; do\n        remainder=$(( $quotient % $base ))\n        quotient=$((\
    \ $quotient / $base ))\n        result=\"$remainder$result\"\n    done\n    echo\
    \ $result", "    number=$1\n    base=$2\n    max_power=0\n    total=0\n    while\
    \ (( 1 <= $number )); do\n        current_digit=$(( $number % $base ))\n     \
    \   (( total += current_digit * ( base ** max_power ) ))\n        (( max_power++\
    \ ))\n        (( number /= base ))\n    done\n    echo $total", "\tlocal number=$1\n\
    \tlocal base=$2\n\t\n\tlocal result=\"$number\"\n\twhile [ $result -ge $base ];\
    \ do\n\t\t# if $result is even, then it is possible to break $result into \n\t\
    \t# $result = $quotient * $base + 1\n\t\t# $quotient = ($result - 1) / $base\n\
    \t\t# If $result is odd, then it is possible to break $result into \n\t\t# $result\
    \ = $quotient * $base + 0\n\t\t# $quotient = $result / $base\n\t\tlocal quotient=$((result/base))\n\
    \t\tlocal remainder=$((result%base))\n\t\tresult=$quotient\n\t\t\n\t\t# Insert\
    \ the remainder, which is 0 or 1, to the beginning of the result string.\n\t\t\
    result=\"$remainder$result\"\n\tdone\n\t# Insert the last quotient, which is less\
    \ than $base, to the beginning of the result string.\n\tresult=\"$result$quotient\"\
    \n\t\n\techo \"$result\"", "    local x=$1\n    local base=$2\n    local digits=(0\
    \ 1 2 3 4 5 6 7 8 9)\n    local str=\"\"\n    local div=0\n    local mod=0\n \
    \   local i=0\n    local j=0\n    local len=${#digits[@]}\n    # we start from\
    \ the least significant digit\n    while [ $x -gt 0 ]; do\n        div=$((x /\
    \ base))\n        mod=$((x % base))\n        x=$div\n        # let's convert digit\
    \ to string\n        for ((i=0; i<len; i++)); do\n            if [ $mod -eq ${digits[$i]}\
    \ ]; then\n                str+=\"$i\"\n                break\n            fi\n\
    \        done\n    done\n    # now, reverse the string\n    len=${#str}\n    local\
    \ tmp=\"\"\n    for ((i=0; i<len; i++)); do\n        tmp+=${str:$((len-i-1)):1}\n\
    \    done\n    echo \"$tmp\"", "    x=$1\n    base=$2\n    y=$x\n    q=0\n   \
    \ while [[ $y -gt 0 ]]; do\n        r=$((y % base))\n        q=$((10 * q + r))\n\
    \        y=$((y / base))\n    done\n    echo \"$q\"", "  local x=$1\n  local base=$2\n\
    \  local result=\"\"\n  while (( x )); do\n    (( result = \"$(( x % base ))\"\
    \ + result * 10 ))\n    (( x /= base ))\n  done\n  echo \"$result\"", "  base=$2\n\
    \  result=\"\"\n  num=$1\n  if [ $num -lt $base ]; then\n    echo $num\n    return\n\
    \  fi\n  while [ $num -ge $base ]; do\n    r=$(expr $num % $base)\n    num=$(expr\
    \ $num / $base)\n    result=$r$result\n  done\n  result=$num$result\n  echo $result",
  "  local integer=$1\n  local base=$2\n  local base_num\n  local result\n  local\
    \ remainder\n\n  while [ $integer -gt 0 ]; do\n    remainder=$(( integer % base\
    \ ))\n    result=\"$remainder$result\"\n    integer=$(( integer / base ))\n  done\n\
    \n  echo $result", "  local x=$1\n  local base=$2\n  local n=$(($x))\n  local\
    \ result=\"\"\n  local remainder=\"\"\n  # base number is less than 10\n  local\
    \ max_base_number=9\n  local max_base_number_string=\"$(get_number_string ${max_base_number})\"\
    \n  if [[ ${base} -gt ${max_base_number} ]]; then\n    return 1\n  fi\n  while\
    \ [[ ${n} -gt 0 ]]; do\n    remainder=$((${n} % ${base}))\n    result=\"$(get_number_string\
    \ ${remainder})${result}\"\n    n=$((${n} / ${base}))\n  done\n  echo \"${result}\"",
  "    local x=$1\n    local base=$2\n    if [[ $base -gt 10 ]]; then\n        echo\
    \ \"base must be less than 10\"\n        exit 1\n    fi\n    local n=$(($x / $base))\n\
    \    local r=$(($x % $base))\n    local buf=\"$r\"\n    while [[ $n -gt 0 ]];\
    \ do\n        x=$n\n        n=$(($x / $base))\n        r=$(($x % $base))\n   \
    \     buf=\"$r$buf\"\n    done\n    echo \"$buf\"", "    local x=$1;\n    local\
    \ base=$2;\n    local res=\"\";\n    local modulo=0;\n    while (( x > 0 )); do\n\
    \        modulo=$(( x % base ));\n        res=$modulo$res;\n        x=$(( x /\
    \ base ));\n    done\n    echo $res;", "\tre='^[0-9]+$'\n\tif ! [[ $1 =~ $re ]]\
    \ || ! [[ $2 =~ $re ]]; then\n\t\techo \"ERROR: input of change_base should be\
    \ a number\"\n\t\texit 1\n\tfi\n\tif [ $2 -ge 10 ]; then\n\t\techo \"ERROR: can\
    \ only convert number to a base less than 10\"\n\t\texit 1\n\tfi\n\t# local x=$1\n\
    \t# local base=$2\n\t# echo $((2#$x))\n\n\t# echo \"$(echo \"obase=$2;ibase=10;$1\"\
    \ | bc)\"\n\techo $(python -c \"print(int($1).to_bytes($1.bit_length(),'big').decode('latin-1'))\"\
    )", "    # local int=$1\n    # local base=$2\n    local result=\"\"\n    local\
    \ tmp=$1\n    local _digit\n\n    while [ $tmp -gt 0 ]; do\n        _digit=$((tmp\
    \ % $2))\n        result=\"$_digit$result\"\n        tmp=$((tmp / $2))\n    done\n\
    \n    echo $result", "  local -i num=$1\n  local -i base=$2\n  local -i next_num=$num\n\
    \  local -i res\n  local out=()\n  while (( next_num >= base )); do\n    res=$((\
    \ next_num % base ))\n    next_num=$(( next_num / base ))\n    out+=(\"$res\"\
    )\n  done\n  if (( next_num > 0 )); then\n    out+=(\"$next_num\")\n  fi\n  echo\
    \ \"${out[@]}\" | sed 's/ /\\n/g' | tac | tr -d '\\n'", "    local n base=$2 x=$1\n\
    \n    while [ $x -gt 0 ]; do\n        n=$(( $x % $base ))$n\n        x=$(( $x\
    \ / $base ))\n    done\n\n    echo $n", "    local n=\"$1\"\n    local b=\"$2\"\
    \n    local i=1\n    local result=\"\"\n    local remainder=\"\"\n    local d=\"\
    \"\n    for (( i=1; i<=n; i++ )); do\n        d=\"$(( n % b ))\"\n        result=\"\
    $d$result\"\n        n=\"$(( n / b ))\"\n    done\n    echo \"$result\"", "  local\
    \ x=\"$1\"\n  local base=\"$2\"\n  local remain=\"\"\n  local result=\"\"\n  while\
    \ true; do\n    let remain=\"$x % $base\"\n    let x=\"$x / $base\"\n    result=\"\
    $remain$result\"\n    if [ \"$x\" -eq 0 ]; then\n      break\n    fi\n  done\n\
    \  echo \"$result\"", "    local x=\"$1\"\n    local base=\"$2\"\n    local r=\"\
    \"\n    local tmp=\"\"\n    while [[ \"$x\" -gt 0 ]]; do\n        r=\"$((x % base))$r\"\
    \n        x=\"$((x / base))\"\n    done\n    echo \"$r\"", "  n=$1\n  base=$2\n\
    \  res=\"\"\n  while [[ $n -gt 0 ]]; do\n    res=$(printf \"%s%s\" $(( n % base\
    \ )) $res)\n    n=$(( n / base ))\n  done\n  echo $res", "  if [[ \"$1\" == \"\
    \" || \"$2\" == \"\" ]]; then\n    exit 1\n  fi\n  # Set the integer to be converted\n\
    \  number=$1\n  # Set the base to which the conversion is made\n  base=$2\n  if\
    \ [ \"$number\" -lt \"$base\" ]; then\n    echo $number\n  else\n    change_base\
    \ $(($number/$base)) $base\n    echo $(($number%$base))\n  fi", "    x=$1\n  \
    \  base=$2\n    exp=0\n    ans=\"\"\n    while [ $x -gt 0 ]; do\n        digit=$(echo\
    \ \"($x % $base)^$exp\" | bc)\n        [ $digit -gt 0 ] && ans=\"${ans}${digit}\"\
    \n        x=$(($x / $base))\n        exp=$(($exp + 1))\n    done\n    echo $ans",
  "    # Change base from 10 to base\n    local value=$1\n    local base=$2\n    local\
    \ result=\"\"\n    local remainder=\"\"\n    # If the value is 0, the base is\
    \ 1.\n    if [[ $value -eq 0 ]]; then\n        echo \"1\"\n        return\n  \
    \  fi\n    # If the value is 1, the base is 0.\n    if [[ $value -eq 1 ]]; then\n\
    \        echo \"0\"\n        return\n    fi\n    # Change the base.\n    while\
    \ [[ $value -gt 0 ]]; do\n        remainder=$(($value % $base))\n        value=$(($value\
    \ / $base))\n        result=\"$remainder$result\"\n    done\n    echo \"$result\"",
  '  echo "obase=$2;ibase=10;$1" | bc', "    local input=$1\n    local base=$2\n \
    \   local value=$input\n    local remainder\n    local result=\"\"\n    while\
    \ (( $value >= $base )); do\n        remainder=$(( $value % $base ))\n       \
    \ value=$(( $value / $base ))\n        result=\"$remainder$result\"\n    done\n\
    \    result=\"$value$result\"\n    echo $result", "  local x=$1\n  local base=$2\n\
    \  local res=()\n  # check whether x is integer\n  if [[ \"$x\" =~ ^[0-9]+$ ]];\
    \ then\n    # check whether base is integer and less than 10\n    if [[ \"$base\"\
    \ =~ ^[0-9]+$ ]] && [ \"$base\" -lt 10 ]; then\n      # check whether x is less\
    \ than base\n      if [ \"$x\" -lt \"$base\" ]; then\n        res+=($x)\n    \
    \  else\n        while [ \"$x\" -ge \"$base\" ]; do\n          res+=($((x % base)))\n\
    \          x=$((x / base))\n        done\n        res+=($x)\n      fi\n      echo\
    \ \"${res[@]}\" | tr -d ' '\n    else\n      echo \"'base' must be an integer\
    \ and less than 10.\"\n    fi\n  else\n    echo \"'x' must be an integer.\"\n\
    \  fi", "  python -c \"\nimport math\ndecimal = $1\nbase = $2\n\ntot = 0\nfor\
    \ n, i in enumerate(reversed(decimal)):\n    tot += int(i) * (base ** n)\nif tot\
    \ > 0:\n    print(\\\"\\\".join(reversed(tot.__format__('b'))))\nelse:\n    print(\\\
    \"0\\\")\n\"", "\tlocal ret=\"\"\n\tlocal x=$1\n\tlocal base=$2\n\tlocal i=0\n\
    \twhile true; do\n\t\tlocal ret=\"$((x % base))$ret\"\n\t\tx=$((x / base))\n\t\
    \t((i++))\n\t\tif ((x < base)); then\n\t\t\tret=\"$x$ret\"\n\t\t\tbreak\n\t\t\
    fi\n\tdone\n\techo \"$ret\"", "  local x=$1\n  local base=$2\n  result=\n  local\
    \ DIGITS=\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  while [[ $x -ne 0 ]]; do\n\
    \    local reminder=$(( $x % $base ))\n    result=${DIGITS:$reminder:1}$result\n\
    \    x=$(( ($x - $reminder) / $base ))\n  done\n  echo $result", "  local x=$1\n\
    \  local base=$2\n  local result=\"\"\n  local tmp=0\n  while (( x > 0 )); do\n\
    \    tmp=$(( x % base ))\n    result=\"${tmp}${result}\"\n    x=$(( x / base ))\n\
    \  done\n  echo $result", "\tlocal x=$1; shift\n\tlocal base=$1; shift\n\tlocal\
    \ rest=\n\tlocal result=\n\tlocal sqr=\n\n\twhile [ $x -gt 0 ]; do\n\t\tlet rest=x%base\n\
    \t\tlet x=x/base\n\t\tlet sqr=rest*rest\n\t\tresult=$result$rest\n\tdone\n\techo\
    \ $result", "\tn=$1\n\tbase=$2\n\tnstr=\"\"\n\twhile [ $n -gt 0 ]; do\n\t\tr=$(($n\
    \ % $base))\n\t\tn=$(($n / $base))\n\t\tnstr=\"$r$nstr\"\n\tdone\n\techo $nstr",
  "    local -u num=$1\n    local -u base=$2\n    local -u ret=\"\"\n    local -u\
    \ rem\n    local -u ans\n    local -u len\n    local -u i\n    if [[ -z \"$num\"\
    \ || -z \"$base\" ]]; then\n        echo \"[]\"\n        return\n    fi\n    while\
    \ [[ \"$num\" -ne 0 ]]; do\n        let \"rem = num % base\"\n        ret=\"$rem$ret\"\
    \n        let \"num = num / base\"\n    done\n    echo \"$ret\"", "    [ \"$1\"\
    \ -lt 0 ] && echo \"-\"$(change_base $(echo \"$1 * -1\" | bc) $2) && return 0\n\
    \    [ \"$1\" -eq 0 ] && echo 0 && return 0\n    echo -n \"$(change_base $(echo\
    \ \"$1 / $2\" | bc) $2)\"$(echo $1 % $2 | bc)", "    if [ -z \"$2\" ]; then\n\
    \        echo \"Usage: change_base <x> <base>\"\n        exit 1\n    fi\n    echo\
    \ \"obase=$2; ibase=10; $1\" | bc", "\tlocal -i x=\"$1\"\n\tlocal -i base=\"$2\"\
    \n\tlocal -i quotient\n\tlocal -i remainder\n\twhile [ \"$x\" -gt \"0\" ]; do\n\
    \t\tquotient=$((x/base))\n\t\tremainder=$((x%base))\n\t\tx=$quotient\n\t\tprintf\
    \ '%i' \"$remainder\"\n\tdone", "  local x=$1\n  local base=$2\n  local retval=\"\
    \"\n  while [ $x -gt 0 ]; do\n    mod=$((x % base))\n    x=$((x / base))\n   \
    \ retval=\"$mod$retval\"\n  done\n  echo $retval", "  local x=$1; local base=$2\n\
    \  local result=\"\"\n  local digit\n\n  if [ $x -eq 0 ]; then\n    echo \"0\"\
    \n    return\n  fi\n\n  while [ $x -gt 0 ]; do\n    digit=$(( x % base ))\n  \
    \  result=\"$digit$result\"\n    x=$(( x / base ))\n  done\n\n  echo \"$result\"",
  "\tlocal x=\"$1\"\n\tlocal base=\"$2\"\n\tlocal result=\"\"\n\twhile [[ \"$x\" -ne\
    \ 0 ]]; do\n\t\tlocal y=$((x % base))\n\t\tresult=\"$y\"\"$result\"\n\t\tx=$((x\
    \ / base))\n\tdone\n\techo \"$result\"", "    local x=$1\n    local base=$2\n\
    \    local ret\n    local n\n    local n0\n    local n1\n    local n2\n    local\
    \ n3\n    local n4\n    local n5\n    local n6\n    local n7\n    local n8\n \
    \   local n9\n    local nn=0\n    local i=0\n    n0=\"\"\n    n1=\"\"\n    n2=\"\
    \"\n    n3=\"\"\n    n4=\"\"\n    n5=\"\"\n    n6=\"\"\n    n7=\"\"\n    n8=\"\
    \"\n    n9=\"\"\n    while [ $x -gt 0 ]; do\n        let n=$x%$base\n        if\
    \ [ $n -eq 0 ]; then\n            n0=$n0\"0\"\n        elif [ $n -eq 1 ]; then\n\
    \            n1=$n1\"1\"\n        elif [ $n -eq 2 ]; then\n            n2=$n2\"\
    2\"\n        elif [ $n -eq 3 ]; then\n            n3=$n3\"3\"\n        elif [\
    \ $n -eq 4 ]; then\n            n4=$n4\"4\"\n        elif [ $n -eq 5 ]; then\n\
    \            n5=$n5\"5\"\n        elif [ $n -eq 6 ]; then\n            n6=$n6\"\
    6\"\n        elif [ $n -eq 7 ]; then\n            n7=$n7\"7\"\n        elif [\
    \ $n -eq 8 ]; then\n            n8=$n8\"8\"\n        elif [ $n -eq 9 ]; then\n\
    \            n9=$n9\"9\"\n        fi\n        let x=$x/$base\n        let i=i+1\n\
    \    done\n    if [ -n \"$n0\" ]; then\n        nn=$n0\n    fi\n    if [ -n \"\
    $n1\" ]; then\n        nn=$n1$nn\n    fi\n    if [ -n \"$n2\" ]; then\n      \
    \  nn=$n2$nn\n    fi\n    if [ -n \"$n3\" ]; then\n        nn=$n3$nn\n    fi\n\
    \    if [ -n \"$n4\" ]; then\n        nn=$n4$nn\n    fi", "  [ $# -ne 2 ] && {\
    \ echo \"change_base() requires 2 arguments\"; exit 1; }\n  echo \"$1\" | awk\
    \ -v b=\"$2\" '{printf \"%d\", $1}' | xargs -I% bash -c 'echo \"obase='$2';%\"\
    ' | bc | tr -d '\\n'", "    local x=\"$1\"\n    local base=\"$2\"\n    local ret=\"\
    \"\n    local digit=\"\"\n    local digit_regex=\"^[0-9]+$\"\n    if [[ $x =~\
    \ $digit_regex ]] && [[ $base =~ $digit_regex ]]; then\n        while [ $x -gt\
    \ 0 ]; do\n            digit=$(($x % $base))\n            x=$(($x / $base))\n\
    \            ret=$digit$ret\n        done\n    fi\n    echo $ret", "    local\
    \ -r x=\"$1\"\n    local -r base=\"$2\"\n    local -r base_digits=\"0123456789\"\
    \n    local d q r\n    local out=\"\"\n    if [[ \"$x\" -eq 0 ]]; then\n     \
    \   echo \"0\"\n        return\n    fi\n    if [[ \"$x\" -lt 0 ]]; then\n    \
    \    echo \"Error: enter number > 0\"\n        return\n    fi\n    if [[ \"$base\"\
    \ -lt 2 ]]; then\n        echo \"Error: base >= 2\"\n        return\n    fi\n\
    \    if [[ \"$base\" -gt 10 ]]; then\n        echo \"Error: base <= 10\"\n   \
    \     return\n    fi\n    d=\"$x\"\n    while [[ \"$d\" -gt 0 ]]; do\n       \
    \ q=$(( d / base ))\n        r=$(( d % base ))\n        d=\"$q\"\n        out=\"\
    ${base_digits:$r:1}$out\"\n    done\n    echo \"$out\"", "    local x=\"$1\"\n\
    \    local base=\"$2\"\n    while [[ \"$x\" -ge \"$base\" ]]; do\n        local\
    \ y=\"$((x%base))\"\n        x=\"$((x/base))\"\n        change_base \"$x\" \"\
    $base\"\n        echo -n \"$y\"\n    done\n    echo -n \"$x\"", "    if [ \"$1\"\
    \ == \"0\" ]; then\n        echo \"0\"\n        return\n    fi\n    local x=$1\n\
    \    local base=$2\n    local result=\"\"\n    while [ $x -gt 0 ]; do\n      \
    \  local mod=$((x % base))\n        result=$(echo \"$result$mod\")\n        x=$((x\
    \ / base))\n    done\n    echo $result", "  local num=$1\n  local base=$2\n  local\
    \ str=\"\"\n  local x=0\n  local remainders=\"\"\n  local result=\"\"\n  for ((x=$base;\
    \ x>0; x--)); do\n    remainders=\"$remainders $(( $num % $x ))\"\n    num=$((\
    \ $num / $x ))\n  done\n  local max_remainder=$(echo \"$remainders\" | sort -g\
    \ | tail -n 1)\n  local max_exponent=$(( $(calc \"$max_remainder - 1\") | sed\
    \ -e 's/e.*//' ))\n  local exponent=0\n  for ((exponent=$max_exponent; exponent>=0;\
    \ exponent--)); do\n    local i=0\n    for remainder in $remainders; do\n    \
    \  if [[ $remainder -ge $(calc \"$base^$exponent\") ]]; then\n        result=\"\
    $result 1\"\n        remainders=$(echo \"$remainders\" | sed -e \"$((i+1))s/^.*$/$((\
    \ $remainder - $(calc \"$base^$exponent\") ))/\")\n      else\n        result=\"\
    $result 0\"\n      fi\n      i=$((i+1))\n    done\n  done\n  echo $result", " \
    \ # num is an integer\n  local num=$1\n  # base is an integer\n  local base=$2\n\
    \  local result=\"\"\n  while [ $num -ne 0 ]; do\n    # $num % $base is a remainder\
    \ of $num divided by $base\n    # $num / $base is a result of $num divided by\
    \ $base\n    result=\"$(($num % $base))$result\"\n    num=$(($num / $base))\n\
    \  done\n  echo $result", "    local x=${1:-0}\n    local b=${2:-10}\n    local\
    \ r=\"\"\n    while [ $x -gt 0 ]; do\n        let \"r=$x%$b\"\n        x=$((x/b))\n\
    \        r=\"$r$r\"\n    done\n    echo \"$r\"", "    local number=$1\n    local\
    \ base=$2\n    local i\n    local str_ret\n    local q\n    local r\n    local\
    \ tmp\n    local ret\n    local flag=0\n    ret=\"\"\n    while [[ $number -ne\
    \ 0 ]]; do\n        q=$(($number/$base))\n        r=$(($number%$base))\n     \
    \   ret=$r$ret\n        number=$q\n    done\n    echo $ret", "    local number=$1\n\
    \    local base=$2\n    local res=''\n    local mod=''\n    while (( number >\
    \ 0 )); do\n        mod=$(( number % base ))\n        res=\"$mod$res\"\n     \
    \   number=$(( number / base ))\n    done\n    echo \"$res\"", "    local x=$1\n\
    \    local base=$2\n    local result=\"\"\n    local mod\n    local div=${x}\n\
    \    while [ ${div} -gt 0 ]; do\n        mod=$((${div} % ${base}))\n        result=\"\
    ${mod}${result}\"\n        div=$((${div} / ${base}))\n    done\n    echo \"${result}\"",
  "  local X=$1\n  local base=$2\n  local result\n  local num=`echo \"${X}\" | head\
    \ -c1`\n  if [[ ${num} -eq 0 ]]; then\n    # base case\n    result=\"0\"\n  else\n\
    \    local remain=`expr ${X} % ${base}`\n    local quotient=`expr ${X} / ${base}`\n\
    \    result=`change_base ${quotient} ${base}`${remain}\n  fi\n  echo \"${result}\"",
  "  number=$1\n  new_base=$2\n  local result=\"0\"\n  local remainder=0\n  local\
    \ string_of_remainder=\"\"\n  local tmp=\"\"\n  i=1\n  while [ \"$number\" -ne\
    \ \"0\" ]; do\n    tmp=$number\n    remainder=$((number % new_base))\n    number=$((number\
    \ / new_base))\n    if [ \"$remainder\" -eq \"0\" ]; then\n      string_of_remainder=\"\
    0\"\n    else\n      string_of_remainder=\"1\"\n    fi\n    result=$(add_strings\
    \ \"$result\" \"$string_of_remainder\")\n    i=$((i + 1))\n  done\n  printf '%s'\
    \ \"$result\"", '    echo "obase=$2; ibase=10; $1" | bc', "    local x=$1\n  \
    \  local base=$2\n    local result=\"\"\n    local remainder=0\n    while [ $x\
    \ -ne 0 ]; do\n        remainder=$((x % base))\n        x=$((x / base))\n    \
    \    result=\"$remainder$result\"\n    done\n    echo \"$result\"", "    x=\"\
    $1\"\n    base=\"$2\"\n    res=\n    while [[ $x -ne 0 ]]; do\n        res=\"\
    $(($x % $base))$res\"\n        x=$(($x / $base))\n    done\n    echo \"$res\"",
  "  echo \"obase=$2; ibase=10; $1\" | bc | sed 's/\\\\//g'", "    local x base nums=()\n\
    \    x=$1\n    base=$2\n    while [ $x -gt 0 ]; do\n        rem=$((x % base))\n\
    \        x=$((x / base))\n        nums=(\"$rem\" \"${nums[@]}\")\n    done\n \
    \   echo \"${nums[@]}\" | tr -d ' '", "  declare -i x=$1\n  declare -i base=$2\n\
    \  declare -i quotient\n  declare -i remainder\n  declare result=\"\"\n  while\
    \ [ $x -ne 0 ]; do\n    remainder=$((x % base))\n    quotient=$((x / base))\n\
    \    result=\"$remainder$result\"\n    x=$quotient\n  done\n  echo $result", " \
    \   if [ $# -ne 2 ]; then\n        echo \"change_base: Invalid number of arguments\"\
    \ >&2\n        return 1\n    fi\n    declare -i x=\"$1\"\n    declare -i base=\"\
    $2\"\n    if [ $x -lt $base ]; then\n        echo $x\n        return 0\n    fi\n\
    \    y=$(( $x % $base ))\n    x=$(( $x / $base ))\n    change_base $x $base\n\
    \    echo $y", "  local x=$1 base=$2\n  local mod div\n  local result=\"\"\n \
    \ while (( x > 0 )); do\n    (( mod = x % base ))\n    (( div = x / base ))\n\
    \    (( x = div ))\n    result=\"${mod}${result}\"\n  done\n  echo \"${result}\"",
  "  local number=$1\n  local base=$2\n  local ret=0\n  local i=0\n  local value=0\n\
    \  local result=\"\"\n  while [ \"$number\" -gt 0 ]; do\n    let ret=$number%$base\n\
    \    number=$number/$base\n    result=\"$ret$result\"\n  done\n  echo $result",
  "    local x=$1\n    local base=$2\n    while ((x > 0)); do\n        echo -n $((x\
    \ % base))\n        x=$((x / base))\n    done", "  if [[ \"$1\" -eq \"0\" ]];\
    \ then\n    echo \"0\"\n    return\n  fi\n  local remainder=\n  local new_number=\n\
    \  local quotient=$1\n  local divisor=$2\n  local base_string=\"0123456789\"\n\
    \  local base_index=0\n  local base_number=0\n  while [[ \"$quotient\" -gt \"\
    0\" ]]; do\n    # we need to use \"bc\" because \"let\" does not support floating\n\
    \    # point arithmatic.\n    remainder=$(echo \"scale=0; $quotient % $divisor\"\
    \ | bc)\n    quotient=$(echo \"scale=0; $quotient / $divisor\" | bc)\n    new_number=$remainder$new_number\n\
    \  done\n  echo \"$new_number\"", "  local number=\"$1\"\n  local base=\"$2\"\n\
    \  (( number < base )) && echo \"$number\" && return 0\n  printf \"%d\\n\" \"\
    $(( number % base ))\"\n  change_base \"$(( number / base ))\" \"$base\"", " \
    \   local x=$1\n    local base=$2\n    local res=\"\"\n    while [ $x -gt 0 ];\
    \ do\n        res=$(($x % $base))$res\n        x=$(($x / $base))\n    done\n \
    \   echo $res", "    local base=$2\n    local x=$1\n    if [ $x -lt $base ]; then\n\
    \        echo $x\n    else\n        local y=$(($x/$base))\n        local n=$(($x%$base))\n\
    \        local n_str=$(change_base $y $base)\n        echo $n_str$n\n    fi",
  "  local x=$1 base=$2\n  local result=\"\"\n\n  while [ $x -gt 0 ]; do\n    result=\"\
    $((x % base))$result\"\n    x=$((x / base))\n  done\n\n  echo $result", "  local\
    \ -i x=$1\n  local -i base=$2\n  local representation=\"\"\n  while [ $x -gt 0\
    \ ]; do\n    representation=\"$(($x % $base))${representation}\"\n    x=$(($x\
    \ / $base))\n  done\n  echo $representation", "  local x=\"$1\"\n  local base=\"\
    $2\"\n  # set of used digits in the target base\n  digits=\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n  if [ \"$x\" -eq 0 ]; then\n    echo 0\n  else\n    local r=\"\"\n    local\
    \ i=0\n    while [ \"$x\" -gt 0 ]; do\n      i=$(( $x % $base ))\n      r=\"${digits:$i:1}$r\"\
    \n      x=$(( $x / $base ))\n    done\n    echo \"$r\"\n  fi", "    local x=$1\n\
    \    local base=$2\n    local base_x=\"\"\n    local r=\"\"\n    local i=\"\"\n\
    \    local stop=\"\"\n    [ $base -le 0 ] && echo -e \"base number must be more\
    \ than 0\" >&2 && exit 1\n    # divide x by base until x < base\n    while [ $x\
    \ -ge $base ]; do\n        stop=$(($x % $base))\n        x=$(($x / $base))\n \
    \       base_x=\"$stop$base_x\"\n    done\n    # the last digit is less than base\n\
    \    [ $x -lt $base ] && base_x=\"$x$base_x\"\n    echo \"$base_x\"", "  base=\"\
    $2\"\n  x=\"$1\"\n  result=\"\"\n  while (( x > 0 )); do\n    y=$(( x % base ))\n\
    \    result=\"$y$result\"\n    x=$(( x / base ))\n  done\n  echo \"$result\"",
  "  python3 <<EOF\nfrom sys import argv\nfrom math import log\nfrom math import floor\n\
    \nx = int(argv[1])\ny = int(argv[2])\nif y < 2:\n  raise ValueError(\"base must\
    \ be greater than 1.\")\nx_ = int(floor(log(x, y)))\nret = \"\"\nwhile x_ >= 0:\n\
    \  xi = x // y**x_\n  ret += str(xi)\n  x -= xi * y**x_\n  x_ -= 1\nprint(ret)\n\
    EOF", "    x=$1\n    base=$2\n    res=\"\"\n    rem=0\n    while [ $x -gt 0 ];\
    \ do\n        rem=$((x % base))\n        x=$((x / base))\n        res=$rem$res\n\
    \    done\n    echo $res", "  n=$1\n  base=$2\n  ret=\"\"\n  while [[ $n -ne 0\
    \ ]]; do\n    ret=\"$(($n % $base))$ret\"\n    n=$(($n / $base))\n  done\n  echo\
    \ $ret", "\tlocal num=$1\n\tlocal base=$2\n\tlocal result=\"\"\n\tlocal remainder=0\n\
    \twhile [[ $num -gt 0 ]]; do\n\t\tremainder=$((num % base))\n\t\tnum=$((num /\
    \ base))\n\t\tresult=\"$remainder$result\"\n\tdone\n\techo \"$result\"", "   \
    \ local number=$1\n    local base=$2\n    local divisor=1\n    local result=\"\
    \"\n    local digit\n    while [ $number -ge $divisor ]; do\n        divisor=$(($divisor\
    \ * $base))\n    done\n    divisor=$(($divisor / $base))\n    while [ $divisor\
    \ -gt 0 ]; do\n        digit=$(($number / $divisor))\n        result=$result$digit\n\
    \        number=$(($number % $divisor))\n        divisor=$(($divisor / $base))\n\
    \    done\n    echo $result", "  local -r x=\"$1\"\n  local -r base=\"$2\"\n \
    \ local -r digits=\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  local -r powers=\"\
    1 2 4 8 16 32 64 128 256 512 1024 2048 4096 8192 16384 32768 65536 131072 262144\
    \ 524288 1048576 2097152 4194304 8388608 16777216 33554432 67108864 134217728\
    \ 268435456 536870912 1073741824 2147483648 4294967296 8589934592 17179869184\
    \ 34359738368 68719476736 137438953472 274877906944 549755813888 1099511627776\
    \ 2199023255552 4398046511104 8796093022208 17592186044416 35184372088832 70368744177664\
    \ 140737488355328 281474976710656 562949953421312 1125899906842624 2251799813685248\
    \ 4503599627370496 9007199254740992 18014398509481984 36028797018963968 72057594037927936\
    \ 144115188075855872 288230376151711744 576460752303423488 1152921504606846976\
    \ 2305843009213693952 4611686018427387904 9223372036854775808 18446744073709551616\"\
    \n  local -r digits_array=($digits)\n  local -r powers_array=($powers)\n  local\
    \ -i i=0\n  local -i n=0\n  local -i x_base=\"$base\"\n  local -i quotient=0\n\
    \  local -i remainder=0\n  local -i i=0\n  local -i j=0\n  local -i k=0\n  local\
    \ -i current_quotient=0\n  local -i current_remainder=0\n  local -i current_digit=0\n\
    \  local -i current_power=0\n  local -i temp=0\n  local -i current_power_of_base=0\n\
    \  local -", "    local x=\"$1\"\n    local base=\"$2\"\n    local out=\n    #\
    \ return values >= 10 are the letter of the alphabet\n    # upper case\n    local\
    \ alphabet=(\n        A\n        B\n        C\n        D\n        E\n        F\n\
    \        G\n        H\n        I\n        J\n        K\n        L\n        M\n\
    \        N\n        O\n        P\n        Q\n        R\n        S\n        T\n\
    \        U\n        V\n        W\n        X\n        Y\n        Z\n    )\n   \
    \ local remainder=0\n    local result=\n    local y=\n    local i=\n    # save\
    \ original value in case we need it later\n    result=\"$x\"\n    while [[ $x\
    \ -gt 0 ]]; do\n        let remainder=\"$x % $base\"\n        let x=\"$x / $base\"\
    \n        y=\"$remainder\"\n        # if the value is >= 10, we need to get the\n\
    \        # letter of the alphabet\n        if [[ $remainder -ge 10 ]]; then\n\
    \            # need to subtract 10 from the value, and then\n            # the\
    \ index into the alphabet\n            let i=\"$remainder - 10\"\n           \
    \ y=\"${alphabet[$i]}\"\n        fi\n        out=\"$y$out\"\n    done\n    # if\
    \ the result is empty, add the original value\n    # to it\n    if [[ -z \"$out\"\
    \ ]]; then\n        out=\"$result\"\n    fi\n    echo \"$out\"", "    local x=$1\n\
    \    local base=$2\n    local new_number=()\n    while ((x > 0)); do\n       \
    \ local new_digit=$((x % base))\n        new_number+=(\"$new_digit\")\n      \
    \  x=$((x / base))\n    done\n    echo \"${new_number[@]}\" | tac | tr -d ' '",
  "  [ \"$#\" -ne 2 ] && >&2 echo \"Use $0 <integer> <base>\" && exit 1\n  n=\"$1\"\
    \n  b=\"$2\"\n  r=\"\"\n  while ((n > 0)); do\n    r=\"$(printf \"%d\" $((n %\
    \ b)))$r\"\n    n=$((n / b))\n  done\n  echo \"$r\"", '  echo "obase=$2; ibase=10;
    $1" | bc', "    local number=$1\n    local base=$2\n    local result=0\n    local\
    \ i=0\n    while [ \"$number\" -gt 0 ]; do\n        local digit=$((number % base))\n\
    \        number=$((number / base))\n        if [ \"$digit\" -eq 0 ]; then\n  \
    \          result=$((result + (1 << i)))\n        fi\n        i=$((i + 1))\n \
    \   done\n    echo \"$result\"", "  local x=$1\n  local base=$2\n  local res=$((x\
    \ % base))\n  if [ $x -eq 0 ]; then\n    echo $res\n  else\n    echo $(change_base\
    \ $(( x / base )) $base)$res\n  fi", "  if [[ -z \"$1\" || -z \"$2\" ]]; then\n\
    \    return 1\n  fi\n  if [[ \"$2\" -ge 10 ]]; then\n    return 1\n  fi\n  local\
    \ x=\"$1\"\n  local base=\"$2\"\n  local result=\"\"\n  local remainder\n  while\
    \ [[ \"$x\" -gt 0 ]]; do\n    let \"remainder = $x % $base\"\n    let \"x = $x\
    \ / $base\"\n    result=\"$remainder$result\"\n  done\n  echo \"$result\"", " \
    \   local x=$1\n    local base=$2\n    local result=''\n    local num=$x\n   \
    \ local r\n    while [ $num -ne 0 ]; do\n        r=$(( num % base ))\n       \
    \ num=$(( num / base ))\n        result=\"$r$result\"\n    done\n    echo $result",
  "\tlocal x=$1\n\tlocal base=$2\n\tlocal res=()\n\tlocal result\n\n\t[[ $x -lt $base\
    \ ]] && echo $x && return 0\n\twhile [[ $x -ge $base ]]; do\n\t\tres+=( $(($x\
    \ % $base)) )\n\t\tx=$(($x / $base))\n\tdone\n\tres+=( $x )\n\t# echo res: \"\
    ${res[@]}\"\n\tresult=$(printf \"%s\" \"${res[@]}\")\n\techo \"${result// /}\"",
  "  local x=$1\n  local base=$2\n  if [ $x -eq 0 ]; then\n    echo 0\n  else\n  \
    \  local y=$((x % base))\n    local z=$(change_base $((x / base)) $base)\n   \
    \ echo \"$z$y\"\n  fi", '    echo "obase=$2;ibase=10;$1" | bc', "\tlocal x=\"\
    $1\"\n\tlocal base=\"$2\"\n\tlocal out=\"\"\n\tlocal m=\"\"\n\twhile [ \"$x\"\
    \ -ne 0 ]; do\n\t\t(( m = x % base ))\n\t\tx=$(( x / base ))\n\t\tout=\"$m$out\"\
    \n\tdone\n\techo $out", '    printf "obase=%s;%s\n" "$2" "$1" | bc', "  local\
    \ number=$1; shift\n  local base=$1; shift\n  local div\n  local rem\n  while\
    \ [[ $number -ne 0 ]]; do\n    div=$(( number / base ))\n    rem=$(( number %\
    \ base ))\n    printf '%s' \"$rem\"\n    number=$div\n  done", "  local base=$1\n\
    \  local decimal_number=$2\n  local change_base_result=\"\"\n  if [[ $decimal_number\
    \ -eq 0 ]]; then\n    change_base_result=\"0\"\n  else\n    while [[ $decimal_number\
    \ -ne 0 ]]; do\n      change_base_result=\"$((decimal_number % base))$change_base_result\"\
    \n      decimal_number=$((decimal_number / base))\n    done\n  fi\n  echo \"$change_base_result\"",
  "    local result=''\n    local div=$1\n    local base=$2\n    while [ $div -ne\
    \ 0 ]; do\n        local remainder=$((div % base))\n        result=$remainder$result\n\
    \        div=$((div / base))\n    done\n    echo $result", "    local num\n  \
    \  let num=$1\n    local base\n    let base=$2\n    local res=\"\"\n    local\
    \ remainder\n\n    while [ \"$num\" -gt 0 ]; do\n        let remainder=$num%$base\n\
    \        num=$num/$base\n        res=\"$remainder$res\"\n    done\n    echo \"\
    $res\"", "    # $1 -> x\n    # $2 -> base\n    local x=$1\n    local base=$2\n\
    \    local stack\n    while (( x >= base ))\n    do\n        stack+=$(( x % base\
    \ ))\n        x=$(( x / base ))\n    done\n    stack+=$x\n    echo $stack", " \
    \ local num=$1\n  local base=$2\n  local res=\"\"\n  if [[ $num -eq 0 ]]; then\n\
    \    res=\"0\"\n  else\n    while [[ $num -gt 0 ]]; do\n      local digit=$((\
    \ num % base ))\n      res=\"$digit$res\"\n      num=$(( num / base ))\n    done\n\
    \  fi\n  echo \"$res\"", "    local x=$1\n    local base=$2\n    declare -a output=()\n\
    \    local mod\n    while [[ $x -ne 0 ]]; do\n        mod=$((x % base))\n    \
    \    x=$((x / base))\n        output=(\"$mod\" \"${output[@]}\")\n    done\n \
    \   echo \"${output[@]}\"", "    local x=$1\n    local base=$2\n    local res=\"\
    \"\n    if [ $x -lt $base ]; then\n        res=\"$x\"\n    else\n        local\
    \ q=$(($x / $base))\n        local r=$(($x % $base))\n        res=\"$(change_base\
    \ $q $base)$r\"\n    fi\n    echo $res", '    echo "obase=$2; ibase=10; $1" |
    bc', "    local input=$1\n    local base=$2\n    local i\n    local num\n    local\
    \ result\n\n    for ((i=0; i<$input; i++)); do\n        num=$(($input % $base))\n\
    \        input=$(($input / $base))\n        result=$num$result\n    done\n   \
    \ echo $result", "  num=$1\n  base=$2\n  if ((num < 0)); then\n    echo \"Error:\
    \ number < 0\"\n    exit 1\n  fi\n  if ((base < 2 || base > 10)); then\n    echo\
    \ \"Error: base should be in range [2, 10]\"\n    exit 1\n  fi\n  if ((num < base));\
    \ then\n    echo $num\n    return\n  fi\n  # Keep dividing the number by base\
    \ until it is less than base.\n  # Use an array to store the quotient and remainder.\n\
    \  # The remainders are the digits of the converted number.\n  # Reverse the array\
    \ and concatenate the elements to get the result.\n  # Note: bash array starts\
    \ from 0.\n  #\n  # Example:\n  # Convert 7 from base 10 to base 2.\n  # 7 / 2\
    \ = 3 remainder 1\n  # 3 / 2 = 1 remainder 1\n  # 1 / 2 = 0 remainder 1\n  # Reverse\
    \ the array, concatenate all elements,\n  # then get 111 as the result.\n  #\n\
    \  # num_array stores the remainders.\n  num_array=()\n  # Loop until the number\
    \ is less than base.\n  while ((num >= base)); do\n    rem=$((num % base))\n \
    \   num=$((num / base))\n    num_array+=($rem)\n  done\n  # Append the last number\
    \ (less than base) to the array.\n  num_array+=($num)\n  # Loop from the end of\
    \ the array and concatenate the elements.\n  # Build the result string.\n  result_str=\"\
    \"\n  for ((i=${#num_array[@]}-1; i>=0; i--)); do\n    result_str+=\"${num_array[$i]}\"\
    \n  done\n  echo $result_str", "    local x=\"$1\"\n    local base=\"$2\"\n  \
    \  local res=0\n    local i=0\n    while [[ $x -gt 0 ]]; do\n        res=$((($x\
    \ % $base) * $((10 ** $i)) + $res))\n        i=$((i + 1))\n        x=$((x / $base))\n\
    \    done\n    echo \"$res\"", "  local x=\"$1\"\n  local base=\"$2\"\n  local\
    \ quotient=\"$x\"\n  local remainder\n  local ret=\"\"\n  while [ \"$quotient\"\
    \ -ge \"$base\" ]; do\n    remainder=$((quotient % base))\n    quotient=$((quotient\
    \ / base))\n    ret=\"$remainder$ret\"\n  done\n  echo \"$quotient$ret\"", " \
    \ local x=$1\n  local base=$2\n  declare -a result\n\n  while [ $x -gt 0 ]; do\n\
    \    local digit=$((x % base))\n    x=$((x / base))\n    result+=(\"$digit\")\n\
    \  done\n\n  local result=$(\n    for (( i = ${#result[@]} - 1; i >= 0; i-- ));\
    \ do\n      echo -n \"${result[i]}\"\n    done\n  )\n\n  echo \"$result\"", " \
    \ result=\"\"\n  local x=$1\n  local base=$2\n  local remainder=0\n  while [ $x\
    \ -gt 0 ]; do\n    remainder=$(( x % base ))\n    x=$(( x / base ))\n    result=\"\
    $remainder$result\"\n  done\n  echo $result", "    local -i x=$1\n    local -i\
    \ base=$2\n    local -i remainder=0\n    local -i digit=0\n    local str=\"\"\n\
    \    if (( x < base )); then\n        echo \"$x\"\n        return\n    fi\n  \
    \  remainder=$(( x % base ))\n    x=$(( x / base ))\n    change_base \"$x\" \"\
    $base\"\n    echo -n \"$remainder\"", "  x=$1\n  base=$2\n  ret=\"\"\n  while\
    \ ((x > 0)); do\n    ret=\"$(($x % $base))$ret\"\n    x=$(($x / $base))\n  done\n\
    \  echo $ret", "    # tr and bc\n    echo \"obase=$2; ibase=10; $1\" | bc | tr\
    \ -d '\\\\\\n'", "\tif [[ ! \"$1\" =~ ^[0-9]+$ ]]; then\n\t\tprintf \"Invalid\
    \ input.\"\n\t\treturn\n\tfi\n\tif [[ ! \"$2\" =~ ^[0-9]+$ ]]; then\n\t\tprintf\
    \ \"Invalid input.\"\n\t\treturn\n\tfi\n\tlocal x=$1;\n\tlocal base=$2;\n\tlocal\
    \ result=\"\";\n\twhile [[ \"$x\" -gt 0 ]]; do\n\t\tlocal rem=$((x % base));\n\
    \t\tresult=$rem$result;\n\t\tx=$((x / base));\n\tdone\n\tprintf \"$result\";",
  "  local number=\"$1\"\n  local base=\"$2\"\n  local result=\"\"\n  local remainder=0\n\
    \  local quotient=0\n  local tmp_number=\"$number\"\n  local digit=0\n  while\
    \ [ \"$tmp_number\" -ne 0 ]; do\n    # modulo\n    remainder=$((tmp_number % base))\n\
    \    quotient=$((tmp_number / base))\n    tmp_number=\"$quotient\"\n    # append\
    \ the remainder\n    result=\"$remainder$result\"\n  done\n  echo \"$result\"",
  "\tlocal -i x=$1\n\tlocal -i base=$2\n\tlocal result=\"\"\n\twhile ((x>0)); do\n\
    \t\tresult=$(echo -n \"$x%$base\")$result\n\t\tx=$x/$base\n\tdone\n\techo \"$result\"",
  "  local result=\"\"\n  local current_base=$2\n  local i=0\n  local x=$1\n  local\
    \ d=$(base10_to_base64 $x)\n  while true; do\n    local remainder=$(($d % $current_base))\n\
    \    d=$(($d / $current_base))\n    if [[ $remainder == 0 ]]; then\n      result+=\"\
    0\"\n    else\n      result+=\"1\"\n    fi\n    i=$(($i + 1))\n    if [[ $d ==\
    \ 0 ]]; then\n      break\n    fi\n  done\n  echo ${result::-1}", "    local number=\"\
    $1\"\n    local base=\"$2\"\n    local x=0\n    local result=\"\"\n    echo \"\
    base is $base number is $number\"\n    for i in $(seq 1 $(($base-1))); do\n  \
    \      x=$(($number % $base))\n        number=$(($number / $base))\n        result=\"\
    $x$result\"\n    done\n    echo \"$result\"", "    local num=$1\n    local base=$2\n\
    \    local res=\"\"\n    while [[ $num -gt 0 ]]; do\n        res=\"$(($num % $base))$res\"\
    \n        num=$(($num / $base))\n    done\n    echo $res", "    local out=0\n\
    \    if [[ $1 -lt 0 ]]; then\n        echo \"The number can not be negative.\"\
    \ >&2\n        return 1\n    fi\n    if [[ $2 -lt 2 ]]; then\n        echo \"\
    The base can not be less than 2.\" >&2\n        return 1\n    fi\n    while [[\
    \ $1 -gt 0 ]]; do\n        out=$(( $1 % $2 ))\n        out=$out$out\n        ((\
    \ $1 /= $2 ))\n    done\n    echo $out", "\tlocal x=$1\n\tlocal base=$2\n\tlocal\
    \ r=\"\"\n\twhile [ $x -gt 0 ]; do\n\t\tr=$(($x % $base))$r\n\t\tx=$(($x / $base))\n\
    \tdone\n\techo $r", "    local x=$1\n    local base=$2\n    result=\"\"\n    while\
    \ [ $x -ne 0 ]; do\n        local mod=$((x % base))\n        result=\"$mod$result\"\
    \n        x=$((x / base))\n    done\n    echo $result", "  local res=\"\"\n  local\
    \ n=$1\n  local base=$2\n  local quotient=1\n  local remainder=0\n  while [ $quotient\
    \ -ne 0 ]; do\n    remainder=$(( n % base ))\n    n=$(( n / base ))\n    res=\"\
    $remainder$res\"\n    quotient=$n\n  done\n  echo $res", "  local num\n  local\
    \ new_num\n  local rest\n  local base\n  local digits=\"0123456789\"\n  local\
    \ p\n\n  base=${2:-10}\n  if [ \"$base\" -gt 10 ]; then\n    p=3\n  else\n   \
    \ p=2\n  fi\n\n  num=$1\n  new_num=\"\"\n  rest=0\n  while [ \"$num\" -gt 0 ];\
    \ do\n    rest=$(( num % base ))\n    num=$(( num / base ))\n    new_num=\"${digits:$rest:1}${new_num}\"\
    \n  done\n  echo $new_num", "\tlocal x=$1\n\tlocal base=$2\n\tlocal quotient=${x}\n\
    \tlocal remainder=0\n\tlocal ret=\"\"\n\twhile [ ${quotient} -gt 0 ]; do\n\t\t\
    remainder=$((${quotient} % ${base}))\n\t\tquotient=$((${quotient} / ${base}))\n\
    \t\tret=\"${remainder}${ret}\"\n\tdone\n\techo \"${ret}\"", "    local x=\"$1\"\
    \n    local base=\"$2\"\n    local conv_x\n    conv_x=''\n    for (( ; x > 0;\
    \ x /= base )); do\n        conv_x=\"$(( x % base ))$conv_x\"\n    done\n    if\
    \ [ \"$x\" -eq \"0\" ]; then\n        conv_x=\"0$conv_x\"\n    fi\n    echo \"\
    $conv_x\"", "  local x=$1\n  local base=$2\n  local a=0\n  local b=0\n  local\
    \ c=0\n  local d=0\n  local num\n  local res\n  local i=0\n  local j=0\n  local\
    \ r_sz=$(echo \"obase=$base; ibase=10; $x\" | bc)\n  local size=${#r_sz}\n  local\
    \ arr\n  local tmp\n\n  # replace base if necessary\n  case $base in\n    \"2\"\
    )\n      num=2\n      ;;\n    \"3\")\n      num=3\n      ;;\n    \"4\")\n    \
    \  num=4\n      ;;\n    \"5\")\n      num=5\n      ;;\n    \"6\")\n      num=6\n\
    \      ;;\n    \"7\")\n      num=7\n      ;;\n    \"8\")\n      num=8\n      ;;\n\
    \    \"9\")\n      num=9\n      ;;\n    *)\n      num=10\n      ;;\n  esac\n\n\
    \  while true; do\n    tmp=$((x%num))\n    arr[i]=$tmp\n    x=$((x/num))\n   \
    \ if [ $x -eq 0 ]; then\n      break\n    fi\n    i=$((i+1))\n  done\n\n  for\
    \ (( j=i; j>=0; j-- )); do\n    if [ $j -eq 0 ]; then\n      echo -n \"${arr[j]}\"\
    \n    else\n      echo -n \"${arr[j]} \"\n    fi\n  done", "\techo \"$1\" | awk\
    \ '{printf \"%s\", $1}' | sed -e 's/^/ibase=10;/' -e \"s/$/;obase=$2;/\" | bc",
  "  local x=\"$1\"\n  local base=\"$2\"\n  local y=\"\"\n  local r\n  while [ \"\
    $x\" -gt 0 ]; do\n    r=$((x % base))\n    x=$((x / base))\n    y=\"$r$y\"\n \
    \ done\n  echo \"$y\"", "  local n=\"$1\"\n  local d=\"$2\"\n  local q\n  local\
    \ r\n  local r_str\n\n  q=${n}\n  r_str=\"\"\n  while true\n  do\n    r=$((${q}\
    \ % ${d}))\n    q=$((${q} / ${d}))\n    r_str=\"${r}${r_str}\"\n    if [ ${q}\
    \ -eq 0 ]; then\n      break\n    fi\n  done\n  echo \"${r_str}\"", '    echo
    "obase=$2; ibase=10; $1" | bc', '    bc <<< "obase=$2; ibase=10; $1"', "\tlocal\
    \ x=\"$1\"\n\tlocal base=\"$2\"\n\tlocal base_num\n\tbase_num=$(echo \"obase=$base;\
    \ $x\" | bc)\n\techo \"$base_num\"", "    # base number is less than 10\n    if\
    \ [[ $2 -gt 10 ]]; then\n        echo -1\n        return\n    fi\n    # convert\
    \ to base-10\n    n=$(echo \"ibase=${2};${1}\" | bc)\n    # convert to new base\n\
    \    echo \"obase=${2};${n}\" | bc", "    local x=$1\n    local base=$2\n    if\
    \ [ ${base} -lt 10 ]; then\n        local result=\"\"\n        local i=$x\n  \
    \      local c\n        while [ ${i} -gt 0 ]; do\n            c=$((${i} % ${base}))\n\
    \            i=$((${i} / ${base}))\n            result=\"${c}${result}\"\n   \
    \     done\n        echo ${result}\n    else\n        echo \"base must be an integer\
    \ less than 10.\"\n    fi", "    local x=\"$1\"\n    local base=\"$2\"\n    local\
    \ out=\"\"\n    local remainder\n\n    while [ $x -gt 0 ]; do\n        remainder=$((x\
    \ % base))\n        x=$((x / base))\n        out=\"$remainder$out\"\n    done\n\
    \n    echo \"$out\"", "    local number=$1\n    local base=$2\n    local tmp\n\
    \    local i\n\n    local quotient\n    local remainder\n\n    if [ $base -lt\
    \ 10 ]; then\n        i=0\n        tmp=\"\"\n        while (( $number > 0 ));\
    \ do\n            quotient=$(($number / $base))\n            remainder=$(($number\
    \ % $base))\n            number=$quotient\n            tmp=$(echo -e \"$remainder$tmp\"\
    )\n            i=$(($i + 1))\n        done\n        echo \"$tmp\"\n    else\n\
    \        echo $number\n    fi", "    local num=$1\n    local base=$2\n    local\
    \ val=\"\"\n    local i\n    # split num into n-digits\n    while [ $num -ne 0\
    \ ]; do\n        i=$((num % base))\n        val=$i$val\n        num=$((num / base))\n\
    \    done\n    echo $val", "    local x=\"$1\"\n    local base=\"$2\"\n    local\
    \ out=\"\"\n    while (( $x > 0 )); do\n        r=$(( $x % $base ))\n        x=$((\
    \ $x / $base ))\n        out=\"$r$out\"\n    done\n    echo $out", "  local n=\"\
    $1\"\n  local base=\"$2\"\n  local str=\"\"\n  while true; do\n    local mod=\"\
    $(($n % $base))\"\n    n=\"$(($n / $base))\"\n    str=\"$mod$str\"\n    if [[\
    \ \"$n\" -eq 0 ]]; then\n      break\n    fi\n  done\n  echo \"$str\"", "  local\
    \ x=\"$1\"\n  local base=\"$2\"\n  if [[ $x -ge $base ]]; then\n    local y=$(($x\
    \ / $base))\n    local r=$(($x % $base))\n    change_base \"$y\" \"$base\" \"\
    $r\"\n  else\n    echo $x\n  fi", "\tx=\"$1\"\n\tbase=\"$2\"\n\twhile [ \"$x\"\
    \ -gt 0 ]; do\n\t\t#echo \"$x\"\n\t\tq=\"$(($x / $base))\"\n\t\tr=\"$(($x % $base))\"\
    \n\t\t#echo \"$r\"\n\t\tx=\"$q\"\n\t\tr_list=\"$r $r_list\"\n\tdone\n\techo \"\
    $r_list\"", "    local -r x=$1\n    local -r base=$2\n    local -r convert=$(dc\
    \ &lt;&lt;&lt; \"$x $base o p\")\n    local -r convert_len=${#convert}\n    local\
    \ -r padding=$((base - convert_len))\n    local -r out=$(printf \"%0${padding}d\"\
    \ 0)${convert}\n    echo \"$out\"", "  number=$1\n  base=$2\n  output=\"\"\n \
    \ while [ \"$number\" -ne 0 ]; do\n    remainder=$((number % base))\n    output=\"\
    $remainder$output\"\n    number=$((number / base))\n  done\n  echo \"$output\""]
stop_tokens:
- "\n}"
