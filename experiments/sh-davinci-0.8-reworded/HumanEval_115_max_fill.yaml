name: HumanEval_115_max_fill
language: sh
prompt: "#!/bin/bash\n# You are given a rectangular grid of wells. Each row represents\
  \ a single well,\n# and each 1 in a row represents a single unit of water.\n# Each\
  \ well has a corresponding bucket that can be used to extract water from it, \n\
  # and all buckets have the same capacity.\n# Your task is to use the buckets to\
  \ empty the wells.\n# Output the number of times you need to lower the buckets.\n\
  # Example 1:\n# >>> $(max_fill \"0 0 1 0\\n0 1 0 0\\n1 1 1 1\" \"1\")\n# \"6\"\n\
  # Example 2:\n# >>> $(max_fill \"0 0 1 1\\n0 0 0 0\\n1 1 1 1\\n0 1 1 1\" \"2\")\n\
  # \"5\"\n# Example 3:\n# >>> $(max_fill \"0 0 0\\n0 0 0\" \"5\")\n# \"0\"\n# Constraints:\n\
  # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
  \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\n#\n# $1 is a newline-separated,\
  \ space-separated list\n# $2 is an integer\nmax_fill() {\n"
tests: "}\n\ncandidate() {\n    max_fill \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
  \ $(candidate \"0 0 1 0\\n0 1 0 0\\n1 1 1 1\" \"1\") = \"6\" ]]\n    [[ $(candidate\
  \ \"0 0 1 1\\n0 0 0 0\\n1 1 1 1\\n0 1 1 1\" \"2\") = \"5\" ]]\n    [[ $(candidate\
  \ \"0 0 0\\n0 0 0\" \"5\") = \"0\" ]]\n    [[ $(candidate \"1 1 1 1\\n1 1 1 1\"\
  \ \"2\") = \"4\" ]]\n    [[ $(candidate \"1 1 1 1\\n1 1 1 1\" \"9\") = \"2\" ]]\n\
  }\n\nrun_test"
completions: ["  echo \"$1\" | while read line; do\n    echo \"$line\" | while read\
    \ water; do\n      echo \"$water\"\n    done\n  done", "    local grid=$1\n  \
    \  local capacity=$2\n    local lines=$(echo \"$grid\" | wc -l)\n    local wells=$(echo\
    \ \"$grid\" | cut -d \" \" -f 1)\n    local cur_fill=0\n    local num_passes=0\n\
    \    local div=0\n    local rem=0\n    for l in $wells; do\n        cur_fill=$(($cur_fill\
    \ + $l))\n        if [ $cur_fill -gt $capacity ]; then\n            div=$(($cur_fill\
    \ / $capacity))\n            rem=$(($cur_fill % $capacity))\n            cur_fill=$rem\n\
    \            num_passes=$(($num_passes + $div))\n        fi\n    done\n    if\
    \ [ $cur_fill -gt 0 ]; then\n        num_passes=$(($num_passes + 1))\n    fi\n\
    \    echo $num_passes", "    echo $1\n    echo $2", "    local grid=$1\n    local\
    \ capacity=$2\n    local read -r -a wells < <(echo \"$grid\" | awk '{print $1}')\n\
    \    local read -r -a lengths < <(echo \"$grid\" | awk '{print length($1)}')\n\
    \    local fill=0\n    local depth=0\n    local curr_well=0\n    local curr_length=0\n\
    \    local curr_well_pos=0\n    local i=0\n    local j=0\n    local k=0\n    local\
    \ l=0\n    for i in \"${!wells[@]}\"; do\n        for j in $(seq 1 \"${lengths[$i]}\"\
    ); do\n            if [ \"${wells[$i]:j-1:1}\" == \"1\" ]; then\n            \
    \    if [ \"$fill\" -lt \"$capacity\" ]; then\n                    fill=$((fill+1))\n\
    \                else\n                    depth=$((depth+1))\n              \
    \      fill=1\n                fi\n            fi\n        done\n    done\n  \
    \  echo \"$depth\"", "  IFS=$'\\n' read -d '' -r -a grid <<< \"$1\"\n  capacity=\"\
    $2\"\n  row_count=${#grid[@]}\n  col_count=${#grid[0]}\n  for ((i=0; i<$row_count;\
    \ i++)); do\n    echo ${grid[$i]}\n  done\n  echo $capacity", "  # your solution\
    \ here\n  :", "  local grid=\"$1\"\n  local capacity=\"$2\"\n  local count=0\n\
    \  echo \"$grid\" | while read -r line; do\n    count=$((count + (line.replace(\"\
    \ \", \"\").count(\"1\")) / capacity))\n  done\n  echo \"$count\"", "    local\
    \ grid=$1\n    local capacity=$2\n    local i=0\n    local j=0\n    local water=0\n\
    \    local lower=0\n    for row in $grid; do\n        for well in $row; do\n \
    \           if [ $well -eq 1 ]; then\n                water=$(($water + 1))\n\
    \            fi\n        done\n    done\n    if [ $water -eq 0 ]; then\n     \
    \   echo $lower\n        return\n    fi\n    local max_fill=$(($capacity * $water))\n\
    \    local row_count=$(echo $grid | wc -l)\n    local row_len=$(echo $grid | head\
    \ -n 1 | wc -w)\n    while [ $i -lt $row_count ]; do\n        while [ $j -lt $row_len\
    \ ]; do\n            if [ $(echo $grid | cut -d \" \" -f $(($j + 1)) -s | head\
    \ -n $(($i + 1)) | tail -n 1) -eq 1 ]; then\n                local fill=$(($fill\
    \ + 1))\n            fi\n            if [ $fill -eq $max_fill ]; then\n      \
    \          lower=$(($lower + 1))\n                local fill=0\n            fi\n\
    \            j=$(($j + 1))\n        done\n        j=0\n        i=$(($i + 1))\n\
    \    done\n    echo $lower", "    # your code here\n    local grid=\"$1\"\n  \
    \  local capacity=\"$2\"\n    local num_rows=$(echo \"$grid\" | wc -l)\n    local\
    \ num_cols=$(echo \"$grid\" | head -n 1 | awk '{print NF}')\n    local max_col_sum=$(echo\
    \ \"$grid\" | awk '{for(i=1;i<=NF;i++)a[i]+=$i}END{for(i in a)printf(\"%d%s\"\
    ,a[i],i==NF?\"\\n\":\" \")}')\n    echo \"$max_col_sum\"\n    local count=0\n\
    \    while [[ \"$(echo \"$max_col_sum\" | tr \" \" \"\\n\" | sort -n | tail -n\
    \ 1)\" -gt \"$capacity\" ]]; do\n        for i in $(seq 1 \"$num_cols\"); do\n\
    \            if [[ \"$(echo \"$max_col_sum\" | cut -d \" \" -f \"$i\")\" -gt \"\
    $capacity\" ]]; then\n                for j in $(seq 1 \"$num_rows\"); do\n  \
    \                  if [[ \"$(echo \"$grid\" | head -n \"$j\" | tail -n 1 | cut\
    \ -d \" \" -f \"$i\")\" -eq \"1\" ]]; then\n                        grid=$(echo\
    \ \"$grid\" | head -n \"$j\" | tail -n 1 | awk '{$i=0;print}' i=\"$i\")\n    \
    \                    echo \"$grid\"\n                        count=$((count+1))\n\
    \                        max_col_sum=$(echo \"$grid\" | awk '{for(i=1;i<=NF;i++)a[i]+=$i}END{for(i\
    \ in a)printf(\"%d%s\",a[i],i==NF?\"\\n\":\" \")}')\n                        echo\
    \ \"$max_col_sum\"\n                        break\n                    fi\n  \
    \              done\n            fi\n        done\n    done\n    echo \"$count\"",
  "  local -i max_fill total\n  max_fill=0\n  for col in $(echo \"$1\" | cut -d' '\
    \ -f1 | tr -d '\\n'); do\n    if [ \"$col\" -eq \"1\" ]; then\n      total=$((total\
    \ + 1))\n    else\n      if [ \"$total\" -gt \"$max_fill\" ]; then\n        max_fill=$total\n\
    \      fi\n      total=0\n    fi\n  done\n  echo $((max_fill/2))", "    local\
    \ grid wells=$(echo \"$1\" | wc -l)\n    local fill_count=0 capacity=$2 row_count=0\n\
    \    for row in $(echo \"$1\"); do\n        row_count=$((row_count + 1))\n   \
    \     for well in $(echo \"$row\"); do\n            ((well == 1)) && fill_count=$((fill_count\
    \ + capacity))\n        done\n    done\n    echo $((fill_count / wells))", " \
    \   local max_row_water=0\n    local row_water=0\n    local water_after_drop=0\n\
    \    local row=()\n    local capacity=$2\n    local result=0\n    local i=0\n\
    \    local length=0\n    local x=0\n    read -r -a rows <<< \"$1\"\n    for row\
    \ in \"${rows[@]}\"; do\n        row_water=0\n        read -r -a row <<< \"$row\"\
    \n        i=0\n        length=${#row[@]}\n        while [[ $i -lt $length ]];\
    \ do\n            x=${row[$i]}\n            if [[ $x -eq 1 ]]; then\n        \
    \        ((row_water++))\n            fi\n            ((i++))\n        done\n\
    \        if [[ $row_water -gt $max_row_water ]]; then\n            max_row_water=$row_water\n\
    \        fi\n    done\n    water_after_drop=$(( max_row_water - capacity ))\n\
    \    if [[ $water_after_drop -lt 0 ]]; then\n        result=0\n    else\n    \
    \    result=$(( water_after_drop * ${#rows[@]} ))\n    fi\n    echo \"$result\"",
  "    local grid=$1; shift\n    local capacity=$1; shift\n    local height=$(echo\
    \ \"$grid\" | wc -l)\n    local width=$(echo \"$grid\" | head -n 1 | wc -w)\n\
    \    local total=0\n    for ((i=0; i<height; i++)); do\n        local row=$(echo\
    \ \"$grid\" | awk \"NR==$i+1\")\n        for ((j=0; j<width; j++)); do\n     \
    \       local column=$(echo \"$row\" | awk '{print $1}')\n            if [[ \"\
    $column\" == \"1\" ]]; then\n                total=$((total + 1))\n          \
    \  fi\n            row=$(echo \"$row\" | awk '{$1=\"\"; print}')\n        done\n\
    \    done\n    echo $((total / capacity))", "  local grid=\"\"\n  local capacity=\"\
    \"\n  local reduced=\"\"\n  local min_row=\"\"\n  local min_nonzero=\"\"\n  local\
    \ num_reductions=\"\"\n  grid=\"$1\"\n  capacity=\"$2\"\n  reduced=\"$grid\"\n\
    \  num_reductions=0\n  while true; do\n    min_row=$(echo \"$reduced\" | \\\n\
    \      perl -ne 'my @a = split /\\s+/; print scalar @a - 1, \" \", $_' | \\\n\
    \      sort -n | \\\n      head -n 1 | \\\n      perl -ne 's/\\d+\\s+//; chomp;\
    \ print')\n    if [ \"$min_row\" = \"\" ]; then\n      break\n    fi\n    min_nonzero=$(echo\
    \ \"$min_row\" | \\\n      perl -ne 'm/(1+)/g; print scalar length $1, \" \",\
    \ $_' | \\\n      sort -n | \\\n      head -n 1 | \\\n      perl -ne 's/\\d+\\\
    s+//; chomp; print')\n    if [ \"$min_nonzero\" = \"\" ]; then\n      break\n\
    \    fi\n    reduced=$(echo \"$reduced\" | \\\n      perl -ne 's/^(0+)\\s*/$1/;\
    \ chomp; print')\n    reduced=$(echo \"$reduced\" | \\\n      perl -ne 's/^$/0/;\
    \ chomp; print')\n    num_reductions=$((num_reductions + 1))\n  done\n  echo $num_reductions",
  "  echo \"$1\" |\\\n  awk -v c=$2 'BEGIN {\n    count = 0\n  } {\n    for (i = 1;\
    \ i <= NF; i++) {\n      if ($i == 1) {\n        count++\n      }\n    }\n  }\
    \ END {\n    printf(\"%d\", count * c)\n  }'", "  echo \"$1\" | awk -v capacity=\"\
    $2\" '\n      BEGIN {\n        OFS = \" \"\n      }\n      {\n        for (i =\
    \ 1; i <= NF; i++) {\n          if (1 == $i) {\n            next_well[i] = 1\n\
    \          }\n        }\n      }\n      END {\n        for (i = 1; i <= NF; i++)\
    \ {\n          if (next_well[i] == 1) {\n            current_well[i] = 1\n   \
    \       }\n        }\n        for (i = 1; i <= NF; i++) {\n          if (current_well[i]\
    \ == 1) {\n            fill_count++\n          }\n        }\n        print int(fill_count/capacity)\n\
    \      }\n  '", "    declare -a wells=(`echo $1 | tr \" \" \"\\n\"`)\n    capacity=$2\n\
    \    declare -i sum=0\n    for well in ${wells[@]}; do\n        sum=$((sum + well))\n\
    \    done\n    echo $(((sum + capacity - 1) / capacity))", "  local grid=\"$1\"\
    \n  local capacity=\"$2\"\n  local row_count=\"$(wc -l <<< \"$grid\")\"\n  local\
    \ column_count=\"$(head -n 1 <<< \"$grid\" | wc -w)\"\n  local max_row_value=0\n\
    \  local max_column_value=0\n  for row in $(seq 1 \"$row_count\"); do\n    local\
    \ row_value=\"$(sed -n \"${row}p\" <<< \"$grid\" | tr -cd 1 | wc -c)\"\n    ((\
    \ row_value > max_row_value )) && max_row_value=\"$row_value\"\n  done\n  for\
    \ column in $(seq 1 \"$column_count\"); do\n    local column_value=\"$(cut -d\
    \ \" \" -f \"$column\" <<< \"$grid\" | tr -cd 1 | wc -c)\"\n    (( column_value\
    \ > max_column_value )) && max_column_value=\"$column_value\"\n  done\n  local\
    \ iterations=$(( max_row_value + max_column_value ))\n  (( iterations > capacity\
    \ )) && iterations=\"$capacity\"\n  echo \"$iterations\"", "  declare -i rows\
    \ cols capacity\n  declare -ia wells\n  declare -i i j num_runs\n  # build wells\
    \ array\n  declare -a tmp_wells\n  read -r -a tmp_wells <<<\"$1\"\n  capacity=$2\n\
    \  rows=${#tmp_wells[@]}\n  cols=${#tmp_wells[0]}\n  num_runs=0\n  for ((i=0;\
    \ i<rows; i++)); do\n    wells[i]=()\n    for ((j=0; j<cols; j++)); do\n     \
    \ wells[i]+=(${tmp_wells[i]:j:1})\n    done\n  done\n  # find maximum row\n  declare\
    \ -i max_row\n  declare -ia max_row_totals\n  for ((i=0; i<rows; i++)); do\n \
    \   max_row_totals[i]=0\n    for ((j=0; j<cols; j++)); do\n      max_row_totals[i]=$((max_row_totals[i]\
    \ + wells[i][j]))\n    done\n  done\n  max_row=0\n  for ((i=1; i<rows; i++));\
    \ do\n    if [[ ${max_row_totals[i]} -gt ${max_row_totals[max_row]} ]]; then\n\
    \      max_row=$i\n    fi\n  done\n  # find maximum column\n  declare -i max_col\n\
    \  declare -ia max_col_totals\n  for ((j=0; j<cols; j++)); do\n    max_col_totals[j]=0\n\
    \    for ((i=0; i<rows; i++)); do\n      max_col_totals[j]=$((max_col_totals[j]\
    \ + wells[i][j]))\n    done\n  done\n  max_col=0\n  for ((j=1; j<cols; j++));\
    \ do\n    if [[ ${max_col_totals[j]} -gt ${max_col_totals[max_col]} ]]; then\n\
    \      max_col", "  local grid=$1\n  local capacity=$2\n  # Your code here"]
stop_tokens:
- "\n}"
