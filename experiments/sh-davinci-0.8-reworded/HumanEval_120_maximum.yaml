name: HumanEval_120_maximum
language: sh
prompt: "#!/bin/bash\n# Given an array arr of integers and a positive integer k, return\
  \ a sorted list \n# of length k with the maximum k numbers in arr.\n# Example 1:\n\
  # >>> $(maximum \"-3 -4 5\" \"3\")\n# ['\"-4\"', '\"-3\"', '\"5\"']\n# Example 2:\n\
  # >>> $(maximum \"4 -4 4\" \"2\")\n# ['\"4\"', '\"4\"']\n# Example 3:\n# >>> $(maximum\
  \ \"-3 2 1 2 -1 -2 1\" \"1\")\n# ['\"2\"']\n# Note:\n# 1. The length of the array\
  \ will be in the range of [1, 1000].\n# 2. The elements in the array will be in\
  \ the range of [-1000, 1000].\n# 3. 0 <= k <= len(arr)\n#\n# $1 is a space-separated\
  \ list\n# $2 is an integer\nmaximum() {\n"
tests: "}\n\ncandidate() {\n    maximum \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
  \ $(candidate \"-3 -4 5\" \"3\") = \"-4 -3 5\" ]]\n    [[ $(candidate \"4 -4 4\"\
  \ \"2\") = \"4 4\" ]]\n    [[ $(candidate \"-3 2 1 2 -1 -2 1\" \"1\") = \"2\" ]]\n\
  \    [[ $(candidate \"123 -123 20 0 1 2 -3\" \"3\") = \"2 20 123\" ]]\n    [[ $(candidate\
  \ \"-123 20 0 1 2 -3\" \"4\") = \"0 1 2 20\" ]]\n    [[ $(candidate \"5 15 0 3 -13\
  \ -8 0\" \"7\") = \"-13 -8 0 0 3 5 15\" ]]\n    [[ $(candidate \"-1 0 2 5 3 -10\"\
  \ \"2\") = \"3 5\" ]]\n    [[ $(candidate \"1 0 5 -7\" \"1\") = \"5\" ]]\n    [[\
  \ $(candidate \"4 -4\" \"2\") = \"-4 4\" ]]\n    [[ $(candidate \"-10 10\" \"2\"\
  ) = \"-10 10\" ]]\n    [[ $(candidate \"1 2 3 -23 243 -400 0\" \"0\") = \"\" ]]\n\
  }\n\nrun_test"
completions: ["    local IFS=\" \"\n    local arr=($1)\n    local k=$2\n    local\
    \ i j\n    for ((i=0; i<k; i++)); do\n        for ((j=i+1; j<${#arr[@]}; j++));\
    \ do\n            if [[ ${arr[$i]} -lt ${arr[$j]} ]]; then\n                #\
    \ swap arr[i] and arr[j]\n                local tmp=${arr[$i]}\n             \
    \   arr[$i]=${arr[$j]}\n                arr[$j]=$tmp\n            fi\n       \
    \ done\n    done\n    printf '\"%s\" ' \"${arr[@]:0:$k}\"", '    echo "[$(printf
    "\"%s\" " $(printf "%s\n" $1 | sort -n | tail -n $2))]"', "    local -n _arr=$1\n\
    \    local -n _k=$2\n    echo \"${_arr[@]}\" | tr \" \" \"\\n\" | sort -nr | head\
    \ -n $_k", "  input=$1\n  len=$2\n  output=\"\"\n  for i in ${input// /\\\\n};\
    \ do\n    if [ -z $output ]; then\n      output=$i\n    else\n      case $i in\n\
    \        $(printf \"$output\" | sort -r | head -1) ) output=\"$output $i\";;\n\
    \        $(printf \"$output\" | sort -r | head -2 | tail -1) ) output=\"$output\
    \ $i\";;\n        $(printf \"$output\" | sort -r | head -3 | tail -1) ) output=\"\
    $output $i\";;\n        $(printf \"$output\" | sort -r | head -4 | tail -1) )\
    \ output=\"$output $i\";;\n        $(printf \"$output\" | sort -r | head -5 |\
    \ tail -1) ) output=\"$output $i\";;\n        * ) output=\"$output $i\";;\n  \
    \    esac\n    fi\n  done\n  echo \"[$(echo $output | sed -e 's/\\s\\+/, /g')]\"",
  "    _arr=()\n    for _i in $1; do\n        _arr=(\"${_arr[@]}\" $_i)\n    done\n\
    \    python -c \"\nimport sys\nfor i in sorted(sys.argv[1:], reverse=True)[:int(sys.argv[1])]:\n\
    \    print(i, end=' ')\n\" \"${_arr[@]}\"", "    read -r -a arr <<< \"$1\"\n\n\
    \    k=$2\n    len=${#arr[@]}\n    if [ $k -gt $len ]; then\n        k=$len\n\
    \    fi\n\n    printf '%s\\n' \"${arr[@]}\" | sort -nr | head -n $k | tr -d \"\
    \\n\"", "    local arr=(\"$@\")\n    local k=\"${arr[-1]}\"\n    arr=(\"${arr[@]:0:${#arr[@]}-1}\"\
    )\n    local len=${#arr[@]}\n    local i\n    local j\n    local tmp\n    for\
    \ ((i=0; i<k; i++)); do\n        for ((j=i+1; j<len; j++)); do\n            if\
    \ [[ ${arr[$i]} -lt ${arr[$j]} ]]; then\n                tmp=${arr[$i]}\n    \
    \            arr[$i]=${arr[$j]}\n                arr[$j]=$tmp\n            fi\n\
    \        done\n    done\n    echo \"${arr[@]:0:$k}\"", "  local -n array=\"($(echo\
    \ $1 | tr \" \" \"\\n\"))\"\n  local k=$2\n  if [ $k -gt ${#array[@]} ]; then\n\
    \    echo \"k must be less than or equal to the number of elements in arr\"\n\
    \    exit 1\n  fi\n  if [ $k -lt 1 ]; then\n    echo \"k must be at least 1\"\n\
    \    exit 1\n  fi\n  local sorted\n  for e in \"${array[@]}\"; do\n    sorted+=($(echo\
    \ -e \"$e\\n${sorted[@]}\" | sort -rn | head -n1))\n  done\n  echo \"[$(printf\
    \ '\"%s\" ' \"${sorted[@]:0:$k}\")]\"", "  arr=($1)\n  k=$2\n  for ((i=0; i<k;\
    \ i++)); do\n    min=${arr[0]}\n    min_index=0\n    for ((j=0; j<${#arr[@]};\
    \ j++)); do\n      if (($(printf '%s\\n' \"${arr[j]}\" \"$min\" | sort -n | head\
    \ -n 1)==\"${arr[j]}\")); then\n        min=${arr[j]}\n        min_index=$j\n\
    \      fi\n    done\n    arr[$min_index]=2147483647\n    new_arr[$i]=$min\n  done\n\
    \  echo \"${new_arr[@]}\"", "    IFS=' ' read -ra ADDR <<< \"$1\"\n    len=${#ADDR[@]}\n\
    \    for ((i=0; i<len; i++)); do\n        for ((j=i+1; j<len; j++)); do\n    \
    \        (( ${ADDR[i]} < ${ADDR[j]} )) && t=${ADDR[i]} && ADDR[i]=${ADDR[j]} &&\
    \ ADDR[j]=$t\n        done\n    done\n    printf '[\"%s\"' \"${ADDR[@]:0:$2}\"\
    \n    printf ']\\n'", "    list=(\"$@\")\n    nums=${list[0]}\n    k=${list[1]}\n\
    \    echo \"[$(echo $nums | xargs -n1 | sort -nr | head -n $k | sed -r 's/(.*)/\"\
    \\1\"/g' | xargs | sed -r 's/\\s/\\,/g')]\"", "    list=$1\n    k=$2\n    for\
    \ x in $list; do\n        echo $x\n    done | sort -nr | head -n $k", "    : \"\
    \n    (a)slc/seq -s' ' l/order/rep -n0 -v -g\" | bc |\n    sed \"\n        s/;/',\
    \ '/g\n        s/^/$(echo \"'\")/\n        s/$/$(echo \"'\")/\n    \"", "    local\
    \ array=(${1// / })\n    local k=${2}\n    local start\n    local end\n    local\
    \ pivot\n    local i\n    local j\n    local temp\n    for (( ; ; ))\n    do\n\
    \        start=0\n        end=$(( ${#array[@]} - 1 ))\n        if [[ ${end} -le\
    \ ${start} ]]; then\n            break\n        fi\n        pivot=${array[${end}]}\n\
    \        i=${start}\n        for (( j=${start}; j<${end}; j++ ))\n        do\n\
    \            if [[ ${array[${j}]} -gt ${pivot} ]]; then\n                temp=${array[${i}]}\n\
    \                array[${i}]=${array[${j}]}\n                array[${j}]=${temp}\n\
    \                (( i++ ))\n            fi\n        done\n        temp=${array[${i}]}\n\
    \        array[${i}]=${array[${end}]}\n        array[${end}]=${temp}\n       \
    \ if [[ ${i} -eq $(( ${k} - 1 )) ]]; then\n            break\n        elif [[\
    \ ${i} -gt $(( ${k} - 1 )) ]]; then\n            end=$(( ${i} - 1 ))\n       \
    \ else\n            start=$(( ${i} + 1 ))\n        fi\n    done\n    for (( i=0;\
    \ i<${k}; i++ ))\n    do\n        echo -n '\"'${array[${i}]}'\"'\n        if [[\
    \ $(( ${i} + 1 )) -lt ${k} ]]; then\n            echo -n ','\n        fi\n   \
    \ done\n    echo", "    echo $1 | tr \" \" \"\\n\" | sort -nr | head -$2 | tr\
    \ \"\\n\" \" \" | sed 's/\\(.*\\)/\\[\"\\1\"\\]/'", "    arr=($1)\n    k=$2\n\
    \    len=${#arr[@]}\n    for i in `seq 0 $((len-1))`; do\n        for j in `seq\
    \ $((i+1)) $((len-1))`; do\n            if [ ${arr[$i]} -lt ${arr[$j]} ]; then\n\
    \                t=${arr[$i]}\n                arr[$i]=${arr[$j]}\n          \
    \      arr[$j]=$t\n            fi\n        done\n    done\n    result=\"\"\n \
    \   for i in `seq 0 $((k-1))`; do\n        result=$result${arr[$i]}' '\n    done\n\
    \    echo \"[$result]\"", "    tmp=\"$1\"\n    k=\"$2\"\n    arr=(${tmp// / })\n\
    \    IFS=$'\\n'\n    arr=($(sort -n <<<\"${arr[*]}\"))\n    unset IFS\n    total=${#arr[@]}\n\
    \    if [[ \"$k\" -gt \"$total\" ]]; then\n        k=\"$total\"\n    fi\n    echo\
    \ \"${arr[@]: -$k}\"", "    # do nothing if $2 <= 0\n    [ \"$2\" -le 0 ] && exit\n\
    \    # if $2 > number of elements, set to number of elements\n    [ \"$2\" -gt\
    \ \"$(tr ' ' '\\n' <<< \"$1\" | wc -l)\" ] && \\\n        set -- \"$1\" \"$(tr\
    \ ' ' '\\n' <<< \"$1\" | wc -l)\"\n    # sort the list in descending order\n \
    \   sorted=($(tr ' ' '\\n' <<< \"$1\" | sort -nr))\n    # extract the first $2\
    \ elements\n    printf '[%s]\\n' \"${sorted[@]:0:$2}\"", "  local list=\"$1\"\n\
    \  local length=\"$2\"\n  local sorted=\"$(echo \"$list\" | tr ' ' '\\n' | sort\
    \ -r)\"\n  local -a array=($sorted)\n  local len=\"${#array[@]}\"\n  if [ \"$len\"\
    \ -lt \"$length\" ]; then\n    echo \"[]\"\n  else\n    output=\"[\"\n    for\
    \ ((i=0; i<length; i++)); do\n      output+=\"\\\"${array[$i]}\\\"\"\n      if\
    \ [ \"$i\" -lt \"$((length-1))\" ]; then\n        output+=\", \"\n      fi\n \
    \   done\n    output+=\"]\"\n    echo \"$output\"\n  fi", "    python -c \"\n\
    import sys\nprint([max(map(int, sys.argv[1].split(' ')))] + sorted(map(int, sys.argv[1].split('\
    \ ')), reverse=True)[:int(sys.argv[2])-1])\n\" \"$1\" \"$2\" | sed 's/ /, /g'\
    \ | sed 's/^/\"/' | sed 's/$/\"/'", "    # $1 is space-separated list\n    # $2\
    \ is an integer\n    l=$1\n    k=$2\n    # Split l by space\n    IFS=' ' read\
    \ -ra a <<< \"$l\"\n    # Sort a by descending\n    r=$(IFS=$'\\n'; sort -nr <<<\
    \ \"${a[*]}\")\n    # Split r by newline\n    IFS=$'\\n' read -ra b <<< \"$r\"\
    \n    # Get maximum k elements and join them by comma\n    echo $(IFS=,; echo\
    \ \"${b[@]:0:$k}\")", "    echo $1 | sed 's/[^0-9-]/ /g' |\n    xargs -n 1 | #\
    \ split into N parts (N = number of args)\n    sed -E 's/(.*)/\\1 \\1/' | # Each\
    \ part is repeated\n    xargs -n 2 | # 2 arguments per line\n    sort -r -n |\
    \ # sort numerically, descending\n    head -n $2 | # first K lines\n    xargs\
    \ -n 1 | # back to N parts\n    sed -E 's/(.*)/\"\\1\"/' | # add quotes\n    xargs\
    \ -n 1 | # back to N parts\n    sed -E 's/^/[/' | # open brackets\n    sed -E\
    \ 's/$/]/' # close brackets", "    arr=()\n    for i in ${1}; do\n        arr+=($i)\n\
    \    done\n    # https://stackoverflow.com/questions/1527049/join-elements-of-an-array\n\
    \    arr_sort=$(echo ${arr[@]} | tr \" \" \"\\n\" | sort -rn | tr \"\\n\" \" \"\
    )\n    counter=0\n    for i in ${arr_sort}; do\n        if [ ${counter} -lt ${2}\
    \ ]; then\n            echo \\\"${i}\\\"\n            counter=$((counter+1))\n\
    \        fi\n    done", "    local input_list\n    local input_k\n    local output_list\n\
    \    local i\n    local j\n    local n\n    local max_value\n    local max_index\n\
    \    local tmp\n    input_list=($1)\n    input_k=$2\n    output_list=()\n    for\
    \ ((i=0; i<input_k; i++)); do\n        max_value=${input_list[0]}\n        max_index=0\n\
    \        for ((j=1; j<${#input_list[@]}; j++)); do\n            if [[ \"${input_list[j]}\"\
    \ -gt \"$max_value\" ]]; then\n                max_value=${input_list[j]}\n  \
    \              max_index=$j\n            fi\n        done\n        output_list+=($max_value)\n\
    \        n=${#input_list[@]}\n        for ((j=max_index; j<n-1; j++)); do\n  \
    \          tmp=${input_list[j]}\n            input_list[j]=${input_list[j+1]}\n\
    \            input_list[j+1]=$tmp\n        done\n        unset input_list[n-1]\n\
    \    done\n    echo \"${output_list[@]}\"", "  arr=(\"$@\")\n  len=${#arr[@]}\n\
    \  if [ ${len} -eq 0 ]; then\n    echo \"[]\"\n    return\n  fi\n  if [ ${len}\
    \ -lt $2 ]; then\n    echo \"[]\"\n    return\n  fi\n  if [ ${len} -eq $2 ]; then\n\
    \    echo \"[${arr[@]}]\"\n    return\n  fi\n  # find the maximum k elements and\
    \ put them in the first k positions\n  for ((i=0; i<$2; i++)); do\n    max=$i\n\
    \    for ((j=$i+1; j<$len; j++)); do\n      if [ ${arr[j]} -gt ${arr[max]} ];\
    \ then\n        max=$j\n      fi\n    done\n    t=${arr[i]}\n    arr[i]=${arr[max]}\n\
    \    arr[max]=$t\n  done\n  # bubble sort the k elements\n  for ((i=0; i<$2; i++));\
    \ do\n    for ((j=$2-1; j>$i; j--)); do\n      if [ ${arr[j]} -gt ${arr[j-1]}\
    \ ]; then\n        t=${arr[j]}\n        arr[j]=${arr[j-1]}\n        arr[j-1]=$t\n\
    \      fi\n    done\n  done\n  out=\"[\"\n  for ((i=0; i<$2; i++)); do\n    if\
    \ [ $i -eq 0 ]; then\n      out=\"${out}\\\"${arr[i]}\\\"\"\n    else\n      out=\"\
    ${out}, \\\"${arr[i]}\\\"\"\n    fi\n  done\n  out=\"${out}]\"\n  echo \"${out}\"",
  "  local -a array=()\n  for i in $1; do\n    array+=($i)\n  done\n  echo \"before\
    \ sort:\"\n  printf '%s\\n' \"${array[@]}\"\n  echo \"after sort:\"\n  printf\
    \ '%s\\n' \"${array[@]}\" | sort -r\n  echo \"after slice:\"\n  printf '%s\\n'\
    \ \"${array[@]}\" | sort -r | head -$2", "    if [[ $# -ne 2 ]]; then\n      \
    \  echo \"Usage: $0 <array> <int>\"\n        return 1\n    fi\n    local -a array=($1)\n\
    \    local k=$2\n    if [[ ${#array[@]} -lt $k ]]; then\n        echo \"Error:\
    \ the length of the array (${#array[@]}) is less than k ($k)\"\n        return\
    \ 1\n    fi\n    array=($(echo \"${array[@]}\" | tr ' ' '\\n' | sort -n -r))\n\
    \    local output=(\"${array[@]:0:$k}\")\n    echo \"${output[@]}\"", "    if\
    \ [[ \"$#\" -ne 2 ]]; then\n        echo \"Two arguments are required.\"\n   \
    \     return 1\n    fi\n    declare -a arr\n    arr=($1)\n    k=$2\n    length=${#arr[@]}\n\
    \    if [[ \"$k\" -gt \"$length\" ]]; then\n        echo \"The second argument\
    \ cannot be greater than the number of items in the array.\"\n        return 1\n\
    \    fi\n    declare -a max\n    max=()\n    while true; do\n        m=-1000\n\
    \        p=0\n        for ((i=0; i<${#arr[@]}; i++)); do\n            if [[ \"\
    ${arr[$i]}\" -gt \"$m\" ]]; then\n                m=${arr[$i]}\n             \
    \   p=$i\n            fi\n        done\n        max+=($m)\n        arr[$p]=-1000\n\
    \        if [[ \"${#max[@]}\" -eq \"$k\" ]]; then\n            break\n       \
    \ fi\n    done\n    echo -e \"['\"$(echo \"${max[@]}\" | tr \" \" \"','\")\"']\"",
  "    echo \"[\"\n    for num in $1; do\n        if [[ ! -z $largest ]]; then\n \
    \           if [[ $num -gt $largest ]]; then\n                largest=$num\n \
    \           fi\n        else\n            largest=$num\n        fi\n    done\n\
    \    echo \\\"$largest\\\"\n    count=1\n    while [[ $count -lt $2 ]]; do\n \
    \       for num in $1; do\n            if [[ $num -gt $largest ]]; then\n    \
    \            largest=$num\n            fi\n        done\n        echo \\\"$largest\\\
    \"\n        count=$((count+1))\n    done\n    echo \"]\"", "    local -a arr\n\
    \    arr=($1)\n    for ((i = 0; i < ${#arr[@]}; i++)); do\n        for ((j = i\
    \ + 1; j < ${#arr[@]}; j++)); do\n            if (( ${arr[i]} < ${arr[j]} ));\
    \ then\n                t=${arr[i]}\n                arr[i]=${arr[j]}\n      \
    \          arr[j]=$t\n            fi\n        done\n    done\n    echo \"${arr[@]:0:$2}\"",
  "  local input=($1)\n  local k=$2\n  local _max=()\n  local n=${#input[@]}\n  for\
    \ ((i=0; i<$k; i++)); do\n    _max[$i]=${input[$i]}\n  done\n  for ((i=$k; i<$n;\
    \ i++)); do\n    for ((j=0; j<$k; j++)); do\n      if [[ ${input[$i]} -gt ${_max[$j]}\
    \ ]]; then\n        _max[$j]=${input[$i]}\n        break\n      fi\n    done\n\
    \  done\n  echo ${_max[@]}", "    local arr=($1)\n    local k=$2\n    local i\
    \ j\n    local max\n\n    for ((i=0; i<k; i++)); do\n        max=${arr[0]}\n \
    \       for ((j=1; j<${#arr[@]}; j++)); do\n            [[ \"${arr[j]}\" > \"\
    $max\" ]] && max=${arr[j]}\n        done\n        echo \"$max\"\n        unset\
    \ \"arr[${i}]\"\n    done", "    arr=($1)\n    length=${#arr[@]}\n    k=$2\n \
    \   echo $length\n    if [[ $length -eq 0 ]]; then\n        # Return an empty\
    \ array\n        echo []\n    elif [[ $length -eq 1 ]]; then\n        # Return\
    \ the only element in an array\n        echo [\\\"${arr[0]}\\\"]\n    else\n \
    \       arr_sorted=($(printf \"%s\\n\" \"${arr[@]}\" | sort -nr))\n        result=()\n\
    \        for ((i=0; i<$k; i++)); do\n            result[$i]=${arr_sorted[$i]}\n\
    \        done\n        # Return an array with the first $k elements\n        echo\
    \ ${result[@]}\n    fi", "  local -a array\n  array=(${1// / })\n  local -a sorted=()\n\
    \  local -a result=()\n  local n=$2\n  for elem in \"${array[@]}\"; do\n    sorted+=($(echo\
    \ \"$elem\" | sed -E 's/^([-+]?[0-9]+)/\\1.0/'))\n  done\n  IFS=$'\\n' sorted=($(sort\
    \ -n <<<\"${sorted[*]}\"))\n  IFS=$' '\n  for ((i=${#sorted[@]}-1; i>=0; i--));\
    \ do\n    if [[ $n -le 0 ]]; then\n      break\n    fi\n    result+=($(echo \"\
    ${sorted[i]}\" | sed -E 's/([-+]?[0-9]+).0/\\1/'))\n    ((n--))\n  done\n  echo\
    \ \"[\\\"${result[*]}\\\"]\"", "    arr=${1}\n    k=${2}\n    len=${#arr[@]}\n\
    \    for ((i=0; i<len; i++)); do\n        for ((j=i+1; j<len; j++)); do\n    \
    \        if [[ ${arr[i]} -gt ${arr[j]} ]]; then\n                temp=${arr[i]}\n\
    \                arr[i]=${arr[j]}\n                arr[j]=${temp}\n          \
    \  fi\n        done\n    done\n    echo \"${arr[@]:0:k}\"", "    local l=(\"$@\"\
    )\n    local length=${#l[@]}\n    local k=$2\n    if [ $length -gt $k ]; then\n\
    \        for ((i=0; i<length; i++)); do\n            for ((j=i+1; j<length; j++));\
    \ do\n                if [ ${l[i]} -lt ${l[j]} ]; then\n                    local\
    \ tmp=${l[i]}\n                    l[i]=${l[j]}\n                    l[j]=$tmp\n\
    \                fi\n            done\n        done\n    fi\n    echo ${l[@]:0:$k}",
  "    echo \"max($1, $2)\" | octave -q | grep -o '\\[.*\\]' | sed 's/\\[//' | sed\
    \ 's/\\]//' | tr -d ' '", "  local arr=$1 k=$2 ret i j\n  local -a array=($arr)\
    \ sorted\n  i=0\n  while [ $i -lt ${#array[@]} ]; do\n    [ $i -lt $k ] && sorted[$i]=${array[$i]}\n\
    \    for j in $(seq 0 $i); do\n      if [ ${array[$i]} -gt ${sorted[$j]} ]; then\n\
    \        sorted=(${sorted[@]:0:$j} ${array[$i]} ${sorted[@]:$j})\n        break\n\
    \      fi\n    done\n    [ ${#sorted[@]} -gt $k ] && sorted=(${sorted[@]:0:$k})\n\
    \    ((i++))\n  done\n  ret=$(echo ${sorted[@]} | tr \" \" \",\")\n  echo \"[${ret:1:${#ret}-2}]\"",
  "  arr=($1)\n  n=${#arr[@]}\n  if [[ $n -gt 0 ]]; then\n    sorted=($(for ((i=0;\
    \ i<n; i++)); do echo \"${arr[i]}\"; done | sort -n))\n    m=$2\n    if [[ $m\
    \ -gt $n ]]; then\n      m=$n\n    fi\n    for ((i=0; i<m; i++)); do\n      echo\
    \ \"${sorted[$((n-1-i))]}\"\n    done\n  fi", "    python3 -c \"\nimport sys\n\
    from itertools import islice\narr = sys.argv[1].split()\nk = int(sys.argv[2])\n\
    print(sorted(arr, reverse=True)[:k])\n\" \"$1\" \"$2\"", "    # a faster and more\
    \ robust solution: https://github.com/dylanaraps/pure-bash-bible#fast-but-inaccurate-sorting\n\
    \    # we can use: sort -nr\n    local arr_temp=()\n    local arr=()\n    local\
    \ max_num\n    local index=0\n    for i in $1; do\n        if (( $index == 0 ));\
    \ then\n            max_num=$i\n        elif (( $max_num < $i )); then\n     \
    \       max_num=$i\n        fi\n        arr_temp+=($i)\n        (( index++ ))\n\
    \    done\n    while (( ${#arr[@]} < $2 )); do\n        local min_num=$max_num\n\
    \        local min_num_idx=0\n        local min_found=false\n        for (( i=0;\
    \ i<${#arr_temp[@]}; i++ )); do\n            if (( ${arr_temp[$i]} < $min_num\
    \ && ${arr_temp[$i]} > 0 )); then\n                min_num=${arr_temp[$i]}\n \
    \               min_num_idx=$i\n                min_found=true\n            fi\n\
    \        done\n        if (( $min_found )); then\n            arr+=($min_num)\n\
    \            arr_temp[$min_num_idx]=0\n        else\n            break\n     \
    \   fi\n    done\n    echo \"[$( IFS=','; echo \"${arr[*]}\" )]\";", "  arr=($1)\n\
    \  k=$2\n  new_arr=()\n  max_val=${arr[0]}\n  min_val=${arr[0]}\n  # first get\
    \ the max and min values\n  for i in \"${arr[@]}\"; do\n    [[ $i -gt $max_val\
    \ ]] && max_val=$i\n    [[ $i -lt $min_val ]] && min_val=$i\n  done\n  # then\
    \ divide the values into k buckets, where arr[i] is in the\n  # (arr[i] - min_val)\
    \ % k bucket\n  index=0\n  buckets=()\n  for i in \"${arr[@]}\"; do\n    [[ ${buckets[$(((i\
    \ - min_val) % k))]} == \"\" ]] && buckets[$(((i - min_val) % k))]=$i || buckets[$(((i\
    \ - min_val) % k))]=\"${buckets[$(((i - min_val) % k))]} $i\"\n  done\n  # finally,\
    \ get the max k values from all the buckets and construct the new array\n  for\
    \ i in \"${buckets[@]}\"; do\n    sub_arr=($i)\n    bucket_max=${sub_arr[0]}\n\
    \    for i in \"${sub_arr[@]}\"; do\n      [[ $i -gt $bucket_max ]] && bucket_max=$i\n\
    \    done\n    new_arr[$index]=$bucket_max\n    index=$((index + 1))\n  done\n\
    \  echo ${new_arr[@]}", "  local -n arr=\"($1)\"\n  local k=\"$2\"\n  local -a\
    \ copy=(\"${arr[@]}\")\n  local max\n  for ((i=0; i<k; i++)); do\n    max=$(echo\
    \ \"${copy[@]}\" | tr ' ' '\\n' | sort -nr | head -n 1)\n    printf '\"%s\" '\
    \ \"$max\"\n    copy=(\"${copy[@]/$max}\")\n  done\n  echo", "    local max_nums=\"\
    $1\"\n    local nums=$(printf \"%s\" \"$1\" | tr ' ' '\\n' | sort -g)\n    local\
    \ len=$(printf \"%s\" \"$nums\" | wc -l)\n    printf \"%s\" \"$nums\" | tail -n\
    \ $((len - $2))", "    local -r a=($1)\n    local -r k=\"$2\"\n    local i\n \
    \   local j\n    local tmp\n    for ((i=0; i<=${#a[@]}-2; i++)); do\n        for\
    \ ((j=i+1; j<=${#a[@]}-1; j++)); do\n            if ((${a[i]} < ${a[j]})); then\n\
    \                tmp=${a[i]}\n                a[i]=${a[j]}\n                a[j]=$tmp\n\
    \            fi\n        done\n    done\n    echo \"${a[@]:0:$k}\"", "  local\
    \ arr=($1)\n  local k=$2\n  local len=${#arr[@]}\n  for ((i=0; i<len; i++)); do\n\
    \    for ((j=i+1; j<len; j++)); do\n      if [[ ${arr[$i]} -lt ${arr[$j]} ]];\
    \ then\n        local tmp=${arr[$i]}\n        arr[$i]=${arr[$j]}\n        arr[$j]=$tmp\n\
    \      fi\n    done\n  done\n  echo -n \"[\"\n  for ((i=0; i<k; i++)); do\n  \
    \  echo -n '\"'${arr[$i]}'\"'\n    if ((i < k-1)); then\n      echo -n \", \"\n\
    \    fi\n  done\n  echo \"]\"", "  local -a arr=($1)\n  local -a out\n  for i\
    \ in ${arr[@]}; do\n    case \"${out[@]}\" in  *\" $i \"*) continue;; esac\n \
    \   if [[ \"${#out[@]}\" -ge \"$2\" ]]; then\n      for j in $(seq 0 \"${#out[@]}\"\
    ); do\n        if [[ \"$i\" -gt \"${out[$j]}\" ]]; then\n          out[$j]=\"\
    $i\"\n          break\n        fi\n      done\n    else\n      out+=($i)\n   \
    \ fi\n  done\n  echo \"${out[@]}\" | sort -n | xargs", "    if [[ $1 =~ (\\\"\
    )?[0-9]+([-][0-9]+)?(\\\")? ]]; then\n        len=$(echo $1 | wc -w)\n       \
    \ if [[ $2 -ge 1 && $2 -le $len ]]; then\n            local arr\n            arr=($(echo\
    \ $1 | tr \" \" \"\\n\" | sort -r | head -n $2))\n            echo \"${arr[@]}\"\
    \n        else\n            echo \"Invalid argument: $2\"\n        fi\n    else\n\
    \        echo \"Invalid argument: $1\"\n    fi", "  local a=($1)\n  local -i k=$2\n\
    \  local -i i\n  if [[ ${#a[@]} -lt k ]]; then\n    echo \"Error: length of array\
    \ [${#a[@]}] must be greater than length k [$k]\"\n    return 1\n  fi\n  echo\
    \ \"${a[@]}\" | tr \" \" \"\\n\" | sort -n -r | head -n $k | tr \"\\n\" \" \"",
  "    python -c \"\nimport sys\nprint sorted(sys.argv[1].split(), reverse=True)[:int(sys.argv[2])]\n\
    \" \"$1\" \"$2\"", "  if [ $# -ne 2 ]; then\n    echo \"usage: $(basename \"$0\"\
    ) [list] [count]\" >&2\n    exit 1\n  fi\n  if [[ ! \"$2\" =~ ^[0-9]+$ ]]; then\n\
    \    echo \"count must be a positive integer\" >&2\n    exit 1\n  fi\n  local\
    \ count=\"$2\"\n  local i=0\n  local array=()\n  for i in $1; do\n    if [[ !\
    \ \"$i\" =~ ^[0-9\\-]+$ ]]; then\n      echo \"list must only contain integers\"\
    \ >&2\n      exit 1\n    fi\n    array[${#array[@]}]=\"$i\"\n  done\n  if [ \"\
    $count\" -gt \"${#array[@]}\" ]; then\n    echo \"count ($count) cannot be greater\
    \ than the length of the list\" >&2\n    exit 1\n  fi\n  printf '%s\\n' \"${array[@]}\"\
    \ | sort -nr | head -n\"$count\" | tr -d '\\n'", "    python3 -c \"\nfrom functools\
    \ import cmp_to_key\n\nnums = [int(num) for num in '$1'.split()]\nk = int('$2')\n\
    \ndef comp(x, y):\n    if x < y:\n        return 1\n    elif x > y:\n        return\
    \ -1\n    else:\n        return 0\n\nprint(sorted(nums, key=cmp_to_key(comp))[:k])\n\
    \"", "    list=$1\n    max=$2\n    # Maximum numbers cannot be greater than the\
    \ number of elements\n    max=$((max > ${#list[@]} ? ${#list[@]} : max))\n   \
    \ # Sort the list and take the last $max items\n    sorted=($(echo \"$list\" |\
    \ sed 's/ /\\n/g' | sort -r))\n    echo \"${sorted[@]:0:$max}\"", "    local arr=()\n\
    \    for i in $1; do\n        arr+=(\"${i}\")\n    done\n    for ((i=0; i<${#arr[@]};\
    \ i++)); do\n        for ((j=i+1; j<${#arr[@]}; j++)); do\n            if ((${arr[i]}\
    \ < ${arr[j]})); then\n                temp=${arr[i]}\n                arr[i]=${arr[j]}\n\
    \                arr[j]=$temp\n            fi\n        done\n    done\n    if\
    \ ((${#arr[@]} < $2)); then\n        echo ${arr[@]}\n    else\n        echo ${arr[@]:0:$2}\n\
    \    fi", "    local arr=${1}\n    local k=${2}\n    local -a result=()\n    local\
    \ -i i\n    local -i j\n    local temp\n\n    for ((i=0; i<k; i++)); do\n    \
    \    result[$i]=${arr%% *}\n        arr=${arr#* }\n    done\n\n    for ((i=k;\
    \ i<${#arr}; i++)); do\n        j=0\n        while [ $j -lt $k ] && [ ${result[$j]}\
    \ -ge ${arr%% *} ]; do\n            j=$((j+1))\n        done\n        if [ $j\
    \ -ne $k ]; then\n            j=$((j-1))\n            temp=${result[$j]}\n   \
    \         result[$j]=${arr%% *}\n            for ((; j<$k-1; j++)); do\n     \
    \           temp2=${result[$((j+1))]}\n                result[$((j+1))]=$temp\n\
    \                temp=$temp2\n            done\n        fi\n        arr=${arr#*\
    \ }\n    done\n\n    printf '[\"%s\"' \"${result[0]}\"\n    for ((i=1; i<k; i++));\
    \ do\n        printf ',\"%s\"' \"${result[$i]}\"\n    done\n    printf ']\\n'",
  "    declare -a input_arr=($1)\n    declare -a output_arr\n    local output_i=0\n\
    \    for ((i=0; i<=${#input_arr[@]}; i++)); do\n        if [[ ${input_arr[$i]}\
    \ -gt ${output_arr[$((output_i-1))]} ]]; then\n            output_arr[$output_i]=${input_arr[$i]}\n\
    \            ((output_i++))\n        fi\n    done\n    echo ${output_arr[@]}",
  "    arr=($1)\n    k=$2\n    ksorted_arr=($(for i in ${arr[@]}; do echo $i; done\
    \ | sort -nr | head -n $k))\n    echo ${ksorted_arr[@]}", "    k=$2\n    IFS='\
    \ ' read -ra arr <<< \"$1\"\n    arr=(\"${arr[@]}\" \"${arr[@]}\" \"${arr[@]}\"\
    ) # append the array to itself\n    size=${#arr[@]}\n    for (( i=0; i<size; i++\
    \ )); do\n        arr[i]=$(printf \"%03d%s\" ${arr[i]} \"$i\") # add index to\
    \ array as prefix\n    done\n    IFS=$'\\n' sorted=($(sort -r <<<\"${arr[*]}\"\
    ))\n    echo \"[$(for i in ${sorted[@]:0:$k}; do\n        echo -n \"\\\"${i:3}\\\
    \" \"\n    done)]", "  [ $# -eq 2 ] || { echo \"Usage: $(basename $0) LIST INTEGER\"\
    ; exit 1; }\n  local list integer\n  list=\"$1\"\n  integer=\"$2\"\n  if [ $integer\
    \ -lt 1 ]; then\n    echo \"[]\"\n  else\n    # https://stackoverflow.com/questions/29899126/convert-string-to-array-in-bash-shell-script\n\
    \    read -ra array <<< \"$list\"\n    echo $(echo \"${array[@]}\" | tr ' ' '\\\
    n' | sort -rn | head -n $integer | tr '\\n' ' ' | sed 's/ /\", \"/g') | sed \"\
    s/^/(\\\"/;s/$/\\\")/\"\n  fi", "    # Pick k maximum numbers\n    k=\"$2\"\n\
    \    # Split $1 into an array named a\n    IFS=\" \" read -r -a a <<< \"$1\"\n\
    \    # Sort array a in descending order\n    # Sort by absolute value (-k1,1n\
    \ => -k2,2n) if $2 is an even number\n    if [[ $k%2 -eq 0 ]]; then\n        for\
    \ ((i=0; i<${#a[@]}; i++)); do\n            a[$i]=$(printf \"%d\" \"${a[$i]}\"\
    )\n        done\n        i=0\n        for n in $(\n            for x in \"${a[@]}\"\
    ; do\n                echo \"$x\"\n            done | sort -k1,1n -k2,2nr\n  \
    \      ); do\n            a[$i]=\"$n\"\n            ((i++))\n        done\n  \
    \  else\n        for ((i=0; i<${#a[@]}; i++)); do\n            a[$i]=$(printf\
    \ \"%d\" \"${a[$i]}\")\n        done\n        i=0\n        for n in $(\n     \
    \       for x in \"${a[@]}\"; do\n                echo \"$x\"\n            done\
    \ | sort -k1,1nr -k2,2n\n        ); do\n            a[$i]=\"$n\"\n           \
    \ ((i++))\n        done\n    fi\n    # Reverse the array if $2 is an odd number\n\
    \    if [[ $k%2 -ne 0 ]]; then\n        j=$((i-1))\n        for ((i=0; i<$j; i++,\
    \ j--)); do\n            t=\"${a[$i]}\"\n            a[$i]=\"${a[$j]}\"\n    \
    \        a[$j]=\"$t\"\n        done\n    fi\n    # Print the first k elements\n\
    \    printf \"[\"\n    for ((i=0; i<$k; i++)); do\n        if [[ $i -lt $((k-1))\
    \ ]]; then\n            printf '\"%s\", ' \"${a[$i]}\"\n        else\n       \
    \     printf '\"%s\"' \"${a[$i]", "    local -a nums=($1)\n    local max_size=$2\n\
    \    local -a maxes=($(sort_and_take ${nums[@]} $max_size))\n    echo $(arr_to_str\
    \ ${maxes[@]})", "    # Convert the space-separated list to an array,\n    # then\
    \ sort the array in descending order\n    arr=(${1// / })\n    arr=($(for x in\
    \ \"${arr[@]}\"; do echo $x; done | sort -rn))\n    # Set the array head to the\
    \ required size\n    arr=(\"${arr[@]:0:$2}\")\n    # Convert the array to a space-separated\
    \ list.\n    echo ${arr[@]}", "    local IFS=\" \"\n    local digits=($1)\n  \
    \  local k=$2\n    ((k<1)) && return 1\n    # shellsort() defined in lib/sort.sh\n\
    \    shellsort \"${digits[@]}\"\n    ((k>${#digits[@]})) && k=${#digits[@]}\n\
    \    local result=${digits[*]:-$((k-1)):$k}\n    printf '[\"%s\"]\\n' $result",
  "    max_array=()\n    input_array=()\n    for element in $(echo $1); do\n     \
    \   if [[ $element -gt ${max_array[0]} ]]; then\n            max_array[0]=$element\n\
    \        fi\n        for index in \"${!max_array[@]}\"; do\n            if [[\
    \ $element -gt ${max_array[$index]} ]]; then\n                max_array[$index]=$element\n\
    \                break\n            fi\n        done\n        input_array+=($element)\n\
    \    done\n    #print_array \"${max_array[@]}\"\n    echo ${max_array[@]}", " \
    \   local arr=\"$1\"\n    local k=\"$2\"\n    python -c \"\nimport sys\ndef maximum(arr,\
    \ k):\n    try:\n        res = sorted(arr, reverse=True)[:k]\n        return res\n\
    \    except Exception as e:\n        return e\nprint(maximum(sys.argv[1].split(),\
    \ int(sys.argv[2])))\n\" \"$arr\" \"$k\"", "    max=\"\"\n    for i in $1; do\n\
    \        max=\"$max$i \"\n    done\n    echo -n \"[\"\n    n=$2\n    while [ $n\
    \ -gt 0 ]; do\n        m=$(echo \"$max\" | tr \" \" \"\\n\" | sort -nr | head\
    \ -n 1)\n        echo -n \"'\\\"$m\\\"', \"\n        max=$(echo \"$max\" | tr\
    \ \" \" \"\\n\" | grep -v \"^$m$\")\n        n=$((n-1))\n    done\n    echo -n\
    \ \"]\"", "    numbers=($1)\n    k=$2\n    j=0\n    while ((j < k))\n    do\n\
    \        ((j++))\n        maximum_number=\"${numbers[0]}\"\n        maximum_number_idx=0\n\
    \        i=0\n        while ((i < ${#numbers[@]}))\n        do\n            if\
    \ (( ${numbers[i]} > $maximum_number ))\n            then\n                maximum_number=\"\
    ${numbers[i]}\"\n                maximum_number_idx=$i\n            fi\n     \
    \       ((i++))\n        done\n        unset \"numbers[$maximum_number_idx]\"\n\
    \        numbers=(\"${numbers[@]}\")\n        printf '\"%s\" ' \"$maximum_number\"\
    \n    done\n    echo \"\"", "    local arr=($1)\n    local size=${#arr[@]}\n \
    \   local k=$2\n    local i j\n    local maxI j maxJ\n    local temp\n\n    #\
    \ Note here i and j is the index in arr and not the real value of arr[i].\n  \
    \  for ((i=0; i<size; i++)); do\n        for ((j=i+1; j<size; j++)); do\n    \
    \        # I need to find the max k numbers in arr, so put the max number\n  \
    \          # at the front of arr.\n            if [[ ${arr[i]} -lt ${arr[j]} ]];\
    \ then\n                temp=${arr[i]}\n                arr[i]=${arr[j]}\n   \
    \             arr[j]=$temp\n            fi\n        done\n    done\n\n    # Get\
    \ the first k numbers of arr\n    for ((i=0; i<k; i++)); do\n        echo -n '\"\
    '${arr[i]}'\"'\n        if [[ $i -lt $((k-1)) ]]; then\n            echo -n ','\n\
    \        fi\n    done\n    echo", "    list=$1\n    num=$2\n    echo ${list} |\
    \ tr ' ' '\\n' | \\\n        awk -v num=\"$num\" '\n            {\n          \
    \      table[$0]++\n            }\n            END {\n                for (key\
    \ in table) {\n                    print \"\\\"\" key \"\\\"\"\n             \
    \   }\n            }' | \\\n        sort -t\"\\\"\" -k2,2 -n | \\\n        head\
    \ -n \"$num\"", "    echo \"$1\" | tr \" \" \"\\n\" | sort -r | head -n \"$2\"\
    \ | tr \"\\n\" \" \" | sed 's/^/[/;s/$/]/'", "    local -n input=\"$1\"\n    local\
    \ k=\"$2\"\n    local -a num_array=(${input// / })\n    local -a max_array=()\n\
    \    local tmp=0\n    local max_index=0\n    local len=${#num_array[@]}\n    local\
    \ i=0\n    local j=0\n    # find the maximum k numbers in arr\n    for i in $(seq\
    \ 0 $(($k-1))); do\n        # find the maximum value in the remaining numbers\n\
    \        max_index=$i\n        for j in $(seq $i $(($len-1))); do\n          \
    \  if [ $(abs \"${num_array[$j]}\") -gt $(abs \"${num_array[$max_index]}\") ];\
    \ then\n                max_index=$j\n            fi\n        done\n        #\
    \ swap\n        tmp=${num_array[$i]}\n        num_array[$i]=${num_array[$max_index]}\n\
    \        num_array[$max_index]=$tmp\n    done\n    # add a leading space to each\
    \ number, except for the first number\n    i=0\n    for i in $(seq 1 $(($k-1)));\
    \ do\n        max_array[$i]=\" ${num_array[$i]}\"\n    done\n    max_array[0]=${num_array[0]}\n\
    \    echo \"${max_array[@]}\"", "    local -a arr=(\"$@\")\n    local -a result\n\
    \    local i=0\n    local j=0\n    local len=$(echo \"$1\" | wc -w)\n    local\
    \ len2=$2\n    while [ $i -lt $len2 ]; do\n        local curr=$(echo \"$1\" |\
    \ cut -d' ' -f $i)\n        local max=$curr\n        local max_index=$i\n    \
    \    while [ $j -lt $len ]; do\n            local val=$(echo \"$1\" | cut -d'\
    \ ' -f $j)\n            if [ $curr -lt $val ]; then\n                max=$val\n\
    \                max_index=$j\n            fi\n            ((j++))\n        done\n\
    \        result[$i]=$max\n        arr[$max_index]=$curr\n        ((i++))\n   \
    \     j=0\n    done\n    echo ${result[@]}", "    if [[ $# -ne 2 ]]; then\n  \
    \      printf \"Error: $(maximum): requires 2 args\\n\" 1>&2\n        return 1\n\
    \    fi\n    local n=$2\n    local lst=$(awk '{ for (i=1; i<=NF; i++) print $i\
    \ }' <<< \"$1\")\n    local i\n    local maxs=()\n    for ((i=0; i<n; i++)); do\n\
    \        maxs+=(0)\n    done\n    local x\n    local max\n    for x in $lst; do\n\
    \        if ((x > maxs[0])); then\n            maxs[0]=$x\n            maxs=$(sort\
    \ -r <<< \"${maxs[*]}\")\n        fi\n    done\n    local out=\"[\"\n    for max\
    \ in ${maxs[@]}; do\n        out+=\"\\\"$max\\\",\"\n    done\n    echo \"${out::-1}]\"",
  "    var=$(echo \"$1\" | tr \" \" \"\\n\" | sort -nr | head -n $2)\n    echo \"\
    $var\" | sed 's/^/\\\"/' | sed 's/$/\\\"/'", "    local -a arr\n    arr=(${1//\
    \ / })\n    local k=$2\n    local -a ans\n    local i ans_i\n    # Assume there\
    \ is no duplicate, so we can use set to remove them\n    # Sorted in descending\
    \ order\n    local -a set=($(for i in ${arr[@]}; do echo $i; done | sort -n |\
    \ uniq))\n    local -a max\n    for ans_i in ${!set[@]}; do\n        if [[ ${#ans[@]}\
    \ -lt $k ]]; then\n            ans+=(\"${set[$ans_i]}\")\n        else\n     \
    \       # Check if the min element in ans is smaller than the next\n         \
    \   # element in set\n            if [[ ${set[$ans_i]} -gt ${ans[-1]} ]]; then\n\
    \                max=($(for i in ${ans[@]}; do echo $i; done | sort -n))\n   \
    \             ans=(${ans[@]/${max[0]}/${set[$ans_i]}})\n            fi\n     \
    \   fi\n    done\n    for i in ${ans[@]}; do echo $i; done | jq -Rs 'split(\"\\\
    n\")'", "    local arr=()\n    local max_nums=()\n    for num in $1; do\n    \
    \    arr+=($num)\n    done\n    for i in $(seq 1 $2); do\n        local index=0\n\
    \        local max=${arr[0]}\n        for j in $(seq 1 $(( ${#arr[@]} - 1 )));\
    \ do\n            if [ \"${arr[$j]}\" -gt \"$max\" ]; then\n                max=${arr[$j]}\n\
    \                index=$j\n            fi\n        done\n        max_nums+=($max)\n\
    \        unset arr[$index]\n    done\n    echo \"${max_nums[@]}\"", "  local array=(${1//\
    \ / })\n  local nums=()\n  local length=${#array[@]}\n  local k=${2}\n  local\
    \ i=0\n  local maxi=0\n  local maxv=0\n  local curr=0\n  local j=0\n  local temp=0\n\
    \  while [[ $i -lt $k ]]; do\n    maxv=${array[$(( $i ))]}\n    maxi=$i\n    j=$((\
    \ $i + 1 ))\n    while [[ $j -lt $length ]]; do\n      curr=${array[$(( $j ))]}\n\
    \      if [[ \"$curr\" -gt \"$maxv\" ]]; then\n        maxv=$curr\n        maxi=$j\n\
    \      fi\n      (( j++ ))\n    done\n    temp=${array[$(( $i ))]}\n    array[$((\
    \ $i ))]=$maxv\n    array[$(( $maxi ))]=$temp\n    nums[$(( $i ))]=$maxv\n   \
    \ (( i++ ))\n  done\n  echo ${nums[@]}", "    local -a A B\n    local n\n    A=($1)\n\
    \    B=()\n    n=${#A[@]}\n    while ((${#B[@]} < $2)); do\n        local i j\n\
    \        local max max_index\n        max=${A[0]}\n        max_index=0\n     \
    \   for ((i=1; i<n; i++)); do\n            local x=${A[i]}\n            if ((x\
    \ > max)); then\n                max=$x\n                max_index=$i\n      \
    \      fi\n        done\n        B[${#B[@]}]=$max\n        A[$max_index]=$MIN_INT\n\
    \    done\n    echo ${B[@]}", "    local -a arr=($1)\n    local k=$2\n    local\
    \ -a res=()\n    for ((i=0; i<${#arr[@]}; i++)); do\n        for ((j=0; j<i; j++));\
    \ do\n            if ((arr[i] > arr[j])); then\n                local tmp=${arr[i]}\n\
    \                arr[i]=${arr[j]}\n                arr[j]=$tmp\n            fi\n\
    \        done\n    done\n    for ((i=0; i<$k; i++)); do\n        res[i]=${arr[i]}\n\
    \    done\n    echo ${res[@]}", "  echo $1 \\\n  | tr ' ' '\\n' \\\n  | sort -nr\
    \ \\\n  | head -n $2 \\\n  | tr '\\n' ' ' \\\n  | sed 's/^/[/' \\\n  | sed 's/\
    \ /\", \"/g' \\\n  | sed 's/$/\"]/'", "    echo -n \"[\"\n    (IFS=\" \"; arr=($1);\
    \ echo \"${arr[*]}\" | sort -rn) | head -n $2 | sed -e 's/ /\", \"/g'\n    echo\
    \ -n \"]\"", "    if [ ! -z \"$1\" ] && [ ! -z \"$2\" ]; then\n        local result=()\n\
    \        IFS=' ' read -r -a array <<< \"$1\"\n        for i in ${array[@]}; do\n\
    \            if [ ${#result[@]} -lt $2 ]; then\n                result+=(\"$i\"\
    )\n            else\n                for j in ${!result[@]}; do\n            \
    \        if [ \"$i\" -gt \"${result[$j]}\" ]; then\n                        result[$j]=\"\
    $i\"\n                        break\n                    fi\n                done\n\
    \            fi\n        done\n        echo \"${result[@]}\"\n    fi", "    local\
    \ arr\n    local i\n    local len\n    local val\n    local sublist\n    local\
    \ entry\n    IFS=' ' read -r -a arr <<< $1\n    len=${#arr[@]}\n    sublist=()\n\
    \    for ((i=0; i<$len; i++)); do\n        val=${arr[$i]}\n        # empty\n \
    \       if [[ ${#sublist[@]} -eq 0 ]]; then\n            sublist+=($val)\n   \
    \         continue\n        fi\n        # not empty\n        for ((j=0; j<${#sublist[@]};\
    \ j++)); do\n            entry=${sublist[$j]}\n            if [[ $val -gt $entry\
    \ ]]; then\n                sublist=(${sublist[@]:0:$j} $val ${sublist[@]:$j})\n\
    \                if [[ ${#sublist[@]} -gt $2 ]]; then\n                    sublist=(${sublist[@]:0:$2})\n\
    \                fi\n                break\n            elif [[ $j -eq $(( ${#sublist[@]}\
    \ - 1 )) ]]; then\n                sublist+=($val)\n                if [[ ${#sublist[@]}\
    \ -gt $2 ]]; then\n                    sublist=(${sublist[@]:1})\n           \
    \     fi\n            fi\n        done\n    done\n    printf \"%s\\n\" \"${sublist[@]}\"",
  "  local array=(\"$@\")\n  unset 'array[0]'\n  unset 'array[1]'\n  local sorted=(\"\
    $(tr ' ' '\\n' <<<\"${array[@]}\" | sort -n)\" \"${array[@]}\")\n  local result=(\"\
    ${sorted[@]:0:$((1 + $2))}\")\n  printf '\"%s\" ' \"${result[@]}\"", "    local\
    \ max=()\n    local local_max\n    # space-separated list to array\n    IFS=\"\
    \ \" read -r -a arr <<< \"$1\"\n    # -r is to disable backslash escaping, -a\
    \ to split the array on whitespace\n    # -a is the name of the array, in our\
    \ case arr\n    for (( i=0; i<\"$2\"; i++ )); do\n        # local_max is the index\
    \ of the maximum value among arr[1] to arr[i]\n        local_max=0\n        for\
    \ (( j=1; j<=i; j++ )); do\n            # find the index of maximum value\n  \
    \          if [[ \"${arr[$j]}\" -gt \"${arr[$local_max]}\" ]]; then\n        \
    \        local_max=$j\n            fi\n        done\n        # swap arr[i] and\
    \ arr[local_max]\n        temp=${arr[$i]}\n        arr[$i]=${arr[$local_max]}\n\
    \        arr[$local_max]=$temp\n    done\n    # select arr[0] to arr[k-1]\n  \
    \  max=( \"${arr[@]:0:$2}\" )\n    # use quotes to make sure the values are preserved\n\
    \    # otherwise, if the values have spaces, they will be split on the spaces\n\
    \    printf '%q\\n' \"${max[@]}\"", "    local -a arr=($1)\n    local k=$2\n \
    \   local -a arr2=()\n    local min\n    local min_idx\n    local n\n    while\
    \ (( k > 0 )); do\n        n=${#arr[@]}\n        min=${arr[0]}\n        min_idx=0\n\
    \        for i in $(seq 1 $((n-1))); do\n            if [[ ${arr[$i]} -lt $min\
    \ ]]; then\n                min=${arr[$i]}\n                min_idx=$i\n     \
    \       fi\n        done\n        arr2+=(\"$min\")\n        unset arr[$min_idx]\n\
    \        (( k-- ))\n    done\n    echo \"${arr2[@]}\"", "    (( $# != 2 )) &&\
    \ echo \"[\\\"null\\\"]\" && return 0\n    local arr=$1\n    local k=$2\n    local\
    \ -a a\n    local -a r\n    for i in ${arr// /}; do\n        a+=($i)\n    done\n\
    \    k=$((k-1))\n    for ((i=0; i<=k; i++)); do\n        local max=${a[0]}\n \
    \       local max_index=0\n        for ((j=1; j<${#a[@]}; j++)); do\n        \
    \    if ((${a[j]} > max)); then\n                max=${a[j]}\n               \
    \ max_index=$j\n            fi\n        done\n        r+=($max)\n        unset\
    \ \"a[$max_index]\"\n    done\n    echo \"$(echo \"${r[@]}\" | sed 's/ /\", \"\
    /g')\"", "  local input_str\n  local output_str\n  local tmp_str\n  local v0 v1\
    \ v2 v3 v4\n  local i\n  for i in $(seq 1 \"$2\"); do\n    tmp_str=\"$(echo \"\
    $1\" | tr \" \" \"\\n\" | sort -rn | head -n\"$i\" | tail -n1)\"\n    output_str=\"\
    $output_str $tmp_str\"\n  done\n  echo \"[$output_str]\"", "    declare -a arr\n\
    \    local k=$2\n    # The following gets past special characters like a quotation\
    \ mark\n    IFS=$'\\n' arr=($(echo -e \"$1\"))\n    IFS=$' '\n    declare -a max\n\
    \    local i=0\n    local j=0\n    local max_size=0\n    #\n    # C++ equiv:\n\
    \    # std::sort(arr.begin(), arr.end(), [](int a, int b) -> bool {\n    #   \
    \ return std::abs(a) > std::abs(b); });\n    # std::vector<int>::iterator it =\
    \ arr.begin();\n    # std::advance(it, k);\n    # arr.erase(it, arr.end());\n\
    \    #\n    # In bash, an array is a list, but we can't sort it, only iterate\
    \ over it.\n    # So we'll use a max heap to get the k maximum values.\n    #\n\
    \    for ((i=0; i<${#arr[@]}; i++)); do\n        if (( max_size == k )); then\n\
    \            if (( max[0] < arr[i] )); then\n                max[0]=${arr[i]}\n\
    \                j=0\n                while (( j<=max_size/2 )); do\n        \
    \            local temp=0\n                    if (( (j*2)+1 < max_size )); then\n\
    \                        if (( max[j] < max[(j*2)+1] )); then\n              \
    \              temp=max[j]\n                            max[j]=max[(j*2)+1]\n\
    \                            max[(j*2)+1]=$temp\n                        fi\n\
    \                    fi\n                    if (( (j*2)+2 < max_size )); then\n\
    \                        if (( max[j] < max[(j*2)+2] )); then\n              \
    \              temp=max[j]\n                            max[j]=max[(j*2)+2]\n\
    \                            max[(j*2)+2]=$temp\n                        fi\n\
    \                    fi\n                    (( j++ ))\n                done\n\
    \            fi\n        else\n            (( max_size++ ))\n            max[$max_size]=${arr[i]}\n\
    \            j=$max_", "    [[ \"$1\" =~ ' ' ]] && IFS=' ' read -r -a a <<< \"\
    $1\" || a=(\"$1\")\n    _map=($(printf \"%s\\n\" \"${a[@]}\" | sort -n | tail\
    \ -n $2))\n    printf \"['%s']\\n\" \"${_map[@]}\"", "  # split a list $1 into\
    \ an array (indexed by \"$index\")\n  # use for-loop to \n  #  - remove negative\
    \ integers\n  #  - sort the array in ascending order\n  #  - grab the \"tail\"\
    \ k elements from the array\n  #  - concatenate the result with a space-separated\
    \ array\n  #  - remove the space in the beginning of the result array\n  local\
    \ list=($1)\n  local k=\"$2\"\n  local result=()\n  local index=0\n  for i in\
    \ \"${list[@]}\"; do\n    if [[ $i -ge 0 ]]; then\n      result[$index]=$i\n \
    \     index=$(($index + 1))\n    fi\n  done\n  result=($(printf \"%s\\n\" \"${result[@]}\"\
    \ | sort -n))\n  result=($(printf \"%s\\n\" \"${result[@]}\" | tail -n $k))\n\
    \  result=($(printf \"%s \" \"${result[@]}\"))\n  result=${result:1}\n  echo \"\
    [${result// /, }]\"", "    local -a nums=()\n    local -a result=()\n    local\
    \ num=\n    local i=\n    local m=\n    local n=\n    local r=\n    local index=\n\
    \n    IFS=' ' read -ra nums <<< \"$1\"\n    r=\"$2\"\n    for ((i=0; i<r; i++));\
    \ do\n        for ((m=0; m<${#nums[@]}; m++)); do\n            index=\"$m\"\n\
    \            num=\"${nums[$m]}\"\n            for ((n=m+1; n<${#nums[@]}; n++));\
    \ do\n                if (( num < ${nums[$n]} )); then\n                    num=\"\
    ${nums[$n]}\"\n                    index=\"$n\"\n                fi\n        \
    \    done\n            nums[$index]=\"${nums[$m]}\"\n            nums[$m]=\"$num\"\
    \n        done\n        result+=(\"$num\")\n    done\n    printf '[\"%s\"]\\n'\
    \ \"${result[@]}\"", "  local max\n  local arr\n  local index=0\n  local k\n \
    \ arr=($1)\n  k=$2\n  while [[ \"$index\" -lt \"$k\" ]]; do\n    max=$(echo \"\
    ${arr[@]}\" | sort -n | tail -n 1)\n    arr=(${arr[@]/$max})\n    echo \"\\\"\
    $max\\\"\"\n    index=$((index+1))\n  done", "    local -a arr\n    read -ra arr\
    \ <<< \"${1// /}\"\n    local -n ret\n    ret=()\n    local num\n    for num in\
    \ \"${arr[@]}\"; do\n        if [[ ${#ret[@]} -lt $2 ]]; then\n            ret+=($num)\n\
    \        else\n            local index\n            for index in ${!ret[@]}; do\n\
    \                if [[ $num -gt ${ret[$index]} ]]; then\n                    ret=(${ret[@]:0:$index}\
    \ $num ${ret[@]:$index})\n                    break\n                fi\n    \
    \        done\n        fi\n    done\n    echo \"${ret[@]:0:$2}\"", "    local\
    \ myArray=()\n    local index=0\n    IFS=' ' read -r -a myArray <<< \"$1\"\n \
    \   while [ $index -lt $2 ]; do\n        local max=${myArray[0]}\n        local\
    \ maxIndex=0\n        for i in \"${!myArray[@]}\"; do\n            if [[ \"${myArray[$i]}\"\
    \ -gt \"$max\" ]]; then\n                max=\"${myArray[$i]}\"\n            \
    \    maxIndex=$i\n            fi\n        done\n        unset myArray[$maxIndex]\n\
    \        echo $max\n        index=$((index+1))\n    done", "    local IFS=$'\\\
    n'\n    local -a Arr=($(echo $1 | tr \" \" \"\\n\" | sort -nr))\n    Arr=(\"${Arr[@]:0:$2}\"\
    )\n    local -a Result=()\n    for i in \"${Arr[@]}\"; do\n        Result+=(\"\
    \\\"$i\\\"\")\n    done\n    echo \"[${Result[*]}]\"", "    local k=$2\n    local\
    \ d=${1// /$'\\n'}\n    local d=($(echo \"$d\" | sort -nr))\n    for ((i=0; i<k;\
    \ i++)); do echo -n \\\"${d[$i]}\\\"\\ ; done\n    echo", "    #\n    # The main\
    \ idea is to remove the smallest element in the array until the\n    # array size\
    \ is $2.\n    #\n    # This algorithm takes O(n*log(n)) time.\n    #\n    local\
    \ nums=\"$1\"\n    local k=\"$2\"\n    local IFS=$' '\n    # convert string to\
    \ array\n    read -a nums_array <<< \"$nums\"\n    local i=0\n    while [ $i -lt\
    \ \"${#nums_array[@]}\" ]; do\n        if [ $(( ${#nums_array[@]} - i )) -le \"\
    $k\" ]; then\n            # the array size is less than $k, so the array is sorted.\n\
    \            # print the array.\n            local j=0\n            while [ $j\
    \ -lt \"${#nums_array[@]}\" ]; do\n                echo -n ${nums_array[$j]}\n\
    \                if [ $j -lt $(( ${#nums_array[@]} - 1 )) ]; then\n          \
    \          echo -n \", \"\n                fi\n                j=$(( j + 1 ))\n\
    \            done\n            echo\n            break\n        fi\n        #\
    \ find the index of the smallest element\n        local min_i=$i\n        local\
    \ j=$(( i + 1 ))\n        while [ $j -lt \"${#nums_array[@]}\" ]; do\n       \
    \     if [ \"${nums_array[$j]}\" -lt \"${nums_array[$min_i]}\" ]; then\n     \
    \           min_i=$j\n            fi\n            j=$(( j + 1 ))\n        done\n\
    \        # remove the smallest element in the array\n        local j=$(( min_i\
    \ + 1 ))\n        while [ $j -lt \"${#nums_array[@]}\" ]; do\n            nums_array[$((\
    \ j - 1 ))]=${nums_array[$j]}\n            j=$(( j + 1 ))\n        done\n    \
    \    unset nums_array[$(( ${#nums_array[@]} - 1 ))]\n    done", "    list=$1\n\
    \    k=$2\n    list=(${list// / })\n    for ((i=0; i<${#list[@]}; i++)); do\n\
    \        for ((j=i+1; j<${#list[@]}; j++)); do\n            if (( ${list[i]} <\
    \ ${list[j]} )); then\n                tmp=${list[i]}\n                list[i]=${list[j]}\n\
    \                list[j]=$tmp\n            fi\n        done\n    done\n    arr=(\"\
    ${list[@]:0:$k}\")\n    echo \"[$(IFS=,; echo \"${arr[*]}\")]\"", "    # Create\
    \ an array from the string of numbers:\n    IFS=\" \" read -r -a arr <<< \"$1\"\
    \n    # Sort arr in descending order:\n    sorted=($(printf \"%s\\n\" \"${arr[@]}\"\
    \ | sort -nr))\n    # Slice the first n elements from the sorted array:\n    sliced=($(printf\
    \ \"%s\\n\" \"${sorted[@]:0:$2}\"))\n    # Convert each element in the array to\
    \ a double-quoted string:\n    quoted=()\n    for element in \"${sliced[@]}\"\
    ; do\n        quoted+=(\"\\\"$element\\\"\")\n    done\n    # Join the elements\
    \ in the array with a comma,\n    # and enclose the whole thing in square brackets:\n\
    \    printf \"[%s]\" \"$(IFS=,; echo \"${quoted[*]}\")\"", "    # if $1 is not\
    \ of space-separated list type, return error\n    if ! [[ \"$1\" =~ ^[0-9\\-]+\\\
    \ ([0-9\\-]+\\ )*[0-9\\-]+$ ]]; then\n        echo \"error\"\n        return 1\n\
    \    fi\n    # if $2 is not an integer, return error\n    if ! [[ \"$2\" =~ ^[0-9]+$\
    \ ]]; then\n        echo \"error\"\n        return 1\n    fi\n    # string ->\
    \ array\n    local input_array\n    input_array=($1)\n    # sort the array in\
    \ descending order\n    local sorted_array\n    sorted_array=($(for element in\
    \ ${input_array[@]}; do\n        echo $element\n    done | sort -nr))\n    # select\
    \ first $2 elements\n    local output_array\n    output_array=(\"${sorted_array[@]:0:$2}\"\
    )\n    # array -> string\n    echo \"${output_array[@]}\"", "    _maximum_helper\
    \ $1 | sort -nr | head -$2 | tr \"\\n\" \" \" | sed 's/[ ]*$//'", "    local -a\
    \ strs\n    local -i k cnt\n    cnt=0\n    k=$2\n    strs=( $(echo \"$1\" | tr\
    \ \" \" \"\\n\" | sort -gr) )\n    echo -n \"[\"\n    for (( ; cnt < k; cnt++\
    \ )); do\n        [[ $cnt -ne 0 ]] && echo -n \", \"\n        echo -n \"'${strs[$cnt]}'\"\
    \n    done\n    echo \"]\"", "    if [[ $# -eq 2 ]]; then\n        local max=()\n\
    \        local arr=($1)\n        local len=${#arr[@]}\n        local k=$2\n  \
    \      if [[ $len -ge $k ]]; then\n            for (( i=0; i<len; i++ )); do\n\
    \                if [[ ${#max[@]} -eq 0 ]]; then\n                    max+=(\"\
    ${arr[$i]}\")\n                else\n                    for (( j=0; j<${#max[@]};\
    \ j++ )); do\n                        if [[ ${arr[$i]} -ge ${max[$j]} ]]; then\n\
    \                            max=(${max[@]:0:$j} \"${arr[$i]}\" ${max[@]:$j})\n\
    \                            break\n                        elif [[ $j -eq $((${#max[@]}-1))\
    \ ]]; then\n                            max+=(\"${arr[$i]}\")\n              \
    \          fi\n                    done\n                fi\n            done\n\
    \            max=(${max[@]:0:$k})\n        fi\n        printf \"[\"\n        for\
    \ i in ${max[@]}; do\n            printf \"\\\"%s\\\"\" \"$i\"\n            if\
    \ [[ $i != ${max[$((${#max[@]}-1))]} ]]; then\n                printf \", \"\n\
    \            fi\n        done\n        printf \"]\"\n    fi", "  declare -a ARR\n\
    \  ARR=($1)\n  N=\"$2\"\n  printf '%s\\n' \"${ARR[@]}\" | sort -r | head -n $N\
    \ | \n  while read line; do\n    printf '\"%s\" ' \"$line\"\n  done\n  echo \"\
    \"", "    local res=\"[\"\n    arr=()\n    for n in $1; do\n        arr+=($n)\n\
    \    done\n    for ((i=0; i<$2; i++)); do\n        local max=\"-1001\"\n     \
    \   for ((j=0; j<${#arr[@]}; j++)); do\n            if [[ ${arr[$j]} -gt $max\
    \ ]]; then\n                max=${arr[$j]}\n                max_index=$j\n   \
    \         fi\n        done\n        res=$res'\"'$max'\"'\n        if [[ $i -lt\
    \ $(( $2 - 1 )) ]]; then\n            res=$res\", \"\n        fi\n        unset\
    \ arr[$max_index]\n    done\n    res=$res\"]\"\n    echo $res", "    # shellcheck\
    \ disable=SC2016\n    echo -n \"[$( echo \"$1\" | sed -r 's/\\s+/-999\\n/g' |\
    \ sort -r -g | head -n \"$2\" | sed -r 's/(-999\\s*)?/\\\"/g' | tr '\\n' ',' |\
    \ sed -r 's/,$//' )]\"", "    printf \"[%s]\\n\" \"$1\" | tr ' ' '\\n' | sort\
    \ -n | tail -$2 | tr '\\n' ',' | sed 's/.$//'", "  local list=($1)\n  local k=$2\n\
    \  local i=0\n  local len=${#list[@]}\n  while [ $i -lt $k ]; do\n    if [ $i\
    \ -eq 0 ]; then\n      local max=$i\n    else\n      [ ${list[$i]} -gt ${list[$max]}\
    \ ] && local max=$i\n    fi\n    let i++\n  done\n  # to remove the \"max\" element\n\
    \  local max_ele=${list[$max]}\n  unset list[$max]\n  local j=0\n  local len=$(($len-1))\n\
    \  for (( j=0; j<$len; j++ )); do\n    if [ $j -eq 0 ]; then\n      local max=$j\n\
    \    else\n      [ ${list[$j]} -gt ${list[$max]} ] && local max=$j\n    fi\n \
    \ done\n  local new_max=${list[$max]}\n  unset list[$max]\n  local new_max_ele=\"\
    $new_max\"\n  len=$(($len-1))\n  if [ $len -eq 0 ]; then\n    local max_array=$max_ele\n\
    \  else\n    local max_array=$max_ele,$new_max_ele\n  fi\n  echo \"${max_array}\"",
  "  local -r arr=\"$1\"\n  local -r k=\"$2\"\n  local -r arr_len=$(echo $arr | wc\
    \ -w)\n  for i in $(seq 1 $arr_len); do\n    local j=$((i-1))\n    local min_index=$i\n\
    \    while [ $j -ge 0 ]; do\n      if [ $(( $(echo \"$arr\" | awk -v a=$j '{print\
    \ $a}') )) -lt $(( $(echo \"$arr\" | awk -v a=$min_index '{print $a}') )) ]; then\n\
    \        min_index=$j\n      fi\n      j=$((j-1))\n    done\n    local temp=$((\
    \ $(echo \"$arr\" | awk -v a=$i '{print $a}') ))\n    local arr=$(echo \"$arr\"\
    \ | awk -v a=$i -v b=$min_index -v t=$temp '{$a=$b;$b=t;for(i=1;i<=NF;i++)print\
    \ $i}')\n  done\n  if [ $k -gt $arr_len ]; then\n    echo $arr\n  else\n    echo\
    \ \"$arr\" | awk -v l=$k '{for(i=NF-l+1;i<=NF;i++)print $i}'\n  fi", "    local\
    \ -a arr=(\"$@\")\n    local -i i=0\n    local -i len=${#arr[@]}\n    local -i\
    \ k=${arr[len-1]}\n    local -i max=${arr[0]}\n    local -i max_index=0\n    local\
    \ -i temp\n    local -i temp_index\n    local -i j\n    local -i max_len=$((len-1))\n\
    \    local -a result\n    for ((i=0; i<k; i++)); do\n        for ((j=0; j<max_len;\
    \ j++)); do\n            [[ ${arr[j]} -gt $max ]] && {\n                max=${arr[j]}\n\
    \                max_index=$j\n            }\n        done\n        result[i]=$max\n\
    \        arr[max_index]=${arr[max_len]}\n        max=${arr[0]}\n        max_len=$((max_len-1))\n\
    \    }\n    echo \"${result[@]}\"", "    local -a arr=( $(echo \"$1\" | tr ' '\
    \ '\\n' | sort -nr) )\n    echo -n '['\n    for ((i=0; i<$2; i++)); do\n     \
    \   if [[ i -ne 0 ]]; then\n            echo -n ', '\n        fi\n        echo\
    \ -n '\"'${arr[$i]}'\"'\n    done\n    echo ']'", "    local -r arr=\"$1\" k=\"\
    $2\"\n    local sorted_arr i j max tmp\n    # First sort the array\n    sorted_arr=$(python\
    \ -c \"print('$arr'.split()).sort()\")\n    # Take the last k elements from the\
    \ sorted array\n    for ((i=${#sorted_arr[@]}-1, j=0; j<k; j++, i--)); do\n  \
    \      # Append each element to the max string\n        max+=\"${sorted_arr[i]}\
    \ \"\n    done\n    # Remove the last space\n    max=${max::-1}\n    # Sort the\
    \ max string again\n    for ((i=${#max[@]}-1, j=0; j<${#max[@]}; j++, i--)); do\n\
    \        # Append each element to the tmp string\n        tmp+=\"${max[i]} \"\n\
    \    done\n    # Remove the last space\n    max=${tmp::-1}\n    # Print the max\
    \ string\n    printf \"$max\"", "    arr=()\n    for i in $1; do\n        if [[\
    \ \"$2\" -gt 0 ]]; then\n            for ((j=0; j<${#arr[@]}; j++)); do\n    \
    \            if [[ \"$i\" -ge \"${arr[$j]}\" ]]; then\n                    arr=(\"\
    ${arr[@]:0:$j}\" \"$i\" \"${arr[@]:$j}\")\n                    break\n       \
    \         fi\n            done\n            ((j==${#arr[@]})) && arr+=(\"$i\"\
    )\n            ((--$2))\n        else\n            for ((j=0; j<${#arr[@]}; j++));\
    \ do\n                if [[ \"$i\" -ge \"${arr[$j]}\" ]]; then\n             \
    \       arr=(\"${arr[@]:0:$j}\" \"$i\" \"${arr[@]:$j+1}\")\n                 \
    \   break\n                fi\n            done\n        fi\n    done\n    echo\
    \ \"${arr[@]}\"", "    local arr=()\n    local k=0\n    for i in ${1}; do\n  \
    \      arr+=($i)\n    done\n    k=$2\n    local n=${#arr[@]}\n    local max=0\n\
    \    local result=()\n    for (( i=0; i<n; i++ )); do\n        for (( j=i+1; j<n;\
    \ j++ )); do\n            if [[ ${arr[$i]} -gt ${arr[$j]} ]]; then\n         \
    \       max=${arr[$i]}\n                arr[$i]=${arr[$j]}\n                arr[$j]=$max\n\
    \            fi\n        done\n    done\n    for (( i=0; i<k; i++ )); do\n   \
    \     result+=(${arr[$i]})\n    done\n    echo ${result[@]}", "  # Initialize\
    \ a hash to store the frequency of each number in the list.\n  for num in $(echo\
    \ $1); do\n    ((++bucket[$num]))\n  done\n  # Create an array for the sorted\
    \ keys.\n  for key in \"${!bucket[@]}\"; do\n    keys[${#keys[@]}]=$key\n  done\n\
    \  # Sort the array in a descending order.\n  sorted=$(for num in \"${keys[@]}\"\
    ; do echo $num; done | sort -nr)\n  # Split the array into an array of length\
    \ n if n is less than or equal to\n  # the length of the array.\n  sorted_arr=()\n\
    \  if [ $2 -le ${#keys[@]} ]; then\n    for num in $(echo $sorted | awk '{ print\
    \ $1, $2, $3, $4, $5, $6, $7, $8, $9, $10 }'); do\n      sorted_arr[${#sorted_arr[@]}]=$num\n\
    \    done\n  else\n    for num in $(echo $sorted); do\n      sorted_arr[${#sorted_arr[@]}]=$num\n\
    \    done\n  fi\n  # Convert the array into a string and return the first k elements.\n\
    \  str=$(echo ${sorted_arr[@]})\n  echo ${str:0:$2}", "    n=${2:-1}\n    echo\
    \ -n \"[\"\n    for i in $(echo $1 | sed 's/\\([^ ]*\\)/\"\\1\"/g'); do\n    \
    \    if [[ $i -gt $2 ]]; then\n            echo -n \"$i \"\n        fi\n    done\
    \ | head -n $n | tr '\\n' ' '\n    echo -n \"]\"", "  local arr_str=\"$1\"\n \
    \ local k=\"$2\"\n  local i\n  local len=$(echo \"$arr_str\" | awk '{print NF}')\n\
    \  local max_values\n  local j\n  local max_value\n  # Check that k is non-negative\
    \ and not greater than length of array\n  if [[ \"$k\" -ge 0 && \"$k\" -le \"\
    $len\" ]]; then\n    # Compute maximum k values\n    for ((i=0; i<k; i++)); do\n\
    \      max_value=$(echo \"$arr_str\" | awk '{max=$1; for (i=2; i<=NF; i++) if\
    \ ($i>max) max=$i; print max}')\n      max_values=$(add \"$max_values\" \"$max_value\"\
    )\n      arr_str=$(echo \"$arr_str\" | awk '{$1=max; for (i=2; i<=NF; i++) $i=($i==max)?next:$i;\
    \ print $0}' max=\"$max_value\")\n    done\n    # Format maximum k values to be\
    \ comma-separated, surrounded by single quotes\n    max_values=$(echo \"$max_values\"\
    \ | awk '{for (i=1; i<=NF; i++) printf(\"%s%s\", i==1 ? \"[\" : \"\", $i); print\
    \ \"]\"}')\n    echo \"$max_values\"\n  else\n    echo \"Invalid input\"\n  fi",
  "    echo \"${1}\" |\n    tr ' ' '\\n' |\n    sort -k 1 -rn |\n    head -n \"${2}\"\
    \ |\n    sed 's/^/\"/' |\n    sed 's/$/\"/' |\n    tr '\\n' ' ' |\n    sed 's/\
    \ $//'", "    arr=(${1// /})\n    k=${2}\n    res=($(printf '%s\\n' \"${arr[@]}\"\
    \ | sort -nr | head -n \"${k}\"))\n    echo \"${res[@]}\"", "    local arr=($1)\n\
    \    local k=$2\n    local result=()\n    local i=0\n\n    while (( i < k ));\
    \ do\n        local max=${arr[0]}\n        local max_index=0\n        local arr_i=0\n\
    \        for num in ${arr[@]}; do\n            (( arr_i++ ))\n            if ((\
    \ $num > $max )); then\n                max=$num\n                max_index=$arr_i\n\
    \            fi\n        done\n        result+=($max)\n        unset arr[$max_index]\n\
    \        (( i++ ))\n    done\n\n    echo ${result[@]}", "  local i j idx result\n\
    \  local -a arr=($1)\n  for ((i=0; i<$2; i++)); do\n    idx=0\n    for ((j=1;\
    \ j<${#arr[@]}; j++)); do\n      if [[ ${arr[j]} -gt ${arr[idx]} ]]; then\n  \
    \      idx=$j\n      fi\n    done\n    result+=(${arr[idx]})\n    unset arr[idx]\n\
    \  done\n  echo $result", "    local a=($1)\n    local k=$2\n    local r=()\n\
    \    local i\n    local n\n    local p\n    for (( i=0; i<$k; i++ )); do\n   \
    \     n=${a[0]}\n        p=0\n        for (( j=1; j<${#a[@]}; j++ )); do\n   \
    \         if (( a[j] > n )); then\n                n=${a[j]}\n               \
    \ p=$j\n            fi\n        done\n        r+=($n)\n        unset a[$p]\n \
    \   done\n    echo ${r[@]}", "    local -a arr=(\"$@\")\n    local -i j=0\n  \
    \  for ((i=1; i<${#arr[@]}; i++)); do\n        ((j=i-1))\n        local key=${arr[i]}\n\
    \        while ((j>=0 && arr[j]<key)); do\n            arr[j+1]=${arr[j]}\n  \
    \          ((j--))\n        done\n        arr[j+1]=$key\n    done\n    echo \"\
    ${arr[@]:0:$2}\"", "    python <(sed 's#.*#&#' <<< \"import sys;\ninput = '$1';\n\
    k = int('$2');\narr = list(map(int, input.split()));\nres = sorted(arr, reverse=True)[:k];\n\
    print(str(res).replace(' ',''))\n\")", "    local arr=\"$1\"\n    local k=\"$2\"\
    \n    heap=()\n    for i in $arr; do\n        heap+=(\"$i\")\n        heapify\n\
    \    done\n    top_k \"$k\"", "    local arr=($1)\n    local k=$2\n    local result=()\n\
    \    local sub_arr=()\n    local i=0\n    local j=0\n    local min=0\n    local\
    \ size=${#arr[@]}\n    while ((i < size)); do\n        while ((j < size)); do\n\
    \            if [[ \"${arr[$i]}\" -lt \"${arr[$j]}\" ]]; then\n              \
    \  let \"i++\"\n                break\n            fi\n            let \"j++\"\
    \n        done\n        if ((i < size)); then\n            sub_arr+=(\"${arr[$i]}\"\
    )\n        fi\n        let \"i++\"\n        j=0\n    done\n    result+=(${sub_arr[@]:\
    \ -$k})\n    echo \"${result[@]}\"", "    python -c \"\nimport itertools\ni=0\n\
    for x in sorted(list(map(int, \\\"$1\\\".split())), reverse=True):\n    print(x,\
    \ end=' ')\n    i+=1\n    if i == int(\\\"$2\\\"):\n        break\n\"", "    local\
    \ n i j k ans\n    ans=$(echo $1 | sed -e 's/ /\\n/g' | sort -r -n | head -n$2)\n\
    \    echo \"[\"\n    n=$(echo \"$ans\" | wc -l)\n    i=1\n    for j in $ans; do\n\
    \        echo -n \\\"$j\\\"\n        if [ $i -lt $n ]; then\n            echo\
    \ -n \", \"\n        fi\n        i=$((i+1))\n    done\n    echo \"]\"", "    k=$2\n\
    \    if [[ $k -gt $(echo $1 | wc -w) ]]; then\n        k=$(echo $1 | wc -w)\n\
    \    fi\n    echo \"$1\" | xargs -n $k | sort -r -n | head -n 1 | xargs", "  local\
    \ k=$2\n  local arr=$1\n  local max\n  local n\n  # Max heap\n  for n in $arr;\
    \ do\n    if (( ${#max[@]} < k )); then\n      max+=($n)\n    else\n      if ((\
    \ n > ${max[0]} )); then\n        max[0]=$n\n      fi\n    fi\n    heapify max\
    \ 0 ${#max[@]}\n  done\n  printf '[\"%s\"]\\n' \"${max[@]}\"", "    arr=($1)\n\
    \    k=$2\n    sorted=($(echo ${arr[@]} | tr \" \" \"\\n\" | sort -nr))\n    echo\
    \ \"[\"\n    for((i=0;i<$k;i++)); do\n        echo '\"'${sorted[$i]}'\"'\n   \
    \     if [[ $i != $(($k-1)) ]]; then\n            echo \",\"\n        fi\n   \
    \ done\n    echo \"]\"", "    result=()\n    for (( i=0; i<$2; i++ )); do\n  \
    \      max=0\n        for num in $1; do\n            if [[ $num -gt $max ]]; then\n\
    \                max=$num\n            fi\n        done\n        result[$i]=$max\n\
    \        temp=()\n        for num in $1; do\n            if [[ $num -ne $max ]];\
    \ then\n                temp+=($num)\n            fi\n        done\n        1=${temp[@]}\n\
    \    done\n    echo ${result[@]}", "    arr=($1)\n    arr=($(echo ${arr[@]} |\
    \ tr \" \" \"\\n\" | sort -r | head -n $2 | tr \"\\n\" \" \"))\n    echo ${arr[@]}",
  "    local sorted=\"$(echo $1 | tr ' ' '\\n' | sort -nr)\"\n    local array=($sorted)\n\
    \    local i\n    for ((i=0; i<$2; i++)); do\n        local value=\"${array[$i]}\"\
    \n        echo \"\\\"$value\\\"\"\n    done", "    local -a arr\n    read -ra\
    \ arr <<< \"${1// /$'\\n'}\"\n    for ((i=0; i<${#arr[@]}; i++)); do\n       \
    \ for ((j=i+1; j<${#arr[@]}; j++)); do\n            [ \"${arr[i]}\" -lt \"${arr[j]}\"\
    \ ] && tmp=${arr[i]} arr[i]=${arr[j]} arr[j]=$tmp\n        done\n    done\n  \
    \  echo \"${arr[@]:0:$2}\"", "    if [ $# -ne 2 ]; then\n        echo \"Usage:\
    \ maximum 'a b ...' k\"\n        return 1\n    fi\n    if [ $2 -lt 1 ] || [ $2\
    \ -gt $(echo $1 | wc -w) ]; then\n        echo \"Given k = $2 must be in the range\
    \ of [1, $(echo $1 | wc -w)]\"\n        return 1\n    fi\n    echo -n \"[\"\n\
    \    for max in $(echo $1 | sed 's/ /\\n/g' | sort -rn | head -n $2); do\n   \
    \     echo -n \"'\\\"$max\\\"', \"\n    done\n    echo -n \"\\b\\b]\"", "  echo\
    \ ${1} | tr ' ' '\\n' | sort -nr | head -n ${2} | tr '\\n' ' ' | sed 's/\\s*$//'",
  "    IFS=\" \" read -r -a ar <<< \"$1\"\n    len=\"${#ar[@]}\"\n    for (( i=0;\
    \ i<len; i++ )); do\n        for (( j=i+1; j<len; j++ )); do\n            if [[\
    \ \"${ar[i]}\" -lt \"${ar[j]}\" ]]; then\n                temp=\"${ar[i]}\"\n\
    \                ar[i]=\"${ar[j]}\"\n                ar[j]=\"$temp\"\n       \
    \     fi\n        done\n    done\n    for (( i=0; i<\"$2\"; i++ )); do\n     \
    \   echo -n \"\\\"${ar[i]}\\\" \"\n    done\n    echo", "  [[ -z \"$1\" ]] &&\
    \ return 1\n  [[ -z \"$2\" ]] && return 1\n  echo \"$1\" | tr ' ' '\\n' | sort\
    \ -rn | head -n \"$2\" | tr '\\n' ' ' | xargs echo", "    IFS=' '; read -r -a\
    \ a <<< \"$1\"; printf \"%s\\n\" \"${a[@]}\" | sort -rn | head -n $2 | xargs echo",
  "    local -n input=$1\n    local k=$2\n    local -a arr=(${input// / })\n    #\
    \ Fill a new array, new_arr, from the input array in a k-sized loop\n    # by\
    \ adding the new element to the end, and\n    # removing the lowest element from\
    \ the beginning until the size of\n    # new_arr is $k.\n    local -a new_arr\n\
    \    local elem\n    for ((i=0; i<k; i++)); do\n        elem=${arr[i]}\n     \
    \   new_arr[${#new_arr[@]}]=$elem\n        for ((j=i+1; j<${#arr[@]}; j++)); do\n\
    \            elem=${arr[j]}\n            # Add the new element to the end of new_arr.\n\
    \            new_arr[${#new_arr[@]}]=$elem\n            # Remove the lowest element\
    \ from the beginning of new_arr.\n            unset new_arr[0]\n        done\n\
    \    done\n    # Sort the array in ascending order.\n    declare -a sorted=($(printf\
    \ \"%s\\n\" \"${new_arr[@]}\" | sort -nu))\n    # Sort the array in descending\
    \ order.\n    declare -a max_sorted=($(printf \"%s\\n\" \"${sorted[@]}\" | sort\
    \ -nr))\n    echo ${max_sorted[@]}", "    local numbers=$1\n    local k=$2\n \
    \   local max=()\n    local i=0\n    for n in $numbers; do\n        if [[ \"${#max[@]}\"\
    \ -lt \"$k\" ]]; then\n            max[$i]=$n\n            let i+=1\n        else\n\
    \            if (( $(printf '%d < %d\\n' \"$n\" \"${max[0]}\") )); then\n    \
    \            continue\n            else\n                max[0]=$n\n         \
    \       local m=0\n                for (( j=1; j<k; j++ )); do\n             \
    \       if (( $(printf '%d < %d\\n' \"${max[j]}\" \"${max[m]}\") )); then\n  \
    \                      m=$j\n                    fi\n                done\n  \
    \              for (( j=0; j<k; j++ )); do\n                    if [[ $j -ne $m\
    \ ]]; then\n                        max[$j]=${max[$m]}\n                    fi\n\
    \                done\n            fi\n        fi\n    done\n    max=($(printf\
    \ \"%s\\n\" \"${max[@]}\" | sort -nr))\n    printf '[\"%s\"]\\n' \"${max[@]}\"",
  "    declare -a array=($1)\n    max=${array[0]}\n    for i in ${array[@]}; do\n\
    \        if (($i > $max)); then\n            max=$i\n        fi\n    done\n  \
    \  echo $max", "    if [ \"$#\" -ne 2 ]; then\n        echo \"Usage: maximum [SPACE-SEPARATED\
    \ LIST] [INTEGER]\"\n        exit 1\n    fi\n    input=$1\n    k=$2\n    for ((i=0;\
    \ i<$k; i++)); do\n        max=$(echo \"$input\" | tr ' ' '\\n' | sort -nr | head\
    \ -n 1)\n        echo -n \"\\\"$max\\\" \"\n        input=$(echo \"$input\" |\
    \ tr ' ' '\\n' | sed \"/$max/d\")\n    done\n    echo", "    arr=$1\n    k=$2\n\
    \    echo $arr | tr \" \" \"\\n\" | sort -nr | head -n $k | tr \"\\n\" \" \"",
  "  input=($1)\n  size=$2\n  result=()\n  for i in \"${input[@]}\"; do\n    if [[\
    \ ${#result[@]} -lt $size ]]; then\n      result+=($i)\n    else\n      for ((\
    \ j=0; j<${#result[@]}; j++ )); do\n        if [[ $i -gt ${result[$j]} ]]; then\n\
    \          result[$j]=$i\n          break\n        fi\n      done\n    fi\n  done\n\
    \  echo \"${result[@]}\"", "    local -n arr=$1\n    for i in $1; do\n       \
    \ arr[$i]=$i\n    done\n    arr=( $( printf \"%s\\n\" \"${arr[@]}\" | sort -rn\
    \ ) )\n    printf \"%s\\n\" \"${arr[@]:0:$2}\"", "    tmp_arr=($1)\n    len=${#tmp_arr[@]}\n\
    \    k=$2\n    for ((i = 0; i < len; i++)); do\n        for ((j = 0; j < len -\
    \ i - 1; j++)); do\n            if (( ${tmp_arr[j]} < ${tmp_arr[$((j + 1))]} ));\
    \ then\n                tmp=${tmp_arr[j]}\n                tmp_arr[$j]=${tmp_arr[$((j\
    \ + 1))]}\n                tmp_arr[$((j + 1))]=$tmp\n            fi\n        done\n\
    \    done\n    printf \"[\"\n    for ((i = 0; i < k; i++)); do\n        printf\
    \ \"'%s'\" \"${tmp_arr[i]}\"\n        if (( i < k - 1 )); then\n            printf\
    \ \", \"\n        fi\n    done\n    printf \"]\"", "    declare -a result=()\n\
    \    local i=0\n    for num in ${1}; do\n        (( i < $2 )) && result+=(${num})\n\
    \        i=$((i+1))\n    done\n    # Due to Python's pop function, the list is\
    \ in reverse order\n    printf '[%s]\\n' \"$( echo \"${result[@]}\" | tr ' ' '\\\
    n' | sort -n | head -n $2 | xargs | tr ' ' ',' | sed 's/,/\", \"/g' )\"", "  \
    \  local n\n    IFS=\" \" read -ra n <<< \"$1\"\n    echo \"${n[@]}\" | sort -nr\
    \ | head -n \"$2\" | tr '\\n' ' ' | sed 's/\\s/\", \"/g' | sed 's/^/\"/' | sed\
    \ 's/$/\"/'", "    local k=$2\n    local list=$1\n    local a=()\n    local r=()\n\
    \    local tmp=()\n    IFS=' ' read -r -a a <<< $list\n    local len=${#a[@]}\n\
    \    if [ $len -eq 0 ]; then\n        return 0\n    fi\n    if [ $len -eq 1 ];\
    \ then\n        echo \"[\\\"${a[0]}\\\"]\"\n        return 0\n    fi\n    for\
    \ (( i=0; i<$k; i++ )); do\n        r[$i]=${a[$i]}\n    done\n    heapify $k r[@]\n\
    \    for (( i=$k; i<$len; i++ )); do\n        if [[ ${a[$i]} -gt ${r[0]} ]]; then\n\
    \            r[0]=${a[$i]}\n            siftdown 0 $k r[@]\n        fi\n    done\n\
    \    # sorting the array\n    echo ${r[@]} | sort -r", "    # $1 is a space-separated\
    \ list\n    # $2 is an integer\n\n    # start with a space-separated list\n  \
    \  local __original__=\"$1\"\n    local __result__=\"$1\"\n    # replace spaces\
    \ with newlines\n    __result__=\"${__result__// /$'\\n'}\"\n    # reverse sort\
    \ (no flag for this in bash)\n    __result__=\"$(echo \"$__result__\" | sort -r)\"\
    \n    # get first $2 entries\n    __result__=\"$(echo \"$__result__\" | head -n\
    \ \"$2\")\"\n    # restore spaces\n    __result__=\"${__result__//$'\\n'/ }\"\n\
    \    # convert to string\n    __result__=\"$(echo \"$__result__\" | tr \" \" \"\
    ,\")\"\n    # return the result (surrounded by square brackets and quotes)\n \
    \   echo \"[$__result__]\"", "    local nums=$1\n    local k=$2\n    local -a\
    \ arr=($nums)\n    for ((i=0; i<${#arr[@]}; i++)); do\n        for ((j=0; j<${#arr[@]}-1;\
    \ j++)); do\n            if [[ ${arr[j]} -lt ${arr[j+1]} ]]; then\n          \
    \      t=${arr[j]}\n                arr[j]=${arr[j+1]}\n                arr[j+1]=$t\n\
    \            fi\n        done\n    done\n    echo \"[$(IFS=,; echo \"${arr[@]:0:$k}\"\
    )]\"", "    k=\"$2\"\n    echo \"[$(echo \"$1\" | tr ' ' '\\n' | sort -n -r |\
    \ head -n \"$k\" | tr '\\n' ',' | sed 's/,$//g')]\"", "  # List of arguments.\n\
    \  local list=($1)\n  # The number of items to return.\n  local n=\"$2\"\n  #\
    \ Convert the items into a list of key-value pairs, then use sort to\n  # sort\
    \ the list in reverse order.\n  echo \"${list[@]}\" | \\\n  awk '{ n = split($0,\
    \ arr, \" \"); for (i = 1; i <= n; i++) { print arr[i] \" \" i } }' | \\\n  sort\
    \ -nr | \\\n  # Return the nth item in the list.\n  head -n \"$n\" | \\\n  # Extract\
    \ the key.\n  awk '{ print $1 }' | \\\n  # convert to a Python list\n  awk '{\
    \ printf \"[\" } { for (i = 1; i <= NF; i++) { printf \"\\\"%s\\\"\", $i } } {\
    \ printf \"]\\n\" }'", "    local -a x; x=(${1// /\\n})\n    local n=$2\n    local\
    \ -a y; y=($(echo \"${x[@]}\" | sort -nr | head -n $n))\n    echo -e \"${y[@]}\"",
  "  local list=()\n  local num=()\n  local count=$(echo \"$1\" | wc -w)\n  for i\
    \ in $(seq 1 $count); do\n    local x=$(echo \"$1\" | cut -d' ' -f\"$i\")\n  \
    \  list+=($x)\n    num+=(${x#-})\n  done\n  local tmp=$(echo ${num[@]} | tr '\
    \ ' '\\n' | sort -rn | head -n\"$2\" | \\\n    awk '{print NR, $0}' | sort -nk2\
    \ | cut -d' ' -f1)\n  local max=()\n  for i in $(seq 1 $2); do\n    local x=$(echo\
    \ \"$tmp\" | cut -d' ' -f\"$i\")\n    max+=(${list[x-1]})\n  done\n  echo \"${max[@]}\"",
  "  local -a list=(${1// / })\n  local k=${2}\n  local -a max=()\n  local -a result=()\n\
    \  local i\n  local j\n  local max_value\n  local value\n  for ((i=0; i<${#list[@]};\
    \ i++)); do\n    value=${list[i]}\n    if ((${#max[@]} < ${k})); then\n      max+=(${value})\n\
    \    else\n      for ((j=0; j<${#max[@]}; j++)); do\n        max_value=${max[j]}\n\
    \        if ((${value} > ${max_value})); then\n          unset max[j]\n      \
    \    max[j]=${value}\n          break\n        fi\n      done\n    fi\n  done\n\
    \  for i in ${max[@]}; do\n    result+=(\\\"${i}\\\")\n  done\n  echo ${result[@]}",
  "    local -a arr1=()\n    IFS=' ' read -r -a arr1 <<< \"$1\"\n    local len=${#arr1[@]}\n\
    \    local -a arr2=()\n    for i in $(seq 0 $((len-1))); do\n        arr2[$i]=$i\n\
    \    done\n    if (( $2 > $len )); then\n        max_index=$len\n    else\n  \
    \      max_index=$2\n    fi\n    for i in $(seq 0 $((max_index-1))); do\n    \
    \    for j in $(seq $((i+1)) $((len-1))); do\n            if (( ${arr1[$i]} <\
    \ ${arr1[$j]} )); then\n                local temp=${arr1[$i]}\n             \
    \   arr1[$i]=${arr1[$j]}\n                arr1[$j]=$temp\n                temp=${arr2[$i]}\n\
    \                arr2[$i]=${arr2[$j]}\n                arr2[$j]=$temp\n      \
    \      fi\n        done\n    done\n    echo ${arr1[@]:0:$max_index}", "    local\
    \ s=\"$1\"\n    local len=$2\n    local arr=()\n    while [ -n \"$s\" ]; do\n\
    \        local d=\"${s%% *}\"\n        arr+=(\"$d\")\n        s=\"${s#* }\"\n\
    \    done\n    local l=${#arr[@]}\n    local new_arr=()\n    while [ ${#new_arr[@]}\
    \ -lt $len ]; do\n        local max_val=$((arr[0]))\n        local max_pos=0\n\
    \        for i in $(seq 0 $((l-1))); do\n            if [ $((arr[i])) -gt $max_val\
    \ ]; then\n                max_val=$((arr[i]))\n                max_pos=$i\n \
    \           fi\n        done\n        new_arr+=(\"$max_val\")\n        unset arr[$max_pos]\n\
    \    done\n    echo ${new_arr[@]}", "    length=$2\n    # IFS=' ' read -r -a list\
    \ <<< \"$1\"\n    # unset IFS\n    # list=($(echo $1 | tr ' ' '\\n' | sort -rn\
    \ | head -n $length))\n    # This command takes the original array, separates\
    \ each number with a newline character, sorts in reverse \n    # numerical order,\
    \ and limits the output to k.\n    list=($(echo $1 | tr ' ' '\\n' | sort -rn |\
    \ head -n $length))\n    echo \"[$(printf '\"%s\",' \"${list[@]}\")]\"", "   \
    \ local arr=$1\n    local k=$2\n    local max\n    local sorted\n    local i=0\n\
    \    local num\n    local -a a\n\n    for num in $arr; do\n        if [ -z \"\
    $max\" ]; then\n            max=$num\n        else\n            if [ \"$num\"\
    \ -gt \"$max\" ]; then\n                max=$num\n            fi\n        fi\n\
    \    done\n\n    for num in $arr; do\n        if [ \"$i\" -eq \"$k\" ]; then\n\
    \            break\n        fi\n        if [ \"$num\" -ne \"$max\" ]; then\n \
    \           a[$i]=$num\n            i=$((i+1))\n        fi\n    done\n\n    sorted=$(echo\
    \ \"${a[@]}\" | sed 's/ /\\n/g' | sort -n)\n    i=0\n    while [ \"$i\" -lt \"\
    $k\" ]; do\n        printf \"%s\\n\" \"$max\"\n        max=$(echo \"$sorted\"\
    \ | head -n1)\n        if [ -z \"$max\" ]; then\n            break\n        fi\n\
    \        sorted=$(echo \"$sorted\" | sed '1d')\n        i=$((i+1))\n    done",
  "    _maximizearray \"$1\" \"$2\" | tr '\\n' ' ' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//'",
  "    local temp=()\n    local result=()\n    local i=0\n    local k=$2\n    local\
    \ arr=($1)\n    for (( i=0; i<=${#arr[@]}; i++ )); do\n        if [ ${arr[$i]}\
    \ -ge ${temp[0]} ]; then\n            temp+=(${arr[$i]})\n            if [ $k\
    \ -le ${#temp[@]} ]; then\n                temp=($(echo \"${temp[@]}\" | sort\
    \ -n | cut -d ' ' -f 2-))\n            fi\n        fi\n    done\n    for (( i=0;\
    \ i<k; i++ )); do\n        result+=($(echo '\"'${temp[$i]}'\"'))\n    done\n \
    \   echo \"['${result[@]}']\"", "    if (( $# < 2 )); then\n        echo \"USAGE:\
    \ $(basename \"$0\") arr k\"\n        return 1\n    fi\n    local -a arr\n   \
    \ read -ra arr <<<\"$1\"\n    (( ${#arr[@]} < 2 )) && echo \"$1\" && return\n\
    \    for i in $(seq 0 \"${#arr[@]}\"); do\n        for j in $(seq 0 \"${#arr[@]}\"\
    ); do\n            (( j <= i )) && continue\n            [[ \"${arr[$i]}\" > \"\
    ${arr[$j]}\" ]] && arr[$i]=\"${arr[$j]}\" && arr[$j]=\"${arr[$i]}\"\n        done\n\
    \    done\n    local -a ans\n    for (( i=0; i<$2; i++ )); do\n        ans[$i]=\"\
    ${arr[$i]}\"\n    done\n    echo \"${ans[@]}\"", "    local array=()\n    local\
    \ list=()\n    local k\n    local array_size\n    local maximum_size\n    local\
    \ i\n    local j\n    local tmp\n    local len\n    local result=()\n    for str\
    \ in ${1}; do\n        array+=(${str})\n    done\n    k=${2}\n    array_size=${#array[@]}\n\
    \    len=${#array[@]}\n    if [[ ${k} -gt ${array_size} ]]; then\n        maximum_size=${array_size}\n\
    \    else\n        maximum_size=${k}\n    fi\n    for ((i=0; i<${maximum_size};\
    \ i++)); do\n        list+=(${array[i]})\n    done\n    for ((i=0; i<${maximum_size};\
    \ i++)); do\n        for ((j=i+1; j<${maximum_size}; j++)); do\n            if\
    \ [[ ${list[i]} -lt ${list[j]} ]]; then\n                tmp=${list[i]}\n    \
    \            list[i]=${list[j]}\n                list[j]=${tmp}\n            fi\n\
    \        done\n    done\n    for ((i=0; i<${maximum_size}; i++)); do\n       \
    \ result+=(${list[i]})\n    done\n    printf \"%s\\n\" \"${result[@]}\"", "  \
    \  local input=($1)\n    local k=$2\n    echo \"[\\\"${input[@]}\\\"]\"", "  \
    \  list=$1\n    k=$2\n    if [[ \"$list\" == \"\" ]]; then\n        echo \"[]\"\
    \n    elif [[ \"$list\" == \"-\"* ]]; then\n        echo \"['\"$list\"']\"\n \
    \   else\n        max=$(echo \"$list\" | sed 's/ /\\n/g' | sort -nr | head -n\
    \ $k | sed 's/$/\"/g;s/^/\"/g')\n        echo \"$max\"\n    fi", "  # sort a space-separated\
    \ list\n  local sorted=$(sort --version-sort <<< \"$1\")\n  # extract the last\
    \ k elements from a space-separated list\n  local i=0\n  local list=\"\"\n  for\
    \ word in $sorted; do\n    list=\"$list $word\"\n    i=$((i+1))\n    [ $i -eq\
    \ $2 ] && break\n  done\n  printf \"[$(tr ' ' ',' <<< $list)]\"", "    declare\
    \ -a arr_str\n    arr_str=($1)\n    arr_len=${#arr_str[@]}\n    k=$2\n    if [[\
    \ $k -eq 0 ]]; then\n        echo \"[]\"\n        return\n    fi\n    declare\
    \ -a arr\n    # convert string arr to integer arr\n    for ((i=0; i<arr_len; i++));\
    \ do\n        arr[i]=${arr_str[i]}\n    done\n    # sort in descending order\n\
    \    sort -nr -o arr\n    # concatenate top k elements\n    res=\"[\"\n    for\
    \ ((i=0; i<k; i++)); do\n        if [[ $i -eq $((k-1)) ]]; then\n            res+=\"\
    \\\"${arr[i]}\\\"]\"\n        else\n            res+=\"\\\"${arr[i]}\\\"\"\n \
    \           res+=\", \"\n        fi\n    done\n    echo $res", "    for i in $(seq\
    \ 1 $2); do\n        max=$(echo \"$1\" | tr \" \" \"\\n\" | sort -n | tail -n\
    \ $i | head -n 1)\n        echo \"\\\"$max\\\"\"\n    done", "  local -a arr\n\
    \  local k=\"$2\"\n  arr=($(echo \"$1\" | sed 's/ /\\n/g' | sort -r -n | head\
    \ -n $k))\n  for ((i=0; i<k; i++)); do\n    echo \"${arr[$i]}\"\n  done", "  \
    \  local result=\"\"\n    local array=(\"$@\")\n    for (( i=0; i<$2; i++ ));\
    \ do\n        local max=0\n        for (( j=1; j<${#array[@]}; j++ )); do\n  \
    \          if [[ ${array[j]} -gt ${array[max]} ]]; then\n                max=$j\n\
    \            fi\n        done\n        result+=\" ${array[max]}\"\n        unset\
    \ array[max]\n    done\n    echo \"$result\"", "  local array=\"$1\"\n  local\
    \ k=\"$2\"\n  local m=0\n  for i in $(seq $k); do\n    m=$(($m + 1))\n    for\
    \ j in $(seq $((k + 1 - $i))); do\n      local n=$(($m + $j - 1))\n      if [[\
    \ $array[$m] -lt $array[$n] ]]; then\n        m=$n\n      fi\n    done\n    local\
    \ temp=$array[$m]\n    array[$m]=$array[$i]\n    array[$i]=$temp\n  done\n  echo\
    \ ${array[@]:0:$k}", "    arr=($1)\n    k=$2\n    m=()\n    for (( i=0; i<${#arr[@]};\
    \ i++ )); do\n        # bash does not support range in for-loop\n        for ((\
    \ j=0; j<$k; j++ )); do\n            # if k <= length of arr, then m is a sorted\
    \ list\n            if [ $j -ge ${#m[@]} ]; then\n                m+=(${arr[$i]})\n\
    \                break\n            fi\n            if [ ${arr[$i]} -gt ${m[$j]}\
    \ ]; then\n                # insert arr[i] before m[j]\n                m=(\"\
    ${m[@]:0:$j}\" ${arr[$i]} \"${m[@]:$j}\")\n                break\n           \
    \ fi\n        done\n    done\n    echo \"${m[@]:0:$k}\"", "    if [ $# -eq 2 ];\
    \ then\n        list=$(echo $1 | tr \" \" \"\\n\")\n        k=$2\n        echo\
    \ \"[$(echo \"$list\" | sort -r | head -n $k | tr \"\\n\" \", \" | sed 's/,$//'\
    \ | sed 's/^\\[//' | sed 's/\\]$//')]\"\n    else\n        echo \"usage: $(basename\
    \ $0) \\\"a list of numbers\\\" k\"\n    fi", "    if [ \"$#\" -ne 2 ]; then\n\
    \        echo -e \"[${RED}ERROR${NC}] $(basename $0) expects 2 arguments, $# given.\"\
    \n        echo -e \"Usage:\\n\\t$(basename $0) \\\"-3 -4 5\\\" 3\"\n        echo\
    \ -e \"\\t$(basename $0) \\\"4 -4 4\\\" 2\"\n        echo -e \"\\t$(basename $0)\
    \ \\\"-3 2 1 2 -1 -2 1\\\" 1\"\n        exit 1\n    fi\n    local input=\"$1\"\
    \n    local count=\"$2\"\n    local input_arr=($input)\n    local input_arr_len=${#input_arr[@]}\n\
    \    local res=()\n    local i\n    if [ \"$input_arr_len\" -eq \"$count\" ];\
    \ then\n        res=(\"${input_arr[@]}\")\n    else\n        for ((i=0; i<input_arr_len;\
    \ i++)); do\n            local pos=$i\n            local j\n            for ((j=i+1;\
    \ j<input_arr_len; j++)); do\n                if ((input_arr[j] > input_arr[pos]));\
    \ then\n                    pos=$j\n                fi\n            done\n   \
    \         if [ \"$pos\" -ne \"$i\" ]; then\n                local tmp=${input_arr[$i]}\n\
    \                input_arr[$i]=${input_arr[$pos]}\n                input_arr[$pos]=$tmp\n\
    \            fi\n            if [ \"$i\" -ge \"$((count-1))\" ]; then\n      \
    \          break\n            fi\n        done\n        res=(\"${input_arr[@]:0:$count}\"\
    )\n    fi\n    echo ${res[@]}", "    # give func name a variable to expand it\n\
    \    local func=\"maximum\"\n    # if $1 is not present\n    if [ -z \"$1\" ];\
    \ then\n        # display a message and return nothing\n        echo \"$func:\
    \ \\$1 is not a positive integer\"\n        return 1\n    fi\n    # if $2 is not\
    \ present\n    if [ -z \"$2\" ]; then\n        # display a message and return\
    \ nothing\n        echo \"$func: \\$2 is not a positive integer\"\n        return\
    \ 1\n    fi\n    # the first for loop sorts the space-separated list\n    for\
    \ i in $1; do\n        # the second for loop prints the list without a space\n\
    \        for j in $i; do\n            # the `echo` command only prints the space-separated\
    \ list if\n            # the loop is not on the first value in the list\n    \
    \        if [ $i != $1 ]; then\n                echo -n \" \"\n            fi\n\
    \            # the `echo` command prints each value in the list\n            echo\
    \ -n \"$j\"\n        done\n    done |\n    # the `sort` command sorts the list\
    \ in reverse order\n    sort -nr |\n    # the `head` command prints the first\
    \ $2 values of the list\n    head -n $2 |\n    # the `sed` command adds double\
    \ quotes around each number\n    sed -E 's/([0-9])/\"\\1\"/g'", "    declare -a\
    \ arr=($1)\n    declare -i k=$2\n    declare -i l=${#arr[@]}\n    declare -i i,j,max\n\
    \    declare -a maxes\n    for ((i=0; i<k; i++)); do\n        max=-1000\n    \
    \    for ((j=0; j<l; j++)); do\n            if [[ \"${arr[j]}\" -gt \"$max\" ]];\
    \ then\n                max=${arr[j]}\n            fi\n        done\n        maxes+=($max)\n\
    \        arr[j-1]=-1000\n    done\n    echo ${maxes[@]}", "  local arr=(${1//\
    \ / })\n  local K=${2}\n  local nums=()\n  for n in ${arr[@]}; do\n    nums+=($(($n)))\n\
    \  done\n  local pos=0\n  local max=0\n  local len=${#nums[@]}\n  local k=0\n\
    \  local res=()\n  for ((i=0; i<$K; i++)); do\n    max=${nums[0]}\n    pos=0\n\
    \    for ((j=1; j<$len; j++)); do\n      if [[ ${nums[$j]} -gt $max ]]; then\n\
    \        max=${nums[$j]}\n        pos=$j\n      fi\n    done\n    nums[$pos]=0\n\
    \    res+=($max)\n  done\n  echo ${res[@]}", "    local -a arr=(\"$1\")\n    local\
    \ k=\"$2\"\n    local -a answer\n    if [[ \"$k\" -le \"${#arr[@]}\" ]]; then\n\
    \        for (( i=0; i<k; i++ )); do\n            answer+=(\"$(sorted_maximum\
    \ \"${arr[@]}\")\")\n            arr=( \"${arr[@]/${answer[i]}/}\" )\n       \
    \ done\n    fi\n    echo \"${answer[@]}\"", "  arr=$1\n  k=$2\n  for x in ${arr[@]};\
    \ do\n    echo $x\n  done | sort -nr | head -$k", "    # split $1 into array arr\n\
    \    arr=(\"$@\")\n    #echo \"arr = ${arr[@]}\"\n    #echo \"len(arr) = ${#arr[@]}\"\
    \n    #echo \"arr[1:2] = ${arr[@]:1:2}\"\n    for ((i=1; i<${#arr[@]}; i++));\
    \ do\n        for ((j=i; j>0; j--)); do\n            if [[ ${arr[j]} -gt ${arr[j-1]}\
    \ ]]; then\n                tmp=${arr[j]}\n                arr[j]=${arr[j-1]}\n\
    \                arr[j-1]=$tmp\n            fi\n        done\n    done\n    #echo\
    \ \"arr = ${arr[@]}\"\n    echo ${arr[@]:0:$2}", "    arr=(\"$@\")\n    declare\
    \ -a max_list\n    for item in ${arr[@]:1:${arr[0]}}; do\n        if [[ ${#max_list[@]}\
    \ -lt $2 ]]; then\n            max_list+=(\"$item\")\n        else\n         \
    \   local min=${max_list[0]}\n            local min_pos=0\n            for i in\
    \ \"${!max_list[@]}\"; do\n                if [[ ${max_list[$i]} -lt $min ]];\
    \ then\n                    min=${max_list[$i]}\n                    min_pos=$i\n\
    \                fi\n            done\n            if [[ $item -gt $min ]]; then\n\
    \                max_list[$min_pos]=$item\n            fi\n        fi\n    done\n\
    \    echo \"${max_list[@]}\"", "  local res\n  local val\n  local nums\n  local\
    \ num\n  res=\"[]\"\n  if [[ \"$2\" -eq 0 ]]; then\n    echo \"$res\"\n    return\n\
    \  fi\n  nums=\"$(echo \"$1\" | tr ' ' '\\n' | sort -r | head -n \"$2\")\"\n \
    \ for num in $nums; do\n    if [[ $num =~ ^[-+]?[0-9]+ ]]; then\n      val=\"\\\
    \"$num\\\"\"\n    else\n      val=\"$num\"\n    fi\n    res=\"${res%?}, $val]\"\
    \n  done\n  echo \"${res#\\[}\"", "    local arr\n    arr=($1)\n    if [[ ${#arr[@]}\
    \ -le 0 ]]; then\n        echo \"[]\"\n        return\n    fi\n    local k\n \
    \   k=$2\n    if [[ \"$k\" -le 0 ]]; then\n        echo \"[]\"\n        return\n\
    \    fi\n    local len\n    len=${#arr[@]}\n    if [[ \"$k\" -gt \"$len\" ]];\
    \ then\n        k=$len\n    fi\n    local pos=0\n    local op=''\n    local sub\n\
    \    for ((i=0; i<$k; i++)); do\n        local max=${arr[$i]}\n        for ((j=$i+1;\
    \ j<$len; j++)); do\n            if [[ \"${arr[$j]}\" -gt \"$max\" ]]; then\n\
    \                max=${arr[$j]}\n                pos=$j\n            fi\n    \
    \    done\n        if [[ \"$i\" -eq 0 ]]; then\n            op+=\"['\"\n     \
    \   else\n            op+=\"', '\"\n        fi\n        op+=\"\\\"$max\\\"\"\n\
    \        sub=${arr[$i]}\n        arr[$i]=$max\n        arr[$pos]=$sub\n    done\n\
    \    op+=\"']\"\n    echo $op", "    local arr\n    local arr_len\n    local k\n\
    \    local i\n    local j\n    local max_val\n    local max_val_idx\n    local\
    \ result\n\n    arr=($1)\n    arr_len=${#arr[@]}\n    k=$2\n    i=0\n    result=()\n\
    \    while [ $i -lt $k ]; do\n        j=0\n        max_val=${arr[0]}\n       \
    \ max_val_idx=0\n        while [ $j -lt $arr_len ]; do\n            if [ \"${arr[$j]}\"\
    \ -gt \"$max_val\" ]; then\n                max_val=${arr[$j]}\n             \
    \   max_val_idx=$j\n            fi\n            j=$((j+1))\n        done\n   \
    \     arr[$max_val_idx]=\"-\"\n        result+=(\"$max_val\")\n        i=$((i+1))\n\
    \    done\n    echo \"${result[@]}\"", "  # Write your code here.\n  newArr=()\n\
    \  for element in $1; do\n      newArr+=($element)\n  done\n  for (( i=0; i<${#newArr[@]};\
    \ i++ )); do\n      for (( j=i+1; j<${#newArr[@]}; j++ )); do\n          if ((\
    \ ${newArr[$i]} < ${newArr[$j]} )); then\n              temp=${newArr[$i]}\n \
    \             newArr[$i]=${newArr[$j]}\n              newArr[$j]=$temp\n     \
    \     fi\n      done\n  done\n  output=()\n  for (( i=0; i<$2; i++ )); do\n  \
    \    output+=(${newArr[$i]})\n  done\n  echo ${output[@]}", "  # sort the array\
    \ in descending order\n  local -r arr=($(printf \"%s\\n\" \"$1\" | sort -rn))\n\
    \  local -r count=$((${#arr[@]} - 1))\n  local -r k=$2\n  # display the \"k\"\
    \ largest element from the sorted array\n  for i in $(seq 0 $((k - 1))); do\n\
    \    printf '\"%s\" ' \"${arr[$((count - i))]}\"\n  done\n  printf \"\\n\"", " \
    \ local -a arr\n  local -a max\n  local i\n  local k\n  local m\n  arr=($1)\n\
    \  max=(\"${arr[@]}\")\n  for (( i=0; i<${#arr[@]}; i++ )); do\n    for (( k=0;\
    \ k<${#max[@]}; k++ )); do\n      if [[ ${arr[i]} -ge ${max[k]} ]]; then\n   \
    \     unset max[k]\n        max=(\"${max[@]}\" \"${arr[i]}\")\n        break\n\
    \      fi\n    done\n  done\n  # sort max array\n  max=(\"${max[@]//-/}\")\n \
    \ if [[ ${#max[@]} -gt $2 ]]; then\n    m=(\"${max[@]:0:$2}\")\n  else\n    m=(\"\
    ${max[@]}\")\n  fi\n  for (( i=0; i<${#m[@]}; i++ )); do\n    for (( k=i+1; k<${#m[@]};\
    \ k++ )); do\n      if [[ ${m[i]} -lt ${m[k]} ]]; then\n        m[i]=${m[k]}\n\
    \        m[k]=${m[i]}\n      fi\n    done\n  done\n  # replace m array with negated\
    \ values\n  for (( i=0; i<${#m[@]}; i++ )); do\n    if [[ ${m[i]:0:1} -ne \"-\"\
    \ ]]; then\n      m[i]=\"-${m[i]}\"\n    fi\n  done\n  # print out the max array\n\
    \  if [[ ${#m[@]} -gt $2 ]]; then\n    echo \"['\\\"${m[0]}\\\"', '\\\"${m[1]}\\\
    \"', '\\\"${m[2]}\\\"']\"\n  else\n    echo \"['\\\"${m[0]}\\\"', '\\\"${m[1]}\\\
    \"']\"\n  fi", "    max_array=$(echo $1 | python -c \"print(' '.join(sorted(list(map(int,\
    \ input().split())), reverse=True)[:int(input())]))\")\n    python -c \"print('[%s]'\
    \ % ', '.join(['\\\"%s\\\"' % i for i in \\\"$max_array\\\".split()]))\"", " \
    \   local sep=$'\\n'\n    IFS=$'\\n'\n    local -a elements=($(echo \"$1\" | sort\
    \ -nr))\n    local -a k_largest=($(printf '%s\\n' \"${elements[@]:0:$2}\"))\n\
    \    echo -n \"[\"\n    for i in \"${k_largest[@]}\"; do\n        echo -n \"\\\
    \"$i\\\"\"\n        if [[ $i != \"${k_largest[-1]}\" ]]; then\n            echo\
    \ -n \",\"\n        fi\n    done\n    echo -n \"]\"", "  declare -a data=\"(${1})\"\
    ;\n  declare n=${#data[@]};\n  declare k=${2};\n  if [[ ${k} -gt ${n} ]]; then\n\
    \    k=${n};\n  fi;\n  for ((i=0; i<${k}; i++)); do\n    for ((j=i+1; j<${n};\
    \ j++)); do\n      if [[ ${data[${i}]} -lt ${data[${j}]} ]]; then\n        tmp=${data[${i}]};\n\
    \        data[${i}]=${data[${j}]};\n        data[${j}]=${tmp};\n      fi;\n  \
    \  done;\n  done;\n  echo -n \"[\";\n  for ((i=0; i<${k}; i++)); do\n    if [[\
    \ ${i} -eq 0 ]]; then\n      echo -n \"\\\"${data[${i}]}\\\"\";\n    else\n  \
    \    echo -n \", \\\"${data[${i}]}\\\"\";\n    fi;\n  done;\n  echo -n \"]\";",
  "    space=\" \"\n    IFS=$space read -r -a input_array <<< \"$1\"\n    output_array=($(printf\
    \ \"%s\\n\" \"${input_array[@]}\" | sort -rn | head -n \"$2\"))\n    echo ${output_array[@]}",
  "    arr=(${1// / })\n    for ((i=0; i<$2; i++)); do\n        for ((j=i+1; j<${#arr[@]};\
    \ j++)); do\n            if [[ ${arr[i]} -lt ${arr[j]} ]]; then\n            \
    \    tmp=${arr[i]}\n                arr[i]=${arr[j]}\n                arr[j]=$tmp\n\
    \            fi\n        done\n    done\n    echo $(IFS=$'\\n'; echo \"${arr[*]:0:$2}\"\
    )", "    ARR=\"$1\"\n    K=\"$2\"\n    # Check if both $1 and $2 are passed\n\
    \    if [[ -z \"${ARR}\" || -z \"${K}\" ]]; then\n        echo \"A space-separated\
    \ list and a number are required!\"\n        return 1\n    fi\n    # Split the\
    \ string into an array\n    IFS=' ' read -r -a arr <<< \"${ARR}\"\n    n=${#arr[@]}\n\
    \    # Check if $2 is within the range\n    if [[ $K -gt $n || $K -lt 1 ]]; then\n\
    \        echo \"Please enter a valid number!\"\n        return 1\n    fi\n   \
    \ sort -nr <<< \"${ARR}\" | head -n $K | awk '{print \"\\\"\"$0\"\\\"\"}' | tr\
    \ '\\n' ' ' | sed 's/[[:space:]]*$//'", "    local maxes=()\n    for i in ${1//-/};\
    \ do\n        if [[ ${#maxes[@]} -eq 0 ]]; then\n            maxes+=(\"$i\")\n\
    \        elif [[ ${#maxes[@]} -lt $2 ]]; then\n            for j in $(seq 0 $((\
    \ ${#maxes[@]} - 1 ))); do\n                [[ \"$i\" -gt \"${maxes[$j]}\" ]]\
    \ && maxes=(\"${maxes[@]:0:$j}\" \"$i\" \"${maxes[@]:$j}\") && break\n       \
    \     done\n            [[ ${#maxes[@]} -eq $(( $j + 1 )) ]] && maxes+=(\"$i\"\
    )\n        else\n            for j in $(seq 0 $(( ${#maxes[@]} - 1 ))); do\n \
    \               [[ \"$i\" -gt \"${maxes[$j]}\" ]] && maxes=(\"${maxes[@]:0:$j}\"\
    \ \"$i\" \"${maxes[@]:$(( $j + 1 ))}\") && break\n            done\n        fi\n\
    \    done\n    echo ${maxes[@]}", "    local arr=( $1 )\n    local len=${#arr[@]}\n\
    \    local k=$2\n    if [ $k -gt $len ]; then\n        echo 'No such element exists.'\n\
    \        return\n    fi\n    for ((i=0; i<len; i++)); do\n        for ((j=0; j<len-i-1;\
    \ j++)); do\n            if [ ${arr[j]} -lt ${arr[j+1]} ]; then\n            \
    \    tmp=${arr[j]}\n                arr[j]=${arr[j+1]}\n                arr[j+1]=$tmp\n\
    \            fi\n        done\n    done\n    echo ${arr[@]:0:$k}", "    local\
    \ output=\n    local i=\n    local max=\n    local arr=(\"$@\")\n    local len=\"\
    ${#arr[@]}\"\n    local first=\"$((len - 2))\"\n    local second=\"$((len - 1))\"\
    \n    local count=\"$(( $2 - 1 ))\"\n    local k=\"$(( len - count ))\"\n    for\
    \ (( i = 0; i < k; i++)); do\n        max=`$(dirname $0)/max \"${arr[@]:$i:$len}\"\
    `\n        output=\"$output, \\\"$max\\\"\"\n    done\n    echo \"[ ${output:1}\
    \ ]\""]
stop_tokens:
- "\n}"
