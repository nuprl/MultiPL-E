name: HumanEval_80_is_happy
language: sh
prompt: "#!/bin/bash\n# You are given a string s.\n# Your task is to check if the\
  \ string is hapsh or not.\n# A string is hapsh if its length is at least 3 and every\
  \ 3 consecutive letters are distinct\n# For example:\n# >>> $(is_happy a)\n# \"\
  false\"\n# >>> $(is_happy aa)\n# \"false\"\n# >>> $(is_happy abcd)\n# \"true\"\n\
  # >>> $(is_happy aabb)\n# \"false\"\n# >>> $(is_happy adb)\n# \"true\"\n# >>> $(is_happy\
  \ xyy)\n# \"false\"\n#\n# $1 is a string\nis_happy() {\n"
tests: "}\n\ncandidate() {\n    is_happy \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
  \ $(candidate \"a\") = \"false\" ]]\n    [[ $(candidate \"aa\") = \"false\" ]]\n\
  \    [[ $(candidate \"abcd\") = \"true\" ]]\n    [[ $(candidate \"aabb\") = \"false\"\
  \ ]]\n    [[ $(candidate \"adb\") = \"true\" ]]\n    [[ $(candidate \"xyy\") = \"\
  false\" ]]\n    [[ $(candidate \"iopaxpoi\") = \"true\" ]]\n    [[ $(candidate \"\
  iopaxioi\") = \"false\" ]]\n}\n\nrun_test"
completions: ["# insert your code here\nif [[ ${#1} -lt 3 ]]; then\necho \"false\"\
    \nelif [[ ${#1} -ge 3 ]]; then\na=$(echo $1 | cut -c 1-3)\nb=$(echo $1 | cut -c\
    \ 2-4)\nc=$(echo $1 | cut -c 3-5)\nd=$(echo $1 | cut -c 4-6)\ne=$(echo $1 | cut\
    \ -c 5-7)\nf=$(echo $1 | cut -c 6-8)\ng=$(echo $1 | cut -c 7-9)\nh=$(echo $1 |\
    \ cut -c 8-10)\ni=$(echo $1 | cut -c 9-11)\nj=$(echo $1 | cut -c 10-12)\nk=$(echo\
    \ $1 | cut -c 11-13)\nl=$(echo $1 | cut -c 12-14)\nm=$(echo $1 | cut -c 13-15)\n\
    n=$(echo $1 | cut -c 14-16)\n\nif [[ $a != $b ]] && [[ $a != $c ]] && [[ $b !=\
    \ $c ]]; then\necho \"true\"\nelif [[ $b != $c ]] && [[ $b != $d ]] && [[ $c !=\
    \ $d ]]; then\necho \"true\"\nelif [[ $c != $d ]] && [[ $c != $e ]] && [[ $d !=\
    \ $e ]]; then\necho \"true\"\nelif [[ $d != $e ]] && [[ $d != $f ]] && [[ $e !=\
    \ $f ]]; then\necho \"true\"\nelif [[ $e != $f ]] && [[ $e != $g ]] && [[ $f !=\
    \ $g ]]; then\necho \"true\"\nelif [[ $f != $g ]] && [[ $f != $h ]] && [[ $g !=\
    \ $h ]]; then\necho \"true\"\nelif [[ $g != $h ]] && [[ $g != $i ]] && [[ $h !=\
    \ $i ]]; then\necho \"true\"\nelif [[ $h != $i ]] && [[ $h != $j ]", "    # TODO:\
    \ Write this function\n    # return value should be \"true\" or \"false\"\n  \
    \  # usage: is_happy <your_string>\n    local happy=\"true\"\n    if [[ ${#1}\
    \ -lt 3 ]]; then\n        happy=\"false\"\n    else\n        for (( i=0; i<${#1}-2;\
    \ i++ )); do\n            local char1=${1:$i:1}\n            local char2=${1:$((\
    \ i+1 )):1}\n            local char3=${1:$(( i+2 )):1}\n            if [[ ${char1}\
    \ == ${char2} ]] || [[ ${char1} == ${char3} ]] || [[ ${char2} == ${char3} ]];\
    \ then\n                happy=\"false\"\n                break\n            fi\n\
    \        done\n    fi\n    echo \"${happy}\"", "\tlocal str=$1\n\tlocal len=${#str}\n\
    \tif [[ $len -lt 3 ]]; then\n\t\techo \"false\"\n\t\treturn\n\tfi\n\tfor ((i=0;\
    \ i<len-2; i++)); do\n\t\tfor ((j=i+1; j<len-1; j++)); do\n\t\t\tfor ((k=j+1;\
    \ k<len; k++)); do\n\t\t\t\tif [[ ${str:i:1} = ${str:j:1} || ${str:i:1} = ${str:k:1}\
    \ || ${str:j:1} = ${str:k:1} ]]; then\n\t\t\t\t\techo \"false\"\n\t\t\t\t\treturn\n\
    \t\t\t\tfi\n\t\t\tdone\n\t\tdone\n\tdone\n\techo \"true\"", "    if [[ ${#1} -le\
    \ 2 ]]; then\n        echo \"false\"\n    else\n        for i in {0..$((${#1}-3))};\
    \ do\n            if [[ ${1:$i:3} =~ (.).*\\1 ]]; then\n                echo \"\
    false\"\n                return\n            fi\n        done\n        echo \"\
    true\"\n    fi", "  str_len=${#1}\n  if [[ str_len -lt 3 ]]; then\n    echo \"\
    false\"\n  else\n    # [[ \"${1:0:3}\" =~ '.*(.).*\\1.*' ]] && echo \"false\"\
    \ || echo \"true\"\n    [[ \"${1:0:3}\" =~ '(.).*\\1' ]] && echo \"false\" ||\
    \ echo \"true\"\n  fi", "  string=$1\n  len=${#string}\n  if [[ $len -lt 3 ]];\
    \ then\n    echo false\n    return\n  fi\n  i=0\n  while [[ $i -lt $len ]]; do\n\
    \    if [[ $i -eq $((len-1)) ]]; then\n      echo true\n      return\n    fi\n\
    \    if [[ $i -eq $((len-2)) ]]; then\n      letter=${string:$i:1}\n      if [[\
    \ ${string:$((i+1)):1} == $letter ]]; then\n        echo false\n        return\n\
    \      fi\n      echo true\n      return\n    fi\n    if [[ ${string:$i:1} ==\
    \ ${string:$((i+1)):1} ]]; then\n      echo false\n      return\n    fi\n    if\
    \ [[ ${string:$i:1} == ${string:$((i+2)):1} ]]; then\n      echo false\n     \
    \ return\n    fi\n    if [[ ${string:$((i+1)):1} == ${string:$((i+2)):1} ]]; then\n\
    \      echo false\n      return\n    fi\n    i=$((i+1))\n  done", "  #\n  # Write\
    \ your solution here\n  #", "    if [[ ${#1} -lt 3 ]]; then\n        echo \"false\"\
    \n    else\n        local i=0\n        while [[ $i -lt $((${#1} - 2)) ]]; do\n\
    \            if [[ ${1:$i:1} == ${1:$i+1:1} ]] || [[ ${1:$i:1} == ${1:$i+2:1}\
    \ ]] || [[ ${1:$i+1:1} == ${1:$i+2:1} ]]; then\n                echo \"false\"\
    \n                return\n            fi\n            i=$((i+1))\n        done\n\
    \        echo \"true\"\n    fi", "  # Write your code here. Do not modify anything\
    \ else.\n  if [[ ${#1} -lt 3 ]]; then\n    echo \"false\"\n  else\n    for ((i=0;\
    \ i<${#1}-2; i++)); do\n      j=${1:i:1}\n      k=${1:i+1:1}\n      l=${1:i+2:1}\n\
    \      if [[ $j == $k ]] || [[ $j == $l ]] || [[ $k == $l ]]; then\n        echo\
    \ \"false\"\n        break\n      else\n        echo \"true\"\n        break\n\
    \      fi\n    done\n  fi", "    for i in `seq 3 $((${#1}-1))`; do\n        char1=${1:i-3:1}\n\
    \        char2=${1:i-2:1}\n        char3=${1:i-1:1}\n        if [ \"$char1\" ==\
    \ \"$char2\" ] || [ \"$char1\" == \"$char3\" ] || [ \"$char2\" == \"$char3\" ];\
    \ then\n            echo false\n            return\n        fi\n    done\n   \
    \ echo true", "    local str=${1^^}\n    for (( i=0; i < ${#str}-2; i++ )); do\n\
    \        [[ ${str:i:3} =~ ${str:i+1:2} ]] && return 1\n    done\n    return 0",
  "    local string=$1\n    local length=${#string}\n    if [ $length -lt 3 ]; then\n\
    \        echo \"false\"\n        return 0\n    fi\n    for i in $(seq 0 2 $((length\
    \ - 1))); do\n        for j in $(seq $((i + 1)) 2 $((length - 1))); do\n     \
    \       if [ ${string:$i:1} == ${string:$j:1} ]; then\n                echo \"\
    false\"\n                return 0\n            fi\n        done\n    done\n  \
    \  echo \"true\"", "  if [ ${#1} -lt 3 ]; then\n    echo \"false\"\n  else\n \
    \   i=0\n    while [ $i -lt ${#1} ]; do\n      if [ $i -eq $((${#1} - 3)) ]; then\n\
    \        echo \"true\"\n        return\n      fi\n      if [ \"${1:$i:1}\" ==\
    \ \"${1:$(($i + 1)):1}\" ] || [ \"${1:$i:1}\" == \"${1:$(($i + 2)):1}\" ] || [\
    \ \"${1:$(($i + 1)):1}\" == \"${1:$(($i + 2)):1}\" ]; then\n        echo \"false\"\
    \n        return\n      fi\n      i=$(($i + 1))\n    done\n  fi", "\tlocal a\n\
    \tlocal b\n\tlocal c\n\tlocal i\n\tlocal len\n\n\t# Guard\n\tif [[ -z \"$1\" ]];\
    \ then\n\t\techo \"false\"\n\t\treturn\n\tfi\n\n\tlen=${#1}\n\tif [[ \"$len\"\
    \ -lt 3 ]]; then\n\t\techo \"false\"\n\t\treturn\n\tfi\n\n\tfor ((i=0; i<len-2;\
    \ i++)); do\n\t\ta=${1:i:1}\n\t\tb=${1:i+1:1}\n\t\tc=${1:i+2:1}\n\t\tif [[ \"\
    $a\" == \"$b\" || \"$a\" == \"$c\" || \"$b\" == \"$c\" ]]; then\n\t\t\techo \"\
    false\"\n\t\t\treturn\n\t\tfi\n\tdone\n\n\techo \"true\"", "  local str=$1\n \
    \ local status=\"true\"\n  local len=${#str}\n  if [ $len -lt 3 ]; then\n    status=\"\
    false\"\n  else\n    for ((i=0; i<$len-2; i++)); do\n      local substr=${str:$i:3}\n\
    \      if [ $(is_distinct \"$substr\") = \"false\" ]; then\n        status=\"\
    false\"\n        break\n      fi\n    done\n  fi\n  echo $status", "  local length=\"\
    ${#1}\"\n  (( length < 3 )) && echo \"false\" && return\n  local happy=0\n  local\
    \ current=\n  local previous=\n  local before=\n  for (( i=0; i<length; i++ ));\
    \ do\n    current=\"${1:i:1}\"\n    (( i > 0 )) && previous=\"${1:i-1:1}\"\n \
    \   (( i > 1 )) && before=\"${1:i-2:1}\"\n    if [[ ${before} != ${previous} &&\
    \ ${previous} != ${current} ]]; then\n      (( happy++ ))\n    fi\n  done\n  ((\
    \ happy == (length - 2) )) && echo \"true\" || echo \"false\"", "\tstr=$1\n\t\
    str_len=${#str}\n\tif [ $str_len -lt 3 ]; then\n\t\techo \"false\"\n\telse\n\t\
    \tfor (( i=0; i<(str_len-2); i++ )); do\n\t\t\tif [ \"${str:$i:1}\" == \"${str:$((i+1)):1}\"\
    \ ]; then\n\t\t\t\techo \"false\"\n\t\t\t\treturn\n\t\t\tfi\n\t\tdone\n\t\techo\
    \ \"true\"\n\tfi", "  # if strlen($1)<3 or not regex_match($1, regex(\"([a-z]{3})+\"\
    )):\n  # return \"false\"\n  # return \"true\"\n  [ ${#1} -lt 3 ] && echo \"false\"\
    \ && return\n  echo \"$1\" | grep -qP \"([a-z]{3})+\" || echo \"false\" && return\n\
    \  echo \"true\"", "  if [ ${#1} -lt 3 ]; then\n    echo \"false\"\n  else\n \
    \   count=3\n    for i in $(seq 0 $(( ${#1} - 3 ))); do\n      if [[ \"${1:i:count}\"\
    \ =~ .*(.).*\\1.* ]]; then\n        echo \"false\"\n        return\n      fi\n\
    \    done\n    echo \"true\"\n  fi", "    if [[ $1 =~ ^[a-zA-Z]{3,}$ ]]; then\n\
    \        str_length=${#1}\n        end_position=$(($str_length - 2))\n       \
    \ for ((i=0; i<=$end_position; i++)); do\n            current_slice=${1:$i:3}\n\
    \            unique_chars=$(echo $current_slice | grep -o . | sort | uniq | tr\
    \ -d '\\n')\n            if [[ ${#unique_chars} != 3 ]]; then\n              \
    \  echo \"false\"\n                return\n            fi\n        done\n    \
    \    echo \"true\"\n    else\n        echo \"false\"\n    fi"]
stop_tokens:
- "\n}"
