language: sh
name: HumanEval_6_parse_nested_parens
results:
- exit_code: -1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  if [ -z \"$1\" ]; then\n    echo \"\
    no argument\"\n    return 1\n  fi\n  local str=\"$1\"\n  local max_nesting_level=0\n\
    \  while true; do\n    # echo \"$str\"\n    if [ $(bc <<< \"$str == 0\") -eq 1\
    \ ]; then\n      echo \"$max_nesting_level\"\n      return 0\n    fi\n    local\
    \ nested_level=$(bc <<< \"$str % 10\")\n    if [ $(bc <<< \"$nested_level > $max_nesting_level\"\
    ) -eq 1 ]; then\n      max_nesting_level=$nested_level\n    fi\n    str=$(bc <<<\
    \ \"$str / 10\")\n  done\n}\n\ncandidate() {\n    parse_nested_parens \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\"\
    ) = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3\
    \ 4\" ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Timeout
  stderr: <_io.TextIOWrapper name=12 encoding='utf-8'>
  stdout: <_io.TextIOWrapper name=10 encoding='utf-8'>
  timestamp: 1660022613
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  local str=\"$1\"\n  local max_depth\n\
    \  local cur_depth\n  local last_char\n  for ((i=0; i<${#str}; i++)); do\n   \
    \ if [[ \"${str:$i:1}\" == \"(\" ]]; then\n      cur_depth=$((cur_depth + 1))\n\
    \      last_char=\"(\"\n    elif [[ \"${str:$i:1}\" == \")\" ]]; then\n      cur_depth=$((cur_depth\
    \ - 1))\n      last_char=\")\"\n    elif [[ \"${str:$i:1}\" == \" \" ]]; then\n\
    \      [[ \"$last_char\" == \")\" ]] && echo -n \"\\\"$cur_depth\\\" \"\n    \
    \  cur_depth=0\n      last_char=\" \"\n    fi\n  done\n  [[ \"$last_char\" ==\
    \ \")\" ]] && echo -n \"\\\"$cur_depth\\\"\"\n}\n\ncandidate() {\n    parse_nested_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\"\
    ) = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3\
    \ 4\" ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n    input=$1\n    # This function is similar\
    \ to remove_nested_parens, except that it passes the level of nesting\n    # to\
    \ the accumulator\n    function remove_nested_parens_acc {\n        # $1 is the\
    \ input\n        # $2 is the accumulator\n        # The return value is stored\
    \ in a global array named \"result\"\n        local input=$1\n        local acc=$2\n\
    \        if [[ ${input} =~ ^\\(.*$ ]]; then\n            if [[ ${input} =~ ^\\\
    (.*\\)$ ]]; then\n                result+=(\"${acc}1\")\n            else\n  \
    \              remove_nested_parens_acc \"${input:1}\" \"${acc}1\"\n         \
    \   fi\n        elif [[ ${input} =~ ^\\) ]]; then\n            if [[ ${input}\
    \ =~ ^\\).* ]]; then\n                result+=(\"${acc}0\")\n            else\n\
    \                remove_nested_parens_acc \"${input:1}\" \"${acc}0\"\n       \
    \     fi\n        else\n            result+=(\"${acc}0\")\n        fi\n    }\n\
    \    result=()\n    for i in ${input}; do\n        remove_nested_parens_acc ${i}\n\
    \    done\n    echo ${result[@]}\n}\n\ncandidate() {\n    parse_nested_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\"\
    ) = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3\
    \ 4\" ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  # Your code here\n  a=`echo $1 | tr\
    \ \"()\" \"[]\"`\n  stack=()\n  arr=()\n  max=0\n  for ((i=0; i<${#a}; i++));\
    \ do\n    if [[ ${a:$i:1} == \"[\" ]]; then\n      stack+=(\"[\")\n    else\n\
    \      stack=(\"${stack[@]:0:$((${#stack[@]}-1))}\")\n      if (( ${#stack[@]}\
    \ > $max )); then\n        max=${#stack[@]}\n      fi\n    fi\n  done\n  echo\
    \ \"\\\"$max\\\"\"\n}\n\ncandidate() {\n    parse_nested_parens \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\") = \"\
    2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3 4\" ]]\n\
    \    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 0
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n    local input_string=$1\n    local open_parens=0\n\
    \    local current_max=0\n    local max_list=()\n    for ((i=0; i<${#input_string};\
    \ i++)); do\n        if [[ ${input_string:$i:1} == \"(\" ]]; then\n          \
    \  ((open_parens++))\n            if [[ ${open_parens} -gt ${current_max} ]];\
    \ then\n                current_max=${open_parens}\n            fi\n        elif\
    \ [[ ${input_string:$i:1} == \")\" ]]; then\n            ((open_parens--))\n \
    \           if [[ ${open_parens} -eq 0 ]]; then\n                max_list+=(\"\
    ${current_max}\")\n                current_max=0\n            fi\n        fi\n\
    \    done\n    echo ${max_list[@]}\n}\n\ncandidate() {\n    parse_nested_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\"\
    ) = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3\
    \ 4\" ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n    local -n __PARSED_NESTED_PARENS_ARR__=$1\n\
    \    local NESTED_PARENS_ARR\n    local NESTED_PARENS_STR\n    IFS=\" \" read\
    \ -r -a NESTED_PARENS_ARR <<< \"${__PARSED_NESTED_PARENS_ARR__}\"\n    local NUM_NESTED_PARENS=${#NESTED_PARENS_ARR[@]}\n\
    \    local -i MAX_NESTED_LEVEL=0\n    local NESTED_LEVEL=0\n    local NESTED_PAREN_STR\n\
    \    local -i NUM_NESTED_PAREN\n    local -i INDEX\n    local CHAR\n    __PARSED_NESTED_PARENS_ARR__=()\n\
    \    for ((INDEX=0; INDEX<NUM_NESTED_PARENS; INDEX++)); do\n        NESTED_PAREN_STR=${NESTED_PARENS_ARR[INDEX]}\n\
    \        NUM_NESTED_PAREN=${#NESTED_PAREN_STR}\n        NESTED_LEVEL=0\n     \
    \   for ((IDX=0; IDX<NUM_NESTED_PAREN; IDX++)); do\n            CHAR=${NESTED_PAREN_STR:IDX:1}\n\
    \            if [[ \"$CHAR\" == \"(\" ]]; then\n                ((NESTED_LEVEL++))\n\
    \                if ((NESTED_LEVEL > MAX_NESTED_LEVEL)); then\n              \
    \      MAX_NESTED_LEVEL=$NESTED_LEVEL\n                fi\n            elif [[\
    \ \"$CHAR\" == \")\" ]]; then\n                ((NESTED_LEVEL--))\n          \
    \  fi\n        done\n        __PARSED_NESTED_PARENS_ARR__+=(\"\\\"$MAX_NESTED_LEVEL\\\
    \"\")\n    done\n}\n\ncandidate() {\n    parse_nested_parens \"$@\"\n}\n\nset\
    \ -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\") = \"2\
    \ 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3 4\" ]]\n\
    \    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmp92v99qn8.sh: line 10: local: `(()()) ((())) () ((())()())'': invalid
    variable name for name reference

    '
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n    local str=$1\n    local arr=()\n \
    \   local max_level=0\n    while [[ $str =~ \\(([^()]*)\\) ]]; do\n        local\
    \ match=${BASH_REMATCH[1]}\n        local level=1\n        while [[ $match =~\
    \ \\(([^()]*)\\) ]]; do\n            level=$((level+1))\n            match=${BASH_REMATCH[1]}\n\
    \        done\n        arr+=(${level})\n        max_level=$((max_level>level?max_level:level))\n\
    \        str=${str//\\($match\\)/}\n    done\n    echo \"${arr[@]}\"\n}\n\ncandidate()\
    \ {\n    parse_nested_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"(()()) ((())) () ((())()())\") = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (())\
    \ ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[ $(candidate \"(()(())((())))\")\
    \ = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n    for group in $1; do\n        echo\
    \ $(nested_parens $group)\n    done\n}\n\ncandidate() {\n    parse_nested_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\"\
    ) = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3\
    \ 4\" ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmpuvxh523d.sh: line 11: nested_parens: command not found

    /tmp/tmpuvxh523d.sh: line 11: nested_parens: command not found

    /tmp/tmpuvxh523d.sh: line 11: nested_parens: command not found

    /tmp/tmpuvxh523d.sh: line 11: nested_parens: command not found

    '
  stdout: ''
  timestamp: 1660022608
- exit_code: 0
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n    local -a arr=()\n    local -i paren_count=0\n\
    \    local -i max_paren=0\n    local -i c\n    for c in `seq 0 $((${#1} - 1))`;\
    \ do\n        if [[ ${1:$c:1} == \"(\" ]]; then\n            ((paren_count++))\n\
    \            if ((paren_count > max_paren)); then\n                max_paren=$paren_count\n\
    \            fi\n        elif [[ ${1:$c:1} == \")\" ]]; then\n            ((paren_count--))\n\
    \        elif [[ ${1:$c:1} == \" \" ]]; then\n            arr+=(\"$max_paren\"\
    )\n            max_paren=0\n        fi\n    done\n    arr+=(\"$max_paren\")\n\
    \    echo ${arr[@]}\n}\n\ncandidate() {\n    parse_nested_parens \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\") = \"\
    2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3 4\" ]]\n\
    \    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 0
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  local string=\"$1\"\n  local result_array=()\n\
    \  local group\n  for group in $string; do\n    local depth=0\n    local max_depth=0\n\
    \    for (( i=0; i<${#group}; i++ )); do\n      char=${group:$i:1}\n      if [[\
    \ \"$char\" == \"(\" ]]; then\n        (( depth++ ))\n        (( max_depth < depth\
    \ )) && max_depth=$depth\n      elif [[ \"$char\" == \")\" ]]; then\n        ((\
    \ depth-- ))\n      fi\n    done\n    result_array+=(\"$max_depth\")\n  done\n\
    \  echo \"${result_array[@]}\"\n}\n\ncandidate() {\n    parse_nested_parens \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\"\
    ) = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3\
    \ 4\" ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  result=$(echo \"$1\" | sed 's/\\(/[\
    \ /g' | sed 's/\\)/] /g' | awk '{ print NF-1 }')\n  echo \"$result\"\n}\n\ncandidate()\
    \ {\n    parse_nested_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"(()()) ((())) () ((())()())\") = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (())\
    \ ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[ $(candidate \"(()(())((())))\")\
    \ = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: 'sed: -e expression #1, char 9: Unmatched ( or \(

    sed: -e expression #1, char 9: Unmatched ) or \)

    '
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n    local string=\"$1\"\n    local regex='\\\
    ([^()]*(?'    # 1: group opening\n    regex+='('                   # 2: group\
    \ opening\n    regex+='[^()]*'              # 3: non-parentheses\n    regex+='|'\
    \                   # 4: or\n    regex+='('                   # 5: group opening\n\
    \    regex+='[^()]*'              # 6: non-parentheses\n    regex+='|'       \
    \            # 7: or\n    regex+='(('                  # 8: group opening\n  \
    \  regex+='[^()]*'              # 9: non-parentheses\n    regex+='|'         \
    \          # 10: or\n    regex+='(('                  # 11: group opening\n  \
    \  regex+='[^()]*'              # 12: non-parentheses\n    regex+='|'        \
    \           # 13: or\n    regex+='(('                  # 14: group opening\n \
    \   regex+='[^()]*'              # 15: non-parentheses\n    regex+='|'       \
    \            # 16: or\n    regex+='(('                  # 17: group opening\n\
    \    regex+='[^()]*'              # 18: non-parentheses\n    regex+='|'      \
    \             # 19: or\n    regex+='(('                  # 20: group opening\n\
    \    regex+='[^()]*'              # 21: non-parentheses\n    regex+='|'      \
    \             # 22: or\n    regex+='(('                  # 23: group opening\n\
    \    regex+='[^()]*'              # 24: non-parentheses\n    regex+='|'      \
    \             # 25: or\n    regex+='(('                  # 26: group opening\n\
    \    regex+='[^()]*'              # 27: non-parentheses\n    regex+='|'      \
    \             # 28: or\n    regex+='(('                  # 29: group opening\n\
    \    regex+='[^()]*'              # 30: non-parentheses\n    regex+='|'      \
    \             # 31: or\n    regex+='(('                  # 32: group opening\n\
    \    regex+='[^()]*'              # 33: non-parentheses\n    regex+='|'      \
    \             # 34: or\n    regex\n}\n\ncandidate() {\n    parse_nested_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\"\
    ) = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3\
    \ 4\" ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmpmmn1w5ne.sh: line 45: regex: command not found

    '
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n    local params=\"$1\"\n    # default\
    \ value if no parameter passed\n    local result=0\n    if [ \"$params\" = \"\"\
    \ ]; then\n        echo $result\n    else\n        local s=\"$params\"\n     \
    \   # How many open parentheses are there in this group?\n        s=\"${s//[^(]}\"\
    \n        # How many closed parentheses are there in this group?\n        s=\"\
    ${s//[^)]}\"\n        echo $(( ${#s} ))\n    fi\n}\n\ncandidate() {\n    parse_nested_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\"\
    ) = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3\
    \ 4\" ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n    local array=($(echo $1 | tr \" \"\
    \ \"\\n\"))\n    local output\n    for i in \"${array[@]}\"\n    do\n        output+=\"\
    $(nested_parens_level \"$i\") \"\n    done\n    echo \"[$(trim_output \"$output\"\
    )]\"\n}\n\ncandidate() {\n    parse_nested_parens \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"(()()) ((())) () ((())()())\") = \"2 3 1 3\" ]]\n  \
    \  [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[ $(candidate\
    \ \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmpl1obzbas.sh: line 14: nested_parens_level: command not found

    /tmp/tmpl1obzbas.sh: line 14: nested_parens_level: command not found

    /tmp/tmpl1obzbas.sh: line 14: nested_parens_level: command not found

    /tmp/tmpl1obzbas.sh: line 14: nested_parens_level: command not found

    /tmp/tmpl1obzbas.sh: line 16: trim_output: command not found

    '
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n    declare -a arr\n    while read -r\
    \ line; do\n        arr+=(\"\\\"$(printf '%s' \"$line\" | grep -oE \"\\(((.*?))\\\
    )\" | awk -F \"(\" '{print NF-1}')\\\"\")\n    done <<< \"$1\"\n    echo \"[${arr[*]}]\"\
    \n}\n\ncandidate() {\n    parse_nested_parens \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"(()()) ((())) () ((())()())\") = \"2 3 1 3\" ]]\n  \
    \  [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[ $(candidate\
    \ \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  # TODO: Write your code here\n  echo\
    \ $1 | awk '{print gsub(/\\(/,\"X\")}'\n}\n\ncandidate() {\n    parse_nested_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\"\
    ) = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3\
    \ 4\" ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n    local __result=$(echo $1 | perl -pe\
    \ 's#[^(]*\\(([^()]*)\\)[^()]*#\"$1\"#g')\n    echo \"$__result\"\n}\n\ncandidate()\
    \ {\n    parse_nested_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"(()()) ((())) () ((())()())\") = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (())\
    \ ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[ $(candidate \"(()(())((())))\")\
    \ = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 2
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n    python -c \"print(map(lambda x: '\"\
    '+str(len(x.split('('))-1)+'\"', '$1'.split(' ')))\"\n}\n\ncandidate() {\n   \
    \ parse_nested_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    (()()) ((())) () ((())()())\") = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (())\
    \ ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[ $(candidate \"(()(())((())))\")\
    \ = \"4\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpe8l0_gux.sh: line 10: syntax error near unexpected token `(''

    /tmp/tmpe8l0_gux.sh: line 10: `    python -c "print(map(lambda x: ''"''+str(len(x.split(''(''))-1)+''"'',
    ''$1''.split('' '')))"''

    '
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n    local IFS=\" \"\n    # TODO: complete\
    \ this function\n    for i in $1; do\n        max=0\n        current=0\n     \
    \   for (( j=0; j<${#i}; j++ )); do\n            if [[ ${i:$j:1} == \"(\" ]];\
    \ then\n                ((current++))\n                if [[ $current -gt $max\
    \ ]]; then\n                    max=$current\n                fi\n           \
    \ elif [[ ${i:$j:1} == \")\" ]]; then\n                ((current--))\n       \
    \     fi\n        done\n        echo -n '\"'$max'\"'\n        echo -n \" \"\n\
    \    done\n}\n\ncandidate() {\n    parse_nested_parens \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"(()()) ((())) () ((())()())\") = \"2 3 1 3\" ]]\n  \
    \  [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[ $(candidate\
    \ \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n    local res=$(echo -n \"$1\" | grep\
    \ -o \"([^()]*)\" | grep -Eo \"\\(+[^()]*\\)\" | sed -e \"s/(/\\'/g\" -e \"s/)/\\\
    '/g\")\n    echo \"$res\"\n}\n\ncandidate() {\n    parse_nested_parens \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\"\
    ) = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3\
    \ 4\" ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  local str=\"$1\"\n  # Replace \")(\"\
    \ with \") (\".\n  local str=\"${str//\\)\\(/\\) \\(}\"\n  # For each of the space\
    \ separated groups, get the deepest level of nesting of parentheses.\n  local\
    \ tokens=$(echo \"$str\" | xargs -n1 | xargs -I% bash -c \"echo -n \\\";%\\\"\
    ; php -r 'echo max(array_map(function(\\$x){return substr_count(\\$x,\\\"(\\\"\
    );},explode(\\\"(\\\",\\\"%\\\")));'\")\n  # Remove leading \";\" and replace\
    \ \";\" with spaces.\n  local tokens=\"${tokens:1}\"\n  local tokens=\"${tokens//;/\
    \ }\"\n  echo \"[$tokens]\"\n}\n\ncandidate() {\n    parse_nested_parens \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\"\
    ) = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3\
    \ 4\" ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: 'bash: php: command not found

    bash: php: command not found

    bash: php: command not found

    bash: php: command not found

    bash: php: command not found

    bash: php: command not found

    bash: php: command not found

    '
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  echo \"$1\" | sed 's/\\([(][^()]*[)]\\\
    )/\\n\\1\\n/g' | sed 's/[(]//g' | sed 's/[)]//g' | sed 's/[^()]*//g' | sed '/^$/d'\
    \ | awk '{print length}' | paste -s -d ' '\n}\n\ncandidate() {\n    parse_nested_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\"\
    ) = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3\
    \ 4\" ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n    local max_depth=0\n    local current_depth=0\n\
    \    for ((i=0; i<${#1}; i++)); do\n        local current_char=${1:$i:1}\n   \
    \     if [[ $current_char == \"(\" ]]; then\n            ((current_depth++))\n\
    \            if [[ $current_depth -gt $max_depth ]]; then\n                max_depth=$current_depth\n\
    \            fi\n        elif [[ $current_char == \")\" ]]; then\n           \
    \ ((current_depth--))\n        elif [[ $current_char == \" \" ]]; then\n     \
    \       echo \"\\\"$max_depth\\\"\"\n            max_depth=0\n            current_depth=0\n\
    \        fi\n    done\n    echo \"\\\"$max_depth\\\"\"\n}\n\ncandidate() {\n \
    \   parse_nested_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"(()()) ((())) () ((())()())\") = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (())\
    \ ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[ $(candidate \"(()(())((())))\")\
    \ = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n    local parse_parens_stack=()\n    local\
    \ parse_parens_depth=0\n    local parse_parens_maxdepth=0\n    local parse_parens_group=()\n\
    \    local parse_parens_i=0\n    local parse_parens_j=0\n    local parse_parens_output=()\n\
    \    for (( parse_parens_i=0; parse_parens_i<${#1}; parse_parens_i++ )); do\n\
    \        # accumulate all parens and spaces\n        if [[ ${1:$parse_parens_i:1}\
    \ == \"(\" ]]; then\n            parse_parens_stack+=( \"(\" )\n            parse_parens_depth=$((\
    \ parse_parens_depth + 1 ))\n            parse_parens_maxdepth=$(( parse_parens_maxdepth\
    \ < parse_parens_depth ? parse_parens_depth : parse_parens_maxdepth ))\n     \
    \   elif [[ ${1:$parse_parens_i:1} == \")\" ]]; then\n            parse_parens_stack+=(\
    \ \")\" )\n            parse_parens_depth=$(( parse_parens_depth - 1 ))\n    \
    \    elif [[ ${1:$parse_parens_i:1} == \" \" ]]; then\n            # start a new\
    \ group if we run into a space\n            parse_parens_output+=( \"\\\"$parse_parens_maxdepth\\\
    \"\" )\n            parse_parens_stack=()\n            parse_parens_depth=0\n\
    \            parse_parens_maxdepth=0\n        fi\n    done\n    # group the last\
    \ one if we have not run into a space\n    if (( ${#parse_parens_stack[@]} !=\
    \ 0 )); then\n        parse_parens_output+=( \"\\\"$parse_parens_maxdepth\\\"\"\
    \ )\n    fi\n    echo \"${parse_parens_output[@]}\"\n}\n\ncandidate() {\n    parse_nested_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\"\
    ) = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3\
    \ 4\" ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n    local -r str=$1\n    python -c \"\n\
    from sys import argv\ndef parse_parens(s):\n    # If the string is empty, return\
    \ 0.\n    if len(s) == 0:\n        return 0\n    # Count how many left parentheses\
    \ are in the current string.\n    left = len([paren for paren in s if paren ==\
    \ '('])\n    # Count how many right parentheses are in the current string.\n \
    \   right = len([paren for paren in s if paren == ')'])\n    # If there are unbalanced\
    \ parentheses, return -1.\n    if left != right:\n        return -1\n    # If\
    \ there are no parentheses in the current string, return 0.\n    if left == 0:\n\
    \        return 0\n    # Find the first left parentheses.\n    start = s.find('(')\n\
    \    # Find the matching right parentheses.\n    end = s.find(')', start + 1)\n\
    \    # Return the number of nested parentheses found.\n    return 1 + parse_parens(s[:start]\
    \ + s[end + 1:])\nparens = []\nfor paren in argv[1].split(' '):\n    parens.append(str(parse_parens(paren)))\n\
    print('[' + ','.join(parens) + ']')\n\" $str\n}\n\ncandidate() {\n    parse_nested_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\"\
    ) = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3\
    \ 4\" ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n    local paren_string=$1\n    local paren_arr=(${paren_string//\
    \ / })\n    for paren in \"${paren_arr[@]}\"; do\n        local max_level=0\n\
    \        local paren_level=0\n        for ((i=0; i<${#paren}; i++)); do\n    \
    \        if [[ ${paren:$i:1} == \"(\" ]]; then\n                ((paren_level++))\n\
    \                if [[ $paren_level -gt $max_level ]]; then\n                \
    \    max_level=$paren_level\n                fi\n            else\n          \
    \      ((paren_level--))\n            fi\n        done\n        echo $max_level\n\
    \    done\n}\n\ncandidate() {\n    parse_nested_parens \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"(()()) ((())) () ((())()())\") = \"2 3 1 3\" ]]\n  \
    \  [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[ $(candidate\
    \ \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  local result=()\n  local count=0\n \
    \ local str=$1\n  local i=0\n  local len=${#str}\n  local max=0\n  for (( i=0;\
    \ i<len; i++ )); do\n    local char=${str:$i:1}\n    if [[ \"$char\" == \"(\"\
    \ ]]; then\n      count=$(( count + 1 ))\n      if (( count > max )); then\n \
    \       max=$count\n      fi\n    elif [[ \"$char\" == \")\" ]]; then\n      count=$((\
    \ count - 1 ))\n    elif [[ \"$char\" == \" \" ]]; then\n      result+=(\"\\\"\
    $max\\\"\")\n      max=0\n      count=0\n    fi\n  done\n  result+=(\"\\\"$max\\\
    \"\")\n  echo \"${result[@]}\"\n}\n\ncandidate() {\n    parse_nested_parens \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\"\
    ) = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3\
    \ 4\" ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 2
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  declare -a result\n  if [[ \"$#\" !=\
    \ 1 ]]; then\n    printf \"parse_nested_parens() requires a single string as input\\\
    n\" >&2\n    exit 1\n  fi\n  # echo \"Input: $1\"\n  declare -a tokens\n  read\
    \ -a tokens <<< $(tr -d '\\n' <<< \"$1\" | sed -e 's/ //g')\n  # Debugging\n \
    \ # echo \"Tokens: ${tokens[@]}\"\n  for token in \"${tokens[@]}\"; do\n    declare\
    \ -a open_parens_stack\n    declare -a close_parens_stack\n    local max_level=0\n\
    \    local current_level=0\n    local level_found_paren=0\n    local level_found_star=0\n\
    \    local open_parens_index=0\n    local close_parens_index=0\n    local parens_counter=0\n\
    \    local token_len=${#token}\n    for ((i=0; i<token_len; i++)); do\n      local\
    \ c=${token:i:1}\n      # Debugging\n      # echo \"Processing $c\"\n      if\
    \ [[ \"$c\" == \"(\" ]]; then\n        open_parens_stack[open_parens_index++]=$i\n\
    \        open_parens_stack[open_parens_index++]=$((current_level + 1))\n     \
    \   parens_counter=$((parens_counter + 1))\n        # Debugging\n        # echo\
    \ \"open_parens_stack: ${open_parens_stack[@]}\"\n        # echo \"current_level:\
    \ $current_level\"\n        current_level=$((current_level + 1))\n        # Debugging\n\
    \        # echo \"current_level: $current_level\"\n        if [[ \"$current_level\"\
    \ -gt \"$max_level\" ]]; then\n          max_level=$current_level\n        fi\n\
    \      elif [[ \"$c\" == \")\" ]]; then\n        close_parens_stack[close_parens_index++]=$i\n\
    \        close_parens_stack[close_parens_index++]=$((current_level - 1\n}\n\n\
    candidate() {\n    parse_nested_parens \"$@\"\n}\n\nset -e\nrun_test() {\n   \
    \ [[ $(candidate \"(()()) ((())) () ((())()())\") = \"2 3 1 3\" ]]\n    [[ $(candidate\
    \ \"() (()) ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[ $(candidate \"(()(())((())))\"\
    ) = \"4\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpmzqn9ohv.sh: line 50: unexpected EOF while looking for matching
    `)''

    /tmp/tmpmzqn9ohv.sh: line 65: syntax error: unexpected end of file

    '
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n    local s=\"$1\"\n    local -a data\n\
    \    local -i pcount=0\n    local -i dcount=0\n    for (( i=0; i<${#s}; i++ ));\
    \ do\n        if [[ \"${s:$i:1}\" == \"(\" ]]; then\n            (( pcount++ ))\n\
    \            (( dcount++ ))\n        elif [[ \"${s:$i:1}\" == \")\" ]]; then\n\
    \            (( pcount-- ))\n        elif [[ \"${s:$i:1}\" == \" \" ]]; then\n\
    \            if (( pcount == 0 )); then\n                data[${#data[@]}]=\"\
    $dcount\"\n                dcount=0\n            fi\n        fi\n    done\n  \
    \  if (( pcount == 0 )); then\n        data[${#data[@]}]=\"$dcount\"\n    fi\n\
    \    echo ${data[@]}\n}\n\ncandidate() {\n    parse_nested_parens \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\") = \"\
    2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3 4\" ]]\n\
    \    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  max_depth=0\n  max_depth_parens=()\n\
    \  while read -r group; do\n    stack_size=0\n    for char in $(echo \"$group\"\
    \ | sed 's/\\(.\\)/\\1 /g'); do\n      if [[ \"$char\" == \"(\" ]]; then\n   \
    \     (( stack_size++ ))\n      elif [[ \"$char\" == \")\" ]]; then\n        ((\
    \ stack_size-- ))\n      fi\n    done\n    if [[ $stack_size -eq 0 ]]; then\n\
    \      if [[ $max_depth -lt $group_depth ]]; then\n        max_depth=$group_depth\n\
    \        max_depth_parens=()\n      fi\n      if [[ $max_depth -eq $group_depth\
    \ ]]; then\n        max_depth_parens+=($group)\n      fi\n    fi\n  done <<< \"\
    $1\"\n  echo \"${max_depth_parens[@]}\"\n}\n\ncandidate() {\n    parse_nested_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\"\
    ) = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3\
    \ 4\" ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  # TODO\n  echo $(python3 -c \"import\
    \ sys; sys.stdout.write('['); sys.stdout.write(', '.join([str(len(i)) for i in\
    \ '$1'.split()]))\")\n}\n\ncandidate() {\n    parse_nested_parens \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\") = \"\
    2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3 4\" ]]\n\
    \    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 0
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  local max_level=0\n  local level=0\n\
    \  local out_arr=()\n  local ch\n  local input=\"$1\"\n  local max_len=${#input}\n\
    \  local i=0\n  while [ $i -lt $max_len ]; do\n    ch=${input:$i:1}\n    case\
    \ $ch in\n      '(')\n        (( level++ ))\n        (( max_level < level )) &&\
    \ max_level=$level\n        ;;\n      ')')\n        (( level-- ))\n        ;;\n\
    \      ' ')\n        (( level > 0 )) && echo \"Invalid nesting of parentheses\
    \ at index $i\" >&2 && exit 1\n        out_arr+=(\"$max_level\")\n        max_level=0\n\
    \        ;;\n      *)\n        echo \"Invalid character $ch at index $i\" >&2\
    \ && exit 1\n        ;;\n    esac\n    (( i++ ))\n  done\n  if (( level > 0 ));\
    \ then\n    echo \"Invalid nesting of parentheses at index $i\" >&2 && exit 1\n\
    \  fi\n  out_arr+=(\"$max_level\")\n  echo \"${out_arr[@]}\"\n}\n\ncandidate()\
    \ {\n    parse_nested_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"(()()) ((())) () ((())()())\") = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (())\
    \ ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[ $(candidate \"(()(())((())))\")\
    \ = \"4\" ]]\n}\n\nrun_test"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  local parens_string=\"$1\"\n  local\
    \ parens_array=($parens_string)\n  local max_levels_string=\"\"\n  for parens\
    \ in \"${parens_array[@]}\"; do\n    local max_level=$(python -c \"print max(c.count('(')\
    \ for c in '$parens'.split('('))\")\n    local max_levels_string=\"$max_levels_string\
    \ $max_level\"\n  done\n  echo \"$max_levels_string\"\n}\n\ncandidate() {\n  \
    \  parse_nested_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    (()()) ((())) () ((())()())\") = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (())\
    \ ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[ $(candidate \"(()(())((())))\")\
    \ = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n    if [[ $# -eq 0 ]]; then\n        echo\
    \ \"Usage: $0 string\"\n        return 1\n    fi\n    echo $@ | awk 'BEGIN {\n\
    \        total_str=\"\"\n        num_parens=0\n        max_parens=0\n        max_parens_str=\"\
    \"\n    }\n    {\n        for (i=1; i<=NF; i++) {\n            if (num_parens\
    \ > max_parens) {\n                max_parens = num_parens\n                max_parens_str\
    \ = total_str\n            }\n            if (num_parens > 0) {\n            \
    \    num_parens--\n                gsub(/\\)/, \"\", total_str)\n            }\n\
    \            num_parens += length($i)\n            total_str = total_str $i\n\
    \        }\n    }\n    END {\n        if (num_parens > max_parens) {\n       \
    \     max_parens = num_parens\n            max_parens_str = total_str\n      \
    \  }\n        print \"[\\\"\" max_parens_str \"\\\"]\"\n    }'\n}\n\ncandidate()\
    \ {\n    parse_nested_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"(()()) ((())) () ((())()())\") = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (())\
    \ ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[ $(candidate \"(()(())((())))\")\
    \ = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  echo \"Your input: $1\"\n  local max_nested_parens\n\
    \  local curr_nested_parens\n  local curr_paren_level\n  local max_paren_level\n\
    \  local char\n  max_nested_parens=0\n  curr_nested_parens=0\n  max_paren_level=0\n\
    \  while [[ $# -gt 0 ]]; do\n    curr_paren_level=0\n    ((curr_nested_parens=0))\n\
    \    for ((i=0; i<${#1}; i++)); do\n      char=${1:$i:1}\n      if [[ \"$char\"\
    \ == \"(\" ]]; then\n        ((curr_paren_level++))\n        if ((curr_paren_level\
    \ > max_paren_level)); then\n          ((max_paren_level=curr_paren_level))\n\
    \        fi\n      fi\n      if [[ \"$char\" == \")\" ]]; then\n        ((curr_paren_level--))\n\
    \        if ((curr_paren_level < 0)); then\n          ((curr_paren_level=0))\n\
    \        fi\n      fi\n      if ((curr_paren_level == 0)); then\n        if ((curr_nested_parens\
    \ > max_nested_parens)); then\n          ((max_nested_parens=curr_nested_parens))\n\
    \        fi\n      fi\n    done\n    shift\n  done\n  echo \"Max Nested Parentheses:\
    \ $max_nested_parens\"\n}\n\ncandidate() {\n    parse_nested_parens \"$@\"\n}\n\
    \nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\") =\
    \ \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3 4\"\
    \ ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  local input=$1\n  # Split the string\
    \ by space into groups.\n  # Then, apply pattern substitution to each group:\n\
    \  # Strip off left most parentheses and keep the remaining string as is.\n  #\
    \ Repeat the step until nothing left.\n  # Then, count how many times the step\
    \ is performed.\n  # This count is the level of nested parentheses.\n  echo $input\
    \ | tr ' ' '\\n' | sed 's/^(//' | sed 's/^(//' | wc -l | tr '\\n' ' '\n}\n\ncandidate()\
    \ {\n    parse_nested_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"(()()) ((())) () ((())()())\") = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (())\
    \ ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[ $(candidate \"(()(())((())))\")\
    \ = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n    echo $1 | sed 's/[^()]//g' | awk '{\n\
    \        max_nesting = 0\n        curr_nesting = 0\n        for (i = 1; i <= length($0);\
    \ i++) {\n            if (substr($0, i, 1) == \"(\") {\n                curr_nesting\
    \ += 1\n            } else {\n                curr_nesting -= 1\n            }\n\
    \            if (curr_nesting > max_nesting) {\n                max_nesting =\
    \ curr_nesting\n            }\n        }\n        print(max_nesting)\n    }'\n\
    }\n\ncandidate() {\n    parse_nested_parens \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"(()()) ((())) () ((())()())\") = \"2 3 1 3\" ]]\n    [[\
    \ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[ $(candidate\
    \ \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  parens=$1\n  echo \"[\"\n  while read\
    \ -r line; do\n    n=\"$(echo \"$line\" | awk 'BEGIN {\n      depth = 0\n    \
    \  max = 0\n    }\n    {\n      for (i = 1; i <= length($0); i++) {\n        if\
    \ (substr($0, i, 1) == \"(\") {\n          depth++\n          if (depth > max)\
    \ {\n            max = depth\n          }\n        } else if (substr($0, i, 1)\
    \ == \")\") {\n          depth--\n        }\n      }\n    }\n    END {\n     \
    \ print max\n    }')\"\n    if [ -z \"$n\" ]; then\n      n=0\n    fi\n    echo\
    \ \"\\\"$n\\\",\"\n  done <<< \"$parens\"\n  echo \"]\"\n}\n\ncandidate() {\n\
    \    parse_nested_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"(()()) ((())) () ((())()())\") = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (())\
    \ ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[ $(candidate \"(()(())((())))\")\
    \ = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  [ -z \"$1\" ] && return 0\n  echo \"\
    $1\" | tr ' ' '\\n' | sed -E 's/^\\(([^()]*)\\)$/\\1/' | while read input; do\n\
    \    echo -n '\"'\n    echo -n \"$input\" | awk '{\n      depth = 0\n      max_depth\
    \ = 0\n      for (i = 1; i <= length($0); i++) {\n        if (substr($0, i, 1)\
    \ == \"(\") {\n          depth += 1\n        } else if (substr($0, i, 1) == \"\
    )\") {\n          depth -= 1\n        }\n        if (depth > max_depth) {\n  \
    \        max_depth = depth\n        }\n      }\n      print max_depth\n    }'\n\
    \    echo -n '\" '\n  done\n}\n\ncandidate() {\n    parse_nested_parens \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\"\
    ) = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3\
    \ 4\" ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n    local __nested_parens_result=$(echo\
    \ \"$1\" | sed 's/(/\\\\(/g' | sed 's/)/\\\\)/g' | awk '{printf \"%s \",gsub(/[^(]*/,\"\
    &1\")}')\n    echo \"$__nested_parens_result\"\n}\n\ncandidate() {\n    parse_nested_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\"\
    ) = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3\
    \ 4\" ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 0
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n    str=$1\n    output=()\n    for group\
    \ in $str; do\n        #echo $group\n        level=0\n        max_level=0\n  \
    \      for (( i=0; i<${#group}; i++ )); do\n            c=${group:$i:1}\n    \
    \        if [ \"$c\" == \"(\" ]; then\n                level=$((level+1))\n  \
    \          elif [ \"$c\" == \")\" ]; then\n                level=$((level-1))\n\
    \            fi\n            if [ $level -gt $max_level ]; then\n            \
    \    max_level=$level\n            fi\n        done\n        output+=($max_level)\n\
    \    done\n    echo ${output[@]}\n}\n\ncandidate() {\n    parse_nested_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\"\
    ) = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3\
    \ 4\" ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n    local str=$1\n    local arr\n    IFS='\
    \ ' read -r -a arr <<< \"$str\"\n    echo $(echo ${arr[@]} | sed 's/\\(\\)/\\\
    n\\1\\n/g' | \n          sed 's/\\(/\\n\\1\\n/g' | \n          sed 's/\\([^()]\\\
    )/\\1 /g' | \n          sed 's/ //g' | \n          sed 's/[()]/\\n\\0\\n/g' |\
    \ \n          sed 's/[()]/\\0 /g' | \n          awk '{ print $1 \" \" NF-2 }'\
    \ | \n          sed 's/ /,/g' | \n          awk -F ',' '{\n            if ($2\
    \ == \"1\") { \n                max[$1] = $2 \n            } else {\n        \
    \        max[$1] = max[$1] + $2\n            }\n          } END {\n          \
    \  for (m in max) {\n                print \"\\\"\" max[m] \"\\\"\"\n        \
    \    }\n          }')\n}\n\ncandidate() {\n    parse_nested_parens \"$@\"\n}\n\
    \nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\") =\
    \ \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3 4\"\
    \ ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: 'sed: -e expression #1, char 13: Unmatched ( or \(

    '
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n    if [ \"$1\" = \"\" ]; then\n     \
    \   return\n    fi\n    local s=$1\n    local max_nesting=0\n    local current_nesting=0\n\
    \    for ((i=0; i<${#s}; i++)); do\n        if [ \"${s:$i:1}\" = \"(\" ]; then\n\
    \            ((current_nesting++))\n            ((max_nesting=max_nesting>current_nesting?max_nesting:current_nesting))\n\
    \        elif [ \"${s:$i:1}\" = \")\" ]; then\n            ((current_nesting--))\n\
    \        fi\n    done\n    echo \"\\\"$max_nesting\\\"\"\n}\n\ncandidate() {\n\
    \    parse_nested_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"(()()) ((())) () ((())()())\") = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (())\
    \ ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[ $(candidate \"(()(())((())))\")\
    \ = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n    local input=()\n    local output=()\n\
    \    local stack=()\n    local right_delimiter_len=1\n    local paren_count=0\n\
    \    local char\n    # Convert input string to array, then get its length\n  \
    \  input=(${1})\n    local len=${#input[@]}\n    # Create a stack to keep track\
    \ of opening parentheses.\n    # If the current character is ')',\n    # pop one\
    \ item from the stack, then increment paren_count by one.\n    # If the stack\
    \ is empty, then the current level of nesting of parentheses is the paren_count,\n\
    \    # and then output it.\n    for ((i=0; i<len; i++)); do\n        char=${input[i]}\n\
    \        if [[ \"$char\" == \"(\" ]]; then\n            stack+=(0)\n        elif\
    \ [[ \"$char\" == \")\" ]]; then\n            stack=(\"${stack[@]:0:${#stack[@]}-right_delimiter_len}\"\
    )\n            ((++paren_count))\n            if [[ ${#stack[@]} -eq 0 ]]; then\n\
    \                output+=($paren_count)\n                paren_count=0\n     \
    \       fi\n        fi\n    done\n    echo $output\n}\n\ncandidate() {\n    parse_nested_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\"\
    ) = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3\
    \ 4\" ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  nested_parens_list=$1\n  parsed_nested_parens=\"\
    \"\n  for nested_parens in $nested_parens_list; do\n    # Convert the current\
    \ parenthesized string to a list of opening and closing parentheses.\n    nested_parens=$(sed\
    \ 's/[()]/& /g' <<< $nested_parens)\n    # For every opening parentheses, add\
    \ 1 to the counter.\n    # For every closing parentheses, subtract 1 from the\
    \ counter.\n    # Keep track of the maximum counter.\n    max_nesting=0\n    nesting=0\n\
    \    for paren in $nested_parens; do\n      if [[ $paren == \"(\" ]]; then\n \
    \       (( nesting += 1 ))\n      else\n        (( nesting -= 1 ))\n      fi\n\
    \      if [[ $nesting -gt $max_nesting ]]; then\n        max_nesting=$nesting\n\
    \      fi\n    done\n    parsed_nested_parens=\"$parsed_nested_parens \\\"$max_nesting\\\
    \"\"\n  done\n  echo $parsed_nested_parens\n}\n\ncandidate() {\n    parse_nested_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\"\
    ) = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3\
    \ 4\" ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n    # Give an empty string as an input,\
    \ we should return an empty list.\n    if [ -z \"$1\" ]; then\n        echo \"\
    []\"\n        return\n    fi\n\n    # We use a stack to remember the depth of\
    \ the last seen \"(\" in the group.\n    # Each element in the stack is a number\
    \ represents the depth at the point when the \"(\" is found.\n    # When we see\
    \ a \")\", we pop out the top element from the stack.\n    # The popped number\
    \ is the level of nested parentheses for the corresponding \")\".\n    # The length\
    \ of the stack is the depth of the last seen \"(\".\n    local -a stack\n    local\
    \ stack_top\n    local depth\n    local group\n    local max_depth\n\n    while\
    \ read -r group; do\n        stack_top=0\n        max_depth=0\n        while read\
    \ -r -n1 char; do\n            if [ \"$char\" == \"(\" ]; then\n             \
    \   stack[$stack_top]=$((stack_top + 1))\n                stack_top=$((stack_top\
    \ + 1))\n            elif [ \"$char\" == \")\" ]; then\n                # Pop\
    \ the top element from the stack.\n                stack_top=$((stack_top - 1))\n\
    \                depth=${stack[$stack_top]}\n                if [ \"$depth\" -gt\
    \ \"$max_depth\" ]; then\n                    max_depth=$depth\n             \
    \   fi\n            fi\n        done <<< \"$group\"\n        echo -n \"${max_depth}\
    \ \"\n    done <<< \"$1\"\n}\n\ncandidate() {\n    parse_nested_parens \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\"\
    ) = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3\
    \ 4\" ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  IFS=' ' read -r -a array <<< \"$1\"\n\
    \  for element in \"${array[@]}\"\n  do\n    local max_level=0\n    local current_level=0\n\
    \    local current_char\n    for ((i=0; i<${#element}; i++))\n    do\n      current_char=\"\
    ${element:$i:1}\"\n      if [[ \"$current_char\" == \"(\" ]]; then\n        ((current_level++))\n\
    \        if ((current_level > max_level)); then\n          max_level=$current_level\n\
    \        fi\n      elif [[ \"$current_char\" == \")\" ]]; then\n        ((current_level--))\n\
    \      fi\n    done\n    echo -n \"\\\"$max_level\\\" \"\n  done\n}\n\ncandidate()\
    \ {\n    parse_nested_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"(()()) ((())) () ((())()())\") = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (())\
    \ ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[ $(candidate \"(()(())((())))\")\
    \ = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 0
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  if [ $# -eq 0 ]; then\n    echo \"error:\
    \ not enough arguments\"\n    exit 1\n  fi\n  IFS=$' ' read -r -a array <<< \"\
    $1\"\n  array_len=${#array[@]}\n  i=0\n  while [ $i -lt $array_len ]; do\n   \
    \ max_depth=0\n    depth=0\n    for (( j=0; j<${#array[$i]}; j++ )); do\n    \
    \  char=${array[$i]:$j:1}\n      if [ \"$char\" == \"(\" ]; then\n        ((depth++))\n\
    \        if [ $depth -gt $max_depth ]; then\n          max_depth=$depth\n    \
    \    fi\n      elif [ \"$char\" == \")\" ]; then\n        ((depth--))\n      fi\n\
    \    done\n    parsed_array[$i]=$max_depth\n    ((i++))\n  done\n  echo ${parsed_array[@]}\n\
    }\n\ncandidate() {\n    parse_nested_parens \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"(()()) ((())) () ((())()())\") = \"2 3 1 3\" ]]\n    [[\
    \ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[ $(candidate\
    \ \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 2
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  local str=$1\n  # Below uses the basic\
    \ idea of the regex matching, but since it's so simple, a state machine can be\
    \ easily constructed.\n  #str=$(echo $str | grep -oE '\\([^()]*\\)' | sed 's/[()]//g')\n\
    \  #\n  # Below is the state machine.\n  #\n  # Levels of nested parentheses are\
    \ counted in the variable level.\n  # The variable in_paren keeps track of whether\
    \ the character just before 'i' is a '(' or not.\n  # The variable in_str keeps\
    \ track of whether the character just before 'i' is within a string or not.\n\
    \  # The variable max_level keeps track of the deepest level of nesting.\n  #\n\
    \  # If the character 'i' is '(',\n  #   if not in a string, then increase level\
    \ by 1 and in_paren becomes true.\n  #   else do nothing.\n  #\n  # If the character\
    \ 'i' is ')',\n  #   if not in a string, then in_paren becomes false, compare\
    \ level with max_level, and decrease level by 1.\n  #   else do nothing.\n  #\n\
    \  # If the character 'i' is '\"',\n  #   if not in a string, then in_str becomes\
    \ true,\n  #   else in_str becomes false.\n  #\n  # Otherwise,\n  #   if in_paren\
    \ is true, then do nothing.\n  #   else if in_str is true, then do nothing.\n\
    \  #   else if the character 'i' is space, then start a new level and do nothing.\n\
    \  #   else assert error.\n  local arr=()\n  local c=\"\"\n  local level=0\n \
    \ local max_level=0\n  local in_paren=false\n  local in_str=false\n  for ((i=0;\
    \ i<${#str}; i++)); do\n    c=${str:$i:1}\n    if [[ $c == \"(\" ]]; then\n  \
    \    if [[ $in_str == true ]]; then\n        continue\n      fi\n      level=$((level+1))\n\
    \      in_paren=true\n    elif [[ $c == \")\" ]]; then\n     \n}\n\ncandidate()\
    \ {\n    parse_nested_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"(()()) ((())) () ((())()())\") = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (())\
    \ ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[ $(candidate \"(()(())((())))\")\
    \ = \"4\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpcavcvcmy.sh: line 54: syntax error near unexpected token `}''

    /tmp/tmpcavcvcmy.sh: line 54: `}''

    '
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n    IFS=' ' read -r -a arr <<< \"$1\"\n\
    \    echo \"[\"\n    for word in \"${arr[@]}\"; do\n        echo -n $(parse_nested_parens_of_word\
    \ \"$word\")\n        echo \",\"\n    done\n    echo \"]\"\n}\n\ncandidate() {\n\
    \    parse_nested_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"(()()) ((())) () ((())()())\") = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (())\
    \ ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[ $(candidate \"(()(())((())))\")\
    \ = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmpf24msihg.sh: line 13: parse_nested_parens_of_word: command not
    found

    /tmp/tmpf24msihg.sh: line 13: parse_nested_parens_of_word: command not found

    /tmp/tmpf24msihg.sh: line 13: parse_nested_parens_of_word: command not found

    /tmp/tmpf24msihg.sh: line 13: parse_nested_parens_of_word: command not found

    '
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n    echo \"$1\" | tr \" \" \"\\n\" | perl\
    \ -e '\n        use strict;\n        use warnings;\n        while(<STDIN>) {\n\
    \            chomp;\n            my $max_nesting_level = 0;\n            while\
    \ ($_ =~ /\\(/g) {\n                $max_nesting_level++;\n            }\n   \
    \         print \"\\\"$max_nesting_level\\\" \";\n        }\n    '\n}\n\ncandidate()\
    \ {\n    parse_nested_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"(()()) ((())) () ((())()())\") = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (())\
    \ ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[ $(candidate \"(()(())((())))\")\
    \ = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: -1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  local parens_match=\"([^()]*\\([^()]*\\\
    )[^()]*)\"\n  local result\n  local -a tmp=()\n  while [[ $1 =~ $parens_match\
    \ ]]; do\n    tmp+=(\"${#BASH_REMATCH[1]}\")\n    result=\"${1//\\(/}\"\n    result=\"\
    ${result//\\)/}\"\n    result=${result//${BASH_REMATCH[1]}/}\n    if [[ -z $result\
    \ ]]; then\n      break\n    fi\n  done\n  for i in \"${tmp[@]}\"; do\n    echo\
    \ -n \\\"$i\\\"\n    echo -n \" \"\n  done\n  echo\n}\n\ncandidate() {\n    parse_nested_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\"\
    ) = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3\
    \ 4\" ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Timeout
  stderr: <_io.TextIOWrapper name=16 encoding='utf-8'>
  stdout: <_io.TextIOWrapper name=13 encoding='utf-8'>
  timestamp: 1660022613
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n    regex='[\\(\\)]+'\n    string=$1\n\
    \    IFS=' '\n    # token is a part of string enclosed within the outermost parentheses.\n\
    \    # For example, \" () \" contains \"()\", \"()()\" contains (\"()\", \"()\"\
    )\n    # and \"(()()) ((()))\" contains (\"(()())\", \"(()))\")\n    for token\
    \ in $string; do\n        # element is a part of token excluding outermost parentheses\n\
    \        for element in $token; do\n            if [[ $element =~ $regex ]]; then\n\
    \                max_level=$(get_max_level $element)\n                echo -n\
    \ \"\\\"$max_level\\\" \"\n            fi\n        done\n    done\n    echo\n\
    }\n\ncandidate() {\n    parse_nested_parens \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"(()()) ((())) () ((())()())\") = \"2 3 1 3\" ]]\n    [[\
    \ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[ $(candidate\
    \ \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmpt_kayaj5.sh: line 20: get_max_level: command not found

    /tmp/tmpt_kayaj5.sh: line 20: get_max_level: command not found

    /tmp/tmpt_kayaj5.sh: line 20: get_max_level: command not found

    /tmp/tmpt_kayaj5.sh: line 20: get_max_level: command not found

    '
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  # NOTE: this regex will match the innermost\
    \ parens first. To change the order,\n  # use (?:(?R)|[^()])* instead of ([^()]|(?R))*\n\
    \  [[ \"$1\" =~ \\(([^()]|(?R))*\\) ]] &&\n    echo \"${BASH_REMATCH[1]}\"\n \
    \   # The above line outputs the first match of the regex. To output all matches,\n\
    \    # try:\n    # for ((i=1; i<${#BASH_REMATCH[@]}; i++)); do\n    #  echo \"\
    ${BASH_REMATCH[i]}\"\n    # done\n}\n\ncandidate() {\n    parse_nested_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\"\
    ) = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3\
    \ 4\" ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  local result\n  if [[ -z $1 ]]; then\n\
    \    result=\"\"\n  else\n    result=\"$(echo \"$1\" | sed -r 's/.*\\(|\\)/\\\
    1/' | sed -r 's/(.*)\\).*/\\1/' | awk '{print length}')\"\n  fi\n  echo $result\n\
    }\n\ncandidate() {\n    parse_nested_parens \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"(()()) ((())) () ((())()())\") = \"2 3 1 3\" ]]\n    [[\
    \ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[ $(candidate\
    \ \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: 'sed: -e expression #1, char 13: invalid reference \1 on `s'' command''s
    RHS

    '
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n    local input=$1\n    # Split by spaces\n\
    \    IFS=' ' read -r -a input_arr <<< \"$input\"\n    local max_depth=1\n    for\
    \ element in \"${input_arr[@]}\"; do\n        max_depth=1\n        while [[ $element\
    \ =~ \\(([^\\(\\)]*)\\) ]]; do\n            element=${BASH_REMATCH[1]}\n     \
    \       ((max_depth+=1))\n        done\n        echo \"\\\"$max_depth\\\"\"\n\
    \    done\n}\n\ncandidate() {\n    parse_nested_parens \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"(()()) ((())) () ((())()())\") = \"2 3 1 3\" ]]\n  \
    \  [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[ $(candidate\
    \ \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  if [ -z \"$1\" ]; then\n    echo -n\
    \ \"\"\n    return 0\n  fi\n\n  local echo_str=\"\"\n  local delimiter=\",\"\n\
    \  local idx\n  local paren_str\n  local paren_arr\n  local stack\n  local paren\n\
    \  local max_level\n\n  # Loop through each group\n  local IFS=$' '\n  for paren_str\
    \ in $1; do\n    paren_arr=($(echo $paren_str | grep -oE \"\\(|\\)\"))\n\n   \
    \ # Initialize variables\n    stack=\"\"\n    idx=0\n    max_level=0\n\n    #\
    \ Loop through each parenthesis in the group\n    for paren in \"${paren_arr[@]}\"\
    ; do\n      if [ \"$paren\" == \"(\" ]; then\n        # If it's an opening parenthesis,\
    \ increment the index\n        stack+=\"$idx \"\n        idx=$((idx+1))\n    \
    \  else\n        # If it's a closing parenthesis, we're going down one level\n\
    \        stack=${stack% *}\n        idx=$((idx-1))\n      fi\n\n      # Keep track\
    \ of the max index\n      if [ $idx -gt $max_level ]; then\n        max_level=$idx\n\
    \      fi\n    done\n\n    # Add this to our echo string\n    echo_str+=\"\\\"\
    $max_level\\\"$delimiter\"\n  done\n\n  # Remove last comma and echo the string\n\
    \  echo_str=${echo_str%$delimiter}\n  echo -n \"[$echo_str]\"\n}\n\ncandidate()\
    \ {\n    parse_nested_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"(()()) ((())) () ((())()())\") = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (())\
    \ ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[ $(candidate \"(()(())((())))\")\
    \ = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  echo $1 |\n  # Replace the multiple\
    \ groups with special delimiters.\n  sed -e 's/ /|/g' |\n  # Replace nested parentheses\
    \ with\n  #   1) the same level of nesting (modulo 9) for the beginning, and\n\
    \  #   2) the same level of nesting (modulo 9) for the end.\n  sed -e 's/(\\([0-9]\\\
    ))/\\1\\1/g' -e 's/\\([0-9]\\))/(\\1/g' |\n  # Get the deepest level of nesting\
    \ of the parentheses for each group.\n  sed -e 's/(\\([0-9]\\))/\\1/g' -e 's/\\\
    ([0-9]\\))/\\1/g' |\n  # Collect the deepest level of nesting of the parentheses.\n\
    \  # [0-9] matches a nested parentheses because the last sed command replaced\
    \ the same level of nesting (modulo 9) with a single parentheses.\n  sed -e 's/|/\"\
    , \"/g' -e 's/\\([0-9]\\)/\"\\1\"/g'\n}\n\ncandidate() {\n    parse_nested_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\"\
    ) = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3\
    \ 4\" ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  local str=\"$1\"\n  echo \"$str\" |\
    \ awk '{\n    depth=0\n    max_depth=0\n    for (i=1; i<=length($0); i++) {\n\
    \      if (substr($0, i, 1) == \"(\") {\n        depth++\n        if (depth >\
    \ max_depth) {\n          max_depth = depth\n        }\n      } else if (substr($0,\
    \ i, 1) == \")\") {\n        depth--\n      }\n    }\n    print max_depth\n  }'\n\
    }\n\ncandidate() {\n    parse_nested_parens \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"(()()) ((())) () ((())()())\") = \"2 3 1 3\" ]]\n    [[\
    \ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[ $(candidate\
    \ \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  declare -a open_parens_indexes\n  max_level=0\n\
    \  current_level=0\n  for ((i=0; i<${#1}; i++)); do\n    if [[ \"${1:$i:1}\" ==\
    \ \"(\" ]]; then\n      open_parens_indexes+=(\"$i\")\n      ((current_level++))\n\
    \      if (( current_level > max_level )); then\n        max_level=$current_level\n\
    \      fi\n    elif [[ \"${1:$i:1}\" == \")\" ]]; then\n      ((current_level--))\n\
    \      unset 'open_parens_indexes[${#open_parens_indexes[@]}-1]'\n    fi\n  done\n\
    \  echo $max_level\n}\n\ncandidate() {\n    parse_nested_parens \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\") = \"\
    2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3 4\" ]]\n\
    \    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n    group_pairs=($(echo $1 | sed 's/ /\\\
    n/g'))\n    results=()\n    for group in \"${group_pairs[@]}\"; do\n        test_string=\"\
    $group\"\n        n=0\n        while [[ \"$test_string\" =~ [^()]*\\([^()]*\\\
    ) ]]; do\n            test_string=${test_string#*\\(}\n            ((n++))\n \
    \       done\n        results+=($n)\n    done\n    echo ${results[@]}\n}\n\ncandidate()\
    \ {\n    parse_nested_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"(()()) ((())) () ((())()())\") = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (())\
    \ ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[ $(candidate \"(()(())((())))\")\
    \ = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  echo $1 | sed -e 's/[^()]//g' | tr -d\
    \ '\\n' | sed -e 's/()/1/g' | sed -e 's/(1)/2/g' | sed -e 's/(2)/3/g' | sed -e\
    \ 's/(3)/4/g' | sed -e 's/(4)/5/g' | sed -e 's/(5)/6/g' | sed -e 's/(6)/7/g' |\
    \ sed -e 's/(7)/8/g' | sed -e 's/(8)/9/g' | sed -e 's/(9)/a/g' | sed -e 's/(a)/b/g'\
    \ | sed -e 's/(b)/c/g' | sed -e 's/(c)/d/g' | sed -e 's/(d)/e/g' | sed -e 's/(e)/f/g'\
    \ | sed -e 's/(f)/g/g' | sed -e 's/(g)/h/g' | sed -e 's/(h)/i/g' | sed -e 's/(i)/j/g'\
    \ | sed -e 's/(j)/k/g' | sed -e 's/(k)/l/g' | sed -e 's/(l)/m/g' | sed -e 's/(m)/n/g'\
    \ | sed -e 's/(n)/o/g' | sed -e 's/(o)/p/g' | sed -e 's/(p)/q/g' | sed -e 's/(q)/r/g'\
    \ | sed -e 's/(r)/s/g' | sed -e 's/(s)/t/g' | sed -e 's/(t)/u/g' | sed -e 's/(u)/v/g'\
    \ | sed -e 's/(v)/w/g' | sed -e 's/(w)/x/g' | sed -e 's/(x)/y/g' | sed -e 's/(y)/z/g'\
    \ | sed -e 's/(z)/A/g' | sed -e 's/(A)/B/g' | sed -e\n}\n\ncandidate() {\n   \
    \ parse_nested_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    (()()) ((())) () ((())()())\") = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (())\
    \ ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[ $(candidate \"(()(())((())))\")\
    \ = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: "sed: option requires an argument -- 'e'\nUsage: sed [OPTION]... {script-only-if-no-other-script}\
    \ [input-file]...\n\n  -n, --quiet, --silent\n                 suppress automatic\
    \ printing of pattern space\n      --debug\n                 annotate program\
    \ execution\n  -e script, --expression=script\n                 add the script\
    \ to the commands to be executed\n  -f script-file, --file=script-file\n     \
    \            add the contents of script-file to the commands to be executed\n\
    \  --follow-symlinks\n                 follow symlinks when processing in place\n\
    \  -i[SUFFIX], --in-place[=SUFFIX]\n                 edit files in place (makes\
    \ backup if SUFFIX supplied)\n  -l N, --line-length=N\n                 specify\
    \ the desired line-wrap length for the `l' command\n  --posix\n              \
    \   disable all GNU extensions.\n  -E, -r, --regexp-extended\n               \
    \  use extended regular expressions in the script\n                 (for portability\
    \ use POSIX -E).\n  -s, --separate\n                 consider files as separate\
    \ rather than as a single,\n                 continuous long stream.\n      --sandbox\n\
    \                 operate in sandbox mode (disable e/r/w commands).\n  -u, --unbuffered\n\
    \                 load minimal amounts of data from the input files and flush\n\
    \                 the output buffers more often\n  -z, --null-data\n         \
    \        separate lines by NUL characters\n      --help     display this help\
    \ and exit\n      --version  output version information and exit\n\nIf no -e,\
    \ --expression, -f, or --file option is given, then the first\nnon-option argument\
    \ is taken as the sed script to interpret.  All\nremaining arguments are names\
    \ of input files; if no input files are\nspecified, then the standard input is\
    \ read.\n\nGNU sed home page: <https://www.gnu.org/software/sed/>.\nGeneral help\
    \ using GNU software: <https://www.gnu.org/gethelp/>.\n"
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  # Convert a string to a list of strings.\
    \ This is needed to apply 'sed' to the whole string.\n  # E.g. $1 = \"(()()) ((()))\"\
    \n  # >>> $(list_to_string \"$1\")\n  # [\"(()())\", \"((()))\"]\n  list_to_string\
    \ \"$1\" | sed 's/\\(.*\\)/\"[\\\"&\\\"]\"/g'\n}\n\ncandidate() {\n    parse_nested_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\"\
    ) = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3\
    \ 4\" ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmp7pqgtnl6.sh: line 14: list_to_string: command not found

    '
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n    echo $1 | sed -e 's/ //g' | sed -e\
    \ 's/\\(([^()]*)\\)/\"\\1\"/g' | sed -e 's/\\(([^()]*(()[^()]*)*)\\)/\"\\1\"/g'\
    \ | sed -e 's/(\\([^()]*\\)*)/\"\\1\"/g' | sed -e 's/\\(/ /g' | sed -e 's/\\)/\
    \ /g' | sed -e 's/^\"\\(.*\\)\"$/\\1/g' | sed -e 's/\"//g' | sed -e 's/[0-9]\\\
    +/\\&/g' | sed -e 's/^\\([^\\&]*\\)\\&\\(.*\\)$/\\1\\2/g' | sed -e 's/\\&\\([^\\\
    &]*\\)/\\1/g' | sed -e 's/ //g' | sed -e 's/\\(\\&\\)\\{2,\\}/\\&/g' | sed -e\
    \ 's/\\(\\&\\)\\{2,\\}/\\&/g' | sed -e 's/\\&\\([^\\&]*\\)/\\1/g' | sed -e 's/\
    \ //g' | sed -e 's/^\\([^\\&]*\\)\\&\\(.*\\)$/\\1\\2/g' | sed -e 's/\\&\\([^\\\
    &]*\\)/\\1/g' | sed -e 's/ //g' | sed -e 's/\\(\\&\\)\\{2,\\}/\\&/g' | sed -e\
    \ 's/\\(\\&\\)\\{2,\\}/\\&/g' | sed -e 's/\\&\\([^\\&]*\\)/\\1/g' | sed -e 's/\
    \ //g' | sed -e 's/^\\([^\\&]*\\)\\&\\(.*\\)$/\\1\\2/g' | sed -e 's/\\&\\([^\\\
    &]*\\)/\\1/g' | sed -e\n}\n\ncandidate() {\n    parse_nested_parens \"$@\"\n}\n\
    \nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\") =\
    \ \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3 4\"\
    \ ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: "sed: -e expression #1, char 8: Unmatched ( or \\(\nsed: -e expression #1,\
    \ char 8: Unmatched ) or \\)\nsed: option requires an argument -- 'e'\nUsage:\
    \ sed [OPTION]... {script-only-if-no-other-script} [input-file]...\n\n  -n, --quiet,\
    \ --silent\n                 suppress automatic printing of pattern space\n  \
    \    --debug\n                 annotate program execution\n  -e script, --expression=script\n\
    \                 add the script to the commands to be executed\n  -f script-file,\
    \ --file=script-file\n                 add the contents of script-file to the\
    \ commands to be executed\n  --follow-symlinks\n                 follow symlinks\
    \ when processing in place\n  -i[SUFFIX], --in-place[=SUFFIX]\n              \
    \   edit files in place (makes backup if SUFFIX supplied)\n  -l N, --line-length=N\n\
    \                 specify the desired line-wrap length for the `l' command\n \
    \ --posix\n                 disable all GNU extensions.\n  -E, -r, --regexp-extended\n\
    \                 use extended regular expressions in the script\n           \
    \      (for portability use POSIX -E).\n  -s, --separate\n                 consider\
    \ files as separate rather than as a single,\n                 continuous long\
    \ stream.\n      --sandbox\n                 operate in sandbox mode (disable\
    \ e/r/w commands).\n  -u, --unbuffered\n                 load minimal amounts\
    \ of data from the input files and flush\n                 the output buffers\
    \ more often\n  -z, --null-data\n                 separate lines by NUL characters\n\
    \      --help     display this help and exit\n      --version  output version\
    \ information and exit\n\nIf no -e, --expression, -f, or --file option is given,\
    \ then the first\nnon-option argument is taken as the sed script to interpret.\
    \  All\nremaining arguments are names of input files; if no input files are\n\
    specified, then the standard input is read.\n\nGNU sed home page: <https://www.gnu.org/software/sed/>.\n\
    General help using GNU software: <https://www.gnu.org/gethelp/>.\n"
  stdout: ''
  timestamp: 1660022608
- exit_code: 0
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  local s=$1\n  local max_levels=0\n \
    \ local cur_levels=0\n  local max_levels_groups=()\n  for ((i=0; i<${#s}; i++));\
    \ do\n    local c=${s:$i:1}\n    if [[ $c == \"(\" ]]; then\n      cur_levels=$((cur_levels+1))\n\
    \      max_levels=$((max_levels>cur_levels?max_levels:cur_levels))\n    elif [[\
    \ $c == \")\" ]]; then\n      cur_levels=$((cur_levels-1))\n    elif [[ $c ==\
    \ \" \" ]]; then\n      max_levels_groups+=($max_levels)\n      max_levels=0\n\
    \      cur_levels=0\n    fi\n  done\n  max_levels_groups+=($max_levels)\n  max_levels=0\n\
    \  cur_levels=0\n  echo \"${max_levels_groups[@]}\"\n}\n\ncandidate() {\n    parse_nested_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\"\
    ) = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3\
    \ 4\" ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  local parens=\"$1\"\n  local result=()\n\
    \  local paren_count=0\n  local max_paren_count=0\n  while read -r -n1 c; do\n\
    \    #echo \"char is: $c\"\n    case \"$c\" in\n      (\\() paren_count=$((paren_count+1))\n\
    \            max_paren_count=$((max_paren_count>paren_count?max_paren_count:paren_count))\n\
    \            ;;\n      (\\)) paren_count=$((paren_count-1))\n            ;;\n\
    \      (*)\n        #do nothing\n        ;;\n    esac\n  done <<< \"$parens\"\n\
    \  if [ \"$paren_count\" -ne 0 ]; then\n    echo \"Error: mismatched parens\"\
    \ >&2\n    return 2\n  fi\n  echo \"\\\"$max_paren_count\\\"\"\n}\n\ncandidate()\
    \ {\n    parse_nested_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"(()()) ((())) () ((())()())\") = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (())\
    \ ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[ $(candidate \"(()(())((())))\")\
    \ = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n    local out=()\n    local IFS=$' '\n\
    \    for nested_parens in $1; do\n        max_level=0\n        level=0\n     \
    \   for (( i=0; i<${#nested_parens}; i++ )); do\n            char=${nested_parens:$i:1}\n\
    \            if [[ $char == \"(\" ]]; then\n                ((level++))\n    \
    \            if (( level > max_level )); then\n                    max_level=$level\n\
    \                fi\n            elif [[ $char == \")\" ]]; then\n           \
    \     ((level--))\n            fi\n        done\n        out+=(\"\\\"$max_level\\\
    \"\")\n    done\n    echo \"[${out[*]}]\"\n}\n\ncandidate() {\n    parse_nested_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\"\
    ) = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3\
    \ 4\" ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 0
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  echo $(echo $1 | tr ' ' '\\n' | awk\
    \ '{\n    count=0\n    max=0\n    for (i=1; i<=length($0); i++) {\n      char=substr($0,\
    \ i, 1)\n      if (char == \"(\") {\n        count += 1\n      } else if (char\
    \ == \")\") {\n        count -= 1\n      }\n      if (count > max) {\n       \
    \ max = count\n      }\n    }\n    print max\n  }')\n}\n\ncandidate() {\n    parse_nested_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\"\
    ) = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3\
    \ 4\" ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  python -c \"\nimport re\nfrom collections\
    \ import Counter\n\ndef is_balanced(pattern):\n    if not pattern:\n        return\
    \ True\n    stack = []\n    for i in range(len(pattern)):\n        if pattern[i]\
    \ == '(':\n            stack.append(pattern[i])\n        elif pattern[i] == ')':\n\
    \            if not stack:\n                return False\n            else:\n\
    \                stack.pop()\n    return len(stack) == 0\n\ndef parse_nested_parens(patterns):\n\
    \    if not patterns:\n        return []\n    result = []\n    for pattern in\
    \ patterns:\n        if not is_balanced(pattern):\n            return []\n   \
    \     result.append(Counter(pattern)['('])\n    return result\n\npatterns = '$1'.split('\
    \ ')\nprint(parse_nested_parens(patterns))\n\"\n}\n\ncandidate() {\n    parse_nested_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\"\
    ) = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3\
    \ 4\" ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n    local IFS=' ' read -ra GROUPS <<<\
    \ \"$1\"\n    for i in \"${GROUPS[@]}\"; do\n        python3 -c \"\nmax = 0\n\
    cur = 0\nfor c in '$i':\n    if c == '(':\n        cur += 1\n    elif c == ')':\n\
    \        cur -= 1\n    if cur > max:\n        max = cur\nprint(max)\"\n    done\n\
    }\n\ncandidate() {\n    parse_nested_parens \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"(()()) ((())) () ((())()())\") = \"2 3 1 3\" ]]\n    [[\
    \ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[ $(candidate\
    \ \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmprlsuyvsi.sh: line 10: local: `-ra'': not a valid identifier

    /tmp/tmprlsuyvsi.sh: line 10: local: GROUPS: variable may not be assigned value

    '
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n    echo \"${1}\" | xargs -I '{}' bash\
    \ -c '\n        max_level=0\n        level=0\n        while read -n1 c; do\n \
    \           if [[ \"${c}\" == \"(\" ]]; then\n                ((level++))\n  \
    \              max_level=${level}\n            elif [[ \"${c}\" == \")\" ]]; then\n\
    \                ((level--))\n            fi\n        done <<< \"{}\"\n      \
    \  echo \"${max_level}\"'\n}\n\ncandidate() {\n    parse_nested_parens \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\"\
    ) = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3\
    \ 4\" ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  # remove non-parens chars\n  sed 's/[^()]//g'\
    \ <<<\"$1\" |\n  # reduce consecutive parens to one\n  tr -d '()' |\n  # replace\
    \ open and close parens to 0 and 1 respectively\n  tr '()' '01' |\n  # replace\
    \ consecutive 0's or 1's to single 0 or 1\n  sed 's/[01]\\+/& /g' |\n  # count\
    \ the number of 0's and 1's and output max of these two values\n  awk '{len=length($0);\
    \ if (len == 0) print 0; else if (substr($0, 1, 1) == 0) {sub(\"0\", \"\", $0);\
    \ print len - length($0)} else {sub(\"1\", \"\", $0); print len - length($0)}}'\n\
    }\n\ncandidate() {\n    parse_nested_parens \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"(()()) ((())) () ((())()())\") = \"2 3 1 3\" ]]\n    [[\
    \ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[ $(candidate\
    \ \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n    text=\"$1\"\n    counter=0\n    max_level=0\n\
    \    while read -n 1 -s char; do\n        # Find all the parentheses\n       \
    \ if [[ \"$char\" == \"(\" ]]; then\n            ((counter++))\n            if\
    \ [[ \"$counter\" -gt \"$max_level\" ]]; then\n                max_level=\"$counter\"\
    \n            fi\n        elif [[ \"$char\" == \")\" ]]; then\n            ((counter--))\n\
    \        fi\n    done <<< \"$text\"\n    echo $max_level\n}\n\ncandidate() {\n\
    \    parse_nested_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"(()()) ((())) () ((())()())\") = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (())\
    \ ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[ $(candidate \"(()(())((())))\")\
    \ = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  local input=$1\n  local output=$(echo\
    \ $input | tr ' ' '\\n' | awk '{\n    max=0\n    for (i=1; i<=length($0); i++)\
    \ {\n      if (substr($0, i, 1) == \"(\") {\n        nest = nest + 1\n      }\
    \ else if (substr($0, i, 1) == \")\") {\n        nest = nest - 1\n      }\n  \
    \    if (nest > max) {\n        max = nest\n      }\n    }\n    print \"\\\"\"\
    \ max \"\\\"\"\n  }')\n  echo $output\n}\n\ncandidate() {\n    parse_nested_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\"\
    ) = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3\
    \ 4\" ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  if [ $# -ne 1 ]; then\n    echo \"Invalid\
    \ arguments.\"\n    exit 1\n  fi\n  local str=$1\n  # echo $str\n  local idx=0\n\
    \  while [ $idx -lt ${#str} ]; do\n    local paren_start=0\n    local paren_end=0\n\
    \    local max_level=0\n    local level=0\n    while [ $idx -lt ${#str} ]; do\n\
    \      local chr=${str:$idx:1}\n      if [ \"$chr\" == \"(\" ]; then\n       \
    \ paren_start=$idx\n        ((level++))\n        if [ $level -gt $max_level ];\
    \ then\n          max_level=$level\n        fi\n      elif [ \"$chr\" == \")\"\
    \ ]; then\n        paren_end=$idx\n        ((level--))\n      fi\n      ((idx++))\n\
    \      if [ $paren_start -ne 0 ] && [ $paren_end -ne 0 ]; then\n        break\n\
    \      fi\n    done\n    echo $max_level\n  done\n}\n\ncandidate() {\n    parse_nested_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\"\
    ) = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3\
    \ 4\" ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 0
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n    local input_str=$1\n    local output_array\n\
    \    local current_index=0\n    local paren_count=0\n    local max_count=0\n \
    \   local word_count=0\n    for (( i=0; i<${#input_str}; i++ )); do\n        if\
    \ [[ ${input_str:$i:1} == \"(\" ]]; then\n            (( paren_count++ ))\n  \
    \          if (( paren_count > max_count )); then\n                max_count=$paren_count\n\
    \            fi\n        elif [[ ${input_str:$i:1} == \")\" ]]; then\n       \
    \     (( paren_count-- ))\n        elif [[ ${input_str:$i:1} == \" \" ]]; then\n\
    \            output_array[$word_count]=$max_count\n            (( word_count++\
    \ ))\n            max_count=0\n        fi\n    done\n    output_array[$word_count]=$max_count\n\
    \    echo \"${output_array[@]}\"\n}\n\ncandidate() {\n    parse_nested_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\"\
    ) = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3\
    \ 4\" ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n    echo $1 | sed -E \"s/[()]+/'&'/g\"\
    \ | awk -F\"'\" 'BEGIN{RS=\" \";FS=\"\"} {n=split($0,a,\"\");if(length($0)==0){next};sum=0;for(i=1;i<=n;i++){if(a[i]==\"\
    (\"){sum+=1} else if(a[i]==\")\"){sum-=1}};print \"\\\"\"sum\"\\\"\"}'\n}\n\n\
    candidate() {\n    parse_nested_parens \"$@\"\n}\n\nset -e\nrun_test() {\n   \
    \ [[ $(candidate \"(()()) ((())) () ((())()())\") = \"2 3 1 3\" ]]\n    [[ $(candidate\
    \ \"() (()) ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[ $(candidate \"(()(())((())))\"\
    ) = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 2
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n    if [[ $# -eq 0 ]]; then\n        echo\
    \ \"[]\"\n        return\n    fi\n    # Split the input string based on spaces\n\
    \    # E.g. \"(()()) ((())) () ((())()())\" -> [\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"]\n    old_IFS=$IFS\n    IFS=\" \"\n    read -ra arr <<< \"$1\"\
    \n    IFS=$old_IFS\n    for i in \"${arr[@]}\"; do\n        # For each group,\
    \ remove all non-parentheses characters\n        # E.g. \"(()()) ((())) () ((())()())\"\
    \ -> \"(()())()(()())()\"\n        #      \"((()))\"                      -> \"\
    ((()))\"\n        #      \"()\"                          -> \"()\"\n        #\
    \      \"((())()())\"                  -> \"((())()())\"\n        i=\"${i//[^()]/}\"\
    \n        # An empty string has a nesting of 1.\n        if [[ -z \"$i\" ]]; then\n\
    \            echo 1\n            continue\n        fi\n        # Remove the outer\
    \ parentheses\n        # E.g. \"(()())()(()())()\" -> \"()())()(()())()\"\n  \
    \      #      \"((()))\"            -> \"(())\"\n        #      \"()\"       \
    \         -> \"\"\n        #      \"((())()())\"        -> \"(())()()\"\n    \
    \    i=\"${i:1:${#i}-2}\"\n        counter=0\n        max_counter=0\n        #\
    \ Loop over the characters in the string until the rightmost parenthesis is found.\n\
    \        # E.g. \"()())()(()())()\" -> \"()\")()(()())()\" -> \")\"()(()())()\"\
    \ -> \"\"(()())()\" -> \"()())()\" -> \")())()\" -> \"())()\" -> \")()()\" ->\
    \ \"()()\" -> \")()\" -> \"()\" -> \"\"\n        #      \"(())\"            ->\
    \ \"()\"            -> \"\"\n        #      \"\"                -> \"\"\n    \
    \    #      \"(())()()\"        -> \"()()()\"       -> \")()()\"       -> \"()()\"\
    \      \n}\n\ncandidate() {\n    parse_nested_parens \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"(()()) ((())) () ((())()())\") = \"2 3 1 3\" ]]\n  \
    \  [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[ $(candidate\
    \ \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpc8pqlnv7.sh: line 45: syntax error near unexpected token `}''

    /tmp/tmpc8pqlnv7.sh: line 45: `}''

    '
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  if [ -z \"$1\" ]; then\n    return 1\n\
    \  fi\n  echo \"[$(parse_nested_parens_helper $(echo $1 | sed 's/\\(/\\(\\(/g;s/\\\
    )/\\)\\)/g'))]\"\n}\n\ncandidate() {\n    parse_nested_parens \"$@\"\n}\n\nset\
    \ -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\") = \"2\
    \ 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3 4\" ]]\n\
    \    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: 'sed: -e expression #1, char 12: Unmatched ( or \(

    /tmp/tmp41y3w6jd.sh: line 13: parse_nested_parens_helper: command not found

    '
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  count=0;\n  maxCount=0;\n  output=\"\
    [\";\n  for (( i=0; i<${#1}; i++ )); do\n    if [[ ${1:$i:1} == \"(\" ]]; then\n\
    \      ((count++));\n      if (( count > maxCount )); then\n        maxCount=$count;\n\
    \      fi\n    elif [[ ${1:$i:1} == \")\" ]]; then\n      ((count--));\n    fi\n\
    \    if [[ ${1:$i:1} == \" \" ]]; then\n      output+=\"\\\"$maxCount\\\"\";\n\
    \      if (( i != ${#1}-1 )); then\n        output+=\", \";\n      fi\n      maxCount=0;\n\
    \      count=0;\n    fi\n  done\n  output+=\"]\";\n  echo $output;\n}\n\ncandidate()\
    \ {\n    parse_nested_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"(()()) ((())) () ((())()())\") = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (())\
    \ ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[ $(candidate \"(()(())((())))\")\
    \ = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n    echo $1 | sed -r 's/[()]+/& /g' |\
    \ tr ' ' '\\n' | \\\n        sed -r 's/^(.*)$/\\1/' | \\\n        awk '{ s = gsub(/[(]/,\
    \ \"\") - gsub(/[)]/, \"\"); print s }'\n}\n\ncandidate() {\n    parse_nested_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\"\
    ) = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3\
    \ 4\" ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  if [ -z \"$1\" ]; then\n    echo \"\
    []\"\n    return 0\n  fi\n\n  local retval=\"[\"\n  # Loop through each group\n\
    \  for group in $1; do\n    local max_depth=0\n    local level=0\n    # Loop through\
    \ each char in the group\n    for (( i=0; i<${#group}; i++ )); do\n      if [\
    \ \"${group:$i:1}\" == \"(\" ]; then\n        (( level += 1 ))\n        if [ $level\
    \ -gt $max_depth ]; then\n          max_depth=$level\n        fi\n      else\n\
    \        (( level -= 1 ))\n      fi\n    done\n    if [ $max_depth -gt 0 ]; then\n\
    \      retval+=\"\\\"$max_depth\\\", \"\n    else\n      retval+=\"\\\"$max_depth\\\
    \", \"\n    fi\n  done\n  # Remove trailing comma and space\n  retval=\"${retval::-2}\"\
    \n  retval+=\"]\"\n  echo $retval\n}\n\ncandidate() {\n    parse_nested_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\"\
    ) = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3\
    \ 4\" ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  # TODO: Fill this in with the command\
    \ you'd use to parse nested parens\n  echo \"$1\" | sed -e 's/ //g' | sed -e 's/(/\\\
    n(/g' | grep '(' | sed -e 's/.*(/(/' | tr '()' '\\n\\n' | grep -v '^$' | awk '{print\
    \ length}' | sort -n | tail -n 1\n}\n\ncandidate() {\n    parse_nested_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\"\
    ) = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3\
    \ 4\" ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n    # trim leading and trailing whitespace\
    \ and parentheses\n    local _input=${1#\\(}\n    _input=${_input#\\(}\n    _input=${_input%\\\
    )}\n    _input=${_input%\\)}\n\n    # replace all balanced parentheses with empty\
    \ string\n    # use a counter to keep track of the nesting level\n    local _max_depth=0\n\
    \    local _depth=0\n    while [[ $_input =~ \\( ]]; do\n        (( _depth++ ))\n\
    \        if [[ $_depth -gt $_max_depth ]]; then\n            _max_depth=$_depth\n\
    \        fi\n        _input=${_input/\\(/}\n        if [[ $_input =~ \\) ]]; then\n\
    \            _input=${_input/\\)/}\n            (( _depth-- ))\n        fi\n \
    \   done\n\n    echo $_max_depth\n}\n\ncandidate() {\n    parse_nested_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\"\
    ) = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3\
    \ 4\" ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  echo $1 | \\\n    sed -e 's/\\([()]\\\
    )/ \\1 /g' | \\\n    sed -e 's/\\s\\s*/ /g' | \\\n    tr ' ' '\\n' | \\\n    awk\
    \ '{ if ($1 == \"(\") ++p; else if ($1 == \")\") --p; else print p }' | \\\n \
    \   sort -n | \\\n    tail -n 1 | \\\n    awk '{ print \"\\\"\" $1 \"\\\"\" }'\n\
    }\n\ncandidate() {\n    parse_nested_parens \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"(()()) ((())) () ((())()())\") = \"2 3 1 3\" ]]\n    [[\
    \ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[ $(candidate\
    \ \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  local str=$1\n  echo $str | tr \" \"\
    \ \"\\n\" | awk '{s=$0; while(gsub(/\\(.*\\)/,\"\")); print length(s)-length($0)}'\n\
    }\n\ncandidate() {\n    parse_nested_parens \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"(()()) ((())) () ((())()())\") = \"2 3 1 3\" ]]\n    [[\
    \ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[ $(candidate\
    \ \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 2
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  local outstr=$(echo $1 | sed -e 's/^([^()]*(//g'\
    \ -e 's/[^()]*)[^()]*$//g' -e 's/[^()]*(//g' -e 's/)[^()]*//g' -e 's/([^()]*(//g'\
    \ -e 's/[^()]*)[^()]*)/1/g' -e 's/([^()]*(/2/g' -e 's/[^()]*)[^()]*)/3/g' -e 's/([^()]*(/4/g'\
    \ -e 's/[^()]*)[^()]*)/5/g' -e 's/([^()]*(/6/g' -e 's/[^()]*)[^()]*)/7/g' -e 's/([^()]*(/8/g'\
    \ -e 's/[^()]*)[^()]*)/9/g' -e 's/([^()]*(/10/g' -e 's/[^()]*)[^()]*)/11/g' -e\
    \ 's/([^()]*(/12/g' -e 's/[^()]*)[^()]*)/13/g' -e 's/([^()]*(/14/g' -e 's/[^()]*)[^()]*)/15/g'\
    \ -e 's/([^()]*(/16/g' -e 's/[^()]*)[^()]*)/17/g' -e 's/([^()]*(/18/g' -e 's/[^()]*)[^()]*)/19/g'\
    \ -e 's/([^()]*(/20/g' -e 's/[^()]*)[^()]*)/21/g' -e 's/([^()]*(/22/g' -e 's/[^()]*)[^()]*)/23/g'\
    \ -e 's/([^()]\n}\n\ncandidate() {\n    parse_nested_parens \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\") = \"2 3 1 3\"\
    \ ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[\
    \ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp20fj7yx7.sh: line 10: unexpected EOF while looking for matching
    `''''

    /tmp/tmp20fj7yx7.sh: line 25: syntax error: unexpected end of file

    '
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  local raw=$1\n  local array=($raw)\n\
    \  local output=()\n  for i in \"${array[@]}\"; do\n    local count=0\n    for\
    \ ((i=0; i<${#i}; i++)); do\n      if [[ ${i:$i:1} == \"(\" ]]; then\n       \
    \ ((count++))\n      elif [[ ${i:$i:1} == \")\" ]]; then\n        ((count--))\n\
    \      fi\n    done\n    output+=(\"\\\"$count\\\"\")\n  done\n  echo \"[${output[@]}]\"\
    \n}\n\ncandidate() {\n    parse_nested_parens \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"(()()) ((())) () ((())()())\") = \"2 3 1 3\" ]]\n  \
    \  [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[ $(candidate\
    \ \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  echo $1 | python3 -c \"\nimport json\n\
    import sys\nfrom collections import defaultdict\n\ndef nested_parens(s):\n  depth\
    \ = defaultdict(int)\n  left, right = 0, 0\n  for c in s:\n    if c == '(':\n\
    \      left += 1\n    elif c == ')':\n      right += 1\n    if left == right:\n\
    \      depth[right] += 1\n  return max(depth)\n\nfor s in sys.stdin.readline().split():\n\
    \  print(json.dumps(nested_parens(s)), end=' ')\n  \"\n}\n\ncandidate() {\n  \
    \  parse_nested_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    (()()) ((())) () ((())()())\") = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (())\
    \ ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[ $(candidate \"(()(())((())))\")\
    \ = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  # Iterate over each of the groups for\
    \ nested parentheses\n  for group in $1; do\n    # Initiliase the max_level and\
    \ current_level to 0\n    max_level=0\n    current_level=0\n    # Iterate over\
    \ each of the character in the group\n    for ((i=0; i<${#group}; i++)); do\n\
    \      # If current character is (, increment the current_level by 1\n      if\
    \ [[ ${group:$i:1} == \"(\" ]]; then\n        ((current_level++))\n      # If\
    \ current character is ), decrement the current_level by 1\n      elif [[ ${group:$i:1}\
    \ == \")\" ]]; then\n        ((current_level--))\n      fi\n      # Update the\
    \ max_level if the current_level is greater than max_level\n      if [[ $current_level\
    \ -gt $max_level ]]; then\n        max_level=$current_level\n      fi\n    done\n\
    \    # Output the max_level\n    echo $max_level\n  done\n}\n\ncandidate() {\n\
    \    parse_nested_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"(()()) ((())) () ((())()())\") = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (())\
    \ ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[ $(candidate \"(()(())((())))\")\
    \ = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n    local results\n\n    while [ -n \"\
    $1\" ]; do\n        local paren_count=0\n        local max_nesting=0\n       \
    \ local group=$1\n        shift\n\n        if [[ $group =~ \\( ]]; then\n    \
    \        for ((i=0; i<${#group}; i++)); do\n                if [[ ${group:$i:1}\
    \ == \"(\" ]]; then\n                    paren_count=$((paren_count + 1))\n  \
    \                  if [ $paren_count -gt $max_nesting ]; then\n              \
    \          max_nesting=$paren_count\n                    fi\n                elif\
    \ [[ ${group:$i:1} == \")\" ]]; then\n                    paren_count=$((paren_count\
    \ - 1))\n                fi\n            done\n        fi\n\n        results+=(\"\
    \\\"$max_nesting\\\"\")\n    done\n\n    echo \"[${results[@]}]\"\n}\n\ncandidate()\
    \ {\n    parse_nested_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"(()()) ((())) () ((())()())\") = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (())\
    \ ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[ $(candidate \"(()(())((())))\")\
    \ = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  local par_string=$1\n  local max_level=0\n\
    \  local cur_level=0\n  local out_str=\"\"\n  while [ -n \"$par_string\" ]; do\n\
    \    local c=${par_string:0:1}\n    if [ \"$c\" == \"(\" ]; then\n      ((cur_level++))\n\
    \      if [ $cur_level -gt $max_level ]; then\n        max_level=$cur_level\n\
    \      fi\n    elif [ \"$c\" == \")\" ]; then\n      ((cur_level--))\n    fi\n\
    \    par_string=${par_string:1}\n  done\n  if [ $max_level -gt 0 ]; then\n   \
    \ out_str=\"\\\"$max_level\\\"\"\n  else\n    out_str=\"\\\"1\\\"\"\n  fi\n  echo\
    \ \"[$out_str]\"\n}\n\ncandidate() {\n    parse_nested_parens \"$@\"\n}\n\nset\
    \ -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\") = \"2\
    \ 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3 4\" ]]\n\
    \    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n    level=0\n    while read -r -n 1 char;\
    \ do\n        if [[ $char == \"(\" ]]; then\n            level=$(( level + 1 ))\n\
    \        elif [[ $char == \")\" ]]; then\n            if [[ $level -gt 0 ]]; then\n\
    \                level=$(( level - 1 ))\n            else\n                # the\
    \ number of closing parentheses exceeds the number of opening ones\n         \
    \       echo '\"0\"'\n                return\n            fi\n        fi\n   \
    \ done <<< \"$1\"\n    if [[ $level -gt 0 ]]; then\n        # the number of opening\
    \ parentheses exceeds the number of closing ones\n        echo '\"0\"'\n    else\n\
    \        echo '\"'$level'\"'\n    fi\n}\n\ncandidate() {\n    parse_nested_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\"\
    ) = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3\
    \ 4\" ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n    local paren_groups=\"$1\"\n    local\
    \ max_levels=''\n    for paren_group in $paren_groups; do\n        max_levels+=\"\
    \\\"$(parse_max_nested_parens \"$paren_group\")\\\" \"\n    done\n    echo \"\
    $max_levels\"\n}\n\ncandidate() {\n    parse_nested_parens \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\") = \"2 3 1 3\"\
    \ ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[\
    \ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmpbjsc48nz.sh: line 13: parse_max_nested_parens: command not found

    /tmp/tmpbjsc48nz.sh: line 13: parse_max_nested_parens: command not found

    /tmp/tmpbjsc48nz.sh: line 13: parse_max_nested_parens: command not found

    /tmp/tmpbjsc48nz.sh: line 13: parse_max_nested_parens: command not found

    '
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n    local max=0\n    local curr=0\n  \
    \  local out=()\n    for ((i=0; i<${#1}; i++)); do\n        if [[ ${1:$i:1} ==\
    \ \"(\" ]]; then\n            curr=$((curr+1))\n            if (( curr > max ));\
    \ then\n                max=$curr\n            fi\n        elif [[ ${1:$i:1} ==\
    \ \")\" ]]; then\n            curr=$((curr-1))\n        fi\n    done\n    for\
    \ ((i=0; i<${#1}; i++)); do\n        if [[ ${1:$i:1} == \" \" ]]; then\n     \
    \       out+=(\"\\\"$max\\\"\")\n            max=0\n            curr=0\n     \
    \   elif [[ ${1:$i:1} == \"(\" ]]; then\n            curr=$((curr+1))\n      \
    \      if (( curr > max )); then\n                max=$curr\n            fi\n\
    \        elif [[ ${1:$i:1} == \")\" ]]; then\n            curr=$((curr-1))\n \
    \       fi\n    done\n    out+=(\"\\\"$max\\\"\")\n    echo ${out[@]}\n}\n\ncandidate()\
    \ {\n    parse_nested_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"(()()) ((())) () ((())()())\") = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (())\
    \ ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[ $(candidate \"(()(())((())))\")\
    \ = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n    echo -n \"${1[@]}\" | sed 's/ /\\\
    n/g' | \\\n        xargs -I_ bash -c \"echo -n '\\\"'; echo -n _ | sed 's/[()]/&\\\
    n/g' | \\\n        xargs -I__ echo -n __ | grep -o ')' | wc -l | xargs -I_ echo\
    \ -n _ | awk '{printf \\\"%d\\\", $1}'; echo -n '\\\"'; echo -n ' ';\"\n}\n\n\
    candidate() {\n    parse_nested_parens \"$@\"\n}\n\nset -e\nrun_test() {\n   \
    \ [[ $(candidate \"(()()) ((())) () ((())()())\") = \"2 3 1 3\" ]]\n    [[ $(candidate\
    \ \"() (()) ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[ $(candidate \"(()(())((())))\"\
    ) = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmphvkqekdp.sh: line 10: ${1[@]}: bad substitution

    '
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  # Find the positions of all the parentheses.\n\
    \  # Characters '(' and ')' have ASCII codes 40 and 41, so we can filter them\
    \ out using tr.\n  # We treat () and ()() as equivalent cases.\n  # This is true\
    \ because any characters outside the pairs of parentheses, in this case the space,\
    \ are discarded.\n  # The number of open and closed parentheses in a group must\
    \ be the same.\n  # >>> $(tr -dc '()' <<< \"() (())\" | wc -c)\n  # 6\n  # >>>\
    \ $(tr -dc '()' <<< \"()\" | wc -c)\n  # 2\n  # >>> $(tr -dc '()' <<< \"() (())\"\
    \ | wc -c)\n  # 6\n  local positions=\"$(tr -dc '()' <<< \"$1\" | fold -w1 | awk\
    \ '{print length}')\"\n  # Trim the extra whitespace in the output.\n  local trimmed_positions=\"\
    $(tr -d ' ' <<< \"$positions\")\"\n  # Output the maximum nest level of every\
    \ group.\n  # In an array of integers, filter out the subarray that ends with\
    \ 40.\n  # These are the open parentheses.\n  # Find the maximum length of the\
    \ filtered subarray.\n  # Add 1 to the maximum length.\n  echo \"$trimmed_positions\"\
    \ | sed 's/\\([^ ]* [^ ]*\\)/[\\1]/g' | jq 'map(. | .[] | .[0:last_index(40)])\
    \ | map(length) | max + 1'\n}\n\ncandidate() {\n    parse_nested_parens \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\"\
    ) = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3\
    \ 4\" ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmpvaxv774l.sh: line 29: jq: command not found

    '
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  local parens=$1\n  local group\n  for\
    \ group in $parens; do\n    echo -n '\"'\n    local depth=0\n    local max_depth=0\n\
    \    local i\n    for ((i=0; i<${#group}; i++)); do\n      if [[ ${group:$i:1}\
    \ == \"(\" ]]; then\n        ((depth++))\n        if ((depth > max_depth)); then\n\
    \          max_depth=$depth\n        fi\n      elif [[ ${group:$i:1} == \")\"\
    \ ]]; then\n        ((depth--))\n      fi\n    done\n    echo -n $max_depth\n\
    \    echo -n '\" '\n  done\n}\n\ncandidate() {\n    parse_nested_parens \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\"\
    ) = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3\
    \ 4\" ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n    local -n __nested_parens=$1\n    local\
    \ __result\n    local __num_levels\n    local __num_chars\n    local __str_parens\n\
    \n    __result=()\n    while [[ \"$__nested_parens\" =~ \\(([^()]*)\\) ]]; do\n\
    \        __str_parens=${BASH_REMATCH[1]}\n        __num_chars=${#__str_parens}\n\
    \        __num_levels=0\n        for ((i=0; i<$__num_chars; i++)); do\n      \
    \      case ${__str_parens:i:1} in\n                \\( )\n                  \
    \  (( __num_levels++ ))\n                    ;;\n                \\) )\n     \
    \               (( __num_levels-- ))\n                    ;;\n            esac\n\
    \        done\n        __result+=(\"$__num_levels\")\n        __nested_parens=${__nested_parens#*\\\
    )}\n    done\n    echo \"${__result[@]}\"\n}\n\ncandidate() {\n    parse_nested_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\"\
    ) = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3\
    \ 4\" ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmpvubp52gk.sh: line 10: local: `(()()) ((())) () ((())()())'': invalid
    variable name for name reference

    '
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  local result=()\n  local paren_str=\"\
    $1\"\n  for paren in ${paren_str[@]}; do\n    result+=($(parse_nested_paren \"\
    $paren\"))\n  done\n  echo ${result[@]}\n}\n\ncandidate() {\n    parse_nested_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\"\
    ) = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3\
    \ 4\" ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmpldnwyg44.sh: line 13: parse_nested_paren: command not found

    /tmp/tmpldnwyg44.sh: line 13: parse_nested_paren: command not found

    /tmp/tmpldnwyg44.sh: line 13: parse_nested_paren: command not found

    /tmp/tmpldnwyg44.sh: line 13: parse_nested_paren: command not found

    '
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n    # Strip all spaces\n    local arg=${1//[[:space:]]/}\n\
    \    local count=0\n    local max_count=0\n    local ret=()\n    # Iterate over\
    \ each char\n    for ((i=0; i<${#arg}; i++)); do\n        if [[ ${arg:$i:1} ==\
    \ \"(\" ]]; then\n            (( count++ ))\n            (( max_count = count\
    \ > max_count ? count : max_count ))\n        elif [[ ${arg:$i:1} == \")\" ]];\
    \ then\n            (( count-- ))\n        fi\n        # If we find a space, reset\
    \ the counters and add the max count to the return array\n        if [[ ${arg:$i:1}\
    \ == \" \" ]]; then\n            ret+=(\"$max_count\")\n            count=0\n\
    \            max_count=0\n        fi\n    done\n    ret+=(\"$max_count\")\n  \
    \  # Write the output in JSON format\n    echo -e \"[$( IFS=$','; echo \"${ret[*]}\"\
    \ )]\\n\"\n}\n\ncandidate() {\n    parse_nested_parens \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"(()()) ((())) () ((())()())\") = \"2 3 1 3\" ]]\n  \
    \  [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[ $(candidate\
    \ \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  echo $1 |\\\n  # Split input into groups\n\
    \  tr \" \" \"\\n\" |\\\n  # Write each group to a file\n  awk '{print > $1\"\
    _file\"}'\n  for file in *.file; do\n    # Calculate depth of each group\n   \
    \ depth=$(cat $file | awk '{print gsub(/\\(/,\"&\")-gsub(/\\)/,\"&\")}')\n   \
    \ # Output depth for each group\n    echo \"\\\"$depth\\\"\"\n  done\n  # Delete\
    \ the file for each group\n  rm -f *.file\n}\n\ncandidate() {\n    parse_nested_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\"\
    ) = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3\
    \ 4\" ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: 'cat: ''*.file'': No such file or directory

    '
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n    local string=$1\n    local result=\"\
    \"\n    for string in $string; do\n        local regex=\"[^()]*\" # start with\
    \ a non-parenthesis\n        # Then match any number of ( followed by the same\
    \ number of )\n        local regex+=\"(\\(($regex)\\)$regex)*\"\n        # If\
    \ the string matches the above regex, then\n        # $BASH_REMATCH[0] will be\
    \ the entire string,\n        # $BASH_REMATCH[1] will be the first (...),\n  \
    \      # $BASH_REMATCH[2] will be the deepest level of parentheses,\n        #\
    \ and so on.\n        [[ $string =~ $regex ]] && result+=\" \\\"${#BASH_REMATCH[@]}\\\
    \"\"\n    done\n    echo \"[$result]\"\n}\n\ncandidate() {\n    parse_nested_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\"\
    ) = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3\
    \ 4\" ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  len=${#1}\n  str=${1}\n  j=0\n  for\
    \ ((i=0; i<$len; i++)); do\n    if [[ ${str:$i:1} == \"(\" ]]; then\n      nested_parens[$j]=$((${nested_parens[$j]}\
    \ + 1))\n    elif [[ ${str:$i:1} == \")\" ]]; then\n      nested_parens[$j]=$((${nested_parens[$j]}\
    \ - 1))\n    elif [[ ${str:$i:1} == \" \" ]]; then\n      ((j++))\n    fi\n  done\n\
    \  # nested_parens is an array of deepest levels of nesting in the string\n  echo\
    \ \"${nested_parens[@]}\"\n}\n\ncandidate() {\n    parse_nested_parens \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\"\
    ) = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3\
    \ 4\" ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n    # Here `awk '{print $1}'` is just\
    \ for testing purpose. For real problem, there is no input to awk.\n    echo \"\
    $1\" | awk '{print $1}' | sed 's/\\(/\\n/g' | sed '/^$/d' | sed 's/)/\\n/g' |\
    \ sed '/^$/d' | awk '\n        BEGIN {\n            depth = 0;\n            max_depth\
    \ = 0;\n        }\n        {\n            if ($0 == \"(\") {\n               \
    \ depth += 1;\n                if (depth > max_depth) {\n                    max_depth\
    \ = depth;\n                }\n            } else {\n                depth -=\
    \ 1;\n            }\n        }\n        END {\n            printf(\"%d\\n\", max_depth);\n\
    \        }\n    '\n}\n\ncandidate() {\n    parse_nested_parens \"$@\"\n}\n\nset\
    \ -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\") = \"2\
    \ 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3 4\" ]]\n\
    \    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: 'sed: -e expression #1, char 9: Unmatched ( or \(

    '
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  local parens_string=\"$1\"\n  local\
    \ parens_list=($parens_string)\n  local output=\"\"\n  for parens in \"${parens_list[@]}\"\
    ; do\n    max_nesting=$(echo \"$parens\" | sed -e 's/[^()]//g' | tr -d '\\n' |\
    \ tr '()' '+-' | tr -d '\\n' | bc)\n    output=\"$output \\\"$max_nesting\\\"\"\
    \n  done\n  echo \"$output\"\n}\n\ncandidate() {\n    parse_nested_parens \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\"\
    ) = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3\
    \ 4\" ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '(standard_in) 1: syntax error

    (standard_in) 1: syntax error

    (standard_in) 1: syntax error

    (standard_in) 1: syntax error

    '
  stdout: ''
  timestamp: 1660022608
- exit_code: 2
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n    # The max_level for each set of parentheses\n\
    \    max_level=0\n    # The current level for each set of parentheses\n    current_level=0\n\
    \    # An array to store the max_level for each set of parentheses\n    max_levels=()\n\
    \    # Check if $1 is a string\n    if [ \"$#\" -ne 1 ]; then\n        echo \"\
    The number of parameters is invalid. Call this function with 1 parameter.\"\n\
    \        return 1\n    fi\n    # Check if $1 is a string\n    if [[ \"$1\" !=\
    \ *\"(\"* || \"$1\" != *\")\"* ]]; then\n        echo \"The input string is invalid.\
    \ It must contain at least one pair of parentheses.\"\n        return 1\n    fi\n\
    \    # Iterate over each character in the string\n    while [ ${#1} -gt 0 ]; do\n\
    \        # Get the first character of the string\n        char=${1:0:1}\n    \
    \    # Cut the first character off the string\n        string=${1:1}\n       \
    \ # If current_level is 0, we're outside of a set of parentheses\n        if [\
    \ $current_level -eq 0 ]; then\n            # If the char is (, we're entering\
    \ a set of parentheses\n            if [ \"$char\" == \"(\" ]; then\n        \
    \        current_level=1\n            fi\n        # If current_level is not 0,\
    \ we're inside a set of parentheses\n        else\n            # If the char is\
    \ (, increment the current_level\n            if [ \"$char\" == \"(\" ]; then\n\
    \                ((current_level++))\n            # If the char is ), decrement\
    \ the current_level\n            elif [ \"$char\" == \")\" ]; then\n         \
    \       ((current_level--))\n                # If current_level becomes 0, we've\
    \ reached the end of a set of parentheses\n                if [ $current_level\
    \ -eq 0 ]; then\n                    # If the max_level is higher than the current\
    \ max_level of the set of parentheses, update the max_level\n                \
    \    if [ $max_level -gt $current_level ]; then\n                        max_level=$current_level\n\
    \                    fi\n                    # Append the max_level to the array\
    \ of max_levels\n                    max_levels+=($max_level)\n              \
    \      # Reset the\n}\n\ncandidate() {\n    parse_nested_parens \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\") = \"\
    2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3 4\" ]]\n\
    \    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpon56h1pl.sh: line 55: syntax error near unexpected token `}''

    /tmp/tmpon56h1pl.sh: line 55: `}''

    '
  stdout: ''
  timestamp: 1660022608
- exit_code: 2
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  input=$1\n  echo $input | awk '{\n \
    \ max_count = 0;\n  res = \"\";\n  while ($0 ~ /[()]/) {\n    if (substr($0, 1,\
    \ 1) == \"(\") {\n      count++;\n      if (count > max_count) {\n        max_count\
    \ = count;\n      }\n    } else {\n      count--;\n    }\n    $0 = substr($0,\
    \ 2);\n  }\n  printf \"\\\"%d\\\" \", max_count;\n}\n\ncandidate() {\n    parse_nested_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\"\
    ) = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3\
    \ 4\" ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpgfto3ugq.sh: line 11: unexpected EOF while looking for matching
    `''''

    /tmp/tmpgfto3ugq.sh: line 40: syntax error: unexpected end of file

    '
  stdout: ''
  timestamp: 1660022608
- exit_code: -1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  groups=`echo \"$1\" | tr \" \" \"\\\
    n\"`\n  for group in $groups; do\n    deepest_level=`echo $group | awk '\n   \
    \   BEGIN {\n        max_depth = 0;\n      }\n      $0 ~ /^\\(/ {\n        s =\
    \ index($0, \"(\");\n        e = index($0, \")\");\n        while (s > 0) {\n\
    \          depth = s;\n          if (e < s) {\n            depth = e;\n      \
    \    }\n          if (depth > max_depth) {\n            max_depth = depth;\n \
    \         }\n          s = index(substr($0, s + 1), \"(\");\n          e = index(substr($0,\
    \ e + 1), \")\");\n        }\n      }\n      END {\n        print max_depth;\n\
    \      }\n    '`\n    echo \"\\\"$deepest_level\\\"\"\n  done\n}\n\ncandidate()\
    \ {\n    parse_nested_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"(()()) ((())) () ((())()())\") = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (())\
    \ ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[ $(candidate \"(()(())((())))\")\
    \ = \"4\" ]]\n}\n\nrun_test"
  status: Timeout
  stderr: <_io.TextIOWrapper name=34 encoding='utf-8'>
  stdout: <_io.TextIOWrapper name=28 encoding='utf-8'>
  timestamp: 1660022613
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n    echo \"$1\" | sed 's/.*\\(([^()]*)\\\
    )/\\1/g' | sed 's/\\([^()]*\\).*/\\1/g' | sed 's/\\(.*\\)/\"\\1\"/g'\n}\n\ncandidate()\
    \ {\n    parse_nested_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"(()()) ((())) () ((())()())\") = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (())\
    \ ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[ $(candidate \"(()(())((())))\")\
    \ = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  local str=\"$1\"\n  # Replace all non\
    \ opening/closing parentheses with spaces\n  str=${str//[^()]/ }\n  local depth\n\
    \  echo $str | while read -r -n1 c; do\n    if [[ $c == \"(\" ]]; then\n     \
    \ ((depth++))\n    elif [[ $c == \")\" ]]; then\n      ((depth--))\n    elif [[\
    \ $c == \" \" ]]; then\n      # Output the last nesting level\n      echo \"\\\
    \"$depth\\\"\"\n      depth=0\n    fi\n  done\n}\n\ncandidate() {\n    parse_nested_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\"\
    ) = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3\
    \ 4\" ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  echo $1 | sed 's/(([^)]))/\\1 /g' |\
    \ sed 's/([^)])([^)]*)/\\1 \\2/g' | sed 's/[()]//g' | awk '{split($0, a, \" \"\
    ); for (i in a) print length(a[i])}' | xargs echo\n}\n\ncandidate() {\n    parse_nested_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\"\
    ) = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3\
    \ 4\" ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: 'sed: -e expression #1, char 23: invalid reference \2 on `s'' command''s
    RHS

    sed: -e expression #1, char 16: invalid reference \1 on `s'' command''s RHS

    '
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n    local s=$1\n    local i level=0 max_level\n\
    \    while true; do\n        if [[ \"${s:$i:1}\" == \"(\" ]]; then\n         \
    \   ((level++))\n            ((max_level < level)) && max_level=$level\n     \
    \   elif [[ \"${s:$i:1}\" == \")\" ]]; then\n            ((level--))\n       \
    \ elif [[ \"${s:$i:1}\" == \" \" ]]; then\n            echo -n \"\\\"$max_level\\\
    \" \"\n            max_level=0\n        else\n            echo \"ERROR: unexpected\
    \ char ${s:$i:1}\"\n            exit 1\n        fi\n        ((i++))\n        if\
    \ [[ \"$i\" -eq \"${#s}\" ]]; then\n            echo -n \"\\\"$max_level\\\"\"\
    \n            break\n        fi\n    done\n}\n\ncandidate() {\n    parse_nested_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\"\
    ) = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3\
    \ 4\" ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 2
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  local -a stack\n  local -i current_length=0\n\
    \  local -i max_length=0\n  local -i start_max=0\n  local -i end_max=0\n  local\
    \ -i counter=0\n  local -i i=0\n  local -i len=$((${#1}-1))\n  local -i start_paren=0\n\
    \  local -i close_paren=0\n  local -i start_paren_i=0\n  local -i close_paren_i=0\n\
    \  local -i start_paren_max=0\n  local -i close_paren_max=0\n  local -i start_paren_max_i=0\n\
    \  local -i close_paren_max_i=0\n  local -i start_paren_max_counter=0\n  local\
    \ -i close_paren_max_counter=0\n  local -i start_paren_counter=0\n  local -i close_paren_counter=0\n\
    \  local -i stack_len=0\n  local -i start_paren_index=0\n  local -i close_paren_index=0\n\
    \  local -i start_index=0\n  local -i close_index=0\n  local char=\"\"\n  local\
    \ -a range_list=()\n  local -a max_range_list=()\n  local output=\"\"\n  local\
    \ output_max=\"\"\n  local start=\"\"\n  local end=\"\"\n  local max_start=\"\"\
    \n  local max_end=\"\"\n  local c=\"\"\n  local -a output_list=()\n  local -a\
    \ max_output_list=()\n  local -a temp_output_list=()\n  local -a temp_max_output_list=()\n\
    \  local -a stack_item=()\n  for ((i=0; i<len; i++)); do\n    char=\"${1:i:1}\"\
    \n    # If we encounter a left parenthesis, push the current index to the stack.\n\
    \    if [[ \"${char}\" == \"(\" ]]; then\n      stack+=([i]=$i)\n      stack_len=${#stack[@]}\n\
    \      ((stack_len=stack_len-1))\n      if [[ \"${stack_len}\"\n}\n\ncandidate()\
    \ {\n    parse_nested_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"(()()) ((())) () ((())()())\") = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (())\
    \ ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[ $(candidate \"(()(())((())))\")\
    \ = \"4\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp8dnqlee3.sh: line 57: unexpected token `newline'', conditional
    binary operator expected

    /tmp/tmp8dnqlee3.sh: line 57: syntax error near `"${stack_len}"''

    /tmp/tmp8dnqlee3.sh: line 57: `      if [[ "${stack_len}"''

    '
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  local echo_this\n  local max_nested_parens\n\
    \  for group in $(sed 's/^(.*)$/\\1/' <<< $1 | sed 's/ /\\n/g'); do\n    max_nested_parens=0\n\
    \    for ((i=0; i<${#group}; i++)); do\n      if [[ ${group:$i:1} == \"(\" ]];\
    \ then\n        (( max_nested_parens++ ))\n      elif [[ ${group:$i:1} == \")\"\
    \ ]]; then\n        (( max_nested_parens-- ))\n      fi\n    done\n    echo_this+='\"\
    '\"$max_nested_parens\"'\" '\n  done\n  echo $(sed 's/ $//' <<< $echo_this)\n\
    }\n\ncandidate() {\n    parse_nested_parens \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"(()()) ((())) () ((())()())\") = \"2 3 1 3\" ]]\n    [[\
    \ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[ $(candidate\
    \ \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: 'sed: -e expression #1, char 12: invalid reference \1 on `s'' command''s
    RHS

    '
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n    local result=()\n    local out\n\n\
    \    while [ -n \"$1\" ]; do\n        out=$(echo \"$1\" | sed -r 's/^([^()]*)([()]+)(.*)$/\\\
    2/')\n        if [ -z \"$out\" ]; then\n            break\n        fi\n      \
    \  if [ -n \"$out\" ]; then\n            local s=\"${out#*(}\"\n            local\
    \ d=\"${out##*(}\"\n            local max=$(\n                if [ -n \"$s\" ]\
    \ && [ -n \"$d\" ]; then\n                    echo \"$s\" | sed -r 's/[^(]//g'\
    \ | wc -c\n                else\n                    echo \"0\"\n            \
    \    fi\n            )\n            result+=(\"\\\"$max\\\"\")\n        fi\n \
    \       shift\n    done\n\n    echo \"${result[@]}\"\n}\n\ncandidate() {\n   \
    \ parse_nested_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    (()()) ((())) () ((())()())\") = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (())\
    \ ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[ $(candidate \"(()(())((())))\")\
    \ = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  local groups=($1)\n  local depths\n\
    \  for group in \"${groups[@]}\"; do\n    local level=0 max_level=0\n    for char\
    \ in $(tr -d -c \"()\" <<< $group); do\n      if [[ $char == \"(\" ]]; then\n\
    \        level=$((level+1))\n      else\n        if [[ $level -gt $max_level ]];\
    \ then\n          max_level=$level\n        fi\n        level=$((level-1))\n \
    \     fi\n    done\n    depths+=\"$max_level \"\n  done\n  echo $(tr -d \"\\n\"\
    \ <<< $depths)\n}\n\ncandidate() {\n    parse_nested_parens \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\") = \"2 3 1 3\"\
    \ ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[\
    \ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  local -n __tmp_pnp_arr=\"$1\"\n  __tmp_pnp_arr=()\n\
    \  local input=$2\n  local nested_parens_regex='\\(([^()]*|(?R))*\\)'\n  while\
    \ [[ $input =~ $nested_parens_regex ]]; do\n    __tmp_pnp_arr+=(\"$(bc <<< $((${#BASH_REMATCH[0]}-2))/2)\"\
    )\n    input=${input//${BASH_REMATCH[0]}/}\n  done\n}\n\ncandidate() {\n    parse_nested_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\"\
    ) = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3\
    \ 4\" ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmp6uqwgf9d.sh: line 10: local: `(()()) ((())) () ((())()())'': invalid
    variable name for name reference

    '
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  local input=\"$1\"\n  local input_arr=()\n\
    \n  while IFS= read -r line; do\n    input_arr+=(\"$line\")\n  done <<< \"$input\"\
    \n\n  for i in \"${input_arr[@]}\"; do\n    local result=\"$(awk -v str=\"$i\"\
    \ 'BEGIN {\n      split(str, chars, \"\")\n      i = 0\n      depth = 0\n    \
    \  max_depth = 0\n      while (i < length(chars)) {\n        if (chars[i] == \"\
    (\") {\n          depth++\n          if (depth > max_depth) {\n            max_depth\
    \ = depth\n          }\n        } else if (chars[i] == \")\") {\n          depth--\n\
    \        }\n        i++\n      }\n      print max_depth\n    }')\"\n    results+=($result)\n\
    \  done\n\n  echo \"${results[@]}\"\n}\n\ncandidate() {\n    parse_nested_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\"\
    ) = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3\
    \ 4\" ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  # break the string into list of groups\n\
    \  local groups=($(echo $1 | tr ' ' '\\n'))\n  local max_nested_parens_list=()\n\
    \  for group in \"${groups[@]}\"; do\n    local max_nested_parens=\"$(parse_nested_parens_internal\
    \ \"$group\")\"\n    max_nested_parens_list+=(\"$max_nested_parens\")\n  done\n\
    \  echo \"${max_nested_parens_list[@]}\"\n}\n\ncandidate() {\n    parse_nested_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\"\
    ) = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3\
    \ 4\" ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmp04fydsua.sh: line 14: parse_nested_parens_internal: command not
    found

    /tmp/tmp04fydsua.sh: line 14: parse_nested_parens_internal: command not found

    /tmp/tmp04fydsua.sh: line 14: parse_nested_parens_internal: command not found

    /tmp/tmp04fydsua.sh: line 14: parse_nested_parens_internal: command not found

    '
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n    local arg=$1\n    local seq=$(echo\
    \ ${arg} | sed -E 's/^\\[|\\]$//g' | sed -E 's/\\(|\\)/\"\\1\"/g')\n    local\
    \ -a level=($(echo ${seq} | sed -E 's/[^()\"]+//g' | tr -d '\\n'))\n    local\
    \ -a stack=()\n    local seq_len=${#level[@]}\n    local i=0\n    local counter=0\n\
    \    local max_counter=0\n    local match\n    local output=()\n\n    while [[\
    \ ${i} -lt ${seq_len} ]]; do\n        match=${level[$i]}\n        if [[ ${match}\
    \ == \"(\" ]]; then\n            counter=$((counter + 1))\n            if [[ ${counter}\
    \ -gt ${max_counter} ]]; then\n                max_counter=${counter}\n      \
    \      fi\n        elif [[ ${match} == \")\" ]]; then\n            counter=$((counter\
    \ - 1))\n        fi\n        i=$((i + 1))\n    done\n    echo ${max_counter}\n\
    }\n\ncandidate() {\n    parse_nested_parens \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"(()()) ((())) () ((())()())\") = \"2 3 1 3\" ]]\n    [[\
    \ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[ $(candidate\
    \ \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: 'sed: -e expression #1, char 14: invalid reference \1 on `s'' command''s
    RHS

    '
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  echo $1 | sed 's/)/\\n/g' | sed 's/^(.*)$/\"\
    \\1\"/g' | sed 's/\\(\\)//g' | sed 's/^[^\"]*\"\\([^\"]*\\)\".*$/\\1/g' | sed\
    \ 's/^[^\"]*$/\"&\"/g' | sed 's/(/\\n(/g' | sed 's/\\(.*\\)(\\(.*\\))/\\1\\2/g'\
    \ | grep -o \"(\" | wc -l | sed 's/ //g' | sed 's/^[^\"]*\"\\([^\"]*\\)\".*$/\\\
    1/g' | sed 's/^[^\"]*$/\"&\"/g'\n}\n\ncandidate() {\n    parse_nested_parens \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\"\
    ) = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3\
    \ 4\" ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: 'sed: -e expression #1, char 15: invalid reference \1 on `s'' command''s
    RHS

    '
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n    echo $1 | sed -e 's/^ //g' | sed -e\
    \ 's/ /\\n/g' | sed -e 's/\\(/\\n(\\n/g' | sed -e 's/\\)/\\n)\\n/g' | grep -v\
    \ '^\\s*$' | awk '\n        BEGIN { level = 0; }\n        /\\(/ { level += 1;\
    \ if (level > maxlevel) { maxlevel = level; } }\n        /\\)/ { level -= 1; }\n\
    \        END { print '\"'\"'\"maxlevel\"'\"'\"'; }\n    '\n}\n\ncandidate() {\n\
    \    parse_nested_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"(()()) ((())) () ((())()())\") = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (())\
    \ ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[ $(candidate \"(()(())((())))\")\
    \ = \"4\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: 'sed: -e expression #1, char 12: Unmatched ( or \(

    sed: -e expression #1, char 12: Unmatched ) or \)

    awk: cmd. line:5:         END { print ''"maxlevel"''; }

    awk: cmd. line:5:                     ^ invalid char '''''' in expression

    awk: cmd. line:5:         END { print ''"maxlevel"''; }

    awk: cmd. line:5:                     ^ syntax error

    '
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n    local parens_str=\"$1\"\n    local\
    \ parens_arr=( $parens_str )\n    local counter=0\n    local max_counter=0\n \
    \   local ans=()\n    for item in \"${parens_arr[@]}\"; do\n        local max_counter=0\n\
    \        local counter=0\n        for (( i=0; i<${#item}; i++ )); do\n       \
    \     if [[ \"${item:$i:1}\" == \"(\" ]]; then\n                let counter+=1\n\
    \                if (( counter > max_counter )); then\n                    max_counter=$counter\n\
    \                fi\n            else\n                let counter-=1\n      \
    \      fi\n        done\n        ans+=(\"$max_counter\")\n    done\n    local\
    \ out=$(printf '%s\\n' \"${ans[@]}\" | sort -n | sed 's/^/\"/;s/$/\"/')\n    echo\
    \ \"[$out]\"\n}\n\ncandidate() {\n    parse_nested_parens \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\") = \"2 3 1 3\"\
    \ ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[\
    \ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  echo \"$1\" | grep -oP '(?<=\\()(?<=^|\\\
    W)\\((\\(([^()]*|\\([^()]*\\))*\\))*(?=\\)|\\W)' | cut -d '(' -f2 | cut -d ')'\
    \ -f1 | awk '{print length($0)}' | python -c 'import sys; print([str(max(map(len,\
    \ sys.stdin.read().split())))])'\n}\n\ncandidate() {\n    parse_nested_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\"\
    ) = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3\
    \ 4\" ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n    echo $1 | sed -E 's/[()]+/\\n&\\n/g'\
    \ |\n    awk '{\n        if(match($0, \"^[()]+$\")){\n            depth = 0\n\
    \            for(i=1; i<=length($0); i++){\n                if(substr($0, i, 1)\
    \ == \"(\"){\n                    depth++\n                }else{\n          \
    \          print depth\n                    depth--\n                }\n     \
    \       }\n        }\n    }'\n}\n\ncandidate() {\n    parse_nested_parens \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\"\
    ) = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3\
    \ 4\" ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 0
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  declare -a paren_depth\n\n  # get rid\
    \ of whitespace\n  local input=$(echo \"$1\" | sed -e 's/[ ]//g')\n\n  local str=\"\
    \"\n  local i=0\n  local j=0\n  local max_depth=0\n  local depth=0\n  local paren_start=0\n\
    \  local paren_end=0\n  local tmp_str=\"\"\n\n  # loop through the input string\n\
    \  while [ \"$i\" -lt \"${#input}\" ]; do\n    # get the char\n    str=${input:$i:1}\n\
    \n    # handle the opening and closing parentheses\n    if [ \"$str\" == \"(\"\
    \ ]; then\n      # check for opening parentheses\n      if [ \"$j\" -eq 0 ]; then\n\
    \        paren_start=$i\n      fi\n      # increment the depth\n      let \"depth\
    \ = $depth + 1\"\n      # update the max depth\n      if [ \"$depth\" -gt \"$max_depth\"\
    \ ]; then\n        max_depth=$depth\n      fi\n    elif [ \"$str\" == \")\" ];\
    \ then\n      # handle for closing parentheses\n      # decrement the depth\n\
    \      let \"depth = $depth - 1\"\n      # check for ending parentheses\n    \
    \  if [ \"$depth\" -eq 0 ]; then\n        paren_end=$i\n        # print max depth\n\
    \        paren_depth[$j]=$max_depth\n        let \"j = $j + 1\"\n        # re-initialize\n\
    \        max_depth=0\n      fi\n    fi\n    let \"i = $i + 1\"\n  done\n\n  echo\
    \ \"${paren_depth[@]}\"\n}\n\ncandidate() {\n    parse_nested_parens \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\"\
    ) = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3\
    \ 4\" ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n    echo \"[$(echo \"$1\" | tr \" \" \"\
    \\n\" | awk '{print match($0, \"[(][)]+[)]\") / 2}')]\"\n}\n\ncandidate() {\n\
    \    parse_nested_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"(()()) ((())) () ((())()())\") = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (())\
    \ ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[ $(candidate \"(()(())((())))\")\
    \ = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  # initialize the starting level of nesting\
    \ to zero\n  local level=0\n  # loop through each character of the input string\n\
    \  for (( i=0; i<${#1}; i++ )); do\n    # if the character is a left parenthesis,\
    \ increase the level of nesting\n    if [[ ${1:$i:1} == \"(\" ]]; then\n     \
    \ (( level++ ))\n    # if the character is a right parenthesis and we are already\
    \ at the maximum nesting level,\n    # output the maximum level of nesting, reset\
    \ level to zero, and keep looping\n    elif [[ ${1:$i:1} == \")\" && $level -eq\
    \ $max_level ]]; then\n      echo -n '\"'$max_level'\" '\n      level=0\n    #\
    \ if the character is a right parenthesis and we are not at the maximum nesting\
    \ level,\n    # reduce the level of nesting\n    elif [[ ${1:$i:1} == \")\" ]];\
    \ then\n      (( level-- ))\n    # finally, if the character is neither a left\
    \ or right parenthesis, we are at the end of a group\n    # so print out the maximum\
    \ level of nesting, reset level to zero, and keep looping\n    else\n      echo\
    \ -n '\"'$max_level'\" '\n      level=0\n    fi\n    # check to see if we are\
    \ in a new maximum level of nesting\n    if [[ $level -gt $max_level ]]; then\n\
    \      max_level=$level\n    fi\n  done\n  # print out the maximum level of nesting\
    \ for the last group\n  echo -n '\"'$max_level'\"'\n}\n\ncandidate() {\n    parse_nested_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\"\
    ) = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3\
    \ 4\" ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  str=\"$1\"\n  str=${str//(/(}\n  str=${str//)/)\
    \ }\n  echo \"$str\" | tr ' ' '\\n' | tr -d ')' | wc -l | tr -d ' '\n}\n\ncandidate()\
    \ {\n    parse_nested_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"(()()) ((())) () ((())()())\") = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (())\
    \ ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[ $(candidate \"(()(())((())))\")\
    \ = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n    local input=$1\n    local output=()\n\
    \    if [[ -z \"${input}\" ]]; then\n        return\n    fi\n    while IFS=\"\
    \ \" read -ra ADDR; do\n        local max_level=0\n        local level=0\n   \
    \     for i in \"${ADDR[@]}\"; do\n            case \"${i}\" in\n            \
    \    '(') level=$((level+1)) ;;\n                ')') level=$((level-1)) ;;\n\
    \            esac\n            if ((level > max_level)); then\n              \
    \  max_level=${level}\n            fi\n        done\n        output+=(\"\\\"${max_level}\\\
    \"\")\n    done <<< \"${input}\"\n    echo -e \"[${output[@]}]\"\n}\n\ncandidate()\
    \ {\n    parse_nested_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"(()()) ((())) () ((())()())\") = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (())\
    \ ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[ $(candidate \"(()(())((())))\")\
    \ = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  local group_index=0\n  local maximum_nesting=0\n\
    \  local current_nesting=0\n  local nested_parens_arr=()\n  for (( i=0; i<${#1};\
    \ i++ )); do\n    # echo ${1:$i:1}\n    if [[ ${1:$i:1} == \"(\" ]]; then\n  \
    \    ((current_nesting++))\n      if [[ $current_nesting -gt $maximum_nesting\
    \ ]]; then\n        maximum_nesting=$current_nesting\n      fi\n    elif [[ ${1:$i:1}\
    \ == \")\" ]]; then\n      ((current_nesting--))\n    elif [[ ${1:$i:1} == \"\
    \ \" ]]; then\n      nested_parens_arr[$group_index]=$maximum_nesting\n      maximum_nesting=0\n\
    \      current_nesting=0\n      ((group_index++))\n    fi\n  done\n  # echo ${nested_parens_arr[@]}\n\
    \  # printf \"%s\\n\" \"${nested_parens_arr[@]}\"\n  printf '\"%s\" ' \"${nested_parens_arr[@]}\"\
    \n}\n\ncandidate() {\n    parse_nested_parens \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"(()()) ((())) () ((())()())\") = \"2 3 1 3\" ]]\n  \
    \  [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[ $(candidate\
    \ \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n    if [[ -z \"$1\" ]]; then\n       \
    \ return\n    fi\n    echo -n \"[\"\n    for ((i=0; i<${#1}; i++)); do\n     \
    \   if [[ \"${1:$i:1}\" == \"(\" ]]; then\n            if [[ $i == ${#1}-1 ]];\
    \ then\n                echo -n '\"1\"'\n            else\n                local\
    \ j\n                for ((j=$i+1; j<${#1}; j++)); do\n                    if\
    \ [[ \"${1:$j:1}\" == \")\" ]]; then\n                        echo -n \"\\\"$((j-$i))\\\
    \"\"\n                        i=$j\n                        break\n          \
    \          fi\n                done\n            fi\n        elif [[ \"${1:$i:1}\"\
    \ == \" \" ]]; then\n            echo -n \", \"\n        fi\n    done\n    echo\
    \ -n \"]\"\n}\n\ncandidate() {\n    parse_nested_parens \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\") = \"2 3 1 3\"\
    \ ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[\
    \ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n    local parens=\"${1:-}\"\n    # shellcheck\
    \ disable=SC2086\n    echo \"$parens\" | grep -o '(' | grep -o ')' | awk '{ print\
    \ length($0) }'\n}\n\ncandidate() {\n    parse_nested_parens \"$@\"\n}\n\nset\
    \ -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\") = \"2\
    \ 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3 4\" ]]\n\
    \    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  if [[ $# -ne 1 ]]; then\n    echo \"\
    USAGE: parse_nested_parens <string>\"\n    exit 1\n  fi\n  local s=\"$1\"\n  local\
    \ -a arr\n  local -i idx=0\n  while [[ \"$s\" =~ \\(.*$ ]]; do\n    arr[idx++]=\"\
    $(echo \"$s\" | sed -r 's|.*\\(([^()]*)\\).*|\\1|' | tr -d '\\n')\"\n    s=\"\
    $(echo \"$s\" | sed -r 's|\\(.*\\)|\\1|')\"\n  done\n  echo \"${arr[@]}\"\n}\n\
    \ncandidate() {\n    parse_nested_parens \"$@\"\n}\n\nset -e\nrun_test() {\n \
    \   [[ $(candidate \"(()()) ((())) () ((())()())\") = \"2 3 1 3\" ]]\n    [[ $(candidate\
    \ \"() (()) ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[ $(candidate \"(()(())((())))\"\
    ) = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: 'sed: -e expression #1, char 12: invalid reference \1 on `s'' command''s
    RHS

    '
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  # handle the space separated substrings\n\
    \  local substrings=($1)\n  for substring in \"${substrings[@]}\"; do\n    local\
    \ level=0\n    local max_level=0\n    for ((i=0; i<${#substring}; i++)); do\n\
    \      local char=${substring:$i:1}\n      if [[ \"$char\" == \"(\" ]]; then\n\
    \        ((level++))\n        max_level=$(max $level $max_level)\n      else\n\
    \        ((level--))\n      fi\n    done\n    echo -n \"\\\"$max_level\\\" \"\n\
    \  done\n}\n\ncandidate() {\n    parse_nested_parens \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"(()()) ((())) () ((())()())\") = \"2 3 1 3\" ]]\n  \
    \  [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[ $(candidate\
    \ \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmpxrnz2d8q.sh: line 19: max: command not found

    /tmp/tmpxrnz2d8q.sh: line 19: max: command not found

    /tmp/tmpxrnz2d8q.sh: line 19: max: command not found

    /tmp/tmpxrnz2d8q.sh: line 19: max: command not found

    /tmp/tmpxrnz2d8q.sh: line 19: max: command not found

    /tmp/tmpxrnz2d8q.sh: line 19: max: command not found

    /tmp/tmpxrnz2d8q.sh: line 19: max: command not found

    /tmp/tmpxrnz2d8q.sh: line 19: max: command not found

    /tmp/tmpxrnz2d8q.sh: line 19: max: command not found

    /tmp/tmpxrnz2d8q.sh: line 19: max: command not found

    /tmp/tmpxrnz2d8q.sh: line 19: max: command not found

    /tmp/tmpxrnz2d8q.sh: line 19: max: command not found

    '
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  [[ -z \"$1\" ]] && return 1\n  declare\
    \ -a grp arr\n  local grp_str\n  IFS=' ' read -r -a grp <<< \"$1\"\n  for grp_str\
    \ in \"${grp[@]}\"; do\n    arr=($(parse_nested_parens_grp \"$grp_str\"))\n  \
    \  [[ \"${#arr[@]}\" -eq 1 ]] && echo \"\\\"${arr[0]}\\\"\" || echo \"${arr[@]}\"\
    \n  done\n}\n\ncandidate() {\n    parse_nested_parens \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"(()()) ((())) () ((())()())\") = \"2 3 1 3\" ]]\n  \
    \  [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[ $(candidate\
    \ \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmpbxgsnd0d.sh: line 15: parse_nested_parens_grp: command not found

    /tmp/tmpbxgsnd0d.sh: line 15: parse_nested_parens_grp: command not found

    /tmp/tmpbxgsnd0d.sh: line 15: parse_nested_parens_grp: command not found

    /tmp/tmpbxgsnd0d.sh: line 15: parse_nested_parens_grp: command not found

    '
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  [[ -z \"$1\" ]] && return\n  # Replace\
    \ each string w/ the corresponding sub-string of parentheses.\n  local -a parens=($(echo\
    \ \"${1//[^()]/}\"))\n  # For each of the string, replace all '()' with '0' and\
    \ count the leftover '('s to determine the maximum nesting.\n  local -a levels=($(for\
    \ str in \"${parens[@]}\"; do echo \"${str//()/0}\" | tr -d '()' | grep -o '('\
    \ | wc -l; done))\n  # Remove duplicate values, but keep the order intact.\n \
    \ local -a unique_levels=($(for el in \"${levels[@]}\"; do echo \"$el\"; done\
    \ | sort -u | tr '\\n' ' '))\n  echo \"${unique_levels[@]}\"\n}\n\ncandidate()\
    \ {\n    parse_nested_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"(()()) ((())) () ((())()())\") = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (())\
    \ ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[ $(candidate \"(()(())((())))\")\
    \ = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  local -a arr=()\n  for i in $1; do\n\
    \    arr+=(\"$(echo $i | sed 's/^(//' | sed 's/)$//' | awk '{print gsub(/\\(|\\\
    )/,\"&\")}')\")\n  done\n  echo ${arr[@]}\n}\n\ncandidate() {\n    parse_nested_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\"\
    ) = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3\
    \ 4\" ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n    local max_nesting=0\n    local result=\"\
    \"\n    local i=0\n    local groups=($1)\n    local c\n    local c_prev=\"$IFS\"\
    \n\n    while [ $i -lt ${#groups[@]} ]; do\n        max_nesting=0\n        c_prev=\"\
    $IFS\"\n        # split at the beginning of each group\n        IFS=\"\"\n   \
    \     for c in ${groups[$i]}; do\n            if [ \"$c\" == \"(\" ]; then\n \
    \               max_nesting=$((max_nesting+1))\n            elif [ \"$c\" == \"\
    )\" ]; then\n                if [ $max_nesting -gt 0 ]; then\n               \
    \     max_nesting=$((max_nesting-1))\n                fi\n            fi\n   \
    \     done\n        IFS=\"$c_prev\"\n        result=\"$result \\\"$max_nesting\\\
    \"\"\n        i=$((i+1))\n    done\n    echo -e \"[$result]\"\n}\n\ncandidate()\
    \ {\n    parse_nested_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"(()()) ((())) () ((())()())\") = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (())\
    \ ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[ $(candidate \"(()(())((())))\")\
    \ = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n    local outfile=$(mktemp /tmp/parse_nested_parens.XXXXXX)\n\
    \    local list=$(echo $1 | sed 's/ /\",\"/g')\n    echo \"[$list]\" > $outfile\n\
    \    python -c 'import sys;import ast;print ast.literal_eval(sys.stdin.read())'\
    \ < $outfile | tr -d ' '\n    rm $outfile\n}\n\ncandidate() {\n    parse_nested_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\"\
    ) = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3\
    \ 4\" ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"<string>\", line 1, in <module>\n\
    \  File \"/usr/lib/python2.7/ast.py\", line 49, in literal_eval\n    node_or_string\
    \ = parse(node_or_string, mode='eval')\n  File \"/usr/lib/python2.7/ast.py\",\
    \ line 37, in parse\n    return compile(source, filename, mode, PyCF_ONLY_AST)\n\
    \  File \"<unknown>\", line 1\n    [(()())\",\"((()))\",\"()\",\"((())()())]\n\
    \             ^\nSyntaxError: invalid syntax\n"
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  string=\"$1\"\n  level=0\n  result=()\n\
    \  while [[ \"$string\" != \"\" ]]; do\n    case \"${string:0:1}\" in\n      \\\
    ()\n        level=$((level + 1))\n        ;;\n      \\) )\n        result+=(\"\
    $level\")\n        level=$((level - 1))\n        ;;\n    esac\n    string=\"${string:1}\"\
    \n  done\n  echo \"${result[@]}\"\n}\n\ncandidate() {\n    parse_nested_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\"\
    ) = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3\
    \ 4\" ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  local input_str=$1\n  local IFS=\" \"\
    \n  for word in $input_str; do\n    local count=0\n    for (( i=0; i<${#word};\
    \ i++ )); do\n      if [[ ${word:$i:1} == \"(\" ]]; then\n        ((count++))\n\
    \      elif [[ ${word:$i:1} == \")\" ]]; then\n        ((count--))\n      fi\n\
    \    done\n    if [[ $count -gt 0 ]]; then\n      echo -n '\"0\" '\n    else\n\
    \      echo -n '\"'${count#-}'\" '\n    fi\n  done\n}\n\ncandidate() {\n    parse_nested_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\"\
    ) = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3\
    \ 4\" ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: -1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n    local -a words=(\"$@\")\n\n    for\
    \ word in \"${words[@]}\"; do\n        local max=0\n\n        while [[ $word =~\
    \ \\( ]]; do\n            word=${word#\\(}\n            (( max += 1 ))\n     \
    \   done\n\n        echo \"$max\"\n    done\n}\n\ncandidate() {\n    parse_nested_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\"\
    ) = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3\
    \ 4\" ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Timeout
  stderr: <_io.TextIOWrapper name=36 encoding='utf-8'>
  stdout: <_io.TextIOWrapper name=25 encoding='utf-8'>
  timestamp: 1660022613
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n    local -n input_groups=\"$1\"\n   \
    \ for i in ${input_groups[@]}; do\n\tlocal max_level=0\n\tlocal cur_level=0\n\t\
    for((j=0; j<${#i}; j++)); do\n\t    local jth_char=${i:$j:1}\n\t    if [[ $jth_char\
    \ == \"(\" ]]; then\n\t\tcur_level=$((cur_level+1))\n\t\tif ((cur_level > max_level));\
    \ then\n\t\t    max_level=$cur_level\n\t\tfi\n\t    elif [[ $jth_char == \")\"\
    \ ]]; then\n\t\tcur_level=$((cur_level-1))\n\t    fi\n\tdone\n\techo -n \"$max_level\
    \ \"\n    done\n}\n\ncandidate() {\n    parse_nested_parens \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\") = \"2 3 1 3\"\
    \ ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[\
    \ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmpbhws4d_w.sh: line 10: local: `(()()) ((())) () ((())()())'': invalid
    variable name for name reference

    '
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  local max_nesting=0\n  local current_nesting=0\n\
    \  # $1 is a string\n  # Cycle through each character in the string\n  for ((\
    \ i=0; i<${#1}; i++ )); do\n    local char=\"${1:$i:1}\"\n    if [[ \"$char\"\
    \ == \"(\" ]]; then\n      current_nesting=$(( current_nesting + 1 ))\n      if\
    \ (( current_nesting > max_nesting )); then\n        max_nesting=$current_nesting\n\
    \      fi\n    elif [[ \"$char\" == \")\" ]]; then\n      current_nesting=$((\
    \ current_nesting - 1 ))\n    fi\n  done\n  echo \"$max_nesting\"\n}\n\ncandidate()\
    \ {\n    parse_nested_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"(()()) ((())) () ((())()())\") = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (())\
    \ ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[ $(candidate \"(()(())((())))\")\
    \ = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n    local parens=\"${1}\"\n    local nested_parens=()\n\
    \    while IFS= read -r -d $' '; do\n        nested_parens+=(\"$(echo \"${REPLY}\"\
    \ | awk 'BEGIN { max_depth = 0; curr_depth = 0; }\n            {\n           \
    \     for (i = 1; i <= length($0); i++) {\n                    if (substr($0,\
    \ i, 1) == \"(\") {\n                        curr_depth++;\n                 \
    \       if (curr_depth > max_depth) {\n                            max_depth =\
    \ curr_depth;\n                        }\n                    } else if (substr($0,\
    \ i, 1) == \")\") {\n                        curr_depth--;\n                 \
    \   }\n                }\n            }\n            END { print max_depth; }')\"\
    )\n    done <<< \"${parens}\"\n    echo \"${nested_parens[@]}\"\n}\n\ncandidate()\
    \ {\n    parse_nested_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"(()()) ((())) () ((())()())\") = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (())\
    \ ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[ $(candidate \"(()(())((())))\")\
    \ = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n    local index=0\n    local max_nesting=0\n\
    \    local curr_nesting=0\n    local result=()\n    # Iterate through each character\
    \ of the string.\n    for ((i=0; i<${#1}; i++)); do\n        case ${1:$i:1} in\n\
    \            \"(\" )\n                ((curr_nesting++))\n                if ((curr_nesting\
    \ > max_nesting)); then\n                    max_nesting=$curr_nesting\n     \
    \           fi\n                ;;\n            \")\" )\n                if ((curr_nesting\
    \ > 0)); then\n                    ((curr_nesting--))\n                fi\n  \
    \              ;;\n            \" \" )\n                result[$index]=$max_nesting\n\
    \                ((index++))\n                max_nesting=0\n                curr_nesting=0\n\
    \                ;;\n        esac\n    done\n    result[$index]=$max_nesting\n\
    \    printf '%s' \"${result[@]}\"\n}\n\ncandidate() {\n    parse_nested_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\"\
    ) = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3\
    \ 4\" ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 0
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n    local str=$1\n    # Split string into\
    \ arrays based on spaces\n    local array=(${str// / })\n    local temp\n    local\
    \ output=()\n    for str in \"${array[@]}\"; do\n        local temp=0\n      \
    \  local nest_count=0\n        local i\n        for ((i=0; i<${#str}; i++)); do\n\
    \            if [[ ${str:$i:1} == \"(\" ]]; then\n                ((temp++))\n\
    \                if ((temp > nest_count)); then\n                    nest_count=$temp\n\
    \                fi\n            elif [[ ${str:$i:1} == \")\" ]]; then\n     \
    \           ((temp--))\n            fi\n        done\n        output+=($nest_count)\n\
    \    done\n    echo ${output[@]}\n}\n\ncandidate() {\n    parse_nested_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\"\
    ) = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3\
    \ 4\" ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n    echo \"$1\" | sed -e 's/\\([^()]\\\
    )/\\1 /g' -e 's/\\(\\) /\\1/g' | while read -r line; do\n        echo \"\\\"$(parse_nested_parens_internal\
    \ \"$line\")\\\"\"\n    done\n}\n\ncandidate() {\n    parse_nested_parens \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\"\
    ) = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3\
    \ 4\" ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmpbrs0sb7g.sh: line 11: parse_nested_parens_internal: command not
    found

    '
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n    echo \"$1\" | grep -o \"\\(([^()]*)\\\
    )\" | grep -o \"\\(\" | wc -l | tr '\\n' ' '\n}\n\ncandidate() {\n    parse_nested_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\"\
    ) = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3\
    \ 4\" ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: 'grep: Unmatched ( or \(

    '
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n    groups=$1\n    oIFS=$IFS;\n    IFS='\
    \ '\n    result=''\n    for g in $groups; do\n        max=0\n        level=0\n\
    \        for c in $(echo $g | grep -o .); do\n            if [ \"$c\" == \"(\"\
    \ ]; then\n                ((level++))\n                if [ $level -gt $max ];\
    \ then\n                    max=$level\n                fi\n            elif [\
    \ \"$c\" == \")\" ]; then\n                ((level--))\n            fi\n     \
    \   done\n        result=$result' \"'$max'\"'\n    done\n    IFS=$oIFS\n    echo\
    \ $result\n}\n\ncandidate() {\n    parse_nested_parens \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"(()()) ((())) () ((())()())\") = \"2 3 1 3\" ]]\n  \
    \  [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[ $(candidate\
    \ \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n    local s=\"$1\"\n    local max_nesting=0\n\
    \    local temp=0\n    for (( i=0; i<${#s}; i++ ))\n    do\n        c=${s:$i:1}\n\
    \        if [[ $c == \"(\" ]]; then\n            ((temp++))\n            ((max_nesting=temp>max_nesting?temp:max_nesting))\n\
    \        elif [[ $c == \")\" ]]; then\n            ((temp--))\n        fi\n  \
    \  done\n    echo $max_nesting\n}\n\ncandidate() {\n    parse_nested_parens \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\"\
    ) = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3\
    \ 4\" ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n    # Get the max depth for each group\n\
    \    max_depths=$(echo $1 | sed -e 's/ /\\n/g' -e 's/^(\\([^()]*\\)*$/\\1/' -e\
    \ 's/\\(/\\n(\\1/g' -e 's/)/\\1)\\n/g' -e 's/^(.*)$/\\1\\n/' | grep \"^(\" | wc\
    \ -l | awk '{print $1}')\n    echo \"[$(echo \"$max_depths\" | sed -e 's/ /\"\
    , \"/g')]\"\n}\n\ncandidate() {\n    parse_nested_parens \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\") = \"2 3 1 3\"\
    \ ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[\
    \ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: 'sed: -e expression #3, char 12: Unmatched ( or \(

    '
  stdout: ''
  timestamp: 1660022608
- exit_code: 0
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n    local parens=\"$1\"\n    parens=$(echo\
    \ $parens | sed 's/[[:space:]]/\\n/g')\n    for paren in $parens; do\n       \
    \ local paren_max_depth=0\n        local paren_depth=0\n        for char in $(echo\
    \ $paren | sed 's/./&\\n/g'); do\n            if [[ $char == \"(\" ]]; then\n\
    \                (( paren_depth++ ))\n                if (( paren_depth > paren_max_depth\
    \ )); then\n                    paren_max_depth=$paren_depth\n               \
    \ fi\n            elif [[ $char == \")\" ]]; then\n                (( paren_depth--\
    \ ))\n            fi\n        done\n        paren_max_depth_list+=($paren_max_depth)\n\
    \    done\n    echo ${paren_max_depth_list[@]}\n}\n\ncandidate() {\n    parse_nested_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\"\
    ) = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3\
    \ 4\" ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n    local str=\"$1\"\n    local groups=(\
    \ $str )\n    for i in \"${groups[@]}\"; do\n        local stack=\"\"\n      \
    \  local length=\"${#i}\"\n        for (( j=0; j<length; j++ )); do\n        \
    \    local char=\"${i:$j:1}\"\n            if [[ \"$char\" == \"(\" ]]; then\n\
    \                stack+=\"$char\"\n            elif [[ \"$char\" == \")\" ]];\
    \ then\n                stack=\"${stack%?}\"\n            fi\n        done\n \
    \       echo -n \"\\\"${#stack}\\\" \"\n    done\n}\n\ncandidate() {\n    parse_nested_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\"\
    ) = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3\
    \ 4\" ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 0
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n    input=$1\n    local nested_parens=()\n\
    \    local current_paren_level=0\n    local current_paren_level_max=0\n    local\
    \ -a local_nested_parens=()\n    local level=0\n    local result=\"\"\n    local\
    \ current_group_index=0\n    IFS=' ' read -r -a groups <<< \"$input\"\n    for\
    \ group in \"${groups[@]}\"; do\n        for ((i=0; i<${#group}; i++)); do\n \
    \           local char=${group:$i:1}\n            if [[ \"$char\" == \"(\" ]];\
    \ then\n                ((current_paren_level++))\n                if [[ \"$current_paren_level\"\
    \ -gt \"$current_paren_level_max\" ]]; then\n                    current_paren_level_max=$current_paren_level\n\
    \                fi\n            elif [[ \"$char\" == \")\" ]]; then\n       \
    \         ((current_paren_level--))\n            fi\n        done\n        nested_parens+=(\"\
    $current_paren_level_max\")\n        current_paren_level=0\n        current_paren_level_max=0\n\
    \    done\n    echo \"${nested_parens[@]}\"\n}\n\ncandidate() {\n    parse_nested_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\"\
    ) = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3\
    \ 4\" ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 0
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  if [ \"$#\" -ne 1 ]; then\n    echo\
    \ \"Usage: $0 PARENS_STRING\"\n    exit 1\n  fi\n  local parens_string=\"$1\"\n\
    \  local is_first_group=\"yes\"\n  local parsed_parens=\"\"\n  local old_ifs=\"\
    $IFS\"\n  IFS=\" \"\n  for parens_group in $parens_string; do\n    local stack=\"\
    \"\n    local longest_stack_len=\"0\"\n    for ((i=0; i<${#parens_group}; i++));\
    \ do\n      local char=\"${parens_group:$i:1}\"\n      if [ \"$char\" == \"(\"\
    \ ]; then\n        stack=\"$stack$char\"\n      elif [ \"$char\" == \")\" ]; then\n\
    \        local stack_len=\"${#stack}\"\n        if [ \"$stack_len\" -gt \"$longest_stack_len\"\
    \ ]; then\n          longest_stack_len=\"$stack_len\"\n        fi\n        stack=\"\
    ${stack:0:stack_len-1}\"\n      fi\n    done\n    if [ -z \"$parsed_parens\" ];\
    \ then\n      parsed_parens=\"$longest_stack_len\"\n    else\n      parsed_parens=\"\
    $parsed_parens $longest_stack_len\"\n    fi\n  done\n  IFS=\"$old_ifs\"\n  echo\
    \ \"$parsed_parens\"\n}\n\ncandidate() {\n    parse_nested_parens \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\") = \"\
    2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3 4\" ]]\n\
    \    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  local groups=$(echo $1 | grep -o \"\\\
    (.*\\)\" | tr -d \"()\" | tr \" \" \"\\n\")\n  local open_parens=0\n  local max_open_parens=0\n\
    \  for char in $groups; do\n    open_parens=$((open_parens + 1))\n    if [[ $open_parens\
    \ -gt $max_open_parens ]]; then\n      max_open_parens=$open_parens\n    fi\n\
    \    if [[ $char == \")\" ]]; then\n      open_parens=$((open_parens - 1))\n \
    \   fi\n  done\n  echo \"\\\"$max_open_parens\\\"\"\n}\n\ncandidate() {\n    parse_nested_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\"\
    ) = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3\
    \ 4\" ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n    local str=\"$1\"\n    python -c \"\
    import re; print(','.join(str(len(match.group(1).split('(')) - len(match.group(1).split(')')))\
    \ for match in re.finditer(r'\\((.*?)\\)', '$str')))\"\n}\n\ncandidate() {\n \
    \   parse_nested_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"(()()) ((())) () ((())()())\") = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (())\
    \ ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[ $(candidate \"(()(())((())))\")\
    \ = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  local str=\"$1\"\n  local oldIFS=$IFS\n\
    \  local word_sep=\" \"\n  local char_sep=\"\"\n  local parsed_str=\"\"\n  local\
    \ cur_word=\"\"\n  local max_level=\"\"\n  local cur_level=\"\"\n  IFS=\"$word_sep\"\
    \n  for word in $str; do\n    IFS=\"$char_sep\"\n    cur_level=0\n    max_level=0\n\
    \    for char in $word; do\n      case \"$char\" in\n        \\() ((cur_level++))\
    \ ;;\n        \\) )\n          if ((cur_level == 0)); then\n            echo \"\
    ERROR: unbalanced parenthesis\"\n            return 1\n          fi\n        \
    \  ((cur_level--))\n          if ((cur_level > max_level)); then\n           \
    \ max_level=$cur_level\n          fi\n          ;;\n      esac\n    done\n   \
    \ if ((cur_level != 0)); then\n      echo \"ERROR: unbalanced parenthesis\"\n\
    \      return 1\n    fi\n    parsed_str=\"$parsed_str \\\"$max_level\\\"\"\n \
    \ done\n  echo \"[$parsed_str]\"\n  IFS=$oldIFS\n}\n\ncandidate() {\n    parse_nested_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\"\
    ) = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3\
    \ 4\" ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 0
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n    declare -a count\n    index=0\n  \
    \  for group in $1; do\n        # set the initial max_depth_in_this_group to -1\n\
    \        max_depth_in_this_group=-1\n        # set the initial depth to 0\n  \
    \      depth=0\n        for(( i=0; i<${#group}; i++ )); do\n            # if we\
    \ find a '(' char, increment the depth by 1\n            if [[ ${group:$i:1} ==\
    \ \"(\" ]]; then\n                ((depth++))\n            fi\n            # if\
    \ we find a ')' char, decrement the depth by 1\n            if [[ ${group:$i:1}\
    \ == \")\" ]]; then\n                ((depth--))\n            fi\n           \
    \ # if the depth for this group is larger than the max_depth_in_this_group\n \
    \           # set the max_depth_in_this_group to be the depth\n            if\
    \ (( depth > max_depth_in_this_group )); then\n                max_depth_in_this_group=$depth\n\
    \            fi\n        done\n        # the max_depth_in_this_group is the number\
    \ we want for this group\n        count[$index]=$max_depth_in_this_group\n   \
    \     ((index++))\n    done\n    echo ${count[@]}\n}\n\ncandidate() {\n    parse_nested_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\"\
    ) = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3\
    \ 4\" ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n    local str=\"$1\"\n    str=${str//[^()]/}\n\
    \n    local result\n    result+=( $(awk 'BEGIN { \n                        while\
    \ (match(str, /\\(/)) {\n                            str = substr(str, RSTART+1)\n\
    \                            level++\n                        }\n            \
    \            printf \"%d\", level\n                    }' str=\"$str\") )\n\n\
    \    local len=\"${#result[@]}\"\n    for ((i=0; i<len; i++)); do\n        result[i]=\"\
    \\\"${result[i]}\\\"\"\n    done\n\n    echo \"${result[@]}\"\n}\n\ncandidate()\
    \ {\n    parse_nested_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"(()()) ((())) () ((())()())\") = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (())\
    \ ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[ $(candidate \"(()(())((())))\")\
    \ = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  local ret_str=\"\"\n  local i=0\n  local\
    \ sub_str=''\n  local str_arr=(${1// / })\n  for sub_str in \"${str_arr[@]}\"\
    ; do\n    i=0\n    for ((j=0; j<${#sub_str}; j++)); do\n      if [[ \"${sub_str:$j:1}\"\
    \ == \"(\" ]]; then\n        i=$((i+1))\n      elif [[ \"${sub_str:$j:1}\" ==\
    \ \")\" ]]; then\n        i=$((i-1))\n      fi\n    done\n    if [[ \"$ret_str\"\
    \ != \"\" ]]; then\n      ret_str=\"$ret_str, \\\"$i\\\"\"\n    else\n      ret_str=\"\
    \\\"$i\\\"\"\n    fi\n  done\n  echo \"[$ret_str]\"\n}\n\ncandidate() {\n    parse_nested_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\"\
    ) = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3\
    \ 4\" ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n    #string=\"(()()) ((())) () ((())()())\"\
    \n    IFS=\" \" read -ra ADDR <<< $1\n    for s in \"${ADDR[@]}\"; do\n      \
    \  #echo $s\n        d=$(awk -v s=\"$s\" 'BEGIN{ print (s ~ /^\\(([^()]*(()[^()]*)*)[^()]*\\\
    )$/) }')\n        #echo $d\n        max_level=0\n        # 1 means a left parenthesis,\
    \ -1 means a right parenthesis\n        cur_level=0\n        for (( i=0; i<${#s};\
    \ i++ )); do\n            if [[ ${s:$i:1} == \"(\" ]]; then\n                ((cur_level++))\n\
    \                if (( cur_level > max_level )); then\n                    max_level=$cur_level\n\
    \                fi\n            else\n                ((cur_level--))\n     \
    \       fi\n        done\n        echo -n \"\\\"$max_level\\\" \"\n    done\n\
    \    echo\n}\n\ncandidate() {\n    parse_nested_parens \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"(()()) ((())) () ((())()())\") = \"2 3 1 3\" ]]\n  \
    \  [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[ $(candidate\
    \ \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n    stack=()\n    max_nesting=()\n   \
    \ for (( i=0; i<${#1}; i++ )); do\n        c=${1:$i:1}\n        if [[ $c == \"\
    (\" ]]; then\n            stack+=(\"$c\")\n        elif [[ $c == \")\" ]]; then\n\
    \            stack=(\"${stack[@]:0:${#stack[@]}-1}\")\n            if [[ ${#stack[@]}\
    \ -gt ${#max_nesting[@]} ]]; then\n                max_nesting=(\"${stack[@]}\"\
    )\n            fi\n        fi\n    done\n    echo \"\\\"${#max_nesting[@]}\\\"\
    \"\n}\n\ncandidate() {\n    parse_nested_parens \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"(()()) ((())) () ((())()())\") = \"2 3 1 3\" ]]\n  \
    \  [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[ $(candidate\
    \ \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  local groups\n  groups=\"$1\"\n  local\
    \ depth\n  depth=0\n  local max_depth\n  max_depth=0\n  for ((i=0; i<${#groups};\
    \ i++)); do\n    if [[ \"${groups:$i:1}\" == \"(\" ]]; then\n      ((depth++))\n\
    \      if ((depth > max_depth)); then\n        max_depth=$depth\n      fi\n  \
    \  elif [[ \"${groups:$i:1}\" == \")\" ]]; then\n      ((depth--))\n    fi\n \
    \ done\n  echo $max_depth\n}\n\ncandidate() {\n    parse_nested_parens \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\"\
    ) = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3\
    \ 4\" ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n    local result\n    local start_parens\n\
    \    local end_parens\n    local count_start_parens\n    local count_end_parens\n\
    \    local start_idx\n    local end_idx\n    local group_end_idx\n    local curr_idx\n\
    \    result=\"\"\n    start_parens=\"(\"\n    end_parens=\")\"\n    count_start_parens=0\n\
    \    count_end_parens=0\n    curr_idx=0\n    start_idx=0\n    end_idx=0\n    for\
    \ (( curr_idx=0; curr_idx<${#1}; curr_idx++ )); do\n        if [[ \"${1:$curr_idx:1}\"\
    \ == \"$start_parens\" ]]; then\n            ((count_start_parens++))\n      \
    \  elif [[ \"${1:$curr_idx:1}\" == \"$end_parens\" ]]; then\n            ((count_end_parens++))\n\
    \        elif [[ \"${1:$curr_idx:1}\" == \" \" ]]; then\n            if [[ $count_start_parens\
    \ == $count_end_parens ]]; then\n                group_end_idx=$curr_idx\n   \
    \             end_idx=$curr_idx\n                if [[ $curr_idx -ne $start_idx\
    \ ]]; then\n                    result+=\"\\\"$(($count_start_parens - 1))\\\"\
    \ \"\n                fi\n                count_start_parens=0\n             \
    \   count_end_parens=0\n                start_idx=$((group_end_idx + 1))\n   \
    \         fi\n        fi\n    done\n    if [[ $start_idx -lt $end_idx ]]; then\n\
    \        result+=\"\\\"$(($count_start_parens - 1))\\\"\"\n    fi\n    echo \"\
    [$result]\"\n}\n\ncandidate() {\n    parse_nested_parens \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\") = \"2 3 1 3\"\
    \ ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[\
    \ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  local input=$1\n  local re='\\((.*)\\\
    )'\n  local max_depth=0\n  local depths=()\n  local i=0\n  for paren_string in\
    \ ${input[@]}; do\n    depth=0\n    while [[ $paren_string =~ $re ]]; do\n   \
    \   depth=$((depth+1))\n      paren_string=${BASH_REMATCH[1]}\n    done\n    depths[$i]=$depth\n\
    \    ((i++))\n  done\n  echo \"[\\\"\"$(IFS=,; echo \"${depths[*]}\")\"\\\"]\"\
    \n}\n\ncandidate() {\n    parse_nested_parens \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"(()()) ((())) () ((())()())\") = \"2 3 1 3\" ]]\n  \
    \  [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[ $(candidate\
    \ \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  local str=\"$1\"\n  # echo \"str: $str\"\
    \n\n  # Idea: keep a counter in a loop, count the number of ( and ) separately,\
    \ and then find the mininum count\n  # NOTE: using IFS=$'\\n' to use newline as\
    \ separator\n  local result=()\n  for curr_str in $(echo $str | tr ' ' '\\n');\
    \ do\n    # echo \"curr_str: $curr_str\"\n    count_l_paren=0\n    count_r_paren=0\n\
    \    for ((i=0; i<${#curr_str}; i++)); do\n      curr_char=${curr_str:$i:1}\n\
    \      if [[ $curr_char == \"(\" ]]; then\n        ((count_l_paren++))\n     \
    \ elif [[ $curr_char == \")\" ]]; then\n        ((count_r_paren++))\n      fi\n\
    \    done\n    # echo \"count_l_paren: $count_l_paren\"\n    # echo \"count_r_paren:\
    \ $count_r_paren\"\n    local curr_result=$(expr $count_l_paren - $count_r_paren)\n\
    \    # echo \"curr_result: $curr_result\"\n    result+=(\"$curr_result\")\n  done\n\
    \  # echo \"result: $result\"\n  echo \"${result[@]}\"\n}\n\ncandidate() {\n \
    \   parse_nested_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"(()()) ((())) () ((())()())\") = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (())\
    \ ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[ $(candidate \"(()(())((())))\")\
    \ = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n    echo \"$1\" | tr ' ' '\\n' | awk '{print\
    \ length}'\n}\n\ncandidate() {\n    parse_nested_parens \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\") = \"2 3 1 3\"\
    \ ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[\
    \ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n    local str=\"$1\"\n    local depth=$(echo\
    \ \"$str\" | tr -d \" \" | perl -pe 's/[^()]//g' | perl -ne 'BEGIN { $max = 0\
    \ } if (m/(\\()/g) { $c++; $max = $c if $c > $max } elsif (m/(\\))/g) { $c-- }\
    \ END { print $max }')\n    echo \"$depth\"\n}\n\ncandidate() {\n    parse_nested_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\"\
    ) = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3\
    \ 4\" ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n    echo \"${1}\" | tr ' ' '\\n' | \\\n\
    \    awk '{\n        len = length($0);\n        len_max = 0;\n        len_cur\
    \ = 0;\n        for (i = 1; i <= len; i++) {\n            if (substr($0, i, 1)\
    \ == \"(\") {\n                len_cur++;\n            } else if (substr($0, i,\
    \ 1) == \")\") {\n                len_cur--;\n            }\n            if (len_cur\
    \ > len_max) {\n                len_max = len_cur;\n            }\n        }\n\
    \        print len_max;\n    }'\n}\n\ncandidate() {\n    parse_nested_parens \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\"\
    ) = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3\
    \ 4\" ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  local string=$1\n  local list=$(echo\
    \ $string | tr ' ' '\\n')\n  # all_levels is a list of lists, where each inner\
    \ list is a level of all parentheses at that level\n  local all_levels=()\n  local\
    \ level=0\n  local all_parens=()\n  for paren in $list; do\n    all_parens+=($paren)\n\
    \    local paren_levels=()\n    local open=0\n    local close=0\n    for ((j=0;\
    \ j<${#paren}; j++)); do\n      local char=${paren:$j:1}\n      if [[ $char ==\
    \ \"(\" ]]; then\n        ((open++))\n      elif [[ $char == \")\" ]]; then\n\
    \        ((close++))\n      fi\n      if [[ $open == $close ]]; then\n       \
    \ paren_levels+=($open)\n        open=0\n        close=0\n      fi\n    done\n\
    \    if [[ $level == 0 ]]; then\n      level=$(printf \"%.0f\" $(echo \"${paren_levels[@]}\"\
    \ | tr ' ' '\\n' | sort -gr | head -n 1))\n    fi\n    all_levels+=($(printf \"\
    [\\\"%s\\\"]\" $(echo \"${paren_levels[@]}\" | tr ' ' ',')))\n  done\n  local\
    \ output=$(printf \"[\\\"%s\\\"]\" \"${all_levels[@]}\" | tr ' ' ',')\n  echo\
    \ $output\n}\n\ncandidate() {\n    parse_nested_parens \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"(()()) ((())) () ((())()())\") = \"2 3 1 3\" ]]\n  \
    \  [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[ $(candidate\
    \ \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  if [ -z \"$1\" ]; then\n    echo -n\
    \ \"\"\n    return 0\n  fi\n\n  local IFS=' '\n  local PARENS=($1)\n  local STACK=()\n\
    \  local RESULT=()\n  local GROUP\n  local CHAR\n\n  for GROUP in \"${PARENS[@]}\"\
    ; do\n    for (( i=0; i<${#GROUP}; i++ )); do\n      CHAR=${GROUP:$i:1}\n    \
    \  if [ \"$CHAR\" == \"(\" ]; then\n        STACK+=(\"$CHAR\")\n      elif [ \"\
    $CHAR\" == \")\" ]; then\n        if [ ${#STACK[@]} -eq 0 ]; then\n          echo\
    \ -n \"ERROR\"\n          return 1\n        fi\n        unset STACK[${#STACK[@]}-1]\n\
    \      fi\n    done\n    RESULT+=(\"${#STACK[@]}\")\n    STACK=()\n  done\n\n\
    \  echo -n \"[\\\"${RESULT[@]}\\\"]\"\n  return 0\n}\n\ncandidate() {\n    parse_nested_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\"\
    ) = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3\
    \ 4\" ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  # Your code here\n  input=$1\n  #echo\
    \ ${input[@]}\n  #printf \"%s\\n\" \"${input[@]}\"\n  #printf \"%s\\n\" ${input[@]}\n\
    \  #echo ${input[0]}\n\n  #printf \"%s\\n\" \"${input[@]}\"\n\n  #printf \"%s\\\
    n\" \"${input[@]}\"\n  #printf \"%s\\n\" \"${#input[@]}\"\n  #echo ${input[1]}\n\
    \  #echo ${input[@]}\n  #printf \"%s\\n\" ${input[@]}\n  #printf \"%s\\n\" ${input[@]}\n\
    \  #printf \"%s\\n\" ${input[@]}\n  #printf \"%s\\n\" ${input[@]}\n  #printf \"\
    %s\\n\" ${input[@]}\n  #printf \"%s\\n\" ${input[@]}\n  #printf \"%s\\n\" ${input[@]}\n\
    \  #printf \"%s\\n\" ${input[@]}\n  #printf \"%s\\n\" ${input[@]}\n  #printf \"\
    %s\\n\" ${input[@]}\n  #printf \"%s\\n\" ${input[@]}\n  #printf \"%s\\n\" ${input[@]}\n\
    \  #printf \"%s\\n\" ${input[@]}\n  #printf \"%s\\n\" ${input[@]}\n  #printf \"\
    %s\\n\" ${input[@]}\n  #printf \"%s\\n\" ${input[@]}\n  #printf \"%s\\n\" ${input[@]}\n\
    \  #printf \"%s\\n\" ${input[@]}\n  #printf \"%s\\n\" ${input[@]}\n  #printf \"\
    %s\\n\" ${input[@]}\n  #printf \"%s\\n\" ${input[@]}\n  #printf \"%s\\n\" ${input[@]}\n\
    \  #printf \"%s\\n\" ${input[@]}\n  #printf \"%s\\n\" ${input[@]}\n  #printf \"\
    %s\\n\" ${input[@]}\n  #printf \"%s\\n\" ${input[@]}\n  #printf \"%s\\n\" ${input[@]}\n\
    \  #printf \"%s\\n\n}\n\ncandidate() {\n    parse_nested_parens \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\") = \"\
    2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3 4\" ]]\n\
    \    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  local str=\"$1\"\n  # Split the string\
    \ by spaces\n  local groups=($(echo $str | tr \" \" \"\\n\"))\n  # Local variables\
    \ to keep track of the deepest nesting level\n  local max_nesting=0\n  local group_with_max_nesting=\"\
    \"\n  # Iterate through the groups array\n  for group in \"${groups[@]}\"; do\n\
    \    local nesting=0\n    # Iterate through each character in the group\n    #\
    \ Check for open parentheses, if it's open parentheses increment nesting\n   \
    \ # Check for closed parentheses, if it's close parentheses decrement nesting\n\
    \    for (( i=0; i<${#group}; i++ )); do\n      if [[ ${group:$i:1} == \"(\" ]];\
    \ then\n        nesting=$((nesting+1))\n      elif [[ ${group:$i:1} == \")\" ]];\
    \ then\n        nesting=$((nesting-1))\n      fi\n    done\n    # Keep track of\
    \ the nesting level of a group with max nesting\n    if [[ $nesting -gt $max_nesting\
    \ ]]; then\n      max_nesting=$nesting\n      group_with_max_nesting=$group\n\
    \    fi\n  done\n  # Print the group with maximum nesting\n  echo $group_with_max_nesting\n\
    }\n\ncandidate() {\n    parse_nested_parens \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"(()()) ((())) () ((())()())\") = \"2 3 1 3\" ]]\n    [[\
    \ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[ $(candidate\
    \ \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  local -a parsetoks\n  local currtok\n\
    \  # start with 0 count\n  local parencount=0\n  local maxnest=0\n  # split all\
    \ the parenthetical groups\n  IFS=' ' read -r -a parsetoks <<< \"$1\"\n  for currtok\
    \ in \"${parsetoks[@]}\"; do\n    # throw away leading and trailing parens\n \
    \   currtok=\"${currtok#'('}\"\n    currtok=\"${currtok%')'}\"\n    for (( i=0;\
    \ i<${#currtok}; i++ )); do\n      # if we have a paren, increment the counter.\n\
    \      # if the counter is greater than the max, update the max\n      if [[ \"\
    ${currtok:$i:1}\" == '(' ]]; then\n        parencount=$((parencount+1))\n    \
    \    if [[ $parencount -gt $maxnest ]]; then\n          maxnest=$parencount\n\
    \        fi\n      else\n        parencount=$((parencount-1))\n      fi\n    done\n\
    \    # printf '\"%s\" ' \"$maxnest\"\n    echo -n \"$maxnest \"\n    # reset the\
    \ variables to do it again\n    parencount=0\n    maxnest=0\n  done\n  echo \"\
    \"\n}\n\ncandidate() {\n    parse_nested_parens \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"(()()) ((())) () ((())()())\") = \"2 3 1 3\" ]]\n  \
    \  [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[ $(candidate\
    \ \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  local output=$(echo \"$1\" | tr ' '\
    \ '\\n' | sed -E \"s/\\([^()]*\\)\\(([^()]*|\\(.*\\))*\\)/\\1/g\" | while read\
    \ e; do echo -n \"${#e},\"; done)\n  echo \"[$(echo \"$output\" | sed -E \"s/,/','/g\"\
    )]\"\n}\n\ncandidate() {\n    parse_nested_parens \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"(()()) ((())) () ((())()())\") = \"2 3 1 3\" ]]\n  \
    \  [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[ $(candidate\
    \ \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  echo $(echo $1 | tr ' ' '\\n' |\n  \
    \  xargs -n1 -d'\\n' -I {} sh -c 'printf \"%s\\n\" $(echo \"{}\" | perl -pe \"\
    s/[^()]//g\" | sed -e \"s/(/1/g\" -e \"s/)/0/g\" | tr -d \"\\n\" | sed -e \"s/10/\
    \ /g\" | awk \"{print \\$(NF)}\")')\n}\n\ncandidate() {\n    parse_nested_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\"\
    ) = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3\
    \ 4\" ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n    local -n _g=$1\n    local g=() i=0\n\
    \    for grp in ${_g[@]}; do\n        i=0\n        for ((j=0; j<${#grp}; j++));\
    \ do\n            ((grp[j] == '(')) && ((++i))\n            ((grp[j] == ')'))\
    \ && ((--i))\n        done\n        g+=($i)\n    done\n    echo ${g[@]}\n}\n\n\
    candidate() {\n    parse_nested_parens \"$@\"\n}\n\nset -e\nrun_test() {\n   \
    \ [[ $(candidate \"(()()) ((())) () ((())()())\") = \"2 3 1 3\" ]]\n    [[ $(candidate\
    \ \"() (()) ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[ $(candidate \"(()(())((())))\"\
    ) = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmpfkfogfx8.sh: line 10: local: `(()()) ((())) () ((())()())'': invalid
    variable name for name reference

    '
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  echo \"$1\" | tr ' ' '\\n' | \\\n  \
    \  awk -F'[()]' '{ if (NF>2) printf(\"\\\"%d\\\" \", NF-2) }'\n}\n\ncandidate()\
    \ {\n    parse_nested_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"(()()) ((())) () ((())()())\") = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (())\
    \ ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[ $(candidate \"(()(())((())))\")\
    \ = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n    local str=$1\n    local arr=()\n\n\
    \    # split the string based on space\n    # >>> IFS=' ' read -ra arr <<< \"\
    $str\"\n    # >>> echo ${arr[@]}\n    # '(\"(()())\")' '(\"((()))\")' '(\"()\"\
    )' '(\"((())()())\")'\n    IFS=' ' read -ra arr <<< \"$str\"\n\n    for i in \"\
    ${arr[@]}\"; do\n        # echo \"arr[$i] is $i\"\n        local count=0\n   \
    \     local max_count=0\n        local j=0\n        # find the max depth of each\
    \ group\n        while [ $j -lt ${#i} ]; do\n            # echo \"i[$j] is ${i:$j:1}\"\
    \n            # if opening paren\n            if [ \"${i:$j:1}\" == \"(\" ]; then\n\
    \                count=$((count+1))\n                if [ $count -gt $max_count\
    \ ]; then\n                    max_count=$count\n                fi\n        \
    \    # if closing paren\n            elif [ \"${i:$j:1}\" == \")\" ]; then\n \
    \               count=$((count-1))\n            fi\n            # echo \"count\
    \ is $count\"\n            j=$((j+1))\n        done\n        # echo \"max count\
    \ is $max_count\"\n        printf \"\\\"%s\\\"\" \"$max_count\"\n        if [\
    \ $i != \"${arr[-1]}\" ]; then\n            printf \",\"\n        fi\n    done\n\
    }\n\ncandidate() {\n    parse_nested_parens \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"(()()) ((())) () ((())()())\") = \"2 3 1 3\" ]]\n    [[\
    \ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[ $(candidate\
    \ \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  string=$1\n  # Splitting into multiple\
    \ groups\n  read -a groups <<< $(echo $string | sed 's/ /\\n/g')\n  max_depth=0\n\
    \  groups_with_max_depth=()\n  # Performing the computation for each group\n \
    \ for group in \"${groups[@]}\"; do\n    depth=0\n    for char in $(echo $group\
    \ | sed 's/./&\\n/g'); do\n      # Incrementing the depth for each open bracket\
    \ and decrementing for each close bracket\n      if [ \"$char\" == \"(\" ]; then\n\
    \        depth=$((depth+1))\n      elif [ \"$char\" == \")\" ]; then\n       \
    \ depth=$((depth-1))\n      fi\n    done\n    # Checking for a new max_depth\n\
    \    if [ \"$depth\" -gt \"$max_depth\" ]; then\n      max_depth=$depth\n    \
    \  groups_with_max_depth=()\n    fi\n    # Adding group with same max_depth to\
    \ group_with_max_depth array\n    if [ \"$depth\" -eq \"$max_depth\" ]; then\n\
    \      groups_with_max_depth+=(\"$depth\")\n    fi\n  done\n  echo $groups_with_max_depth\n\
    }\n\ncandidate() {\n    parse_nested_parens \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"(()()) ((())) () ((())()())\") = \"2 3 1 3\" ]]\n    [[\
    \ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[ $(candidate\
    \ \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  local list=($1)\n  for str in \"${list[@]}\"\
    ; do\n    # echo $str\n    local nested_level=0\n    for (( i=0; i<${#str}; i++\
    \ )); do\n      if [[ ${str:$i:1} == \"(\" ]]; then\n        ((nested_level++))\n\
    \      elif [[ ${str:$i:1} == \")\" ]]; then\n        ((nested_level--))\n   \
    \   fi\n    done\n    echo \"\\\"$nested_level\\\"\"\n  done\n}\n\ncandidate()\
    \ {\n    parse_nested_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"(()()) ((())) () ((())()())\") = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (())\
    \ ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[ $(candidate \"(()(())((())))\")\
    \ = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  echo $1 | sed -r 's/\\([^ ()]*\\)|\\\
    ([()]\\)/\\1\\n\\2/g' | sed -r 's/\\([()]\\)/ \\1 /g' | tr -s ' ' | grep '^('\
    \ | while read -r g; do\n    l=0\n    c=0\n    for i in $(echo $g | sed -r 's/\\\
    ([()]\\)/ \\1 /g' | tr -s ' '); do\n      if [ \"$i\" == \"(\" ]; then\n     \
    \   c=$((c+1))\n        l=$((l<c?c:l))\n      elif [ \"$i\" == \")\" ]; then\n\
    \        c=$((c-1))\n      fi\n    done\n    echo \\\"$l\\\"\n  done\n}\n\ncandidate()\
    \ {\n    parse_nested_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"(()()) ((())) () ((())()())\") = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (())\
    \ ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[ $(candidate \"(()(())((())))\")\
    \ = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: 'sed: -e expression #1, char 17: invalid reference \1 on `s'' command''s
    RHS

    sed: -e expression #1, char 31: invalid reference \2 on `s'' command''s RHS

    '
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n    local str=$1\n    local max_depth=0\n\
    \    local current_depth=0\n    local last_char=\"\"\n    local char=\"\"\n  \
    \  local results=\"\"\n    for (( i=0; i<${#str}; i++ )); do\n        char=${str:$i:1}\n\
    \        if [[ $char == \"(\" ]]; then\n            ((current_depth++))\n    \
    \        if [[ $current_depth -gt $max_depth ]]; then\n                max_depth=$current_depth\n\
    \            fi\n        elif [[ $char == \")\" ]]; then\n            ((current_depth--))\n\
    \        fi\n        last_char=$char\n    done\n    echo $max_depth\n}\n\ncandidate()\
    \ {\n    parse_nested_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"(()()) ((())) () ((())()())\") = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (())\
    \ ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[ $(candidate \"(()(())((())))\")\
    \ = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  echo $1 | awk '{\n    gsub(/\\(/,\"\
    ( \");\n    gsub(/\\)/,\" )\");\n    for (i=1; i<=NF; i++) {\n      curr_token=$i;\n\
    \      if (curr_token == \"(\") {\n        num_left_paren=num_left_paren+1;\n\
    \      } else if (curr_token == \")\") {\n        if (num_left_paren > num_right_paren)\
    \ {\n          num_right_paren=num_right_paren+1;\n        } else {\n        \
    \  printf \"\\\"0\\\" \";\n          num_left_paren=0;\n          num_right_paren=0;\n\
    \        }\n      }\n    }\n    if (num_left_paren != 0) {\n      printf \"\\\"\
    %d\\\"\", num_left_paren;\n    }\n  }'\n}\n\ncandidate() {\n    parse_nested_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\"\
    ) = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3\
    \ 4\" ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  local result=()\n  for group in $1;\
    \ do\n    local maximum_level=0\n    local current_level=0\n    for (( i=0; i<${#group};\
    \ i++ )); do\n      if [[ ${group:$i:1} == \"(\" ]]; then\n        (( current_level++\
    \ ))\n        if (( current_level > maximum_level )); then\n          maximum_level=$current_level\n\
    \        fi\n      elif [[ ${group:$i:1} == \")\" ]]; then\n        (( current_level--\
    \ ))\n      fi\n    done\n    result+=(\"$maximum_level\")\n  done\n  echo $result\n\
    }\n\ncandidate() {\n    parse_nested_parens \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"(()()) ((())) () ((())()())\") = \"2 3 1 3\" ]]\n    [[\
    \ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[ $(candidate\
    \ \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n    local level\n    printf \"%s\\n\"\
    \ \"$1\" |\n    {\n        while read -r line\n        do\n            level=0\n\
    \            for ((i=0; i<${#line}; i++))\n            do\n                c=${line:$i:1}\n\
    \                if [[ $c == \"(\" ]]; then\n                    ((level++))\n\
    \                elif [[ $c == \")\" ]]; then\n                    ((level--))\n\
    \                fi\n            done\n            printf '\"%s\"\\n' \"$level\"\
    \n        done\n    }\n}\n\ncandidate() {\n    parse_nested_parens \"$@\"\n}\n\
    \nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\") =\
    \ \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3 4\"\
    \ ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 2
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  local __out=()\n  local __arg_array=()\n\
    \  local __parser=()\n  local __delimiter=\"\"\n  local __paren_counter=\"\"\n\
    \  # Splitting arguments based on space and reconstructing it\n  IFS=\" \" read\
    \ -ra __arg_array <<< \"$1\"\n  for i in \"${__arg_array[@]}\"; do\n    __delimiter=$(echo\
    \ \"${i}\" | cut -c1)\n    # Checking whether a string begins with parenthesis\n\
    \    if [[ \"${__delimiter}\" == \"(\" ]]; then\n      for p in $(seq 1 \"${#i}\"\
    ); do\n        __delimiter=$(echo \"${i}\" | cut -c\"${p}\")\n        if [[ \"\
    ${__delimiter}\" == \"(\" ]]; then\n          ((__paren_counter++))\n        elif\
    \ [[ \"${__delimiter}\" == \")\" ]]; then\n          ((__paren_counter--))\n \
    \       fi\n      done\n      # Checking whether a string is a valid string\n\
    \      if [[ \"${__paren_counter}\" == \"0\" ]]; then\n        # Adding a valid\
    \ string to the array\n        __parser+=(\"${i}\")\n      else\n        __parser+=(\"\
    INVALID\")\n      fi\n    else\n      __parser+=(\"INVALID\")\n    fi\n    __paren_counter=\"\
    \"\n  done\n  # Looping through an array\n  for n in \"${__parser[@]}\"; do\n\
    \    # Making an array of valid strings\n    if [[ \"${n}\" != \"INVALID\" ]];\
    \ then\n      __out+=(\"${n}\")\n    fi\n  done\n  # Looping through the array\
    \ of valid strings\n  for o in \"${__out[@]}\"; do\n    __paren_counter=\"\"\n\
    \    for p in $(seq 1 \"${#o}\"); do\n      __delimiter=$(echo \"${o}\" | cut\
    \ -c\"${p}\")\n      if [[ \"${__delimiter}\" == \"(\" ]]; then\n        ((__paren_counter++))\n\
    \      elif [[ \"${__delimiter}\" == \")\" ]]; then\n        ((__paren_counter--))\n\
    \      fi\n    done\n}\n\ncandidate() {\n    parse_nested_parens \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\") = \"\
    2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3 4\" ]]\n\
    \    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpturxqg3h.sh: line 59: syntax error near unexpected token `}''

    /tmp/tmpturxqg3h.sh: line 59: `}''

    '
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  local result\n\n  # In the example above,\
    \ we should expect the following output\n  # (()()) = 2\n  # ((())) = 3\n  # ()\
    \ = 1\n  # ((())()()) = 3\n  result=$(python -c \"result = [len(list(group)) for\
    \ group in re.findall(r'\\(([^()]*)\\)', '$1')] ; print(result)\")\n  echo \"\
    [$result]\"\n}\n\ncandidate() {\n    parse_nested_parens \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\") = \"2 3 1 3\"\
    \ ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[\
    \ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"<string>\", line 1, in <module>\n\
    NameError: name 're' is not defined\n"
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  if [[ \"$#\" -ne 1 ]]; then\n    echo\
    \ \"Usage: parse_nested_parens \\\"STRING\\\"\"\n    return 1\n  fi\n  local string=$1\n\
    \  local result=$(echo $string | tr \" \" \"\\n\" | awk -F\"\" '{\n    out = \"\
    \";\n    for (i = 1; i <= NF; i++) {\n      if ($i == \"(\") {\n        cnt++;\n\
    \      } else if ($i == \")\") {\n        if (cnt > max) {\n          max = cnt;\n\
    \        }\n        cnt--;\n      }\n    }\n    print \"\\\"\" max \"\\\"\";\n\
    \  }')\n  echo $result\n}\n\ncandidate() {\n    parse_nested_parens \"$@\"\n}\n\
    \nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\") =\
    \ \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3 4\"\
    \ ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: "Usage: awk [POSIX or GNU style options] -f progfile [--] file ...\nUsage:\
    \ awk [POSIX or GNU style options] [--] 'program' file ...\nPOSIX options:\t\t\
    GNU long options: (standard)\n\t-f progfile\t\t--file=progfile\n\t-F fs\t\t\t\
    --field-separator=fs\n\t-v var=val\t\t--assign=var=val\nShort options:\t\tGNU\
    \ long options: (extensions)\n\t-b\t\t\t--characters-as-bytes\n\t-c\t\t\t--traditional\n\
    \t-C\t\t\t--copyright\n\t-d[file]\t\t--dump-variables[=file]\n\t-D[file]\t\t--debug[=file]\n\
    \t-e 'program-text'\t--source='program-text'\n\t-E file\t\t\t--exec=file\n\t-g\t\
    \t\t--gen-pot\n\t-h\t\t\t--help\n\t-i includefile\t\t--include=includefile\n\t\
    -l library\t\t--load=library\n\t-L[fatal|invalid|no-ext]\t--lint[=fatal|invalid|no-ext]\n\
    \t-M\t\t\t--bignum\n\t-N\t\t\t--use-lc-numeric\n\t-n\t\t\t--non-decimal-data\n\
    \t-o[file]\t\t--pretty-print[=file]\n\t-O\t\t\t--optimize\n\t-p[file]\t\t--profile[=file]\n\
    \t-P\t\t\t--posix\n\t-r\t\t\t--re-interval\n\t-s\t\t\t--no-optimize\n\t-S\t\t\t\
    --sandbox\n\t-t\t\t\t--lint-old\n\t-V\t\t\t--version\n\nTo report bugs, see node\
    \ `Bugs' in `gawk.info'\nwhich is section `Reporting Problems and Bugs' in the\n\
    printed version.  This same information may be found at\nhttps://www.gnu.org/software/gawk/manual/html_node/Bugs.html.\n\
    PLEASE do NOT try to report bugs by posting in comp.lang.awk,\nor by using a web\
    \ forum such as Stack Overflow.\n\ngawk is a pattern scanning and processing language.\n\
    By default it reads standard input and writes standard output.\n\nExamples:\n\t\
    gawk '{ sum += $1 }; END { print sum }' file\n\tgawk -F: '{ print $1 }' /etc/passwd\n"
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  echo $1 | sed -E 's/[()]/& /g' | tr\
    \ ' ' '\\n' | awk '\n    function state_machine(stack_count, balance) {\n    \
    \  if (stack_count >= 0) {\n        sub(/^[(]/, \"\", balance)\n        sub(/[)]$/,\
    \ \"\", balance)\n        printf \"%s %s\", stack_count, balance > \"/dev/stderr\"\
    \n        stack_count += 1\n        balance = \"(\" balance \")\"\n      } else\
    \ {\n        stack_count += 1\n        balance = \"(\" balance \")\"\n      }\n\
    \      return stack_count\n    }\n    BEGIN {\n      stack_count = 0\n      balance\
    \ = \"\"\n    }\n    $1 == \"(\" {\n      stack_count = state_machine(stack_count,\
    \ balance)\n    }\n    $1 == \")\" {\n      stack_count = state_machine(stack_count,\
    \ balance)\n    }\n    END {\n      print stack_count\n    }\n  '\n}\n\ncandidate()\
    \ {\n    parse_nested_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"(()()) ((())) () ((())()())\") = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (())\
    \ ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[ $(candidate \"(()(())((())))\")\
    \ = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 '
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n    [[ \"$1\" =~ \\(([^()]*|\\([^()]*\\\
    ))*\\) ]]\n    for i in \"${BASH_REMATCH[@]}\"; do\n        if [[ \"$i\" =~ \\\
    ( ]]; then\n            echo -n $[$(bc <<< \"$i\" | grep -o '(' | wc -l) +1]\n\
    \        else\n            echo -n \"1\"\n        fi\n        echo -n ' '\n  \
    \  done\n}\n\ncandidate() {\n    parse_nested_parens \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"(()()) ((())) () ((())()())\") = \"2 3 1 3\" ]]\n  \
    \  [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[ $(candidate\
    \ \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '(standard_in) 1: syntax error

    (standard_in) 1: syntax error

    '
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n    local i=0\n    local j=0\n    local\
    \ result=()\n    local level=()\n    for ((i=0; i<${#1}; i++)); do\n        if\
    \ [[ ${1:$i:1} == \"(\" ]]; then\n            ((j++))\n            level[$j]=$((level[$j]+1))\n\
    \        elif [[ ${1:$i:1} == \")\" ]]; then\n            ((j--))\n        elif\
    \ [[ ${1:$i:1} == \" \" ]]; then\n            result+=(\"${level[$j]}\")\n   \
    \         unset level[$j]\n            j=0\n        fi\n    done\n    echo \"\
    ${result[@]}\"\n}\n\ncandidate() {\n    parse_nested_parens \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\") = \"2 3 1 3\"\
    \ ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[\
    \ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n    local string=\"$1\"\n    echo \"$string\"\
    \ | awk '{\n        while (match($0, \"\\\\([^()]*\\\\)\")) {\n            nest\
    \ = nest + 1\n            # Remove leading and trailing parentheses.\n       \
    \     $0 = substr($0, RSTART + 1, RLENGTH - 2)\n        }\n        printf(\"\\\
    \"%d\\\" \", nest)\n        nest = 0\n    }'\n}\n\ncandidate() {\n    parse_nested_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\"\
    ) = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3\
    \ 4\" ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  local s=\"$1\"\n  echo -n '['\n  if\
    \ [[ -n $s ]]; then\n    # This helps in case of multiline input.\n    IFS=$'\\\
    n' arr=($(echo $s))\n    if [[ ${#arr[@]} -gt 1 ]]; then\n      for i in ${arr[@]};\
    \ do\n        local val=$(parse_nested_parens \"$i\")\n        echo -n \"$val,\
    \ \"\n      done\n    else\n      local nest_level=0\n      local max_nest_level=0\n\
    \      local len=${#s}\n      local prev_char=''\n      for i in $(seq 1 $len);\
    \ do\n        local char=${s:i-1:1}\n        if [[ $char == '(' ]]; then\n   \
    \       ((nest_level++))\n          if [[ $nest_level -gt $max_nest_level ]];\
    \ then\n            max_nest_level=$nest_level\n          fi\n        elif [[\
    \ $char == ')' ]]; then\n          ((nest_level--))\n        fi\n        if [[\
    \ $char == ' ' && -n $prev_char ]]; then\n          echo -n '\"'$max_nest_level'\"\
    , '\n          max_nest_level=0\n          nest_level=0\n        fi\n        prev_char=$char\n\
    \      done\n      echo -n '\"'$max_nest_level'\"'\n    fi\n  fi\n  echo ']'\n\
    }\n\ncandidate() {\n    parse_nested_parens \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"(()()) ((())) () ((())()())\") = \"2 3 1 3\" ]]\n    [[\
    \ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[ $(candidate\
    \ \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  local max_level group\n  max_level=0\n\
    \  group=0\n  echo ${1} | sed -e 's/[^()]//g' -e 's/(/&\\n/g' -e 's/)/\\n&/g'\
    \ | \\\n    awk '{if ($0 == \"(\") print $0; else if ($0 == \")\") print $0; else\
    \ print 0}' | \\\n    while read; do\n      if [[ $REPLY =~ \"(\" ]]; then\n \
    \       if ((group > max_level)); then\n          max_level=$group\n        fi\n\
    \        ((group++))\n      elif [[ $REPLY =~ \")\" ]]; then\n        ((group--))\n\
    \      fi\n    done\n  echo $max_level\n}\n\ncandidate() {\n    parse_nested_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\"\
    ) = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3\
    \ 4\" ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> $(parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n# ['\"2\"', '\"3\"', '\"1\"', '\"3\"']\n#\n# $1\
    \ is a string\nparse_nested_parens() {\n  local -a nest_count\n  local -a nest_level\n\
    \  local -i count=0\n  local -i level=0\n  local c\n\n  for c in $1; do\n    case\
    \ $c in\n      '(')\n        ((level++))\n        ((count++))\n        ;;\n  \
    \    ')')\n        if [[ $level -gt 0 ]]; then\n          ((level--))\n      \
    \    ((count++))\n        else\n          echo \"ERROR: '$c' appears at the wrong\
    \ place\"\n          return 1\n        fi\n        ;;\n      *)\n        if [[\
    \ $count -gt 0 ]]; then\n          nest_count[$level]+=\"$c\"\n        else\n\
    \          echo \"ERROR: '$c' appears at the wrong place\"\n          return 1\n\
    \        fi\n        ;;\n    esac\n  done\n\n  if [[ $level -gt 0 ]]; then\n \
    \   echo \"ERROR: Unbalanced parentheses\"\n    return 1\n  fi\n\n  for ((i=0;\
    \ i<${#nest_count[@]}; i++)); do\n    nest_level[$i]=\"$(expr ${#nest_count[$i]}\
    \ + 1)\"\n  done\n\n  echo \"${nest_level[@]}\"\n}\n\ncandidate() {\n    parse_nested_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\"\
    ) = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3\
    \ 4\" ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660022608
