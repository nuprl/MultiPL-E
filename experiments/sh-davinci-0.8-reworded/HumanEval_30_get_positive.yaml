name: HumanEval_30_get_positive
language: sh
prompt: "#!/bin/bash\n# Return only positive numbers in the list.\n# >>> $(get_positive\
  \ \"-1 2 -4 5 6\")\n# ['\"2\"', '\"5\"', '\"6\"']\n# >>> $(get_positive \"5 3 -5\
  \ 2 -3 3 9 0 123 1 -10\")\n# ['\"5\"', '\"3\"', '\"2\"', '\"3\"', '\"9\"', '\"123\"\
  ', '\"1\"']\n#\n# $1 is a space-separated list\nget_positive() {\n"
tests: "}\n\ncandidate() {\n    get_positive \"$@\"\n}\n\nset -e\nrun_test() {\n \
  \   [[ $(candidate \"-1 -2 4 5 6\") = \"4 5 6\" ]]\n    [[ $(candidate \"5 3 -5\
  \ 2 3 3 9 0 123 1 -10\") = \"5 3 2 3 3 9 123 1\" ]]\n    [[ $(candidate \"-1 -2\"\
  ) = \"\" ]]\n    [[ $(candidate \"\") = \"\" ]]\n}\n\nrun_test"
completions: ["  echo \"$1\" | tr \" \" \"\\n\" | egrep \"^[0-9]+$\" | tr \"\\n\"\
    \ \" \" | sed 's/^ *//g' | sed 's/ *$//g'", '    _get_numbers_with_sign $1 "positive"',
  "    local result=\"\"\n    local n\n\n    for n in $(echo $1); do\n        if [\
    \ $n -ge 0 ]; then\n            result=\"$result \\\"$n\\\"\"\n        fi\n  \
    \  done\n\n    echo \"[$result]\"", "    local __resultvar=$1\n\n    local numbers=($2)\n\
    \    local result_numbers=()\n    for number in \"${numbers[@]}\"; do\n      \
    \  if (( number > 0 )); then\n            result_numbers+=(\"$number\")\n    \
    \    fi\n    done\n\n    stringify_array __resultvar[@] result_numbers[@]", " \
    \ echo $1 | awk '{for(i=1;i<=NF;i++)if($i>0)print $i}'", "  local -a items=\"\
    ${1// /|}\"\n  if [ ${#items[@]} -ne 0 ]; then\n    # Return only positive numbers.\n\
    \    for item in ${items[@]}; do\n      if [[ ${item} -gt 0 ]]; then\n       \
    \ printf '\"%s\" ' \"${item}\"\n      fi\n    done\n  fi", "  local result=\"\"\
    \n  for i in $1; do\n    if [ $i -gt 0 ]; then\n      result+=\" \\\"$i\\\"\"\n\
    \    fi\n  done\n  echo \"$result\"", "    local __resultvar=$1\n    local numbers=$2\n\
    \    local res\n    for n in $numbers; do\n        if [ $n -ge 0 ]; then\n   \
    \         res=\"$res $n\"\n        fi\n    done\n    eval $__resultvar=\"['$res']\"",
  "    # shellcheck disable=SC2086\n    echo \"$1\" | sed -n 's/^\\(.*\\)\\s\\([0-9]\\\
    +\\)\\s\\(.*\\)$/\\1 \"\\2\" \\3/p' | awk '{print \"\\\"\"$0\"\\\"\"}' | tr '\\\
    n' ',' | sed 's/,$//'", "  echo \"$1\" | tr ' ' '\\n' | grep -v '^-.*' | tr '\\\
    n' ' ' | sed 's/\\s*$//'", "    number_list=($1)\n    positive_list=()\n    for\
    \ n in ${number_list[@]}; do\n        if [ $n -ge 0 ]; then\n            positive_list+=(\"\
    $n\")\n        fi\n    done\n    echo \"${positive_list[@]}\"", "  local input=($1)\n\
    \  local output=()\n  for item in \"${input[@]}\"; do\n    [[ $item -ge 0 ]] &&\
    \ output+=($item)\n  done\n  echo \"${output[@]}\"", "    local _array\n    read\
    \ -r -a _array <<< \"$1\"\n    local _positive_array\n    for n in \"${_array[@]}\"\
    ; do\n        if [ \"$n\" -ge 0 ]; then\n            _positive_array+=(\"$n\"\
    )\n        fi\n    done\n    echo ${_positive_array[@]}", '    echo "[$(get_positive_impl
    "$1")]"', "    local RESULT=()\n    for ITEM in $1; do\n        (( ITEM > 0 ))\
    \ && RESULT+=(\"$ITEM\")\n    done\n    echo \"${RESULT[@]}\"", "  awk 'BEGIN\
    \ {\n    OFS=\" \"\n  }\n  {\n    for (i = 1; i <= NF; i++) {\n      if ($i >\
    \ 0) {\n        print $i\n      }\n    }\n  }' <<< \"$1\"", "    local out=[]\n\
    \    for i in $1; do\n        if [[ $i =~ ^- ]]; then\n            continue\n\
    \        fi\n        out+=(\"\\\"$i\\\"\")\n    done\n    echo \"${out[@]}\"",
  '  _get_numbers "$1" "([[:digit:]]+)"', "    local __res=$(get_numbers $1)\n   \
    \ local __var=$(echo $__res | awk '{\n        while (match($0, \"[[:digit:]]+\
    \ *\") > 0) {\n            num = substr($0, RSTART, RLENGTH);\n            if\
    \ (num > 0) {\n                printf(\"\\\"%s\\\" \", num);\n            }\n\
    \            $0 = substr($0, RSTART + RLENGTH);\n        }\n    }')\n    # strip\
    \ final space\n    echo \"${__var%?}\"", "    if [[ -z \"$1\" ]]; then\n     \
    \   return 0\n    fi\n    local output\n    for arg in $1; do\n        if [[ $arg\
    \ -gt 0 ]]; then\n            output=\"$output \\\"$arg\\\"\"\n        fi\n  \
    \  done\n    echo \"[$output]\"", "  # Return only positive numbers in the list\n\
    \  echo \"$1\" | \\\n    # Remove whitespace\n    tr -d ' ' | \\\n    # Split\
    \ by space\n    tr ' ' '\\n' | \\\n    # Remove only non-positive numbers\n  \
    \  grep -ve '^-.*' | \\\n    # Return numbers\n    awk '{print $1}' | \\\n   \
    \ # Wrap in quotes\n    wrap_in_quotes | \\\n    # Join numbers by space\n   \
    \ join ' '", "    echo $1 | awk '{\n    split($0, a, \" \");\n    for (i in a)\
    \ {\n        if (a[i] >= 0) {\n            print \"\\\"\" a[i] \"\\\"\";\n   \
    \     }\n    }", "    echo \"[$(echo $1 | tr ' ' '\\n' | grep -E '^[0-9]+$' |\
    \ sed 's/.*/\"&\"/' | tr '\\n' ',' | sed 's/,$//')]\"", "    if [[ -z \"$1\" ]];\
    \ then\n        echo '[]'\n        return\n    fi\n\n    local -a list\n    list=($(echo\
    \ \"$1\" | tr ' ' '\\n'))\n    local -a positive_list\n\n    for e in \"${list[@]}\"\
    ; do\n        if [[ $e -gt 0 ]]; then\n            positive_list+=($e)\n     \
    \   fi\n    done\n\n    js_list_helper \"${positive_list[@]}\"", "  local list=$1\n\
    \  local res=()\n  for a in $list; do\n    if [[ $a -gt 0 ]]; then\n      res+=(\"\
    $a\")\n    fi\n  done\n  echo \"${res[@]}\"", "    echo \"$1\" | awk '{for(i=1;i<=NF;i++)if($i>0)print\
    \ $i}'", "  list=$(echo $1 | tr ' ' '\\n')\n  echo \"[\"\n  for n in $list; do\n\
    \    if [ $n -ge 0 ]; then\n      echo '\"'$n'\"',\n    fi\n  done\n  echo \"\
    ]\"", "  get_not_negative \"$@\" | tr -d '-'", "  list=$1\n  p_list=$(echo $list\
    \ | sed 's/-[0-9]*//g' | sed 's/^ *//g')\n  echo $p_list", "  declare -a list=($(echo\
    \ \"$1\" | tr \" \" \"\\n\"))\n  local result=()\n  for ((i=0; i<${#list[@]};\
    \ i++)); do\n    if [[ \"${list[$i]}\" =~ ^-?[0-9]+$ ]]; then\n      local value=${list[$i]}\n\
    \      if ((value > 0)); then\n        result+=(\"$value\")\n      fi\n    fi\n\
    \  done\n  list_to_string \"${result[@]}\"", "  declare -a arr\n  read -a arr\
    \ <<< $1\n  output=()\n  for a in \"${arr[@]}\"; do\n    if [[ $a -gt 0 ]]; then\n\
    \      output+=(\"$a\")\n    fi\n  done\n  echo \"${output[@]}\"", "    local\
    \ list=\"$@\"\n    local positives=()\n    for number in $list; do\n        if\
    \ [[ $number -ge 0 ]]; then\n            positives+=(\"$number\")\n        fi\n\
    \    done\n    echo \"${positives[@]}\"", "  local list\n  list=$(get_list \"\
    $1\")\n  echo \"$list\" | grep -oP '\\d+'", "    local ret_val=\"[\"\n    for\
    \ element in $1; do\n        if [ \"$element\" -gt 0 ]; then\n            if [\
    \ \"$ret_val\" != \"[\" ]; then\n                ret_val=\"$ret_val, \"\n    \
    \        fi\n            ret_val=\"$ret_val\\\"$element\\\"\"\n        fi\n  \
    \  done\n    ret_val=\"$ret_val]\"\n    echo \"$ret_val\"", '  echo "${1}" | tr
    " " "\n" | grep "^[0-9]*[1-9][0-9]*$" | tr "\n" " "', "  local in_list=\"$1\"\n\
    \  local out_list=()\n  local elem\n  for elem in ${in_list}; do\n    if [[ ${elem}\
    \ -gt 0 ]]; then\n      out_list+=(\"${elem}\")\n    fi\n  done\n  echo $(array_to_json_string\
    \ \"${out_list[@]}\")", "    local _nums=($1)\n    local _selected=()\n    for\
    \ _n in \"${_nums[@]}\"; do\n        if (( _n > 0 )); then\n            _selected+=(\"\
    $_n\")\n        fi\n    done\n    printf \"%s\" \"$(array_to_json \"${_selected[@]}\"\
    )\"", "  local args=\"$*\"\n  local p=()\n  local n=()\n  local res=()\n  while\
    \ IFS=' ' read -r number; do\n    if [[ $number =~ ^[0-9]+$ ]]; then\n      p+=(\"\
    $number\")\n    elif [[ $number =~ ^-([0-9]+)$ ]]; then\n      n+=(\"${BASH_REMATCH[1]}\"\
    )\n    fi\n  done <<<\"$args\"\n  for n in \"${n[@]}\"; do\n    for p in \"${p[@]}\"\
    ; do\n      if [[ $n -eq $p ]]; then\n        res+=(\"$n\")\n      fi\n    done\n\
    \  done\n  echo \"${res[@]}\"", "    if [ -z \"$1\" ]; then\n        exit 1\n\
    \    fi\n    echo \"$1\" | tr ' ' '\\n' | grep '^[0-9]*[1-9][0-9]*$' | tr '\\\
    n' ' '", "    local output\n    for item in $1; do\n        if [[ $item -gt 0\
    \ ]]; then\n            output+=\"$item \"\n        fi\n    done\n    echo \"\
    $output\"", "  local input=($1)\n  local result=()\n  for i in \"${input[@]}\"\
    ; do\n    if [[ $i -ge 0 ]]; then\n      result+=(\"$i\")\n    fi\n  done\n  echo\
    \ \"${result[@]}\"", "  echo $1 | xargs -n1 echo | awk '$1>0' | xargs -n1 echo\
    \ | \\\n    sed 's/^/\"/g' | sed 's/$/\"/g' | xargs -n1 echo", "  local positi_list\n\
    \  # If a number is positive, return it; if not, return an empty string.\n  filter_positive()\
    \ {\n    local num=\"$1\"\n    if [[ \"$num\" -ge 0 ]]; then\n      echo \"$num\"\
    \n    else\n      echo \"\"\n    fi\n  }\n  # Map filter_positive over each argument\
    \ of $1.\n  # Assign the result to positi_list.\n  positi_list=\"$(map \"filter_positive\"\
    \ \"$1\")\"\n  # Trim whitespace from beginning and end of each element in positi_list.\n\
    \  trim_all_whitespace \"$positi_list\"", "  echo \"$1\" | tr ' ' '\\n' | awk\
    \ '{if ($1>0) print $1}' | tr '\\n' ' ' | sed 's/^ *//' | sed 's/ *$//'", "  \
    \  echo $1 | tr ' ' '\\n' | grep -v -E '^[^0-9]*-[0-9]' | tr '\\n' ' '", "  local\
    \ val\n  for val in $1; do\n    if [[ \"$val\" -gt 0 ]]; then\n      echo -n \\\
    \"$val\\\"\" \"\n    fi\n  done", "    declare -A nums\n    for n in $1; do\n\
    \        if (( n > 0 )); then\n            nums[${#nums[@]}]=$n\n        fi\n\
    \    done\n    echo ${nums[@]}", "  local list=$1\n  echo '['$(echo $list | tr\
    \ ' ' '\\n' |\n    awk '{if ($1>0) print \"\\\"\"$1\"\\\"\"}' |\n    tr '\\n'\
    \ ',' |\n    sed 's/,$//')']'", "    echo $(echo $1 | tr ' ' '\\n' | awk '{if\
    \ ($1 > 0) print $1}')", "  if [ $# -eq 0 ]; then\n    echo \"[]\"\n    return\n\
    \  fi\n  local numbers=($1)\n  local positive=()\n  for number in \"${numbers[@]}\"\
    ; do\n    if [ \"$number\" -ge 0 ]; then\n      positive+=(\"$number\")\n    fi\n\
    \  done\n  array_to_list \"${positive[@]}\"", "  local numbers_string=${1// /,}\n\
    \  local python_command=\"print([x for x in [${numbers_string}] if x > 0])\"\n\
    \  python -c \"${python_command}\" | sed 's/^\\[//g' | sed 's/\\]$//g'", "  echo\
    \ $1 | tr ' ' '\\n' | grep -E '^[0-9]+$' | tr '\\n' ' '", "    echo \"$1\" | tr\
    \ \" \" \"\\n\" | sed '/^-/d' | xargs", "    echo \"$1\" | \\\n        grep -oE\
    \ '[[:digit:]]+' | \\\n        grep -oE '^[^-]+' | \\\n        sed 's/^/[\"/g'\
    \ | \\\n        sed 's/$/\"]/g' | \\\n        tr '\\n' ' ' | \\\n        sed 's/^\\\
    (.*\\) $/\\1/g'", "    local result=$(echo $1 | tr ' ' '\\n' | grep -E -v -e '^-[0-9]+$'\
    \ -e '^$')\n    echo \"[${result// /, }]\"", "    local num\n    for num in $1;\
    \ do\n        if [[ \"$num\" -gt 0 ]]; then\n            echo \"$num\"\n     \
    \   fi\n    done", "    echo \"$1\" | tr ' ' '\\n' | grep -P \"^([0-9]+|[1-9][0-9]*)$\"\
    \ | xargs echo", "  local NUMBER_LIST=$1\n  local NUMBER_LIST_LENGTH=$(echo $NUMBER_LIST\
    \ | wc -w)\n  local POSITIVE_NUMBER_LIST=()\n  local NUMBER\n  for ((i=1; i<=$NUMBER_LIST_LENGTH;\
    \ i++)); do\n    NUMBER=$(echo $NUMBER_LIST | cut -d' ' -f$i)\n    if [[ $NUMBER\
    \ -gt 0 ]]; then\n      POSITIVE_NUMBER_LIST+=(\"$NUMBER\")\n    fi\n  done\n\
    \  echo \"${POSITIVE_NUMBER_LIST[@]}\"", "  local numbers=($(echo \"$1\" | tr\
    \ ' ' '\\n'))\n  for number in \"${numbers[@]}\"; do\n    if [[ $number -ge 0\
    \ ]]; then\n      echo \"\\\"$number\\\"\"\n    fi\n  done", "    json=$(cat <<EOF\n\
    \    [$(printf '%s,' $1 | sed 's/ -[0-9]*,/ /g')]\nEOF\n    )\n    echo $json\
    \ | sed 's/\\[,\\]/\\[\\]/g'", "    local -a positive_numbers\n    for number\
    \ in $1; do\n        if [[ $number -ge 0 ]]; then\n            positive_numbers+=(\"\
    $number\")\n        fi\n    done\n    printf '%s\\n' \"${positive_numbers[@]}\"",
  "  local array\n  array=($1)\n  local pos\n  pos=()\n  for (( i=0; i<${#array[@]};\
    \ i++ )); do\n    if [[ ${array[$i]} -gt 0 ]]; then\n      pos+=(\"${array[$i]}\"\
    )\n    fi\n  done\n  echo ${pos[@]}", "  if [ -z \"$1\" ]; then\n    # Print nothing\
    \ if input is empty\n    echo\n  else\n    # Otherwise, print all the positive\
    \ integers in the list\n    echo $1 | tr \" \" \"\\n\" | awk '{ if ($1 >= 0) print\
    \ $1 }' | tr \"\\n\" \" \"\n  fi", "    local list=\"$1\"\n    local result\n\
    \    for item in $list; do\n        [[ $item -gt 0 ]] && result+=($item)\n   \
    \ done\n    printf \"%s\\n\" \"${result[@]}\"", "  LIST=$1\n  POS_NUMBERS=()\n\
    \  for NUMBER in $LIST; do\n    if [ \"$NUMBER\" -gt 0 ]; then\n      POS_NUMBERS+=($NUMBER)\n\
    \    fi\n  done\n  echo ${POS_NUMBERS[@]}", "    local num=\"$1\"\n    # if no\
    \ numbers, return empty\n    if [[ $num == \"\" ]]; then\n        echo \"\"\n\
    \        return 0\n    fi\n    local res=\"\"\n    local -a out\n    read -a out\
    \ <<< \"$num\"\n    for o in \"${out[@]}\"; do\n        if [[ \"$o\" -gt 0 ]];\
    \ then\n            res=\"$res $o\"\n        fi\n    done\n    echo \"$res\"",
  "  python -c \"import sys; res = [str(i) for i in sorted(list(set([int(i) for i\
    \ in sys.argv[1].split(' ')]))) if i > 0]; print(json.dumps(res))\" \"$1\"", " \
    \ python3 -c \"\nfrom lib.looper import Looper\nimport sys\n\nif __name__ == '__main__':\n\
    \  sys.stdout.write(str(list(filter(lambda n: n > 0, map(int, Looper('$1'))))))\n\
    \"", "    local list\n    if [[ -z \"$1\" ]]; then\n        list=\"$(tr ' ' '\\\
    n' <<< \"${@:2}\")\"\n    else\n        list=\"$(tr ' ' '\\n' <<< \"$1\")\"\n\
    \    fi\n    local result\n    result=\"$(awk '{if($1>0) print $1}' <<< \"$list\"\
    )\"\n    echo \"$(tr '\\n' ' ' <<< \"$result\")\"", "    echo \"${1}\" | awk '{\n\
    \        for (i = 1; i <= NF; i++) {\n            if ($i > 0) {\n            \
    \    printf \"\\\"%s\\\" \", $i\n            }\n        }\n    }'", "    local\
    \ list=$(extract_numbers \"$1\")\n    local positive=()\n    local num\n    for\
    \ num in $list; do\n        if [ $num -gt 0 ]; then\n            positive+=(\"\
    $num\")\n        fi\n    done\n    echo \"${positive[@]}\"", "  local -r list=\"\
    $1\"\n  local -r result=$(echo \"$list\" | awk '{for(i=1;i<=NF;i++) if($i>0) print\
    \ $i}')\n  echo \"[$(join_by \"', '\" $result)]\"", "    result=()\n    for i\
    \ in $(echo $1 | xargs); do\n        if (( $i > 0 )); then\n            result+=(\"\
    $i\")\n        fi\n    done\n    echo \"${result[@]}\"", "  if [ \"$#\" -eq 0\
    \ ]; then\n    echo \"${FUNCNAME[0]}() requires 1 argument: space-separated list.\
    \ No arguments provided.\" >&2\n    return 1\n  fi\n  local __result\n  local\
    \ -a __list\n  local __item\n  for __item in $1; do\n    if [ $__item -gt 0 ];\
    \ then\n      __list+=($__item)\n    fi\n  done\n  __result=$(printf '\"%s\" '\
    \ \"${__list[@]}\")\n  echo \"[${__result% }]\"", "    seq \"$1\" | grep -oP '^[\\\
    d]+$' | tr '\\n' ' ' | sed 's/[ ]*$//'", "  local filtered\n  filtered=\"$(filter_list\
    \ \"${1}\" \"x>0\")\"\n  echo \"${filtered}\"", "  echo $(echo \"$1\" | sed -e\
    \ 's/-/ -/g' | grep -o -e '[0-9]\\+' | jq -R -s -c .)", "  if [[ $# -eq 0 ]];\
    \ then\n    return 1\n  fi\n  echo \"$@\" | tr \" \" \"\\n\" | awk '{ if ($1 >=\
    \ 0) print $1 }' | tr \"\\n\" \" \"", "    local -r list=\"$1\"\n    python -c\
    \ \"print [ str(x) for x in $list if x > 0 ]\"", "  echo \"$1\" | tr ' ' '\\n'\
    \ |\n  {\n    while read num; do\n      if [ \"$num\" -ge 0 ]; then\n        echo\
    \ \"\\\"$num\\\"\"\n      fi\n    done\n  } | tr '\\n' ' '", "    local -a pos_list=()\n\
    \    for i in $1; do\n        if [ \"$i\" -gt 0 ]; then\n            pos_list+=($i)\n\
    \        fi\n    done\n    echo \"${pos_list[@]}\"", "    python -c \"\nimport\
    \ sys\nfor num in sys.argv[1].split():\n    if int(num) > 0:\n        print(num)\n\
    \" \"$1\"", "    [[ -z \"$1\" ]] && return\n    local num\n    local pos\n   \
    \ IFS=' ' read -r -a nums <<< \"$1\"\n    local pos=()\n    for num in \"${nums[@]}\"\
    ; do\n        if [[ $num -gt 0 ]]; then\n            pos+=(\"$num\")\n       \
    \ fi\n    done\n    echo \"[$(IFS=, ; echo \"${pos[*]}\")]\"", "    local _nums=($1)\n\
    \    local _positive_nums=()\n    for _num in \"${_nums[@]}\"; do\n        if\
    \ ((_num > 0)); then\n            _positive_nums+=(\"$_num\")\n        fi\n  \
    \  done\n    printf '[\"%s\"]' \"${_positive_nums[@]}\"", "    local result\n\
    \    for value in $1; do\n        if [[ $value -gt 0 ]]; then\n            result+=(\
    \ \"\\\"$value\\\"\" )\n        fi\n    done\n    echo \"[${result[@]}]\"", " \
    \   # Get space-separated list as array\n    arr=($1)\n    ret=()\n    # Search\
    \ for numbers greater than zero\n    for n in \"${arr[@]}\"; do\n        [[ $n\
    \ -gt 0 ]] && ret+=(\"$n\")\n    done\n    echo \"${ret[@]}\"", "    local __resultvar=$1\n\
    \n    # Bash regex, captures any number with an optional leading + sign\n    local\
    \ regex=\"([+]?[0-9]+)\"\n\n    # Extract each number from the input and save\
    \ it in the __resultvar\n    local numbers=()\n    for number in ${@:2}; do\n\
    \        [[ $number =~ $regex ]]\n        numbers+=(\"\\\"${BASH_REMATCH[1]}\\\
    \"\")\n    done\n\n    # Save the extracted numbers in the __resultvar\n    if\
    \ [[ $__resultvar ]]; then\n        eval $__resultvar=\"'${numbers[@]}'\"\n  \
    \  fi", "  echo \"$1\" | tr \" \" \"\\n\" | tr -d \"-\" | egrep '^[0-9]+$' | tr\
    \ \"\\n\" \" \" | sed -r 's/ /\", \"/g' | sed -r 's/^/[\"/' | sed -r 's/$/\"/'",
  "  list=${1//-/ }  # replace all - with space\n  [[ $1 =~ ^- ]] && list=${list#\
    \ }  # remove first space if $1 starts with -\n  eval echo $(for num in $list;\
    \ do\n                [[ $num -gt 0 ]] && echo $num\n              done | xargs\
    \ echo \\\")", "    echo $1 | tr ' ' '\\n' | grep -E '^[0-9]+$' | tr '\\n' ' '",
  "    echo \"$1\" | awk 'BEGIN {RS=\" \"; ORS=\", \"} $1 > 0 {print \"\\\"\"$1\"\\\
    \"\"}'", "  local nums=($(echo $1))\n  local filtered=()\n  for num in ${nums[@]};\
    \ do\n    if [ ${num:0:1} == \"-\" ]; then\n      continue\n    fi\n    filtered+=(${num})\n\
    \  done\n  echo \"${filtered[@]}\"", "    local numbers=\"$1\"\n    local number=\n\
    \    local positive=()\n    for number in $numbers; do\n        [[ \"$number\"\
    \ -ge 0 ]] && positive+=(\"$number\")\n    done\n    echo \"${positive[@]}\"",
  "  local input=${1}\n  if [[ ${input} ]]; then\n    local arr=($(echo ${input}))\n\
    \    local result=$(map_to_str $(filter_positive ${arr[@]}))\n    echo ${result}\n\
    \  fi", "    local input=\"$1\"\n    local array=($input)\n    for element in\
    \ \"${array[@]}\"; do\n        if ((element > 0)); then\n            echo -n '\"\
    '$element'\"'\n            echo -n \" \"\n        fi\n    done", "  # check if\
    \ no argument passed\n  if [ -z \"$1\" ]; then\n    >&2 echo \"No argument passed\
    \ to $(basename $0) > get_positive()\"\n    exit 1\n  fi\n\n  # use space as separator\n\
    \  OLDIFS=$IFS\n  IFS=$' '\n\n  # use an array to store numbers\n  IFS=' ' read\
    \ -r -a numbers <<< \"$1\"\n\n  # reset IFS\n  IFS=$OLDIFS\n\n  # return only\
    \ positive numbers in the list\n  for i in \"${numbers[@]}\"; do\n    if [ \"\
    $i\" -gt 0 ]; then\n      printf '\"%s\" ' \"$i\"\n    fi\n  done", "  declare\
    \ -a result=()\n  for x in $(echo $1); do\n    if [ $x -ge 0 ]; then\n      result+=($x)\n\
    \    fi\n  done\n  echo ${result[@]}", "  local result\n  result=()\n  for x in\
    \ $1; do\n    if [[ $x -ge 0 ]]; then\n      result+=(\"$x\")\n    fi\n  done\n\
    \  echo \"${result[@]}\"", "  local -r SORT_ARGS='-n'\n  local -r POSITIVE_ARGS='-0\
    \ -E'\n  local -r list=$1\n  local -r POSITIVE_PATTERN='[0-9]+'\n  echo $(get_matching\
    \ \"$list\" \"$POSITIVE_PATTERN\" \"$POSITIVE_ARGS\" \"$SORT_ARGS\")", "    local\
    \ x\n    echo \"[\"\n    for x in $1; do\n        if [ $x -ge 0 ]; then\n    \
    \        echo '\"'$x'\"'\n        fi\n    done\n    echo \"]\"", "    echo $1\
    \ | tr ' ' '\\n' | awk '$1 > 0' | tr '\\n' ' ' | tr -d '\\r'", "    local list=\"\
    $1\"\n    __get_list \"$list\" \"p\"", "    # -n is for --no-dereference.\n  \
    \  for f in $1; do\n        if [ $f -ge 0 ] 2>/dev/null; then\n            echo\
    \ -n '\"'$f'\"'\n            echo -n \" \"\n        fi\n    done", "    echo -n\
    \ \"[\"\n    for value in $1; do\n        if [[ \"$value\" -gt 0 ]]; then\n  \
    \          echo -n \"\\\"$value\\\" \"\n        fi\n    done\n    echo -n \"]\"",
  "    if [ \"$#\" -ne 1 ]; then\n        error \"Error in ${FUNCNAME[0]}, requires\
    \ list as an argument\"\n        return 1\n    fi\n    local list=\"$1\"\n   \
    \ local positive_list=\"\"\n    for item in $list; do\n        if [ \"$item\"\
    \ -gt 0 ]; then\n            positive_list=\"$positive_list $item\"\n        fi\n\
    \    done\n    echo \"$positive_list\"", "  set -f; IFS=$'\\n'\n  # remove all\
    \ empty strings\n  local all_values=\"$(echo \"$1\" | tr ' ' '\\n' | sed \"/^$/d\"\
    )\"\n  local positives=\"$(echo \"$all_values\" | grep \"^[[:digit:]]*$\" || true)\"\
    \n  local result=\"$(echo \"$positives\" | tr '\\n' ' ')\"\n  if [ -z \"$result\"\
    \ ]; then\n    echo \"[]\"\n  else\n    echo \"[${result}]\"\n  fi", "  echo $1\
    \ | tr ' ' '\\n' | grep '^[[:digit:]]*$' | sed 's/^\\([0-9]*\\)$/\"\\1\"/g'",
  "    read -ra nums <<<\"$1\"\n    for num in \"${nums[@]}\"; do\n        [[ $num\
    \ -ge 0 ]] && printf \"%s\\n\" \"$num\"\n    done", "  # TODO: implement this\
    \ function.\n  # Hint: use > 0.\n  echo \"\\\"$(echo $1 | tr \" \" \"\\n\" | sort\
    \ -n | grep -v \"-\")\\\"\"", "    if [[ \"$1\" ]]; then\n        echo $(eval\
    \ echo $1 | sed -e 's/ /\", \"/g')\n    fi", "    local -r numbers=\"$1\"\n  \
    \  local positive\n    for i in $numbers; do\n        if (( i > 0 )); then\n \
    \           positive+=($i)\n        fi\n    done\n    echo -n \"$(to_json \"${positive[@]}\"\
    )\"", "  local _res=()\n  IFS=' ' read -r -a nums <<< \"$1\"\n  for num in \"\
    ${nums[@]}\"; do\n    if [ \"$num\" -ge 0 ]; then\n      _res+=(\"$num\")\n  \
    \  fi\n  done\n  array_to_json_string \"${_res[@]}\"", "    local arr=(${1// /\
    \ })\n    for var in \"${arr[@]}\"; do\n        if [[ $var -ge 0 ]]; then\n  \
    \          echo -n '\"'$var'\"'\n            echo -n \" \"\n        fi\n    done",
  "    local num_list=\"$1\"\n    echo $num_list | sed 's/\\(-[0-9]\\+\\)/ /g' | sed\
    \ 's/\\(-[0-9]\\+\\)/ /g' | sed 's/\\(-[0-9]\\+\\)/ /g' | sed 's/\\(-[0-9]\\+\\\
    )/ /g' | sed 's/^[ \\t]*//;s/[ \\t]*$//'", "    echo \"$1\" | grep -E '^([[:space:]]*[0-9]+[[:space:]]*)+$'\
    \ | tr ' ' '\\n' | grep -v '^-' | paste -sd ' '", "    local POSITIVE\n    # POSITIVE\
    \ is a bash array, including only the positive numbers of the input\n    POSITIVE=(\
    \ $(echo \"$1\" | awk '{if ($1 > 0) print $1}') )\n    # Parse the array to a\
    \ string where the elements are separated by space\n    local RETURN_VAL=$(echo\
    \ \"${POSITIVE[@]}\")\n    echo $RETURN_VAL", "    local -a elements=($1)\n  \
    \  local -a positive=()\n    for element in \"${elements[@]}\"; do\n        if\
    \ [ \"$element\" -gt 0 ]; then\n            positive+=($element)\n        fi\n\
    \    done\n    printf \"[\"\n    if [ \"${#positive[@]}\" -gt 0 ]; then\n    \
    \    printf '\"%s\"' \"${positive[0]}\"\n        if [ \"${#positive[@]}\" -gt\
    \ 1 ]; then\n            for i in \"${positive[@]:1}\"; do\n                printf\
    \ ',\"%s\"' \"$i\"\n            done\n        fi\n    fi\n    printf \"]\"", " \
    \ local arr=()\n  local is_positive\n  #IFS=\" \" read -r -a arr <<< \"$1\"\n\
    \  for i in $1; do\n    #is_positive=$(echo \"$i>0\" | bc)\n    is_positive=$(echo\
    \ \"$i>0\" | bc)\n    if [ \"$is_positive\" -eq 1 ]; then\n      arr+=($i)\n \
    \   fi\n  done\n  printf '%s\\n' \"${arr[@]}\"", "    local result=()\n    local\
    \ number\n    for number in ${@}; do\n        (( number >= 0 )) && result+=( \"\
    \\\"${number}\\\"\" )\n    done\n    echo \"[${result[*]}]\"", "    result=()\n\
    \    for x in $1; do\n        if [ $x -ge 0 ]; then\n            result+=(\"\\\
    \"$x\\\"\")\n        fi\n    done\n    echo \"[\"$(join_by \", \" \"${result[@]}\"\
    )\"]\"", "    local numbers=($1)\n    # Pattern for number checking.\n    local\
    \ pattern=\"^[+-]?([0-9]+)([.][0-9]+)?$\"\n    local pos_numbers=()\n    local\
    \ i\n\n    for ((i = 0; i < ${#numbers[@]}; i++)); do\n        if [[ ${numbers[$i]}\
    \ =~ $pattern ]]; then\n            if [[ ${numbers[$i]} -ge 0 ]]; then\n    \
    \            pos_numbers+=(${numbers[$i]})\n            fi\n        fi\n    done\n\
    \n    echo ${pos_numbers[@]}", "  printf \"[\"\n  for elt in $1; do\n    [[ \"\
    $elt\" -ge 0 ]] && printf '\"%s\", ' \"$elt\"\n  done | sed 's/,$//'\n  printf\
    \ \"]\"", "  local  p=\"$1\"\n  echo \"$p\" | tr \" \" \"\\n\" | grep -E '^[0-9]+$'\
    \ | tr \"\\n\" \" \"", "    local input_list=(\"$@\")\n    local output_list=()\n\
    \    for element in \"${input_list[@]}\"; do\n        if (( element > 0 )); then\n\
    \            output_list+=(\"$element\")\n        fi\n    done\n    printf \"\
    %s\" \"$(get_json_array \"${output_list[@]}\")\"", "    echo -n $1 | awk 'BEGIN\
    \ { RS=\" \"; ORS=\" \" }; { if($1 > 0) print $1 }'", "  local str=$1\n  local\
    \ out=[]\n  local arr\n  IFS=' ' read -ra arr <<<\"$str\"\n  for i in \"${arr[@]}\"\
    ; do\n    if [[ $i -gt 0 ]]; then\n      out+=(\"\\\"$i\\\"\")\n    fi\n  done\n\
    \  echo $out", "    local nums=\"$1\"\n    echo -n \"[\"\n    local to_append=\"\
    \"\n    for num in ${nums}; do\n        if [[ \"${num}\" -gt 0 ]]; then\n    \
    \        echo -n \"${to_append}\\\"${num}\\\"\"\n            to_append=\", \"\n\
    \        fi\n    done\n    echo \"]\"", "  echo \"$1\" | tr ' ' '\\n' | sort -nr\
    \ | awk '$1 > 0' | tr '\\n' ' ' | tr -d '\\r'", "  local -r input=\"$1\"\n  echo\
    \ \"$input\" | grep '^[0-9]\\+$'", "    local list=${1:?}\n    local numbers=(${list//\
    \ / })\n    local result=()\n    for n in ${numbers[@]}; do\n        if (( n >\
    \ 0 )); then\n            result+=(\"$n\")\n        fi\n    done\n    echo \"\
    ${result[@]}\"", "    echo \"$1\" | grep -E '^[0-9]+$' | paste -sd '[\\\\\"' '\\\
    \\\",\\\\\"']", "  for v in $1; do\n    if [ $v -ge 0 ]; then\n      echo -n \"\
    \\\"$v\\\" \"\n    fi\n  done", "  echo \"[${1//-[[:digit:]]/}]\" | sed 's/\\\
    [\\]/\\[\\]/g'", "    local ret=$(echo $1 | tr \" \" \"\\n\" | grep -E '^[0-9]+$')\n\
    \    if [ -z \"$ret\" ]; then\n        ret=\"[]\"\n    else\n        ret=\"[$(echo\
    \ $ret | tr \" \" \"\\\",\\\"\")]\"\n    fi\n    echo \"$ret\"", "  local list=\"\
    $1\"\n  local re='^-?[0-9]+$'\n  echo \"$list\" | tr ' ' '\\n' | \\\n    awk '$1\
    \ > 0' | tr '\\n' ' ' | sed 's/^ *//g' | sed 's/ *$//g'", "  echo \"$1\" | tr\
    \ ' ' '\\n' | grep -E '[0-9]+' | tr '\\n' ' '", "    #IFS=' ' read -r -a arr <<<\
    \ $1\n    arr=($1)\n    s=''\n    for v in \"${arr[@]}\"; do\n        if [[ $v\
    \ -gt 0 ]]; then\n            s+=\" $v\"\n        fi\n    done\n    echo \"[$(to_json_list\
    \ $s)]\"", "  local digits_with_space=$(echo \"$1\" | xargs -n1 echo | tr '\\\
    n' ' ')\n  local positive_digits_with_space=$(echo $digits_with_space | awk '{for(i=1;i<=NF;i++)\
    \ if($i>0) print $i}')\n  echo \"[$(echo $positive_digits_with_space | sed -e\
    \ 's/ /\",\"/g')]\"", "    echo \"$1\" | awk '{for(i=1;i<=NF;i++)if($i>0)printf\
    \ \"%s%s\",sep,$i;sep=\" \"}'", "    list=($1)\n    length=${#list[@]}\n    for\
    \ ((i=0; i<$length; i++)); do\n        number=${list[$i]}\n        if [ $number\
    \ -gt 0 ]; then\n            echo -n \"\\\"$number\\\" \"\n        fi\n    done",
  "  local numbers=\"$1\"\n  local positive_pattern='^[0-9]+$'\n  local positive_numbers=()\n\
    \  for number in $numbers; do\n    if [[ $number =~ $positive_pattern ]]; then\n\
    \      positive_numbers+=($number)\n    fi\n  done\n  echo \"${positive_numbers[@]}\"",
  "    echo \"${1}\" | tr ' ' '\\n' | grep '^[0-9]*$' | tr '\\n' ' '", "    if [[\
    \ $# -eq 0 ]]; then\n        echo \"[]\"\n        return\n    fi\n\n    local\
    \ list=\"[$(\n        for n in $1; do\n            if (( n > 0 )); then\n    \
    \            echo \"\\\"$n\\\"\"\n            fi\n        done\n    | paste -sd,\
    \ -)]\"\n\n    echo \"$list\"", "  _local res=''\n  _local num\n  for num in ${1};\
    \ do\n    if [[ ${num} -gt 0 ]]; then\n      res+=\" \\\"${num}\\\"\"\n    fi\n\
    \  done\n  echo ${res}", "    local -a __data=$1;\n    local -a __result=( $(/usr/bin/awk\
    \ 'BEGIN { for (i = 1; i <= NF; i++) {\n                                     \
    \                       if ($i > 0) {\n                                      \
    \                          print $i;\n                                       \
    \                     }\n                                                    \
    \    }\n                                                     }' <<< \"${__data}\"\
    ) );\n    echo ${__result[@]};", "  local numbers=$1\n  local output=\"\"\n  for\
    \ n in $numbers; do\n    if [ \"$n\" -ge 0 ]; then\n      if [ -z \"$output\"\
    \ ]; then\n        output=\"\\\"$n\\\"\"\n      else\n        output=\"$output,\
    \ \\\"$n\\\"\"\n      fi\n    fi\n  done\n  echo \"[$output]\"", "    echo $(echo\
    \ $1 | tr ' ' '\\n' | grep -E '^[0-9]+$' | tr '\\n' ' ')", "  local numbers=(${@})\n\
    \  local positives=()\n  for i in \"${numbers[@]}\"; do\n    ((i > 0)) && positives+=(\"\
    $i\")\n  done\n  echo ${positives[@]}", "    [[ $# -eq 0 ]] && return 0\n    local\
    \ -a in_arr=($1)\n    local -a out_arr=()\n    for i in \"${in_arr[@]}\"; do\n\
    \        if [[ $i -gt 0 ]]; then\n            out_arr+=(\"$i\")\n        fi\n\
    \    done\n    echo \"${out_arr[@]}\"", "    awk '\n    {\n        for (i = 1;\
    \ i <= NF; i++) {\n            if ($i > 0) {\n                print \"\\\"\"$i\"\
    \\\"\"\n            }\n        }\n    }' <<< \"$1\"", '  echo $(get_extremum "$1"
    min_inclusive 0)', "  local input_list=${1}\n  local pattern='^[0-9]+$'\n  local\
    \ positive_list=()\n  local i=0\n  local item=''\n  local positive_item=''\n \
    \ for item in ${input_list}; do\n    if [[ ${item} =~ ${pattern} ]]; then\n  \
    \    positive_list[${i}]=${item}\n      i=$((i+1))\n    fi\n  done\n  i=0\n  for\
    \ positive_item in ${positive_list[@]}; do\n    if [[ ${i} -eq 0 ]]; then\n  \
    \    local result=\"[${positive_item}\"\n    else\n      local result=\"${result},\
    \ ${positive_item}\"\n    fi\n    i=$((i+1))\n  done\n  if [[ ${i} -gt 0 ]]; then\n\
    \    local result=\"${result}]\"\n  fi\n  echo ${result}", "  local list=\"$1\"\
    \n  local item\n  local result=()\n  for item in $list; do\n    if [[ $item -gt\
    \ 0 ]]; then\n      result+=($item)\n    fi\n  done\n  echo \"${result[@]}\"",
  "  for number in $1; do\n    if [[ $number =~ ^[0-9]+$ ]]; then\n      echo \"\\\
    \"$number\\\"\"\n    fi\n  done", "  echo $1 | tr ' ' '\\n' | tr '\\n' ' ' | sed\
    \ -r 's/-[0-9]+//g' | tr ' ' '\\n' | tr '\\n' ' ' | sed -r 's/[0-9]+/'\"'\"'&'\"\
    '\"'/g' | sed -r 's/^ *//' | sed -r 's/ *$//' | sed -r 's/^ *//' | sed -r 's/\
    \ *$//' | sed -r 's/ +/ /g'", "  echo \"$1\" | tr \" \" \"\\n\" |\n  while read\
    \ x; do\n    if [ $x -ge 0 ]; then\n      echo -n '\"'$x'\"'\n      echo -n \"\
    \ \"\n    fi\n  done", "  python3 -c \"\n# Read from stdin.\nimport sys\nint_list\
    \ = sys.stdin.read().split()\n# Print only positive integers.\nsys.stdout.write('\
    \ '.join([i for i in int_list if int(i) > 0]))\n\" <<< \"$1\"", "    echo $1 |\
    \ tr ' ' '\\n' | grep -P '^\\d+$' | tr '\\n' ' ' | sed 's/^ *//g' | sed 's/ *$//g'",
  "    local IFS=$' '\n    local n\n    for n in $1; do\n        [[ $n -ge 0 ]] &&\
    \ echo $n\n    done", "  local argument=\"$1\"\n  mapfile -t list <<< \"$argument\"\
    \n  local filtered=()\n  for value in \"${list[@]}\"; do\n    if [[ $value -ge\
    \ 0 ]]; then\n      filtered+=(\"$value\")\n    fi\n  done\n  join_by ' ' \"${filtered[@]}\"",
  "    echo \"$1\" | tr ' ' '\\n' | grep -v \"^-\" | tr '\\n' ' ' | sed 's/ $//'",
  "    local val=\"$1\"\n    echo \"$val\" | tr ' ' '\\n' | grep '^[0-9]*[1-9][0-9]*$'\
    \ | tr '\\n' ' '", "    declare -a list=($1)\n    declare -a result=()\n    for\
    \ item in \"${list[@]}\"; do\n        if [[ ${item:0:1} == \"-\" ]]; then\n  \
    \          continue\n        fi\n        result+=(\"${item}\")\n    done\n   \
    \ echo \"${result[@]}\"", "    local output=\"[\"\n    local arr=($1)\n    for\
    \ i in \"${arr[@]}\"; do\n        if [ $i -ge 0 ]; then\n            output+=\"\
    \\\"$i\\\",\"\n        fi\n    done\n    output=\"${output::-1}]\"\n    echo \"\
    $output\"", '    echo "$1" | tr " " "\n" | grep -E "^[0-9]+$" | tr "\n" " "',
  "  echo \"$1\" | tr ' ' '\\n' | grep -oP '\\d+' | grep -oP '^[1-9]\\d*$' | tr '\\\
    n' ' ' | tr -d '\\r'", "  local out=()\n  for i in $1; do\n    if [[ $i -gt 0\
    \ ]]; then\n      out+=($i)\n    fi\n  done\n  echo \"${out[@]}\"", "  echo \"\
    $@\" | tr ' ' '\\n' | grep '^[0-9]*[1-9][0-9]*$' | tr '\\n' ' '", "    if [[ \"\
    $1\" == \"\" ]]; then\n        echo '[]'\n    else\n        echo \"[\"$(echo \"\
    $1\" | awk '{$1=$1;print}' OFS='\",\"' \\\n                  | awk -F ' ' '$1>0'\
    \ \\\n                  | tr -d '\\n')\"]\"\n    fi", "  local nums=($(echo $1))\n\
    \  local positive_nums=()\n  for i in \"${nums[@]}\"; do\n    if [[ $i -gt 0 ]];\
    \ then\n      positive_nums+=(\"$i\")\n    fi\n  done\n  echo ${positive_nums[@]}",
  "  for num in $1; do\n    if [ $num -ge 0 ]; then\n      echo -n \"\\\"$num\\\"\
    \ \"\n    fi\n  done", "  # local numbers=$(echo $1 | tr \" \" \"\\n\")\n  local\
    \ numbers=($1)\n  local out=()\n  for num in ${numbers[@]}; do\n    if [ $num\
    \ -ge 0 ]; then\n      out+=($num)\n    fi\n  done\n  echo ${out[@]}", "    list=$1\n\
    \    is_pos=$(echo $list |\n            sed -e 's/ /\\n/g' |\n            awk\
    \ '$1 >= 0 {printf \"%s \", $1}')\n    echo \"[$(echo $is_pos | sed -e 's/ /\"\
    , \"/g')]\"", "    echo \"$1\" | tr ' ' '\\n' | grep -E '^[0-9]+$' | tr '\\n'\
    \ ' '", "  local space_separated_list=\"$1\"\n  local arr=()\n  IFS=\" \" read\
    \ -r -a arr <<< \"$space_separated_list\"\n  local res=()\n  for elem in \"${arr[@]}\"\
    ; do\n    if [ \"$elem\" -gt 0 ]; then\n      res+=(\"$elem\")\n    fi\n  done\n\
    \  local res_str=$(array_to_str \"${res[@]}\")\n  echo \"$res_str\"", "  local\
    \ list=\"$1\"\n  local res=()\n  for i in $list; do\n    if [ $i -ge 0 ]; then\n\
    \      res+=(\"$i\")\n    fi\n  done\n  echo $(tostr $res)", "  for n in $1; do\n\
    \    if [[ $n -ge 0 ]]; then\n      printf \"%s\\n\" \"\\\"$n\\\"\"\n    fi\n\
    \  done", "  echo \"$1\" | xargs -n1 | awk '$1 > 0 {print $1}' | xargs", "   \
    \ local res=$(echo \"$1\" | tr \" \" \"\\n\" | grep -o -P '^\\d+')\n    echo \"\
    [${res//$'\\n'/, }]\"", "    local -a numbers\n    numbers=($(echo \"$1\" | tr\
    \ ' ' '\\n'))\n    local -a positives\n    for number in \"${numbers[@]}\"; do\n\
    \        if [ $number -ge 0 ]; then\n            positives+=(\"\\\"$number\\\"\
    \")\n        fi\n    done\n    echo \"[$(join_by , \"${positives[@]}\")]\"", " \
    \   local positive=()\n    for i in $1; do\n        if [[ $i -gt 0 ]]; then\n\
    \            positive+=($i)\n        fi\n    done\n    echo ${positive[@]}", " \
    \   echo \"`echo $1 | tr ' ' '\\n' | grep -v '^-' | sed 's/^/\\\"/g' | sed 's/$/\\\
    \"/g' | tr '\\n' ' '`\"", "    declare -a arr=()\n    for i in $1; do\n      \
    \  if [ $i -ge 0 ]; then\n            arr+=($i)\n        fi\n    done\n    echo\
    \ ${arr[@]}", "    local x\n    for x in $@; do\n        if [[ ${x} -gt 0 ]];\
    \ then\n            echo -n '\"'${x}'\"'\n            echo -n ' '\n        fi\n\
    \    done", "  local LIST=$1\n  local ALL_POSITIVE=()\n  for VALUE in $LIST; do\n\
    \    if (( $VALUE > 0 )); then\n      ALL_POSITIVE+=($VALUE)\n    fi\n  done\n\
    \  if [[ ${#ALL_POSITIVE[@]} -eq 0 ]]; then\n    echo 'undefined'\n  else\n  \
    \  # The number of digits of the biggest positive number in the list.\n    local\
    \ MAX_LENGTH=${#ALL_POSITIVE[0]}\n    local ALL_POSITIVE_FORMATTED=()\n    for\
    \ VALUE in ${ALL_POSITIVE[@]}; do\n      local FORMAT=\n      local DIFF_LENGTH=$((MAX_LENGTH\
    \ - ${#VALUE}))\n      for (( c=0; c<${DIFF_LENGTH}; c++ )); do\n        FORMAT+='\
    \ '\n      done\n      ALL_POSITIVE_FORMATTED+=('\"'$FORMAT$VALUE'\"')\n    done\n\
    \    echo ${ALL_POSITIVE_FORMATTED[@]}\n  fi", "    echo $1 | tr ' ' '\\n' | tr\
    \ -d '[' | tr -d ']' | tr -d '\"' | grep -E \"^[0-9]+$\"", "    local -a numbers=($1)\n\
    \    local -a positive=()\n    for number in \"${numbers[@]}\"; do\n        if\
    \ (($number >= 0)); then\n            positive+=(\"$number\")\n        fi\n  \
    \  done\n    echo \"${positive[@]}\"", "  local lst\n  lst=$(echo $1 | tr ' '\
    \ '\\n' | awk '$1 > 0 { print $1 }')\n  echo \"[$(printf '\"%s\", ' $lst | sed\
    \ -e 's/,$//')]\"", "  local -r l=$(echo \"$1\" | tr \" \" \"\\n\")\n  local -r\
    \ r=$(echo \"$l\" | awk '$1 > 0 {printf \"\\\"%s\\\" \", $1}')\n  echo \"[$r]\"",
  "    echo \"$1\" | awk '{ for (i=1; i<=NF; i++) { if($i>0) print $i; } }' | \\\n\
    \        tr \"\\n\" \" \" | sed 's/ $//'", "  local list=($1)\n  local i\n  for\
    \ i in ${list[@]}; do\n    if (( i > 0 )); then\n      echo $i\n    fi\n  done",
  "    get_filtered_data \"$1\" 'if [ $data -gt 0 ]; then\n            echo $data\n\
    \        fi'", "    python3 -c \"\nimport sys\n\nfor n in sys.argv[1:]:\n    n\
    \ = int(n)\n    if n > 0:\n        print(n, end=' ')\n\" $@", '    echo "[ $(echo
    "$1" | tr " " "\n" | grep "^[0-9]*[1-9][0-9]*$" | tr "\n" " ") ]"', "  echo \"\
    [$(echo \"$1\" | tr ' ' '\\n' | grep -E \"^\\s*[0-9]+\\s*$\" | tr '\\n' ',' |\
    \ sed 's/,$//')]\"", "  local numbers=$1\n  local number\n  local positive_numbers=()\n\
    \  for number in ${numbers}; do\n    if [[ ${number} -gt 0 ]]; then\n      positive_numbers+=(${number})\n\
    \    fi\n  done\n  echo ${positive_numbers[@]}", "    echo $1 | tr \" \" \"\\\
    n\" | awk 'BEGIN {n=\"[\"; sep=\"\"} { if($1>0) {n=n\"\"sep\"\\\"\"$1\"\\\"\"\
    ; sep=\", \"} } END {n=n\"]\"; print n}'", "  local search=\"-\"\n  # Replace\
    \ spaces with new lines.\n  local input=$(echo \"$1\" | tr \" \" \"\\n\")\n  #\
    \ Check if the first character of each line is equal to the search character.\n\
    \  # If not, return the line.\n  echo \"$input\" | grep -v \"^$search\"", "  \
    \  local in_list=($1)\n    local out_list=()\n    for num in \"${in_list[@]}\"\
    ; do\n        if [[ \"$num\" == +(0|[1-9]) ]]; then\n            out_list+=(\"\
    $num\")\n        fi\n    done\n    array_to_json_string \"${out_list[@]}\"", " \
    \   echo \"$1\" | grep -oE '[0-9]+(\\.0+)?' | tr '\\n' ' ' | sed 's/[[:space:]]*$//'"]
stop_tokens:
- "\n}"
