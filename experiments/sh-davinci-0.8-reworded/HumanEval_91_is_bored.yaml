name: HumanEval_91_is_bored
language: sh
prompt: "#!/bin/bash\n# You'll be given a string of words, and your task is to count\
  \ the number\n# of boredoms. A boredom is a sentence that starts with the word \"\
  I\".\n# Sentences are delimited by '.', '?' or '!'.\n# For example:\n# >>> $(is_bored\
  \ \"Hello world\")\n# \"0\"\n# >>> $(is_bored \"The sky is blue. The sun is shining.\
  \ I love this weather\")\n# \"1\"\n#\n# $1 is a string\nis_bored() {\n"
tests: "}\n\ncandidate() {\n    is_bored \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
  \ $(candidate \"Hello world\") = \"0\" ]]\n    [[ $(candidate \"Is the sky blue?\"\
  ) = \"0\" ]]\n    [[ $(candidate \"I love It \\!\") = \"1\" ]]\n    [[ $(candidate\
  \ \"bIt\") = \"0\" ]]\n    [[ $(candidate \"I feel good today. I will be productive.\
  \ will kill It\") = \"2\" ]]\n    [[ $(candidate \"You and I are going for a walk\"\
  ) = \"0\" ]]\n}\n\nrun_test"
completions: ["    echo \"$1\" | awk -F. '{print $0}' | grep \"I\" | wc -l", "   \
    \ # Your code here...\n    echo \"$1\" | grep -oP \"\\bI.*?[.?!]\" | wc -l", '    echo
    "$1" | grep -oP "I\s+\K.*?[\.!?](?=\s*\w)" | wc -l', "\tlocal boredoms=$(echo\
    \ \"$1\" | tr '?' '\\n' | tr '!' '\\n' | grep '^I' | wc -l)\n\techo $boredoms",
  "  echo \"$1\" | sed -n \"s/I/ /g p\" | awk '{print NF}'", '    echo "$1" | egrep
    -o "I " | wc -l', "    echo $(tr -d ' \\t\\n\\r' <<< \"$1\" | grep -o \"I\" |\
    \ wc -l)", '  echo "$1" | grep -oPc "^I"', "    echo \"$1\" | grep -P -o '(^|[.?!])I\\\
    s' | wc -l", "  echo $1 | grep -Eo '(?<=I )\\w+' | wc -l", '  echo $1 | tr "."
    "\n" | grep -c "^I"', '  echo $(echo $1 | grep -E "\.|\?|\!" | grep -E "^I" |
    wc -l)', "\techo \"$1\" | grep -oi 'I\\s' | grep -c 'I'", '  # Your code here',
  "  local sentence=$1\n  local boredoms=$(echo $sentence | tr '[:punct:]' ' ' | grep\
    \ -c -E \"^I\")\n  echo $boredoms", '    echo "$1" | grep -o "I" | wc -l', " \
    \ echo $1 | tr -s '[:blank:]' ' ' | grep -o '^I\\s.*\\(\\.\\|\\?\\|\\!\\)' | wc\
    \ -l", '    echo "$1" | grep -c "^I"', '    echo "$1" | grep "^I" | grep -c "[\.\?\!]$"',
  '  echo "${1}" | grep -o "I[ ]*[a-zA-Z]" | wc -l', "\techo $1 | grep -o -e \"^I\"\
    \ | wc -l", "    echo $1 | awk '\n        { count = 0 }\n        { if (match($0,\
    \ /([[:space:]])I/)) { count += 1 } }\n        END { print count }\n    '", " \
    \   # Replace all '.' and '?' (below is single line)\n    awk -F '.|?' '{for(i=1;i<=NF;i++)\
    \ {split($i, a, \" \"); if(a[1] == \"I\") count++}} END {print count}'", "   \
    \ echo $1 | tr '[:upper:]' '[:lower:]' | grep -o \"i\" | wc -l", "  local first_char_index=0\n\
    \  while [[ $first_char_index -lt ${#1} ]]; do\n    if [[ $(echo \"${1:$first_char_index:1}\"\
    ) =~ ^[?.!]$ ]]; then\n      echo \"EOL found at index $first_char_index\"\n \
    \     first_char_index=$((first_char_index + 1))\n    else\n      echo \"First\
    \ char index: $first_char_index, substring: ${1:$first_char_index:4}\"\n     \
    \ if [[ $(echo \"${1:$first_char_index:4}\") =~ ^I\\ .+ ]]; then\n        echo\
    \ \"Boredom found\"\n      fi\n      first_char_index=$((first_char_index + 1))\n\
    \    fi\n  done", '  echo "$1" | grep -E "^I" | wc -l', "    echo $1 | grep -oE\
    \ '(^|\\.\\s*|\\?\\s*|!\\s*)I\\s' | wc -l", "  echo $1 | grep -o -e '^I[^\\.]*'\
    \ | wc -l", "    local word_list=$(echo $1 | tr \" \" \"\\n\")\n    local bored_count=0\n\
    \    for word in $word_list; do\n        if [[ $word == \"I\" ]]; then\n     \
    \       ((bored_count++))\n        fi\n    done\n    echo $bored_count", "   \
    \ echo \"$1\" | awk -F '[.?!]' 'BEGIN {\n        total = 0\n    }\n    {\n   \
    \     for (i = 1; i <= NF; i++) {\n            sub(/^ /, \"\", $i)\n         \
    \   if (match($i, /^I/)) {\n                total++\n            }\n        }\n\
    \    }\n    END {\n        print total\n    }'", "    echo $(echo $1 | sed 's/\\\
    . /\\.\\n/g' | grep -c '^I')", '  echo "${1}" | grep -o "I[^.?!]*[.?!]" | wc -l',
  "  local str=\"$1\"\n  local re='[A-Z][^.?!]*\\bI\\b[^.?!]*[.?!]'\n  # -o is a match\n\
    \  # -E is extended regex\n  # -c is count\n  echo $str | grep -E -o \"$re\" |\
    \ grep -c \"\"", "    declare -i counter\n    counter=0\n    for var in ${@:2}\n\
    \    do\n        if [[ $var == I* ]]\n        then\n            counter=$counter+1\n\
    \        fi\n    done\n    # echo \"counter is $counter\"\n    echo $counter",
  "    echo \"$1\" | awk -F '[ !?.]' '$1 == \"I\" {n++} END {print n}'", "    echo\
    \ \"$1\" | tr -c '[:alnum:]\\n' ' ' | tr '[:upper:]' '[:lower:]' |\n    tr -s\
    \ ' ' | sed -e 's/\\s\\s*/\\n/g' | grep '^i\\|[.!?]' | grep -c '^i'", "\techo\
    \ \"${1}\" |\n\t\tgrep -oi -e '^I ' |\n\t\twc -l", '  echo "$1" | grep -o -P "(?<=\wI\s).*?(?=\.|\?|!)"
    | wc -l', "    echo \"${1}\" | awk 'BEGIN { RS=\"\\.|\\?|\\!\"; FS=\" \"; } {\
    \ for (i=1; i<=NF; i++) { if ($i == \"I\") { count++ } } } END { print count }'",
  "\t# IFS is the internal field separator. It tells the shell how to split\n\t# values.\
    \ By default, IFS is \\n (newline). Here, I am setting it to\n\t# space in order\
    \ to split sentences.\n\tlocal IFS=\".\"\n\t# I am reading the string into a variable\
    \ called sentences.\n\t# Because I want to make sure each sentence is counted\
    \ properly,\n\t# I am appending a period to the end of the string.\n\tlocal sentences=\"\
    $1.\"\n\t# This will save the original IFS value, so I can restore it later.\n\
    \tlocal original_IFS=$IFS\n\t# This will count the number of sentences (which\
    \ is the same as the\n\t# number of boredoms).\n\tlocal boredoms=0\n\t# For each\
    \ sentence in the string, do the following.\n\tfor sentence in $sentences; do\n\
    \t\t# If the sentence begins with the word \"I\", increment boredoms.\n\t\tif\
    \ [[ $sentence == I* ]]; then\n\t\t\t((boredoms++))\n\t\tfi\n\tdone\n\t# After\
    \ the loop is over, restore the original IFS value.\n\tIFS=$original_IFS\n\t#\
    \ Return the number of boredoms.\n\techo $boredoms", "\t#\n\t# YOUR CODE HERE\n\
    \t#", '  echo "$1" | grep -o "I.*[\.\?\!]\|I" | wc -l', "  echo \"$1\" | awk 'BEGIN\
    \ { FS = \"[!.?]\" } { for (i = 1; i <= NF; i++) { if ( $i ~ /^ *I *$/ ) { bored\
    \ += 1 }}} END { print bored }'", "    echo $1 | tr -cd '!.' | wc -c", "    echo\
    \ $1 | sed -e 's/[^!?.]//g' | tr -d '\\n' | tr '!' '.' |\n        tr '?' '.' |\
    \ sed -e 's/\\./\\n/g' | grep '^I' | wc -l", "  echo \"$1\" | grep -o -P '\\bI\\\
    b(?=.*(\\.|\\?|\\!))' | wc -l", "    echo \"${1}\" | sed -n -e 's/[^\\.]*\\.//gp'\
    \ | sed -n -e 's/^ I/I/gp' | wc -l", "  echo \"$1\" | tr -s '[:space:]' '\\n'\
    \ | grep -c \"^I\"", '  echo "$1" | grep -o "^I" | wc -l', "    # Complete this\n\
    \    echo \"$1\" | grep -o 'I.*\\.\\?\\!' | wc -l", "  result=$(grep -o \"I\"\
    \ <<< $1 | wc -l)\n  echo \"$result\"", "  # Your code here\n  echo \"Not yet\
    \ implemented.\"", "\techo \"$1\" | tr '?' '\\n' | tr '!' '\\n' | grep -c \"^[\
    \ \\t]*I.*\"", '  echo $1 | grep -oP "I \w+[\.\?\!]*" | wc -l', "    echo $1 |\
    \ awk -F'[?!.]' '{print NF}'", '    echo "${1}" | grep -o -i "^i[ ]\+[a-z]" |
    wc -l', '  echo "$1" | grep -o "I[[:space:]]" | wc -l', "\tlocal boredoms=$(echo\
    \ $1 | grep -o '\\.\\?\\!\\?\\s*I' | wc -l)\n\techo $boredoms", '    echo "$1"
    | tr -d "[^I.?!]" | grep -o "I[^?!.]*[.?!]" | wc -l', "    echo \"$1\" | awk 'BEGIN\
    \ { RS=\"[.?!]\" } { if ($1 == \"I\") n++ } END { print n }'", "  echo \"$1\"\
    \ | grep -o '\\<I\\>' | wc -l", "  local string=$1\n  local number_of_boredoms=0\n\
    \  local -a sentences\n\n  # Split string into sentences\n  IFS='?!.' read -r\
    \ -a sentences <<< \"$string\"\n\n  # Count sentences that start with \"I\"\n\
    \  for sentence in \"${sentences[@]}\"; do\n    local first_word=${sentence%%\
    \ *}\n    if [[ \"$first_word\" == \"I\" ]]; then\n      number_of_boredoms=$((number_of_boredoms\
    \ + 1))\n    fi\n  done\n\n  echo \"$number_of_boredoms\"", "    # Write your\
    \ code here\n    local input=$1\n    local count=0\n    IFS='.'\n    for sen in\
    \ $input; do\n        if [[ $sen == I* ]]; then\n            count=$(($count+1))\n\
    \        fi\n    done\n    echo $count", "  if [ $# -lt 1 ]; then\n    echo \"\
    USAGE: $(basename $0) <string>\"\n    exit 1\n  fi\n  words=$1\n  echo \"$words\"\
    \ | tr -c '[:upper:]' '[\\n*]' | grep -c '^I'", "  # Save the  I and the sentence\
    \ that follows in an array.\n  I_sentence_array=( $(echo \"$1\" | sed 's/\\.\\\
    s*\\(I\\)/\\1/g' | tr '.' '\\n' | grep '^I') )\n  for sentence in \"${I_sentence_array[@]}\"\
    ; do\n    echo \"$sentence\" | grep '[^I]*$' > /dev/null # Check if it's just\
    \ I\n    if [ $? -eq 0 ]; then\n      echo \"0\"\n      exit\n    fi\n  done\n\
    \  echo \"1\"", "  echo \"$1\" | grep -o '\\(^I\\|[\\.,?!]\\s*I\\)' | grep -c\
    \ 'I'", '  echo $1 | grep -o -i "i[^.!?]*[.!?]" | wc -l', "    echo \"$1\" | tr\
    \ -cd '\\n!' | tr -d '\\t\\n' | grep -o 'I[[:space:]]' | wc -l", "  # Start by\
    \ splitting the string on the delimiters.\n  IFS=$'\\.'\n  for sentence in $1;\
    \ do\n    # Remove all non-alpha characters and make it lower case.\n    sentence=$(echo\
    \ \"$sentence\" | tr -d '[:digit:]' | tr -d '[:punct:]' | tr '[:upper:]' '[:lower:]')\n\
    \    # Pick the first word (might be I or just blank)\n    first=$(echo \"$sentence\"\
    \ | cut -d \" \" -f 1)\n    # If it's I, then add one to the boredom counter.\n\
    \    if [ \"$first\" == \"i\" ]; then\n      let counter++\n    fi\n  done\n \
    \ echo \"$counter\"", '  echo $(echo $1 | grep -o "I" | wc -l)', "    # number\
    \ of boredoms\n    res=0\n    for word in $(echo $1 | tr \" \" \"\\n\"); do\n\
    \        if [[ $word == \"I\" ]]; then\n            res=$((res+1))\n        fi\n\
    \    done\n    echo $res", '  echo $1 | grep -c "I "', '    echo "$1" | grep -o
    "I.*" | grep -c ".*"', "  # hello world -> [\"hello world\"]\n  # hello.world\
    \ -> [\"hello\", \"world\"]\n  # hello?world -> [\"hello\", \"world\"]\n  # hello!world\
    \ -> [\"hello\", \"world\"]\n  # hello\\nworld -> [\"hello\", \"world\"]\n  sentences=$(echo\
    \ \"$1\" | tr '.' '\\n' | tr '?' '\\n' | tr '!' '\\n')\n  for sentence in $sentences;\
    \ do\n    if [[ \"$sentence\" = \"I\"* ]]; then\n      echo \"1\"\n      return\n\
    \    fi\n  done\n  echo \"0\"", "    echo \"$1\" | tr -s \"?!.\" \"\\n\" | grep\
    \ -c '^I'", "    echo \"$1\" | tr -d '.' | tr -d '?' | tr -d '!' | sed 's/^.*I/I/'\
    \ | wc -w", "  echo $1 | tr ' ' '\\n' | grep -c -e '^I$' -e '^I[.!?]$'", '    echo
    "$1" | grep -o "I[^.]*[.!?]" | wc -l', "    echo $1 | sed -e 's/[^I]//g' | wc\
    \ -c", "    #\n    # Put your implementation here\n    #\n    echo \"0\"", " \
    \   local sentence=${1:-}\n    # split into sentences\n    local sents=(${sentence//[.?!]/\
    \ })\n    # count the number of boredoms\n    local boredoms=$(echo \"${sents[@]}\"\
    \ | grep -c '^I')\n    echo \"$boredoms\"", '    echo "$1" | grep -i "^I" | grep
    -o "\." | wc -l', "    local sum=0\n    while read -r line\n    do\n        if\
    \ [[ \"$line\" =~ ^I.* ]]\n        then\n            sum=$((sum+1))\n        fi\n\
    \    done <<< \"$1\"\n    echo \"$sum\"", "  echo \"$1\" | tr '?' '.' | tr '!'\
    \ '.' | sed -n 's/\\(^I\\)[^.]*\\./\\1 /p' | wc -w", "    local str=\"$1\"\n \
    \   echo \"${str}\" | grep -c \"^I\"", "  local sentence\n  local sentences\n\
    \  local num=0\n  sentences=$(echo \"$1\" | tr '\\n' '.')\n  sentences=$(echo\
    \ \"$sentences\" | tr '?' '.')\n  sentences=$(echo \"$sentences\" | tr '!' '.')\n\
    \  sentences=$(echo \"$sentences\" | sed -e 's/\\.\\./\\./g')\n  sentences=$(echo\
    \ \"$sentences\" | sed -e 's/^\\./ /g')\n  sentences=$(echo \"$sentences\" | sed\
    \ -e 's/\\.$/ /g')\n  for sentence in $sentences; do\n    if [[ \"$sentence\"\
    \ =~ ^[[:space:]]*I[[:space:]] ]]; then\n      ((num++))\n    fi\n  done\n  echo\
    \ \"$num\"", '  echo "$1" | grep -oE "^I\b" | wc -l', "\t# Add your code here",
  "    echo $1 | grep -o '\\.\\?\\!\\?' | wc -l", "\tlocal boredoms=$(echo $1 | grep\
    \ -Eio '^I.*[\\.|\\?|\\!]' | wc -l)\n\techo $boredoms", '    echo "$1" | grep
    -c "^I"', "  local IFS=$'.'\n\n  local string=$(echo \"$1\" | sed 's/\\.$//')\n\
    \  local arr=($string)\n  local count=0\n\n  for s in \"${arr[@]}\"; do\n    if\
    \ [[ \"$s\" =~ ^\"I\" ]]; then\n      ((count++))\n    fi\n  done\n\n  echo \"\
    $count\"", "  echo \"${1}\" | \n  tr -c '[:alnum:]!?. ' '[\\n*]' |\n  grep '^I\
    \ ' | \n  wc -l |\n  sed 's/^ *//g'", '    echo "$1" | grep -o -E "^I .*[?!.]"
    | wc -l', "  echo \"$1\" | grep -c '^I'", "  count=0\n  for word in $(echo $1\
    \ | tr \".\" \"\\n\")\n  do\n    if [[ ${word:0:1} == \"I\" ]]\n    then\n   \
    \   (( count++ ))\n    fi\n  done\n  echo \"$count\"", "  grep -oi '\\bI\\b' <<<\
    \ $1 | wc -l", '    echo "$1" | grep -o "I " | wc -l', "    local boredoms=$(echo\
    \ \"$1\" | tr -d '!' | tr -d '?' | tr -d '.' | tr ' ' '\\n' | grep -c '^I')\n\
    \    echo \"$boredoms\"", "    # String of words given\n    local str=\"$1\"\n\
    \    # Declare an empty variable\n    local count=0\n    # For each word in the\
    \ string\n    for word in $str; do\n        # If the word starts with a capital\
    \ I\n        if [[ \"$word\" =~ ^I ]]; then\n            # Increase the count\
    \ by 1\n            ((count++))\n        fi\n    done\n    # Return count\n  \
    \  echo \"$count\"", '    echo "$1" | tr -s "\n" | tr -s " " | grep -o "I " |
    wc -l', "    # your code here\n    echo ${1} | tr \".\" \"\\n\" | tr \"?\" \"\\\
    n\" | tr \"!\" \"\\n\" | grep -c '^I'", "    echo \"${1}\" | grep -c '\\([.!?]\\\
    |^\\)[ \\t]*I[ \\t]*[A-Z]'", "\techo $1 | grep -o \"I\" | wc -l", "    local input=$1\n\
    \    local count=0\n    local word=''\n    for word in $(echo \"$input\" | tr\
    \ \".\" \" \" | tr \"?\" \" \" | tr \"!\" \" \"); do\n        if [[ \"$word\"\
    \ == \"I\" ]]; then\n            ((count++))\n        fi\n    done\n    echo \"\
    $count\"", "    if [ $# -ne 1 ]; then\n        echo \"is_bored requires a string\"\
    \n        return 1\n    fi\n    # Could be a regex, but eh.\n    echo $(echo \"\
    $1\" | grep -o -i -e '\\(^I \\)\\|\\(\\.\\s*I \\)\\|\\(\\?\\s*I \\)\\|\\(\\!\\\
    s*I \\)' | wc -l)", "  if [[ $1 =~ ^I ]]; then\n    echo \"1\"\n  else\n    echo\
    \ \"0\"\n  fi", '  echo "$1" | grep -c "^I"', "  # Put your code below this line\n\
    \  echo 0\n  # Put your code above this line", "  echo \"${1}\" | tr '?' '\\n'\
    \ | tr '!' '\\n' | cut -d '.' -f 1 | sed '/^I/!d' | wc -l", "  local counter=0\n\
    \  IFS=$'\\n'\n  for line in ${1[@]}; do\n    if [[ $line =~ ^I ]]; then\n   \
    \   counter=$((counter+1))\n    fi\n  done\n  echo $counter", "  local IFS='.?!'\
    \ #the IFS declares the field separator for the loop\n  local count=0\n  for sentence\
    \ in $1\n  do\n    local first_word=$(echo $sentence | awk '{print $1}')\n   \
    \ if [ \"$first_word\" == \"I\" ]\n    then\n      count=$((count+1))\n    fi\n\
    \  done\n  echo $count", "  local num_sentences=0\n  local num_boredoms=0\n  while\
    \ read line\n  do\n    num_sentences=$(( num_sentences + 1 ))\n    if [ \"${line:0:2}\"\
    \ == \"I \" ]; then\n      num_boredoms=$(( num_boredoms + 1 ))\n    fi\n  done\
    \ <<< $(sed 's/[.!?]/&\\n/g' <<< \"$1\")\n  echo \"$num_boredoms\"", "\tif [ $#\
    \ -ne 1 ]; then\n\t\texit 1\n\tfi\n\techo \"$1\" | sed 's/[\\.\\!\\?]/\\n/g' |\
    \ grep '^[ \\t]*I' | wc -l", '  echo $1 | grep -o -P "(^|\.\s*)I" | wc -l', " \
    \ # your code here\n  # hint: use `sed` or `awk` or `grep`\n  echo $1 | awk '{print\
    \ gsub(/I/,\"\")}'", '  echo "$1" | egrep -c "^\s*I\s+"', "  echo \"$1\" | tr\
    \ -cd 'I' | wc -c", '  echo "$1" | grep -o "I" | wc -l', "    # echo \"$1\"\n\
    \    echo \"$1\" | grep \"^I\" | grep -c '\\.\\|!\\|\\?'", "    echo \"$1\" |\
    \ awk -F'[.?!]' '{for(i=1;i<=NF;i++) if($i ~ /^I/) boredoms+=1; print boredoms}'",
  '    echo "$1" | grep -oP "I\s\w*\s*\w*" | wc -l', "  echo \"$1\" | awk 'BEGIN {FS=\"\
    .|!|\\?\"; RS=\"\"}/^I/{print $1}' | wc -l", "    echo $1 | tr -c '[:alpha:]'\
    \ '\\n' | \\\n        awk '/^I$/{b++} END{print b}'", "    # replace all ? and\
    \ ! to .\n    # replace all newlines to spaces\n    # split string by '.' character\n\
    \    # grep by start with 'I' and count \n    echo $1 | sed -e 's/\\(.\\)\\{1,\\\
    }/\\./g' | sed -e 's/\\n/ /g' | tr '.' '\\n' | grep '^I' | wc -l", '    echo "$1"
    | grep -o " I " | wc -l', '  echo $1 | grep -o -i "I" | wc -l', "  local input=\"\
    $1\"\n  # Your code here\n  # Ignore test errors below until you have finished\
    \ your code.\n  # Ignore test errors above until you have finished your code.\n\
    \  echo -n \"Test errors are expected until you finish your code\" >&2\n  echo\
    \ \"$input\" | wc -l", '  echo "$1" | grep -o "I" | wc -l', "  if [[ -z $1 ]];\
    \ then\n    echo \"0\"\n  else\n    echo \"$1\" | awk 'BEGIN { RS = \"[.!?]\"\
    \ } /^[ ]*I/ { count++ } END { print count }'\n  fi", "  echo \"$1\" | grep -c\
    \ -i '^\\s*I'", "  #tr -s \" \" \" \" | tr \" \" \"\\n\" | grep -c \"^I\"\n\n\
    \  # Remove double spaces and replace with single space\n  local string=$(echo\
    \ \"$1\" | tr -s \" \" \" \")\n\n  # Replace space with new line\n  string=$(echo\
    \ \"$string\" | tr \" \" \"\\n\")\n\n  # Count the number of lines that begin\
    \ with \"I\"\n  echo \"$string\" | grep -c \"^I\"", '    # Write your code here',
  "  local input=$1\n  echo $(echo $input | tr -cd 'I' | wc -c)", "  local string=\"\
    $1\"\n  # Count the number of sentences that start with \"I\"\n  echo \"$string\"\
    \ | tr -d '[:punct:]' | sed -e 's/^I / I /g' -e 's/[\\.\\?\\!]/\\\n/g' | grep\
    \ '^ I ' | wc -l", "  echo \"$1\" | sed -n 's/^I //p' | wc -l", "  echo \"$1\"\
    \ | grep -o 'I' | wc -l", "    echo \"$1\" | awk 'BEGIN { RS = \"[.!?]\" ; count\
    \ = 0 }\n               { for (i = 1; i <= NF; i++)\n                   if (index($i,\
    \ \"I\") == 1)\n                       count++ }\n               END { print count\
    \ }'", '  echo "$1" | grep -Eo "I " | wc -l', "    local result=$(echo $1 | grep\
    \ -o -e '^I' | grep -c '')\n    echo $result", "  echo \"$1\" | tr '?' '\\n' |\
    \ tr '!' '\\n' | grep -c '^I'", "    echo $1 | grep -o 'I [^.]*' | wc -l", "\t\
    echo \"$1\" | grep -i \"^\\s*i \" | wc -l", "    echo \"$1\" | grep -o -E 'I[[:space:]]'\
    \ | wc -l", "    string=$1\n    echo $string | grep -o \"I.*\\.\" | wc -l", " \
    \   echo $1 | sed -e 's/I/\\nI/g' -e 's/[?.!]/\\n/g' | grep -c ^I", '    echo
    "$1" | grep -c -e "^I"', '  echo "$1" | grep "I " | wc -l', '  echo "$1" | grep
    -c "^I"', '    [[ $1 =~ ^I\b ]] && echo 1 || echo 0', "  # Remove special characters\n\
    \  input=$(echo $1 | tr -d '!' | tr -d '?' | tr -d '.' | tr -d ',')\n  # Remove\
    \ leading \"I\"\n  filtered=$(echo $input | sed 's/^I //')\n  # if input is equal\
    \ to filtered then there were no leading \"I\"\n  if [ \"$input\" = \"$filtered\"\
    \ ]; then\n    echo \"0\"\n  else\n    echo \"1\"\n  fi", "    echo \"$1\" | tr\
    \ -d '[:punct:]' | awk '$1 ~ /^I$/ {n++} END {print n}'", '  echo $(echo "$1"
    | grep -c "^I ")', "  echo $1 | egrep -o -i '\\bi\\b' | wc -l", '    echo "$1"
    | grep -io "i\s[^\.]*\." | wc -l', "    local boring_count\n    boring_count=$(tr\
    \ -s ' ' '\\n' | grep \"^I\" | wc -l)\n    echo \"$boring_count\"", "    echo\
    \ \"$1\" | awk 'BEGIN { FS=\"[.!?]\" } {\n        a=0\n        for (i=1; i<=NF;\
    \ i++) {\n            if ($i ~ /^I.*/) {\n                a++\n            }\n\
    \        }\n        print a\n    }'", "    # Write your solution here...\n   \
    \ echo \"$1\" | sed 's/\\./\\n/g' | sed 's/\\!/\\n/g' | sed 's/\\?/\\n/g' | grep\
    \ '^I' | wc -l", '  echo "$1" | grep -i "^i" | grep -oE "[^!.?]+" | wc -l', " \
    \ local boredoms=0\n  if [[ $1 =~ ^I ]]; then\n    ((boredoms++))\n  fi\n  if\
    \ [[ $1 =~ \\.$ ]]; then\n    is_bored $(echo $1 | cut -d . -f 2)\n  elif [[ $1\
    \ =~ \\?$ ]]; then\n    is_bored $(echo $1 | cut -d ? -f 2)\n  elif [[ $1 =~ \\\
    !$ ]]; then\n    is_bored $(echo $1 | cut -d ! -f 2)\n  fi\n  echo $boredoms",
  '  echo "${1}" | grep -o "\bI\b" | wc -l', '  echo "$1" | grep -o "^I " | wc -l',
  '    echo "$1" | grep -oE "^I [^.?!]+" | wc -l', "  # Implement me!\n  echo -n \"\
    0\"", "  # Boring code goes here.\n  echo $1 | grep -oEi \"(^|[[:space:]]+)I[[:space:]]+\"\
    \ | wc -l", "    local str=\"$1\"\n    local count=0\n    for word in ${str//!/.};\
    \ do\n        if [[ \"$word\" == \"I\"* ]]; then\n            count=$((count +\
    \ 1))\n        fi\n    done\n    echo \"$count\"", "  local sentence=\"$1\"\n\
    \  local count=0\n  local boring=false\n  local word=''\n  for word in $sentence;\
    \ do\n    if [[ $word == \"I\" ]]; then\n      boring=true\n    elif [[ \"$word\"\
    \ =~ \"\\.|\\?|\\!\" ]]; then\n      boring=false\n    fi\n    if [[ $boring ==\
    \ true ]]; then\n      (( count++ ))\n    fi\n  done\n  echo \"$count\"", "\t\
    echo $1 | tr '\\n' ' ' | grep -oP 'I\\s.*?[\\.\\!\\?]' | wc -l", "    echo \"\
    $1\" | sed -E 's/[\\.!\\?]+/\\n/g' | grep -E \"^I\" | wc -l", '  echo "$1" | grep
    -o "^I" | wc -l', "    string=$1\n    echo $string | awk '{\n                \
    \          split($0,bored,\".\")\n                          for (i in bored) {\n\
    \                              split(bored[i],bored_sentence,\" \")\n        \
    \                      if (bored_sentence[1] == \"I\") {\n                   \
    \               num_bored += 1\n                              }\n            \
    \              }\n                          print num_bored\n                \
    \       }'", "    echo \"${1}\" | grep -c '^I '", "    # your code goes here\n\
    \    printf \"%s\" \"$1\" | grep -Eo \"^I\" | wc -l", "  # Using grep's -c option,\
    \ we can count the number of times a pattern\n  # matches a string, which is exactly\
    \ what we want in this case.\n  echo $1 | grep -c \"^I \"", "    local COUNT=\"\
    0\"\n    for word in $1; do\n        if [[ \"$word\" == \"I\" ]]; then\n     \
    \       let COUNT+=1\n        fi\n    done\n    echo \"$COUNT\"", "  echo \"$1\"\
    \ | sed 's/[^\\.]*I/I/g' | grep -i '^I' | wc -l", "    echo $1 | grep -i '^i\\\
    s' | wc -l", "    echo $1 | awk -F'[.?!]' '{for(i=1;i<=NF;i++) if($i~/^[ ]*I/)\
    \ count++} END {print count}'", "  echo $1 | tr '[:space:]' '\\n' | grep -c '^I'",
  "  local str=$1\n  # TODO\n  echo \"0\"", "\tlocal IFS=$'\\n'\n\t# remove leading\
    \ and trailing spaces\n\tlocal str=\"$(echo -e \"${1}\" | xargs)\"\n\techo \"\
    ${str}\" | grep -c \"^I\"", "    echo \"${1}\" | grep -i -o -c '^I'", "    local\
    \ count\n    count=$(echo $1 | tr -cd '!' | wc -c)\n    if [ \"$count\" -gt \"\
    0\" ]; then\n        local words\n        words=$(echo $1 | tr '!' '.' | tr '?'\
    \ '.' | tr '.' ' ')\n        for word in $words; do\n            if [ \"$word\"\
    \ == \"I\" ]; then\n                let count++\n            fi\n        done\n\
    \    fi\n    echo $count", "    local number_of_sentences=$(echo \"$1\" | tr -d\
    \ '.?!' | grep -cw \"I\")\n    echo $number_of_sentences", "  echo \"$1\" | grep\
    \ -o '^I' | wc -l", '  echo "$1" | grep -i "^I" | wc -l', "  printf '%s' \"$1\"\
    \ | grep -o -i -c 'I [^.?!]*[.?!]'", "  echo \"$1\" | sed -e 's/\\./\\n/g' -e\
    \ 's/\\?/\\n/g' -e 's/\\!/\\n/g' \\\n     | grep -c '^\\s*I'", '  echo $1 | grep
    -o "I" | wc -l', '    echo "$1" | grep -o -i "I.*\." | wc -l', "  if [[ $1 =~\
    \ ^\\s*I ]]; then\n    echo \"1\"\n  else\n    echo \"0\"\n  fi", '  echo "$1"
    | grep -c "^I\b"', "  echo \"$1\" | tr '.' '\\n' | tr '?' '\\n' | tr '!' '\\n'\
    \ | grep -e '^I' | wc -l", "  echo $1 | grep -o -i '^\\s*i' | wc -l", '    echo
    $1 | grep -o -c "I"', "    echo \"${1}\" | sed -r 's/[^.]+/&\\n/g' | grep -c '^I\
    \ '", "    echo $1 | tr -d ' ' | grep -o -P '\\.|\\?|\\!' | wc -l", "    echo\
    \ \"$1\" | awk 'BEGIN { FS = \"[.!?]\" }\n        {\n            for (i = 1; i\
    \ <= NF; i++) {\n                if ($i ~ /^[ ]*I /) count++\n            }\n\
    \        }\n        END { print count }'", "    local input=$1;\n    local count=0;\n\
    \    local sentence;\n    local tmp_file=$(mktemp);\n    echo \"$input\" > $tmp_file;\n\
    \    for sentence in $(cat $tmp_file | tr '.' '\\n' | tr '?' '\\n' | tr '!' '\\\
    n' | \\\n                      grep -v '^[[:space:]]*$'); do\n        echo $sentence\
    \ | awk '{if ($1 ~ /^I$/) {print \"1\"} else {print \"0\"}}' > $tmp_file;\n  \
    \      if [[ $(cat $tmp_file) == \"1\" ]]; then\n            count=$((count +\
    \ 1));\n        fi\n    done\n    echo $count;\n    rm $tmp_file;", "  if [ $#\
    \ -eq 0 ]; then\n    echo \"Usage: $0 <string>\"\n    exit\n  fi\n  echo \"$1\"\
    \ | sed 's/\\?/\\?./g' | sed 's/\\!/\\!./g' | sed 's/\\./\\. /g' |\\\n  sed 's/^I\
    \ /&BORED /g' | tr ' ' '\\n' | grep 'BORED' | wc -l"]
stop_tokens:
- "\n}"
