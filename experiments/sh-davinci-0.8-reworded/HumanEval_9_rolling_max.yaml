name: HumanEval_9_rolling_max
language: sh
prompt: "#!/bin/bash\n# From a given list of integers, generate a list of rolling\
  \ maximum element found until given moment\n# in the sequence.\n# >>> $(rolling_max\
  \ \"1 2 3 2 3 4 2\")\n# ['\"1\"', '\"2\"', '\"3\"', '\"3\"', '\"3\"', '\"4\"', '\"\
  4\"']\n#\n# $1 is a space-separated list\nrolling_max() {\n"
tests: "}\n\ncandidate() {\n    rolling_max \"$@\"\n}\n\nset -e\nrun_test() {\n  \
  \  [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"1 2 3 4\") = \"1 2 3 4\"\
  \ ]]\n    [[ $(candidate \"4 3 2 1\") = \"4 4 4 4\" ]]\n    [[ $(candidate \"3 2\
  \ 3 100 3\") = \"3 3 3 100 100\" ]]\n}\n\nrun_test"
completions: ["    arr=($1)\n    max=${arr[0]}\n    for i in \"${arr[@]}\"\n    do\n\
    \        if [[ \"$i\" -gt \"$max\" ]]; then\n            max=$i\n        fi\n\
    \        echo \"\\\"$max\\\"\"\n    done", "  # Internal variable for storing\
    \ current max value\n  # shellcheck disable=SC2034\n  local _max\n\n  # Iterate\
    \ over the list\n  local e\n  for e in \"$@\"; do\n    # Current max is the maximum\
    \ of current and previous value\n    _max=$(echo \"$_max $e\" | awk '{print $1\
    \ > $2 ? $1 : $2}')\n    # Print result\n    echo \"\\\"$_max\\\"\"\n  done",
  "    local list=$1;\n    local maxtemp=$(echo $list | cut -d ' ' -f 1);\n    local\
    \ max=$maxtemp;\n    for i in $list; do\n        if [ $max -lt $i ]; then\n  \
    \          max=$i;\n        fi\n        echo \\\"$max\\\";\n    done", "    local\
    \ array\n    array=( $1 )\n    local size=${#array[@]}\n    local max=$(echo ${array[0]}\
    \ | bc)\n    local output=()\n    output+=( $max )\n    local i\n    for (( i=1;\
    \ i<$size; i++ )); do\n        local current=$(echo ${array[$i]} | bc)\n     \
    \   if [[ $(echo \"$max < $current\" | bc) -eq 1 ]]; then\n            max=$current\n\
    \        fi\n        output+=( $max )\n    done\n    echo \"${output[@]}\"", " \
    \ seq=$1\n  awk -v seq=\"$seq\" '\n  BEGIN {\n    split(seq, arr, \" \")\n   \
    \ for (i = 1; i <= length(arr); i++) {\n      printf \"%s\\n\", arr[i]\n     \
    \ for (j = 1; j < i; j++) {\n        if (arr[j] > arr[i]) {\n          printf\
    \ \"%s\\n\", arr[j]\n        } else {\n          printf \"%s\\n\", arr[i]\n  \
    \      }\n      }\n    }\n  }'", "    for i in $1; do\n        max=$i\n      \
    \  for j in $1; do\n            if [[ $j -gt $max ]]; then\n                max=$j\n\
    \            fi\n        done\n        echo '\"'$max'\"'\n    done", "    declare\
    \ -a rms\n    local -i rm_i=0\n    for e in ${1// / }; do\n        rms[$rm_i]=$(max\
    \ \"${rms[@]}\" \"$e\")\n        let rm_i+=1\n    done\n    printf '%s\\n' \"\
    ${rms[@]}\"", "  local max\n  local current_value\n  local max_value\n  max=0\n\
    \  while [ -n \"$1\" ]; do\n    current_value=$1\n    shift\n    if [ ${current_value}\
    \ -gt ${max} ]; then\n      max=${current_value}\n    fi\n    printf '\"%s\" '\
    \ \"${max}\"\n  done", "    local arg_list=()\n    local arg_max=0\n    for arg\
    \ in $@; do\n        if (( $arg > $arg_max )); then\n            arg_max=$arg\n\
    \        fi\n        arg_list+=(\"$arg_max\")\n    done\n    # This is tedious,\
    \ but I don't see an easier way to convert the array back to a space-separated\n\
    \    # string.\n    echo '\"'$( IFS=$'\\n'; echo \"${arg_list[*]}\" )'\"'", " \
    \   local ret=''\n    local i=0\n    local max_elem='\"1\"'\n    local seq=($1)\n\
    \    for elem in \"${seq[@]}\"; do\n        if [[ $elem -gt $max_elem ]]; then\n\
    \            max_elem=$elem\n        fi\n        ret+=\"$max_elem \"\n    done\n\
    \    echo $ret", "  local -a list=($1)\n  local local_max=${list[0]}\n  echo \"\
    \\\"$local_max\\\"\"\n  local i\n  for ((i=1; i<${#list[@]}; i++)); do\n    if\
    \ [[ ${list[$i]} -gt $local_max ]]; then\n      local_max=${list[$i]}\n    fi\n\
    \    echo \"\\\"$local_max\\\"\"\n  done", "    # Assume that the first element\
    \ is max\n    local max=$(echo \"$1\" | awk '{print $1}')\n    local list=$(echo\
    \ \"$1\" | awk '{$1=\"\"; print}')\n    local result=$(seq 0 $(echo \"$list\"\
    \ | wc -w))\n    local count=0\n    for el in $list; do\n        if [[ $el -gt\
    \ $max ]]; then\n            max=$el\n        fi\n        result[$count]=$max\n\
    \        ((count++))\n    done\n    result=$(echo ${result[@]} | tr \" \" \",\"\
    )\n    echo \"[$result]\"", "    local -n arr=$1\n    local -a maxlist\n    local\
    \ elem\n    local maxelem\n    local maxlist\n\n    if [[ ${#arr[@]} -eq 0 ]];\
    \ then\n        echo -n \"[\"\n        for i in \"${arr[@]}\"; do\n          \
    \  echo -n \"\\\"$i\\\" \"\n        done\n        echo -n \"]\"\n        return\n\
    \    fi\n\n    maxelem=${arr[0]}\n    maxlist+=(${arr[0]})\n    for (( i=1; i<${#arr[@]};\
    \ i++ )); do\n        elem=${arr[$i]}\n        if [[ \"$elem\" -gt \"$maxelem\"\
    \ ]]; then\n            maxelem=$elem\n        fi\n        maxlist+=($maxelem)\n\
    \    done\n\n    echo -n \"[\"\n    for i in \"${maxlist[@]}\"; do\n        echo\
    \ -n \"\\\"$i\\\" \"\n    done\n    echo -n \"]\"", "  local _num_list=$1\n  local\
    \ _max=0\n  local _num\n  for _num in $_num_list; do\n    echo $((_max = ($_num\
    \ > $_max) ? $_num : $_max))\n  done", "    if [ -z \"$1\" ]; then\n        echo\
    \ ''\n        return\n    fi\n\n    echo \"$1\" | awk '{\n        if (n == 0)\
    \ {\n            max = $1\n        } else {\n            max = $1 > max ? $1 :\
    \ max\n        }\n        printf(\"\\\"%s\\\" \", max)\n        n += 1\n    }'",
  "    echo $(cat) |  awk '{\n        for (i = 1; i <= NF; i++) {\n            if\
    \ (i == 1) {\n                max = $i\n            } else {\n               \
    \ if ($i > max) {\n                    max = $i\n                }\n         \
    \   }\n            printf(\"\\\"%s\\\" \", max)\n        }\n    }'", "    local\
    \ max=\"$1\"\n    while read -r a; do\n        max=\"$a\"\n        printf \"\\\
    \"%s\\\" \" \"$max\"\n    done <<< \"${@:2}\"", "    declare -a A=($1)\n    echo\
    \ \"['\"${A[0]}\"',\"\n    for ((i=1; i<${#A[@]}; i++)); do\n        echo \" $((\
    \ i == ${#A[@]}-1 ? \"\" : \", \" ))'\"$(max \"${A[$i]}\" \"${A[$((i-1))]}\")\"\
    '\"\n    done\n    echo \"]\"", "    acc=0\n    for i in $1\n    do\n        if\
    \ [ $i -gt $acc ]\n        then\n            acc=$i\n        fi\n        echo\
    \ -n \"\\\"$acc\\\" \"\n    done", "    local -a arr arr_sorted arr_sorted_i\n\
    \    arr=($1)\n    arr_sorted=($(echo \"${arr[@]}\" | xargs -n1 | sort -n))\n\
    \    for x in \"${arr[@]}\"; do\n        for i in \"${!arr_sorted[@]}\"; do\n\
    \            if [[ \"${arr_sorted[$i]}\" -eq \"$x\" ]]; then\n               \
    \ arr_sorted_i+=(\"$i\")\n                break\n            fi\n        done\n\
    \    done\n    echo \"${arr_sorted_i[@]}\" | xargs -n1 | while read i; do\n  \
    \      echo \"${arr_sorted[$i]}\"\n    done | tr '\\n' ' '", "  local list=$1\
    \ i max\n  max=$(echo $list | cut -d' ' -f1)\n  for i in $list; do\n    if [ \"\
    $i\" -gt \"$max\" ]; then\n      max=$i\n    fi\n    echo '\"'$max'\"'\n  done",
  "    OLD_IFS=\"$IFS\"\n    IFS=' '\n    arr=($*)\n    IFS=\"$OLD_IFS\"\n    max=${arr[0]}\n\
    \    echo \"\\\"$max\\\"\"\n    for elem in \"${arr[@]:1}\"; do\n        if (($elem\
    \ > $max)); then\n            max=$elem\n        fi\n        echo \"\\\"$max\\\
    \"\"\n    done", "    declare -a list=($1)\n    result=\"[\"\n    for ((i=0; i<${#list[@]};\
    \ i++)); do\n        result=\"$result$(largest_of \"${list[$i]}\" \"${list[@]:$i+1}\"\
    )\"\n        if ((i != ${#list[@]}-1)); then\n            result=\"$result, \"\
    \n        fi\n    done\n    result=\"$result]\"\n    echo \"$result\"", "    local\
    \ input_list=\"$1\"\n\n    local stack=()\n    local max_list=()\n    for i in\
    \ $input_list; do\n        stack=(\"$i\" \"${stack[@]}\")\n        max_list=(\"\
    $(max \"${stack[@]}\")\" \"${max_list[@]}\")\n    done\n\n    echo $(join \" \"\
    \ \"${max_list[@]}\")", "    local numbers=\"$1\"\n    local n\n    local i=0\n\
    \    local last_max=0\n    for n in $numbers; do\n        echo -n '\"'\n     \
    \   (( n > last_max )) && last_max=$n\n        echo -n $last_max\n        echo\
    \ '\"'\n        (( i++ ))\n    done", "  # Pre-populate the max list with the\
    \ first element\n  declare -a max_list\n  max_list[0]=$(echo \"$1\" | cut -d'\
    \ ' -f1)\n\n  # For each element in the list\n  for ((i=1; i<$(echo \"$1\" | wc\
    \ -w); i++)); do\n    # Get current value\n    value=$(echo \"$1\" | cut -d' '\
    \ -f$((i+1)))\n\n    # Set current max value\n    max_value=$(echo \"${max_list[@]}\"\
    \ | tr ' ' '\\n' | sort -rn | head -n1)\n\n    # Add it to the list of max values\n\
    \    max_list[$i]=$(echo $max_value | awk '{ if ($1>$2) { print $1 } else { print\
    \ $2 } }' - $value)\n  done\n\n  # Print the list in a format which can be used\
    \ to declare a bash array\n  echo $(printf \"[%s]\" \"$(printf '\"%s\" ' \"${max_list[@]}\"\
    )\")", "  local list=\"$1\"\n  local cur_max=$(echo \"$list\" | head -n 1)\n \
    \ local cur_max_list=\"$cur_max\"\n  shift\n\n  echo \"$list\" | while read cur_num\n\
    \  do\n    if [ \"$cur_num\" -gt \"$cur_max\" ]; then\n      cur_max=\"$cur_num\"\
    \n    fi\n    cur_max_list=\"$cur_max_list $cur_max\"\n  done\n\n  echo \"$cur_max_list\"",
  "    local seq=($1)\n    local max=${seq[0]}\n    for e in \"${seq[@]}\"; do\n \
    \       if [[ \"$e\" -gt \"$max\" ]]; then\n            max=$e\n        fi\n \
    \       echo \"\\\"$max\\\"\"\n    done", "  local list_of_elements=\"$1\"\n \
    \ local element_array=()\n  local current_max\n  while read -r element\n  do\n\
    \    element_array+=(\"$element\")\n    if [ -z \"$current_max\" ] || [ \"$element\"\
    \ -gt \"$current_max\" ]\n    then\n      current_max=\"$element\"\n    fi\n \
    \   echo \"$current_max\"\n  done <<< \"$list_of_elements\"", "    declare -a\
    \ x=($1)\n    max=${x[0]}\n    echo -n [\n    for i in ${x[@]}; do\n        if\
    \ (( i > max )); then\n            max=$i\n        fi\n        echo -n '\"'$max'\"\
    '\n        echo -n ,\n    done\n    echo -n ]", "    local max_so_far=\n    for\
    \ n in $1; do\n        if [[ -z $max_so_far || $n -gt $max_so_far ]]; then\n \
    \           max_so_far=$n\n        fi\n        echo $max_so_far\n    done", " \
    \   test -z \"$1\" && return\n\n    # For the purpose of this exercise, number\
    \ 1 is the maximum in the list.\n    max=$1\n    echo \"\\\"$max\\\"\"\n\n   \
    \ # Shift to the second element of the list.\n    shift\n    for i in $@; do\n\
    \        if [ \"$i\" -gt \"$max\" ]; then\n            max=$i\n        fi\n  \
    \      echo \"\\\"$max\\\"\"\n    done", "    local -a list=\"(${1})\";\n    local\
    \ -a max_list;\n    local max_element;\n    for i in \"${list[@]}\"; do\n    \
    \    if [ -z \"$max_element\" ] || [ \"$i\" -gt \"$max_element\" ]; then\n   \
    \         max_element=\"$i\";\n        fi;\n        max_list+=(\"$max_element\"\
    );\n    done;\n    echo \"['\\\"${max_list[*]}\\\"']\";", "    max=$1\n    shift\n\
    \    for i in $@; do\n        if [[ $i -gt $max ]]; then\n            max=$i\n\
    \        fi\n        echo -n $max\n        echo -n ' '\n    done", "  local current_max=\"\
    \"\n  # It's important to loop in a subshell so values of the subshell are not\n\
    \  # globally exposed.\n  (\n    for n in \"$@\"; do\n      ((n > current_max))\
    \ && current_max=\"$n\"\n      echo \"\\\"$current_max\\\"\"\n    done\n  )",
  "    [ $# -eq 0 ] && return\n    local result\n    IFS=\" \" read -ra nums <<< \"\
    $1\"\n    result+=( \"${nums[0]}\" )\n    local max_so_far=\"${nums[0]}\"\n  \
    \  for ((i=1; i<${#nums[@]}; i++)); do\n        if [ \"${nums[i]}\" -gt \"$max_so_far\"\
    \ ]; then\n            max_so_far=\"${nums[i]}\"\n        fi\n        result+=(\
    \ \"$max_so_far\" )\n    done\n    # print as a string\n    printf '[%s]' \"$(printf\
    \ '\"%s\", ' \"${result[@]}\")\"", "  # python -c \"$(\n  #   cat <<- EOF\n  #\
    \ from sys import stdin\n  # from itertools import accumulate\n  # from functools\
    \ import reduce\n  #\n  # def max_until(lst):\n  #   def max_accum(acc, x):\n\
    \  #     return acc if acc > x else x\n  #   return reduce(max_accum, lst)\n \
    \ #\n  # print(list(accumulate(\n  #     map(int, stdin.read().split()),\n  #\
    \     max_until\n  # )))\n  # EOF\n  # )\" <<< \"$1\"\n  local TMPFILE=$(mktemp)\n\
    \  seq $# | \\\n    xargs -I {} echo \"$1\" | \\\n    cut -d ' ' -f 1-{} | \\\n\
    \    tr ' ' '\\n' | \\\n    tr -d '\\n' | \\\n    sed 's/^/[\\\"/g' | \\\n   \
    \ sed 's/$/\\\"]/g' | \\\n    sed 's/\\][,]/],/g' | \\\n    sed '1s/^/[/' | \\\
    \n    sed '$s/$/]/' | \\\n    python -c \"import sys; print(sys.stdin.read())\"\
    \ > \"$TMPFILE\"\n  cat \"$TMPFILE\"\n  rm \"$TMPFILE\"", "    local -n n=$1\n\
    \    printf \"%s\" \"[\"\n    for (( i=0; i<${#n[@]}; i++ )); do\n        printf\
    \ \"%s\" \"[\\\"${n[i]}\\\"\"\n        for (( j=i+1; j<${#n[@]}; j++ )); do\n\
    \            if (( ${n[j]} > ${n[i]} )); then\n                printf \", \\\"\
    ${n[j]}\\\"\"\n            fi\n        done\n        printf \"]\"\n        if\
    \ (( i < ${#n[@]}-1 )); then\n            printf \", \"\n        fi\n    done\n\
    \    printf \"]\"", "    local arr=($1)\n    if [[ \"${#arr[@]}\" == 0 ]]; then\n\
    \        return 0\n    fi\n    if [[ \"${#arr[@]}\" == 1 ]]; then\n        echo\
    \ \"${arr[0]}\"\n        return 0\n    fi\n    local max=${arr[0]}\n    echo \"\
    ${max}\"\n    for ((i=1; i<${#arr[@]}; i++)); do\n        if [[ \"${arr[$i]}\"\
    \ -gt \"${max}\" ]]; then\n            max=${arr[$i]}\n        fi\n        echo\
    \ \"${max}\"\n    done", "    local i;\n    local list=();\n    for i in ${@};\
    \ do\n        echo \"${list[@]}\" | xargs printf \"%d\\n\" | sort -r -n | head\
    \ -n 1;\n        list+=(\"${i}\");\n    done;", "    declare -a A=(\"$@\")\n \
    \   local N=\"${#A[@]}\"\n    local MAX=${A[0]}\n    local I\n    echo \"\\\"\
    ${MAX}\\\"\"\n    for ((I=1; I<N; I++)); do\n        ((${A[I]}>MAX)) && MAX=${A[I]}\n\
    \        echo \"\\\"${MAX}\\\"\"\n    done", "    local input=($1)\n    local\
    \ output\n    for (( i=0; i<${#input[@]}; i++ )); do\n        if [ \"$i\" -eq\
    \ 0 ]; then\n            output=${input[$i]}\n        else\n            if [ \"\
    ${input[$i]}\" -gt \"$output\" ]; then\n                output=${input[$i]}\n\
    \            fi\n        fi\n        echo \"\\\"$output\\\"\"\n    done", "  declare\
    \ -a input_array\n  input_array=($1)\n  declare -a maxes\n  maxes=()\n  for i\
    \ in $(seq 1 ${#input_array[@]}); do\n    maxes+=(\"${input_array[$((i-1))]}\"\
    )\n    for j in $(seq $((i-1)) -1 0); do\n      if [[ \"${input_array[$((j-1))]}\"\
    \ -gt \"${maxes[$((i-1))]}\" ]]; then\n        maxes[$((i-1))]=\"${input_array[$((j-1))]}\"\
    \n      fi\n    done\n  done\n  echo -n \"[\"\n  for i in $(seq 0 $(((${#maxes[@]}-1))));\
    \ do\n    echo -n '\"'\n    echo -n \"${maxes[$i]}\"\n    echo -n '\"'\n    if\
    \ [[ $i -lt $(((${#maxes[@]}-1))) ]]; then\n      echo -n \", \"\n    fi\n  done\n\
    \  echo \"]\"", "  local array=($1)\n  local max=${array[0]}\n  local i=0\n  for\
    \ ((i=0; i<${#array[@]}; i++)); do\n    if (( \"${array[$i]}\" > \"$max\" ));\
    \ then\n      max=${array[$i]}\n    fi\n    echo '\"'$max'\"'\n  done", "    local\
    \ _begin=\"$1\"\n    local _max=${_begin[0]}\n    for _elem in \"${_begin[@]}\"\
    ; do\n        [ \"$_elem\" -gt \"$_max\" ] && _max=\"$_elem\"\n        printf\
    \ '\"%s\" ' \"$_max\"\n    done", "    local rolling_max=$1\n    shift 1\n   \
    \ for e in $@; do\n        if [ \"$e\" -gt \"$rolling_max\" ]; then\n        \
    \    rolling_max=$e\n        fi\n        echo $rolling_max\n    done", "  local\
    \ max\n  for n in $1; do\n    echo \"$max\"\n    if [[ -z \"$max\" || \"$n\" -gt\
    \ \"$max\" ]]; then\n      max=\"$n\"\n    fi\n  done", "    declare -a maxes\n\
    \    # add \"$1\" as array and iterate over it\n    for i in $(eval echo \"$1\"\
    ); do\n        if [ -z \"${maxes[$((${#maxes[@]} - 1))]}\" ]; then\n         \
    \   maxes+=(\"$i\")\n        else\n            if [ \"$i\" -gt \"${maxes[$((${#maxes[@]}\
    \ - 1))]}\" ]; then\n                maxes+=(\"$i\")\n            else\n     \
    \           maxes+=(\"${maxes[$((${#maxes[@]} - 1))]}\")\n            fi\n   \
    \     fi\n    done\n    printf '%s\\n' \"${maxes[@]}\"", "    local -a arr\n \
    \   local -i i\n    read -a arr <<< \"$1\"\n    declare -p arr | cut -d= -f2\n\
    \    for ((i=1; i<${#arr[@]}; i++)); do\n        echo -n \"\\\"${arr[i-1]}\\\"\
    \"\n        [[ \"${arr[i]}\" -gt \"${arr[i-1]}\" ]] && echo -n \" \\\"${arr[i]}\\\
    \"\" || echo -n \" \\\"${arr[i-1]}\\\"\"\n    done\n    echo", "    local max=$(echo\
    \ \"$1\" | head -n 1)\n    while read element; do\n        if [ \"$element\" -gt\
    \ \"$max\" ]; then\n            max=$element\n        fi\n        echo \"$max\"\
    \n    done <<< \"$1\"", "  local input_array=(\"$@\")\n  local output_array\n\
    \  local local_max=${input_array[0]}\n  output_array+=(\"$local_max\")\n  for\
    \ (( i=1; i<${#input_array[@]}; i++ )); do\n    if (( ${input_array[$i]} > $local_max\
    \ )); then\n      local_max=${input_array[$i]}\n    fi\n    output_array+=(\"\
    $local_max\")\n  done\n  echo \"${output_array[@]}\"", "  max=0\n  for i in $1;\
    \ do\n    if [ $i -gt $max ]; then\n      max=$i\n    fi\n    echo $max\n  done",
  "    declare -a arr=(${1})\n    local -i max=${arr[0]}\n    echo -n \"[\"\n    for\
    \ elem in \"${arr[@]}\"; do\n        echo -n \"\\\"${max}\\\"\"\n        if [[\
    \ ${elem} -gt ${max} ]]; then\n            max=${elem}\n        fi\n        echo\
    \ -n \", \"\n    done\n    echo -n \"]\"", "    local sequence=( $1 )\n    local\
    \ answer=\"\"\n    local current_max=\"\"\n    for element in \"${sequence[@]}\"\
    ; do\n        if [[ -z $current_max ]]; then\n            current_max=$element\n\
    \        else\n            if [[ $element -gt $current_max ]]; then\n        \
    \        current_max=$element\n            fi\n        fi\n        answer=\"$answer\
    \ \\\"$current_max\\\"\"\n    done\n    echo $answer", "  local array=${1// /,}\n\
    \  echo \"$(echo -n \"echo [\\\"$(echo ${array} | sed -e 's/\\([0-9]\\+\\)/\\\
    1\" \",/g')\\\"] | python -c 'import sys; a = sys.stdin.readline().strip(); print\
    \ \\\",\\\".join([str(max(map(int, a[:i+1].split(\\\",\\\")))) for i in range(len(a.split(\\\
    \",\\\")))])'\" | bash)\"", "  local input=($1)\n  local last_max=${input[0]}\n\
    \  local last_max_index=0\n  local i\n  printf '\"%s\"' \"$last_max\"\n  for ((i=1;\
    \ i<${#input[@]}; i++)); do\n    if ((last_max < input[i])); then\n      last_max=${input[i]}\n\
    \      last_max_index=$i\n    fi\n    printf ', \"%s\"' \"$last_max\"\n  done",
  "  local rolling_max_VAR\n  rolling_max_VAR=$(echo \"$1\" | python -c '\nimport\
    \ sys\nfor x in map(int, sys.stdin.readline().split()):\n  print \"max(%d, %s)\"\
    \ % (x, \" \".join(sys.stdin.readline().split()))\n')\n  echo \"($rolling_max_VAR)\"",
  "    max=\"$1\"\n    for value in $1; do\n        max=\"$value $max\"\n        echo\
    \ -n '\"$max\" '\n    done", "    local tail_i=0\n    local tail=$(tail +${tail_i}\
    \ <<< \"$1\")\n    local max=$(head -n 1 <<< \"$1\")\n    local s=\n    local\
    \ r=\n\n    for i in $(seq 0 $((${#1}-1))); do\n        local n=$(printf '%s'\
    \ \"${1:$i:1}\")\n        if [[ ${n} -gt ${max} ]]; then\n            max=${n}\n\
    \        fi\n        printf '%s\\n' \"${max}\"\n    done", "  for x in $(echo\
    \ \"$1\"); do\n    echo -n $x\n    echo -n \",\"\n    echo -n $max\n    echo -n\
    \ \";\"\n    if [ -z \"$max\" ] || [ \"$x\" -gt \"$max\" ]; then\n      max=$x\n\
    \    fi\n  done", "  list=$(echo \"$1\" | tr \" \" \"\\n\")\n  echo \"$list\"\
    \ | awk '\n  BEGIN {\n    max=0;\n  }\n  {\n    if ($1 > max) {\n      max = $1;\n\
    \    }\n    printf \"%s\\n\", max;\n  }'", "  arg=\"$1\"\n  max=-1\n  for i in\
    \ $arg; do\n    if [[ $i -gt $max ]]; then\n      max=$i\n    fi\n    echo -n\
    \ '\"'\n    echo -n $max\n    echo -n '\" '\n  done", "    # The Python one-liner\
    \ that solves this problem is this one:\n    # python -c 'import sys;from itertools\
    \ import *;from collections import *;print([max(islice(a,i+1)) for i,a in enumerate(accumulate(map(int,sys.argv[1:])))])'\
    \ \"$1\"\n    #\n    # The problem is that `islice` does not work well with stdin:\n\
    \    #   $  echo \"1 2 3\" | python -c 'import sys;from itertools import *;from\
    \ collections import *;print([max(islice(a,i+1)) for i,a in enumerate(accumulate(map(int,sys.stdin)))])'\n\
    \    #\n    # The python script instead works with stdin, but the result needs\
    \ to be transformed before being\n    # returned:\n    python <<PYTHON\nfrom itertools\
    \ import *\nfrom collections import *\nimport sys\n\nmaxs = [max(islice(a,i+1))\
    \ for i,a in enumerate(accumulate(map(int,sys.stdin)))]\nprint(\"[%s]\" % \",\
    \ \".join('\"%s\"' % str(x) for x in maxs))\nPYTHON", "  local max\n  local current\n\
    \n  for elem in $1; do\n    current=$elem\n    if [[ -z $max ]] || [[ $current\
    \ -gt $max ]]; then\n      max=$current\n    fi\n    echo \"\\\"$max\\\"\"\n \
    \ done", "    local list=\"\"\n    local max=\"\"\n    for i in $1; do\n     \
    \   max=$i\n        if [ -z \"$list\" ]; then\n            list=\"'$max'\"\n \
    \       else\n            list=\"$list,'$max'\"\n        fi\n        for j in\
    \ $list; do\n            if [ \"$j\" -gt \"$max\" ]; then\n                max=$j\n\
    \            fi\n        done\n        list=$(echo \"$list\" | sed \"s/'$i'/'$max'/\"\
    )\n    done\n    echo \"$list\"", "  local seq=$1\n  local max=$(echo $seq | cut\
    \ -d \" \" -f 1)\n  echo \\\"$max\\\"\n  for v in $seq; do\n    if [ $v -gt $max\
    \ ]; then\n      max=$v\n    fi\n    echo \\\"$max\\\"\n  done", "    local max;\n\
    \    max=0;\n    for i in $(echo $1); do\n        if [[ $i -gt $max ]]; then\n\
    \            max=$i;\n        fi;\n        echo \"\\\"$max\\\"\";\n    done;",
  "    seq -s ' ' $1 | \\\n        while read c; do\n            if [ -z \"$max\"\
    \ ]; then\n                max=$c\n            else\n                if ((c >\
    \ max)); then\n                    max=$c\n                fi\n            fi\n\
    \            echo \"$max\"\n        done", "  local max=0\n  local IFS=' ' arr=($1)\n\
    \  for n in \"${arr[@]}\"; do\n    max=$(($n > $max ? $n : $max))\n    echo '\"\
    '$max'\"'\n  done", "    local buf=\n    for i in $1; do\n        if [[ -z $buf\
    \ ]]; then\n            buf=$i\n        else\n            if (( $i > $buf ));\
    \ then\n                buf=$i\n            fi\n        fi\n        echo -n '\"\
    '$buf'\"'\n        echo -n ' '\n    done", "    local first=\"true\"\n    local\
    \ cur_max=\"${1%% *}\"\n    local out=\"[\\\"${cur_max}\\\"\"\n    shift\n   \
    \ for x in \"$@\"; do\n        if [[ \"$x\" -gt \"$cur_max\" ]]; then\n      \
    \      cur_max=\"$x\"\n        fi\n        out+=\", \\\"${cur_max}\\\"\"\n   \
    \ done\n    echo \"${out}]\"", "  max=$1\n  echo -n '[\\\"$max\\\"'\n  shift\n\
    \  for n in $@; do\n    ((n > max)) && max=$n\n    echo -n ', \\\"$max\\\"'\n\
    \  done\n  echo ']'", "  local -a input=($1)\n  local -a results=()\n  local current_max=${input[0]}\n\
    \  local temp_current_max\n  for ((i=0; i<${#input[@]}; i++)); do\n    temp_current_max=${input[$i]}\n\
    \    if [[ \"$temp_current_max\" -gt \"$current_max\" ]]; then\n      current_max=\"\
    $temp_current_max\"\n    fi\n    results[$i]=\"$current_max\"\n  done\n  printf\
    \ \"[%s]\" \"$(printf '\"%s\", ' \"${results[@]}\")\"", "  if [ -z \"$1\" ]; then\n\
    \    echo \"Error: rolling_max requires a space-separated list of integers\"\n\
    \    exit 1\n  fi\n  local max=$(echo \"$1\" | head -n 1)\n  local list=()\n \
    \ for value in $1; do\n    if (( max < value )); then\n      max=$value\n    fi\n\
    \    list+=(\"$max\")\n  done\n  echo \"${list[@]}\"", "  local array=($1)\n \
    \ local max=0\n  for i in ${array[@]}; do\n    if [[ $i -gt $max ]]; then\n  \
    \    max=$i\n    fi\n    echo '\"'$max'\"'\n  done", "    local list=($1)\n  \
    \  local max=${list[0]}\n    echo -n \"$max\"\n    for i in \"${list[@]:1}\";\
    \ do\n        if (( i > max )); then\n            max=$i\n        fi\n       \
    \ echo -n \" $max\"\n    done", "    local cmax=\"$1\"\n    shift 1\n    local\
    \ localmax=0\n    for cmax in $*; do\n        [ \"$cmax\" -gt \"$localmax\" ]\
    \ && localmax=\"$cmax\"\n        echo \"$localmax\"\n    done", "    local max\n\
    \    max=$(echo \"$1\" | head -n 1)\n    echo \"$1\" | while read element; do\n\
    \        if [[ $element -gt $max ]]; then\n            max=$element\n        fi\n\
    \        echo \"\\\"$max\\\"\"\n    done", "    local max=\"$1\"\n    shift\n\
    \    for n in $@; do\n        if [[ \"$n\" -gt \"$max\" ]]; then\n           \
    \ max=\"$n\"\n        fi\n        echo -n '\"'$max'\"'\n        echo -n ' '\n\
    \    done", "    local max=0\n    local value\n    echo -n \"[\"\n    for value\
    \ in $@; do\n        if [ \"$value\" -gt \"$max\" ]; then\n            max=\"\
    $value\"\n        fi\n        echo -n \"\\\"$max\\\"\"\n        if [ \"$value\"\
    \ != \"$@\" ]; then\n            echo -n \", \"\n        fi\n    done\n    echo\
    \ \"]\"", "    if [ -z \"$1\" ]; then\n        echo \"\"\n        return\n   \
    \ fi\n\n    local seq=\"$@\"\n    local max\n    local max_i\n    local i\n  \
    \  for ((i=0;i<${#seq};i++)); do\n        if [ -z \"$max\" ] || [ \"${seq:$i:1}\"\
    \ -gt \"$max\" ]; then\n            max=\"${seq:$i:1}\"\n            max_i=$i\n\
    \        fi\n        echo -n \"\\\"$max\\\" \"\n    done\n    echo", "  local\
    \ -a arr\n  local -r list=($1)\n  local -i i=0\n\n  for ((i=0; i<${#list[@]};\
    \ i++)); do\n    # Compare max elements from the previous iteration with current\
    \ element\n    if (($i > 0)); then\n      arr[$i]=$(max \"${arr[$(($i-1))]}\"\
    \ \"${list[$i]}\")\n    else\n      arr[$i]=${list[$i]}\n    fi\n  done\n\n  echo\
    \ \"${arr[@]}\"", "  local list=\"$1\"\n  local max=0\n\n  while read -r n; do\n\
    \    if (( n > max )); then\n      max=\"$n\"\n    fi\n    echo \"$max\"\n  done\
    \ <<< \"$list\"", "  raw_list=\"$1\"\n  max_so_far=\"$(echo \"${raw_list}\" |\
    \ head -n 1)\"\n  result=\"${max_so_far}\"\n  echo \"${raw_list}\" | sed '1d'\
    \ | while read line; do\n    if [ \"${line}\" -gt \"${max_so_far}\" ]; then\n\
    \      max_so_far=\"${line}\"\n    fi\n    result=\"${result} ${max_so_far}\"\n\
    \  done\n  echo \"${result}\"", "    # use first element if no argument provided\n\
    \    if [[ -z \"$1\" ]]; then\n        echo -n '\"1\"'\n        return\n    fi\n\
    \n    local current_max=0\n    for element in $1; do\n        if [[ \"$element\"\
    \ -gt \"$current_max\" ]]; then\n            current_max=\"$element\"\n      \
    \  fi\n        echo -n \"\\\"$current_max\\\" \"\n    done", "    local max=\n\
    \    for v in $1\n    do\n        if [[ ! $max || $v -gt $max ]]\n        then\n\
    \            max=$v\n        fi\n        echo \\\"$max\\\"\n    done", "  local\
    \ max\n  local list=($1)\n  local length=${#list[@]}\n  local i=0\n  local out\n\
    \  for i in $(seq 0 $((length-1))); do\n    max=${list[$i]}\n    for j in $(seq\
    \ $((i+1)) $((length-1))); do\n      local current=${list[$j]}\n      if [[ $current\
    \ -gt $max ]]; then\n        max=$current\n      fi\n    done\n    if [[ -z $out\
    \ ]]; then\n      out=$max\n    else\n      out=\"$out $max\"\n    fi\n  done\n\
    \  echo $out", "    # Initial condition, no max found\n    local max=-1\n    #\
    \ Parse each input argument\n    for num in $1; do\n        if [ \"$num\" -gt\
    \ \"$max\" ]; then\n            # Update max value\n            max=$num\n   \
    \     fi\n        # Print maximum value until given moment in the list\n     \
    \   echo $max\n    done", "  OLDIFS=\"$IFS\"\n  IFS=' '\n  for i in $1; do\n \
    \   if [[ $i -ge $max ]]; then\n      max=$i\n    fi\n    echo '\"'$max'\"'\n\
    \  done\n  IFS=\"$OLDIFS\"", "    local -a max_so_far\n    local -a elems\n  \
    \  local max\n\n    elems=( $1 )\n    max=${elems[0]}\n    max_so_far=( \"$max\"\
    \ )\n\n    for i in \"${elems[@]:1}\"; do\n        max=$(gmp max $max $i)\n  \
    \      max_so_far+=( \"$max\" )\n    done\n\n    echo \"${max_so_far[@]}\"", " \
    \ local max=''\n  for i in $1; do\n    if [[ -z $max ]]; then\n      max=$i\n\
    \    elif [[ $i -gt $max ]]; then\n      max=$i\n    fi\n    echo $max\n  done",
  "    local arr\n    arr=($1)\n    local max=${arr[0]}\n    local i\n    for i in\
    \ \"${arr[@]}\"; do\n        if (( i > max )); then\n            max=$i\n    \
    \    fi\n        echo \"\\\"$max\\\"\"\n    done", "    local -a input=(\"$@\"\
    )\n    local -a output\n    output[0]=${input[0]}\n    echo \"output[0]=${output[0]}\"\
    \n    local max=${input[0]}\n    for i in $(seq 1 $((${#input[@]}-1))); do\n \
    \       if [[ \"${input[$i]}\" -gt \"$max\" ]]; then\n            max=${input[$i]}\n\
    \        fi\n        output[$i]=$max\n    done\n    echo \"${output[@]}\"", " \
    \   local -a list_\n    local -a max_\n\n    list_=(${1})\n    max_=(${1})\n\n\
    \    for ((i=1; i<${#list_[@]}; i++)); do\n        if [[ \"${list_[$i]}\" -gt\
    \ \"${max_[$(($i-1))]}\" ]]; then\n            max_[$i]=\"${list_[$i]}\"\n   \
    \     else\n            max_[$i]=\"${max_[$(($i-1))]}\"\n        fi\n    done\n\
    \n    echo \"${max_[@]}\"", "    awk -v max=-1 '{ \n        if (max < $1) { max\
    \ = $1 }\n        printf(\",\\\"%s\\\"\", max)\n    } END { print \"\" }' <<<\
    \ \"$1\"", "  local -n __ROLLING_MAX_result=$1\n  shift\n  local current=0\n \
    \ for item in \"$@\"; do\n    if (( $item > $current )); then\n      current=$item\n\
    \    fi\n    __ROLLING_MAX_result+=($current)\n  done", "  local -a a_list=($1)\n\
    \  local -a out\n  local i\n  local max\n  for ((i=0; i<${#a_list[@]}; i++));\
    \ do\n    max=$(max \"${a_list[$i]}\" $max)\n    out[$i]=$max\n  done\n  # Convert\
    \ output array to printable list\n  echo \"$(print_list \"${out[@]}\")\"", " \
    \   local current_max=0\n    local buffer=\"\"\n    for i in $@; do\n        if\
    \ [ $i -gt $current_max ]; then\n            current_max=$i\n        fi\n    \
    \    buffer=\"$buffer $current_max\"\n    done\n    echo \"[$(echo $buffer | sed\
    \ 's/^\\s*//g' | sed 's/\\s\\+/\\, \\\"/g')]\"", "    max_val=0\n    for val in\
    \ $1; do\n        (( val > max_val )) && max_val=$val\n        echo \\\"$max_val\\\
    \"\n    done", "    ARRAY=($1)\n    #roll_max=${ARRAY[0]}\n    roll_max=$1\n \
    \   echo '['\"\\\"$roll_max\\\"\"\n    for i in ${ARRAY[@]:1}; do\n        if\
    \ [[ \"$i\" -gt \"$roll_max\" ]]; then\n            roll_max=$i\n        fi\n\
    \        echo ','\"\\\"$roll_max\\\"\"\n    done\n    echo ']'", "    max=\n \
    \   for num in $1\n    do\n        if [[ \"$num\" > \"$max\" ]]\n        then\n\
    \            max=\"$num\"\n        fi\n        echo \"\\\"$max\\\"\"\n    done",
  "    arr=($1)\n    for ((i=0; i<${#arr[@]}; i++)); do\n        max=${arr[0]}\n \
    \       for ((j=0; j<=i; j++)); do\n            if [[ ${arr[j]} -gt $max ]]; then\n\
    \                max=${arr[j]}\n            fi\n        done\n        echo '\"\
    '$max'\"'\n    done", "  rolling_max=\"\"\n  for val in $1; do\n    if [ \"$rolling_max\"\
    \ = \"\" ] || [ \"$val\" -gt \"$rolling_max\" ]; then\n      rolling_max=\"$val\"\
    \n    fi\n    echo '\"'\"$rolling_max\"'\"'\n  done", "    local elements=($1)\n\
    \    local rolling_max=${elements[0]}\n    echo -n \"[\\\"$rolling_max\\\"\"\n\
    \    for element in ${elements[@]:1}; do\n        if (($element > $rolling_max));\
    \ then\n            rolling_max=$element\n        fi\n        echo -n \", \\\"\
    $rolling_max\\\"\"\n    done\n    echo \"]\"", "  local -a max_up_to_i=($1)\n\
    \  local n_max_up_to_i=${#max_up_to_i[@]}\n  local -a rolling_max=()\n  local\
    \ max_so_far=${max_up_to_i[0]}\n  rolling_max+=(\"$max_so_far\")\n  for ((i=1;\
    \ i<n_max_up_to_i; i++)); do\n    if (( max_up_to_i[i] > max_so_far )); then\n\
    \      max_so_far=${max_up_to_i[i]}\n    fi\n    rolling_max+=(\"$max_so_far\"\
    )\n  done\n  echo -n \"[\"\n  for i in \"${rolling_max[@]}\"; do\n    echo -n\
    \ \"\\\"$i\\\",\"\n  done\n  echo -n \"]\"", "    local MAX=${1%% *}\n    shift\n\
    \    for N in $@; do\n        [ \"$N\" -gt \"$MAX\" ] && MAX=$N\n        echo\
    \ $MAX\n    done", "  read -a arr <<< \"$1\"\n  max=${arr[0]}\n  echo \"\\\"$max\\\
    \"\"\n  for ((i=1; i<${#arr[@]}; i++)); do\n    if [[ ${arr[$i]} -gt $max ]];\
    \ then\n      max=${arr[$i]}\n    fi\n    echo \"\\\"$max\\\"\"\n  done", "  local\
    \ list=$1\n  local max=0\n  local -a output\n  for element in $list; do\n    max=$(echo\
    \ -e \"$max\\n$element\" | sort -n | tail -n 1)\n    output+=(\"\\\"$max\\\"\"\
    )\n  done\n  echo ${output[@]}", "  arr=($1)\n  maximum=${arr[0]}\n  echo -n '\"\
    '${arr[0]}'\"'\n  for elem in ${arr[@]:1}; do\n    if [ \"$elem\" -gt \"$maximum\"\
    \ ]; then\n      maximum=$elem\n    fi\n    echo -n ', \"'$maximum'\"'\n  done",
  "    if [[ \"$1\" = \"\" ]]; then\n        return\n    fi\n    local input=($1)\n\
    \    local res=\"${input[0]}\"\n    for el in \"${input[@]:1}\"; do\n        if\
    \ [[ \"$el\" -gt \"$res\" ]]; then\n            res=\"$el\"\n        fi\n    \
    \    echo '\"'\"$res\"'\"'\n    done", "    local array=(\"$@\")\n    local result=(\"\
    ${array[0]}\")\n    for index in \"${!array[@]}\"; do\n        if [[ ${array[$index]}\
    \ -gt ${result[$index]} ]]; then\n            result[$index]=\"${array[$index]}\"\
    \n        else\n            result[$index]=\"${result[$index-1]}\"\n        fi\n\
    \    done\n    echo \"${result[@]}\"", "  local -a a\n  IFS=' ' read -r -a a <<<\
    \ \"$1\"\n  local n=${#a[@]}\n  local -a m\n  m[0]=${a[0]}\n  local i\n  for ((i=1;\
    \ i<n; i++)); do\n    m[i]=$(max \"${m[i-1]}\" \"${a[i]}\")\n  done\n  pprint_array\
    \ $(array_to_str_array m)", "    declare -a arr=($1)\n    local max=$(echo \"\
    ${arr[0]}\")\n    echo -n \"[\"\n    for i in \"${arr[@]}\"; do\n        if ((\
    \ i > max )); then\n            max=$i\n        fi\n        echo -n '\"'$max'\"\
    ',\n    done\n    echo \"]\"", "  echo \"$1\" | {\n    IFS=\" \"\n    max=0\n\
    \    while read x; do\n      if [[ $x -gt $max ]]; then\n        max=$x\n    \
    \  fi\n      echo $max\n    done\n  }", '    python -c "import itertools as it;
    print(it.accumulate($1, max))"', "  local out=()\n  for i in $1; do\n    out+=(\
    \ \"$(echo $(echo \"${out[@]}\" $i | tr ' ' '\\n' | sort -n | tail -n 1))\" )\n\
    \  done\n  echo \"${out[@]}\"", "  local list=($1)\n  local max=\"${list[0]}\"\
    \n  echo -n \"[\"\n  for i in \"${list[@]}\"; do\n    if [[ $i -gt $max ]]; then\n\
    \      max=$i\n    fi\n    echo -n '\"'$max'\"'\n    echo -n \", \"\n  done\n\
    \  echo -n \"]\"", "  local list=($1)\n  local max=${list[0]}\n  local result=($max)\n\
    \  for elem in \"${list[@]:1}\"; do\n    if [[ $elem -gt $max ]]; then\n     \
    \ max=$elem\n    fi\n    result+=($max)\n  done\n  echo $(array_to_string \"${result[@]}\"\
    )", "    list=($1)\n    i=0\n    for el in ${list[@]}; do\n        max=$el\n \
    \       for i in $(seq 1 $i); do\n            if [[ \"${list[$i]}\" -gt \"${max}\"\
    \ ]]; then\n                max=${list[$i]}\n            fi\n        done\n  \
    \      echo -n \"[\\\"${max}\\\"]\"\n        i=$((i+1))\n        if [[ \"$i\"\
    \ -lt \"${#list[@]}\" ]]; then\n            echo -n \", \"\n        fi\n    done",
  "    local current_max=0\n    while read element; do\n        (( current_max = element\
    \ > current_max ? element : current_max ))\n        echo \"$current_max\"\n  \
    \  done <<< \"$1\"", "    local max=\"$1\"\n\n    for i in $@; do\n        if\
    \ [[ $i -gt $max ]]; then\n            max=$i\n        fi\n        echo \"\\\"\
    $max\\\"\"\n    done", "    local max\n    local el\n    for el in $1; do\n  \
    \      [ \"$el\" -gt \"$max\" ] && max=\"$el\"\n        echo \"\\\"$max\\\"\"\n\
    \    done", "  local -a results\n  local max\n  local number\n  while IFS=\" \"\
    \ read -ra nums; do\n    max=${nums[0]}\n    for number in \"${nums[@]}\"; do\n\
    \      if [[ $number -gt $max ]]; then\n        max=$number\n      fi\n    done\n\
    \    results+=(\"$max\")\n  done <<< \"$1\"\n  echo \"${results[@]}\"", "    if\
    \ [[ $# -lt 1 ]]; then\n        echo 'error: missing argument \"list\"'\n    \
    \    return 1\n    fi\n\n    declare -a list=$1\n\n    local max=${list[0]}\n\
    \    local out=\"\\\"$max\\\"\"\n    local i\n    for ((i=1; i<${#list[@]}; i++));\
    \ do\n        if [[ ${list[$i]} -gt $max ]]; then\n            max=${list[$i]}\n\
    \        fi\n        out=\"$out, \\\"$max\\\"\"\n    done\n\n    echo \"[$out]\"",
  "    declare -a arr=($1)\n    _max=${arr[0]}\n    declare -a maxs\n    maxs+=(\"\
    $_max\")\n    for el in \"${arr[@]:1}\"; do\n        if [[ $el -gt $_max ]]; then\n\
    \            _max=$el\n        fi\n        maxs+=(\"$_max\")\n    done\n    echo\
    \ \"${maxs[@]}\"", "    if [ $# -lt 1 ]; then\n        echo \"Usage: $0 <list\
    \ of integers>\"\n        return 1\n    fi\n\n    declare -a max_list\n    max_list[0]=$1\n\
    \    for i in $(seq 1 $(($# - 1))); do\n        if [ ${1%% *} -lt ${max_list[$(($i\
    \ - 1))]%% *} ]; then\n            max_list[$i]=${max_list[$(($i - 1))]}\n   \
    \     else\n            max_list[$i]=$1\n        fi\n        shift\n    done\n\
    \n    # return the array\n    printf \"[%s]\" \"${max_list[@]}\"", "  local seq=\"\
    $1\"\n  local max=0\n  for x in ${seq}; do\n    [[ \"$x\" > \"$max\" ]] && max=\"\
    $x\"\n    echo \"\\\"$max\\\"\"\n  done", "  local -n args=$1\n  max=$(echo \"\
    ${args[@]}\" | tr ' ' '\\n' | sort -nr | head -n 1)\n  echo \"${args[@]}\" | tr\
    \ ' ' '\\n' | while read item; do\n    if [ $item -lt $max ]; then\n      echo\
    \ -n \"\\\"$max\\\" \"\n    else\n      max=$item\n      echo -n \"\\\"$max\\\"\
    \ \"\n    fi\n  done", "  # $1 -> input string\n  local -a result_array=()\n \
    \ local -i max_element=0\n  for element in $1; do\n    if ((element > max_element));\
    \ then\n      max_element=$element\n    fi\n    result_array+=($max_element)\n\
    \  done\n  printf \"\\\"%s\\\" \" \"${result_array[@]}\"", "    local seq_arr=($1)\n\
    \    local max_so_far=${seq_arr[0]}\n    echo '\"'\"$max_so_far\"'\"'\n    for\
    \ item in \"${seq_arr[@]:1}\"; do\n        if [[ \"$max_so_far\" -lt \"$item\"\
    \ ]]; then\n            max_so_far=\"$item\"\n        fi\n        echo '\"'\"\
    $max_so_far\"'\"'\n    done", "  local max_value=0\n  for value in $1; do\n  \
    \  max_value=$(math.max \"$max_value\" \"$value\")\n    printf '\"%s\" ' \"$max_value\"\
    \n  done", "    local seen\n    for i in $1; do\n        echo \"${seen}\" | xargs\
    \ -n1 | sort -nr | head -n1\n        seen=\"${seen} ${i}\"\n    done", "  _max=1\n\
    \  for _num in $1; do\n    _max=$(max $_max $_num)\n    printf \"\\\"%s\\\" \"\
    \ $_max\n  done", "    local max=0\n    local list=($1)\n    local len=${#list[@]}\n\
    \    for (( i=0; i<len; i++ )); do\n        local this=${list[$i]}\n        max=$(echo\
    \ \"$this > $max\" | bc)\n        echo -n \"$max \"\n    done", "    local sum=0\n\
    \    local maximum=0\n    for i in $1\n    do\n        if [ $i -gt $maximum ]\n\
    \        then\n            maximum=$i\n        fi\n        echo '\"'$maximum'\"\
    '\n    done", "    local res\n\n    while read element; do\n        if [[ $res\
    \ ]]; then\n            if [[ \"$element\" -gt \"$res\" ]]; then\n           \
    \     res=\"$element\"\n            fi\n        else\n            res=\"$element\"\
    \n        fi\n        echo \"$res\"\n    done <<< $(echo \"$1\")", "    local\
    \ -a L\n    local m\n    local last\n    IFS=\" \" read -r -a L <<< \"$1\"\n \
    \   echo -n '\"'\n    if [ ${#L[@]} -gt 0 ]; then\n        m=${L[0]}\n       \
    \ echo -n \"$m\"\n        last=0\n    fi\n    for n in \"${L[@]:1}\"; do\n   \
    \     if [ \"$n\" -gt \"$m\" ]; then\n            echo -n '\" \"'\"$n\"\n    \
    \        m=$n\n        else\n            echo -n '\" \"'\"$m\"\n        fi\n \
    \   done\n    echo '\"'", "    local input=( $1 )\n    local output\n    local\
    \ i\n    local max=$input\n    output=( \"${input[0]}\" )\n    for (( i=1; i<${#input[@]};\
    \ i++ )); do\n        if (( input[i] > max )); then\n            max=${input[i]}\n\
    \        fi\n        output+=( \"$max\" )\n    done\n    echo \"${output[@]}\"",
  "    # Process $1 string character by character\n    list=\"$1\"\n    while IFS=\
    \ read -r -n1 char; do\n        # If character is a number, we have found a new\
    \ element\n        # in the sequence, so we append it to our current maximum.\n\
    \        if [[ $char =~ [0-9] ]]; then\n            # Initialize max to the number's\
    \ value\n            if [[ -z $max ]]; then\n                max=$char\n     \
    \       else\n                # Add the new element to the current max\n     \
    \           max=\"$max $char\"\n            fi\n        # If character is a space,\
    \ we have reached the end of an element,\n        # so we need to prune the max\
    \ and potentially update it.\n        elif [[ $char == \" \" ]]; then\n      \
    \      # Pop the first element from the current max\n            max=\"${max#*\
    \ }\"\n            # If the popped element is greater than the next one,\n   \
    \         # then we prune it and append to the sequence.\n            if [[ $(echo\
    \ \"$max\" | cut -d\" \" -f1) -gt $(echo \"$max\" | cut -d\" \" -f2) ]]; then\n\
    \                list=\"$list $(echo \"$max\" | cut -d\" \" -f1)\"\n         \
    \   else\n                # Otherwise, we pop the second element in max and append\
    \ it to the sequence.\n                list=\"$list $(echo \"$max\" | cut -d\"\
    \ \" -f2)\"\n                max=\"${max#* }\"\n            fi\n        fi\n \
    \   done <<< \"$list\"\n    # Print our list to stdout\n    echo $list", "   \
    \ local cmd=\"$1\"\n    local max=-2147483648\n    local -a rmax\n    local -a\
    \ arr=($cmd)\n    for i in \"${arr[@]}\"; do\n        if (( i > max )); then\n\
    \            max=\"$i\"\n        fi\n        rmax+=(\"$max\")\n    done\n    echo\
    \ \"${rmax[@]}\"", "  # check for existence of parameters\n  if [ -z \"$1\" ];\
    \ then\n    echo \"No parameter passed! Use $(basename \"$0\") [list_of_items]\"\
    \n    exit 1\n  fi\n\n  # check for existence of python module\n  if [ -z \"$(pip\
    \ list | grep wheel)\" ]; then\n    echo \"wheel not found, using local version\"\
    \n    wheel_path=$(dirname \"$0\")/../python/wheel\n  else\n    wheel_path=wheel\n\
    \  fi\n\n  # generate the list of maximum elements\n  echo $(echo $1 | tr \" \"\
    \ \"\\n\" |\n    python -m \"$wheel_path\" rolling_max)", "    local -a rolling_list\n\
    \    for n in $1\n    do\n        rolling_list+=(\"$n\")\n        echo \"\\\"\
    $(max_of \"${rolling_list[@]}\")\\\"\"\n    done", "    local max=0\n    echo\
    \ \"$1\" | while read -r n; do\n        if (( $n > $max )); then\n           \
    \ max=$n\n        fi\n        echo \"\\\"$max\\\"\"\n    done", "    # Initialize\
    \ max with the first element\n    max=$(echo \"$1\" | awk '{print $1}')\n    #\
    \ Start iterating through the array and update max\n    for ((i=2; i<=$#; i++));\
    \ do\n        val=$(echo \"$1\" | awk -v i=$i '{print $i}')\n        if (( val\
    \ > max )); then\n            max=$val\n        fi\n        echo $max\n    done",
  "    current_max=0\n    for i in $1\n    do\n        if [[ $i -gt $current_max ]]\n\
    \        then\n            current_max=$i\n        fi\n        echo $current_max\n\
    \    done", "    local seq=\"$1\"\n    local max=0\n    local output=()\n    for\
    \ item in ${seq}; do\n        if [[ ${item} -gt ${max} ]]; then\n            max=${item}\n\
    \        fi\n        output=(\"${output[@]}\" \"\\\"${max}\\\"\")\n    done\n\
    \    echo \"${output[@]}\"", "    local res=()\n    local cur_max=\n    for i\
    \ in \"$@\"; do\n        if [[ -z \"$cur_max\" ]]; then\n            cur_max=\"\
    $i\"\n        elif (( i > cur_max )); then\n            cur_max=\"$i\"\n     \
    \   fi\n        res+=(\"$cur_max\")\n    done\n    echo \"${res[@]}\"", "    #\
    \ https://stackoverflow.com/a/15287112/156458\n    declare -a input=(${1})\n \
    \   declare -a output\n    local max=${input[0]}\n    local i\n    output+=($max)\n\
    \    for ((i=1; i<${#input[@]}; i++)); do\n        if (( ${input[$i]} > $max ));\
    \ then\n            max=${input[$i]}\n        fi\n        output+=($max)\n   \
    \ done\n    echo ${output[@]}", "    echo \"$1\" | while read item; do\n     \
    \   if [ \"${_MAX}\" = \"\" ]; then\n            _MAX=\"$item\"\n        elif\
    \ [ \"${_MAX}\" -lt \"$item\" ]; then\n            _MAX=\"$item\"\n        fi\n\
    \        echo \"\\\"${_MAX}\\\"\"\n    done", "    local max\n\n    for element\
    \ in $1; do\n        [[ -z $max ]] && max=$element || \\\n            [[ $element\
    \ -gt $max ]] && max=$element\n        echo $max\n    done", "    python3 -c \"\
    import sys; print('[' + ', '.join('\\\"{}\\\"'.format(max(map(int, sys.argv[1:])))\
    \ for i in range(len(sys.argv[1:]))) + ']')\" $@", "    local N\n    local MAX\n\
    \    local TMP\n    local RESULT=\"\"\n    for N in $1; do\n        TMP=$N\n \
    \       if [[ -z $MAX ]]; then\n            MAX=$N\n        else\n           \
    \ if [[ $N -gt $MAX ]]; then\n                MAX=$N\n            fi\n       \
    \ fi\n        RESULT=\"$RESULT \\\"$MAX\\\"\"\n    done\n    echo \"$RESULT\"",
  "    declare -a l=($1)\n    d=${l[0]}\n    printf '\"%s\"' \"$d\"\n    for (( i=1;\
    \ i<${#l[@]}; i++ )); do\n        if [[ ${l[$i]} -gt $d ]]; then\n           \
    \ d=${l[$i]}\n        fi\n        printf ',\"%s\"' \"$d\"\n    done", "    set\
    \ -- $1;\n    if [[ -z \"$@\" ]]; then\n        return 0;\n    fi;\n    # Initialize\
    \ with first element in the list\n    max=$1;\n    for (( i=2; i<=$#; i++ ));\
    \ do\n        if [[ \"${!i}\" -gt \"$max\" ]]; then\n            max=${!i};\n\
    \        fi;\n        printf \"%s\\n\" \"$max\";\n    done;", "    max=0\n   \
    \ while IFS=' ' read -ra NUMS; do\n        for i in \"${NUMS[@]}\"; do\n     \
    \       if (( \"$i\" > \"$max\" )); then\n                max=\"$i\"\n       \
    \     fi\n            echo \"\\\"$max\\\"\"\n        done\n    done <<< \"$1\"",
  "    if [[ $# -lt 1 ]]; then\n        echo \"Usage: $0 <space-separated list of\
    \ integers>\" >&2\n        return 1\n    fi\n\n    local max=0\n    for element\
    \ in $1; do\n        max=$((element > max ? element : max))\n        echo -n \"\
    \\\"$max\\\" \"\n    done", "    local -a array=($( echo \"$1\" | sed -e 's/ /\"\
    , \"/g' ))\n    local -a max_until_now=()\n    for x in \"${array[@]}\"; do\n\
    \        max_until_now+=($(max \"${max_until_now[-1]}\" \"$x\"))\n    done\n \
    \   echo \"${max_until_now[@]}\"", "    out=\"\"\n    max=0\n    for i in $1\n\
    \    do\n        if [[ $i -gt $max ]]\n        then\n            max=$i\n    \
    \    fi\n        out=\"$out $max\"\n    done\n    echo $out", "    echo \"$1\"\
    \ | awk '{\n        for (i = 1; i <= NF; i++) {\n            if (i == 1) {\n \
    \               print \"\\\"\" $i \"\\\"\"\n            } else {\n           \
    \     if ($i > max) {\n                    max = $i\n                }\n     \
    \           print \"\\\"\" max \"\\\"\"\n            }\n        }\n    }'", " \
    \   local list=\"$1\"\n    local max=0\n    local value=0\n    for i in ${list[@]};\
    \ do\n        value=${i}\n        [[ ${value} -gt ${max} ]] && max=${value}\n\
    \        echo \"\\\"${max}\\\"\"\n    done", "  local current_max\n  current_max=0\n\
    \  for i in $1; do\n    [[ \"$i\" -gt \"$current_max\" ]] && current_max=\"$i\"\
    \n    echo \"\\\"$current_max\\\"\"\n  done", "    local max=0\n    for elem in\
    \ $1; do\n        if [ $elem -gt $max ]; then\n            max=$elem\n       \
    \ fi\n        echo -n '\"'\n        echo -n $max\n        echo -n '\" '\n    done",
  "    echo \"$1\" | \\\n        while read line\n        do\n            echo \"\
    ${line}\"\n            echo \"${line}\" | while read line\n            do\n  \
    \              echo $line\n            done\n        done", "  local max=\n  for\
    \ n in $@; do\n    if [[ $n -gt $max ]]; then\n      max=$n\n    fi\n    echo\
    \ -n '\"'\n    echo -n $max\n    echo -n '\"'\n    echo -n ', '\n  done", "  \
    \  local MAX=\"$1\"\n    shift\n    while [ $# -gt 0 ]; do\n        if [ \"$(echo\
    \ -e \"$MAX\\n$1\" | sort -nr | head -n1)\" != \"$MAX\" ]; then\n            MAX=\"\
    $1\"\n        fi\n        echo -n '\"'\"$MAX\"'\"'\n        shift\n        if\
    \ [ $# -gt 0 ]; then\n            echo -n ', '\n        fi\n    done", "    local\
    \ -a max=()\n    local -a acc=()\n    for i in $1; do\n        acc+=($i)\n   \
    \     if [ ${#max} -eq 0 ]; then\n            max+=($i)\n        else\n      \
    \      if (( ${max[${#max[@]}-1]} < $i )); then\n                max+=($i)\n \
    \           else\n                max+=(${max[${#max[@]}-1]})\n            fi\n\
    \        fi\n    done\n    local -a ret=()\n    for i in ${max[@]}; do\n     \
    \   ret+=(\\\"$i\\\")\n    done\n    echo ${ret[@]}", "  if [ $# -ne 1 ]; then\n\
    \    echo \"Invalid parameters for rolling_max: $@\"\n    return 1\n  fi\n  local\
    \ -a seq\n  IFS=\" \" read -r -a seq <<< \"$1\"\n  local max_so_far=${seq[0]}\n\
    \  echo \"[\\\"$max_so_far\\\"\"\n  for ((i=1; i<${#seq[@]}; i++)); do\n    if\
    \ ((max_so_far < seq[i])); then\n      max_so_far=${seq[i]}\n    fi\n    echo\
    \ \", \\\"$max_so_far\\\"\"\n  done\n  echo \"]\"", "    local l=$1\n    local\
    \ max=0\n    for x in $l; do\n        max=$((max>x?max:x))\n        echo -n \"\
    \\\"$max\\\" \"\n    done", "    echo $(echo \"$1\" | awk '\n    BEGIN {\n   \
    \     max = 0;\n    }\n    {\n        if ($1 > max) {\n            max = $1;\n\
    \        }\n        print max;\n    }')", "  local nums=$1; shift\n  local res=$(echo\
    \ \"$nums\" |\n      awk '{\n            cur=$1;\n            for (i=2; i<=NF;\
    \ i++) {\n              cur=max($i, cur);\n              print cur;\n        \
    \    }\n           }')\n  echo \"$res\"", "  local r=$1; shift\n  for i in $@;\
    \ do\n    if [ $i -gt $r ]; then\n      r=$i\n    fi\n    echo $r\n  done", " \
    \   local -a arr=(\"$@\")\n    local -a ans=()\n    local max=0\n    for i in\
    \ \"${arr[@]}\"; do\n        ans+=(\"\\\"$max\\\"\")\n        if [[ \"$i\" -gt\
    \ \"$max\" ]]; then\n            max=\"$i\"\n        fi\n    done\n    echo \"\
    ${ans[@]}\"", "    local input=($1)\n    local output=()\n    local max=${input[0]}\n\
    \    output[0]=$max\n    # Strip the first element since the rolling max is known\n\
    \    input=(${input[@]:1})\n    for value in ${input[@]}; do\n        if [[ $value\
    \ -gt $max ]]; then\n            max=$value\n        fi\n        output+=(\"$max\"\
    )\n    done\n    printf '%s\\n' \"${output[@]}\"", "    max=\"$1\"\n    for i\
    \ in $*; do\n        [ $i -gt $max ] && max=$i\n        echo \"\\\"$max\\\"\"\n\
    \    done", "    _rolling_max_max_element=\"$1\"\n    shift\n    echo \"\\\"$_rolling_max_max_element\\\
    \"\"\n    for _rolling_max_item in $@\n    do\n        if [ \"$_rolling_max_item\"\
    \ -gt \"$_rolling_max_max_element\" ]\n        then\n            _rolling_max_max_element=\"\
    $_rolling_max_item\"\n        fi\n        echo \"\\\"$_rolling_max_max_element\\\
    \"\"\n    done", "    local buf=()\n\n    # initialization\n    buf[0]=$(echo\
    \ \"$1\" | cut -d \" \" -f 1)\n\n    echo \"$1\" | cut -d \" \" -f 2- | while\
    \ read i; do\n        if [ \"$i\" -gt \"${buf[-1]}\" ]; then\n            buf[${#buf[@]}]=$i\n\
    \        else\n            buf[${#buf[@]}]=${buf[-1]}\n        fi\n    done\n\n\
    \    echo \"${buf[@]}\" | tr ' ' '\\n' | jq -s '.'", "    local max=0\n\n    for\
    \ num in $1; do\n        if [[ $num -gt $max ]]; then\n            max=$num\n\
    \        fi\n        echo -n $max\n        echo -n ' '\n    done", "  local rolling_max_LIST=$1\n\
    \  local rolling_max_ELTS=($rolling_max_LIST)\n  local rolling_max_RESULT\n  for\
    \ rolling_max_ELEMENT in \"${rolling_max_ELTS[@]}\"; do\n    if [[ -z \"$rolling_max_RESULT\"\
    \ ]]; then\n      rolling_max_RESULT=$rolling_max_ELEMENT\n    else\n      if\
    \ [[ $rolling_max_ELEMENT -gt $rolling_max_RESULT ]]; then\n        rolling_max_RESULT=$rolling_max_ELEMENT\n\
    \      fi\n    fi\n    echo '\"'\"$rolling_max_RESULT\"'\"'\n  done", "    local\
    \ max\n    declare -a maxes\n    local -i i\n    max=$(IFS=\" \"; echo \"$*\"\
    \ | tr ' ' '\\n' | sort -n | tail -n 1)\n    maxes=(\"$max\")\n    for i in $*;\
    \ do\n        max=$(( i > max ? i : max ))\n        maxes+=(\"$max\")\n    done\n\
    \    printf \"[%s]\" \"$(IFS=\" \"; echo \"${maxes[*]}\" | tr ' ' ',')\"", " \
    \   local current_max=0\n    for i in $1; do\n        if [ \"$i\" -gt \"$current_max\"\
    \ ]; then\n            current_max=$i\n        fi\n        echo \"\\\"$current_max\\\
    \"\"\n    done", "    local arr=()\n    local max=0\n    for num in $1\n    do\n\
    \        arr+=($num)\n        if [[ $num -gt $max ]]\n        then\n         \
    \   max=$num\n        fi\n        echo \"\\\"$max\\\"\"\n    done", "  for i in\
    \ $1; do\n    if [ -z \"$2\" ]; then\n      echo -n '\"'\"$i\"'\"'\n    else\n\
    \      if [ \"$i\" -gt \"$2\" ]; then\n        echo -n '\"'\"$i\"'\"'\n      else\n\
    \        echo -n '\"'\"$2\"'\"'\n      fi\n    fi\n    echo -n ' '\n  done", " \
    \   local list=\"$1\"\n    local max=0\n    local new_list\n    for value in $list;\
    \ do\n        if [ $value -gt $max ]; then\n            max=$value\n        fi\n\
    \        echo \"\\\"$max\\\"\"\n    done", "    echo '[' \"$(echo $1 | tr \" \"\
    \ \"\\n\" | sort -r -g | tr \"\\n\" \" \")\" ']'", "  local numbers=(${1// / })\n\
    \  local max=$numbers\n  echo \"[$(jq -R . <<< \"${numbers[0]}\")\"\n  for i in\
    \ \"${numbers[@]:1}\"\n  do\n    ((i > max)) && max=$i\n    echo \",$(jq -R .\
    \ <<< \"$max\")\"\n  done\n  echo \"]\"", "  local -a A\n  local -i m\n  A=($1)\n\
    \  m=${A[0]}\n  echo -n \"\\\"$m\\\"\"\n  for (( i=1; i<${#A[@]}; i++ )); do\n\
    \    if (( A[i] > m )); then\n      m=${A[i]}\n    fi\n    echo -n \", \\\"$m\\\
    \"\"\n  done", "    python -c \"\nimport sys\narr = map(int, sys.argv[1].split())\n\
    ret = []\nmax_until_now = arr[0]\nret.append(max_until_now)\nfor i in arr[1:]:\n\
    \    max_until_now = max(max_until_now, i)\n    ret.append(max_until_now)\nprint\
    \ '[%s]' % ', '.join(map(lambda x: '\\\"%s\\\"' % x, ret))\n\" \"$1\"", "    local\
    \ i=0;\n    local array=($1);\n    local max=${array[0]};\n    local max_index=$i;\n\
    \    for (( i=1; i<${#array[@]}; i++ )); do\n        if (( \"${array[$i]}\" >\
    \ \"$max\" )); then\n            max=${array[$i]};\n            max_index=$i;\n\
    \        fi\n        echo $max;\n    done", "    local v=\"$1\" arr=($v) last_max=0\
    \ i\n    for i in ${!arr[@]}; do\n        [[ ${arr[$i]} -ge $last_max ]] && last_max=${arr[$i]}\n\
    \        printf '\"%s\" ' \"$last_max\"\n    done", "    local -a values=($1)\n\
    \n    local max=${values[0]}\n    for value in \"${values[@]}\"; do\n        echo\
    \ -n '\"'\n        if [[ \"$value\" -gt \"$max\" ]]; then\n            max=$value\n\
    \        fi\n        echo -n \"$max\"\n        echo '\",'\n    done", "  local\
    \ -a ints=($1)\n  local -a maxs\n  maxs[0]=${ints[0]}\n  for i in \"${!ints[@]}\"\
    ; do\n    maxs[$((i+1))]=$(echo \"${maxs[$i]} ${ints[$i]}\" | tr ' ' '\\n' | sort\
    \ -nr | head -n 1)\n  done\n  echo \"${maxs[@]}\"", "    awk '\n        BEGIN\
    \ {FS = OFS = \" \"}\n        function print_max() {\n            max = a[1]\n\
    \            for (i = 2; i <= n; i++) {\n                if (a[i] > max) max =\
    \ a[i]\n            }\n            print \"\\\"\" max \"\\\"\"\n        }\n  \
    \      {\n            if (max < $1) max = $1\n            n = split($0, a, \"\
    \ \")\n            print_max()\n        }\n        END {\n            print_max()\n\
    \        }\n    ' <<< \"$1\"", "    max=0\n    for x in \"$@\"; do\n        if\
    \ [[ $x -gt $max ]]; then\n            max=$x\n        fi\n        printf '\"\
    %s\" ' \"$max\"\n    done", "    #echo \"Args: $@\"\n    list=$@\n    local -a\
    \ l=()\n    for x in $list; do\n        if [[ ${#l[@]} -eq 0 ]]; then\n      \
    \      l=($x)\n        else\n            l[${#l[@]}]=$x\n        fi\n        echo\
    \ ${l[@]} | sort -V | tail -n 1\n    done", "  local var_name=\"${2:-_}\"\n  local\
    \ values=(\"$@\")\n  local max=\"${values[0]}\"\n  declare -g \"$var_name\"\n\n\
    \  for (( i=1; i<${#values[@]}; i++ )); do\n    local value=\"${values[$i]}\"\n\
    \    max=$(( value > max ? value : max ))\n    eval \"$var_name[$i]=$max\"\n \
    \ done", "    while read -r line; do\n        # Start with the first element\n\
    \        [[ -z \"$max\" ]] && max=\"$line\"\n\n        [[ \"$line\" -gt \"$max\"\
    \ ]] && max=\"$line\"\n        printf '\"%s\"\\n' \"$max\"\n    done <<< \"$1\"",
  "    if [ -z \"$1\" ]; then\n        echo '[]'\n        return\n    fi\n\n    local\
    \ result\n    result=\"[$(echo \"$1\" | cut -d ' ' -f 1)]\"\n    for i in $(echo\
    \ \"$1\" | cut -d ' ' -f 2-); do\n        result=\"$result, $(python3 -c \"print(max($result[-1],\
    \ $i))\")\"\n    done\n    echo \"$result\"", "    local max_elem\n    max_elem=$(echo\
    \ \"$1\" | head -n 1)\n    for i in $1; do\n        if [ \"$max_elem\" -lt \"\
    $i\" ]; then\n            max_elem=$i\n        fi\n        echo '\"'\"$max_elem\"\
    '\"'\n    done", "  local -a sequence=($@)\n  local -a maximum=(${sequence[0]})\n\
    \  for ((i=1; i<${#sequence[@]}; i++)); do\n    local previous_maximum=${maximum[$(($i-1))]}\n\
    \    if ((previous_maximum > sequence[i])); then\n      maximum[$i]=$previous_maximum\n\
    \    else\n      maximum[$i]=${sequence[i]}\n    fi\n  done\n  echo $(printf '\"\
    %s\" ' \"${maximum[@]}\")", "  if [[ -z \"$1\" ]]; then\n    echo \"\"\n    return\
    \ 0\n  fi\n\n  rolling_max_helper $1 | awk '{print $1}'"]
stop_tokens:
- "\n}"
