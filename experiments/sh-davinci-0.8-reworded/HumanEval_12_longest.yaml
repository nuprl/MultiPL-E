name: HumanEval_12_longest
language: sh
prompt: "#!/bin/bash\n# Out of list of strings, return the longest one. Return the\
  \ first one in case of multiple\n# strings of the same length. Return None in case\
  \ the input list is empty.\n# >>> $(longest \"\")\n# \"None\"\n# >>> $(longest \"\
  a b c\")\n# \"a\"\n# >>> $(longest \"a bb ccc\")\n# \"ccc\"\n#\n# $1 is a space-separated\
  \ list\nlongest() {\n"
tests: "}\n\ncandidate() {\n    longest \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
  \ $(candidate \"\") = \"None\" ]]\n    [[ $(candidate \"x y z\") = \"x\" ]]\n  \
  \  [[ $(candidate \"x yyy zzzz www kkkk abc\") = \"zzzz\" ]]\n}\n\nrun_test"
completions: ["  if [ -z \"$1\" ]; then\n    echo \"None\"\n  else\n    echo \"$1\"\
    \ | tr ' ' '\\n' | awk '{ if (max == \"\" || length($0) > max) { max = length($0);\
    \ max_string = $0; } } END { print max_string }'\n  fi", "    longest_str=\"\"\
    \n    longest_str_len=0\n    for w in $1; do\n        w_len=${#w}\n        if\
    \ [ $w_len -gt $longest_str_len ]; then\n            longest_str_len=$w_len\n\
    \            longest_str=$w\n        fi\n    done\n    if [ $longest_str_len -eq\
    \ 0 ]; then\n        echo \"None\"\n    else\n        echo \"$longest_str\"\n\
    \    fi", "  x=$(echo $1 | sed 's|\\ |\\n|g' | sort -r -k1,1 | head -n1)\n  if\
    \ [ -z \"$x\" ]; then\n    echo \"None\"\n  else\n    echo \"$x\"\n  fi", "  if\
    \ [[ \"$#\" -eq 0 ]]; then\n    echo \"None\"\n  else\n    echo \"$*\" | tr '\
    \ ' '\\n' | sort -r -k1.4 | head -n1\n  fi", "  declare -a strs\n  strs=($@)\n\
    \  if [ \"${#strs[@]}\" -eq 0 ]; then\n    echo \"None\"\n  else\n    echo $(sort\
    \ <<< \"${strs[*]}\" | tail -n 1)\n  fi", "    local result='None'\n    local\
    \ longest_length=0\n    for i in $1; do\n        local current_length=$(echo $i\
    \ | wc -c)\n        if [ $current_length -gt $longest_length ]; then\n       \
    \     longest_length=$current_length\n            result=$i\n        fi\n    done\n\
    \    echo $result", "    if [[ -z \"$1\" ]]; then\n        echo \"None\"\n   \
    \ else\n        echo \"$1\" | awk '{ for (i=1; i<=NF; i++) { len[i] = length($i)\
    \ } max = len[1]; maxind = 1; for (i=2; i<=NF; i++) { if (len[i] > max) { max\
    \ = len[i]; maxind = i } } print $maxind }'\n    fi", "  list_length=0\n  longest_word=\"\
    \"\n  while [[ $# -gt 0 ]]; do\n    word=\"$1\"\n    ((word_length=${#word}))\n\
    \    if [[ $word_length -gt $list_length ]]; then\n      list_length=$word_length\n\
    \      longest_word=\"$word\"\n    fi\n    shift\n  done\n  if [[ $list_length\
    \ -eq 0 ]]; then\n    echo None\n  else\n    echo \"$longest_word\"\n  fi", " \
    \   local longest=\"\"\n    local val=\"\"\n    local i=\"\"\n    local input_list=\"\
    $1\"\n    longest=\"None\"\n    for i in $input_list; do\n        if [[ -z \"\
    $i\" ]]; then\n            continue\n        fi\n        if [[ \"${#i}\" -gt \"\
    ${#longest}\" ]]; then\n            longest=\"$i\"\n        fi\n    done\n   \
    \ echo \"$longest\"", "  local str;\n  while read str; do\n    if [[ -z \"$result\"\
    \ ]]; then\n      result=\"$str\"\n    elif (( ${#str} > ${#result} )); then\n\
    \      result=\"$str\"\n    fi\n  done <<< \"$1\"\n  echo \"${result:-None}\"",
  "  local longest_\n  if [ -z \"$1\" ]; then\n    echo \"None\"\n  else\n    longest_=\"\
    $1\"\n    for i in $1; do\n      if [ \"${#i}\" -gt \"${#longest_}\" ]; then\n\
    \        longest_=\"$i\"\n      fi\n    done\n    echo \"$longest_\"\n  fi", " \
    \ if [ -z \"$1\" ]; then\n    echo \"None\"\n  else\n    echo \"$1\" | tr \" \"\
    \ \"\\n\" | sort -r -k1,1 -s | head -n1\n  fi", "\tif [ \"$1\" == \"\" ]; then\n\
    \t\techo \"None\"\n\telse\n\t\techo \"$1\" | awk '{max=0; for (i=1; i<=NF; i++)\
    \ {\n\t\t\tif (length($i) > max) {\n\t\t\t\tmax = length($i);\n\t\t\t\tmax_index\
    \ = i;\n\t\t\t}\n\t\t} print $max_index}'\n\tfi", "  [[ $# -eq 0 ]] && echo None\
    \ && return\n  local IFS=$'\\n'\n  echo \"$1\" | xargs printf \"%s\\n\" | sort\
    \ -r | head -n 1", "    local s max=0 longest=\n    for s in $*; do\n        [\
    \ ${#s} -gt $max ] && max=${#s} && longest=$s\n    done\n    [ -z \"$longest\"\
    \ ] && longest=None\n    echo \"$longest\"", "  if [ -z \"$1\" ]; then\n    echo\
    \ \"None\"\n  else\n    printf '%s\\n' \"$@\" | sort -r -k1,1 -t\" \" -n - | head\
    \ -n1\n  fi", "    local longest_word\n    local word\n    local length\n    longest_word=\n\
    \    for word in $1\n    do\n        [[ -z \"$word\" ]] && continue\n        length=${#word}\n\
    \        if [[ -z \"$longest_word\" ]] || (( length > ${#longest_word} ))\n  \
    \      then\n            longest_word=$word\n        fi\n    done\n    if [[ -z\
    \ \"$longest_word\" ]]\n    then\n        longest_word=\"None\"\n    fi\n    echo\
    \ \"$longest_word\"", "    local longest=\n    local cur=\n    for word in $1;\
    \ do\n        if [[ -z \"$longest\" ]]; then\n            longest=\"$word\"\n\
    \        else\n            if [[ ${#word} -gt ${#longest} ]]; then\n         \
    \       longest=\"$word\"\n            fi\n        fi\n    done\n    if [[ -z\
    \ \"$longest\" ]]; then\n        echo \"None\"\n    else\n        echo \"$longest\"\
    \n    fi", "  if [ -z \"$1\" ]; then\n    echo \"None\"\n  else\n    echo \"$1\"\
    \ | awk '{ print length, $0 }' | sort -nr | head -1 | cut -d' ' -f2-\n  fi", " \
    \   if [ $# -lt 1 ]; then\n        echo \"None\"\n    else\n        echo \"$@\"\
    \ | tr \" \" \"\\n\" | sort -nr | head -n 1\n    fi", "    if [ -z \"$1\" ]; then\n\
    \        echo \"None\"\n    else\n        for i in $1; do\n            if [ \"\
    ${#i}\" -gt \"${#longest}\" ]; then\n                longest=\"$i\"\n        \
    \    fi\n        done\n        echo \"$longest\"\n    fi", "    if [ $# -eq 0\
    \ ]; then\n        echo \"None\"\n    else\n        local res=\n        local\
    \ max_len=0\n        for arg; do\n            local arg_len=$(echo -n \"$arg\"\
    \ | wc -c)\n            if [ $arg_len -gt $max_len ]; then\n                max_len=$arg_len\n\
    \                res=$arg\n            fi\n        done\n        echo \"$res\"\
    \n    fi", "  local longest_string\n  local string\n  local max_len=0\n  while\
    \ read string; do\n    [[ ${#string} -gt $max_len ]] && longest_string=$string\n\
    \  done <<< \"$*\"\n  if [[ -z $longest_string ]]; then\n    echo \"None\"\n \
    \ else\n    echo \"$longest_string\"\n  fi", "  local longest_line=\"\"\n  local\
    \ longest_line_len=0\n  local new_line=\"\"\n  local new_line_len=0\n  while IFS=\
    \ read -r new_line; do\n    new_line_len=${#new_line}\n    if [[ ${new_line_len}\
    \ -gt ${longest_line_len} ]]; then\n      longest_line=${new_line}\n      longest_line_len=${new_line_len}\n\
    \    fi\n  done <<< ${1}\n  if [[ ${longest_line_len} -eq 0 ]]; then\n    echo\
    \ \"None\"\n  else\n    echo \"${longest_line}\"\n  fi", "    if [ $# -eq 0 ];\
    \ then\n        echo \"None\"\n    else\n        # space-separated list to newline-separated\
    \ list\n        # sed -e 's/[[:space:]]/\\n/g'\n        # sort by length\n   \
    \     # sed -e 's/.*//'\n        # reverse sort\n        # sed -e '1!G;h;$!d'\n\
    \        # print the first item\n        echo \"$1\" | sed -e 's/[[:space:]]/\\\
    n/g' | sed -e 's/.*//' | sed -e '1!G;h;$!d' | sed -e 's/\\n.*//'\n    fi", "\t\
    [ $# -eq 0 ] && return 0\n\tlocal longest_len=0\n\tlocal longest\n\tlocal word\
    \ len\n\tfor word in $1; do\n\t\tlen=${#word}\n\t\tif (( $len > $longest_len ));\
    \ then\n\t\t\tlongest_len=$len\n\t\t\tlongest=$word\n\t\tfi\n\tdone\n\techo $longest",
  "    echo \"$1\" | awk 'BEGIN { longest = \"None\" } { if (length($1) > length(longest))\
    \ longest = $1; } END { print longest }'", "  echo $1 | tr ' ' '\\n' | awk '{if\
    \ (length > max) {max = length; line = $0}} END {if (max) print line}'", "   \
    \ if [[ -z \"$1\" ]]; then\n        echo \"None\"\n    else\n        echo \"$@\"\
    \ | tr ' ' '\\n' | sort -nr | head -n 1\n    fi", "\tlist=($1)\n\tif [ ${#list[@]}\
    \ -eq 0 ]; then\n\t\techo \"None\"\n\t\treturn\n\tfi\n\tlongest_string=${list[0]}\n\
    \tmax_length=${#longest_string}\n\tfor s in \"${list[@]:1}\"; do\n\t\tif [ ${#s}\
    \ -gt $max_length ]; then\n\t\t\tlongest_string=$s\n\t\t\tmax_length=${#s}\n\t\
    \tfi\n\tdone\n\techo \"$longest_string\"", "  if [[ -z \"$1\" ]]; then\n    echo\
    \ \"None\"\n  else\n    echo \"$1\" | tr ' ' '\\n' | sort -r -n -k1 | head -n1\n\
    \  fi", "  local longest=\"\"\n  for word in $*; do\n    [[ ${#word} -gt ${#longest}\
    \ ]] && longest=$word\n  done\n  if [[ -z $longest ]]; then\n    echo \"None\"\
    \n  else\n    echo \"$longest\"\n  fi", "    str_list=$1\n    max_len=0\n    for\
    \ i in $str_list; do\n        len=${#i}\n        if [ $len -gt $max_len ]; then\n\
    \            longest_str=$i\n            max_len=$len\n        fi\n    done\n\
    \    if [ $max_len -gt 0 ]; then\n        echo \"$longest_str\"\n    else\n  \
    \      echo \"None\"\n    fi", "  longest=\n  for e in $1; do\n    if [ -z \"\
    $longest\" ]; then\n      longest=$e\n    elif [ ${#e} -gt ${#longest} ]; then\n\
    \      longest=$e\n    fi\n  done\n  if [ -z \"$longest\" ]; then\n    echo \"\
    None\"\n  else\n    echo \"$longest\"\n  fi", "\tlocal LONGEST=\n\tlocal LEN=0\n\
    \tlocal CURRENT=\n\tlocal IFS=\" \"\n\n\tfor CURRENT in $1\n\tdo\n\t\tif [ ${#CURRENT}\
    \ -gt $LEN ]\n\t\tthen\n\t\t\tLONGEST=$CURRENT\n\t\t\tLEN=${#CURRENT}\n\t\tfi\n\
    \tdone\n\n\tif [ -z \"$LONGEST\" ]\n\tthen\n\t\techo \"None\"\n\telse\n\t\techo\
    \ \"$LONGEST\"\n\tfi", "  # \"a bb ccc\" -> \"a bb ccc\" \"a\" \"bb\" \"ccc\"\n\
    \  read -r -a words <<< \"$1\"\n  max=\"\"\n  for word in \"${words[@]}\"; do\n\
    \    if [[ -z \"$max\" || ${#word} -gt ${#max} ]]; then\n      max=\"$word\"\n\
    \    fi\n  done\n  if [[ -z \"$max\" ]]; then\n    echo \"None\"\n  else\n   \
    \ echo \"$max\"\n  fi", "    local -a words=(${1:-None})\n    local max=0\n  \
    \  local longest=None\n    for word in \"${words[@]}\"; do\n        local length=${#word}\n\
    \        if [[ $length -gt $max ]]; then\n            max=$length\n          \
    \  longest=$word\n        fi\n    done\n    echo \"$longest\"", "\t# First, we\
    \ need to get the length of each item in the list.\n\t# Save the result in a temporary\
    \ file.\n\tfor i in $1; do\n\t\techo ${#i}\n\tdone > /tmp/$$.len\n\n\t# Second,\
    \ we need to find the max number in the temp file.\n\t# Save the result in a temporary\
    \ file.\n\tmax=-1\n\tfor i in $(cat /tmp/$$.len); do\n\t\tif [ $i -gt $max ];\
    \ then\n\t\t\tmax=$i\n\t\tfi\n\tdone > /tmp/$$.max\n\n\t# Third, we need to find\
    \ the first item in the list whose length\n\t# is the same as the max number we\
    \ just found.\n\tindex=0\n\tfor i in $1; do\n\t\tif [ ${#i} -eq $max ]; then\n\
    \t\t\techo $i\n\t\t\tbreak\n\t\tfi\n\t\tindex=$((index+1))\n\tdone\n\n\t# Housekeeping.\n\
    \trm /tmp/$$.len /tmp/$$.max", "  if [[ -z \"$1\" ]]; then\n    echo \"None\"\n\
    \  else\n    echo \"$1\" | tr ' ' '\\n' | sort -t. -k1,1n -k2,2n -k3,3n -k4,4n\
    \ | tail -n1\n  fi", "  if [ -z \"$1\" ]; then\n    echo None\n  else\n    echo\
    \ $1 | awk '{print $1}'\n  fi", "    set -- $*;\n    if [ $# -gt 0 ]; then\n \
    \       echo $* | tr ' ' '\\n' | sort -n -t ' ' -k 1 -r | head -n 1;\n    else\n\
    \        echo \"None\";\n    fi", "    if [ -z \"$1\" ]; then\n        echo \"\
    None\"\n    else\n        echo \"$1\" | tr ' ' '\\n' | sort -n -r -k 1 | head\
    \ -n 1\n    fi", "\techo \"$@\" | sed 's/ /\\n/g' | awk '{\n\t\tif (! maxlen ||\
    \ length > maxlen) {\n\t\t\tmaxlen = length\n\t\t\tmaxstr = $0\n\t\t}\n\t} END\
    \ {\n\t\tif (maxlen) {\n\t\t\tprint maxstr\n\t\t} else {\n\t\t\tprint \"None\"\
    \n\t\t}\n\t}'", "    if [ $# -eq 0 ]; then\n        echo None\n    else\n    \
    \    printf \"%s\\n\" \"$@\" | awk '{if (length($0) > length(max)) max = $0} END\
    \ {print max}'\n    fi", "  local sep_str=$(to_sep_str \"$1\")\n  local sorted_str=$(sep_str_sort\
    \ \"$sep_str\")\n  echo \"$sorted_str\" | tail -n 1", "  local res=\n  if [ -z\
    \ \"$1\" ]; then\n    res=\"None\"\n  else\n    local l=\n    local m=0\n    for\
    \ e in $1; do\n      l=${#e}\n      if [ $l -gt $m ]; then\n        m=$l\n   \
    \     res=$e\n      fi\n    done\n  fi\n  echo $res", "  local length=-1\n  local\
    \ longest=None\n  while read -r string; do\n    if [[ ${#string} -gt $length ]];\
    \ then\n      length=${#string}\n      longest=$string\n    fi\n  done <<< \"\
    $1\"\n  echo \"$longest\"", "    # Check if the input list is empty\n    if [\
    \ $# -eq 0 ]; then\n        echo \"None\"\n        return\n    fi\n\n    # Initialize\
    \ variables\n    local ret=$1\n    local len=${#1}\n\n    # Traverse input list\n\
    \    for i in $@; do\n        if [ ${#i} -gt $len ]; then\n            ret=$i\n\
    \            len=${#i}\n        fi\n    done\n\n    echo $ret", "  local max_length=0\
    \ max_length_element=''\n  for element in $1; do\n    local length=$(echo -n \"\
    $element\" | wc -c)\n    if [ $length -gt $max_length ]; then\n      max_length=$length\n\
    \      max_length_element=$element\n    fi\n  done\n  if [ $max_length -eq 0 ];\
    \ then\n    echo None\n  else\n    echo \"$max_length_element\"\n  fi", "    [\
    \ $# -eq 0 ] && echo \"None\" && return\n    # build list of words and their lengths\n\
    \    IFS=' ' read -r -a words <<< \"$1\"\n    local -a words_lengths=()\n    for\
    \ word in \"${words[@]}\"; do\n        words_lengths+=(\"$word\" \"${#word}\"\
    )\n    done\n    # sort by length and return the first word\n    IFS=$'\\n' sorted=($(sort\
    \ -k2 -n -r <<< \"${words_lengths[*]}\"))\n    echo \"${sorted[0]}\"", "  local\
    \ long=\"None\"\n  local current\n  local maxlength=0\n  while read -r current;\
    \ do\n    if [ ${#current} -gt $maxlength ]; then\n      long=$current\n     \
    \ maxlength=${#current}\n    fi\n  done <<< \"$1\"\n  echo \"$long\"", "    test\
    \ -z \"$1\" && echo \"None\" && return 0\n    echo \"$1\" | tr ' ' '\\n' | awk\
    \ '{ if (NR == 1 || length($0) > maxlen) {maxlen = length($0); longest = $0} }\
    \ END { print longest }'", "  local IFS=$' '\n  local longest=\"\"\n  for word\
    \ in $1; do\n    if [[ ${#word} -gt ${#longest} ]]; then\n      longest=$word\n\
    \    fi\n  done\n  if [[ -z $longest ]]; then\n    echo \"None\"\n  else\n   \
    \ echo \"$longest\"\n  fi", "    if [[ $# -eq 0 ]]; then\n        echo \"None\"\
    \n    else\n        printf '%s\\n' \"$1\" | awk '{if(length>len) {str=$0; len=length}}\
    \ END {print str}'\n    fi", "  longest=\"\"\n  longest_len=0\n  for word in $1;\
    \ do\n    word_len=${#word}\n    if [ $word_len -gt $longest_len ]; then\n   \
    \   longest=$word\n      longest_len=$word_len\n    fi\n  done\n  if [ -z \"$longest\"\
    \ ]; then\n    echo \"None\"\n  else\n    echo \"$longest\"\n  fi", "    # If\
    \ the list is empty, return \"None\"\n    [ -z \"$1\" ] && echo \"None\" && return\n\
    \n    # Otherwise, split the list into words, loop over words and get their length.\n\
    \    # The first word with the max length is the longest.\n    local word\n  \
    \  local max_length=0\n    local longest_word=\n    for word in $1; do\n     \
    \   local word_length=${#word}\n        if [ $word_length -gt $max_length ]; then\n\
    \            max_length=$word_length\n            longest_word=$word\n       \
    \ fi\n    done\n    echo \"$longest_word\"", "    string=$1\n    longest_string=None\n\
    \    for word in $string; do\n        if [ ${#word} -gt ${#longest_string} ];\
    \ then\n            longest_string=$word\n        fi\n    done\n    echo \"$longest_string\"",
  "    if [ -z \"$1\" ]; then\n        echo \"None\"\n    else\n        echo \"$1\"\
    \ | tr \" \" \"\\n\" | awk '{ print length, $0 }' | sort -n -r | head -n 1 | awk\
    \ '{ print $2 }'\n    fi", "\tlocal longest=$(awk '{ if (length > max) max = length\
    \ } END { print max }' <<< \"$1\")\n\tawk -v max=$longest 'length == max { print;\
    \ exit }' <<< \"$1\"", "    if [ -z \"$1\" ]; then\n        echo \"None\"\n  \
    \  else\n        longest_item=\"$1\"\n        for item in $1; do\n           \
    \ if [ ${#item} -gt ${#longest_item} ]; then\n                longest_item=\"\
    $item\"\n            fi\n        done\n        echo \"$longest_item\"\n    fi",
  "    local longest_word\n    local longest_length=0\n    local word_length\n   \
    \ local word\n    # For each word in $1, check length\n    for word in $1; do\n\
    \        word_length=${#word}\n        if [[ word_length -gt longest_length ]];\
    \ then\n            longest_length=$word_length\n            longest_word=$word\n\
    \        fi\n    done\n    if [[ -z $longest_word ]]; then\n        echo \"None\"\
    \n    else\n        echo \"$longest_word\"\n    fi", "  [ -z \"$1\" ] && echo\
    \ \"None\" || echo \"$1\" | awk '{\n    l=0;\n    s=\"\";\n    for (i=1; i<=NF;\
    \ i++) {\n      if (length($i) > l) {\n        l = length($i);\n        s = $i;\n\
    \      }\n    }\n    print s;\n  }'", "\t[ $# -eq 0 ] && echo \"None\" && return\n\
    \tlocal longest=\"$1\"\n\tfor i in \"$@\"; do\n\t\t[ ${#i} -gt ${#longest} ] &&\
    \ longest=\"$i\"\n\tdone\n\techo \"$longest\"", "    if [ -z \"$1\" ]; then\n\
    \        echo \"None\"\n    else\n        echo \"$1\" | tr \" \" \"\\n\" | sort\
    \ -nr | head -n 1\n    fi", '  echo "$1" | xargs -n1 | sort -nr -k1 | head -n1',
  "    # In case $1 is empty, show that\n    [ -z \"$1\" ] && echo \"None\" && return\n\
    \    # Split string into an array\n    local string_arr=($1)\n    # Print the\
    \ first element\n    echo \"${string_arr[0]}\"\n    # Print the rest of the elements,\
    \ only if it's non-empty\n    if [ ${#string_arr[@]} -gt 1 ]; then\n        for\
    \ string in \"${string_arr[@]:1}\"; do\n            # Only print if the previous\
    \ string is longer\n            if [ ${#string} -gt ${#echo $(longest \"$1\")}\
    \ ]; then\n                echo \"$string\"\n            fi\n        done\n  \
    \  fi", "\t[[ $# -eq 0 ]] && echo \"None\" && return 0\n\tmax_len=0\n\tlongest_str=\n\
    \tfor str in $1; do\n\t\tif [[ ${#str} -gt $max_len ]]; then\n\t\t\tmax_len=${#str}\n\
    \t\t\tlongest_str=$str\n\t\tfi\n\tdone\n\techo \"$longest_str\"", "    local l=\"\
    $*\"\n    if [[ -z \"$l\" ]]; then\n        echo \"None\"\n    else\n        local\
    \ max_length=0\n        local max_length_index=0\n        local i=0\n        for\
    \ e in $l; do\n            if (( ${#e} > max_length )); then\n               \
    \ max_length=${#e}\n                max_length_index=$i\n            fi\n    \
    \        (( i++ ))\n        done\n        echo \"${l[$max_length_index]}\"\n \
    \   fi", "    local longest=\"\"\n    local length=0\n    local word\n    for\
    \ word in $1\n    do\n        if [ ${#word} -gt $length ]\n        then\n    \
    \        longest=$word\n            length=${#word}\n        fi\n    done\n  \
    \  echo \"$longest\"", "  local ret=\"\"\n  local ret_len=0\n  local item=\"\"\
    \n  local item_len=0\n  local list=$1\n  for item in $list; do\n    item_len=${#item}\n\
    \    if [[ $item_len -gt $ret_len ]]; then\n      ret=$item\n      ret_len=$item_len\n\
    \    fi\n  done\n  if [[ $ret_len -eq 0 ]]; then\n    echo \"None\"\n  else\n\
    \    echo $ret\n  fi", "  local maxLength=0\n  local maxString=''\n  for s in\
    \ $*; do\n    if [[ ${#s} -gt $maxLength ]]; then\n      maxLength=${#s}\n   \
    \   maxString=$s\n    fi\n  done\n  if [[ -z $maxString ]]; then\n    echo \"\
    None\"\n  else\n    echo \"$maxString\"\n  fi", "  if [ -z \"$1\" ]; then\n  \
    \  echo \"None\"\n  else\n    echo \"$1\" | xargs -n1 | sort -n -r -k1,1 | head\
    \ -n1\n  fi", "  if [ -z \"$1\" ]; then\n    echo \"None\"\n  else\n    max_length=0\n\
    \    longest_word=''\n    for word in $1; do\n      len=${#word}\n      if [ $len\
    \ -gt $max_length ]; then\n        max_length=$len\n        longest_word=$word\n\
    \      fi\n    done\n    echo \"$longest_word\"\n  fi", "\tif [ \"$1\" == \"\"\
    \ ]; then\n\t\techo \"None\"\n\telse\n\t\techo \"$1\" | sed -r 's/\\s+/\\n/g'\
    \ | sort -nr | head -n 1\n\tfi", "    if [ -z \"$1\" ]; then\n        echo \"\
    None\"\n    else\n        echo \"$1\" | tr ' ' '\\n' | sort -rn | head -n 1\n\
    \    fi", "  local longest_string longest_length=0\n\n  for string in $1; do\n\
    \    [ ${#string} -gt $longest_length ] && longest_string=$string && longest_length=${#string}\n\
    \  done\n\n  [ -z \"$longest_string\" ] && echo \"None\" || echo \"$longest_string\"",
  "    if [ $# -eq 0 ]; then\n        echo \"None\"\n    else\n        max=0\n   \
    \     for element in $*; do\n            [ ${#element} -gt $max ] && max=${#element}\n\
    \        done\n        for element in $*; do\n            [ ${#element} -eq $max\
    \ ] && echo $element && break\n        done\n    fi", "  if [[ -z \"$1\" ]]; then\n\
    \    echo \"None\"\n  else\n    echo \"$1\" | tr \" \" \"\\n\" | sort -r -k1,1\
    \ | head -n1\n  fi", "    case $# in\n        0)\n            echo \"None\"\n\
    \            ;;\n        1)\n            echo \"$1\"\n            ;;\n       \
    \ *)\n            if [[ $1 =~ $' ' ]]; then\n                new_args=${1// /\
    \ }\n                echo \"$new_args\"\n            else\n                echo\
    \ \"$1\"\n            fi\n            ;;\n    esac", "  [[ -z \"$1\" ]] && echo\
    \ \"None\" && return\n  # For a better performance, we use external utils and\
    \ need a temporary file to read from.\n  # We need a list of lines, and a space-separated\
    \ list can be read as lines.\n  # Another option is to convert space-separated\
    \ list to a list of lines, but that might be\n  # more costly.\n  local tempfile=$(mktemp)\n\
    \  echo \"$1\" > \"$tempfile\"\n  awk '{ if (length($0) > max) max = length($0);\
    \ line = $0 } END { if (max == 0) print \"None\"; else print line }' \"$tempfile\"\
    \n  rm \"$tempfile\"", "    if [ -z \"$1\" ]; then\n        echo \"None\"\n  \
    \  else\n        echo \"$1\" | tr ' ' '\\n' | sort -r -k1,1 -t ' ' | head -n 1\n\
    \    fi", "  if [ $# -eq 0 ]; then\n    echo \"None\"\n  else\n    # Sort by length\
    \ (descending)\n    # Remove length field\n    # Remove empty strings\n    # First\
    \ line is the longest (or the first one of the longest lines in case of multiple)\n\
    \    echo \"$1\" | xargs -n1 | awk '{print length, $0}' | sort -rn | cut -d\"\
    \ \" -f2- | sed '/^$/d' | head -n1\n  fi", "  if [ -z \"$1\" ]; then\n    echo\
    \ \"None\"\n  else\n    for s in $1; do\n      if [ -z \"$longest\" ] || [ ${#s}\
    \ -gt ${#longest} ]; then\n        longest=\"$s\"\n      fi\n    done\n    echo\
    \ \"$longest\"\n  fi", "\tif test -z \"$1\"; then\n\t\techo \"None\"\n\telse\n\
    \t\techo \"$1\" | tr ' ' '\\n' | sort -n -k1,1 -t' ' | tail -n1\n\tfi", "\techo\
    \ \"$1\" | tr ' ' '\\n' |\n\t\tawk '{\n\t\t\tif (length > maxlen) {\n\t\t\t\t\
    maxlen = length;\n\t\t\t\tlongest = $0;\n\t\t\t}\n\t\t}\n\t\tEND {\n\t\t\tif (maxlen\
    \ == 0) {\n\t\t\t\tprint \"None\";\n\t\t\t} else {\n\t\t\t\tprint longest;\n\t\
    \t\t}\n\t\t}'", "  if [ $# -eq 0 ]; then\n    echo None\n  else\n    echo \"$1\"\
    \ | tr ' ' '\\n' | sort -u -k1,1 -s | tail -n1\n  fi", "    if [ -z \"$1\" ];\
    \ then\n        echo None\n    else\n        local -a LONGEST\n        IFS=' '\
    \ read -ra LONGEST <<< \"$1\"\n        local LONGEST_LEN=0\n        local -a CANDIDATES\n\
    \        for i in \"${LONGEST[@]}\"; do\n            if [ ${#i} -gt $LONGEST_LEN\
    \ ]; then\n                LONGEST_LEN=${#i}\n                CANDIDATES=(\"$i\"\
    )\n            elif [ ${#i} -eq $LONGEST_LEN ]; then\n                CANDIDATES+=(\"\
    $i\")\n            fi\n        done\n        echo \"${CANDIDATES[0]}\"\n    fi",
  "    { [ $# -gt 0 ] && printf '%s\\n' \"$@\" || printf '\\n'; } |\n    sort -r |\n\
    \    head -n 1", "  IFS=\" \"\n  read -a words <<< \"$*\"\n  if [ \"${#words[@]}\"\
    \ -eq 0 ]; then\n    echo \"None\"\n  else\n    longest_string=\"\"\n    for word\
    \ in \"${words[@]}\"; do\n      if [ \"${#word}\" -gt \"${#longest_string}\" ];\
    \ then\n        longest_string=\"$word\"\n      fi\n    done\n    echo \"$longest_string\"\
    \n  fi", "    local -r delimiter=\" \"\n    local longest=\"None\"\n    local\
    \ -i longest_len=0\n    local s\n    for s in ${1//\"$delimiter\"/ }; do\n   \
    \     local -i len=${#s}\n        if [[ $len -gt $longest_len ]]; then\n     \
    \       longest=\"$s\"\n            longest_len=$len\n        fi\n    done\n \
    \   echo \"$longest\"", "    IFS=' ' read -r -a in <<< \"$1\"\n    if [[ ${#in[@]}\
    \ -eq 0 ]]; then\n        echo \"None\"\n    else\n        max_length=0\n    \
    \    max_idx=0\n        for idx in \"${!in[@]}\"; do\n            cur_length=${#in[$idx]}\n\
    \            if [[ $cur_length -gt $max_length ]]; then\n                max_length=$cur_length\n\
    \                max_idx=$idx\n            fi\n        done\n        echo \"${in[$max_idx]}\"\
    \n    fi", "  local longest=\n  for word in $1\n  do\n    if [ \"$word\" ]\n \
    \   then\n      if [ ${#word} -gt ${#longest} ]\n      then\n        longest=$word\n\
    \      fi\n    fi\n  done\n  if [ \"$longest\" ]\n  then\n    echo \"$longest\"\
    \n  else\n    echo \"None\"\n  fi", "    local longest=\"\"\n    local longest_size=0\n\
    \    for string in \"$@\"; do\n        local string_size=${#string}\n        if\
    \ [[ $string_size -gt $longest_size ]]; then\n            longest=\"$string\"\n\
    \            longest_size=$string_size\n        fi\n    done\n    echo $longest",
  "  local i j max l\n  max=0\n  l=\"\"\n  for i in $1; do\n    j=${#i}\n    if [\
    \ $j -gt $max ]; then\n      max=$j\n      l=$i\n    fi\n  done\n  if [ $max -eq\
    \ 0 ]; then\n    echo \"None\"\n  else\n    echo \"$l\"\n  fi", "    [[ -z \"\
    $1\" ]] && echo \"None\" && return\n    arr=( $1 )\n    [[ -z \"${arr[@]}\" ]]\
    \ && echo \"None\" && return\n    longest=${arr[0]}\n    for s in \"${arr[@]}\"\
    \n    do\n        [[ ${#s} -gt ${#longest} ]] && longest=$s\n    done\n    echo\
    \ \"$longest\"", "    local maxlen=0\n    local curlen\n    local maxword\n  \
    \  for w in $1; do\n        curlen=${#w}\n        if ((curlen > maxlen)); then\n\
    \            maxlen=$curlen\n            maxword=$w\n        fi\n    done\n  \
    \  echo $maxword", "  if [[ -z \"$1\" ]]; then\n    echo \"None\"\n  else\n  \
    \  echo \"$*\" | tr ' ' '\\n' | sort -rn | head -n 1\n  fi", "  [ -z \"$1\" ]\
    \ && echo \"None\" || echo \"$1\" | tr ' ' '\\n' | sort -r | head -n 1", "\tlocal\
    \ l\n\tlocal l_len\n\tlocal i_len\n\tfor l in $1; do\n\t\ti_len=${#l}\n\t\tif\
    \ [ $i_len -gt $l_len ]; then\n\t\t\tl_len=$i_len\n\t\t\tprintf \"%s\" \"$l\"\n\
    \t\tfi\n\tdone\n\tif [ -z \"$l_len\" ]; then\n\t\tprintf \"%s\" \"None\"\n\tfi",
  "  echo \"$*\" |\n    sed -e 's/\\([^ ]*\\) .*/\\1/' -e 't done' -e ':loop' -e 'N'\
    \ -e 's/\\([^ ]*\\) \\([^ ]*\\)\\n.*/\\2 \\1/' -e 't loop' -e ':done'", "  echo\
    \ $1 | tr ' ' '\\n' | \\\n    awk 'BEGIN { max = 0; } { if (length($0) > max)\
    \ { max = length($0); longest = $0; }} END { if (max == 0) { print \"None\"; }\
    \ else { print longest; }}'", "  longest=\"\"\n  longest_count=0\n  for word in\
    \ $@; do\n    current_count=${#word}\n    if [[ \"$current_count\" -gt \"$longest_count\"\
    \ ]]; then\n      longest=\"$word\"\n      longest_count=\"$current_count\"\n\
    \    fi\n  done\n  [[ \"$longest\" ]] || echo \"None\"\n  echo \"$longest\"",
  "    if [ -z \"$1\" ]; then\n        echo None\n    else\n        echo $1 | tr '\
    \ ' '\\n' | sort -g -r | head -n 1\n    fi", "    local max_len=0\n    local max_str=\n\
    \    for curr_str in $1; do\n        len=${#curr_str}\n        if [ $len -gt $max_len\
    \ ]; then\n            max_len=$len\n            max_str=$curr_str\n        fi\n\
    \    done\n    if [ $max_len -eq 0 ]; then\n        echo \"None\"\n    else\n\
    \        echo \"$max_str\"\n    fi", "    if [[ -z \"$1\" ]]; then\n        echo\
    \ \"None\"\n    else\n        echo \"$1\" | awk '\n            BEGIN { max_len\
    \ = 0; max_word = \"\" }\n            { for (i = 1; i <= NF; i++) {\n        \
    \        if (length($i) > max_len) {\n                    max_len = length($i);\n\
    \                    max_word = $i;\n                }\n            }}\n     \
    \       END { print max_word }\n        '\n    fi", "  local str\n  local longest_str\n\
    \  local longest_len=0\n  for str in $1; do\n    len=${#str}\n    if [[ $len -gt\
    \ $longest_len ]]; then\n      longest_str=$str\n      longest_len=$len\n    fi\n\
    \  done\n  if [[ -z $longest_str ]]; then\n    echo None\n  else\n    echo $longest_str\n\
    \  fi", "    if [ -z \"$1\" ]; then\n        echo \"None\"\n    else\n       \
    \ local max_length=0\n        local max_words=()\n        for word in $1; do\n\
    \            local length=${#word}\n            if [ $length -gt $max_length ];\
    \ then\n                max_length=$length\n                max_words=(\"$word\"\
    )\n            elif [ $length -eq $max_length ]; then\n                max_words+=(\"\
    $word\")\n            fi\n        done\n        echo \"${max_words[0]}\"\n   \
    \ fi", "  if [ -z \"$1\" ]; then\n    echo None\n  else\n    for item in $1; do\n\
    \      if [ -z \"$longest\" ] || [ \"${#item}\" -gt \"${#longest}\" ]; then\n\
    \        longest=\"$item\"\n      fi\n    done\n    echo \"$longest\"\n  fi",
  "    res=\"\"\n    for i in $*; do\n        if [[ -z \"$res\" ]]; then\n       \
    \     res=\"$i\"\n        elif [[ \"${#i}\" -gt \"${#res}\" ]]; then\n       \
    \     res=\"$i\"\n        fi\n    done\n    [[ -z \"$res\" ]] && echo \"None\"\
    \ || echo \"$res\"", "    IFS=' ' read -r -a array <<< \"$1\"\n    longest=\"\"\
    \n    for item in \"${array[@]}\"; do\n        if [ -z \"$longest\" ] || [ ${#item}\
    \ -gt ${#longest} ]; then\n            longest=\"$item\"\n        fi\n    done\n\
    \    echo \"$longest\"", "\tif [ -z \"$1\" ]; then\n\t\techo \"None\"\n\telse\n\
    \t\techo \"$*\" | tr ' ' '\\n' | sort -r -k 1,1 -n | head -n 1\n\tfi", "    if\
    \ [[ \"$#\" -eq 0 ]]; then\n        echo \"None\"\n    else\n        longest=$1\n\
    \        for arg in \"$@\"; do\n            if [[ ${#arg} -gt ${#longest} ]];\
    \ then\n                longest=$arg\n            fi\n        done\n        echo\
    \ \"$longest\"\n    fi", "\t[ $# -eq 0 ] && echo \"None\" && return\n\tset --\
    \ $*\n\t[ $# -eq 1 ] && echo \"$1\" && return\n\t[ ${#1} -gt ${#2} ] && longest\
    \ \"$1\" \"${@:3}\" && return\n\tlongest \"$2\" \"${@:3}\"", "  local list=\"\
    $1\"\n  if [[ -z \"$list\" ]]; then\n    echo \"None\"\n  else\n    longest_str_len=0\n\
    \    longest_str=\"\"\n    for i in $list; do\n      str_len=${#i}\n      if [[\
    \ \"$str_len\" -gt \"$longest_str_len\" ]]; then\n        longest_str_len=$str_len\n\
    \        longest_str=$i\n      fi\n    done\n    echo \"$longest_str\"\n  fi",
  "    test -z \"$1\" && echo \"None\" && return 0\n\n    local LONGEST=\n    local\
    \ TEMP=\n    for str in $1; do\n        test ${#str} -gt ${#LONGEST} && LONGEST=$str\n\
    \    done\n    echo $LONGEST", "  test -z \"$1\" && echo \"None\" && return 0\n\
    \  readarray -t arr <<< \"$1\"\n  len=$(echo \"${arr[@]}\" | wc -L)\n  echo \"\
    ${arr[@]}\" | grep -m 1 \"^.\\{$len\\}\"", "  longest_string=\"None\"\n  for string\
    \ in $1; do\n    if [ -z \"$string\" ]; then\n      continue\n    fi\n    if [\
    \ \"${#string}\" -gt \"${#longest_string}\" ]; then\n      longest_string=\"$string\"\
    \n    fi\n  done\n  echo \"$longest_string\"", "  [[ -z \"$1\" ]] && echo \"None\"\
    \ && return\n  longest=\"$1\"\n  for str in $1; do\n    [[ ${#str} -gt ${#longest}\
    \ ]] && longest=\"$str\"\n  done\n  echo \"$longest\"", "  if [ -z \"$1\" ]; then\n\
    \    echo \"None\"\n  else\n    set $1\n    longest_string=$1\n    for string;\
    \ do\n      string_length=${#string}\n      longest_string_length=${#longest_string}\n\
    \      if [ $string_length -gt $longest_string_length ]; then\n        longest_string=$string\n\
    \      fi\n    done\n    echo \"$longest_string\"\n  fi", "  local longest_length\
    \ longest_string\n  local i length word\n  for i in $*; do\n    word=\"$i\"\n\
    \    length=${#word}\n    if [[ -z $longest_length || $length -gt $longest_length\
    \ ]]; then\n      longest_length=$length\n      longest_string=\"$word\"\n   \
    \ fi\n  done\n  echo \"$longest_string\"", "    local max=\"\"\n    local word=\"\
    \"\n    local len=\"\"\n    local max_len=\"\"\n    while read -r word; do\n \
    \       len=${#word}\n        max_len=${#max}\n        if [ $len -gt $max_len\
    \ ]; then\n            max=$word\n        fi\n    done <<< \"$1\"\n    echo $max",
  "    local longest=\"\"\n    local next=\"\"\n    while read -r -d ' ' next; do\n\
    \        if [[ -z \"$longest\" ]]; then\n            longest=\"$next\"\n     \
    \   else\n            if [[ \"${#next}\" -gt \"${#longest}\" ]]; then\n      \
    \          longest=\"$next\"\n            fi\n        fi\n    done <<< \"$1\"\n\
    \    echo \"$longest\"", "    local longest=\"\"\n    for el in $1; do\n     \
    \   if [ \"${#el}\" -gt \"${#longest}\" ]; then\n            longest=\"$el\"\n\
    \        fi\n    done\n    if [ -z \"$longest\" ]; then\n        echo \"None\"\
    \n    else\n        echo \"$longest\"\n    fi", "  _longest_list=\"$@\"\n  if\
    \ [ \"x$_longest_list\" = \"x\" ]; then\n    echo \"None\"\n  else\n    longest_max_len=0\n\
    \    longest_i=0\n    for i in $_longest_list; do\n      if [ ${#i} -gt $longest_max_len\
    \ ]; then\n        longest_max_len=${#i}\n        longest_i=$i\n      fi\n   \
    \ done\n    echo \"$longest_i\"\n  fi", "    # find the length of the longest\
    \ string\n    # map every string to its length\n    # return the maximum value\n\
    \    local longest_len=$(echo \"$*\" | tr ' ' '\\n' | awk '{ print length($0)\
    \ }' | sort -n | tail -n 1)\n    # return the first string that matches the above\
    \ length\n    local longest_str=$(echo \"$*\" | tr ' ' '\\n' | awk '{ print length($0)\
    \ }' | awk '$1 == '$longest_len' { print $0 }' | head -n 1)\n    echo \"$longest_str\"",
  "\tif [ -z \"$1\" ]; then\n\t\techo \"None\"\n\telse\n\t\techo \"$1\" | tr \" \"\
    \ \"\\n\" | sort -nr | head -n 1\n\tfi", "  [ $# -ne 0 ] || { echo \"None\"; return;\
    \ }\n  # Assuming there's at least one parameter and at least one word\n  max_len=0\n\
    \  max_str=\"\"\n  for x in $@; do\n    # echo $x \"${#x}\"\n    if [ ${#x} -gt\
    \ $max_len ]; then\n      max_len=${#x}\n      max_str=$x\n    fi\n  done\n  echo\
    \ $max_str", "\tif [ -z \"$1\" ]; then\n\t\techo \"None\"\n\telse\n\t\tlocal max=0\
    \ max_str\n\t\tfor str in $1; do\n\t\t\t[ ${#str} -gt $max ] && max=${#str} &&\
    \ max_str=$str\n\t\tdone\n\t\techo \"$max_str\"\n\tfi", "  local longest_str\n\
    \  for e in $1; do\n    if [ -z \"$longest_str\" ] || [ ${#e} -gt ${#longest_str}\
    \ ]; then\n      longest_str=$e\n    fi\n  done\n  if [ -z \"$longest_str\" ];\
    \ then\n    echo \"None\"\n  else\n    echo \"$longest_str\"\n  fi", "\tlocal\
    \ list=(\"$@\")\n\tlocal longest=\"\"\n\tlocal max_length=0\n\tfor s in \"${list[@]}\"\
    ; do\n\t\tif [[ ${#s} -gt $max_length ]]; then\n\t\t\tlongest=\"$s\"\n\t\t\tmax_length=${#s}\n\
    \t\tfi\n\tdone\n\tif [[ -z $longest ]]; then\n\t\techo None\n\telse\n\t\techo\
    \ \"$longest\"\n\tfi", "    local longest_string\n    longest_string=$(echo \"\
    $1\" | tr \" \" \"\\n\" | sort -r | head -n 1)\n    [[ -z \"$longest_string\"\
    \ ]] && echo \"None\" || echo \"$longest_string\"", "  local longest=''\n  local\
    \ cur=''\n  for word in $1\n  do\n    if [ ${#word} -gt ${#longest} ]\n    then\n\
    \      longest=$word\n    fi\n  done\n  if [ -z \"$longest\" ]\n  then\n    echo\
    \ 'None'\n  else\n    echo $longest\n  fi", "  if [ -z \"$1\" ]; then\n    echo\
    \ None\n  else\n    echo \"$1\" | sed 's/\\s/\\n/g' | sort -nr | head -n 1\n \
    \ fi", "    local longest\n    if [ -z \"$1\" ]; then\n        echo \"None\"\n\
    \    else\n        for string in $1; do\n            if [ -z \"$longest\" ] ||\
    \ [ ${#string} -gt ${#longest} ]; then\n                longest=\"$string\"\n\
    \            fi\n        done\n        echo \"$longest\"\n    fi", "  {\n    [[\
    \ $# = 0 ]] && echo \"None\" && return\n    local max=0\n    local max_str=\n\
    \    for s in $@; do\n      local len=${#s}\n      [[ $len -gt $max ]] && max=$len\
    \ && max_str=$s\n    done\n    echo \"$max_str\"\n  }", "\tmax_len=0\n\tmax_str=\n\
    \tfor str in $1; do\n\t\t[[ ${#str} -gt $max_len ]] && max_len=${#str} && max_str=$str\n\
    \tdone\n\t[[ -z $max_str ]] && echo \"None\" || echo \"$max_str\"", "    awk 'BEGIN\
    \ {\n        longest_len = 0\n        longest_word = \"None\"\n    } {\n     \
    \   for (i = 1; i <= NF; i++) {\n            if (length($i) > longest_len) {\n\
    \                longest_len = length($i)\n                longest_word = $i\n\
    \            }\n        }\n    } END {\n        print longest_word\n    }' <<<\
    \ \"$1\"", "    if [ -z \"$1\" ]; then\n        echo \"None\"\n    else\n    \
    \    echo \"$1\" | \\\n            tr ' ' '\\n' | \\\n            awk '{ if (length($0)\
    \ > max) { max = length($0); maxline = $0 } } END { print maxline }'\n    fi",
  "  if [[ -z \"$1\" ]]; then\n    echo \"None\"\n  else\n    echo \"$1\" | tr ' '\
    \ '\\n' | sort -nr | head -n 1\n  fi", "    local rv=$(for i in $1; do echo ${#i};\
    \ done | sort -n | tail -n 1)\n    if [ -z \"$rv\" ]; then\n        echo \"None\"\
    \n    else\n        for i in $1; do\n            if [ ${#i} -eq $rv ]; then\n\
    \                echo $i\n                break\n            fi\n        done\n\
    \    fi", "  longest=$(echo $1 | tr ' ' '\\n' | sort -r -n -k1,1 | head -n 1)\n\
    \  if [ -z \"$longest\" ]; then\n    echo \"None\"\n  else\n    echo \"$longest\"\
    \n  fi", "  local ret=\"\"\n  local i=\"\"\n  for i in ${1+\"$@\"}; do\n    if\
    \ [ -z \"$ret\" ]; then\n      ret=\"$i\"\n    elif [ ${#i} -gt ${#ret} ]; then\n\
    \      ret=\"$i\"\n    fi\n  done\n  if [ -z \"$ret\" ]; then\n    echo \"None\"\
    \n  else\n    echo \"$ret\"\n  fi", "    if [[ -z \"$1\" ]]; then\n        echo\
    \ \"None\"\n    else\n        echo \"$1\" | tr ' ' '\\n' | sort -r -k1,1V -k2n\
    \ | head -n1\n    fi", "  __longest_list=$(echo \"$1\" | tr ' ' '\\n' | sort -nr\
    \ -k1,1 | head -n1)\n  if [[ -z \"$__longest_list\" ]]; then\n    echo \"None\"\
    \n  else\n    echo \"$__longest_list\"\n  fi", "    local strs=$1 longest\n  \
    \  for str in $strs; do\n        if [ -z \"$longest\" ] || [ ${#str} -gt ${#longest}\
    \ ]; then\n            longest=$str\n        fi\n    done\n    if [ -z \"$longest\"\
    \ ]; then\n        echo None\n    else\n        echo $longest\n    fi", "    if\
    \ [ -z \"$1\" ]; then\n        echo \"None\"\n    else\n        echo \"$1\" |\
    \ tr ' ' '\\n' | sort -rn | head -n 1\n    fi", "    local len=0\n    local item=\"\
    \"\n    local i=0\n    for word in $1; do\n        if [[ ${#word} -gt $len ]];\
    \ then\n            len=${#word}\n            item=\"$word\"\n        fi\n   \
    \ done\n    echo \"$item\"", "  if [ \"$#\" -eq 0 ]; then\n    echo \"None\"\n\
    \  else\n    longest=\"$1\"\n    for x in $@; do\n      if [ ${#x} -gt ${#longest}\
    \ ]; then\n        longest=\"$x\"\n      fi\n    done\n    echo \"$longest\"\n\
    \  fi", "  if [ -z \"$1\" ]; then\n    echo \"None\"\n  else\n    longest_word=\"\
    \"\n    longest_word_len=0\n    for word in $1; do\n      word_len=${#word}\n\
    \      if [ $word_len -gt $longest_word_len ]; then\n        longest_word=$word\n\
    \        longest_word_len=$word_len\n      fi\n    done\n    echo \"$longest_word\"\
    \n  fi", "\tlocal -a strarr\n\tlocal -i i j len len_max\n\tlocal elt maxelt\n\n\
    \tif [ -z \"$1\" ]; then\n\t\techo \"None\"\n\t\treturn 0\n\tfi\n\n\tstrarr=($1)\n\
    \tlen_max=0\n\tfor ((i=0; i<${#strarr[@]}; i++)); do\n\t\telt=${strarr[$i]}\n\t\
    \tlen=${#elt}\n\t\tif [ $len -gt $len_max ]; then\n\t\t\tlen_max=$len\n\t\t\t\
    maxelt=$elt\n\t\tfi\n\tdone\n\techo \"$maxelt\"", "\t[[ -z \"$1\" ]] && { echo\
    \ \"None\"; return; }\n\tlocal longest_so_far length=$(echo \"$1\" | wc -w)\n\t\
    for word in $1; do\n\t\t[[ ${#word} -gt $length ]] && { longest_so_far=$word;\
    \ length=${#word}; }\n\tdone\n\techo \"$longest_so_far\"", "  longest_str=\"$(printf\
    \ \"%s\\n\" \"$@\" | awk '\n    { if (length($0) > len) { len = length($0); longest\
    \ = $0 } }\n    END { print longest }\n  ')\"\n  if [ -z \"$longest_str\" ]; then\n\
    \    longest_str=\"None\"\n  fi\n  echo \"$longest_str\"", "    if [[ \"$1\" =~\
    \ \" \" ]]; then\n        echo \"$1\" | tr ' ' '\\n' | tr '\\n' ' ' | sed -e 's/^\
    \ *//g' -e 's/ *$//g' | sort -rn | sed -e 's/^ *//g' -e 's/ *$//g' | head -n 1\n\
    \    else\n        echo \"$1\"\n    fi", "\tlocal strings=$1\n\t[ -z \"$strings\"\
    \ ] && echo \"None\" && return\n\tIFS=\" \" read -ra strs <<< \"$strings\"\n\t\
    max_length=0\n\tlongest_string=\"\"\n\tfor str in \"${strs[@]}\"; do\n\t\tlen=${#str}\n\
    \t\tif [ $len -gt $max_length ]; then\n\t\t\tmax_length=$len\n\t\t\tlongest_string=$str\n\
    \t\tfi\n\tdone\n\techo \"$longest_string\"", "    [[ $# -gt 0 ]] || { echo \"\
    None\"; return; }\n    local maxlen=0\n    local maxstr=\n    for str in $*; do\n\
    \        len=${#str}\n        if [[ $len -gt $maxlen ]]; then\n            maxlen=$len\n\
    \            maxstr=$str\n        fi\n    done\n    echo \"$maxstr\"", "\tif [\
    \ $# -eq 0 ]; then\n\t\techo \"None\"\n\t\treturn\n\tfi\n\twords=($1)\n\tword=${words[0]}\n\
    \tfor i in \"${words[@]:1}\"; do\n\t\tif [ ${#i} -gt ${#word} ]; then\n\t\t\t\
    word=$i\n\t\tfi\n\tdone\n\techo \"$word\"", "  case $# in\n    0)\n      echo\
    \ None\n      ;;\n    *)\n      echo \"$@\" | tr ' ' '\\n' | sort -r -k 1,1 |\
    \ head -n 1\n      ;;\n  esac", "\t[ $# -eq 0 ] && echo \"None\" && return 1\n\
    \tif [ -z \"$1\" ]; then\n\t\techo \"None\"\n\t\treturn 1\n\tfi\n\techo \"$1\"\
    \ | tr \" \" \"\\n\" | sort -r -t' ' -k1.1,1.1 | head -n1", "    if [ $# -eq 0\
    \ ]; then\n        echo \"None\"\n    else\n        longest=\"\"\n        for\
    \ word in $*; do\n            if [ ${#word} -gt ${#longest} ]; then\n        \
    \        longest=$word\n            fi\n        done\n        echo $longest\n\
    \    fi", "    # Empty list\n    if [ -z \"$1\" ]; then\n        echo \"None\"\
    \n        return\n    fi\n\n    # Single element list\n    if [ \"$(echo \"$1\"\
    \ | wc -w)\" = \"1\" ]; then\n        echo \"$1\"\n        return\n    fi\n\n\
    \    # Multiple elements\n    # Find the longest string in the list\n    longest=$(echo\
    \ \"$1\" | tr \" \" \"\\n\" | sort -n -r -k 1 | head -n 1)\n    # Return the first\
    \ occurrence\n    echo \"$1\" | tr \" \" \"\\n\" | grep -m 1 \"^$longest$\"",
  "  local longest_word=\n  for word in $1; do\n    # echo \"word: $word\"\n    if\
    \ [[ -z $longest_word ]]; then\n      longest_word=$word\n    elif [[ ${#word}\
    \ -gt ${#longest_word} ]]; then\n      longest_word=$word\n    fi\n  done\n  if\
    \ [[ -z $longest_word ]]; then\n    echo \"None\"\n  else\n    echo \"$longest_word\"\
    \n  fi", "\ttest -z \"$1\" && echo None && return\n\techo \"$1\" | awk '\n\tBEGIN\
    \ {\n\t\tlongest = 0\n\t\tnum_longest = 0\n\t}\n\t{\n\t\tif (length($1) > longest)\
    \ {\n\t\t\tlongest = length($1)\n\t\t\tnum_longest = 1\n\t\t\tlongest[num_longest]\
    \ = $1\n\t\t} else if (length($1) == longest) {\n\t\t\tnum_longest++\n\t\t\tlongest[num_longest]\
    \ = $1\n\t\t}\n\t}\n\tEND {\n\t\tprint longest[1]\n\t}'", "    [[ $# == 0 ]] &&\
    \ echo \"None\" && return\n    local maxlen=0\n    local maxstr=\n    for word\
    \ in $1; do\n        [[ ${#word} -gt $maxlen ]] && maxlen=${#word} && maxstr=$word\n\
    \    done\n    echo \"$maxstr\"", "    local longest=\"\"\n    for word in $1;\
    \ do\n        if [ -z \"$longest\" ]; then\n            longest=\"$word\"\n  \
    \      elif [ ${#word} -gt ${#longest} ]; then\n            longest=\"$word\"\n\
    \        fi\n    done\n    if [ -z \"$longest\" ]; then\n        echo \"None\"\
    \n    else\n        echo \"$longest\"\n    fi", "    local longest=\"\"\n    local\
    \ current=\"\"\n    for current in $1; do\n        if [[ -z \"$longest\" ]] ||\
    \ [[ ${#current} -gt ${#longest} ]]; then\n            longest=\"$current\"\n\
    \        fi\n    done\n    if [[ -z \"$longest\" ]]; then\n        echo \"None\"\
    \n    else\n        echo \"$longest\"\n    fi", "    local max_len=0\n    local\
    \ arg=\n    local longest_arg=\n\n    for arg in $*; do\n        len=${#arg}\n\
    \        if [ $len -gt $max_len ]; then\n            max_len=$len\n          \
    \  longest_arg=$arg\n        fi\n    done\n\n    if [ -z \"$longest_arg\" ]; then\n\
    \        longest_arg=\"None\"\n    fi\n\n    echo \"$longest_arg\"", "    (IFS=\\\
    \ \n        longest=\"\"\n        for word in $1; do\n            if [[ \"$word\"\
    \ != \"\" ]]; then\n                if [[ -z \"$longest\" ]]; then\n         \
    \           longest=\"$word\"\n                elif [[ ${#word} -gt ${#longest}\
    \ ]]; then\n                    longest=\"$word\"\n                fi\n      \
    \      fi\n        done\n        if [[ -z \"$longest\" ]]; then\n            echo\
    \ \"None\"\n        else\n            echo \"$longest\"\n        fi\n    )", " \
    \   local maxlen=0\n    local maxidx=-1\n    local wordlen=0\n    local idx=0\n\
    \    for word in $1; do\n        wordlen=${#word}\n        if [ $wordlen -gt $maxlen\
    \ ]; then\n            maxlen=$wordlen\n            maxidx=$idx\n        fi\n\
    \        idx=$(($idx + 1))\n    done\n    if [ $maxidx -eq -1 ]; then\n      \
    \  echo \"None\"\n    else\n        echo $1 | cut -d ' ' -f $maxidx\n    fi",
  "\tif [ \"$#\" -eq 0 ]; then\n\t\techo \"None\"\n\telse\n\t\techo \"$1\" | tr '\
    \ ' '\\n' | sort -b -s -k1,1 -k2,2nr | head -n1\n\tfi", "    if [ \"$#\" -eq 0\
    \ ]; then\n        echo \"None\"\n    else\n        echo $* | cut -d' ' -f1\n\
    \    fi", "    if [ -z \"$1\" ]; then\n        echo \"None\"\n    else\n     \
    \   echo \"$1\" | awk '\n        {\n            maxlen = length($1)\n        \
    \    maxstr = $1\n            for (i = 2; i <= NF; i++) {\n                if\
    \ (length($i) > maxlen) {\n                    maxlen = length($i)\n         \
    \           maxstr = $i\n                }\n            }\n            print maxstr\n\
    \        }'\n    fi", "\tif [[ -z \"$1\" ]]; then\n\t\techo \"None\"\n\telse\n\
    \t\techo \"$1\" | tr ' ' '\\n' | sort -r -n -k 1 | head -n 1\n\tfi", "  # The\
    \ command does not always return the output it should, \n  # a workaround is to\
    \ store the output in a variable\n  longest=$(echo \"$1\" | tr \" \" \"\\n\" |\
    \ awk '{ if (length > max) max = length } END { print max }')\n  if [ -z \"$longest\"\
    \ ]; then\n    echo \"None\"\n  else\n    echo \"$longest\"\n  fi", "    [ -z\
    \ \"$1\" ] && echo \"None\" && return\n    longest=$(echo \"$1\" | tr ' ' '\\\
    n' | head -n 1)\n    longest_len=${#longest}\n    for s in $1; do\n        s_len=${#s}\n\
    \        if [ $s_len -gt $longest_len ]; then\n            longest=$s\n      \
    \      longest_len=$s_len\n        fi\n    done\n    echo \"$longest\"", "   \
    \ if [ -z \"$1\" ]; then\n        echo \"None\"\n    else\n        echo \"$1\"\
    \ | tr ' ' '\\n' | sort -r -k 1 -n | head -n 1\n    fi", "\tlocal longest;\n\t\
    local current;\n\tfor i in $1; do\n\t\tcurrent=$(echo -n \"$i\" | wc -c)\n\t\t\
    if [[ \"$longest\" -lt \"$current\" ]]; then\n\t\t\tlongest=\"$current\"\n\t\t\
    fi\n\tdone\n\tif [[ \"$longest\" -gt 0 ]]; then\n\t\techo \"$longest\"\n\telse\n\
    \t\techo \"None\"\n\tfi", "    local maxlen=0 longest=None\n    for i in $1\n\
    \    do\n        len=${#i}\n        if [ $len -gt $maxlen ]\n        then\n  \
    \          maxlen=$len\n            longest=$i\n        fi\n    done\n    echo\
    \ $longest", "    local max_length=0\n    local longest=\"\"\n    for s in $1\n\
    \    do\n        local length=${#s}\n        if [ $length -gt $max_length ]\n\
    \        then\n            max_length=$length\n            longest=$s\n      \
    \  fi\n    done\n    echo \"$longest\"", "    set -- $1\n    L=$1\n    if [ $#\
    \ -eq 0 ]; then\n        echo \"None\"\n    else\n        for i in $*; do\n  \
    \          if [ ${#i} -gt ${#L} ]; then\n                L=$i\n            fi\n\
    \        done\n        echo $L\n    fi", "    local longest_string\n    if [[\
    \ $# -eq 0 ]]; then\n        echo \"None\"\n    else\n        longest_string=$1\n\
    \        for i in $@; do\n            if [[ ${#i} -gt ${#longest_string} ]]; then\n\
    \                longest_string=$i\n            fi\n        done\n        echo\
    \ \"$longest_string\"\n    fi", "    if [ -z \"$1\" ]; then\n        echo \"None\"\
    \n    else\n        echo \"$1\" | tr ' ' '\\n' | sort -r | head -n 1\n    fi",
  "    if [[ -z \"$1\" ]]; then\n        echo \"None\"\n    else\n        echo \"\
    $1\" | awk '\n            BEGIN {\n                longest = 0\n             \
    \   longest_line = \"None\"\n            }\n            {\n                if\
    \ (length > longest) {\n                    longest = length\n               \
    \     longest_line = $0\n                }\n            }\n            END {\n\
    \                print longest_line\n            }\n        '\n    fi", "\tif\
    \ [ \"$#\" -eq 0 ]; then\n\t\techo \"None\"\n\telse\n\t\tlocal longest=\"$1\"\n\
    \t\tshift\n\t\tfor s in \"$@\"; do\n\t\t\tif [ ${#s} -gt ${#longest} ]; then\n\
    \t\t\t\tlongest=\"$s\"\n\t\t\tfi\n\t\tdone\n\t\techo \"$longest\"\n\tfi", "  if\
    \ [ -z \"$1\" ]; then\n    echo \"None\"\n  else\n    echo \"$1\" | tr ' ' '\\\
    n' | longest_line\n  fi", "  if [ $# -eq 0 ]; then\n    echo \"None\"\n  else\n\
    \    longest=\n    for i in $*; do\n      if [ -z \"$longest\" ] || [ ${#i} -gt\
    \ ${#longest} ]; then\n        longest=$i\n      fi\n    done\n    echo \"$longest\"\
    \n  fi", '    [ $# -eq 0 ] && echo "None" || echo "$@" | tr " " "\n" | sort -t
    . -k 1,1nr -k 2,2nr -k 3,3nr -k 4,4nr | head -n 1', "    [[ -z \"$1\" ]] && echo\
    \ \"None\" && return\n    while read -r x; do\n        if [[ -z \"${longest_str:-}\"\
    \ ]] || (( ${#x} > ${#longest_str} )); then\n            longest_str=\"$x\"\n\
    \        fi\n    done <<< \"$1\"\n    echo \"$longest_str\"", "    if [[ -z \"\
    $1\" ]]; then\n        echo \"None\"\n    else\n        echo \"$1\" | tr \" \"\
    \ \"\\n\" | sort -r -k 1 | head -n 1\n    fi", "  readonly local result\n  result=\n\
    \  if [ $# -ne 0 ]; then\n    while [ $# -ne 0 ]; do\n      if [ -z \"$result\"\
    \ ] || [ \"${#1}\" -gt \"${#result}\" ]; then\n        result=\"$1\"\n      fi\n\
    \      shift\n    done\n  else\n    result=\"None\"\n  fi\n  echo \"$result\"",
  "    if [ \"$#\" -eq 0 ]; then\n        echo \"None\"\n    else\n        local max_length=0\n\
    \        local max_length_index=0\n        for i in $(seq 0 $(($# - 1))); do\n\
    \            if [ \"${#1}\" -gt \"$max_length\" ]; then\n                max_length=\"\
    ${#1}\"\n                max_length_index=\"$i\"\n            fi\n           \
    \ shift\n        done\n        for i in $(seq 0 \"$max_length_index\"); do\n \
    \           shift\n        done\n        echo \"$1\"\n    fi", "\tawk '{max =\
    \ length(max) < length($0) ? $0 : max } END { if (max == \"\") print \"None\"\
    ; else print max }' <<< \"$1\"", "    [[ -z \"$1\" ]] && { echo \"None\"; return;\
    \ }\n    echo \"$1\" | awk '{a=0; m=\"\"} {for (i=1; i<=NF; i++) {if (length($i)\
    \ > a) {a=length($i); m=$i}} print m}'", "    if [ \"$#\" -eq \"0\" ]; then\n\
    \        echo \"None\"\n    else\n        echo \"$1\" | tr ' ' '\\n' | sort -t\
    \ ' ' -k 1,1 -n -r | head -n 1\n    fi", "\tlocal longest=\n\tlocal len=0\n\t\
    for item in $1; do\n\t\tif [ ${#item} -gt $len ]; then\n\t\t\tlongest=$item\n\t\
    \t\tlen=${#item}\n\t\tfi\n\tdone\n\techo $longest", "  awk 'BEGIN {max=0} {\n\
    \    split($0,t,\" \");\n    for (i in t) {\n      if (length(t[i]) > max) {\n\
    \        max = length(t[i]);\n        ans = t[i];\n      }\n    }\n  } END {\n\
    \    if (max == 0) {\n      print \"None\";\n    } else {\n      print ans;\n\
    \    }\n  }' <<< \"$1\"", "  local longest=\"\"\n  if [ -z \"$1\" ]; then\n  \
    \  echo \"None\"\n  else\n    longest=$(echo \"$1\" | sed -n \"s/^\\(.*\\) \\\
    (.*\\)/\\2 \\1/p\" | sort -n | tail -n 1 | sed \"s/ .*//\")\n    echo \"$longest\"\
    \n  fi", "    [ -z \"$1\" ] && echo \"None\" || echo $* | tr ' ' '\\n' | sort\
    \ -r -k1,1 | head -n1", "    local -a arr=( $1 )\n\n    if [ ${#arr[@]} -eq 0\
    \ ]; then\n        echo \"None\"\n    else\n        # https://stackoverflow.com/a/25228679/1360263\n\
    \        local longest_string=\"\"\n        local longest_string_length=0\n  \
    \      for elem in \"${arr[@]}\"; do\n            if [ ${#elem} -gt $longest_string_length\
    \ ]; then\n                longest_string=$elem\n                longest_string_length=${#elem}\n\
    \            fi\n        done\n        echo \"$longest_string\"\n    fi", "  if\
    \ [ -z \"$1\" ]; then\n    echo \"None\"\n  else\n    echo \"$1\" | tr \" \" \"\
    \\n\" | sort -n -r -k1,1 | head -n 1\n  fi", "  [[ -z \"$1\" ]] && echo \"None\"\
    \ && return\n  declare -a length=($(echo \"$1\" | tr ' ' '\\n' | wc -L))\n  if\
    \ [[ \"${#length[@]}\" -gt 1 ]]; then\n    max=0\n    max_index=0\n    for i in\
    \ \"${!length[@]}\"; do\n      [[ \"${length[$i]}\" -gt \"$max\" ]] && max=\"\
    ${length[$i]}\" && max_index=\"$i\"\n    done\n    echo \"$(echo \"$1\" | cut\
    \ -d' ' -f$(($max_index + 1)))\"\n  else\n    echo \"$1\"\n  fi"]
stop_tokens:
- "\n}"
