name: HumanEval_12_longest
language: sh
prompt: "#!/bin/bash\n# Out of list of strings, return the longest one. Return the\
  \ first one in case of multiple\n# strings of the same length. Return None in case\
  \ the input list is empty.\n# >>> $(longest \"\")\n# \"None\"\n# >>> $(longest \"\
  a b c\")\n# \"a\"\n# >>> $(longest \"a bb ccc\")\n# \"ccc\"\n#\n# $1 is a space-separated\
  \ list\nlongest() {\n"
tests: "}\n\ncandidate() {\n    longest \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
  \ $(candidate \"\") = \"None\" ]]\n    [[ $(candidate \"x y z\") = \"x\" ]]\n  \
  \  [[ $(candidate \"x yyy zzzz www kkkk abc\") = \"zzzz\" ]]\n}\n\nrun_test"
completions: ["  if [ -z \"$1\" ]; then\n    echo \"None\"\n  else\n    echo \"$1\"\
    \ | tr ' ' '\\n' | awk '{ if (max == \"\" || length($0) > max) { max = length($0);\
    \ max_string = $0; } } END { print max_string }'\n  fi", "    longest_str=\"\"\
    \n    longest_str_len=0\n    for w in $1; do\n        w_len=${#w}\n        if\
    \ [ $w_len -gt $longest_str_len ]; then\n            longest_str_len=$w_len\n\
    \            longest_str=$w\n        fi\n    done\n    if [ $longest_str_len -eq\
    \ 0 ]; then\n        echo \"None\"\n    else\n        echo \"$longest_str\"\n\
    \    fi", "  x=$(echo $1 | sed 's|\\ |\\n|g' | sort -r -k1,1 | head -n1)\n  if\
    \ [ -z \"$x\" ]; then\n    echo \"None\"\n  else\n    echo \"$x\"\n  fi", "  if\
    \ [[ \"$#\" -eq 0 ]]; then\n    echo \"None\"\n  else\n    echo \"$*\" | tr '\
    \ ' '\\n' | sort -r -k1.4 | head -n1\n  fi", "  declare -a strs\n  strs=($@)\n\
    \  if [ \"${#strs[@]}\" -eq 0 ]; then\n    echo \"None\"\n  else\n    echo $(sort\
    \ <<< \"${strs[*]}\" | tail -n 1)\n  fi", "    local result='None'\n    local\
    \ longest_length=0\n    for i in $1; do\n        local current_length=$(echo $i\
    \ | wc -c)\n        if [ $current_length -gt $longest_length ]; then\n       \
    \     longest_length=$current_length\n            result=$i\n        fi\n    done\n\
    \    echo $result", "    if [[ -z \"$1\" ]]; then\n        echo \"None\"\n   \
    \ else\n        echo \"$1\" | awk '{ for (i=1; i<=NF; i++) { len[i] = length($i)\
    \ } max = len[1]; maxind = 1; for (i=2; i<=NF; i++) { if (len[i] > max) { max\
    \ = len[i]; maxind = i } } print $maxind }'\n    fi", "  list_length=0\n  longest_word=\"\
    \"\n  while [[ $# -gt 0 ]]; do\n    word=\"$1\"\n    ((word_length=${#word}))\n\
    \    if [[ $word_length -gt $list_length ]]; then\n      list_length=$word_length\n\
    \      longest_word=\"$word\"\n    fi\n    shift\n  done\n  if [[ $list_length\
    \ -eq 0 ]]; then\n    echo None\n  else\n    echo \"$longest_word\"\n  fi", " \
    \   local longest=\"\"\n    local val=\"\"\n    local i=\"\"\n    local input_list=\"\
    $1\"\n    longest=\"None\"\n    for i in $input_list; do\n        if [[ -z \"\
    $i\" ]]; then\n            continue\n        fi\n        if [[ \"${#i}\" -gt \"\
    ${#longest}\" ]]; then\n            longest=\"$i\"\n        fi\n    done\n   \
    \ echo \"$longest\"", "  local str;\n  while read str; do\n    if [[ -z \"$result\"\
    \ ]]; then\n      result=\"$str\"\n    elif (( ${#str} > ${#result} )); then\n\
    \      result=\"$str\"\n    fi\n  done <<< \"$1\"\n  echo \"${result:-None}\"",
  "  local longest_\n  if [ -z \"$1\" ]; then\n    echo \"None\"\n  else\n    longest_=\"\
    $1\"\n    for i in $1; do\n      if [ \"${#i}\" -gt \"${#longest_}\" ]; then\n\
    \        longest_=\"$i\"\n      fi\n    done\n    echo \"$longest_\"\n  fi", " \
    \ if [ -z \"$1\" ]; then\n    echo \"None\"\n  else\n    echo \"$1\" | tr \" \"\
    \ \"\\n\" | sort -r -k1,1 -s | head -n1\n  fi", "\tif [ \"$1\" == \"\" ]; then\n\
    \t\techo \"None\"\n\telse\n\t\techo \"$1\" | awk '{max=0; for (i=1; i<=NF; i++)\
    \ {\n\t\t\tif (length($i) > max) {\n\t\t\t\tmax = length($i);\n\t\t\t\tmax_index\
    \ = i;\n\t\t\t}\n\t\t} print $max_index}'\n\tfi", "  [[ $# -eq 0 ]] && echo None\
    \ && return\n  local IFS=$'\\n'\n  echo \"$1\" | xargs printf \"%s\\n\" | sort\
    \ -r | head -n 1", "    local s max=0 longest=\n    for s in $*; do\n        [\
    \ ${#s} -gt $max ] && max=${#s} && longest=$s\n    done\n    [ -z \"$longest\"\
    \ ] && longest=None\n    echo \"$longest\"", "  if [ -z \"$1\" ]; then\n    echo\
    \ \"None\"\n  else\n    printf '%s\\n' \"$@\" | sort -r -k1,1 -t\" \" -n - | head\
    \ -n1\n  fi", "    local longest_word\n    local word\n    local length\n    longest_word=\n\
    \    for word in $1\n    do\n        [[ -z \"$word\" ]] && continue\n        length=${#word}\n\
    \        if [[ -z \"$longest_word\" ]] || (( length > ${#longest_word} ))\n  \
    \      then\n            longest_word=$word\n        fi\n    done\n    if [[ -z\
    \ \"$longest_word\" ]]\n    then\n        longest_word=\"None\"\n    fi\n    echo\
    \ \"$longest_word\"", "    local longest=\n    local cur=\n    for word in $1;\
    \ do\n        if [[ -z \"$longest\" ]]; then\n            longest=\"$word\"\n\
    \        else\n            if [[ ${#word} -gt ${#longest} ]]; then\n         \
    \       longest=\"$word\"\n            fi\n        fi\n    done\n    if [[ -z\
    \ \"$longest\" ]]; then\n        echo \"None\"\n    else\n        echo \"$longest\"\
    \n    fi", "  if [ -z \"$1\" ]; then\n    echo \"None\"\n  else\n    echo \"$1\"\
    \ | awk '{ print length, $0 }' | sort -nr | head -1 | cut -d' ' -f2-\n  fi", " \
    \   if [ $# -lt 1 ]; then\n        echo \"None\"\n    else\n        echo \"$@\"\
    \ | tr \" \" \"\\n\" | sort -nr | head -n 1\n    fi"]
stop_tokens:
- "\n}"
