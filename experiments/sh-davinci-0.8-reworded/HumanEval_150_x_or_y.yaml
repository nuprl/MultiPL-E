name: HumanEval_150_x_or_y
language: sh
prompt: "#!/bin/bash\n# A simple program which should return the value of x if n is\
  \ \n# a prime number and should return the value of y otherwise.\n# Examples:\n\
  # >>> $(x_or_y \"7\" \"34\" \"12\")\n# \"34\"\n# >>> $(x_or_y \"15\" \"8\" \"5\"\
  )\n# \"5\"\n#\n# $1 is an integer\n# $2 is an integer\n# $3 is an integer\nx_or_y()\
  \ {\n"
tests: "}\n\ncandidate() {\n    x_or_y \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
  \ \"7\" \"34\" \"12\") = \"34\" ]]\n    [[ $(candidate \"15\" \"8\" \"5\") = \"\
  5\" ]]\n    [[ $(candidate \"3\" \"33\" \"5212\") = \"33\" ]]\n    [[ $(candidate\
  \ \"1259\" \"3\" \"52\") = \"3\" ]]\n    [[ $(candidate \"7919\" \"-1\" \"12\")\
  \ = \"-1\" ]]\n    [[ $(candidate \"3609\" \"1245\" \"583\") = \"583\" ]]\n    [[\
  \ $(candidate \"91\" \"56\" \"129\") = \"129\" ]]\n    [[ $(candidate \"6\" \"34\"\
  \ \"1234\") = \"1234\" ]]\n    [[ $(candidate \"1\" \"2\" \"0\") = \"0\" ]]\n  \
  \  [[ $(candidate \"2\" \"2\" \"0\") = \"2\" ]]\n}\n\nrun_test"
completions: ["   \n   if [ \"$(is_prime $1)\" == \"true\" ]; then\n    echo $2\n\
    \   else\n    echo $3\n   fi", "    # insert your code here\n    NUM=\"$1\"\n\
    \    DIV=2\n    INC=1\n    PRIME=1\n    for ((INC=2; INC < NUM; INC++))\n    do\n\
    \        DIV=$((NUM%INC))\n        if [ $DIV -eq 0 ]\n        then\n         \
    \   PRIME=0\n            break\n        fi\n    done\n    if [ $PRIME -eq 1 ]\n\
    \    then\n        echo \"$2\"\n    else\n        echo \"$3\"\n    fi", "\tlocal\
    \ n=$1\n\tlocal x=$2\n\tlocal y=$3\n\t[ $n -eq 2 ] && echo $x && return\n\t[ $n\
    \ -eq 3 ] && echo $x && return\n\t[ $n -eq 5 ] && echo $x && return\n\t[ $n -eq\
    \ 7 ] && echo $x && return\n\tfor i in {2..`echo \"$n - 1\" | bc`}\n\tdo\n\t\t\
    [ `echo \"$n % $i\" | bc` -eq 0 ] && echo $y && return\n\tdone\n\techo $x", "\t\
    # This is a helper function that returns 1 if a number is prime\n\t# and 0 otherwise.\n\
    \t# Example:\n\t# >>> $(is_prime \"7\")\n\t# \"1\"\n\t# >>> $(is_prime \"15\"\
    )\n\t# \"0\"\n\tis_prime() {\n\t\t# This function only works for positive integers\n\
    \t\tif [ $1 -lt 0 ]; then\n\t\t\techo \"0\"\n\t\t\treturn 0\n\t\tfi\n\t\t# The\
    \ number 1 is not prime\n\t\tif [ $1 -eq 1 ]; then\n\t\t\techo \"0\"\n\t\t\treturn\
    \ 0\n\t\tfi\n\t\t# The number 2 is prime\n\t\tif [ $1 -eq 2 ]; then\n\t\t\techo\
    \ \"1\"\n\t\t\treturn 0\n\t\tfi\n\t\t# This is a naive test for primality.\n\t\
    \tlocal i\n\t\tfor ((i=2; i < $1; i++)); do\n\t\t\tif [ $(( $1 % $i )) -eq 0 ];\
    \ then\n\t\t\t\techo \"0\"\n\t\t\t\treturn 0\n\t\t\tfi\n\t\tdone\n\t\techo \"\
    1\"\n\t\treturn 0\n\t}\n\tif [ $(is_prime $1) -eq 1 ]; then\n\t\techo $2\n\telse\n\
    \t\techo $3\n\tfi", "  if [ \"$#\" -ne 3 ]; then\n    echo \"$0: invalid number\
    \ of arguments\"\n    return 1\n  fi\n  if ! [[ \"$1\" =~ ^[0-9]+$ ]]; then\n\
    \    echo \"$0: argument 1 is not an integer\"\n    return 1\n  fi\n  if ! [[\
    \ \"$2\" =~ ^[0-9]+$ ]]; then\n    echo \"$0: argument 2 is not an integer\"\n\
    \    return 1\n  fi\n  if ! [[ \"$3\" =~ ^[0-9]+$ ]]; then\n    echo \"$0: argument\
    \ 3 is not an integer\"\n    return 1\n  fi\n  if [ $1 -lt 1 ]; then\n    echo\
    \ \"$0: argument 1 is not greater than 0\"\n    return 1\n  fi\n  if [ $1 -lt\
    \ 1 ]; then\n    echo \"$0: argument 1 is not greater than 0\"\n    return 1\n\
    \  fi\n  if [ $2 -lt 1 ]; then\n    echo \"$0: argument 2 is not greater than\
    \ 0\"\n    return 1\n  fi\n  if [ $3 -lt 1 ]; then\n    echo \"$0: argument 3\
    \ is not greater than 0\"\n    return 1\n  fi\n  if ! is_prime \"$1\"; then\n\
    \    echo \"$2\"\n  else\n    echo \"$3\"\n  fi", "\t# check if all values are\
    \ integers\n\tif [ \"$(echo \"$1 $2 $3\" | grep '[^[:digit:]]')\" != \"\" ]; then\n\
    \t\techo \"Arguments are not integers\"\n\t\treturn 1\n\tfi\n\t# check if $1 is\
    \ prime\n\tif [ \"$(primes_up_to \"$1\" \"$1\")\" != \"$1\" ]; then\n\t\techo\
    \ \"$2\"\n\telse\n\t\techo \"$3\"\n\tfi", "\tif [[ $(is_prime \"$1\") == \"1\"\
    \ ]]; then\n\t\techo \"$2\"\n\telse\n\t\techo \"$3\"\n\tfi", "    local n=$1\n\
    \    local x=$2\n    local y=$3\n    for ((i=2; i<=${n}; i++)); do\n        if\
    \ [ $((${n}%${i})) -eq 0 ]; then\n            echo \"${y}\"\n            break\n\
    \        fi\n    done\n    if [ ${i} -eq ${n} ]; then\n        echo \"${x}\"\n\
    \    fi", "\tif [ \"$#\" -ne 3 ]; then\n\t\techo \"Usage: x_or_y <int> <int> <int>\"\
    \n\t\treturn 1\n\tfi\n\tif ! [[ \"$1\" =~ ^[0-9]+$ ]]; then\n\t\techo \"Arg 1:\
    \ '$1' is not an integer\"\n\t\treturn 1\n\tfi\n\tif ! [[ \"$2\" =~ ^[0-9]+$ ]];\
    \ then\n\t\techo \"Arg 2: '$2' is not an integer\"\n\t\treturn 1\n\tfi\n\tif !\
    \ [[ \"$3\" =~ ^[0-9]+$ ]]; then\n\t\techo \"Arg 3: '$3' is not an integer\"\n\
    \t\treturn 1\n\tfi\n\tif ! [[ \"$1\" -ge 0 ]]; then\n\t\techo \"Arg 1: '$1' is\
    \ not a positive integer\"\n\t\treturn 1\n\tfi\n\tif ! [[ \"$2\" -ge 0 ]]; then\n\
    \t\techo \"Arg 2: '$2' is not a positive integer\"\n\t\treturn 1\n\tfi\n\tif !\
    \ [[ \"$3\" -ge 0 ]]; then\n\t\techo \"Arg 3: '$3' is not a positive integer\"\
    \n\t\treturn 1\n\tfi\n\tif [ \"$(is_prime \"$1\")\" = \"true\" ]; then\n\t\techo\
    \ \"$2\"\n\t\treturn 0\n\telse\n\t\techo \"$3\"\n\t\treturn 0\n\tfi", "    if\
    \ is_prime $1; then\n        echo \"$2\"\n    else\n        echo \"$3\"\n    fi",
  "    if [ $# -ne 3 ]; then\n        return 1\n    fi\n    if [[ $1 =~ ^-?[0-9]+$\
    \ ]] && [[ $2 =~ ^-?[0-9]+$ ]] && [[ $3 =~ ^-?[0-9]+$ ]]; then\n        if [ $1\
    \ -eq 0 ]; then\n            echo \"$2\"\n        elif [ $1 -eq 1 ]; then\n  \
    \          echo \"$3\"\n        else\n            x_or_y $(( $1 - 1 )) $3 $((\
    \ $2 + $3 ))\n        fi\n    else\n        return 1\n    fi", "\t# TODO: Implement\
    \ the function", "  local x\n  local y\n  local n\n  local remainder\n  x=$2\n\
    \  y=$3\n  n=$1\n  if [ -z \"$n\" ]\n  then\n    echo \"Missing parameter\"\n\
    \    return 1\n  fi\n  if [ -z \"$x\" ]\n  then\n    echo \"Missing parameter\"\
    \n    return 1\n  fi\n  if [ -z \"$y\" ]\n  then\n    echo \"Missing parameter\"\
    \n    return 1\n  fi\n  if ! is_integer \"$n\"\n  then\n    echo \"Invalid parameter\"\
    \n    return 1\n  fi\n  if ! is_integer \"$x\"\n  then\n    echo \"Invalid parameter\"\
    \n    return 1\n  fi\n  if ! is_integer \"$y\"\n  then\n    echo \"Invalid parameter\"\
    \n    return 1\n  fi\n  for ((i=2; i<n; i++))\n  do\n    remainder=$((n % i))\n\
    \    if [ $remainder -eq 0 ]\n    then\n      echo \"$y\"\n      return\n    fi\n\
    \  done\n  echo \"$x\"", "    local n=\"$1\"\n    local x=\"$2\"\n    local y=\"\
    $3\"\n    if ((n%2==0 || n%3==0)); then\n        echo $y\n    else\n        echo\
    \ $x\n    fi", "  if [[ $1 == \"$2\" ]]; then\n    echo $3\n  else\n    echo $2\n\
    \  fi", "    # Put your code here\n    #return 0\n    #To find the prime number\n\
    \    for ((i=2; i<=$1/2; i++))\n    do\n        if [ $(($1%$i)) -eq 0 ]\n    \
    \    then\n            echo $2\n            return 0\n        fi\n    done\n \
    \   echo $3\n    return 0", "  if is_prime \"$1\"; then\n    echo \"$2\"\n  else\n\
    \    echo \"$3\"\n  fi", "  if [ -z $1 ] || [ -z $2 ] || [ -z $3 ]; then\n   \
    \ echo \"Usage: x_or_y num1 num2 num3\" >&2\n    return 1\n  fi\n  if ! [[ $1\
    \ =~ ^[0-9]+$ ]]; then\n    echo \"Error: first arg has to be a number\" >&2\n\
    \    return 1\n  fi\n  if ! [[ $2 =~ ^[0-9]+$ ]]; then\n    echo \"Error: second\
    \ arg has to be a number\" >&2\n    return 1\n  fi\n  if ! [[ $3 =~ ^[0-9]+$ ]];\
    \ then\n    echo \"Error: third arg has to be a number\" >&2\n    return 1\n \
    \ fi\n  x=$2\n  y=$3\n  for (( i=2; i<$1; i++ )); do\n    if [[ $(( $1 % $i ))\
    \ -eq 0 ]]; then\n      echo $y\n      return\n    fi\n  done\n  echo $x", "\t\
    local integer=$1\n\tlocal x=$2\n\tlocal y=$3\n\tif (( $integer%2==0 ))\n\tthen\n\
    \t\techo $y\n\telse\n\t\techo $x\n\tfi", "\tif (( (( $1 % 2 == 0 )) || (( $1 %\
    \ 3 == 0 )) || (( $1 % 5 == 0 )) || (( $1 % 7 == 0 )) )); then\n\t\techo \"$3\"\
    \n\telse\n\t\techo \"$2\"\n\tfi"]
stop_tokens:
- "\n}"
