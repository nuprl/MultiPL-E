name: HumanEval_150_x_or_y
language: sh
prompt: "#!/bin/bash\n# A simple program which should return the value of x if n is\
  \ \n# a prime number and should return the value of y otherwise.\n# Examples:\n\
  # >>> $(x_or_y \"7\" \"34\" \"12\")\n# \"34\"\n# >>> $(x_or_y \"15\" \"8\" \"5\"\
  )\n# \"5\"\n#\n# $1 is an integer\n# $2 is an integer\n# $3 is an integer\nx_or_y()\
  \ {\n"
tests: "}\n\ncandidate() {\n    x_or_y \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
  \ \"7\" \"34\" \"12\") = \"34\" ]]\n    [[ $(candidate \"15\" \"8\" \"5\") = \"\
  5\" ]]\n    [[ $(candidate \"3\" \"33\" \"5212\") = \"33\" ]]\n    [[ $(candidate\
  \ \"1259\" \"3\" \"52\") = \"3\" ]]\n    [[ $(candidate \"7919\" \"-1\" \"12\")\
  \ = \"-1\" ]]\n    [[ $(candidate \"3609\" \"1245\" \"583\") = \"583\" ]]\n    [[\
  \ $(candidate \"91\" \"56\" \"129\") = \"129\" ]]\n    [[ $(candidate \"6\" \"34\"\
  \ \"1234\") = \"1234\" ]]\n    [[ $(candidate \"1\" \"2\" \"0\") = \"0\" ]]\n  \
  \  [[ $(candidate \"2\" \"2\" \"0\") = \"2\" ]]\n}\n\nrun_test"
completions: ["   \n   if [ \"$(is_prime $1)\" == \"true\" ]; then\n    echo $2\n\
    \   else\n    echo $3\n   fi", "    # insert your code here\n    NUM=\"$1\"\n\
    \    DIV=2\n    INC=1\n    PRIME=1\n    for ((INC=2; INC < NUM; INC++))\n    do\n\
    \        DIV=$((NUM%INC))\n        if [ $DIV -eq 0 ]\n        then\n         \
    \   PRIME=0\n            break\n        fi\n    done\n    if [ $PRIME -eq 1 ]\n\
    \    then\n        echo \"$2\"\n    else\n        echo \"$3\"\n    fi", "\tlocal\
    \ n=$1\n\tlocal x=$2\n\tlocal y=$3\n\t[ $n -eq 2 ] && echo $x && return\n\t[ $n\
    \ -eq 3 ] && echo $x && return\n\t[ $n -eq 5 ] && echo $x && return\n\t[ $n -eq\
    \ 7 ] && echo $x && return\n\tfor i in {2..`echo \"$n - 1\" | bc`}\n\tdo\n\t\t\
    [ `echo \"$n % $i\" | bc` -eq 0 ] && echo $y && return\n\tdone\n\techo $x", "\t\
    # This is a helper function that returns 1 if a number is prime\n\t# and 0 otherwise.\n\
    \t# Example:\n\t# >>> $(is_prime \"7\")\n\t# \"1\"\n\t# >>> $(is_prime \"15\"\
    )\n\t# \"0\"\n\tis_prime() {\n\t\t# This function only works for positive integers\n\
    \t\tif [ $1 -lt 0 ]; then\n\t\t\techo \"0\"\n\t\t\treturn 0\n\t\tfi\n\t\t# The\
    \ number 1 is not prime\n\t\tif [ $1 -eq 1 ]; then\n\t\t\techo \"0\"\n\t\t\treturn\
    \ 0\n\t\tfi\n\t\t# The number 2 is prime\n\t\tif [ $1 -eq 2 ]; then\n\t\t\techo\
    \ \"1\"\n\t\t\treturn 0\n\t\tfi\n\t\t# This is a naive test for primality.\n\t\
    \tlocal i\n\t\tfor ((i=2; i < $1; i++)); do\n\t\t\tif [ $(( $1 % $i )) -eq 0 ];\
    \ then\n\t\t\t\techo \"0\"\n\t\t\t\treturn 0\n\t\t\tfi\n\t\tdone\n\t\techo \"\
    1\"\n\t\treturn 0\n\t}\n\tif [ $(is_prime $1) -eq 1 ]; then\n\t\techo $2\n\telse\n\
    \t\techo $3\n\tfi", "  if [ \"$#\" -ne 3 ]; then\n    echo \"$0: invalid number\
    \ of arguments\"\n    return 1\n  fi\n  if ! [[ \"$1\" =~ ^[0-9]+$ ]]; then\n\
    \    echo \"$0: argument 1 is not an integer\"\n    return 1\n  fi\n  if ! [[\
    \ \"$2\" =~ ^[0-9]+$ ]]; then\n    echo \"$0: argument 2 is not an integer\"\n\
    \    return 1\n  fi\n  if ! [[ \"$3\" =~ ^[0-9]+$ ]]; then\n    echo \"$0: argument\
    \ 3 is not an integer\"\n    return 1\n  fi\n  if [ $1 -lt 1 ]; then\n    echo\
    \ \"$0: argument 1 is not greater than 0\"\n    return 1\n  fi\n  if [ $1 -lt\
    \ 1 ]; then\n    echo \"$0: argument 1 is not greater than 0\"\n    return 1\n\
    \  fi\n  if [ $2 -lt 1 ]; then\n    echo \"$0: argument 2 is not greater than\
    \ 0\"\n    return 1\n  fi\n  if [ $3 -lt 1 ]; then\n    echo \"$0: argument 3\
    \ is not greater than 0\"\n    return 1\n  fi\n  if ! is_prime \"$1\"; then\n\
    \    echo \"$2\"\n  else\n    echo \"$3\"\n  fi", "\t# check if all values are\
    \ integers\n\tif [ \"$(echo \"$1 $2 $3\" | grep '[^[:digit:]]')\" != \"\" ]; then\n\
    \t\techo \"Arguments are not integers\"\n\t\treturn 1\n\tfi\n\t# check if $1 is\
    \ prime\n\tif [ \"$(primes_up_to \"$1\" \"$1\")\" != \"$1\" ]; then\n\t\techo\
    \ \"$2\"\n\telse\n\t\techo \"$3\"\n\tfi", "\tif [[ $(is_prime \"$1\") == \"1\"\
    \ ]]; then\n\t\techo \"$2\"\n\telse\n\t\techo \"$3\"\n\tfi", "    local n=$1\n\
    \    local x=$2\n    local y=$3\n    for ((i=2; i<=${n}; i++)); do\n        if\
    \ [ $((${n}%${i})) -eq 0 ]; then\n            echo \"${y}\"\n            break\n\
    \        fi\n    done\n    if [ ${i} -eq ${n} ]; then\n        echo \"${x}\"\n\
    \    fi", "\tif [ \"$#\" -ne 3 ]; then\n\t\techo \"Usage: x_or_y <int> <int> <int>\"\
    \n\t\treturn 1\n\tfi\n\tif ! [[ \"$1\" =~ ^[0-9]+$ ]]; then\n\t\techo \"Arg 1:\
    \ '$1' is not an integer\"\n\t\treturn 1\n\tfi\n\tif ! [[ \"$2\" =~ ^[0-9]+$ ]];\
    \ then\n\t\techo \"Arg 2: '$2' is not an integer\"\n\t\treturn 1\n\tfi\n\tif !\
    \ [[ \"$3\" =~ ^[0-9]+$ ]]; then\n\t\techo \"Arg 3: '$3' is not an integer\"\n\
    \t\treturn 1\n\tfi\n\tif ! [[ \"$1\" -ge 0 ]]; then\n\t\techo \"Arg 1: '$1' is\
    \ not a positive integer\"\n\t\treturn 1\n\tfi\n\tif ! [[ \"$2\" -ge 0 ]]; then\n\
    \t\techo \"Arg 2: '$2' is not a positive integer\"\n\t\treturn 1\n\tfi\n\tif !\
    \ [[ \"$3\" -ge 0 ]]; then\n\t\techo \"Arg 3: '$3' is not a positive integer\"\
    \n\t\treturn 1\n\tfi\n\tif [ \"$(is_prime \"$1\")\" = \"true\" ]; then\n\t\techo\
    \ \"$2\"\n\t\treturn 0\n\telse\n\t\techo \"$3\"\n\t\treturn 0\n\tfi", "    if\
    \ is_prime $1; then\n        echo \"$2\"\n    else\n        echo \"$3\"\n    fi",
  "    if [ $# -ne 3 ]; then\n        return 1\n    fi\n    if [[ $1 =~ ^-?[0-9]+$\
    \ ]] && [[ $2 =~ ^-?[0-9]+$ ]] && [[ $3 =~ ^-?[0-9]+$ ]]; then\n        if [ $1\
    \ -eq 0 ]; then\n            echo \"$2\"\n        elif [ $1 -eq 1 ]; then\n  \
    \          echo \"$3\"\n        else\n            x_or_y $(( $1 - 1 )) $3 $((\
    \ $2 + $3 ))\n        fi\n    else\n        return 1\n    fi", "\t# TODO: Implement\
    \ the function", "  local x\n  local y\n  local n\n  local remainder\n  x=$2\n\
    \  y=$3\n  n=$1\n  if [ -z \"$n\" ]\n  then\n    echo \"Missing parameter\"\n\
    \    return 1\n  fi\n  if [ -z \"$x\" ]\n  then\n    echo \"Missing parameter\"\
    \n    return 1\n  fi\n  if [ -z \"$y\" ]\n  then\n    echo \"Missing parameter\"\
    \n    return 1\n  fi\n  if ! is_integer \"$n\"\n  then\n    echo \"Invalid parameter\"\
    \n    return 1\n  fi\n  if ! is_integer \"$x\"\n  then\n    echo \"Invalid parameter\"\
    \n    return 1\n  fi\n  if ! is_integer \"$y\"\n  then\n    echo \"Invalid parameter\"\
    \n    return 1\n  fi\n  for ((i=2; i<n; i++))\n  do\n    remainder=$((n % i))\n\
    \    if [ $remainder -eq 0 ]\n    then\n      echo \"$y\"\n      return\n    fi\n\
    \  done\n  echo \"$x\"", "    local n=\"$1\"\n    local x=\"$2\"\n    local y=\"\
    $3\"\n    if ((n%2==0 || n%3==0)); then\n        echo $y\n    else\n        echo\
    \ $x\n    fi", "  if [[ $1 == \"$2\" ]]; then\n    echo $3\n  else\n    echo $2\n\
    \  fi", "    # Put your code here\n    #return 0\n    #To find the prime number\n\
    \    for ((i=2; i<=$1/2; i++))\n    do\n        if [ $(($1%$i)) -eq 0 ]\n    \
    \    then\n            echo $2\n            return 0\n        fi\n    done\n \
    \   echo $3\n    return 0", "  if is_prime \"$1\"; then\n    echo \"$2\"\n  else\n\
    \    echo \"$3\"\n  fi", "  if [ -z $1 ] || [ -z $2 ] || [ -z $3 ]; then\n   \
    \ echo \"Usage: x_or_y num1 num2 num3\" >&2\n    return 1\n  fi\n  if ! [[ $1\
    \ =~ ^[0-9]+$ ]]; then\n    echo \"Error: first arg has to be a number\" >&2\n\
    \    return 1\n  fi\n  if ! [[ $2 =~ ^[0-9]+$ ]]; then\n    echo \"Error: second\
    \ arg has to be a number\" >&2\n    return 1\n  fi\n  if ! [[ $3 =~ ^[0-9]+$ ]];\
    \ then\n    echo \"Error: third arg has to be a number\" >&2\n    return 1\n \
    \ fi\n  x=$2\n  y=$3\n  for (( i=2; i<$1; i++ )); do\n    if [[ $(( $1 % $i ))\
    \ -eq 0 ]]; then\n      echo $y\n      return\n    fi\n  done\n  echo $x", "\t\
    local integer=$1\n\tlocal x=$2\n\tlocal y=$3\n\tif (( $integer%2==0 ))\n\tthen\n\
    \t\techo $y\n\telse\n\t\techo $x\n\tfi", "\tif (( (( $1 % 2 == 0 )) || (( $1 %\
    \ 3 == 0 )) || (( $1 % 5 == 0 )) || (( $1 % 7 == 0 )) )); then\n\t\techo \"$3\"\
    \n\telse\n\t\techo \"$2\"\n\tfi", "\t# Declaring variables\n\tlocal n=\"$1\"\n\
    \tlocal x=\"$2\"\n\tlocal y=\"$3\"\n\tlocal sum=0\n\tlocal j=1\n\t\n\t# Check\
    \ if n is prime number\n\twhile [ $j -lt $n ]\n\tdo\n\t\tlet \"sum=$n%$j\"\n\t\
    \tlet \"j=$j+1\"\n\t\tif [ $sum -eq 0 ]\n\t\tthen\n\t\t\techo \"$y\"\n\t\t\treturn\n\
    \t\tfi\n\tdone\n\t\n\techo \"$x\"", "\t#checks all the numbers that are less than\
    \ the third argument\n\tfor i in $(seq 1 $3); do\n\t\t#checks if the number is\
    \ divisible by any other number\n\t\tif [[ $(( $3 % $i )) -eq 0 ]]; then\n\t\t\
    \t#if the number is divisible by itself or 1 it returns $1\n\t\t\tif [[ $i -eq\
    \ 1 || $i -eq $3 ]]; then\n\t\t\t\techo \"$1\"\n\t\t\t#if the number is divisible\
    \ by another number that is not 1 or itself it returns $2\n\t\t\telse\n\t\t\t\t\
    echo \"$2\"\n\t\t\tfi\n\t\tfi\n\tdone", "    n=\"$1\"\n    x=\"$2\"\n    y=\"\
    $3\"\n    if [ -z \"$n\" ] || [ -z \"$x\" ] || [ -z \"$y\" ]; then\n\techo \"\
    Invalid input\"\n\treturn 1\n    fi\n    if [ \"$n\" -lt 2 ]; then\n\techo \"\
    $y\"\n\treturn 1\n    fi\n    i=2\n    while [ $i -lt \"$n\" ]; do\n\tremainder=$((n\
    \ % i))\n\tif [ \"$remainder\" -eq 0 ]; then\n\t    echo \"$y\"\n\t    return\
    \ 1\n\tfi\n\t((i++))\n    done\n    echo \"$x\"", "\t# If $1 is a prime number\n\
    \t# -n is to check if string is not empty\n\tif [ -n \"$(is_prime \"$1\")\" ];\
    \ then\n\t\techo \"$2\"\n\telse\n\t\techo \"$3\"\n\tfi", "\tif [[ \"$(is_prime\
    \ \"$1\")\" -eq \"1\" ]]; then\n\t\techo \"$2\"\n\telse\n\t\techo \"$3\"\n\tfi",
  "    is_prime=\"$(./is_prime.sh \"$1\")\"\n    if [ \"$is_prime\" = \"true\" ];\
    \ then\n        echo \"$2\"\n    else\n        echo \"$3\"\n    fi", "\tlocal\
    \ -i num\n\tlocal -i x\n\tlocal -i y\n\tlocal -i res\n\t\n\tnum=$1\n\tx=$2\n\t\
    y=$3\n\t\n\tres=$(is_prime $num)\n\tif [ $res -eq 0 ]; then\n\t\techo $x\n\telse\n\
    \t\techo $y\n\tfi", "\tif [[ $1 -gt 0 ]]; then\n\t\tis_integer_prime $1\n\t\t\
    if [[ $? -eq 0 ]]; then\n\t\t\techo \"$2\"\n\t\telse\n\t\t\techo \"$3\"\n\t\t\
    fi\n\telse\n\t\techo \"$3\"\n\tfi", "\tlocal n=$1\n\tlocal x=$2\n\tlocal y=$3\n\
    \tlocal i=2\n\twhile [ $i -lt $n ]; do\n\t\tif [ $((n % i)) -eq 0 ]; then\n\t\t\
    \techo $y\n\t\t\treturn\n\t\tfi\n\t\t((++i))\n\tdone\n\techo $x", "  if [[ \"\
    $#\" -ne 3 ]]; then\n    echo \"Illegal number of parameters\"\n    exit 1\n \
    \ fi\n  if [[ -z \"$1\" ]]; then\n    echo \"Parameter 1 cannot be empty\"\n \
    \   exit 1\n  fi\n  if [[ -z \"$2\" ]]; then\n    echo \"Parameter 2 cannot be\
    \ empty\"\n    exit 1\n  fi\n  if [[ -z \"$3\" ]]; then\n    echo \"Parameter\
    \ 3 cannot be empty\"\n    exit 1\n  fi\n  local number=\"$1\"\n  local x=\"$2\"\
    \n  local y=\"$3\"\n  # It's faster to check even numbers using an arithmetic\
    \ comparison\n  if [[ \"$((number % 2))\" -eq 0 ]]; then\n    echo \"$y\"\n  \
    \  return\n  fi\n  # If number is less than 2, it can't be prime\n  if [[ \"$number\"\
    \ -lt 2 ]]; then\n    echo \"$y\"\n    return\n  fi\n  # We can check all odd\
    \ numbers after 2\n  for ((i = 3; i < \"$number\"; i += 2)); do\n    if [[ \"\
    $((number % i))\" -eq 0 ]]; then\n      echo \"$y\"\n      return\n    fi\n  done\n\
    \  echo \"$x\"", "  local n=$1\n  local x=$2\n  local y=$3\n  if (( $n > 1 ));\
    \ then\n    i=2\n    while (( $(($i * $i)) <= $n )); do\n      if (( $(($n % $i))\
    \ == 0 )); then\n        echo $y\n        return\n      fi\n      i=$(($i + 1))\n\
    \    done\n    echo $x\n  else\n    echo $y\n  fi", "\tif [ $# -ne 3 ]; then\n\
    \t\techo \"x_or_y: Three arguments are required.\"\n\t\texit 1\n\tfi\n\tif [[\
    \ $1 -lt 2 ]]; then\n\t\techo \"ERROR: Argument n should be greater than 1.\"\n\
    \t\texit 1\n\tfi\n\tfor (( i=2; i*i<=$1; i++ )); do\n\t\tif [[ $1%$i -eq 0 ]];\
    \ then\n\t\t\techo $3\n\t\t\texit 0\n\t\tfi\n\tdone\n\techo $2", "\t# your code\
    \ here\n\t\n\tif is_prime $1; then\n\t\techo $2\n\telse\n\t\techo $3\n\tfi", " \
    \   # Enter your code here.\n    # Do not change the \"$( is_prime ... )\" and\
    \ \"$( is_not_prime ... )\"\n    # lines, otherwise, you won't get any points\
    \ for this task.\n    if $(is_prime \"$1\")\n    then\n        echo \"$2\"\n \
    \   else\n        echo \"$3\"\n    fi", "  if is_prime $1; then\n    echo $2\n\
    \  else\n    echo $3\n  fi", "    x=1\n    for (( i=2; i<=$1/2; i++ ))\n    do\n\
    \        if [ $(( $1 % $i )) -eq 0 ]\n        then\n            x=0\n        \
    \    break\n        fi\n    done\n    if [ $x -eq 1 ]\n    then\n        echo\
    \ \"$2\"\n    else\n        echo \"$3\"\n    fi", "  if [ $1 -eq 2 ] || [ $1 -eq\
    \ 3 ] || [ $1 -eq 5 ] || [ $1 -eq 7 ]\n  then\n    echo \"$2\"\n  else\n    echo\
    \ \"$3\"\n  fi", "\tif [ $1 -eq 2 ] || [ $1 -eq 3 ] || [ $1 -eq 5 ] || [ $1 -eq\
    \ 7 ] || [ $1 -eq 11 ] || [ $1 -eq 13 ] || [ $1 -eq 17 ] || [ $1 -eq 19 ] || [\
    \ $1 -eq 23 ] || [ $1 -eq 29 ] || [ $1 -eq 31 ]\n\tthen\n\t\techo $2\n\telse\n\
    \t\techo $3\n\tfi", "    if [[ $1 -eq 2 ]] || [[ $1 -eq 3 ]] || [[ $1 -eq 5 ]]\
    \ || [[ $1 -eq 7 ]]\n    then\n        echo $3\n    else\n        echo $2\n  \
    \  fi", "\tif [[ $(is_prime $1) == \"true\" ]]; then\n\t\techo $2\n\telse\n\t\t\
    echo $3\n\tfi", "    if [[ $1 =~ ^[0-9]+$ ]] && [[ $2 =~ ^[0-9]+$ ]] && [[ $3\
    \ =~ ^[0-9]+$ ]]; then\n        local n=$1\n        local x=$2\n        local\
    \ y=$3\n        local result=\"$y\"\n        if ((n==2 || n==3 || n==5 || n==7));\
    \ then\n            result=\"$x\"\n        elif ((n>1)); then\n            if\
    \ ((n%2!=0 && n%3!=0 && n%5!=0 && n%7!=0)); then\n                result=\"$x\"\
    \n            fi\n        fi\n        echo \"$result\"\n    else\n        echo\
    \ \"Invalid input\"\n    fi", "\tis_a_prime_number \"$1\"\n\tlocal prime=$?\n\t\
    if [[ $prime -eq 0 ]]; then\n\t\techo \"$2\"\n\telse\n\t\techo \"$3\"\n\tfi",
  "    if [[ $# -ne 3 ]]; then\n        return\n    fi\n    if [[ ! $1 =~ ^[0-9]+$\
    \ ]]; then\n        return\n    fi\n    if [[ ! $2 =~ ^[0-9]+$ ]]; then\n    \
    \    return\n    fi\n    if [[ ! $3 =~ ^[0-9]+$ ]]; then\n        return\n   \
    \ fi\n    if [[ $1 -lt 0 ]]; then\n        return\n    fi\n    if [[ $2 -lt 0\
    \ ]]; then\n        return\n    fi\n    if [[ $3 -lt 0 ]]; then\n        return\n\
    \    fi\n    if [[ $1 -eq 1 ]]; then\n        echo $2\n        return\n    fi\n\
    \    for (( i=2; i<$1; i++ )); do\n        if [[ $(( $1 % $i )) -eq 0 ]]; then\n\
    \            echo $3\n            return\n        fi\n    done\n    echo $2",
  "    if [ \"$#\" -eq 3 ]; then\n        x=$2\n        y=$3\n        if [ $1 -eq\
    \ 2 ]; then\n            echo $x\n        elif [ $1 -eq 3 ]; then\n          \
    \  echo $x\n        elif [ $1 -eq 5 ]; then\n            echo $x\n        elif\
    \ [ $1 -eq 7 ]; then\n            echo $x\n        elif [ $1 -eq 11 ]; then\n\
    \            echo $x\n        elif [ $1 -eq 13 ]; then\n            echo $x\n\
    \        elif [ $1 -eq 17 ]; then\n            echo $x\n        elif [ $1 -eq\
    \ 19 ]; then\n            echo $x\n        elif [ $1 -eq 23 ]; then\n        \
    \    echo $x\n        elif [ $1 -eq 29 ]; then\n            echo $x\n        elif\
    \ [ $1 -eq 31 ]; then\n            echo $x\n        elif [ $1 -eq 37 ]; then\n\
    \            echo $x\n        elif [ $1 -eq 41 ]; then\n            echo $x\n\
    \        elif [ $1 -eq 43 ]; then\n            echo $x\n        elif [ $1 -eq\
    \ 47 ]; then\n            echo $x\n        elif [ $1 -eq 53 ]; then\n        \
    \    echo $x\n        elif [ $1 -eq 59 ]; then\n            echo $x\n        elif\
    \ [ $1 -eq 61 ]; then\n            echo $x\n        elif [ $1 -eq 67 ]; then\n\
    \            echo $x\n        elif [ $1 -eq 71 ]; then\n            echo $x\n\
    \        elif [ $1 -eq 73 ]; then\n            echo $x\n        elif [ $1 -eq\
    \ 79 ]; then\n            echo $x\n        elif [ $1 -eq 83 ]; then\n        \
    \    echo $x\n        elif [ $1 -eq 89 ]; then\n            echo $x\n        elif\
    \ [ $1 -eq 97 ]; then\n            echo $x\n        else\n            echo $y\n\
    \        fi\n    else\n        echo \"Error: 3 arguments expected\"\n    fi",
  "    if [[ $(prime_number \"$1\") -eq 1 ]]; then\n        echo \"$2\"\n    else\n\
    \        echo \"$3\"\n    fi", "\tif [ $1 -eq 2 ] || [ $1 -eq 3 ] || [ $1 -eq\
    \ 5 ] || [ $1 -eq 7 ] || [ $1 -eq 11 ] || [ $1 -eq 13 ] || [ $1 -eq 17 ] || [\
    \ $1 -eq 19 ] || [ $1 -eq 23 ] || [ $1 -eq 29 ] || [ $1 -eq 31 ] || [ $1 -eq 37\
    \ ] || [ $1 -eq 41 ] || [ $1 -eq 43 ] || [ $1 -eq 47 ] || [ $1 -eq 53 ] || [ $1\
    \ -eq 59 ] || [ $1 -eq 61 ] || [ $1 -eq 67 ] || [ $1 -eq 71 ] || [ $1 -eq 73 ]\
    \ || [ $1 -eq 79 ] || [ $1 -eq 83 ] || [ $1 -eq 89 ] || [ $1 -eq 97 ]\n\tthen\n\
    \t\techo \"$2\"\n\telse\n\t\techo \"$3\"\n\tfi", "    # TODO: You code here.\n\
    \    # If you want to call another function, use $(your_function)", "\tlocal n=$1\n\
    \tlocal x=$2\n\tlocal y=$3\n\tlocal counter=2\n\tlocal is_prime=true\n\twhile\
    \ [[ $counter -lt $n ]]; do\n\t\tlocal remainder=$(($n % $counter))\n\t\tif [[\
    \ $remainder -eq 0 ]]; then\n\t\t\tis_prime=false\n\t\t\tbreak\n\t\tfi\n\t\tcounter=$(($counter\
    \ + 1))\n\tdone\n\tif [[ $is_prime = true ]]; then\n\t\techo \"$x\"\n\telse\n\t\
    \techo \"$y\"\n\tfi", "  int=$1\n  x=$2\n  y=$3\n  if [[ $int -eq 2 || $int -eq\
    \ 3 || $int -eq 5 || $int -eq 7 ]]; then\n    echo $x\n  elif [[ $int%2 -eq 0\
    \ || $int%3 -eq 0 || $int%5 -eq 0 || $int%7 -eq 0 ]]; then\n    echo $y\n  else\n\
    \    echo $x\n  fi", "    if [[ $1 =~ ^[0-9]+$ ]] && [[ $2 =~ ^[0-9]+$ ]] && [[\
    \ $3 =~ ^[0-9]+$ ]]; then\n        if [[ $(is_prime $1) -eq 1 ]]; then\n     \
    \       echo $2\n        else\n            echo $3\n        fi\n    else\n   \
    \     echo \"Error. Usage: x_or_y <INT> <INT> <INT>\"\n    fi", "    local x\n\
    \    local y\n    x=$2\n    y=$3\n    if [[ $(is_prime $1) == true ]]; then\n\
    \        echo \"$x\"\n    else\n        echo \"$y\"\n    fi", "    if [[ $1 =~\
    \ ^[0-9]+$ ]] && [[ $2 =~ ^[0-9]+$ ]] && [[ $3 =~ ^[0-9]+$ ]]; then\n        if\
    \ [[ $3 == 2 ]] || [[ $3 == 3 ]] || [[ $3 == 5 ]] || [[ $3 == 7 ]]; then\n   \
    \         echo $1\n        else\n            echo $2\n        fi\n    else\n \
    \       echo \"ERROR\"\n    fi", "    local n=\"$1\"\n    local x=\"$2\"\n   \
    \ local y=\"$3\"\n    if [[ $n -eq 1 ]]; then\n        echo $y\n    elif [[ $n\
    \ -eq 2 ]]; then\n        echo $x\n    elif [[ $n -gt 2 ]]; then\n        for\
    \ i in $(seq 2 $(( n-1 ))); do\n            if [[ $(( n % i )) -eq 0 ]]; then\n\
    \                echo $y\n                break\n            fi\n        done\n\
    \        echo $x\n    fi", "    if [[ $1 -le 1 ]]; then\n        echo $3\n   \
    \ elif [[ $1 -eq 2 ]]; then\n        echo $2\n    elif [[ $1%2 -eq 0 ]]; then\n\
    \        echo $3\n    else\n        for ((i=3; i <= sqrt($1); i+=2)); do\n   \
    \         if [[ $1%$i -eq 0 ]]; then\n                echo $3\n              \
    \  return\n            fi\n        done\n        echo $2\n    fi", "    # Need\
    \ to use bc to deal with floats\n    if [ $1 -eq 2 ]; then\n        echo $3\n\
    \    elif [ $(bc <<< \"$1 % 2\") -eq 0 ]; then\n        echo $2\n    else\n  \
    \      sqr=$(bc <<< \"sqrt($1)\")\n        for i in $(seq 3 2 $sqr); do\n    \
    \        if [ $(bc <<< \"$1 % $i\") -eq 0 ]; then\n                echo $2\n \
    \               return\n            fi\n        done\n        echo $3\n    fi",
  "   if [[ $(is_prime $1) == \"True\" ]]; then\n      echo $2\n   else\n      echo\
    \ $3\n   fi", "\t# change the value of x, a, b below\n\tx=\n\ta=\n\tb=\n\tcheck_primality\
    \ $1\n\tif [[ $? == 0 ]]; then\n\t\techo $a\n\telse\n\t\techo $b\n\tfi", "  if\
    \ [ $1 -gt 0 ] && [ $(($1 % $2)) -eq 0 ]\n  then\n    echo $2\n  else\n    echo\
    \ $3\n  fi", "\tif is_prime \"$1\"; then\n\t\techo \"$2\"\n\telse\n\t\techo \"\
    $3\"\n\tfi", "\tif [[ $# -ne 3 ]]; then\n\t\techo \"${FUNCNAME[0]} error: wrong\
    \ number of arguments\"\n\t\texit 1\n\tfi\n\tlocal input=$1\n\tlocal x=$2\n\t\
    local y=$3\n\t\n\tif [[ $input -eq 2 ]] || [[ $input -eq 3 ]]; then\n\t\techo\
    \ \"$x\"\n\t\treturn 0\n\tfi\n\t\n\tif [[ $(( $input % 2 )) -eq 0 ]] || [[ $((\
    \ $input % 3 )) -eq 0 ]]; then\n\t\techo \"$y\"\n\t\treturn 0\n\tfi\n\t\n\tlocal\
    \ i=5\n\tlocal w=2\n\twhile (( $(bc <<< \"$i * $i <= $input\") )); do\n\t\tif\
    \ [[ $(( $input % $i )) -eq 0 ]]; then\n\t\t\techo \"$y\"\n\t\t\treturn 0\n\t\t\
    fi\n\t\ti=$(( $i + $w ))\n\t\tw=$(( 6 - $w ))\n\tdone\n\techo \"$x\"\n\treturn\
    \ 0", "    # checks if the third argument is a prime number\n    if [ $(is_prime\
    \ $3) -eq 1 ]; then\n        echo $1\n    else\n        echo $2\n    fi", "\t\
    if [[ $1 -eq 2 ]] || [[ $1 -eq 3 ]] || [[ $1 -eq 5 ]] || [[ $1 -eq 7 ]] || [[\
    \ $1 -eq 11 ]] || [[ $1 -eq 13 ]] || [[ $1 -eq 17 ]] || [[ $1 -eq 19 ]] || [[\
    \ $1 -eq 23 ]] || [[ $1 -eq 29 ]] || [[ $1 -eq 31 ]] || [[ $1 -eq 37 ]] || [[\
    \ $1 -eq 41 ]] || [[ $1 -eq 43 ]] || [[ $1 -eq 47 ]] || [[ $1 -eq 53 ]] || [[\
    \ $1 -eq 59 ]] || [[ $1 -eq 61 ]] || [[ $1 -eq 67 ]] || [[ $1 -eq 71 ]] || [[\
    \ $1 -eq 73 ]] || [[ $1 -eq 79 ]] || [[ $1 -eq 83 ]] || [[ $1 -eq 89 ]] || [[\
    \ $1 -eq 97 ]] || [[ $1 -eq 101 ]] || [[ $1 -eq 103 ]] || [[ $1 -eq 107 ]] ||\
    \ [[ $1 -eq 109 ]] || [[ $1 -eq 113 ]] || [[ $1 -eq 127 ]] || [[ $1 -eq 131 ]]\
    \ || [[ $1 -eq 137 ]] || [[ $1 -eq 139 ]] || [[ $1 -eq 149 ]] || [[ $1 -eq 151\
    \ ]] || [[ $1 -eq 157 ]] || [[ $1 -eq 163 ]] || [[ $1 -eq 167 ]] || [[ $1 -eq\
    \ 173 ]] || [[ $1 -eq 179 ]] || [[ $1 -eq 181 ]] || [[ $1 -eq 191 ]] || [[ $1\
    \ -eq 193 ]] || [[ $1 -eq 197 ]] || [[ $1 -eq 199 ]] || [[ $1 -eq 211 ]] || [[\
    \ $1 -eq 223 ]] || [[ $1 -eq 227 ]] || [[ $1 -eq 229 ]] || [[ $1 -eq 233 ]] ||\
    \ [[ $1 -eq 239 ]] || [[ $1 -eq 241 ]] || [[ $1 -eq 251 ]] || [[ $1 -eq 257 ]]\
    \ || [[ $1 -eq 263 ]] || [[ $1 -eq", "\t# TODO: Implement x_or_y\n\t# Return the\
    \ value of x if n is a prime number and y otherwise\n\t# The return value should\
    \ be the value of x or y\n\t# Hint: check for a prime number using is_prime.sh\n\
    \t# Note: If a number is a prime number, the function is_prime should return 0\n\
    \t# Use the function is_prime to check whether $1 is a prime number\n\t# use the\
    \ return value of is_prime to decide which value to return\n\t# Note: The return\
    \ value of the function has to be redirected to a file.\n\t#       Otherwise the\
    \ return value will only be available in the subshell.\n\tif [ $(is_prime $1)\
    \ == 0 ]; then\n\t\techo $2\n\telse\n\t\techo $3\n\tfi", "    local n=$1\n   \
    \ local x=$2\n    local y=$3\n    if [ $n -eq 2 ] || [ $n -eq 3 ] || [ $n -eq\
    \ 5 ] || [ $n -eq 7 ] || [ $n -eq 11 ]\n    then\n        echo $x\n    else\n\
    \        echo $y\n    fi", '    echo $(if ! ([ $1 -gt 1 ] && [ $(($1%2)) -eq 0
    ]); then echo $2; else echo $3; fi)', "\tlocal n=\"$1\"\n\tlocal x=\"$2\"\n\t\
    local y=\"$3\"\n\tlocal output\n\t# begin your code here\n\tif [ $(is_prime \"\
    $n\") == \"true\" ]; then\n\t\toutput=\"$x\"\n\telse\n\t\toutput=\"$y\"\n\tfi\n\
    \techo \"$output\"", "    for (( i=2; i<$1; i++ )); do\n        if [[ $(( $1 %\
    \ $i )) -eq 0 ]]; then\n            echo \"$3\"\n            return\n        fi\n\
    \    done\n    echo \"$2\"", "\t# if the number is prime\n\tif [[ $(is_prime \"\
    $1\") -eq 0 ]]; then\n\t\t# print x\n\t\techo \"$2\"\n\telse\n\t\t# print y\n\t\
    \techo \"$3\"\n\tfi", "    if ! [[ \"$1\" =~ ^[0-9]+$ ]] ; then\n       echo \"\
    error: Not a number\" >&2; exit 1\n    fi\n    if ! [[ \"$2\" =~ ^[0-9]+$ ]] ;\
    \ then\n       echo \"error: Not a number\" >&2; exit 1\n    fi\n    if ! [[ \"\
    $3\" =~ ^[0-9]+$ ]] ; then\n       echo \"error: Not a number\" >&2; exit 1\n\
    \    fi\n    if [ $# -ne 3 ]; then\n        echo \"error: incorrect number of\
    \ arguments\" >&2; exit 1\n    fi\n    sqrt=$(echo \"sqrt($1)\" | bc -l)\n   \
    \ if [ $(bc <<< \"$sqrt%1\") -eq 0 ]; then\n        echo \"$3\"\n    else\n  \
    \      echo \"$2\"\n    fi", "    if is_prime \"$1\"; then\n        echo \"$2\"\
    \n    else\n        echo \"$3\"\n    fi", "\techo $(echo $1 | egrep '^[0-9]+$')\n\
    \tif [ ! $? -eq 0 ]; then\n\t\techo \"First argument is not a number\"\n\t\texit\
    \ 1\n\tfi\n\tif [ ! -z $(echo $2 | egrep '^[0-9]+$') ]; then\n\t\techo \"Second\
    \ argument is not a number\"\n\t\texit 1\n\tfi\n\tif [ ! -z $(echo $3 | egrep\
    \ '^[0-9]+$') ]; then\n\t\techo \"Third argument is not a number\"\n\t\texit 1\n\
    \tfi\n\t\n\tfor (( i=2; i<=$1/2; i++ )); do\n\t\tif [ $(($1%$i)) -eq 0 ]; then\n\
    \t\t\techo $2\n\t\t\texit 0\n\t\tfi\n\tdone\n\techo $3", "    # TODO: Add your\
    \ code here.\n    n=$1\n    x=$2\n    y=$3\n    a=0\n    for (( i=1; i<=n; i++\
    \ ))\n    do\n    if [[ $(($n%$i)) -eq 0 ]] ; then\n    a=$(($a+1))\n    fi\n\
    \    done\n    if [[ $a -eq 2 ]] ; then\n    echo $x\n    else\n    echo $y\n\
    \    fi", "\tif [[ -z $1 ]] || [[ -z $2 ]] || [[ -z $3 ]]; then\n\t\techo \"Three\
    \ arguments are required\"\n\t\texit 1\n\tfi\n\t# If this variable is set, it\
    \ is not a prime number\n\tnot_prime=\n\t# Iterate from 2 to n - 1\n\tfor ((i=2;\
    \ i<\"$1\"; i++)); do\n\t\tif [[ $(($1 % $i)) -eq 0 ]]; then\n\t\t\tnot_prime=true\n\
    \t\t\tbreak\n\t\tfi\n\tdone\n\tif [[ -z $not_prime ]]; then\n\t\techo \"$2\"\n\
    \telse\n\t\techo \"$3\"\n\tfi", "   temp=`bc <<< \"$1 % $3\"`\n   if [[ $temp\
    \ -eq 0 ]]; then\n       echo $2\n   else\n       echo $1\n   fi", "  if (( \"\
    $1\" == 2 )) || (( \"$1\" == 3 )) || (( \"$1\" == 5 )) || (( \"$1\" == 7 )); then\n\
    \    echo \"$2\"\n  elif (( $1 % 2 == 0 )) || (( $1 % 3 == 0 )) || (( $1 % 5 ==\
    \ 0 )) || (( $1 % 7 == 0 )); then\n    echo \"$3\"\n  else\n    echo \"$2\"\n\
    \  fi", "    x=$1\n    y=$2\n    n=$3\n    echo \"x = $x, y = $y, n = $n\"\n \
    \   [ $x -le 0 ] && echo \"x must be a positive integer\" && exit 1\n    [ $y\
    \ -le 0 ] && echo \"y must be a positive integer\" && exit 1\n    [ $n -le 0 ]\
    \ && echo \"n must be a positive integer\" && exit 1\n    if [ $n -eq 2 ] || [\
    \ $n -eq 3 ] || [ $n -eq 5 ] || [ $n -eq 7 ] ; then\n        echo $x\n    else\n\
    \        expr $n % 2 > /dev/null && echo $y && exit 0\n        expr $n % 3 > /dev/null\
    \ && echo $y && exit 0\n        expr $n % 5 > /dev/null && echo $y && exit 0\n\
    \        expr $n % 7 > /dev/null && echo $y && exit 0\n        echo $x\n    fi",
  '  # your code here', "\tn=$1\n\tx=$2\n\ty=$3\n\t# check if n is a prime number\n\
    \tfactor $n\n\tif [ $? -eq 0 ]; then\n\t\techo $x\n\telse\n\t\techo $y\n\tfi",
  "  if [ \"$#\" -ne 3 ]; then\n    echo \"Usage: $0 <integer1> <integer2> <integer3>\"\
    \n    exit 1\n  fi\n  if [ \"$1\" -lt 2 ]; then\n    echo \"First integer should\
    \ be greater than 1\"\n    exit 1\n  fi\n  # Define the prime number variable\n\
    \  prime=0\n  for((i=2;i<=$1/2;i++))\n  do\n    if [ $(( $1 % $i )) -eq 0 ]\n\
    \    then\n      prime=1\n      break\n    fi\n  done\n  if [ $prime -eq 0 ]\n\
    \  then\n    echo \"$2\"\n  else\n    echo \"$3\"\n  fi", "    if (( $1 < 2 ))\
    \ || (( $1 % 2 == 0 )) && (( $1 != 2 )); then\n        echo $3\n    else\n   \
    \     for (( n=3; n < $1; n=n+2 )); do\n            if (( $1 % n == 0 )); then\n\
    \                echo $3\n                return\n            fi\n        done\n\
    \        echo $2\n    fi", "\t# is x or y a prime number?\n\tif [[ $1 -eq 2 ||\
    \ $1 -eq 3 || $1 -eq 5 || $1 -eq 7 ]]; then\n\t\t# return x\n\t\techo $1\n\telif\
    \ [[ $1 -gt 2 && $(($1 % 2)) -ne 0 && $(($1 % 3)) -ne 0 && $(($1 % 5)) -ne 0 &&\
    \ $(($1 % 7)) -ne 0 ]]; then\n\t\t# return x\n\t\techo $1\n\telif [[ $2 -eq 2\
    \ || $2 -eq 3 || $2 -eq 5 || $2 -eq 7 ]]; then\n\t\t# return y\n\t\techo $2\n\t\
    elif [[ $2 -gt 2 && $(($2 % 2)) -ne 0 && $(($2 % 3)) -ne 0 && $(($2 % 5)) -ne\
    \ 0 && $(($2 % 7)) -ne 0 ]]; then\n\t\t# return y\n\t\techo $2\n\telif [[ $3 -eq\
    \ 2 || $3 -eq 3 || $3 -eq 5 || $3 -eq 7 ]]; then\n\t\t# return z\n\t\techo $3\n\
    \telif [[ $3 -gt 2 && $(($3 % 2)) -ne 0 && $(($3 % 3)) -ne 0 && $(($3 % 5)) -ne\
    \ 0 && $(($3 % 7)) -ne 0 ]]; then\n\t\t# return z\n\t\techo $3\n\tfi", "    if\
    \ [[ $(is_prime \"$1\") -eq 0 ]]; then\n        echo \"$2\"\n    else\n      \
    \  echo \"$3\"\n    fi", "    if [ \"$#\" -ne 3 ]; then\n        echo \"There\
    \ should be three parameters\"\n        return\n    fi\n    if [ \"$1\" -lt 2\
    \ ]; then\n        echo \"The first parameter should be an integer >= 2\"\n  \
    \      return\n    fi\n    if [ \"$2\" -eq \"$2\" ] 2>/dev/null; then\n      \
    \  :\n    else\n        echo \"The second parameter should be an integer\"\n \
    \       return\n    fi\n    if [ \"$3\" -eq \"$3\" ] 2>/dev/null; then\n     \
    \   :\n    else\n        echo \"The third parameter should be an integer\"\n \
    \       return\n    fi\n    i=2\n    while [ $i -lt $1 ]; do\n        if [ $(($1\
    \ % $i)) -eq 0 ]; then\n            echo \"$2\"\n            return\n        fi\n\
    \        ((i=i+1))\n    done\n    echo \"$3\"", "    if is_prime \"$1\"; then\n\
    \        echo \"$2\"\n    else\n        echo \"$3\"\n    fi", "  if  is_prime\
    \ $1 ; then \n    echo $2\n  else\n    echo $3\n  fi", "  res=`is_prime $1`\n\
    \  if [[ $res -eq 0 ]]; then\n    echo \"$2\"\n  else\n    echo \"$3\"\n  fi",
  "    n=$1\n    x=$2\n    y=$3\n    if [[ `is_prime $n` -eq 1 ]]; then\n        echo\
    \ $x\n    else\n        echo $y\n    fi", "  local n=\"$1\"\n  local x=\"$2\"\n\
    \  local y=\"$3\"\n  local i\n  local z=\"$x\"\n  # TODO: Fix below (remove the\
    \ semicolon)\n  for ((i=2; i<\"$n\"; i++)) ; do\n    if [ $((n%i)) -eq 0 ]; then\n\
    \      z=\"$y\"\n      break\n    fi\n  done\n  echo \"$z\"", "  if [ \"$#\" -ne\
    \ 3 ]; then\n    echo \"Usage: x_or_y NUMBER X Y\"\n    return 1\n  fi\n  if [\
    \ $(is_prime \"$1\") -eq 1 ]; then\n    echo \"$2\"\n  else\n    echo \"$3\"\n\
    \  fi", "\tif (is_prime \"$1\"); then\n\t\techo \"$2\"\n\telse\n\t\techo \"$3\"\
    \n\tfi", "  for ((i=2;i<=$1/2;i++))\n  do\n    if [ $(($1%i)) -eq 0 ]\n    then\n\
    \      echo $3\n      return\n    fi\n  done\n  echo $2", "    if is_prime \"\
    $1\"; then\n        echo \"$2\"\n    else\n        echo \"$3\"\n    fi", "\tif\
    \ [ \"$1\" -eq \"$1\" ] 2>/dev/null; then\n\t\tif [ \"$2\" -eq \"$2\" ] 2>/dev/null;\
    \ then\n\t\t\tif [ \"$3\" -eq \"$3\" ] 2>/dev/null; then\n\t\t\t\tif [ \"$1\"\
    \ -eq 0 ] || [ \"$1\" -eq 1 ]; then\n\t\t\t\t\techo \"$2\"\n\t\t\t\telse\n\t\t\
    \t\t\ti=2\n\t\t\t\t\tflag=0\n\t\t\t\t\twhile [ $i -lt $1 ]\n\t\t\t\t\tdo\n\t\t\
    \t\t\t\tx=$(($1 % $i))\n\t\t\t\t\t\tif [ $x -eq 0 ]; then\n\t\t\t\t\t\t\tflag=1\n\
    \t\t\t\t\t\t\tbreak\n\t\t\t\t\t\tfi\n\t\t\t\t\t\ti=$(($i + 1))\n\t\t\t\t\tdone\n\
    \t\t\t\t\tif [ $flag -eq 0 ]; then\n\t\t\t\t\t\techo \"$3\"\n\t\t\t\t\telse\n\t\
    \t\t\t\t\techo \"$2\"\n\t\t\t\t\tfi\n\t\t\t\tfi\n\t\t\telse\n\t\t\t\techo \"$2\"\
    \n\t\t\tfi\n\t\telse\n\t\t\techo \"$2\"\n\t\tfi\n\telse\n\t\techo \"$2\"\n\tfi",
  "    local n=\"$1\"\n    local x=\"$2\"\n    local y=\"$3\"\n    local i\n    for\
    \ ((i=2; i<\"$n\"; i++)); do\n        if [[ $((n%i)) -eq 0 ]]; then\n        \
    \    echo \"$y\"\n            return\n        fi\n    done\n    echo \"$x\"",
  "\tprime () {\n\t\tlocal num=$1\n\t\tlocal divisor=2\n\t\tlocal max=$(($num/2))\n\
    \t\twhile [ $divisor -le $max ] ; do\n\t\t\tif [ $(($num%$divisor)) -eq 0 ] ;\
    \ then\n\t\t\t\treturn 1\n\t\t\tfi\n\t\t\tdivisor=$(($divisor+1))\n\t\tdone\n\t\
    \treturn 0\n\t}\n\tif prime $1 ; then\n\t\techo $2\n\telse\n\t\techo $3\n\tfi",
  "  local n=$1\n  local x=$2\n  local y=$3\n  # If there are no arguments, return\
    \ -1\n  if [ -z \"$1\" ] || [ -z \"$2\" ] || [ -z \"$3\" ]; then\n    echo -1\n\
    \    return -1\n  fi\n  # If one of the arguments are not integers, return -1\n\
    \  if ! [[ \"$n\" =~ ^[0-9]+$ ]] || ! [[ \"$x\" =~ ^[0-9]+$ ]] || ! [[ \"$y\"\
    \ =~ ^[0-9]+$ ]]; then\n    echo -1\n    return -1\n  fi\n  # If n is less than\
    \ 2 return -1\n  if [ \"$n\" -lt 2 ]; then\n    echo -1\n    return -1\n  fi\n\
    \  # If n is equal to 2 or 3 return $x\n  if [ \"$n\" -eq 2 ] || [ \"$n\" -eq\
    \ 3 ]; then\n    echo $x\n    return $x\n  fi\n  # If n is divisible by 2 or 3\
    \ return $y\n  if [ \"$(($n % 2))\" -eq 0 ] || [ \"$(($n % 3))\" -eq 0 ]; then\n\
    \    echo $y\n    return $y\n  fi\n  local i=5\n  local w=2\n  # If n is not divisible\
    \ by 2 or 3, check if its divisible by \n  # i, where i is in the range (5, sqrt(n),\
    \ 2)\n  while [ \"$(($i * $i))\" -le \"$n\" ]; do\n    if [ \"$(($n % $i))\" -eq\
    \ 0 ]; then\n      echo $y\n      return $y\n    fi\n    i=$(($i + $w))\n    w=$(($w\
    \ ^ 6))\n  done\n  echo $x\n  return $x", "  # insert your code here\n  for ((i=2;\
    \ i<$1; i++))\n  do\n    if [ $(($1%$i)) -eq 0 ]\n    then\n      echo $3\n  \
    \    return\n    fi\n  done\n  echo $2", "  declare -i x=$2 y=$3\n  if (( $1 %\
    \ 2 == 0 )); then\n    echo $y\n  else\n    echo $x\n  fi", "\tprime=1\n\tfor\
    \ (( i=2;i<$1;i++ )); do\n\t\tif [ $(($1%$i)) -eq 0 ]; then\n\t\t\tprime=0\n\t\
    \t\tbreak\n\t\tfi\n\tdone\n\tif [ $prime -eq 1 ]; then\n\t\techo $2\n\telse\n\t\
    \techo $3\n\tfi", "    n=$1\n    x=$2\n    y=$3\n    is_prime=$(is_prime \"$n\"\
    )\n    if [ \"$is_prime\" == \"true\" ]; then\n        echo \"$x\"\n    else\n\
    \        echo \"$y\"\n    fi", "    if [[ $(is_prime \"$1\") == 0 ]]; then\n \
    \       echo \"$2\"\n    else\n        echo \"$3\"\n    fi", "  if [ $(($1 % 2))\
    \ == 0 ]; then\n    echo $2\n  else\n    echo $3\n  fi", "    value=$1\n    x=$2\n\
    \    y=$3\n    if is_prime \"$value\"; then\n        echo \"$x\"\n    else\n \
    \       echo \"$y\"\n    fi", "  if [ \"$#\" -ne 3 ]; then\n    echo \"Usage:\
    \ $0 n x y\" >&2\n    exit 1\n  fi\n  n=$1\n  x=$2\n  y=$3\n  if [ $(is_prime\
    \ $n) -eq 1 ]; then\n    echo $x\n  else\n    echo $y\n  fi", "    if is_prime\
    \ $1; then\n        echo $2\n    else\n        echo $3\n    fi", "\tNUM=$1\n\t\
    X=$2\n\tY=$3\n\tif [ $((NUM%2)) -eq 0 ] || [ $((NUM%3)) -eq 0 ] || [ $((NUM%5))\
    \ -eq 0 ] || [ $((NUM%7)) -eq 0 ]; then\n\t\techo $Y\n\telse\n\t\techo $X\n\t\
    fi", "    n=$1\n    x=$2\n    y=$3\n    if ! (( n % 2 )) || (( n < 2 )); then\n\
    \        echo $y\n    else\n        for (( i = 3; i <= sqrt; i += 2 )); do\n \
    \           if ! (( n % i )); then\n                echo $y\n                return\n\
    \            fi\n        done\n        echo $x\n    fi", "    if [[ $1 =~ ^[0-9]+$\
    \ ]] && [[ $2 =~ ^[0-9]+$ ]] && [[ $3 =~ ^[0-9]+$ ]]; then\n        if [[ $3 ==\
    \ $1 ]]; then\n            echo $2\n        else\n            echo $1\n      \
    \  fi\n    else\n        echo \"Error: argument(s) passed to 'x_or_y' is not an\
    \ integer.\"\n    fi", "\ti=2\n\ts=$1\n\tx=$2\n\ty=$3\n\twhile [ $i -lt $s ]\n\
    \tdo\n\t\tif [ $((s%i)) -eq 0 ]\n\t\tthen\n\t\t\techo \"$y\"\n\t\t\treturn\n\t\
    \tfi\n\t\ti=$((i+1))\n\tdone\n\techo \"$x\"", "    isPrime $1\n    if [[ $? -eq\
    \ 0 ]]; then\n        echo $2\n    else\n        echo $3\n    fi", "\tlocal n=$1\n\
    \tlocal x=$2\n\tlocal y=$3\n\t\n\twhile [ ! $n -eq 1 ]\n\tdo\n\t\tif [ $(( $n\
    \ % 2 )) -eq 0 ]\n\t\tthen\n\t\t\tn=$(( $n / 2 ))\n\t\telse\n\t\t\tn=$(( $n *\
    \ 3 + 1 ))\n\t\tfi\n\tdone\n\t\n\tif [ $n -eq 1 ]\n\tthen\n\t\techo $x\n\telse\n\
    \t\techo $y\n\tfi", "    if is_prime \"$1\"; then\n        echo \"$2\"\n    else\n\
    \        echo \"$3\"\n    fi", "\tif [[ $(is_prime $1) == \"true\" ]]; then\n\t\
    \techo \"$2\"\n\telse\n\t\techo \"$3\"\n\tfi", "    # your code goes here\n  \
    \  # hint: there is a command that checks if an integer is a prime number.", " \
    \   if (( $1 % $3 )) ; then\n        echo $2\n    else\n        echo $1\n    fi",
  "\tif [[ $# != 3 ]]; then\n\t\techo \"Usage: $0 n x y\"\n\telse\n\t\tif [[ $1 -le\
    \ 0 ]]; then\n\t\t\techo \"The number n must be greater than 0\"\n\t\telse\n\t\
    \t\t# A flag to check whether the number is prime or not\n\t\t\tprime=1\n\t\t\t\
    for (( i=2; i<=$1/2; i++ ))\n\t\t\tdo\n\t\t\t\tif [[ $(( $1 % $i )) -eq 0 ]];\
    \ then\n\t\t\t\t\tprime=0\n\t\t\t\t\tbreak\n\t\t\t\tfi\n\t\t\tdone\n\t\t\tif [[\
    \ $prime -eq 1 ]]; then\n\t\t\t\techo \"$2\"\n\t\t\telse\n\t\t\t\techo \"$3\"\n\
    \t\t\tfi\n\t\tfi\n\tfi", "    if [ $1 -eq 2 ] || [ $1 -eq 3 ] || [ $1 -eq 5 ]\
    \ || [ $1 -eq 7 ] || [ $1 -eq 11 ] || [ $1 -eq 13 ] || [ $1 -eq 17 ] || [ $1 -eq\
    \ 19 ] || [ $1 -eq 23 ] || [ $1 -eq 29 ] || [ $1 -eq 31 ] || [ $1 -eq 37 ] ||\
    \ [ $1 -eq 41 ] || [ $1 -eq 43 ] || [ $1 -eq 47 ] || [ $1 -eq 53 ] || [ $1 -eq\
    \ 59 ] || [ $1 -eq 61 ] || [ $1 -eq 67 ] || [ $1 -eq 71 ] || [ $1 -eq 73 ] ||\
    \ [ $1 -eq 79 ] || [ $1 -eq 83 ] || [ $1 -eq 89 ] || [ $1 -eq 97 ] ; then\n\t\
    echo \"$2\"\n    else\n\techo \"$3\"\n    fi", "    if [ \"$#\" -ne 3 ]; then\n\
    \techo \"Error: three parameters are needed to use this function.\"\n\treturn\n\
    \    fi\n    if [ $1 -eq 2 ] || [ $1 -eq 3 ] || [ $1 -eq 5 ] || [ $1 -eq 7 ];\
    \ then\n\techo \"$3\"\n    else\n\tt=$(($1 % 2))\n\tu=$(($1 % 3))\n\tv=$(($1 %\
    \ 5))\n\tw=$(($1 % 7))\n\tif [ $t -eq 0 ] || [ $u -eq 0 ] || [ $v -eq 0 ] || [\
    \ $w -eq 0 ]; then\n\t    echo \"$2\"\n\telse\n\t    echo \"$3\"\n\tfi\n    fi",
  "    # Check if the given input is integer or not\n    if [[ \"$1\" =~ ^[0-9]+$\
    \ ]]; then\n        # Check if the given input is integer or not\n        if [[\
    \ \"$2\" =~ ^[0-9]+$ ]]; then\n            # Check if the given input is integer\
    \ or not\n            if [[ \"$3\" =~ ^[0-9]+$ ]]; then\n                # Check\
    \ if the given input is prime or not\n                if [[ $(is_prime \"$1\"\
    ) -eq 1 ]]; then\n                    echo \"$2\"\n                else\n    \
    \                echo \"$3\"\n                fi\n            else\n         \
    \       echo \"Please, enter an integer\"\n            fi\n        else\n    \
    \        echo \"Please, enter an integer\"\n        fi\n    else\n        echo\
    \ \"Please, enter an integer\"\n    fi", "\tif [ $# -ne 3 ]; then\n\t\techo \"\
    Error: expected 3 arguments\"\n\t\texit 1\n\tfi\n\tif ! [ \"$1\" -eq \"$1\" ]\
    \ 2>/dev/null; then\n\t\techo \"Error: \\$1 is not an integer\"\n\t\texit 1\n\t\
    fi\n\tif ! [ \"$2\" -eq \"$2\" ] 2>/dev/null; then\n\t\techo \"Error: \\$2 is\
    \ not an integer\"\n\t\texit 1\n\tfi\n\tif ! [ \"$3\" -eq \"$3\" ] 2>/dev/null;\
    \ then\n\t\techo \"Error: \\$3 is not an integer\"\n\t\texit 1\n\tfi\n\tx=$1\n\
    \ty=$2\n\tn=$3\n\tif [ $n -lt 2 ]; then\n\t\techo \"$y\"\n\t\texit 0\n\tfi\n\t\
    for((i=2;i<=n/2;i++))\n\tdo\n\t\tif [ $((n%i)) -eq 0 ]; then\n\t\t\techo \"$y\"\
    \n\t\t\texit 0\n\t\tfi\n\tdone\n\techo \"$x\"", "    if is_prime $1\n    then\n\
    \        echo $2\n    else\n        echo $3\n    fi", "  if [ -z \"$1\" ] || [\
    \ -z \"$2\" ] || [ -z \"$3\" ]; then\n    return 1\n  fi\n  if [[ $1 -gt $3 ]];\
    \ then\n    return 2\n  fi\n  x=$1\n  y=$2\n  n=$3\n  prime=$(is_prime \"$n\"\
    )\n  if [ \"$prime\" == \"true\" ]; then\n    echo \"$x\"\n  else\n    echo \"\
    $y\"\n  fi", "\tif ! $(is_prime \"$1\"); then\n\t\techo \"$2\"\n\telse\n\t\techo\
    \ \"$3\"\n\tfi", "\tif [[ $(is_prime \"$1\") -eq 1 ]]; then\n\t\techo \"$2\"\n\
    \telse\n\t\techo \"$3\"\n\tfi", "  local n=$1\n  local x=$2\n  local y=$3\n  local\
    \ is_prime_n=$(is_prime $n)\n  if [ $is_prime_n -eq 0 ]; then\n    echo $x\n \
    \ else\n    echo $y\n  fi", "\tfor (( n=2; n<$1; n++ ))\n\tdo\n\t    if [ $((\
    \ $1 % $n )) -eq 0 ]\n\t    then\n\t        echo \"$2\"\n\t        return 0\n\t\
    \    fi\n\tdone\n\techo \"$3\"", "  local num=$1\n  local x=$2\n  local y=$3\n\
    \  if $(is_prime $num); then\n    echo $x\n  else\n    echo $y\n  fi", "    if\
    \ [ $1 -eq 2 ] || [ $1 -eq 3 ] || [ $1 -eq 5 ] || [ $1 -eq 7 ] || [ $1 -eq 11\
    \ ] || [ $1 -eq 13 ] || [ $1 -eq 17 ] || [ $1 -eq 19 ] || [ $1 -eq 23 ] || [ $1\
    \ -eq 29 ] || [ $1 -eq 31 ] || [ $1 -eq 37 ] || [ $1 -eq 41 ] || [ $1 -eq 43 ]\
    \ || [ $1 -eq 47 ] || [ $1 -eq 53 ] || [ $1 -eq 59 ] || [ $1 -eq 61 ] || [ $1\
    \ -eq 67 ] || [ $1 -eq 71 ] || [ $1 -eq 73 ] || [ $1 -eq 79 ] || [ $1 -eq 83 ]\
    \ || [ $1 -eq 89 ] || [ $1 -eq 97 ]\n    then\n        echo $2\n    else\n   \
    \     echo $3\n    fi", "    if [[ \"$1\" -lt \"2\" ]]; then\n        echo \"\
    $3\"\n    elif [[ \"$1\" -eq \"2\" ]]; then\n        echo \"$2\"\n    elif [[\
    \ $(( $1 % 2 )) -eq 0 ]]; then\n        echo \"$3\"\n    fi\n    local s=3\n \
    \   while [[ $(( $s * $s )) -le \"$1\" ]]; do\n        if [[ $(( $1 % $s )) -eq\
    \ 0 ]]; then\n            echo \"$3\"\n            return\n        fi\n      \
    \  s=$(( $s + 2 ))\n    done\n    echo \"$2\"", "\t# Check that each argument\
    \ is an integer\n\tre='^[0-9]+$'\n\tif ! [[ $1 =~ $re ]] || ! [[ $2 =~ $re ]]\
    \ || ! [[ $3 =~ $re ]] ; then\n\t\techo \"Error: invalid number(s)\" >&2; exit\
    \ 1\n\tfi\n\n\t# If the first argument is prime, return the second argument.\n\
    \t# Otherwise, return the third argument.\n\tif [[ $(is_prime \"$1\") ]]; then\n\
    \t\techo \"$2\"\n\telse\n\t\techo \"$3\"\n\tfi", "    if [ $# -ne 3 ]; then\n\
    \        echo \"x_or_y takes 3 arguments\"\n        return 1\n    fi\n    if [[\
    \ -z $1 || -z $2 || -z $3 ]]; then\n        echo \"x_or_y takes 3 arguments\"\n\
    \        return 1\n    fi\n    if ! [[ $1 =~ ^[0-9]+$ && $2 =~ ^[0-9]+$ && $3\
    \ =~ ^[0-9]+$ ]]; then\n        echo \"x_or_y takes 3 integers\"\n        return\
    \ 1\n    fi\n    if [[ $1 -lt 0 || $2 -lt 0 || $3 -lt 0 ]]; then\n        echo\
    \ \"x_or_y takes 3 positive integers\"\n        return 1\n    fi\n    if [ $3\
    \ -eq 0 ]; then\n        echo $2\n        return 0\n    fi\n    for (( i=2; i<=$(($3/2));\
    \ i++ )); do\n        if [ $(($3%$i)) -eq 0 ]; then\n            echo $2\n   \
    \         return 0\n        fi\n    done\n    echo $1\n    return 0", "    if\
    \ [ -z $1 ]\n    then\n        # First argument is empty\n        echo \"The first\
    \ argument is not given\"\n        return 1\n    fi\n    if [ -z $2 ]\n    then\n\
    \        # Second argument is empty\n        echo \"The second argument is not\
    \ given\"\n        return 1\n    fi\n    if [ -z $3 ]\n    then\n        # Third\
    \ argument is empty\n        echo \"The third argument is not given\"\n      \
    \  return 1\n    fi\n    if [ $1 -eq 0 ]\n    then\n        # First argument cannot\
    \ be zero\n        echo \"The first argument cannot be zero\"\n        return\
    \ 1\n    fi\n    if [ $2 -eq 0 ]\n    then\n        # Second argument cannot be\
    \ zero\n        echo \"The second argument cannot be zero\"\n        return 1\n\
    \    fi\n    if [ $3 -eq 0 ]\n    then\n        # Third argument cannot be zero\n\
    \        echo \"The third argument cannot be zero\"\n        return 1\n    fi\n\
    \    if [ $1 -lt 0 ]\n    then\n        # First argument cannot be negative\n\
    \        echo \"The first argument cannot be negative\"\n        return 1\n  \
    \  fi\n    if [ $2 -lt 0 ]\n    then\n        # Second argument cannot be negative\n\
    \        echo \"The second argument cannot be negative\"\n        return 1\n \
    \   fi\n    if [ $3 -lt 0 ]\n    then\n        # Third argument cannot be negative\n\
    \        echo \"The third argument cannot be negative\"\n        return 1\n  \
    \  fi\n    for arg in $1 $2 $3\n    do\n        if [ $arg -lt 0 ]\n        then\n\
    \            # Argument cannot be negative\n            echo \"An argument cannot\
    \ be negative\"\n            return 1\n        fi\n    done\n    if ! [[ $1 =~\
    \ ^[0-9]+$ ]]\n    then\n        # First argument is not an integer\n        echo\
    \ \"The first argument is not an integer\"\n        return 1\n    fi\n    if !\
    \ [[ $2 =~ ^[0-9]+$ ]]\n    then\n        # Second argument is not an integer\n\
    \        echo \"The second argument is not an integer\"\n        return 1\n  \
    \  fi\n    if ! [[ $3 =~ ^[0-9]+", "\tif [ $(is_prime \"$1\") -eq 1 ]; then\n\t\
    \techo \"$2\"\n\telse\n\t\techo \"$3\"\n\tfi", "    if [ $1 -lt 2 ]; then \n \
    \       echo $3\n    elif [ $1 -eq 2 ]; then\n        echo $2\n    elif [ $((\
    \ $1 % 2 )) -eq 0 ]; then\n        echo $3\n    else\n        for (( i=3; i<=Math.sqrt($1);\
    \ i+=2 )); do\n            if [ $(( $1 % $i )) -eq 0 ]; then\n               \
    \ echo $3\n                return 1\n            fi\n        done\n        echo\
    \ $2\n    fi", "\t# Check if $1 is prime, if not prime return $2, otherwise return\
    \ $3\n\t# TODO: Fill in the rest of the code here\n\tif is_prime \"$1\"; then\n\
    \t\techo \"$3\"\n\telse\n\t\techo \"$2\"\n\tfi", "  local result=\"\"\n  if [\
    \ $(is_prime $1) -eq 1 ]; then\n    result=$2\n  else\n    result=$3\n  fi\n \
    \ echo $result", "    n=$1\n    x=$2\n    y=$3\n    remainder=2\n    while [ $((n\
    \ % $remainder)) -ne 0 -a $remainder -lt $n ]\n    do\n        remainder=$((remainder\
    \ + 1))\n    done\n    if [ $remainder -eq $n ]\n    then\n        echo $x\n \
    \   else\n        echo $y\n    fi", "    n=$1\n    x=$2\n    y=$3\n    # If n\
    \ is prime, return x, otherwise return y\n    if $(is_prime $n); then\n      \
    \  echo $x\n    else\n        echo $y\n    fi", "    if is_prime \"$1\"; then\n\
    \        echo \"$2\"\n    else\n        echo \"$3\"\n    fi", "  local test_n=$1\n\
    \  local x=$2\n  local y=$3\n  if [ \"$test_n\" -lt 2 ]; then\n    echo $y\n \
    \ elif [ \"$test_n\" -eq 2 ]; then\n    echo $x\n  elif [ $(( test_n % 2 )) -eq\
    \ 0 ]; then\n    echo $y\n  else\n    local i=3\n    while [ $(( i * i )) -le\
    \ \"$test_n\" ]; do\n      if [ $(( test_n % i )) -eq 0 ]; then\n        echo\
    \ $y\n        return\n      fi\n      i=$(( i + 2 ))\n    done\n    echo $x\n\
    \  fi", "\tlocal n=$1\n\tlocal x=$2\n\tlocal y=$3\n\tlocal i=2\n\tlocal result=1\n\
    \twhile [ $i -lt $n ]\n\tdo\n\t\tif [ $(( $n % $i )) -eq 0 ]\n\t\tthen\n\t\t\t\
    result=0\n\t\t\tbreak\n\t\tfi\n\t\ti=$(( $i + 1 ))\n\tdone\n\tif [ $result -eq\
    \ 1 ]\n\tthen\n\t\techo $x\n\telse\n\t\techo $y\n\tfi", "    (n=$1; x=$2; y=$3;\n\
    \     if [ $(is_prime \"$n\") -eq 0 ]; then\n         echo \"$x\"\n     else\n\
    \         echo \"$y\"\n     fi)", "    local n=$1\n    local x=$2\n    local y=$3\n\
    \    if [[ $n == 2 || $n == 3 || $n == 5 || $n == 7 ]]; then\n        printf \"\
    %s\" \"$x\"\n    elif [[ $n%2 -ne 0 && $n%3 -ne 0 && $n%5 -ne 0 && $n%7 -ne 0\
    \ ]]; then\n        printf \"%s\" \"$x\"\n    else\n        printf \"%s\" \"$y\"\
    \n    fi", "    if [[ \"$1\" -eq 0 ]]; then\n        echo \"Invalid input\"\n\
    \        return 0\n    fi\n    for (( i=2; i<\"$1\"; i++ )); do\n        if [[\
    \ $(( \"$1\" % i )) -eq 0 ]]; then\n            echo \"$3\"\n            return\
    \ 0\n        fi\n    done\n    echo \"$2\"", "\t# TODO: Fill in this function.\n\
    \tif [[ $# -eq 3 ]]; then\n\t\tif [[ $1 =~ ^-?[0-9]+$ ]] && [[ $2 =~ ^-?[0-9]+$\
    \ ]] && [[ $3 =~ ^-?[0-9]+$ ]]; then\n\t\t\tif [[ $(bc <<< \"$1%$3\") -eq 0 ]];\
    \ then\n\t\t\t\techo \"$2\"\n\t\t\telse\n\t\t\t\techo \"$1\"\n\t\t\tfi\n\t\telse\n\
    \t\t\techo \"Error: Inputs must be integers.\"\n\t\tfi\n\telse\n\t\techo \"Error:\
    \ Usage: x_or_y x y n.\"\n\tfi", "    if (($1<2)) \n    then\n        echo \"\
    $3\"\n    else\n        for (( i=2; i*i<=$1; i++ )); do\n            if (( $1\
    \ % i == 0 )); then\n                echo \"$3\"\n                return\n   \
    \         fi\n        done\n        echo \"$2\"\n    fi", "    if [[ -z $1 ]]\
    \ || [[ -z $2 ]] || [[ -z $3 ]]; then\n        return 1\n    fi\n    if [[ ! $1\
    \ =~ ^[0-9]+$ ]] || [[ ! $2 =~ ^[0-9]+$ ]] || [[ ! $3 =~ ^[0-9]+$ ]]; then\n \
    \       return 1\n    fi\n    local x=$2\n    local y=$3\n    local n=$1\n   \
    \ local sqrt_n=$( echo \"sqrt($n)\" | bc )\n    local i=2\n    while [[ i -le\
    \ sqrt_n ]]; do\n        if [[ $(( n % i )) -eq 0 ]]; then\n            echo $y\n\
    \            return 0\n        fi\n        (( i++ ))\n    done\n    echo $x\n\
    \    return 0", "    for (( i=2; i<$1; i++ )); do\n        if [ $(( $1 % $i ))\
    \ -eq 0 ]; then\n            echo $3\n            exit 0\n        fi\n    done\n\
    \    echo $2", "    factor $1 \n    if [[ $? -eq 0 ]]; then\n        echo $2\n\
    \    else\n        echo $3\n    fi", "  if [ $# -ne 3 ]; then\n    echo \"Usage:\
    \ $0 n x y\"\n    exit 1\n  fi\n  if [ $1 -le 0 ]; then\n    echo \"n must be\
    \ a positive integer\"\n    exit 1\n  fi\n  for i in $(seq 2 $1); do\n    if [\
    \ $1 -eq $i ]; then\n      echo $3\n      return\n    fi\n    if [ $(( $1 % $i\
    \ )) -eq 0 ]; then\n      echo $2\n      return\n    fi\n  done", "\t# TODO: Complete\
    \ this function\n\tif [[ $2 -eq 1 || $2 -eq 0 ]]; then\n\t\t#echo \"1\"\n\t\t\
    echo $1\n\telif [[ $2 -eq 2 ]]; then\n\t\t#echo \"2\"\n\t\techo $3\n\telif [[\
    \ $2 -eq 3 ]]; then\n\t\t#echo \"3\"\n\t\techo $1\n\telif [[ $2 -eq 4 ]]; then\n\
    \t\t#echo \"4\"\n\t\techo $3\n\telif [[ $2 -eq 5 ]]; then\n\t\t#echo \"5\"\n\t\
    \techo $1\n\telif [[ $2 -eq 6 ]]; then\n\t\t#echo \"6\"\n\t\techo $3\n\telif [[\
    \ $2 -eq 7 ]]; then\n\t\t#echo \"7\"\n\t\techo $1\n\telif [[ $2 -eq 8 ]]; then\n\
    \t\t#echo \"8\"\n\t\techo $3\n\telif [[ $2 -eq 9 ]]; then\n\t\t#echo \"9\"\n\t\
    \techo $3\n\telif [[ $2 -eq 10 ]]; then\n\t\t#echo \"10\"\n\t\techo $3\n\telif\
    \ [[ $2 -eq 11 ]]; then\n\t\t#echo \"11\"\n\t\techo $1\n\telif [[ $2 -eq 12 ]];\
    \ then\n\t\t#echo \"12\"\n\t\techo $3\n\telif [[ $2 -eq 13 ]]; then\n\t\t#echo\
    \ \"13\"\n\t\techo $1\n\telif [[ $2 -eq 14 ]]; then\n\t\t#echo \"14\"\n\t\techo\
    \ $3\n\telif [[ $2 -eq 15 ]]; then\n\t\t#echo \"15\"\n\t\techo $3\n\telif [[ $2\
    \ -eq 16 ]]; then\n\t\t#echo \"16\"\n\t\techo $3\n\telif [[ $2 -eq 17 ]]; then\n\
    \t\t#echo \"17\"\n\t\techo $1\n\telif [[ $2 -eq 18 ]]; then\n\t\t#echo \"18\"\n\
    \t\techo $3\n\telif [[ $2 -eq 19 ]];", "  int=$1\n  x=$2\n  y=$3\n  if [ $int\
    \ -le 1 ]; then\n    echo $y\n  elif [ $int -eq 2 ]; then\n    echo $x\n  else\n\
    \    square_root=$(echo \"sqrt($int)\" | bc -l)\n    factors=1\n    counter=2\n\
    \    while [ $counter -le $square_root ]; do\n      remainder=$(($int % $counter))\n\
    \      if [ $remainder -eq 0 ]; then\n        factors=$(($factors + 2))\n    \
    \  fi\n      counter=$(($counter + 1))\n    done\n    if [ $factors -eq 2 ]; then\n\
    \      echo $x\n    else\n      echo $y\n    fi\n  fi", "    if [ $1 -eq $3 ];\
    \ then\n        echo $2\n    else\n        echo $1\n    fi", "\tif (( $1 % 2 ==\
    \ 0 )); then\n\t\techo $2\n\telse\n\t\techo $3\n\tfi", "    local n=$1\n    local\
    \ x=$2\n    local y=$3\n    if [[ $((n%2)) -eq 0 || $((n%3)) -eq 0 || $((n%5))\
    \ -eq 0 || $((n%7)) -eq 0 ]]; then\n        echo $y\n    else\n        echo $x\n\
    \    fi", "  if [[ $1 -gt 1 ]]; then\n    for (( i=2; i<=$1-1; i++ )); do\n  \
    \    if [[ $1%$i -eq 0 ]]; then\n        echo \"$2\"\n        return\n      fi\n\
    \    done\n    echo \"$3\"\n  else\n    echo \"$2\"\n  fi", "\tlocal x\n\tlocal\
    \ y\n\tlocal n\n\tx=\"$1\"\n\ty=\"$2\"\n\tn=\"$3\"\n\tif [[ \"2\" -le \"$n\" ]];\
    \ then\n\t\tlocal i\n\t\ti=\"2\"\n\t\twhile [[ \"$i\" -lt \"$n\" ]]; do\n\t\t\t\
    if [[ \"$n\" -eq \"$(($n / $i * $i))\" ]]; then\n\t\t\t\techo \"$y\"\n\t\t\t\t\
    return\n\t\t\tfi\n\t\t\ti=\"$(($i + 1))\"\n\t\tdone\n\tfi\n\techo \"$x\"", " \
    \ if [[ $3 -eq 1 ]]; then\n    echo $1\n  else\n    declare -i x=$(x_or_y $1 $2\
    \ $(($3-1)))\n    if [[ $x -eq 1 ]]; then\n      echo $1\n    else\n      echo\
    \ $2\n    fi\n  fi", "    if [[ $# -ne 3 ]]; then\n        echo \"x_or_y: Usage:\
    \ ./x_or_y.sh <n> <x> <y>\"\n        exit 1\n    fi\n    if [[ $1 -lt 0 ]]; then\n\
    \        echo \"x_or_y: <n> should be a positive integer\"\n        exit 1\n \
    \   fi\n    if [[ $1 -eq 1 ]]; then\n        echo $3\n        exit 0\n    fi\n\
    \    for i in $(seq 2 $(( $1 - 1))); do\n        if [[ $(( $1 % $i )) -eq 0 ]];\
    \ then\n            echo $3\n            exit 0\n        fi\n    done\n    echo\
    \ $2", "    local x=$1\n    local y=$2\n    local n=$3\n    if [[ $n -lt 2 ]];\
    \ then\n        echo $y\n    elif [[ $n -eq 2 ]]; then\n        echo $x\n    else\n\
    \        for i in $(seq 2 $n); do\n            if [[ $((n % i)) -eq 0 ]]; then\n\
    \                echo $y\n                return\n            fi\n        done\n\
    \        echo $x\n    fi", "    if [[ $(is_prime \"$1\") == \"true\" ]]; then\n\
    \        echo \"$2\"\n    else\n        echo \"$3\"\n    fi", "\t# TODO: You should\
    \ check whether the arguments are integers\n\t# If not, call the usage function\
    \ with the following error\n\t# message: \"Arguments are not integers.\"\n\tif\
    \ [[ \"$1\" =~ ^-?[0-9]+$ ]] && [[ \"$2\" =~ ^-?[0-9]+$ ]] && [[ \"$3\" =~ ^-?[0-9]+$\
    \ ]]; then\n\t\tif [[ $3 -eq 1 ]]; then\n\t\t\tprintf \"$2\"\n\t\telse\n\t\t\t\
    printf \"$1\"\n\t\tfi\n\telse\n\t\tusage \"Arguments are not integers.\"\n\tfi",
  "    # write your code here\n    n=$1\n    x=$2\n    y=$3\n    # $(( )) is the command\
    \ used to evaluate arithmetic expression.\n    # The expr command has been deprecated\
    \ for some time.\n    if [ $((n%2)) -eq 0 ]; then\n        echo $y\n    else\n\
    \        echo $x\n    fi", "    if [ \"$1\" -lt \"2\" ]; then\n        echo \"\
    $3\"\n    elif [ \"$1\" -eq \"2\" ]; then\n        echo \"$2\"\n    elif [ $(($1\
    \ % 2)) -eq \"0\" ]; then\n        echo \"$3\"\n    else\n        i=3\n      \
    \  while [ $(($i * $i)) -le \"$1\" ]; do\n            if [ $(($1 % $i)) -eq \"\
    0\" ]; then\n                echo \"$3\"\n                return\n           \
    \ fi\n            i=$(($i + 2))\n        done\n        echo \"$2\"\n    fi", "\t\
    if [ \"$1\" -eq 2 ] || [ \"$1\" -eq 3 ] || [ \"$1\" -eq 5 ] || [ \"$1\" -eq 7\
    \ ] || [ \"$1\" -eq 11 ]\n\tthen\n\t\techo \"$3\"\n\telif [ $(($1 % 2)) -eq 0\
    \ ] || [ $(($1 % 3)) -eq 0 ] || [ $(($1 % 5)) -eq 0 ] || [ $(($1 % 7)) -eq 0 ]\
    \ || [ $(($1 % 11)) -eq 0 ]\n\tthen\n\t\techo \"$2\"\n\tfi", "  number=$1\n  x=$2\n\
    \  y=$3\n  is_prime=$(is_prime $number)\n  if [ $is_prime == \"1\" ]; then\n \
    \   echo $x\n  else\n    echo $y\n  fi", "    if is_prime $1; then\n        echo\
    \ $2\n    else\n        echo $3\n    fi", "\tlocal number=$1\n\tlocal x=$2\n\t\
    local y=$3\n\ti=2\n\tf=0\n\twhile [ $i -le `expr $number / 2` ]\n\tdo\n\t\tif\
    \ [ `expr $number % $i` -eq 0 ]\n\t\tthen\n\t\t\tf=1\n\t\tfi\n\t\ti=`expr $i +\
    \ 1`\n\tdone\n\tif [ $f -eq 0 ]\n\tthen\n\t\techo $x\n\telse\n\t\techo $y\n\t\
    fi", "    if is_prime \"$1\"; then\n        echo \"$2\"\n    else\n        echo\
    \ \"$3\"\n    fi", "\tif [[ \"$1\" -eq \"$1\" ]] 2>/dev/null; then\n\t\tif is_prime\
    \ \"$1\"; then\n\t\t\techo \"$2\"\n\t\telse\n\t\t\techo \"$3\"\n\t\tfi\n\telse\n\
    \t\techo \"1st argument is not an integer\"\n\tfi", "  is_n_prime=\"false\"\n\
    \  for i in $(seq $3); do\n    if [[ $i -eq $3 ]]; then\n      break\n    fi\n\
    \    rem=$(($3 % $i))\n    if [[ $rem -eq 0 ]]; then\n      is_n_prime=\"false\"\
    \n      break\n    else\n      is_n_prime=\"true\"\n    fi\n  done\n  if [[ $is_n_prime\
    \ = \"true\" ]]; then\n    echo $1\n  else\n    echo $2\n  fi", "  if [[ $(is_prime\
    \ \"$1\") -eq 1 ]]; then\n    echo \"$2\"\n  else\n    echo \"$3\"\n  fi", "\t\
    x=\"$1\"\n\ty=\"$2\"\n\tn=\"$3\"\n\tif [ \"$(sieve \"$n\")\" -eq 1 ]; then\n\t\
    \techo \"$x\"\n\telse\n\t\techo \"$y\"\n\tfi", "\t# Define variables\n\tlocal\
    \ is_prime=\"$(is_prime $1)\"\n\tlocal n=\"$1\"\n\tlocal x=\"$2\"\n\tlocal y=\"\
    $3\"\n\tlocal output=\"$x\"\n\t# Check to see if number is prime\n\tif [[ $is_prime\
    \ -eq 0 ]]; then\n\t\toutput=\"$y\"\n\tfi\n\t# Return the value of x or y\n\t\
    echo \"$output\"", "  if [ \"$1\" == \"\" ] || [ \"$2\" == \"\" ] || [ \"$3\"\
    \ == \"\" ]; then\n    echo \"Error: Wrong input.\"\n    return 1\n  fi\n  if\
    \ [ $(is_prime \"$1\") -eq 0 ]; then\n    echo \"$2\"\n  else\n    echo \"$3\"\
    \n  fi", "    if (($3 % $1 == 0)); then\n        echo $2\n    else\n        echo\
    \ $1\n    fi", "  if [ $# -ne 3 ]; then\n    echo \"Three arguments required.\"\
    \n    exit 1\n  fi\n  if [[ $1 =~ ^-?[0-9]+$ ]]; then\n    if [ $(prime_number\
    \ $1) -eq 0 ]; then\n      echo $2\n    else\n      echo $3\n    fi\n  else\n\
    \    echo \"Not an integer.\"\n    exit 1\n  fi", "    is_prime $1\n    if [[\
    \ $? -eq 1 ]]; then\n        echo $2\n    else\n        echo $3\n    fi", "\t\
    if [[ $(check_is_prime \"$1\") -eq 1 ]]; then\n\t\techo \"$2\"\n\telse\n\t\techo\
    \ \"$3\"\n\tfi", "\tif is_prime $1; then\n\t\techo $2\n\telse\n\t\techo $3\n\t\
    fi", "\tif [ $1 -gt 0 ]\n\tthen\n\t\tif [ $1 -eq 2 ]\n\t\tthen\n\t\t\techo $3\n\
    \t\telif [ $1 -eq 3 ]\n\t\tthen\n\t\t\techo $3\n\t\telif [ $1 -eq 5 ]\n\t\tthen\n\
    \t\t\techo $3\n\t\telif [ $1 -eq 7 ]\n\t\tthen\n\t\t\techo $3\n\t\telif [ $1 -eq\
    \ 11 ]\n\t\tthen\n\t\t\techo $3\n\t\telif [ $1 -eq 13 ]\n\t\tthen\n\t\t\techo\
    \ $3\n\t\telif [ $1 -eq 17 ]\n\t\tthen\n\t\t\techo $3\n\t\telif [ $1 -eq 19 ]\n\
    \t\tthen\n\t\t\techo $3\n\t\telif [ $1 -eq 23 ]\n\t\tthen\n\t\t\techo $3\n\t\t\
    elif [ $1 -eq 29 ]\n\t\tthen\n\t\t\techo $3\n\t\telif [ $1 -eq 31 ]\n\t\tthen\n\
    \t\t\techo $3\n\t\telif [ $1 -eq 37 ]\n\t\tthen\n\t\t\techo $3\n\t\telif [ $1\
    \ -eq 41 ]\n\t\tthen\n\t\t\techo $3\n\t\telif [ $1 -eq 43 ]\n\t\tthen\n\t\t\t\
    echo $3\n\t\telif [ $1 -eq 47 ]\n\t\tthen\n\t\t\techo $3\n\t\telif [ $1 -eq 53\
    \ ]\n\t\tthen\n\t\t\techo $3\n\t\telif [ $1 -eq 59 ]\n\t\tthen\n\t\t\techo $3\n\
    \t\telif [ $1 -eq 61 ]\n\t\tthen\n\t\t\techo $3\n\t\telif [ $1 -eq 67 ]\n\t\t\
    then\n\t\t\techo $3\n\t\telif [ $1 -eq 71 ]\n\t\tthen\n\t\t\techo $3\n\t\telif\
    \ [ $1 -eq 73 ]\n\t\tthen\n\t\t\techo $3\n\t\telif [ $1 -eq 79 ]\n\t\tthen\n",
  "\tlocal n=\"$1\"\n\tlocal x=\"$2\"\n\tlocal y=\"$3\"\n\tlocal prime=$(is_prime\
    \ \"$n\")\n\tif [[ \"$prime\" -eq 1 ]]; then\n\t\techo \"$x\"\n\telse\n\t\techo\
    \ \"$y\"\n\tfi", "\t# Check if first argument is a prime number\n\tif [ $(is_prime\
    \ $1) == \"true\" ]; then\n\t\t# Return value of x\n\t\techo \"$2\"\n\telse\n\t\
    \t# Return value of y\n\t\techo \"$3\"\n\tfi", "    echo \"--- x_or_y $1 $2 $3\
    \ ---\"\n    if [[ $1 =~ ^[0-9]+$ ]]; then\n        if [[ $(is_prime $1) == \"\
    true\" ]]; then\n            echo $2\n        else\n            echo $3\n    \
    \    fi\n    else\n        echo \"Error: $1 is not an integer\"\n    fi", "  if\
    \ is_prime \"$1\"; then\n    echo \"$2\"\n  else\n    echo \"$3\"\n  fi", "  if\
    \ [[ -z $1 ]] || [[ -z $2 ]] || [[ -z $3 ]]; then\n    echo \"Inputs must be integers\"\
    \n    return 0\n  fi\n  if [[ $1 -eq 0 ]] || [[ $1 -eq 1 ]]; then\n    echo $2\n\
    \    return 0\n  fi\n  for (( i=2; i<=$(($1/2)); i++ )); do\n    if [[ $(( $1\
    \ % $i )) -eq 0 ]]; then\n      echo $2\n      return 0\n    fi\n  done\n  echo\
    \ $3", "\tlocal n=$1\n\tlocal x=$2\n\tlocal y=$3\n\tlocal prime=$(is_prime \"\
    $n\")\n\tif [ \"$prime\" -eq \"1\" ]; then\n\t\techo \"$x\"\n\telse\n\t\techo\
    \ \"$y\"\n\tfi", "\tif (( $1 % 2 == 0 )) || (( $1 % 3 == 0 )) || (( $1 % 5 ==\
    \ 0 )) || (( $1 % 7 == 0 )); then\n\t\techo $3\n\telse\n\t\techo $2\n\tfi", "\t\
    if [ $(is_prime $1) -eq 1 ]; then\n\t\techo $2\n\telse\n\t\techo $3\n\tfi", "\t\
    x=0;\n\tfor ((i=2; i<$1; i++)); do\n\t\tif [ $(($1 % $i)) == 0 ]; then\n\t\t\t\
    x=1;\n\t\tfi\n\tdone\n\n\tif [ $x == 0 ]; then\n\t\techo $2;\n\telse\n\t\techo\
    \ $3;\n\tfi", "\tif is_prime \"$1\"; then\n\t\techo \"$2\"\n\telse\n\t\techo \"\
    $3\"\n\tfi", "    if [ $(is_prime $1) -eq 0 ]; then\n        echo $2\n    else\n\
    \        echo $3\n    fi", "  local n=\"$1\"\n  local x=\"$2\"\n  local y=\"$3\"\
    \n  local i=$((n-1))\n  if ((n<2)); then\n    echo \"$y\"\n  else\n    while ((i>1));\
    \ do\n      if ((n%i==0)); then\n        echo \"$y\"\n        return\n      fi\n\
    \      i=$((i-1))\n    done\n    echo \"$x\"\n  fi", "\tlocal n=\"$1\"\n\tlocal\
    \ x=\"$2\"\n\tlocal y=\"$3\"\n\t\n\t# Check whether $n is a prime number\n\tlocal\
    \ result=$(is_prime \"$n\")\n\tif [ \"$result\" == \"true\" ]; then\n\t\techo\
    \ \"$x\"\n\telse\n\t\techo \"$y\"\n\tfi", "  # check if $1 is a prime number\n\
    \  if [[ \"$1\" =~ ^[0-9]+$ ]]; then\n    # check if $1 is > 2 and divisible by\
    \ 2\n    if [ $1 -gt 2 ] && [ $(( $1 % 2 )) -eq 0 ]; then\n      echo $2\n   \
    \ # check if $1 is 1 or 2\n    elif [ $1 -eq 1 ] || [ $1 -eq 2 ]; then\n     \
    \ echo $2\n    # check for all other cases\n    else\n      i=3\n      sqrt=\"\
    $(echo \"sqrt($1)\" | bc -l)\"\n      while [ $i -le $sqrt ]; do\n        if [\
    \ $(( $1 % $i )) -eq 0 ]; then\n          echo $2\n          exit 0\n        fi\n\
    \        i=$(( $i + 2 ))\n      done\n      echo $3\n    fi\n  else\n    echo\
    \ $2\n  fi", "  if $(is_prime \"$1\"); then\n    echo \"$2\"\n  else\n    echo\
    \ \"$3\"\n  fi", "    local n=$1\n    local x=$2\n    local y=$3\n    if (( $n\
    \ < 2 )); then\n        echo $y\n    elif (( $n % 2 == 0 )); then\n        echo\
    \ $y\n    else\n        for i in $(seq 3 2 $(bc <<< \"$n-1\")); do\n         \
    \   if (( $n % $i == 0 )); then\n                echo $y\n                return\n\
    \            fi\n        done\n        echo $x\n    fi", "    # Check if $1 is\
    \ divisible by $3 and if so return $2\n    if (( $1 % $3 == 0 )); then\n     \
    \   echo $2\n    else\n        echo $1\n    fi", "if [[ \"$1\" -ge 2 ]] && [[\
    \ \"$1\" -le 100 ]] && [[ \"$2\" -ge 2 ]] && [[ \"$2\" -le 100 ]] && [[ \"$3\"\
    \ -ge 2 ]] && [[ \"$3\" -le 100 ]]; then\n    n=$3\n    x=$1\n    y=$2\n    is_prime\
    \ $n\n    if [[ $? -eq 0 ]]; then\n        echo $x\n    else\n        echo $y\n\
    \    fi\nelse\n    echo \"x must be between 2 and 100\"\n    echo \"y must be\
    \ between 2 and 100\"\n    echo \"n must be between 2 and 100\"\nfi", "\t# Copy\
    \ the arguments and assign to named variables for convenience\n\tx=$1\n\ty=$2\n\
    \tn=$3\n\t\n\t# Write a function to check if a number is prime\n\tis_prime() {\n\
    \t\t# If the number is less than 2, it's not prime\n\t\tif [ $1 -lt 2 ]; then\n\
    \t\t\treturn 1\n\t\tfi\n\t\t\n\t\t# If the number is greater than 2, try to divide\
    \ it by every number\n\t\t# between 2 and the number. If any of those divisions\
    \ are evenly\n\t\t# divisible, then the number is not prime\n\t\tfor divisor in\
    \ $(seq 2 $1); do\n\t\t\tif [ $((n % divisor)) -eq 0 ]; then\n\t\t\t\treturn 1\n\
    \t\t\tfi\n\t\tdone\n\t\t\n\t\t# If we did not find a divisor, then the number\
    \ is prime\n\t\treturn 0\n\t}\n\t\n\tis_prime $n\n\tif [ $? -eq 0 ]; then\n\t\t\
    echo $x\n\telse\n\t\techo $y\n\tfi"]
stop_tokens:
- "\n}"
