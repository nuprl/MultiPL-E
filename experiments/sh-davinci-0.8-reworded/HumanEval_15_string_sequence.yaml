name: HumanEval_15_string_sequence
language: sh
prompt: "#!/bin/bash\n# Return a string containing space-delimited numbers starting\
  \ from 0 upto n inclusive.\n# >>> $(string_sequence \"0\")\n# \"0\"\n# >>> $(string_sequence\
  \ \"5\")\n# \"0 1 2 3 4 5\"\n#\n# $1 is an integer\nstring_sequence() {\n"
tests: "}\n\ncandidate() {\n    string_sequence \"$@\"\n}\n\nset -e\nrun_test() {\n\
  \    [[ $(candidate \"0\") = \"0\" ]]\n    [[ $(candidate \"3\") = \"0 1 2 3\" ]]\n\
  \    [[ $(candidate \"10\") = \"0 1 2 3 4 5 6 7 8 9 10\" ]]\n}\n\nrun_test"
completions: ["    for i in $(seq 0 \"$1\"); do\n        printf \"%s\" \"$i \"\n \
    \   done", "  local -i n\n  n=$1\n  echo $(eval echo {0..$n})", "    local __resultvar=$2\n\
    \    local result=\"\"\n    for i in $(seq 0 $1); do\n        result=\"$result\
    \ $i\"\n    done\n    if [[ \"$__resultvar\" ]]; then\n        eval $__resultvar=\"\
    '$result'\"\n    else\n        echo \"$result\"\n    fi", "    local n=$1\n  \
    \  local i\n    echo -n \"\"\n    for ((i=0; i<=$n; i++)); do\n        if [[ $i\
    \ -ne 0 ]]; then\n            echo -n \" \"\n        fi\n        echo -n $i\n\
    \    done", "  local i\n  echo -n \"0\"\n  for ((i=1; i<=$1; i++)); do\n    echo\
    \ -n \" $i\"\n  done", "    local STR=\"\"\n    for i in $(seq 0 $1); do\n   \
    \     STR=\"$STR $i\"\n    done\n    echo $STR", "    local -i n=$1\n    local\
    \ -i i=0\n    local sequence=()\n    while (( i <= n )); do\n        sequence+=($i)\n\
    \        (( i++ ))\n    done\n    echo ${sequence[@]}", "  if [ \"$1\" -eq \"\
    -1\" ]; then return; fi\n  seq 0 $1", "    # Get number of digits in input number.\n\
    \    local digits=$(string_length \"$1\")\n    local output=\"\"\n    local i=0\n\
    \    while [ $i -lt $1 ]; do\n        # Create a number with the correct number\
    \ of digits.\n        local number=$(string_format \"%0${digits}d\" $i)\n    \
    \    if [ $i -eq 0 ]; then\n            output=\"$number\"\n        else\n   \
    \         output=\"$output $number\"\n        fi\n        let i=i+1\n    done\n\
    \    echo \"$output\"", "    number=$1\n    while [ \"$number\" -ge 0 ]; do\n\
    \        echo -n \"$number \"\n        number=$(( number - 1 ))\n    done", " \
    \   local i\n    for ((i=0; i<=$1; i++)); do\n        echo -n \"$i \"\n    done",
  '    printf "%s\n" {0..$1}', "  local i seq=''\n\n  for ((i=0; i<=$1; i++)); do\n\
    \    seq=\"$seq $i\"\n  done\n\n  echo $seq", "    local SEQ_LENGTH=$1\n    local\
    \ SEQ_RETURN=\"\"\n    local i=0\n    while [ $i -le $SEQ_LENGTH ]; do\n     \
    \   SEQ_RETURN=\"$SEQ_RETURN $i\"\n        i=$((i+1))\n    done\n    echo $SEQ_RETURN",
  "    str=$(seq \"$1\")\n    echo \"${str// / }\"", "    echo $1 | awk '{for(i=0;i<=$1;i++)print\
    \ i}'", "  local n=\"$1\"\n  local result=\n  for i in $(seq 0 \"$n\"); do\n \
    \   result=\"$result $i\"\n  done\n  echo \"$result\"", "    # Assume $1 is a\
    \ numeric string.\n    # Iterating over $1 without this would cause expansion\
    \ of character\n    # ranges like \"2\".\n    #\n    # seq(1) has a -w flag, but\
    \ busybox (on CoreOS) doesn't support it.\n    seq -s' ' 0 \"$1\"", "    local\
    \ n=$1\n    seq 0 $n", "  for i in $(seq 0 \"$1\"); do\n    echo -n \"$i \"\n\
    \  done", "    if [ \"$#\" -ne 1 ]; then\n        echo \"Usage: ${FUNCNAME[0]}\
    \ <integer>\"\n        return 1\n    fi\n    local _n=$1\n    local _return=\"\
    \"\n    while [ $_n -ge 0 ]; do\n        _return=\"$_return $_n\"\n        _n=$((_n-1))\n\
    \    done\n    echo $_return", "  local i\n  for ((i=0; i<=$1; i++)); do\n   \
    \ printf \"%s \" \"$i\"\n  done", "    local n=\"$1\"\n    local i\n    local\
    \ result=\"\"\n    for ((i=0; i<=n; i++)); do\n        result=\"$result $i\"\n\
    \    done\n    echo \"$result\"", "  local n=$1\n\n  if [[ $n -ge 0 ]]; then\n\
    \    echo $(seq -s ' ' 0 $n)\n  else\n    echo $n\n  fi", "  n=$1\n  _str=\"\"\
    \n  for (( i=0; i<=n; i++ )); do\n    _str+=\"$i \"\n  done\n  echo $_str", " \
    \   local n=$1\n    local output=\"\"\n    for i in $(seq 0 $n); do\n        output+=\"\
    $i \"\n    done\n    echo \"$output\"", '    echo $(seq 0 $1)', '    for ((i=0;
    i<=$1; i++)); do echo $i; done', "    local n=\"$1\"\n    local result=\"\"\n\
    \    for ((i=0; i<=n; i++)); do\n        result=\"$result $i\"\n    done\n   \
    \ echo \"$result\"", "    for ((i=0; i<=$1; i++)); do\n        echo -n \"$i \"\
    \n    done", "    local sequence=\"$(seq 0 \"$1\")\"\n    echo \"$sequence\"",
  "    # Truncate $1 to an integer.\n    # https://stackoverflow.com/a/376006/5248602\n\
    \    local n=$(( 10#$1 ))\n    local ret=\"\"\n    for i in $(seq 0 $n); do\n\
    \        ret=\"$ret $i\"\n    done\n    echo \"$ret\"", "    seq --format='%g\
    \ ' 0 \"$1\"", "  local n=$1\n  local res=\"\"\n  for i in $(seq 0 $n); do\n \
    \   res=\"$res $i\"\n  done\n  echo \"$res\"", "    local n=$1\n    local num\n\
    \    local -a nums\n    while (( n >= 0 )); do\n        nums+=($n)\n        ((\
    \ n-- ))\n    done\n    echo ${nums[@]}", "  local int=\"$1\"\n  local i=0\n \
    \ local out=\"\"\n  if [[ \"$int\" == 0 ]]; then\n    echo \"0\"\n  else\n   \
    \ while [ $i -le $int ]; do\n      out+=\"$i \"\n      i=$((i+1))\n    done\n\
    \    echo \"$out\"\n  fi", "    local string=\"\"\n    for ((i=0; i<=$1; i++));\
    \ do\n        string=\"$string $i\"\n    done\n    echo $string", "    if [[ \"\
    $1\" == \"0\" ]]; then\n        echo \"$1\"\n    else\n        number_sequence\
    \ \"$1\" | paste -sd \" \" -\n    fi", '    echo $(seq 0 $1)', "    local N\n\
    \    N=$1\n    echo $(seq -s \" \" 0 \"$N\")", "    local result=\"\"\n    for\
    \ i in $(seq 0 $1); do\n        result=\"$result $i\"\n    done\n    echo $result",
  "    local -i n\n    n=$1\n    # Make a space-delimited string of numbers starting\
    \ from 0 upto n inclusive.\n    seq -s' ' 0 $n", '  echo $(seq -s " " 0 $1)',
  "    local result=''\n    for i in $(seq 0 \"$1\"); do\n        result=\"$result\
    \ $i\"\n    done\n    echo \"$result\"", "    local i\n    for ((i=0; i<=$1; i++));\
    \ do\n        echo -n \"$i \"\n    done", "    local last_arg=$1\n    local i\n\
    \    local sequence\n    for ((i=0; i<=last_arg; i++)); do\n        sequence=\"\
    $sequence $i\"\n    done\n    echo \"$sequence\"", "    integer_is_positive \"\
    $1\" || return 1\n    local i=$1\n    if [ $i -eq 0 ]; then\n        echo 0\n\
    \    else\n        local nums\n        while [ $i -gt 0 ]; do\n            nums=\"\
    $i $nums\"\n            i=$((i-1))\n        done\n        echo 0 $nums\n    fi",
  "  local n=\"$1\"\n  local iterate_jsh_to_n=\"$2\"\n  [ -z \"$iterate_jsh_to_n\"\
    \ ] &&\n    iterate_jsh_to_n=\"$(jshlib_dir)/iterate/jsh-to-n\"\n  $iterate_jsh_to_n\
    \ --whitespace \"$n\"", "  local n=\"$1\"\n  local res=\"\"\n  for i in $(seq\
    \ 0 \"$n\"); do\n    res=\"$res $i\"\n  done\n  echo \"$res\"", "    local -r\
    \ n=$1\n    local -r max=10\n    local -r str_leading=\" \"\n    local -r str_trailing=\"\
    \\n\"\n    [ ${#n} -gt $max ] && err \"Integer $n is too large.\" && return 1\n\
    \    local -r pad_zeros=$(( $max - ${#n} ))\n    local -r padding=$(str_repeat\
    \ \"$str_leading\" \"$pad_zeros\")\n    echo -en \"$padding\"\n    seq 0 $n |\
    \ xargs echo", "  if is_empty \"$1\"; then\n    echo ''\n  else\n    echo $(seq\
    \ -s ' ' 0 $1)\n  fi", "    [ $# -eq 1 ] || exit 1\n    [ $1 -ge 0 ] || exit 1\n\
    \    echo \"$(seq -s ' ' 0 $1)\"", "    local i=\"0\"\n    local n=\"$1\"\n  \
    \  local nums=\"\"\n    if [[ \"$n\" == \"0\" ]]; then\n        echo \"$n\"\n\
    \    else\n        while [[ \"$i\" -le \"$n\" ]]; do\n            nums=\"$nums\
    \ $i\"\n            i=$((i+1))\n        done\n        echo \"$nums\"\n    fi",
  "  local n=\"$1\"\n  local i\n  local string\n  for ((i=0; i<=n; i++)); do\n   \
    \ string=\"$string$i \"\n  done\n  echo \"$string\"", "    local -r n=\"$1\"\n\
    \    seq -s \" \" 0 \"$n\"", '    echo $(seq 0 $1)', "  local start_from=\"${1:-0}\"\
    \n  local end_at=\"${2:-$1}\"\n  local start_from_as_int=\"$(int \"$start_from\"\
    )\"\n  local end_at_as_int=\"$(int \"$end_at\")\"\n  local range=$(seq \"$start_from_as_int\"\
    \ \"$end_at_as_int\")\n  local result=\"\"\n  for i in $range; do\n    result=\"\
    $result $i\"\n  done\n  echo \"$result\"", "    local n=$1\n    local sequence\n\
    \    for((i=0; i<=n; i++)); do\n        if [ -z \"$sequence\" ]; then\n      \
    \      sequence=\"$i\"\n        else\n            sequence=\"$sequence $i\"\n\
    \        fi\n    done\n    echo \"$sequence\"", '    for i in $(seq 0 $1); do
    echo -n "$i "; done', "  if [ \"$#\" -ne 1 ]; then\n    printf \"Illegal number\
    \ of parameters\\n\"\n    exit 1\n  fi\n  local n=\"$1\"\n  local -i i=0\n  while\
    \ [ \"$i\" -le \"$n\" ]; do\n    printf \"%d\" \"$i\"\n    if [ \"$i\" -lt \"\
    $n\" ]; then\n      printf \" \"\n    fi\n    i=$((i+1))\n  done", "    for ((i=0;\
    \ i<=$1; i++)); do\n        echo -n \"$i \"\n    done", '    echo $(seq 0 $1)',
  "    local number=\"$1\"\n    local i=0\n    while [ $i -le $number ]; do\n    \
    \    echo -n \"$i \"\n        i=$(($i + 1))\n    done", "    [[ -z \"$1\" ]] &&\
    \ exit 1 || local length=$1\n\n    local -a result\n    for ((i=0; i<=length;\
    \ i++)); do\n        result+=($i)\n    done\n    echo \"${result[@]}\"", "   \
    \ [ \"$#\" -eq 1 ] || yush_die \"string_sequence: Usage: $(basename \"$0\") <integer>\"\
    \n    local i\n    if [ \"$1\" -lt 0 ]; then\n        for ((i=\"$1\"; i<=0; i++));\
    \ do\n            printf \"%s \" \"$i\"\n        done\n    else\n        for ((i=0;\
    \ i<=\"$1\"; i++)); do\n            printf \"%s \" \"$i\"\n        done\n    fi",
  "  local -i n=$1\n\n  for ((i=0; i<=n; i++)); do\n    echo -n \"$i \"\n  done",
  "    local n=$1\n    local -a arr=()\n    for i in $(seq 0 $n); do\n        arr[$i]=$i\n\
    \    done\n    echo \"${arr[@]}\"", "    local n=$1 i\n    for ((i=0; i<=n; i++));\
    \ do\n        printf \"%s \" \"$i\"\n    done", "    [[ \"$1\" =~ ^[0-9]+$ ]]\
    \ || return 1\n    echo $(seq -s \" \" 0 $1)", "    local n=\"$1\"\n    local\
    \ output=\n    for (( i=0; i<=$n; i++ )); do\n        output+=\"$i \"\n    done\n\
    \    echo \"$output\"", "    local -i n=$1\n    local -i i\n    local s\n\n  \
    \  for ((i=0; i<=n; i++)); do\n        s=\"$s $i\"\n    done\n\n    echo \"$s\"",
  "  local i n=$1\n  for ((i=0; i<=n; i++)); do echo -n \"$i \"; done", "    local\
    \ numbers=()\n    for (( i=0; i<=\"$1\"; i++ )); do\n        numbers+=(\"$i\"\
    )\n    done\n    echo \"${numbers[@]}\"", "    local n=\"$1\"\n    seq -s ' '\
    \ 0 \"$n\"", '    echo $(seq 0 $1)', "    local n=$1\n    local i=0\n    while\
    \ [[ \"$i\" -le \"$n\" ]]; do\n        echo -n \"$i \"\n        ((i++))\n    done",
  "    local range=\"\"\n    for ((i=0; i<=$1; i++)); do\n        range+=\" $i\"\n\
    \    done\n    echo $range", "    local result=\"\"\n    for i in $(seq 0 $1);\
    \ do\n        result=\"$result $i\"\n    done\n    echo $result", "    local i\n\
    \    local res\n    local n=${1}\n    for ((i=0; i<=n; i++)); do\n        res+=\"\
    $i \"\n    done\n    echo \"$res\"", "    local i=0\n    local n=$1\n    local\
    \ s=\"\"\n    while (( i <= n )); do\n        s=\"$s $i\"\n        (( i++ ))\n\
    \    done\n    echo $s", "    if (( $1 < 0 )); then\n        echo \"ERROR: The\
    \ parameter passed to string_sequence is not a positive integer: $1\"\n      \
    \  exit 1\n    fi\n    echo $(seq -s \" \" 0 $1)", "    local n=$1\n    if [ $n\
    \ -eq 0 ]; then\n        echo 0\n    else\n        echo $(eval echo {0..$n})\n\
    \    fi", "    declare n=\"$1\"\n    local i=0\n    while (( i <= n )); do\n \
    \       echo -n \"$i \"\n        (( i++ ))\n    done", "    local n; n=\"$1\"\n\
    \    if [ $n -eq 0 ]; then\n        echo \"0\"\n    else\n        string_sequence\
    \ $(($n - 1))\n    fi", '    echo $(seq 0 "$1")', "    local integer=$1\n    local\
    \ i=0\n    while [ $i -le $integer ]; do\n        echo -n \"$i \"\n        ((\
    \ i++ ))\n    done", "    local -i n=${1?param missing - integer number}\n   \
    \ if ((n<0)); then\n        echo $@\n    else\n        for ((i=0; i<=n; i++));\
    \ do\n            printf \"%d%s\" $i $'\\n'\n        done\n    fi", "    local\
    \ number=$1\n    seq -s \" \" 0 $number", "  if [ \"$#\" -ne 1 ]; then\n    echo\
    \ \"ERROR: string_sequence() called with $# arguments. Expecting 1.\"\n    return\
    \ 1\n  fi\n  if ! integer_is_positive \"$1\"; then\n    echo \"ERROR: string_sequence()\
    \ called with non-positive value.\"\n    return 1\n  fi\n  local n=\"$1\"\n  local\
    \ i=0\n  local seq=\"\"\n  while [ \"$i\" -le \"$n\" ]; do\n    seq=\"$seq $i\"\
    \n    i=$((i+1))\n  done\n  echo \"$seq\"", "    test $# -eq 1 || script_exit\
    \ \"string_sequence requires exactly 1 argument, $# provided\"\n    integer_is_valid\
    \ \"$1\" || script_exit \"first argument to string_sequence must be an integer\"\
    \n    local -i n=$1\n    local -i i\n    for ((i=0; i<=n; i++)); do\n        if\
    \ [ $i -ne 0 ]; then\n            echo -n \" \"\n        fi\n        echo -n \"\
    $i\"\n    done", "    local len=$1\n    local str=\"\"\n    local -i i\n    for\
    \ i in $(seq 0 \"$len\"); do\n        str+=\"$i \"\n    done\n    echo \"$str\"",
  '    echo $(eval echo {0..$1})', "    if [[ -z \"$1\" ]]; then\n        echo \"\
    string_sequence requires an integer argument\" >&2\n        return 1\n    fi\n\
    \    if [[ $1 -lt 0 ]]; then\n        echo \"string_sequence requires a positive\
    \ integer argument\" >&2\n        return 1\n    fi\n    result=\"\"\n    for i\
    \ in $(seq 0 $1); do\n        result=\"$result $i\"\n    done\n    echo $result",
  "    local seq=\"\"\n    for((i=0; i<=$1; i++)); do\n        seq+=\"$i \"\n    done\n\
    \    echo \"$seq\"", '    echo $(eval echo "{0.."$1"}")', "    local index=\"\
    0\"\n    local result=\"\"\n    while [[ \"$index\" -le \"$1\" ]]; do\n      \
    \  result=\"$result $index\"\n        index=$((index + 1))\n    done\n    echo\
    \ \"$result\"", "    if (($1 >= 0)); then\n        seq -s \" \" 0 $1\n    else\n\
    \        echo \"string_sequence() requires argument to be >= 0\" >&2\n       \
    \ return 1\n    fi", "    local i=0\n    local n=$1\n    local str=\"\"\n    while\
    \ [ $i -le $n ]; do\n        str=\"$str $i\"\n        i=$((i+1))\n    done\n \
    \   echo \"$str\"", "    local -i num=$1\n\n    for i in $(seq 0 $num); do\n \
    \       echo -n \"$i \"\n    done", "    local seq=\"\"\n    local i=$1\n    while\
    \ [ $i -ge 0 ]; do\n        seq=\"$seq $i\"\n        i=$((i-1))\n    done\n  \
    \  echo \"$seq\"", "  local n=$1\n  local s=\"\"\n  local x\n  for ((x=0; x<=$n;\
    \ x++)); do\n    if [[ \"$s\" != \"\" ]]; then\n      s=\"$s \"\n    fi\n    s=\"\
    $s$x\"\n  done\n  echo \"$s\"", "    if ! is_int \"$1\"; then\n        warn \"\
    string_sequence: param '$1' is not an integer\"\n        exit 1\n    fi\n    seq\
    \ -s \" \" 0 \"$1\"", "  seq -s' ' 0 $1", "    local n=$1\n    local i=0\n   \
    \ while [[ i -le n ]]; do\n        echo -n \"$i \"\n        ((i++))\n    done",
  "  if [ $# -ne 1 ]; then\n    echo_err \"Wrong number of arguments for $FUNCNAME()\"\
    \n    return 1\n  fi\n  local ret\n  for ((i=0; i<=$1; i++)); do\n    if [ -z\
    \ \"$ret\" ]; then\n      ret=\"$i\"\n    else\n      ret=\"$ret $i\"\n    fi\n\
    \  done\n  echo $ret", "    python3 -c \"print(' '.join([str(i) for i in range($1\
    \ + 1)]))\"", "  local n=$1\n  seq -s ' ' 0 $n", "    local -n __sequence=$1\n\
    \    local n=$2\n    local n2=$(( n + 1 ))\n    __sequence=\"\"\n    for i in\
    \ $(seq 0 $n); do\n        __sequence+=\"$i \"\n    done", "  local I=0\n  local\
    \ result=\"\"\n  while [[ $I -le $1 ]]; do\n    if [[ $I != 0 ]]; then\n     \
    \ result=\"$result $I\"\n    else\n      result=\"$I\"\n    fi\n    I=$((I+1))\n\
    \  done\n  echo \"$result\"", "    local n=$1\n    if [ $n -lt 0 ]; then\n   \
    \     echo \"Expected n >= 0\" >&2\n        exit 1\n    fi\n    local i=0\n  \
    \  while [ $i -le $n ]; do\n        echo -n \"$i \"\n        i=$(($i + 1))\n \
    \   done", "    # make sure $1 is an integer\n    if [[ $1 =~ ^[0-9]+$ ]]; then\n\
    \        python -c \"print(' '.join(map(str, range($1+1))))\"\n    else\n    \
    \    echo \"Argument to function $FUNCNAME must be an integer\" >&2\n        exit\
    \ 1\n    fi", "  local n=$1\n  local n=${n:-0}\n  seq 0 $n", "    local start=0\n\
    \    local end=$1\n    local sequence=\"\"\n    for number in $(seq \"${start}\"\
    \ \"${end}\"); do\n        sequence=\"${sequence} ${number}\"\n    done\n    echo\
    \ \"${sequence}\"", "  x=0\n  while [ $x -le $1 ]; do\n    echo -n \"$x \"\n \
    \   x=$((x+1))\n  done", "    # tr: Translate characters\n    # -s: Squeeze repetitions\
    \ of the set1 characters into a single character from set2\n    echo $(seq 0 $1\
    \ | tr '\\n' ' ' | tr -s ' ')", "    local n=\"$1\"\n    local i\n    for ((i=0;\
    \ i<=n; i++)); do\n        if [[ $i -ne 0 ]]; then\n            echo -n \" \"\n\
    \        fi\n        echo -n \"$i\"\n    done", "    if [[ $1 -eq 0 ]]; then\n\
    \        echo \"0\"\n    else\n        echo \"$(seq 0 1 $1)\"\n    fi", '    echo
    $(seq 0 "$1")', '  seq -s " " 0 $1', "    local -i n=$1\n    local result=\"\"\
    \n    local -i i=0\n    while [ $i -le $n ]; do\n        result=\"$result $i\"\
    \n        i+=1\n    done\n    echo \"$result\"", "    local n=$1\n    echo $(eval\
    \ echo {0..$n})", "    local sequence=\"\"\n    for ((i=0; i<=$1; i++)); do\n\
    \        sequence=\"$sequence $i\"\n    done\n    echo \"$sequence\"", "    local\
    \ i\n    for ((i=0; i<=$1; i++)); do\n        echo -n \"$i \"\n    done", '    seq
    0 $1', "    local str=\"\"\n    for i in $(seq 0 $1); do\n        str+=\"$i \"\
    \n    done\n    echo \"$str\"", "  local n=$1\n  while [ \"$n\" -ge 0 ]; do\n\
    \    echo -n \"$n \"\n    n=$((n-1))\n  done", '    seq $1', "    local n=$1\n\
    \    local s=\"\"\n    for ((i=0; i<=n; i++)); do\n        s=\"$s $i\"\n    done\n\
    \    echo $s", '    eval "echo {0..$1}"', '    seq --format="%g " 0 $1', "   \
    \ local t=\"\"\n    for (( i=0; i<=$1; i++ )); do\n        t=\"$t $i\"\n    done\n\
    \    echo $t", "    local n=\"$1\"\n    local l=\"\"\n    for i in $(seq 0 \"\
    $n\"); do\n        l=\"$l $i\"\n    done\n    echo \"$l\"", "    if is_number\
    \ \"$1\"; then\n        seq -s \" \" 0 \"$1\"\n    else\n        echo -n \"$1\"\
    \n    fi", "  _string_sequence=\"\"\n  for _i in $(seq 0 $1); do\n    _string_sequence=\"\
    ${_string_sequence} ${_i}\"\n  done\n  echo \"${_string_sequence}\"", "    local\
    \ n=$1\n    seq -s ' ' 0 \"$n\"", "    local n=$1\n    local i=0\n    local sequence=\"\
    \"\n    while [ $i -le $n ]; do\n        sequence=\"$sequence $i\"\n        i=$((i+1))\n\
    \    done\n    echo $sequence", "    # XXX: grep -vE not supported on some systems.\n\
    \    # See: http://stackoverflow.com/questions/19547898/grep-v-e-not-supported-on-some-systems\n\
    \    # $1 + 1 because it doesn't include $1.\n    seq -s \" \" 0 $(( $1 + 1 ))\
    \ | tr -d \"\\n\"", "    result=\"\"\n    for ((i=0; i<=$1; i++)); do\n      \
    \  result=\"$result $i\"\n    done\n    printf \"%s\" \"$result\"", "  if [ \"\
    $1\" -eq \"0\" ]; then\n    echo \"0\"\n  else\n    echo $(seq 0 \"$1\")\n  fi",
  "    local n=\"$1\"\n    local range=\"\"\n    for i in $(seq 0 \"$n\"); do\n  \
    \      range=\"$range $i\"\n    done\n    echo \"$range\"", "    local n=\"$1\"\
    \n\n    if [[ \"${n}\" == \"0\" ]]; then\n        echo \"${n}\"\n    else\n  \
    \      seq 0 \"${n}\"\n    fi", '    echo $(seq 0 $1)', "    local i;\n    for\
    \ ((i=0; i<=$1; i++)); do\n        echo -n \"$i \";\n    done", "    n=\"$1\"\n\
    \    seq -s \" \" -f \"0 %g\" \"$n\"", "  # The range is inclusive.\n  local n=\"\
    $1\"\n  local i\n  for ((i=0; i<=n; i++)); do\n    printf \"%s \" \"$i\"\n  done",
  "    local i=\"$1\"\n    local seq=\"0\"\n    for (( i=1; i<=\"$1\"; i++ ))\n  \
    \  do\n\t\tif [ $i -gt 0 ]; then\n\t\t\tseq=\"$seq $i\"\n\t\tfi\n    done\n  \
    \  echo \"$seq\"", "    local -i i\n    for ((i=0; i<=$1; i++)); do\n        echo\
    \ -n \"$i \"\n    done", "    local size=$1; shift\n    local res=\"\"\n    for\
    \ i in $(seq 0 $size); do\n        res=\"$res $i\"\n    done\n    echo \"$res\"",
  "    # $1 is number\n    # return space-delimited string\n    for (( i=0; i<=$1;\
    \ i++ )); do\n        echo -n \"$i \"\n    done", "    # The point of this function\
    \ is to use bash builtins to do the work of seq\n    # It is much more complex\
    \ than it needs to be to handle the case where n is negative\n    #\n    # convert\
    \ n to an absolute value\n    local n=\"${1#-}\"\n    # create an array of numbers\
    \ from 0 to n\n    local vals=($(eval echo {0..$n}))\n    # if n was negative,\
    \ we need to reverse the array\n    if [ \"$1\" -lt 0 ]; then\n        local val=\n\
    \        for val in \"${vals[@]}\"; do\n            if [ \"$val\" -ne 0 ]; then\n\
    \                echo -n \"$val \"\n            fi\n        done | tac\n    else\n\
    \        echo \"${vals[@]}\"\n    fi", "    local i\n    # $1 is an integer\n\
    \    for ((i=0; i<=$1; i++)); do\n        printf \"$i \"\n    done", "  local\
    \ -i seq_max\n  seq_max=$1\n  for (( i=0; i<=seq_max; i++ )); do\n    printf \"\
    %s\" \"$i\"\n    if [[ $i -lt $seq_max ]]; then\n      printf \" \"\n    fi\n\
    \  done", "    declare -a a\n    a=( $(seq 0 \"$1\") )\n    echo \"${a[@]}\"",
  '  seq -s " " 0 "$1"', "  local range=$(seq 0 \"$1\")\n  echo \"$range\"", "   \
    \ local -i n=\"$1\"\n    local -i i=0\n    while ((i<=n)); do\n        echo -n\
    \ \"$i \"\n        ((i++))\n    done", "    local i=\"0\"\n    while (( i <= $1\
    \ )); do\n        printf \"%s \" \"$i\"\n        (( i++ ))\n    done", "    local\
    \ numbers\n    for (( i=0; i<=$1; i++ )); do\n        numbers=\"$numbers $i\"\n\
    \    done\n    echo $numbers", "    local n=$1\n    local result=\"\"\n    for\
    \ (( i=0; i<=n; i++ )); do\n        result+=\" $i\"\n    done\n    echo $result",
  "    # https://unix.stackexchange.com/a/143935\n    # https://stackoverflow.com/a/1390541\n\
    \    seq -s \" \" 0 \"$1\"", "    local i=0\n    local n=\"$1\"\n    local str=''\n\
    \    while [ $i -le $n ]; do\n        str=\"$str $i\"\n        i=$((i+1))\n  \
    \  done\n    echo \"$str\"", "    local -i n=$1\n    local -i i=0\n    local -a\
    \ sequence\n    until [ $i -gt $n ]; do\n        sequence+=( $i )\n        ((i++))\n\
    \    done\n    echo \"${sequence[@]}\"", "    local count=0\n    while [ $count\
    \ -le $1 ]; do\n        printf \"$count \"\n        count=$((count + 1))\n   \
    \ done", "    local -i n\n    n=$1\n    local -i i\n    for ((i=0; i<=n; i++));\
    \ do\n        echo -n \"$i \"\n    done", "    local n=$1\n    local i\n    for\
    \ ((i=0; i<=$n; i++)); do\n        echo -n \"$i \"\n    done", "  declare -i n=$1\n\
    \  for ((i=0; i<=n; i++)); do\n    printf '%d ' $i\n  done", "    local n=\"$1\"\
    \n    local i\n    for ((i=0; i<=n; i++)); do\n        printf '%s ' \"$i\"\n \
    \   done", "    local i\n    local n=\"$1\"\n    local args=\"\"\n    for ((i=0;\
    \ i<=n; i++)); do\n        args=\"$args $i\"\n    done\n    printf \"%s\" \"$args\"",
  "  local n=$1\n  if [ $n -ge 0 ]; then\n    echo $(eval echo {0..$n})\n  else\n\
    \    echo \"\"\n  fi", "    local -i n=$1\n    local sequence\n    for ((i=0;\
    \ i<=n; i++)); do\n        sequence+=\"$i \"\n    done\n    echo $sequence", " \
    \   if [ $# -ne 1 ]; then\n        echo \"Wrong number of arguments!\" >&2\n \
    \       echo \"Usage: string_sequence <integer>\" >&2\n        return 1\n    fi\n\
    \n    if ! is_int \"$1\"; then\n        echo \"$1 is not an integer!\" >&2\n \
    \       return 1\n    fi\n\n    local -i i=0\n    local -i n=$1\n    local string=''\n\
    \n    for (( i=0; i<=n; i++ )); do\n        string+=\"$i \"\n    done\n\n    echo\
    \ \"$string\"", "    i=$1\n    a=\"\"\n    while [ $i -ge 0 ]; do\n        a=\"\
    $a $i\"\n        let i-=1\n    done\n    echo \"$a\"", "    local sequence=\"\"\
    \n    for index in $(seq 0 \"$1\"); do\n        sequence=\"$sequence $index\"\n\
    \    done\n    echo \"$sequence\"", "    # Integer must be greater than or equal\
    \ to 0.\n    integer=$1\n    if [ $integer -lt 0 ]; then\n        echo \"Error:\
    \ integer cannot be less than 0.\"\n        exit 1\n    fi\n\n    # n can be 0\
    \ only.\n    if [ $integer -eq 0 ]; then\n        echo \"0\"\n        return\n\
    \    fi\n\n    # Generate the string of space-delimited numbers from 0 upto n\
    \ inclusive.\n    local index=0\n    string=\"$index\"\n    while [ $index -lt\
    \ $integer ]; do\n        index=$((index + 1))\n        string=\"$string $index\"\
    \n    done\n    echo \"$string\"", '    echo $(seq 0 "$1")', "    declare -i n=\"\
    $1\"\n    for i in $(seq 0 $n); do\n        echo -n \"$i \"\n    done", "  if\
    \ [ $# -eq 0 ]; then\n    echo 'string_sequence: missing operand' >&2\n    return\
    \ 1\n  fi\n  if [[ $1 =~ ^[0-9]+$ ]]; then\n    local n=$1\n    local s\n    for((i=0;i<=n;i++));\
    \ do\n      s=\"$s$i \"\n    done\n    echo \"$s\"\n  else\n    echo \"string_sequence:\
    \ invalid number '$1'\" >&2\n    return 1\n  fi", "  local i n result\n  n=\"\
    $1\"\n  result=\"\"\n  for ((i=0; i<=n; i++)); do\n    result=\"$result $i\"\n\
    \  done\n  echo \"$result\"", "  local num\n  for ((num=0; num<=$1; num++)); do\n\
    \    printf \"$num \"\n  done", "  local result=\"\"\n  for ((i=0; i<=$1; i++));\
    \ do\n    result=\"$result $i\"\n  done\n  echo \"$result\"", "    if [ \"$1\"\
    \ == \"\" ]; then\n        echo \"string_sequence requires an integer\"\n    \
    \    exit 1\n    fi\n    local n=$1\n    local i=0\n    while [ $i -le $n ]; do\n\
    \        echo -n \"$i \"\n        let i=$i+1\n    done", "    local n=${1:?}\n\
    \    local i=0\n    local str=\n    while [[ $i -le $n ]]; do\n        str=\"\
    $str $i\"\n        i=$((i+1))\n    done\n    echo $str", "  local i\n  local IFS\n\
    \  local size\n  size=$1\n  for ((i=0; i<=size; i++)); do\n    echo -n \"$i \"\
    \n  done", "  local -i n\n  n=$1\n  local i\n  for ((i=0; i<=$n; i++)); do\n \
    \   echo -n \"$i \"\n  done", "  local n=\"$1\"\n  local i=0\n  local s=''\n \
    \ if [ $n -gt -1 ]; then\n    while [ $i -le $n ]; do\n      s=\"$s $i\"\n   \
    \   i=$((i+1))\n    done\n  fi\n  echo \"$s\"", "  seq --format='%g ' 0 $1", " \
    \   local n=$1\n    local string=\"\"\n    for i in $(seq 0 $n); do\n        string=\"\
    $string $i\"\n    done\n    echo $string", "  local N=$1\n  local i\n  for ((i=0;\
    \ i<=N; i++)); do\n    echo -n \"$i \"\n  done", "  local i\n  local seq=\"\"\n\
    \  for ((i=0; i<=\"$1\"; i++)); do\n    seq=\"$seq $i\"\n  done\n  echo $seq",
  "    local output=\"\"\n    for (( i=0; i<=$1; i++ )); do\n        output+=\"$i\
    \ \"\n    done\n    echo $output", "    # $i = counter\n    for ((i=0; i<=$1;\
    \ i++)); do\n        printf \"%s\" \"$i \"\n    done", "  if [[ -z \"$1\" ]];\
    \ then\n    printf \"ERROR: string_sequence requires an integer argument.\\n\"\
    \n    exit 1\n  fi\n  for i in $(seq 0 \"$1\"); do printf \"%s\" \"$i \"; done",
  "    local string_sequence_SEQ=\n    for i in $(seq 0 $1); do\n        string_sequence_SEQ=\"\
    $string_sequence_SEQ $i\"\n    done\n    echo \"$string_sequence_SEQ\"", '    seq
    -s " " 0 "$1"', "    local n=$1\n    local -a seq\n    for ((i=0; i<=n; i++));\
    \ do\n        seq[$i]=$i\n    done\n    echo ${seq[@]}", "    test -z \"$1\" &&\
    \ echo \"Error: string_sequence() requires an integer argument\" && exit 1\n \
    \   local -i n=\"$1\"\n    local -i i=0\n    while (( i <= n )); do\n        if\
    \ (( i == 0 )); then\n            printf \"0\"\n        else\n            printf\
    \ \" $i\"\n        fi\n        i=i+1\n    done", "    local i\n\n    for ((i=0;\
    \ i<=${1}; i++)); do\n        echo -n \"${i} \"\n    done", "    if [[ \"$1\"\
    \ =~ ^[0-9]+$ ]]; then\n        local i\n        for ((i=0; i<=$1; i++)); do\n\
    \            echo -n \"$i \"\n        done\n    else\n        echo \"Error: string_sequence:\
    \ 1st argument must be an integer\" >&2\n        exit 1\n    fi", '    seq 0 $1',
  '    echo $(seq 0 "$1")']
stop_tokens:
- "\n}"
