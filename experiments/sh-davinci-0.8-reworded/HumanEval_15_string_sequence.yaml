name: HumanEval_15_string_sequence
language: sh
prompt: "#!/bin/bash\n# Return a string containing space-delimited numbers starting\
  \ from 0 upto n inclusive.\n# >>> $(string_sequence \"0\")\n# \"0\"\n# >>> $(string_sequence\
  \ \"5\")\n# \"0 1 2 3 4 5\"\n#\n# $1 is an integer\nstring_sequence() {\n"
tests: "}\n\ncandidate() {\n    string_sequence \"$@\"\n}\n\nset -e\nrun_test() {\n\
  \    [[ $(candidate \"0\") = \"0\" ]]\n    [[ $(candidate \"3\") = \"0 1 2 3\" ]]\n\
  \    [[ $(candidate \"10\") = \"0 1 2 3 4 5 6 7 8 9 10\" ]]\n}\n\nrun_test"
completions: ["    for i in $(seq 0 \"$1\"); do\n        printf \"%s\" \"$i \"\n \
    \   done", "  local -i n\n  n=$1\n  echo $(eval echo {0..$n})", "    local __resultvar=$2\n\
    \    local result=\"\"\n    for i in $(seq 0 $1); do\n        result=\"$result\
    \ $i\"\n    done\n    if [[ \"$__resultvar\" ]]; then\n        eval $__resultvar=\"\
    '$result'\"\n    else\n        echo \"$result\"\n    fi", "    local n=$1\n  \
    \  local i\n    echo -n \"\"\n    for ((i=0; i<=$n; i++)); do\n        if [[ $i\
    \ -ne 0 ]]; then\n            echo -n \" \"\n        fi\n        echo -n $i\n\
    \    done", "  local i\n  echo -n \"0\"\n  for ((i=1; i<=$1; i++)); do\n    echo\
    \ -n \" $i\"\n  done", "    local STR=\"\"\n    for i in $(seq 0 $1); do\n   \
    \     STR=\"$STR $i\"\n    done\n    echo $STR", "    local -i n=$1\n    local\
    \ -i i=0\n    local sequence=()\n    while (( i <= n )); do\n        sequence+=($i)\n\
    \        (( i++ ))\n    done\n    echo ${sequence[@]}", "  if [ \"$1\" -eq \"\
    -1\" ]; then return; fi\n  seq 0 $1", "    # Get number of digits in input number.\n\
    \    local digits=$(string_length \"$1\")\n    local output=\"\"\n    local i=0\n\
    \    while [ $i -lt $1 ]; do\n        # Create a number with the correct number\
    \ of digits.\n        local number=$(string_format \"%0${digits}d\" $i)\n    \
    \    if [ $i -eq 0 ]; then\n            output=\"$number\"\n        else\n   \
    \         output=\"$output $number\"\n        fi\n        let i=i+1\n    done\n\
    \    echo \"$output\"", "    number=$1\n    while [ \"$number\" -ge 0 ]; do\n\
    \        echo -n \"$number \"\n        number=$(( number - 1 ))\n    done", " \
    \   local i\n    for ((i=0; i<=$1; i++)); do\n        echo -n \"$i \"\n    done",
  '    printf "%s\n" {0..$1}', "  local i seq=''\n\n  for ((i=0; i<=$1; i++)); do\n\
    \    seq=\"$seq $i\"\n  done\n\n  echo $seq", "    local SEQ_LENGTH=$1\n    local\
    \ SEQ_RETURN=\"\"\n    local i=0\n    while [ $i -le $SEQ_LENGTH ]; do\n     \
    \   SEQ_RETURN=\"$SEQ_RETURN $i\"\n        i=$((i+1))\n    done\n    echo $SEQ_RETURN",
  "    str=$(seq \"$1\")\n    echo \"${str// / }\"", "    echo $1 | awk '{for(i=0;i<=$1;i++)print\
    \ i}'", "  local n=\"$1\"\n  local result=\n  for i in $(seq 0 \"$n\"); do\n \
    \   result=\"$result $i\"\n  done\n  echo \"$result\"", "    # Assume $1 is a\
    \ numeric string.\n    # Iterating over $1 without this would cause expansion\
    \ of character\n    # ranges like \"2\".\n    #\n    # seq(1) has a -w flag, but\
    \ busybox (on CoreOS) doesn't support it.\n    seq -s' ' 0 \"$1\"", "    local\
    \ n=$1\n    seq 0 $n", "  for i in $(seq 0 \"$1\"); do\n    echo -n \"$i \"\n\
    \  done"]
stop_tokens:
- "\n}"
