name: HumanEval_86_anti_shuffle
language: sh
prompt: "#!/bin/bash\n# Write a function that takes a string and returns an ordered\
  \ version of it.\n# Ordered version of string, is a string where all words (separated\
  \ by space)\n# are replaced by a new word where all the characters arranged in\n\
  # ascending order based on ascii value.\n# Note: You should keep the order of words\
  \ and blank spaces in the sentence.\n# For example:\n# >>> $(anti_shuffle \"Hi\"\
  )\n# \"Hi\"\n# >>> $(anti_shuffle \"hello\")\n# \"ehllo\"\n# >>> $(anti_shuffle\
  \ \"Hello World\\!\\!\\!\")\n# \"Hello \\!\\!\\!Wdlor\"\n#\n# $1 is a string\nanti_shuffle()\
  \ {\n"
tests: "}\n\ncandidate() {\n    anti_shuffle \"$@\"\n}\n\nset -e\nrun_test() {\n \
  \   [[ $(candidate \"Hi\") = \"Hi\" ]]\n    [[ $(candidate \"hello\") = \"ehllo\"\
  \ ]]\n    [[ $(candidate \"number\") = \"bemnru\" ]]\n    [[ $(candidate \"abcd\"\
  ) = \"abcd\" ]]\n    [[ $(candidate \"Hello World\\!\\!\\!\") = \"Hello \\!\\!\\\
  !Wdlor\" ]]\n    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"Hi. My name\
  \ is Mister Robot. How are you?\") = \".Hi My aemn is Meirst .Rboot How aer ?ouy\"\
  \ ]]\n}\n\nrun_test"
completions: ["    local split_string=$(echo \"$1\" | sed 's/ /\\n/g')\n    local\
    \ sorted_string\n    for i in $split_string; do\n        sorted_string+=$(echo\
    \ $i | fold -w1 | sort -n | tr -d '\\n')\n    done\n    echo $sorted_string",
  "    echo \"$1\" | tr ' ' '\\n' | while read word; do echo -n $(anti_shuffle_word\
    \ $word); echo -n ' '; done", "    text=$1\n    for word in $text; do\n      \
    \  chars=($(echo $word | grep -o .))\n        chars=$(echo ${chars[@]} | tr '\
    \ ' '\\n' | sort | tr '\\n' ' ')\n        sorted_text=\"$sorted_text $chars\"\n\
    \    done\n    echo $sorted_text", "  IFS=' ' read -ra ADDR <<< \"$1\"\n  for\
    \ i in \"${ADDR[@]}\"; do\n    # add counter\n    c=0\n    IFS='' read -ra letters\
    \ <<< \"$i\"\n    for j in \"${letters[@]}\"; do\n      # iterate through word\n\
    \      # check if letter is already in new array\n      if [ \"$(echo \"${letters_asc[@]}\"\
    \ | grep -o \"$j\" | wc -w)\" -eq 0 ]; then\n        # append the value of current\
    \ letter to a new array\n        letters_asc[c]=\"$j\"\n        ((c++))\n    \
    \  fi\n    done\n    # sort letter array\n    letters_asc=($(for k in \"${letters_asc[@]}\"\
    ; do echo \"$k\"; done | sort))\n    echo -n \"${letters_asc[@]}\"\n    unset\
    \ letters_asc\n  done", "    # Define the empty string\n    local str=\"\"\n \
    \   # Loop over each word in $1\n    for word in $1; do\n        # Loop over each\
    \ character in $word\n        for (( i=0; i<${#word}; i++ )); do\n           \
    \ # Assign each character in $word to an array\n            characters[$i]=${word:$i:1}\n\
    \        done\n        # Sort characters\n        IFS=$'\\n' sorted=($(sort <<<\"\
    ${characters[*]}\"))\n        unset IFS\n        # Append sorted characters to\
    \ the empty string\n        str+=\"${sorted[*]}\"\n    done\n    # Print string\n\
    \    echo \"$str\"", "  local IFS=$'\\n'\n  local out\n\n  for word in $(echo\
    \ \"$1\" | tr ' ' '\\n'); do\n    # add word to output - but sort it's characters\n\
    \    # then and the sorted characters back together\n    out=\"$out$(echo \"$word\"\
    \ | fold -w1 | sort | tr -d '\\n')\"\n  done\n\n  echo \"$out\"", "  local awk_str='{\
    \ \\\n    while (match($0, /([^ ]+)/, groups)) { \\\n      split(groups[1], chars,\
    \ \"\"); \\\n      sort(chars); \\\n      print (tolower(chars[1]) == tolower(groups[1]))\
    \ ? chars[1] : toupper(chars[1]); \\\n      $0 = substr($0, length(groups[1])\
    \ + 1); \\\n    } \\\n  }';\n  echo \"$1\" | awk \"$awk_str\";", "\techo $(echo\
    \ $1 | tr ' ' '\\n' | grep -v '^$' | sed 's/./&\\n/g' | sort -u | tr -d '\\n'\
    \ | tr ' ' '\\n' | grep -v '^$' | tr '\\n' ' ')", "\tlocal words=($1)\n\tlocal\
    \ result=()\n\tfor word in \"${words[@]}\"; do\n\t\tlocal letters=($(echo $word\
    \ | grep -o .))\n\t\tlocal sorted_letters=($(printf \"%s\\n\" \"${letters[@]}\"\
    \ | sort))\n\t\tresult+=(\"${sorted_letters[*]}\")\n\tdone\n\techo \"${result[*]}\"",
  "    # put your code here, you can use external programs\n    # $(echo -n \"Hello\
    \ World!\" | tr ' ' '\\n' | sort | tr '\\n' ' ')\n    # $() \u0441\u043E\u0437\
    \u0434\u0430\u0451\u0442 \u043E\u0431\u0451\u0440\u0442\u043A\u0443 \u043D\u0430\
    \u0434 \u043A\u043E\u043C\u0430\u043D\u0434\u043E\u0439, \u043A\u043E\u0442\u043E\
    \u0440\u0443\u044E \u043E\u043D\u0430 \u0437\u0430\u043F\u0443\u0441\u043A\u0430\
    \u0435\u0442,\n    # \u0438 \u0437\u0430\u043C\u0435\u043D\u044F\u0435\u0442 \u0432\
    \ \u044D\u0442\u043E\u043C \u043C\u0435\u0441\u0442\u0435 \u0435\u0451 \u0432\u044B\
    \u0432\u043E\u0434\n    # \u0418\u0437\u0432\u043B\u0435\u043A\u0430\u0435\u043C\
    \ \u0438\u0437 \u0441\u0442\u0440\u043E\u043A\u0438 \u0441\u043B\u043E\u0432\u0430\
    \n    local words=$(echo -n \"$1\" | tr ' ' '\\n')\n    # \u0421\u043E\u0440\u0442\
    \u0438\u0440\u0443\u0435\u043C \u043F\u043E ascii\n    local sorted=$(echo -n\
    \ \"$words\" | sort)\n    # \u0412\u043E\u0441\u0441\u0442\u0430\u043D\u0430\u0432\
    \u043B\u0438\u0432\u0430\u0435\u043C \u043F\u043E\u0440\u044F\u0434\u043E\u043A\
    \ \u0441\u043B\u043E\u0432\n    local result=$(echo -n \"$sorted\" | tr '\\n'\
    \ ' ')\n    # \u0412\u043E\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u043C \u0440\
    \u0435\u0437\u0443\u043B\u044C\u0442\u0430\u0442\n    echo \"$result\"", "   \
    \ for word in $1; do\n        word_arr=()\n        for ((i=0; i<${#word}; i++));\
    \ do\n            word_arr+=(\"${word:$i:1}\")\n        done\n        printf \"\
    %s\" \"${word_arr[@]}\" | sort | tr -d \" \"\n    done", "  # Please write your\
    \ code here.\n  # \"abcde\" -> \"abcde\"\n  # \"a b cd\" -> \"a b cd\"\n  # \"\
    Hello World\" -> \"Hello World\"\n  # \"He ll o W o rl d\" -> \"He ll o W o rl\
    \ d\"\n  # \"Hello World!!!!\" -> \"Hello World!!!!\"\n  # \"Hi\" -> \"Hi\"\n\
    \  # \"hello\" -> \"ehllo\"\n  # \"Hello World!!\" -> \"Hello World!!\"\n  # \"\
    Hello World!!!!\" -> \"Hello World!!!!\"\n  out=\"\"\n  for word in $1; do\n \
    \   echo $word\n    out=$out$(echo $word | grep -o . | sort | tr -d '\\n')\n \
    \ done\n  echo $out", "  # Make a new array of words from $1\n  local IFS=$' '\n\
    \  local words=( $1 )\n  # Make a new word\n  for word in \"${words[@]}\"; do\n\
    \    new_word=\"\"\n    # Make a new array of characters from $word\n    local\
    \ IFS=$''\n    local chars=( $word )\n    # Sort an array of characters, remove\
    \ duplicates and make a new string\n    for char in $(echo \"${chars[*]}\" | tr\
    \ ' ' '\\n' | sort -n | uniq); do\n      new_word=\"$new_word$char\"\n    done\n\
    \    new_words[${#new_words[@]}]=\"$new_word\"\n  done\n  # Make a new string\
    \ from an array of words\n  echo \"${new_words[*]}\"", "  str=\"$1\"\n  new_str=\"\
    \"\n  for word in $str; do\n    new_word=$(echo $word | fold -w1 | sort | tr -d\
    \ '\\n')\n    new_str=\"$new_str $new_word\"\n  done\n  echo $new_str", "    string_arr=($(echo\
    \ $1 | sed 's/[\\!\\?\\., ]/& /g'))\n    for word in \"${string_arr[@]}\"; do\n\
    \        characters=$(echo \"$word\" | grep -o . | sort)\n        if [[ \"$word\"\
    \ =~ [\\!\\?\\., ] ]]; then\n            printf \"$characters\"\n        else\n\
    \            printf \"$characters \"\n        fi\n    done\n    printf \"\\n\"",
  "  local var=$1\n  local res\n  local word\n  local s\n  local c\n  local res_arr=()\n\
    \  local var_arr\n  # Split by space and put into var_arr\n  IFS=' ' read -r -a\
    \ var_arr <<< \"$var\"\n  # Iterate over all words, put into word\n  for word\
    \ in \"${var_arr[@]}\"; do\n    # Store an empty string to s, then iterate over\
    \ all characters in word\n    # and put into c\n    s=\"\"\n    for c in $(echo\
    \ $word | fold -w1); do\n      # Add characters from c to s using their ASCII\
    \ value\n      s+=$(printf \"%s\" $c | od -A n -t dC)\n    done\n    # Sort s\
    \ and pipe it to cut to get the character value\n    s=$(echo $s | tr \" \" \"\
    \\n\" | sort -n | cut -f2)\n    # Then add these characters to res_arr\n    res_arr+=(\"\
    $s\")\n  done\n  # After iterating over all words, add them to res\n  res=$(echo\
    \ ${res_arr[@]} | tr \" \" \"\\n\")\n  # Finally, print res\n  echo \"$res\"",
  "  # Your code here\n  # This is a possible solution.\n  # It uses the fact that\
    \ `<<<` is the same as `echo` in bash.\n  echo \"$1\" | tr ' ' '\\n' |\n    while\
    \ read word\n    do\n      echo $word |\n        fold -w1 |\n        sort |\n\
    \        tr -d '\\n'\n      echo -n ' '\n    done", "  for word in $1; do\n  \
    \  sorted_word=$(echo $word | grep -o . | sort | tr -d '\\n')\n    echo -n \"\
    $sorted_word \"\n  done", "    # word\uC758 \uAC2F\uC218\uB97C \uC54C\uC544\uB0B4\
    \uAE30 \uC704\uD574 wc \uC0AC\uC6A9\n    count=$(echo $1 | wc -w)\n    for ((i=1;\
    \ i<=count; i++))\n    do\n        # \uB2E8\uC5B4\uB97C \uBC30\uC5F4\uB85C \uBC1B\
    \uC544\uC634\n        word=$(echo $1 | cut -d \" \" -f $i)\n        # \uBC30\uC5F4\
    \uC758 \uAC01 \uB2E8\uC5B4\uB4E4\uC744 \uBE44\uAD50\uD574\uC11C \uC624\uB984\uCC28\
    \uC21C\uC73C\uB85C \uBC30\uC5F4 \uC7AC\uC815\uB82C\n        for ((j=1; j<=${#word};\
    \ j++))\n        do\n            # \uB2E8\uC5B4\uC758 \uAC01 \uBB38\uC790\uB97C\
    \ \uBC30\uC5F4\uB85C \uBC1B\uC544\uC634\n            char=$(echo $word | cut -c\
    \ $j)\n            # \uBC30\uC5F4 \uC7AC\uC815\uB82C\n            array[$j]=$char\n\
    \        done\n        sorted_word=$(printf \"%s\\n\" \"${array[@]}\" | sort -n)\n\
    \        # \uBC30\uC5F4\uC758 \uAC01 \uB2E8\uC5B4\uC5D0 \uB300\uD574\uC11C \uC704\
    \uC640 \uAC19\uC740 \uC791\uC5C5\n        new_word=$(echo $new_word $sorted_word)\n\
    \    done\n    echo $new_word", "    # Write your code from here\n    str=\"$1\"\
    \n    # echo \"$str\"\n    newstr=''\n    for word in $str; do\n        # echo\
    \ \"$word\"\n        # echo \"$newstr\"\n        newstr+=\"$(sort -h <<< \"$word\"\
    )\"\n        newstr+=' '\n    done\n    echo \"$newstr\"", "\tarr=($(echo $1 |\
    \ tr \" \" \"\\n\"))\n\tfor i in \"${arr[@]}\"\n\tdo\n\t\techo -n \"$(echo \"\
    $i\" | tr -cs \"[:alnum:]\" \"\\n\" |\n\t\tsort -u | tr -d \"\\n\")\"\n\tdone\n\
    \techo \"\"", "    awk '{\n        split($0,a,\"\");\n        for (i=1;i<=length($0);i++)\n\
    \            ascii[i]=a[i] \" \" i;\n        asort(ascii);\n        for (i=1;i<=length($0);i++)\n\
    \            a[ascii[i] \" \" i]=ascii[i];\n        for (i=1;i<=length($0);i++)\n\
    \            printf(\"%s\",a[i]);\n        printf(\"\\n\");\n    }' <<< \"$1\"",
  "   local var=\"$1\"\n   local res\n   for word in $var; do\n      res+=\"$(echo\
    \ -n $word | grep -o . | sort -n | uniq | tr -d '\\n')\"\n   done\n   echo $res",
  "    eval $1 | tr ' ' '\\n' | sort -d | xargs", "  # Solution 1:\n  echo $1 | tr\
    \ ' ' '\\n' | while read word; do\n    echo -n \"$(echo -n $word | fold -w1 |\
    \ sort -n | tr -d '\\n') \"\n  done\n  echo\n\n  # Solution 2:\n  # echo $1 |\
    \ sed -r 's/([a-z]+)/\\1\\n/g' | while read word; do\n  #   echo -n \"$(echo -n\
    \ $word | fold -w1 | sort -n | tr -d '\\n') \"\n  # done\n  # echo", "  # Write\
    \ your code here\n  # You may want to use:\n  #  - anti_shuffle_word()\n  #  -\
    \ anti_shuffle_words()\n  #  - anti_shuffle_sentence()\n  return 0", "    local\
    \ new_string=\"\"\n    local tmp_word=\"\"\n    for word in $1; do\n        tmp_word=\"\
    \"\n        for char in $(echo $word | fold -w1); do\n            tmp_word+=$(echo\
    \ -e \"$char\\n$tmp_word\" | sort -r | head -n1)\n        done\n        new_string+=\"\
    \ $tmp_word\"\n    done\n    echo \"$new_string\"", "    local string=$1\n   \
    \ echo \"$string\"", "    local input=$1\n    local result=\n    local word=\n\
    \    local word_length=\n    local char=\n    local char_array=\n    for word\
    \ in $input; do\n        for (( i=0; i<${#word}; i++ )); do\n            char_array[i]=${word:$i:1}\n\
    \        done\n        word_length=${#word}\n        for (( i=0; i<word_length;\
    \ i++ )); do\n            for (( j=i+1; j<word_length; j++ )); do\n          \
    \      if [ ${char_array[$i]} \\> ${char_array[$j]} ]; then\n                \
    \    char=${char_array[$i]}\n                    char_array[$i]=${char_array[$j]}\n\
    \                    char_array[$j]=$char\n                fi\n            done\n\
    \        done\n        result=\"$result${char_array[@]}\"\n    done\n    echo\
    \ $result", "    echo \"${@}\" | tr ' ' '\\n' | tr -cs '[:alnum:]' '\\n' | awk\
    \ '{\n        for (i = 1; i <= NF; i++) {\n            word = word $i;\n     \
    \   }\n        print word;\n        word = \"\";\n    }' | sort | tr '\\n' ' '\
    \ | sed 's/ $//'", "    local _AS_WORDS=$(echo $1 | tr \" \" \"\\n\")\n    local\
    \ _RESULT=\"\"\n    for _WORD in $_AS_WORDS; do\n        _RESULT=$_RESULT\"$(echo\
    \ $_WORD | sed 's/./&\\n/g' | sort | tr -d \"\\n\") \"\n    done\n    _RESULT=$(echo\
    \ $_RESULT | sed 's/\\s*$//')\n    echo $_RESULT", "\tlocal string=$1\n\tIFS=\"\
    \ \" # set space as delimiter\n\t# split string to array of strings\n\tread -a\
    \ strings <<< \"$string\"\n\t# iterate through array and update each string\n\t\
    for idx in \"${!strings[@]}\"; do\n\t\tstrings[$idx]=$(echo ${strings[$idx]} |\
    \ grep -o . | sort | tr -d '\\n')\n\tdone\n\t# print array of strings as one string\n\
    \techo \"${strings[@]}\"", "\t# remove white spaces from start and end of string\n\
    \tstring=\"$(echo -e \"${1}\" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')\"\
    \n\t# split string by empty space\n\tIFS=' ' read -ra words <<< \"$string\"\n\t\
    # sort character of each word\n\tfor i in \"${!words[@]}\"; do\n\t\t# sort character\
    \ of word\n\t\twords[$i]=\"$(echo \"${words[$i]}\" | grep -o . | sort | tr -d\
    \ '\\n')\"\n\tdone\n\t# print new string\n\techo \"${words[*]}\"", "    local\
    \ out\n    local in=\"$1\"\n    local oldIFS=$IFS\n    IFS=' '\n    for w in $in;\
    \ do\n        out=\"$out $(echo \"$w\" | grep -o . | sort | tr -d '\\n')\"\n \
    \   done\n    IFS=$oldIFS\n    echo \"$out\"", "    local string=\"$1\"\n    local\
    \ result=\"\"\n    for word in $string; do\n        local chars=\"\"\n       \
    \ for (( i=0; i<${#word}; i++ )); do\n            chars=\"$chars${word:$i:1}\"\
    \n        done\n        chars=$(sort <<<\"$chars\")\n        result=\"$result\
    \ $chars\"\n    done\n    echo $result", "    echo $1 | tr \" \" \"\\n\" |\n \
    \       while read line; do\n            echo -n $line | sort -n | tr -d \"\\\
    n\"\n            echo -n \" \"\n        done", "  string=$1\n  words=$(echo \"\
    ${string}\" | sed 's/[^a-zA-Z ]/ /g')\n  echo \"${words}\" | \\\n    awk '{\n\
    \      for (i = 1; i <= NF; i++) {\n        if (length($i) > 0) {\n          command\
    \ = \"echo \\\"\"$i\"\\\" | sed -e \\\"s/\\(.\\)/\\1\\n/g\\\" | sort | paste -sd\\\
    \"\\\"\"\n          command | getline word\n          printf \"%s \", word\n \
    \       }\n      }\n      printf \"\\n\"\n    }'", "\t# Your code here\n\tfor\
    \ word in $1; do\n\t\tlen=${#word}\n\t\tres=\"\"\n\t\tfor (( i=0; i<len; i++ ));\
    \ do\n\t\t\tres=$res$(printf \"$word\" | grep -o . | sort -n | tr -d '\\n')\n\t\
    \tdone\n\t\techo -n \"$res \"\n\tdone\n\tprintf \"\\n\"", "  local SORTED_STRING=\"\
    \"\n  # Iterate over the words in the string and sort each one\n  for WORD in\
    \ $1; do\n    echo $WORD | grep -q \" \"\n    if [ $? -eq 0 ]; then\n      WORD_CHAR=$(echo\
    \ $WORD | sed 's/\\s*//g')\n      WORD_CHAR=$(echo $WORD_CHAR | sed 's/./&\\n/g'\
    \ | sort | tr -d '\\n')\n      SORTED_STRING=\"$SORTED_STRING$WORD_CHAR \"\n \
    \   else\n      WORD_CHAR=$(echo $WORD | sed 's/./&\\n/g' | sort | tr -d '\\n')\n\
    \      SORTED_STRING=\"$SORTED_STRING$WORD_CHAR \"\n    fi\n  done\n  # Remove\
    \ the trailing whitespace\n  SORTED_STRING=$(echo $SORTED_STRING | sed 's/\\s*$//')\n\
    \  echo $SORTED_STRING", "    # create a new string\n    new_string=\"\"\n   \
    \ for word in $1; do\n        # add word to new string\n        new_string=\"\
    $new_string\"$(echo $word | grep -o . | sort | tr -d '\\n')\n    done\n    echo\
    \ $new_string", "  local __shuffled=`echo $1 | sed 's/ /\\n/g' | sort | tr -d\
    \ '\\n'`\n  local __oldIFS=$IFS\n  IFS=\" \"\n  echo $__shuffled\n  IFS=$__oldIFS",
  "    str=$1\n    words=$(echo \"$str\" | tr \" \" \"\\n\")\n    new_words=\"\"\n\
    \    for word in $words; do\n        chars=$(echo \"$word\" | fold -w1)\n    \
    \    new_word=\"\"\n        for char in $chars; do\n            char_ascii=$(echo\
    \ -n \"$char\" | xxd -p)\n            char_ascii=$(echo \"$char_ascii\" | tr \"\
    [:lower:]\" \"[:upper:]\")\n            char_dec=$(echo \"ibase=16; $char_ascii\"\
    \ | bc)\n            new_word+=\"$char_dec\"\n        done\n        new_word=$(echo\
    \ \"$new_word\" | fold -w1 | sort -g | tr -d \"\\n\")\n        new_words+=\"$new_word\
    \ \"\n    done\n    new_words=$(echo \"$new_words\" | tr \" \" \"\\n\")\n    for\
    \ new_word in $new_words; do\n        len=${#new_word}\n        for (( i=0; i<$len;\
    \ i++ )); do\n            (( ch=10#${new_word:$i:1} ))\n            printf \\\\\
    $(printf '%03o' \"$ch\")\n        done\n        echo -n \" \"\n    done\n    echo\
    \ \"\"", "  local _in_str=$1\n  local _out_str=\"\"\n  local _word_arr=()\n  local\
    \ _chars_arr=()\n  local _cnt=0\n  local _wrd_cnt=0\n  local _chr_cnt=0\n  local\
    \ _max_chr_cnt=0\n  local _chr_idx=0\n  local _idx=0\n  local _chr=\"\"\n  local\
    \ _wrd=\"\"\n  local _arr=()\n  local _tmp_arr=()\n  local _first_flag=0\n  local\
    \ _wrd_flag=0\n  local _sort_flag=0\n  local _blnk_flag=0\n  local _str=\"\"\n\
    \  local _str_chr=\"\"\n  local _word_regex='^[a-zA-Z]+$'\n  local _blank_regex='^\\\
    s+$'\n  local _i=0\n  local _j=0\n  local _idx=0\n  local _dup_arr=()\n  local\
    \ _dup_cnt=0\n  local _tmp_idx=0\n  local _out_idx=0\n  local _tmp=0\n  local\
    \ _cnt=0\n  local _first_flag=0\n  local _tmp_arr=()\n  local _loop_flag=0\n \
    \ local _dup_flag=0\n  local _tmp_dup_flag=0\n  local _chr=\"\"\n  local _chr_idx=0\n\
    \  local _first_idx=0\n  local _min_idx=0\n  local _tmp_cnt=0\n  local _dup_str=\"\
    \"\n  local _dup_str_chr=\"\"\n  local _dup_cnt=0\n  local _wrd_idx=0\n  local\
    \ _tmp_idx=0\n  local _dup_idx=0\n  local _wrd_flag=0\n  local _dup_flag=0\n \
    \ local _out_idx=0\n  local _tmp_cnt=0\n  local _min_idx=0\n  local _chr", " \
    \   if [ -z \"$1\" ]; then\n        return 0\n    fi\n    str=$1\n    spaces=\"\
    $(tr -s ' ' <<< \"$str\")\"\n    trimmed_spaces=\"$(tr -d ' ' <<< \"$spaces\"\
    )\"\n    words=\"$(tr ' ' '\\n' <<< \"$trimmed_spaces\")\"\n    length=${#str}\n\
    \    i=0\n    while [ $i -lt $length ]; do\n        if [ \"${str:$i:1}\" == \"\
    \ \" ]; then\n            echo -n \" \"\n        else\n            echo -n \"\
    $(bubble_sort \"$words\")\"\n            words=$(remove_first_word \"$words\"\
    )\n        fi\n        i=$((i+1))\n    done\n    echo", "  # Write your code here\n\
    \  IFS=\" \"\n  str=($1)\n  result=\"\"\n  for w in ${str[@]}; do\n    ord=`echo\
    \ \"$w\" | grep -o . | sort | tr -d \"\\n\"`\n    result+=\" $ord\"\n  done\n\
    \  echo \"$result\"", "    local words=($(echo $1 | tr -s ' ' '\\n'))\n    for\
    \ word in \"${words[@]}\"; do\n        echo $(echo \"$word\" | grep -o . | sort\
    \ | tr -d '\\n')\n    done | tr -d '\\n'", "  local result=\"\"\n  for word in\
    \ $1; do\n    # A is the ascii value of the first letter of word.\n    # Z is\
    \ the ascii value of the last letter of word.\n    # expr is the expression to\
    \ evaluate\n    #  A + (index of the character - 1)\n    #  $((expr))\n    # is\
    \ a way to evaluate the expression and it's better\n    # than to use the let\
    \ keyword.\n    # $(printf) is a command to print formatted output.\n    local\
    \ chars=$(printf \"%$((65 + $(expr index \"$word\" \"\\(.\\)\")))c\" {0..255})\n\
    \    # $(grep -o) is a command to print only matches.\n    # [:alpha:] is a regular\
    \ expression for alphabet.\n    result+=$(echo -e \"$chars\" | grep -o '[:alpha:]'\
    \ | tr -d '\\n')\n  done\n  echo $result", "    new_str=''\n    for word in $1;\
    \ do\n        cnt=0\n        new_word=''\n        for (( i=0; i<${#word}; i++\
    \ )); do\n            if [ $i -eq 0 ]; then\n                new_word=\"${word:$i:1}\"\
    \n            else\n                for (( j=0; j<${#new_word}; j++ )); do\n \
    \                   if [ $(printf '%d' \"'${word:$i:1}\") -lt $(printf '%d' \"\
    '${new_word:$j:1}\") ]; then\n                        new_word=\"${new_word:0:$j}${word:$i:1}${new_word:$j}\"\
    \n                        cnt=1\n                        break\n             \
    \       fi\n                done\n                if [ $cnt -eq 0 ]; then\n  \
    \                  new_word=\"${new_word}${word:$i:1}\"\n                fi\n\
    \            fi\n        done\n        new_str=\"${new_str}${new_word}\"\n   \
    \ done\n    echo \"$new_str\"", "    if [[ $# -eq 0 ]]; then\n        echo \"\
    Usage: anti_shuffle <string>\"\n        return 0\n    fi\n    local string=$1\n\
    \    echo \"$string\" | tr \" \" \"\\n\" |\n        while read -r line; do\n \
    \           echo -n \"$(echo -n \"$line\" |\n                tr -cd [:alnum:]\
    \ | sort | tr -d '\\n') \"\n        done", "\t# if string is empty, return it\n\
    \tif [ -z \"$1\" ]; then\n\t\techo \"$1\"\n\t\treturn\n\tfi\n\n\t# iterate through\
    \ words\n\tfor word in $1; do\n\t\t# if character is not alpha, print it\n\t\t\
    if ! [[ $word =~ ^[a-zA-Z]+$ ]]; then\n\t\t\techo -n \"$word\"\n\t\t\tcontinue\n\
    \t\tfi\n\n\t\t# get sorted word\n\t\tsorted_word=\"$(printf \"%s\\n\" \"$word\"\
    \ | sort -n)\"\n\n\t\t# if first character is lower case, make all characters\
    \ lower case\n\t\tif [[ \"${sorted_word:0:1}\" =~ ^[a-z]+$ ]]; then\n\t\t\techo\
    \ -n \"${sorted_word,,}\"\n\t\t# else make all characters upper case\n\t\telse\n\
    \t\t\techo -n \"${sorted_word^^}\"\n\t\tfi\n\tdone", "  output=\"\"\n  for word\
    \ in ${1}\n  do\n    if [ \"$word\" == \" \" ]\n    then\n      output=\"$output\
    \ $word\"\n    else\n      output=\"$output $(${SCRIPT_FOLDER}/ascii_sort.sh $word)\"\
    \n    fi\n  done\n  echo $output", "    local words i\n    words=($(echo \"$1\"\
    \ | tr -s '[:space:]' '\\n'))\n    for ((i=0; i<${#words[@]}; i++)); do\n    \
    \    words[$i]=$(echo \"${words[$i]}\" | grep -o . | sort -u | tr -d '\\n')\n\
    \    done\n    echo \"${words[@]}\"", "  echo $1 | xargs -n1 | sort -t' ' -k1.2\
    \ | tr -d '\\n'", "    res=\"\"\n    local sorted\n    for word in $1; do\n  \
    \      sorted=$(echo \"$word\" | grep -o . | sort | tr -d '\\n')\n        res=\"\
    $res$sorted\"\n    done\n    echo \"$res\"", "    for word in $1; do\n       \
    \ chars=$(echo \"$word\" | fold -w1)\n        echo \"$(echo \"$chars\" | sort\
    \ -n)\"\n    done", "    echo $1 | tr ' ' '\\n' | sort -k1 -t. | xargs | tr '\
    \ ' '\\n' | sort -f | xargs", "    # Split string into array of words, sorted\
    \ by shortest word first\n    local all_words=($(echo \"$1\" | awk '{n=split($0,s,/[\
    \ \\t\\n]+/);for(i=1;i<=n;i++)a[i]=s[i]}END{for(i=1;i<=n;i++)for(j=i+1;j<=n;j++)if(length(a[i])>length(a[j])){t=a[i];a[i]=a[j];a[j]=t}for(i=1;i<=n;i++)printf(\"\
    %s \",a[i])}'))\n    local word_count=${#all_words[@]}\n    local ordered_words=(${all_words[@]})\n\
    \    local word\n    local pos\n    local i\n    local new_word\n    local new_sentence\n\
    \    # Sort each word in all_words\n    for ((i=0; i<word_count; i++)); do\n \
    \       word=${all_words[$i]}\n        new_word=$(echo \"$word\" | awk '{gsub(/./,\"\
    &\\n\",$0);for(i=1;i<=NF;i++)a[i]=$i}END{for(i=1;i<=NF;i++)for(j=i+1;j<=NF;j++)if(a[i]>a[j]){t=a[i];a[i]=a[j];a[j]=t}for(i=1;i<=NF;i++)printf(\"\
    %s\",a[i])}')\n        ordered_words[$i]=$new_word\n    done\n    # Replace sorted\
    \ words in input string to get new sentence\n    new_sentence=$1\n    for ((i=0;\
    \ i<word_count; i++)); do\n        word=${all_words[$i]}\n        new_word=${ordered_words[$i]}\n\
    \        if [[ \"$word\" == \"$new_word\" ]]; then\n            continue\n   \
    \     fi\n        new_sentence=$(echo \"$new_sentence\" |", "    local result=$(echo\
    \ $1 | tr ' ' '\\n' | sed -e 's/^\\(.\\)/\\1 /' | sort -s -k1,1 -k2,2n | tr -d\
    \ ' ')\n    echo $result", "  # TODO: Write this function\n  echo \"Not implemented\"",
  "    if [ -z \"$1\" ]; then\n        echo \"usage: $0 'string'\"\n        return\
    \ 1\n    fi\n    local WORDS=()\n    for word in $1; do\n        WORDS+=(\"$(echo\
    \ $word | fold -w1 | sort | tr -d '\\n')\")\n    done\n    echo \"${WORDS[@]}\"",
  "    echo \"$1\" | tr ' ' '\\n' | \\\n    while read word; do\n        echo -n \"\
    $(echo -n \"$word\" | fold -w1 | sort | tr -d '\\n') \"\n    done", "  local -i\
    \ acs=0\n  local result=\"\"\n  for ((i=0; i<${#1}; i++)); do\n    acs=${1:$i:1}\n\
    \    if [[ $acs == ' ' ]]; then\n      result+=\" \"\n    else\n      string=$(echo\
    \ ${1:$i} | tr -cd \"[a-zA-Z0-9]\")\n      string=$(echo $string | grep -o .)\n\
    \      string=$(echo \"$string\" | tr \"[:upper:]\" \"[:lower:]\")\n      result+=$(echo\
    \ \"$string\" | sort | tr -d \"\\n\")\n    fi\n  done\n  echo \"$result\"", " \
    \ local arr=($(echo \"$1\" | tr ' ' '\\n'))\n  for (( i = 0; i < ${#arr[@]}; i++\
    \ )); do\n    arr[$i]=$(echo \"${arr[$i]}\" | fold -w1 | sort | tr -d '\\n')\n\
    \  done\n  echo \"${arr[@]}\" | tr ' ' '\\n' | tr -d '\\n'", "    echo $1 | tr\
    \ ' ' '\\n' | while read word; do\n        echo $word | tr -cs 'A-Za-z' '\\n'\
    \ | sort | tr -d '\\n'\n        echo -n ' '\n    done", "    local str\n    local\
    \ ans\n    IFS=' '\n    for str in $1; do\n        ans=\"$ans$(anti_shuffle_one_word\
    \ $str)\"\n    done\n    echo $ans", "    # Insert code here\n    # Write your\
    \ own implementation\n    # Return value should be printed to stdout\n    local\
    \ result=$(echo $1 | tr \" \" \"\\n\")\n    echo $(for word in $result; do echo\
    \ -n \"$(echo -n $word | grep -o . | sort -u | tr -d \"\\n\")\"; echo -n \" \"\
    ; done)", "    str=\"$1\"\n    result=\"\"\n    for word in ${str}; do\n     \
    \   new_word=$(echo ${word} | grep -o . | sort | tr -d '\\n')\n        result=\"\
    ${result} ${new_word}\"\n    done\n    echo \"${result}\"", "    for word in $1;\
    \ do\n        echo -n \"$word\" |\n        {\n            length=$(echo -n \"\
    $word\" | wc -c)\n            for ((i=1; i<=$length; i++)); do\n             \
    \   char=$(echo -n \"$word\" | head -c $i | tail -c 1)\n                echo -n\
    \ \"$char\"\n            done\n        } | sort -b |\n        {\n            length=$(echo\
    \ -n \"$word\" | wc -c)\n            for ((i=1; i<=$length; i++)); do\n      \
    \          char=$(head -n $i | tail -n 1)\n                echo -n \"$char\"\n\
    \            done\n        }\n        echo -n \" \"\n    done", "    # First split\
    \ the string into an array of words using newline\n    # character as delimiter.\n\
    \    local -a str_arr\n    read -a str_arr <<<\"$(printf \"%s\\n\" \"$1\")\"\n\
    \    # Then iterate over the array and sort each word\n    # individually and\
    \ then append the resulting string\n    # to the output.\n    local output\n \
    \   for word in \"${str_arr[@]}\"; do\n        output+=\"$(printf \"%s\" \"$word\"\
    \ | sort)\"\n    done\n    printf \"%s\" \"$output\"", "    # Loop through each\
    \ word\n    for word in $1; do\n        # Split up the word into individual characters\n\
    \        chars=$(echo $word | grep -o .)\n        # Sort the characters alphabetically\n\
    \        chars_sorted=$(printf \"%s\\n\" $chars | sort)\n        # Replace the\
    \ word with the sorted characters\n        new_string=\"${new_string}${chars_sorted}\"\
    \n    done\n    # Return the new string with all sorted words\n    echo $new_string",
  "    echo \"$1\" | awk '{for(i=1;i<=NF;i++) {\n                    for(j=1;j<=length($i);j++)\
    \ {\n                        arr[j]=substr($i,j,1)\n                    }\n  \
    \                  sort(arr)\n                    for(k=1;k<=length($i);k++) {\n\
    \                        printf \"%s\",arr[k]\n                    }\n       \
    \             printf \" \"\n                }\n                printf \"\\n\"\n\
    \    }'", "    # shellcheck disable=SC2206\n    words=($(echo \"$1\" | tr ' '\
    \ '\\n'))\n    for word in \"${words[@]}\"; do\n        reversed_word=$(echo \"\
    $word\" | rev)\n        echo -n \"$(sort <<< \"$reversed_word\")\"\n    done\n\
    \    echo", "  # Put your code here\n  line=$1\n  word=''\n  result=''\n  for\
    \ ((i=0; i<${#line}; i++)); do\n    char=${line:$i:1}\n    if [[ $char == \" \"\
    \ ]]; then\n      result=\"$result $word\"\n      word=''\n    else\n      if\
    \ [[ $word == '' ]]; then\n        word=$char\n      else\n        for ((j=0;\
    \ j<${#word}; j++)); do\n          jth=${word:$j:1}\n          if [[ $char < $jth\
    \ ]]; then\n            first=${word:0:$j}\n            second=${word:$j}\n  \
    \          word=\"$first$char$second\"\n            break\n          elif [[ $j\
    \ == $(( ${#word} - 1 )) ]]; then\n            word=$word$char\n          fi\n\
    \        done\n      fi\n    fi\n  done\n  result=\"$result $word\"\n  echo \"\
    $result\"", "  # Check if parameters are supplied\n  # $# is number of params\n\
    \  if [ $# -ne 1 ]; then\n    echo \"Function takes one parameter only\"\n   \
    \ return 1\n  fi\n\n  # Check if parameter is a string\n  # -z checks if string\
    \ is empty\n  if [ -z \"$1\" ]; then\n    echo \"Parameter should be a string\"\
    \n    return 1\n  fi\n\n  # Make sure argument is wrapped in double quotes\n \
    \ # To pass a double quote without closing the string,\n  # you can escape it\
    \ with a backslash, or you can use single quotes.\n  # It's good practice to wrap\
    \ arguments in double quotes for safety,\n  # even if the contents don't contain\
    \ any spaces.\n  # Using single quotes will not do variable expansion.\n  # Using\
    \ double quotes will enable variable expansion\n  # and escape sequence interpretation.\n\
    \  # https://unix.stackexchange.com/questions/65803/why-is-printf-better-than-echo\n\
    \  # When using the printf command, make sure to wrap the string argument\n  #\
    \ in quotes to prevent errors related to unescaped (or escaped incorrectly)\n\
    \  # characters.\n  printf -v output_string \"%s\" \"$1\"\n\n  # Split string\
    \ into array of words\n  # http://stackoverflow.com/questions/5163144/bash-split-string-into-array\n\
    \  # IFS is internal field separator\n  # http://www.gnu.org/software/bash/manual/html_node/The-Set-Builtin.html\n\
    \  # IFS is set to empty string for this command to override default whitespace\n\
    \  # separator.\n  # read -ra turns string into array.\n  IFS=' ' read -ra words\
    \ <<< \"$output_string\"\n\n  # For each word in words array, sort it\n  for word\
    \ in \"${words[@]}\"; do\n    # Process each word using a closure\n    # http://stackoverflow.com/questions/16989598/bash-comparing-two-strings-in-if-statement\n\
    \    # Use double brackets [[ ... ]] for string comparison.\n    # Use single\
    \ bracket [ ... ] for file conditional expressions.\n    # Use -n to test string",
  "  local -r str=\"$1\"\n  local -r pattern='\\w+'\n  local -r sep=' '\n  local -r\
    \ txt=\"$(echo \"$str\" | tr ' ' '\\n' | sort)\"\n  local -r arr=(${txt//$sep/\
    \ })\n  local -r new_txt=\"$(printf \"$sep%s\" \"${arr[@]}\")\"\n  local -r new_arr=(${new_txt//$sep/\
    \ })\n  echo -e \"$str\" | sed -r \"s/(\\w+)/${new_arr[i++]}/g\"", "    # TODO:\
    \ REPLACE THIS LINE WITH YOUR CODE.\n    output=$( echo $1 | sed -E 's/ /\\n/g'\
    \ | sort -k1 -t . | sed -E 's/\\n/ /g' )\n    echo ${output[@]}", "  # Your code\
    \ here\n  echo \"Not Implemented\"", "    local -i i=0\n    for word in $1; do\n\
    \        word_arr[$i]=$word\n        let i+=1\n    done\n    for (( i=0; i<${#word_arr[@]};\
    \ i++ )); do\n        arr[$i]=$(echo ${word_arr[$i]} | grep -o . | sort | tr -d\
    \ '\\n')\n    done\n    res=${arr[@]}\n    echo $res", "    str=$(echo \"$1\"\
    \ | tr ' ' '\\n')\n    echo $str | sort -u -k1,1 | sort -k1.1,1.1 -r", "\t# TODO\n\
    \t# Use tr to remove special characters\n\t# Then use sed to make the words\n\t\
    # in the string lowercase.\n\techo \"$1\" | tr -d \"?!.,;\" | sed 's/[A-Z]/\\\
    l&/g' | sed 's/[^a-zA-Z ]*//g' | tr \" \" \"\\n\" | sort -f | tr \"\\n\" \" \"\
    \ | sed 's/ /\\L&/g'", "    local result=\"\"\n    local j\n    local i\n    local\
    \ k\n    local l\n    # Make sure the input string is not empty\n    if [ -z \"\
    $1\" ]; then\n        return 1\n    fi\n    # loop through every word in the string\
    \ $1\n    for i in $1; do\n        # loop through each character in the word $i\n\
    \        for j in $(seq 1 ${#i}); do\n            k=$(echo \"$i\" | cut -c$j)\n\
    \            l=\"$l$k\"\n        done\n        # sort the characters in the word\
    \ $i\n        result=\"$result$(for i in $(echo \"$l\" | sed 's/./&\\n/g' | sort);\
    \ do echo -n \"$i\"; done)\"\n        l=\"\"\n    done\n    echo \"$result\"",
  "    echo \"$1\" | # read from stdin\n    tr \" \" \"\\n\" | # seperate words\n\
    \    xargs -I% bash -c 'echo -n \"% \"; echo % | fold -w1 | sort | xargs' | #\
    \ output is % <sorted_word>\n    tr -d \" \" # remove whitespace", "    echo -n\
    \ \"$1\" | tr ' ' '\\n' | awk '{print substr(tolower($0),1,1) substr(toupper($0),2,length($0))}'\
    \ | tr '\\n' ' '", "    echo \"$1\" | tr \" \" \"\\n\" | while read -r word; do\n\
    \        local sorted=\"$(echo \"$word\" | grep -o . | sort -u | tr -d \"\\n\"\
    )\"\n        echo -n \"$sorted\"\n    done", "    local new_str=\"\"\n    local\
    \ words=$(echo $1 | tr \" \" \"\\n\")\n    for w in $words; do\n        local\
    \ new_word=\"\"\n        for ((i=0; i<${#w}; i++)); do\n            local cur_char=${w:$i:1}\n\
    \            local chars=${new_word}\n            if [ -z \"$chars\" ]; then\n\
    \                new_word=${cur_char}\n            else\n                for ((j=0;\
    \ j<${#chars}; j++)); do\n                    local temp_char=${chars:$j:1}\n\
    \                    if [ \"$cur_char\" \\< \"$temp_char\" ]; then\n         \
    \               local substr_start=${j}\n                        local substr_end=$((j+1))\n\
    \                        chars=${chars:0:$substr_start}${cur_char}${chars:$substr_end}\n\
    \                        break\n                    elif [ \"$j\" -eq $(( ${#chars}\
    \ - 1 )) ]; then\n                        chars=${chars}${cur_char}\n        \
    \            fi\n                done\n                new_word=${chars}\n   \
    \         fi\n        done\n        new_str=${new_str}${new_word}\" \"\n    done\n\
    \    echo $new_str", "    string=$1\n    result=\"\"\n    for word in $string;\
    \ do\n        chars=($(echo $word | grep -o .))\n        chars_sorted=($(for i\
    \ in ${chars[@]}; do echo $i; done | sort))\n        for i in ${chars_sorted[@]};\
    \ do\n            result=\"$result$i\"\n        done\n        result=\"$result\
    \ \"\n    done\n    result=${result% }\n    echo $result", "  local IFS=' '\n\
    \  local string=()\n  local word=()\n  for word in $1; do\n    string+=($(echo\
    \ -n $word | sort -b))\n  done\n  echo -n \"${string[*]}\"", "    local ret\n\
    \    if [ $# -ne 1 ]; then\n        echo 'bad args' >&2\n        return 1\n  \
    \  fi\n    while read word; do\n        local w\n        w=$(echo \"$word\" |\
    \ grep -o . | sort | tr -d '\\n')\n        ret=\"$ret $w\"\n    done <<< \"$1\"\
    \n    echo \"$ret\"", "\techo \"$1\" | tr -s ' ' '\\n' | \n\t\t\twhile read word;\
    \ do\n\t\t\t\t\techo \"$word\" | \n\t\t\t\t\t\t\tfold -w1 |\n\t\t\t\t\t\t\tsort\
    \ |\n\t\t\t\t\t\t\ttr -d '\\n'\n\t\t\t\t\techo -n ' '\n\t\t\tdone", "    IFS=$'\
    \ '\n    for word in $1; do\n        echo -n $(echo $word | grep -o . | sort |\
    \ tr -d '\\n')\n    done\n    echo", "  s=$1\n  echo $s | tr ' ' '\\n' | tr '\\\
    n' ' ' | { while read word; do echo -n \"$(echo -n $word | grep -o . | sort)\"\
    ; done; }", "    # Get words\n    WORD_LIST=$(echo $1 | tr ' ' '\\n')\n    # For\
    \ each word, get the ordered version of it.\n    RESULT_LIST=\"\"\n    for WORD\
    \ in $WORD_LIST; do\n        # Get the ordered version of each word.\n       \
    \ ORDERED_WORD=$(echo $WORD | fold -w1 | sort -n | tr -d '\\n')\n        # Concatenate\
    \ the ordered words\n        RESULT_LIST=\"$RESULT_LIST $ORDERED_WORD\"\n    done\n\
    \    # remove the leading blank space\n    echo $RESULT_LIST | cut -c2-", "  \
    \  # YOUR CODE HERE\n    return 0", "  local arg_string=$1\n  local words=()\n\
    \  IFS=' ' read -r -a words <<< \"$arg_string\"\n  local word\n  local word_array\n\
    \  local anti_shuffled=\"\"\n  for word in \"${words[@]}\"; do\n    IFS=$'\\n'\
    \ read -r -a word_array <<< $(printf '%s\\n' \"$word\" | sort)\n    anti_shuffled+=\"\
    ${word_array[*]}\"\n    anti_shuffled+=\" \"\n  done\n  echo \"$anti_shuffled\"",
  "\t# Create an empty string\n\toutput=''\n\t# For each word in the input string\n\
    \tfor word in $1; do\n\t\t# Create an empty string\n\t\toutput_word=''\n\t\t#\
    \ For each letter in the word\n\t\tfor letter in $(echo $word | fold -w1); do\n\
    \t\t\t# Add letter to temporary string\n\t\t\toutput_word+=$letter\n\t\tdone\n\
    \t\t# Sort the letters in the temporary string\n\t\toutput_word=$(echo $output_word\
    \ | fold -w1 | sort)\n\t\t# Add temporary string to output string\n\t\toutput+=$output_word\n\
    \tdone\n\t# Remove whitespace from output string\n\toutput=$(echo $output | tr\
    \ -d ' ')\n\t# Print output string\n\techo $output", "\tSENTENCE=`echo $1 | sed\
    \ -e 's/[^[:space:]]\\+/\\L&/g'`\n\n\tfor word in $SENTENCE; do\n\t\techo -n `echo\
    \ $word | fold -w1 | sort -n | tr -d '\\n'`\n\tdone\n\techo \"\"", "  STRING_SIZE=${#1}\n\
    \  NEW_STRING=\"\"\n  i=0\n  while [[ $i -lt $STRING_SIZE ]]; do\n    if [[ ${1:$i:1}\
    \ == \" \" ]]; then\n      NEW_STRING+=\" \"\n    else\n      let j=$i+1\n   \
    \   while [[ $j -lt $STRING_SIZE ]]; do\n        if [[ ${1:$j:1} == \" \" ]];\
    \ then\n          j=$STRING_SIZE\n        else\n          if [[ ${1:$i:1} > ${1:$j:1}\
    \ ]]; then\n            TEMP=${1:$i:1}\n            NEW_STRING+=${1:$j:1}\n  \
    \          NEW_STRING+=${TEMP}\n            let i=$i+1\n            let j=$j+1\n\
    \          else\n            NEW_STRING+=${1:$i:1}\n            let i=$i+1\n \
    \         fi\n        fi\n      done\n      NEW_STRING+=${1:$i:1}\n    fi\n  \
    \  let i=$i+1\n  done\n  echo $NEW_STRING", "    local ret=\"\"\n    # -w flag\
    \ in echo to suppress trailing newline (if exist)\n    for word in $(echo -w \"\
    $1\"); do\n        local sorted_word=\"\"\n        for (( i=0; i<${#word}; i++\
    \ )); do\n            sorted_word=\"$sorted_word${word:$i:1}\"\n        done\n\
    \        sorted_word=$(echo -w \"$sorted_word\" | sort -u)\n        ret=\"$ret$sorted_word\"\
    \n    done\n    echo -w \"$ret\"", "    echo $1 | tr ' ' '\\n' | while read i;\
    \ do\n        echo -n $(echo $i | grep -o . | sort | tr -d '\\n')\" \"\n    done",
  "  if [ -z \"$1\" ]; then\n    echo \"No argument supplied\"\n    return 1\n  fi\n\
    \  echo $1 | tr \" \" \"\\n\" |\n  while read word; do\n    echo -n \"$(echo -n\
    \ $word | grep -o . | sort | tr -d \"\\n\") \"\n  done", "  # your code goes here\n\
    \n  echo \"$(echo \"$1\" | tr \" \" \"\\n\" | sort -u | tr \"\\n\" \" \" | tr\
    \ -d \"[:punct:]\" | tr \"[:space:]\" \"\\n\" | sort -n | tr \"\\n\" \" \")\"",
  "    local word=$1\n    local temp=\"\"\n    for (( i=0; i<${#word}; i++ )); do\n\
    \        temp=\"${temp}${word:$i:1}\"\n    done\n    echo $(echo $temp | sort\
    \ -n)", "    local word\n    local words\n    local word_sorted\n    local words_sorted\n\
    \    read -ra words <<< \"$1\"\n    for word in \"${words[@]}\"; do\n        read\
    \ -ra letters <<< \"$word\"\n        word_sorted=\"$(printf '%s\\n' \"${letters[@]}\"\
    \ | sort -f | tr -d \"\\n\")\"\n        words_sorted+=(\"$word_sorted\")\n   \
    \ done\n    printf '%s\\n' \"${words_sorted[@]}\" | tr -d '[]'", "  for word in\
    \ $1; do\n    echo -n $word | sort -n\n  done", "  # Create an array of each character\
    \ in the string\n  IFS= read -r -d '' -a chars <<<\"$1\"\n  local char_arr=\"\
    ${chars[@]}\"\n  # Append an index to each character\n  local index_char_arr=()\n\
    \  for i in \"${!chars[@]}\"; do\n    index_char_arr+=(\"$i ${chars[$i]}\")\n\
    \  done\n  # Sort based on ascii value\n  local sorted_index_char_arr=$(printf\
    \ '%s\\n' \"${index_char_arr[@]}\" | sort -k2)\n  # Remove the index\n  local\
    \ sorted_arr=$(echo \"$sorted_index_char_arr\" | cut -d' ' -f2)\n  # Array of\
    \ sorted characters\n  sorted_arr=($sorted_arr)\n  # Replace the string with the\
    \ sorted array\n  local new_char_arr=()\n  for i in \"${!chars[@]}\"; do\n   \
    \ new_char_arr+=(\"${sorted_arr[$i]}\")\n  done\n  # Create string\n  local new_str=$(echo\
    \ \"${new_char_arr[@]}\" | tr -d ' ')\n  echo \"$new_str\"", "    # Remove if\
    \ statement\n    # Then use echo to return the result\n    echo $(for i in $1;\
    \ do echo $i | sed -r 's/([a-zA-Z])/\\1\\n/g' | sort | tr -d '\\n'; done)", " \
    \   local temp_str=\"\"\n    for word in $1; do\n        if [ -z $temp_str ];\
    \ then\n            temp_str=$(echo $word | grep -o . | sort | tr -d '\\n')\n\
    \        else\n            temp_str=$temp_str\" \"$(echo $word | grep -o . | sort\
    \ | tr -d '\\n')\n        fi\n    done\n    echo $temp_str", "    local string=\"\
    $1\"\n    local word\n    local result=\"\"\n    for word in ${string}; do\n \
    \       result+=\"$(echo ${word} | grep -o . | sort | tr -d '\\n')\"\n    done\n\
    \    echo ${result}", "    first_word=1\n    for word in $1; do\n        if [[\
    \ $first_word -eq 1 ]]; then\n            first_word=0\n        else\n       \
    \     echo -n \" \"\n        fi\n        echo -n $(echo -n $word | fold -w1 |\
    \ sort | tr -d '\\n')\n    done\n    echo \"\"", "    local str=$1\n    local\
    \ tmp=''\n    for word in $str; do\n        # Remove everything that is not alpha\
    \ from the word\n        # then sort it.\n        tmp+=`echo $word | sed 's/[^a-zA-Z]//g'\
    \ | sort -f`\n    done\n    echo $tmp", "  local arg=$1\n  local first_space=${arg%%\
    \ *}\n  if [ \"$first_space\" == \"$arg\" ]; then\n    echo $arg | fold -w1 |\
    \ sort | tr -d '\\n'\n  else\n    local first_word=${arg%% *}\n    echo $first_word\n\
    \    echo $arg | cut -d' ' -f2- | anti_shuffle\n  fi", "  local input=$1\n  local\
    \ output=\"\"\n  local prev_char=\"\"\n  local ascii=0\n  local char=\"\"\n  for\
    \ ((i=0; i<${#input}; i++)); do\n    char=${input:$i:1}\n    ascii=$(printf \"\
    %d\" \"'$char\")\n    if [[ $ascii -eq 32 ]]; then\n      output+=\" \"\n    else\n\
    \      prev_char=$char\n      for ((j=i+1; j<${#input}; j++)); do\n        char=${input:$j:1}\n\
    \        ascii=$(printf \"%d\" \"'$char\")\n        if [[ $ascii -gt 32 ]]; then\n\
    \          prev_char_ascii=$(printf \"%d\" \"'$prev_char\")\n          if [[ $ascii\
    \ -lt $prev_char_ascii ]]; then\n            prev_char=${input:$j:1}\n       \
    \     input=${input:0:$j}${input:$j+1}${input:$j:1}${input:$j+2}\n          fi\n\
    \        fi\n      done\n      output+=$prev_char\n    fi\n  done\n  echo $output",
  "  declare -a ordered_string=()\n  for word in $1; do\n    ordered_string+=($(echo\
    \ \"$word\" |\n      fold -w1 |\n      sort |\n      tr -d '\\n'))\n  done\n \
    \ echo \"${ordered_string[@]}\"", "    # remove any spaces at beginning and end\
    \ of string\n    stripped=$(trim \"$1\")\n    # split on space\n    IFS=\" \"\n\
    \    # create array with words in order\n    words=($stripped)\n    # join words\
    \ with space\n    unset IFS\n    sorted=$(trim \"$(shuf \"${words[@]}\")\")\n\
    \    echo \"$sorted\"", "    res=\"\"\n    for word in $1; do\n        res=\"\
    $res $(echo $word | fold -w1 | sort -f)\"\n    done\n    echo $res", "    local\
    \ string=\"$1\"\n    local new_string=\"\"\n    for word in ${string}; do\n  \
    \      new_string=\"${new_string} $(echo \"${word}\" | sort -V)\"\n    done\n\
    \    echo \"${new_string}\"", "    # Put your code here\n    # ...\n    IFS='\
    \ '\n    arr=($1)\n    IFS=''\n    for i in ${arr[@]};\n    do\n        sorted=$(echo\
    \ $i | grep -o . | sort | tr -d '\\n')\n        space=$(echo $i | grep ' ')\n\
    \        if [ \"$space\" == ' ' ]; then\n            echo -n \"$space\"\n    \
    \    fi\n        echo -n \"$sorted\"\n    done\n    echo -n \"\\n\"", "    local\
    \ chars=\"\"\n    for i in $(seq $(( 0x20 )) $(( 0x7e ))); do\n        chars+=$(printf\
    \ \"\\\\$(printf '%03o' \"$i\")\")\n    done\n    echo \"$1\" | tr \"$chars\"\
    \ \"$(echo \"$chars\" | sed 's/./&\\n/g' | sort -g | tr -d '\\n')\"", "      \
    \  local -i n=0\n        for word in $1; do\n                sorted[n]=$(echo\
    \ $word | fold -w1 | sort | tr -d '\\n')\n                n=$n+1\n        done\n\
    \        echo ${sorted[@]}", "    local result=\"\";\n    for word in $1; do\n\
    \        local sorted_chars=\"\";\n        for (( i=0; i<${#word}; i++ )); do\n\
    \            sorted_chars+=\"${word:$i:1}\";\n        done;\n        sorted_chars=$(echo\
    \ \"$sorted_chars\" | grep -o . | sort -n | tr -d '\\n');\n        result+=\"\
    $sorted_chars\";\n    done;\n    echo \"$result\";", "  echo \"$1\" | tr ' ' '\\\
    n' | tr -s '[:blank:]' |\n  while read word; do\n    sorted_word=\"$(echo \"$word\"\
    \ | fold -w1 | sort -n | tr -d '\\n')\"\n    echo -n \"$sorted_word \"\n  done",
  "    echo $1 | tr ' ' '\\n' | while read word; do\n        echo -n \"$(echo $word\
    \ | grep -o . | sort -n | tr -d '\\n') \"\n    done", "  IFS=$'\\n'\n  arr=($(echo\
    \ \"$1\" | fold -w1 | sort -d | tr -d '\\n'))\n  echo \"${arr[*]}\"", "    # Create\
    \ a new string, will be the result\n    # Create an array of words in the sentence\n\
    \    local NEW_STRING=\"\"\n    local WORDS=($(echo $1 | tr \" \" \"\\n\"))\n\
    \    for WORD in ${WORDS[@]}; do\n        # For each word in the array, save the\
    \ first character\n        # and erase it from the word.\n        local FIRST_CHAR=${WORD:0:1}\n\
    \        local SUB_WORD=${WORD:1}\n        # Append the first character to the\
    \ new string\n        NEW_STRING+=$FIRST_CHAR\n        # Sort the rest of the\
    \ characters and append them to the new string\n        NEW_STRING+=$(echo -n\
    \ $SUB_WORD | tr -d \"\\n\" | fold -w1 | sort | tr -d \"\\n\")\n    done\n   \
    \ echo $NEW_STRING", "  echo \"$1\" | tr ' ' '\\n' |\n  while read w; do\n   \
    \ echo -n \"$w\" | fold -w1 | sort | tr -d '\\n'\n    echo -n ' '\n  done | tr\
    \ -d ' '", "    local tmp=\"\"\n    local word=\"\"\n    local IFS=\" \"\n   \
    \ for word in $1; do\n        tmp=\"$tmp $(echo $word | sort)\"\n    done\n  \
    \  echo \"$tmp\"", "  local x\n  local tmp\n  for x in ${1// / }; do\n    echo\
    \ $x | grep -q -E '[a-zA-Z]' || continue\n    echo $x | fold -w1 | sort | paste\
    \ -s -d \"\"\n  done", "    # ASSUMPTION: words are separated by any number of\
    \ spaces\n    #             (which are replaced by 1 space during printing).\n\
    \    local string=\"$1\"\n    local -a words\n    local i=0\n\n    while read\
    \ -r word; do\n        words[i++]=\"$word\"\n    done <<< \"$(echo \"$string\"\
    \ | sed 's/ /\\n/g')\"\n\n    for (( i=0; i<${#words[@]}; i++ )); do\n       \
    \ local word=${words[i]}\n        local word_len=${#word}\n        local -a char_arr\n\
    \        local j=0\n\n        while read -r char; do\n            char_arr[j++]=\"\
    $char\"\n        done <<< \"$(echo \"$word\" | sed 's/./&\\n/g')\"\n\n       \
    \ for (( j=0; j<${#char_arr[@]}; j++ )); do\n            local min_index=$j\n\
    \            local min_value=${char_arr[j]}\n\n            for (( k=j+1; k<${#char_arr[@]};\
    \ k++ )); do\n                if [ ${char_arr[k]} -lt ${min_value} ]; then\n \
    \                   min_index=$k\n                    min_value=${char_arr[k]}\n\
    \                fi\n            done\n\n            if [ $min_index -ne $j ];\
    \ then\n                local temp=${char_arr[j]}\n                char_arr[j]=${char_arr[min_index]}\n\
    \                char_arr[min_index]=$temp\n            fi\n        done\n\n \
    \       for (( j=0; j<${#char_arr[@]}; j++ )); do\n            printf \"%c\" \"\
    ${char_arr[j]}\"\n        done\n\n        [ $i -lt $(( ${#words[@]} - 1 )) ] &&\
    \ printf \" \"\n    done", "    local -a word_a\n    local word\n    for word\
    \ in ${1}; do\n        word_a+=($(echo ${word} | grep -o . | sort -r))\n    done\n\
    \    echo \"${word_a[@]}\"", "    local STR=$1\n    local WORDS=$(echo $STR |\
    \ tr ' ' '\\n')\n    local NEW_WORDS=\"\"\n    for WORD in $WORDS; do\n      \
    \  local NEW_WORD=$(echo $WORD | fold -w1 | sort | tr -d '\\n')\n        NEW_WORDS=\"\
    $NEW_WORDS $NEW_WORD\"\n    done\n    echo $NEW_WORDS", "    # your code here\n\
    \    for WORD in $1\n    do\n      for ((i=0; i<${#WORD}; i++))\n      do\n  \
    \      CHAR=${WORD:$i:1}\n        ORDER+=$(printf \"%d\\\\n\" \\'\"$CHAR\"\\'\
    \ | xargs printf \"%c\" | sort -n -u | xargs printf \"%d\\\\n\" | xargs printf\
    \ \"%c\")\n      done\n      echo -n \"$ORDER \"\n      ORDER=\"\"\n    done\n\
    \    echo", "\tlocal pattern='\\([[:alnum:]]*\\)'\n\tlocal string=$1\n\tlocal\
    \ result=''\n\techo $string | while read -d ' ' word; do\n\t\tresult+=$(echo $word\
    \ | grep -Eo $pattern | sort -u | tr -d '\\n')\n\t\tresult+=' '\n\tdone\n\techo\
    \ $result", "\tfor word in $1\n\tdo\n\t\tnew_word=''\n\t\tfor (( i=0; i<${#word};\
    \ i++ ))\n\t\tdo\n\t\t\tnew_word+=${word:$i:1}\n\t\tdone\n\t\techo $new_word |\
    \ grep -o . | sort | tr -d '\\n'\n\tdone", "    echo $1 | awk '{for(i=1;i<=NF;i++)\
    \ {s=$i; gsub(/./,\"&\\n\",s); print s | \"sort -n\" | tr -d \"\\n\" } print \"\
    \"}'", "  local new_string=\"\"\n  local word=\"\"\n  local chars_in_word=\"\"\
    \n  local space=\"\"\n  local char=\"\"\n  while [ ! -z \"$1\" ]; do\n    word=$(echo\
    \ \"$1\" | cut -d \" \" -f 1)\n    space=$(echo \"$1\" | cut -d \" \" -f 2-)\n\
    \    chars_in_word=$(echo \"$word\" | fold -w 1)\n    while [ ! -z \"$chars_in_word\"\
    \ ]; do\n      char=$(echo \"$chars_in_word\" | cut -c 1)\n      chars_in_word=$(echo\
    \ \"$chars_in_word\" | cut -c 2-)\n      new_string=$(echo \"$new_string$char\"\
    \ | fold -w 1 | sort | tr -d \"\\n\")\n    done\n    new_string=\"$new_string\
    \ $space\"\n    new_string=$(echo \"$new_string\" | cut -d \" \" -f 2-)\n    new_string=$(echo\
    \ \"$new_string\" | cut -d \" \" -f 1)\n    new_string=\"$new_string \"\n    new_string=$(echo\
    \ \"$new_string\" | sed 's/ //g')\n    new_string=$(echo \"$new_string\" | cut\
    \ -d \" \" -f 2-)\n    new_string=$(echo \"$new_string\" | cut -d \" \" -f 1)\n\
    \    new_string=\"$new_string \"\n    new_string=$(echo \"$new_string\" | sed\
    \ 's/ //g')\n    new_string=$(echo \"$new_string\" | cut -d \" \" -f 2-)\n   \
    \ new_string=$(echo \"$new_string\" | cut -d \" \" -f 1)\n    new_string=\"$new_string\
    \ \"\n    new_string=$(echo \"$new_string\" | sed 's/ //g')\n    new_string=$(echo\
    \ \"$new_string\" | cut -d \" \" -f 2-)\n    new_string=$(echo \"$new_string\"\
    \ | cut -d \" \" -f 1)\n    new_string=\"$new_string \"\n    new_string=$(echo\
    \ \"$new_string\" | sed", "    input=\"$1\"\n    output=\"\"\n    for word in\
    \ $input; do\n        last_char=${word: -1}\n        first_char=${word:0:1}\n\
    \        if [[ $last_char =~ [^0-9a-zA-Z] ]]; then\n            last_char=\"\"\
    \n        fi\n        if [[ $first_char =~ [^0-9a-zA-Z] ]]; then\n           \
    \ first_char=\"\"\n        fi\n        output+=\"$first_char$(echo -n $word |\
    \ tr -dc '[:alnum:]' | sed -e 's/\\(.\\)/\\1\\n/g' | sort | uniq | tr -d '\\n')$last_char\
    \ \"\n    done\n    echo \"$output\"", "\tlocal result=\"\"\n\twhile [ $# -gt\
    \ 0 ]; do\n\t\tif [ -z \"${1// }\" ]; then\n\t\t\t# blank space\n\t\t\tresult=\"\
    ${result} \"\n\t\telse\n\t\t\t# not blank\n\t\t\tresult=\"${result}$(echo \"$1\"\
    \ | fold -w1 | sort | tr -d '\\n')\"\n\t\tfi\n\t\tshift\n\tdone\n\techo \"$result\"",
  "    local -a words\n    local word\n    while IFS=' ' read -ra words; do\n    \
    \    for word in \"${words[@]}\"; do\n            echo -n \"${word}\" | grep -oE\
    \ \"[a-zA-Z]\" | sort | tr -d '\\n'\n        done\n        echo -n ' '\n    done\
    \ <<< \"$1\"", "    local string=$1\n    local output=\"\"\n    # First split\
    \ the string into words, and then sort each word\n    while read word; do\n  \
    \      # -u here means to sort the characters in each word in\n        # ascending\
    \ order\n        output=\"$output $(echo \"$word\" | sort -u)\"\n    done <<<\
    \ \"$(echo \"$string\" | tr ' ' '\\n')\"\n    echo \"$output\"", "  declare -A\
    \ tmp\n  declare -A temp\n  declare -A word\n  declare -A word2\n  declare -A\
    \ final\n  declare -A words\n  declare -A words2\n  declare -a sorted_tmp\n  declare\
    \ -a sorted_tmp2\n  declare -a sorted_tmp3\n  declare -a sorted_tmp4\n  index=0\n\
    \  index2=0\n  index3=0\n  index4=0\n  index5=0\n  index6=0\n  index7=0\n  index8=0\n\
    \  index9=0\n  index10=0\n  index11=0\n  index12=0\n  index13=0\n  index14=0\n\
    \  index15=0\n  for i in $(echo \"$1\" | fold -w1); do\n    if [[ \"$i\" =~ [[:space:]]\
    \ ]]; then\n      ((index2++))\n      words[$index2]=$index\n      ((index5++))\n\
    \      words2[$index5]=$index\n      ((index7++))\n      words2[$index7]=$index\n\
    \      ((index9++))\n      words2[$index9]=$index\n      ((index11++))\n     \
    \ words2[$index11]=$index\n      ((index13++))\n      words2[$index13]=$index\n\
    \      ((index15++))\n      words2[$index15]=$index\n    else\n      ((index++))\n\
    \      tmp[$index]=$i\n      ((index3++))\n      temp[$index3]=$i\n      ((index4++))\n\
    \      word[$index4]=$i\n      ((index6++))\n      word2[$index6]=$i\n      ((index8++))\n\
    \      word2[$index8]=$i\n      ((index10++))\n      word2[$index10]=$i\n    \
    \  ((index12++))\n      word2[$index12]=$i\n      ((index14++))\n      word2[$index14]=$i\n\
    \    fi\n  done\n  sorted_tmp=($(for i in ${!tmp[@]}; do\n    echo $i:${tmp[$i]}\n\
    \  done | sort -", "    if [ -z \"$1\" ]; then\n        echo \"usage: $(basename\
    \ $0) \\\"string\\\"\"\n        exit\n    fi\n    local result=\"$1\"\n    # Split\
    \ into words\n    local word_list=($(echo \"$result\" | tr ' ' '\\n'))\n    local\
    \ word\n    local new_word\n    for word in \"${word_list[@]}\"; do\n        new_word=\"\
    $(echo \"$word\" | fold -w1 | sort | tr -d '\\n')\"\n        result=${result/$word/$new_word}\n\
    \    done\n    echo \"$result\"", "    local IFS=' '\n    read -r -a words <<<\
    \ \"$1\"\n    local sentence=''\n    for word in \"${words[@]}\"; do\n       \
    \ word=$(echo \"$word\" | grep -o . | sort -b | tr -d '\\n')\n        sentence+=\"\
    $word \"\n    done\n    echo \"$sentence\"", "    # For example:\n    # >>> anti_shuffle\
    \ \"Hello World\\!\\!\\!\"\n    #\n    # 1. Get words\n    # >>> anti_shuffle\
    \ \"Hello World\\!\\!\\!\" | cut -d' ' -f1\n    # Hello\n    #\n    # 2. Get special\
    \ characters\n    # >>> anti_shuffle \"Hello World\\!\\!\\!\" | cut -d' ' -f2-\n\
    \    # \\!\\!\\!\n    #\n    # 3. Sort the letters\n    # >>> echo \"hello\" |\
    \ fold -w1 | sort | tr -d '\\n'\n    # ehllo\n    #\n    # 4. Remove the \\ before\
    \ special characters\n    # >>> echo \"\\!\\!\\!\" | sed -e 's/\\\\//g'\n    #\
    \ !!!\n    #\n    # 5. Combine the result\n    # >>> anti_shuffle \"Hello World\\\
    !\\!\\!\" | cut -d' ' -f1 | fold -w1 | sort | tr -d '\\n'\n    # Hello\n    #\
    \ >>> anti_shuffle \"Hello World\\!\\!\\!\" | cut -d' ' -f2- | sed -e 's/\\\\\
    //g'\n    # !!!\n    #\n    # 6. Put all together\n    # >>> anti_shuffle \"Hello\
    \ World\\!\\!\\!\" | cut -d' ' -f1 | fold -w1 | sort | tr -d '\\n'\n    # Hello\n\
    \    # >>> anti_shuffle \"Hello World\\!\\!\\!\" | cut -d' ' -f2- | sed -e 's/\\\
    \\//g'\n    # !!!\n    # >>> anti_shuffle \"Hello World\\!\\!\\!\" | cut -d' '\
    \ -f1 | fold -w1 | sort | tr -d '\\n' \\\n    # > anti_shuffle \"Hello World\\\
    !\\!\\!\" | cut -d' ' -f2- | sed -e 's/\\\\//g'\n    # Hello !!!\n    echo $1\
    \ | cut -d' ' -f1 | fold -w1 | sort | tr -d '\\n' \\\n    > echo $1 | cut", " \
    \   echo $1 | tr ' ' '\\n' | \\\n        while read line; do\n            echo\
    \ $line | \\\n                fold -w1 | \\\n                sort | \\\n     \
    \           tr -d '\\n'\n            echo ' '\n        done | \\\n        tr -d\
    \ '\\n'", "    # write your code here\n    words=$(echo $1 | tr \" \" \"\\n\"\
    )\n    # echo \"words is $words\"\n    # IFS=$'\\n'\n    IFS=\" \"\n    result=\"\
    \"\n    for word in $words\n    do\n        result=$result$(echo $word | grep\
    \ -o . | sort | tr -d \"\\n\")\n    done\n    echo $result", "    echo $1 | tr\
    \ ' ' '\\n' | sort -k1.2,1.2 -r | tr '\\n' ' '", "    # The function checks if\
    \ the input is empty. If so, it returns the input.\n    if [ -z \"$1\" ]; then\n\
    \        echo -n $1\n        return\n    fi\n    # This is the new string, where\
    \ all the characters are sorted.\n    local newstring=\"\"\n    # The for loop\
    \ splits the string into the words based on spaces\n    # and iterates over them.\n\
    \    for word in $1; do\n        # This is the new word, where all the characters\
    \ are sorted.\n        local newword=\"\"\n        # The following for loop iterates\
    \ over each character of the word.\n        for (( i=0; i<${#word}; i++ )); do\n\
    \            # $char contains the current character\n            local char=${word:$i:1}\n\
    \            # The following if statement checks if $newword is empty.\n     \
    \       # It adds $char to $newword.\n            if [ -z \"$newword\" ]; then\n\
    \                newword=\"$char\"\n            # The following else statement\
    \ adds $char to $newword in an ordered way.\n            else\n              \
    \  for (( j=0; j<${#newword}; j++ )); do\n                    # $ch contains the\
    \ current character of $newword\n                    local ch=${newword:$j:1}\n\
    \                    # This if statement checks if $char is smaller than $ch\n\
    \                    # based on ascii value.\n                    if [ \"$char\"\
    \ \\< \"$ch\" ]; then\n                        # $newword is then splitted into\
    \ 2 parts:\n                        # a) $newword1: First part of $newword (before\
    \ $ch)\n                        # b) $newword2: Last part of $newword (after $ch)\n\
    \                        local newword1=${newword:0:$j}\n                    \
    \    local newword2=${newword:$j}\n                        # $newword is replaced\
    \ by the combination of\n                        # (a) + $char + (b)\n       \
    \                 newword=\"$newword1$char$newword2\"\n                      \
    \  # The inner loop is ended in order to start the next iteration\n          \
    \              # of the outer loop.\n                        break\n         \
    \           fi\n                    # This if statement checks if the last character\
    \ of $newword\n                    # is reached. If so, $", "    local result=\"\
    \"\n    for word in $1; do\n        local s=$(printf \"%s\" \"$word\" | grep -Eo\
    \ . | sort | tr -d \"\\n\")\n        result=\"$result $s\"\n    done\n    printf\
    \ \"%s\" \"$result\"", '  # TODO: Write your solution here.', "\tlocal newstring=\"\
    \"\n\t# Iterate over each word in the string\n\tfor word in $1; do\n\t\tlocal\
    \ newword=\"\"\n\t\tlocal i=0\n\t\tlocal chars=\"\"\n\t\t# Get all the characters\
    \ of the word\n\t\tfor ((i=0; i<${#word}; i++)); do\n\t\t\tchars=\"$chars${word:$i:1}\"\
    \n\t\tdone\n\t\t# Sort the characters\n\t\tchars=($(echo $chars | grep -o . |\
    \ sort))\n\t\t# Create the new word\n\t\tfor ((i=0; i<${#chars[@]}; i++)); do\n\
    \t\t\tnewword=\"$newword${chars[$i]}\"\n\t\tdone\n\t\t# Add the new word to the\
    \ new string\n\t\tnewstring=\"$newstring $newword\"\n\tdone\n\t# Print the new\
    \ string\n\techo $newstring", "\t# first, trim double space to only one space\n\
    \t# then, split string by space to an array\n\t# then, sort characters in each\
    \ word\n\t# finally, join the array by space to a string\n\tlocal STRING=$(echo\
    \ -e \"$1\" | tr -s ' ' | tr ' ' '\\n' | sort -u | tr '\\n' ' ')\n\techo \"$STRING\"",
  "  new_string=\"\"\n  for word in $(echo $1 | tr \" \" \"\\n\"); do\n    new_string+=\"\
    \ $(echo $word | fold -w1 | sort -n | tr -d \"\\n\")\"\n  done\n  echo \"${new_string:1}\"",
  "\tlocal string=$1\n\tlocal words=$(echo $string | tr \" \" \"\\n\")\n\tlocal new_string=\"\
    \"\n\tfor word in $words; do\n\t\tnew_string=\"$new_string $(anti_shuffle_word\
    \ $word)\"\n\tdone\n\techo $new_string", "  local result=\"\"\n  for word in $1;\
    \ do\n    if [[ $word =~ [^[:space:]] ]]; then\n      result=$result$(echo $word\
    \ | tr -d '\\n' | rev | sort | rev)\n    else\n      result=$result$word\n   \
    \ fi\n  done\n  echo $result", "    echo $1 | awk '{for(i=1;i<=NF;i++)\n     \
    \                      {\n                               if(i==1)\n          \
    \                         printf(\"%s\",$i)\n                               else\n\
    \                                   printf(\" %s\",$i)\n                     \
    \      }\n                       }' | awk '{\n                           for(i=1;i<=NF;i++)\n\
    \                           {\n                               split($i, array,\
    \ \"\")\n                               asort(array)\n                       \
    \        if(i==1)\n                                   {\n                    \
    \                   for(j=1;j<=length($i);j++)\n                             \
    \              printf(\"%s\",array[j])\n                                   }\n\
    \                               else\n                                   {\n \
    \                                      printf(\" \")\n                       \
    \                for(j=1;j<=length($i);j++)\n                                \
    \           printf(\"%s\",array[j])\n                                   }\n  \
    \                         }\n                       }'", "  if [ $# -ne 1 ]; then\n\
    \    echo \"usage: anti_shuffle <input string>\"\n    return\n  fi\n  if [ -z\
    \ \"$1\" ]; then\n    echo \"input string can't be empty\"\n    return\n  fi\n\
    \  echo \"$1\" | sed -e 's/\\([a-zA-Z]\\+\\)/\\1 \\n/g' | sort | cut -d ' ' -f2\
    \ | paste -sd \" \"", '    echo "${1//[a-z]/*}"', "    # Implement here\n    #\n\
    \    # Hint:\n    #   - Use a for loop to iterate over each words.\n    #   -\
    \ If a word contains a space, use double quote to surround it\n    #     so that\
    \ it is treated as a single word.\n    #   - Use the following command to sort\
    \ the characters:\n    #     sorted=\"$(echo $word | grep -o . | sort | tr -d\
    \ '\\n')\"\n    #     - `grep -o .` prints every character from the string\n \
    \   #     - `sort` sorts the letters\n    #     - `tr -d '\\n'` strips the newline\
    \ inserted by the previous commands\n    #   - After sorting all the characters,\
    \ use the new word to replace\n    #     the old word in the string.\n\n    #\
    \ TODO: Remove the line below and write your code here\n    echo \"Unimplemented\"",
  "    if [ \"$#\" -eq 1 ]; then\n        local str=\"$1\"\n\n        while [[ \"\
    $str\" =~ ([a-zA-Z]+)( )? ]]; do\n            local a=${BASH_REMATCH[1]}\n   \
    \         local b=${BASH_REMATCH[2]}\n            local str=${str#*${BASH_REMATCH[0]}}\n\
    \            echo -n \"$(echo $a | grep -o . | sort | tr -d '\\n')$b\"\n     \
    \   done\n    fi", "\tresult=\"\"\n\tIFS=' ' read -ra words <<< \"$1\"\n\tfor\
    \ word in \"${words[@]}\"; do\n\t\tsorted_word=$(echo $word | fold -w1 | sort\
    \ | tr -d '\\n')\n\t\tresult+=\"$sorted_word \"\n\tdone\n\techo $result", "  \
    \  local anti_shuffled_str=\"\"\n    for word in $1; do\n        # Add a space\
    \ if the last char is not a space,\n        # and a space is needed.\n       \
    \ if [[ ${anti_shuffled_str:(-1)} != \" \" ]] && [[ $word == \" \" ]]; then\n\
    \            anti_shuffled_str+=\" \"\n        elif [[ $word != \" \" ]]; then\n\
    \            # Split words into a chars array\n            local chars=($(echo\
    \ \"$word\" | grep -o .))\n            local anti_shuffled_word=\"\"\n       \
    \     # Sort the chars array\n            IFS=$'\\n' chars=($(sort <<<\"${chars[*]}\"\
    ))\n            # Join the chars array to a word\n            anti_shuffled_word=\"\
    $(echo -e \"${chars[*]}\" | tr -d '[:space:]')\"\n            anti_shuffled_str+=\"\
    $anti_shuffled_word\"\n        fi\n    done\n    echo \"$anti_shuffled_str\"",
  "    # START SOLUTION\n    res=''\n    while read word; do\n        if [ -z \"$res\"\
    \ ]; then\n            res=\"$(echo \"$word\" | fold -w1 | sort | tr -d '\\n')\"\
    \n        else\n            res=\"$res $(echo \"$word\" | fold -w1 | sort | tr\
    \ -d '\\n')\"\n        fi\n    done <<< \"$(echo \"$1\" | tr ' ' '\\n')\"\n  \
    \  echo \"$res\"\n    # END SOLUTION", "  echo $1 | tr ' ' '\\n' | awk '{print\
    \ $1 | \"sort\"}' | tr '\\n' ' '", "  for word in $1; do\n    res=\"$res $(echo\
    \ \"$word\" | grep -o . | sort -r | tr -d '\\n')\"\n  done\n  echo \"$res\"",
  "  local str=\"$1\"\n  local OLD_IFS=\"$IFS\"\n  IFS=\" \"\n  while [ $# -gt 0 ];\
    \ do\n    # Change IFS back to a space and save it in OLD_IFS\n    IFS=\"$OLD_IFS\"\
    \n    # Sort the string and display the result\n    echo -n \"$(echo \"$1\" |\
    \ fold -w1 | sort | paste -sd '')\"\n    # Change IFS to a space\n    IFS=\" \"\
    \n    # Move the argument list forward by one argument\n    shift\n  done\n  #\
    \ Change IFS back to a space and save it in OLD_IFS\n  IFS=\"$OLD_IFS\"\n  # Just\
    \ to insert a new line at the end\n  echo", "    local SPACE=' '\n    if [[ \"\
    $1\" == \"$SPACE\" ]]; then\n        echo \"$SPACE\"\n        return 0\n    fi\n\
    \    local word_list=()\n    local word=\"\"\n    local char\n    local -i i=0\n\
    \    for (( i=0; i<${#1}; i++ )); do\n        char=\"${1:$i:1}\"\n        if [[\
    \ \"$char\" == \"$SPACE\" ]]; then\n            # store one word, the current\
    \ word ends with SPACE\n            word_list+=(\"$word\")\n            word=\"\
    \"\n        else\n            word=\"$word$char\"\n        fi\n    done\n    #\
    \ store the last word\n    word_list+=(\"$word\")\n    # sort chars in a word\n\
    \    local word_list_ord=()\n    for word in \"${word_list[@]}\"; do\n       \
    \ #print_debug \"word=$word\"\n        #print_debug \"anti_shuffle_word $word\"\
    \n        local word_ord=\"$(anti_shuffle_word \"$word\")\"\n        word_list_ord+=(\"\
    $word_ord\")\n    done\n    # merge sorted words\n    local str=\"\"\n    for\
    \ word in \"${word_list_ord[@]}\"; do\n        if [[ \"$str\" == \"\" ]]; then\n\
    \            str=\"$word\"\n        else\n            str=\"$str$SPACE$word\"\n\
    \        fi\n    done\n    echo \"$str\"", "    local result=\"\"\n    for word\
    \ in $(echo $1 | tr \" \" \"\\n\"); do\n        for i in $(echo $word | grep -o\
    \ .); do\n            result=\"$result$i\"\n        done\n        result=\"$result$(echo\
    \ $word | tr -d [:alpha:])\"\n    done\n    echo $result", "    local -r str=\"\
    $1\"\n    local -r arr=($(echo \"$str\" | tr ' ' '\\n'))\n    local -r sorted=($(printf\
    \ \"%s\\n\" \"${arr[@]}\" | sort -n | tr '\\n' ' '))\n    local -r str_len=${#str}\n\
    \    local -r sorted_len=${#sorted[@]}\n    local -r diff=$((sorted_len - str_len))\n\
    \    local ret=()\n    local index=0\n    local i=0\n    local sorted_index=0\n\
    \    for (( ; i < $str_len; i++)); do\n        local c=\"${str:$i:1}\"\n     \
    \   if [[ \"$c\" =~ [A-Za-z] ]]; then\n            ret+=(\"${sorted[$sorted_index]}\"\
    )\n            sorted_index=$((sorted_index + 1))\n        else\n            ret+=(\"\
    $c\")\n        fi\n    done\n    echo \"${ret[@]}\"", "  local -a result\n  for\
    \ word in $1; do\n    result+=(\"$(anti_shuffle_word \"$word\")\")\n  done\n \
    \ echo \"${result[@]}\"", "    # TODO: Implement this function.\n    # The below\
    \ implementation is a sample implementation.\n    # Feel free to remove it.\n\
    \    echo \"$1\"", "  printf \"%s\" \"$1\" | tr ' ' '\\n' | tr -d '[:punct:]'\
    \ | sort -f | tr '\\n' ' '", "  local -r output=$(echo \"$1\" | tr ' ' '\\n' |\
    \ sort -s -k1 -n | xargs)\n  echo \"$output\"", "  echo $1 | tr ' ' '\\n' | tr\
    \ -s 'A-Za-z0-9' '\\n' | sort -f | tr -d '\\n' | tr 'A-Za-z0-9' ' '", "  echo\
    \ \"$1\" |\n    tr \" \" \"\\n\" |\n    while read x; do\n      echo \"$x\" |\n\
    \        grep -o . |\n        sort |\n        tr -d \"\\n\"\n      echo -n \"\
    \ \"\n    done |\n    tr -d \"\\n\"", "  # Input a string.\n  input=$1\n  # Remove\
    \ all special characters and blank spaces and\n  # sort the characters.\n  input=`echo\
    \ $input | tr -cd [:alpha:] | sed 's/ //g' | sort`\n  # Reorder the input string\
    \ so that it's the same order\n  # as the input string.\n  for((i=0;i<${#input};i++));\
    \ do\n    char=`echo $1 | tr -cd [:alpha:] | sed 's/ //g' | cut -c$((i+1))`\n\
    \    if [[ ${input} == *${char}* ]]; then\n      # Remove the found character\
    \ from the input string.\n      input=`echo $input | sed \"s/${char}//g\"`\n \
    \     # Append the found character to the front of the new string.\n      new_input=\"\
    ${char}${new_input}\"\n    fi\n  done\n  # Add the blank spaces back in the same\
    \ position as the original string.\n  new_input=`echo $new_input | sed \"s/./$&\
    \ /g\"`\n  # Print the new string.\n  echo $new_input", "  # Check if number of\
    \ arguments is 1\n  if [ $# -ne 1 ]; then\n    echo 'Number of arguments is not\
    \ 1'\n    return 1\n  fi\n\n  # Using Bash string manipulation\n  local RESULT=\"\
    \"\n  local OUTPUT=\"\"\n  local SENTENCE=\"$1\"\n  while [[ ${SENTENCE} =~ ([a-z]*)|([[:punct:]]+)\
    \ ]]; do\n    OUTPUT+=${BASH_REMATCH[0]}\n    # Save the part of SENTENCE after\
    \ the current match\n    SENTENCE=${SENTENCE:${#BASH_REMATCH[0]}}\n  done\n  for\
    \ word in ${OUTPUT}; do\n    if [[ \"${word}\" =~ [a-z] ]]; then\n      word=$(printf\
    \ \"%s\\n\" \"${word}\" | sort)\n    fi\n    RESULT+=\"${word}\"\n  done\n  echo\
    \ \"${RESULT}\"", "    if [[ $# != 1 ]]; then\n        echo \"Usage: $0 string\"\
    \n        return 1\n    fi\n    local -a words=($(echo $1 | tr ' ' '\\n'))\n \
    \   local sorted=\n    for word in \"${words[@]}\"; do\n        local -a letters=($(echo\
    \ $word | tr ' ' '\\n'))\n        sorted+=$(for letter in \"${letters[@]}\"; do\n\
    \            echo $letter\n        done | sort -k1 | tr '\\n' ' ')\n        sorted+=\"\
    \ \"\n    done\n    echo \"$sorted\"", "    local words new_words;\n    # We are\
    \ expecting an argument\n    [ $# -eq 1 ] || return 1\n    # We are expecting\
    \ a non-empty string\n    [ -n \"$1\" ] || return 1\n    words=($(echo \"$1\"\
    \ | tr \" \" \"\\n\"))\n    new_words=($(for word in \"${words[@]}\"; do\n   \
    \                 echo \"$word\" | fold -w1 | sort -n | tr -d \"\\n\"\n      \
    \          done))\n    echo \"${new_words[@]}\" | tr \" \" \" \"", "    local\
    \ result=''\n    for word in $1; do\n        local chars=$(echo \"$word\" | sed\
    \ -e 's/./&\\n/g' | sort -f | tr -d '\\n')\n        result=\"$result$chars\"\n\
    \    done\n    echo \"$result\"", "  echo \"$1\" | tr ' ' '\\n' | sort -r | tr\
    \ '\\n' ' '", "  local spaces\n  local result=''\n  local word\n  local -i length\n\
    \  local -i i\n  local -i j\n  local -i k\n  local char\n  local -a temp\n  local\
    \ -i temp_length\n  local -i ascii_value\n\n  # Finds the number of spaces in\
    \ the string and\n  # store it in the variable spaces\n  spaces=$(echo \"$1\"\
    \ | awk '{print gsub(/ /, \"\")}')\n\n  word=''\n  temp=()\n  for (( i=0; i<${#1};\
    \ i++ )); do\n    # Stores the current character in a variable\n    char=${1:$i:1}\n\
    \n    # If the current character is not space then add\n    # the character to\
    \ the variable word\n    if [[ \"$char\" != ' ' ]]; then\n      word+=\"$char\"\
    \n    else\n      # Sorts the characters in word based on their\n      # ascii\
    \ value in ascending order\n      length=${#word}\n      for (( j=0; j<length;\
    \ j++ )); do\n        temp_length=${#temp[@]}\n        temp+=(\"${word:$j:1}\"\
    )\n        for (( k=0; k<temp_length; k++ )); do\n          ascii_value=$(printf\
    \ \"%d\" \"'${temp[$k]}\")\n          if [[ $ascii_value -gt $(printf \"%d\" \"\
    '${temp[$((k+1))]}\") ]]; then\n            temp[$k]=\"${temp[$((k+1))]}\"\n \
    \           temp[$((k+1))]=\"${temp[$k]}\"\n          fi\n        done\n     \
    \ done\n\n      # Adds the sorted word to the result string\n      result+=\"\
    ${temp[@]}\"\n\n      # Adds one space for each space in the input string, but\n\
    \      # does not add the last space\n      for (( j=0; j<spaces; j++ )); do\n\
    \        result+=' '\n      done\n\n      # Resets all the variables to empty\n\
    \      word=''\n      unset temp\n      temp=()\n    fi\n  done\n\n  # Sorts the\
    \ characters in word based on", "  echo -n \"$1\" | {\n    while read -n1 ch\n\
    \    do\n      if [[ \"$ch\" == \" \" ]]\n      then\n        echo -n \" \"\n\
    \      else\n        echo -n \"$ch\" | sed 's/./&\\n/g' | sort | tr -d '\\n'\n\
    \      fi\n    done\n  }", "    local words line\n    words=${1//[^a-zA-Z]/ }\n\
    \    line=\n    while read -r word; do\n        line=\"$line$(echo -n \"$word\"\
    \ | sort -n | tr -d '\\n')\"\n    done <<< \"$words\"\n    echo \"$line\"", "\t\
    # words_list is a list of words that we get from $1\n\tlocal words_list=($(echo\
    \ $1 | tr ' ' '\\n'))\n\tlocal ans_list=()\n\t# anti_shuffle a word\n\tfor word\
    \ in ${words_list[@]}; do\n\t\t# get the characters and sort them\n\t\tlocal new_word=$(echo\
    \ $word | tr -d '\\n' | fold -w1 | sort | tr -d '\\n')\n\t\tans_list+=($new_word)\n\
    \tdone\n\t# return a string\n\techo \"${ans_list[@]}\" | tr ' ' '\\n' | tr -d\
    \ '\\n'", "    echo $1 | tr \" \" \"\\n\" | awk '{\n        split($0,a,\"\");\n\
    \        n = asort(a);\n        for (i=1; i<=n; i++)\n            printf \"%s\"\
    , a[i];\n        printf \" \";\n    }' | tr -d \"\\n\"", "    for word in $1;\
    \ do\n        echo -n \"$(echo $word | rev | sort -f | rev)\"\n    done", "\t\
    local -a words\n\tlocal result\n\twords=( $(echo \"$1\" | tr \" \" \"\\n\") )\n\
    \tfor word in \"${words[@]}\"; do\n\t\tresult+=\"$(echo \"$word\" | fold -w1 |\
    \ sort | tr -d \"\\n\")\"\n\tdone\n\techo \"$result\"", "    local IFS\n    local\
    \ -a words\n    local -a result\n    local -a sorted_word\n    IFS=' '\n    words=($1)\n\
    \    local word\n    local word_char\n    for word in \"${words[@]}\"; do\n  \
    \      IFS=$'\\n'\n        sorted_word=($(printf \"%s\\n\" \"$word\" | sort))\n\
    \        IFS=' '\n        result+=($(printf \"%s\" \"${sorted_word[*]}\"))\n \
    \   done\n    printf \"%s\" \"${result[*]}\"", "    local -a word_array\n    for\
    \ word in $1; do\n        word_array=(\"${word_array[@]}\" \"$(echo $word | fold\
    \ -w1 | sort -f)\")\n    done\n    echo \"${word_array[@]}\"", "  res=\"\"\n \
    \ for word in $1; do\n    chars=$(echo $word | fold -w1)\n    chars=($chars)\n\
    \    sorted=($(echo ${chars[@]} | tr ' ' '\\n' | sort))\n    for char in ${sorted[@]};\
    \ do\n      res+=$char\n    done\n    res+=\" \"\n  done\n  echo \"$res\"", " \
    \ local tmp_str=\n\n  for word in $1; do\n    tmp_str+=\"$(echo $word | fold -w1\
    \ | sort | tr -d \"\\n\")\"\n  done\n\n  echo $tmp_str", "    echo \"$1\" | awk\
    \ '{for(i=1;i<=NF;i++) print | \"sort\"}'", "    echo -n \"${1//[[:space:]]/ }\"\
    \ | {\n        # for every chunk of non space char.\n        while read chunk;\
    \ do\n            # split it into characters by sorting it.\n            chars=$(echo\
    \ -n \"$chunk\" | grep -o . | sort)\n            # and print it back.\n      \
    \      echo -n \"$chars\"\n        done\n    }", "    # Assume that the first\
    \ char is not a space.\n    # Add it to the beginning of the \"space_or_not\"\
    \ array.\n    space_or_not=(\"${1:0:1}\")\n    # Check if the first char is a\
    \ space.\n    # If it is a space, add a 1 to the beginning of the array,\n   \
    \ # else add a 0 to the beginning of the array.\n    if [[ \"${1:0:1}\" == \"\
    \ \" ]]; then\n        space_or_not=(1 \"${space_or_not[@]}\")\n    else\n   \
    \     space_or_not=(0 \"${space_or_not[@]}\")\n    fi\n    # Loop through the\
    \ string, starting from char index 1, until the end.\n    for (( i=1; i<${#1};\
    \ i++ )); do\n        # Check if the current char is a space.\n        # If it\
    \ is a space, add a 1 to the array,\n        # else add a 0 to the array.\n  \
    \      if [[ \"${1:$i:1}\" == \" \" ]]; then\n            space_or_not=(1 \"${space_or_not[@]}\"\
    )\n        else\n            space_or_not=(0 \"${space_or_not[@]}\")\n       \
    \ fi\n    done\n    # Loop through the space_or_not array, starting from index\
    \ 1.\n    for (( i=1; i<${#space_or_not[@]}; i++ )); do\n        # If the current\
    \ char is not a space, add a space to the\n        # beginning of the array.\n\
    \        if [[ \"${space_or_not[$i]}\" == 0 ]]; then\n            space_or_not=(${space_or_not[@]:0:$i}\
    \ 1 ${space_or_not[@]:$i:$((${#space_or_not[@]}-$i))})\n        fi\n    done\n\
    \    # Loop through the space_or_not array.\n    for (( i=0; i<${#space_or_not[@]};\
    \ i++ )); do\n        # If the current char is a space, add a space to the result.\n\
    \        if [[ \"${space", "    echo $(echo $1 | awk '{for(i=1;i<=NF;i++) {for(j=1;j<=length($i);j++)\
    \ {printf \"%s\",substr($i,j,1)}};printf \"\\n\"}' | sort -n | sed -e \"s/\\([0-9]\\\
    )/\\1 /g\" | tr '0-9' ' ' | awk '{for(i=1;i<=NF;i++) {s = $i; for(j=2;j<=NF;j++)\
    \ {if(substr($j,1,1) == substr(s,length(s),1)) {s = s substr($j,2,length($j)-1);\
    \ $j = \"\"}}} print s}')", "\t# Split input into words\n\tread -a array <<< \"\
    $1\"\n\t# Iterate words\n\tfor (( i=0; i<${#array[@]}; i++ ))\n\tdo\n\t\t# Read\
    \ each char\n\t\tread -a array2 <<< \"${array[$i]}\"\n\t\t# Sort char\n\t\tfor\
    \ (( j=0; j<${#array2[@]}; j++ ))\n\t\tdo\n\t\t\tfor (( k=j+1; k<${#array2[@]};\
    \ k++ ))\n\t\t\tdo\n\t\t\t\tif [ \"${array2[$j]}\" \\> \"${array2[$k]}\" ]\n\t\
    \t\t\tthen\n\t\t\t\t\ttemp=\"${array2[$j]}\"\n\t\t\t\t\tarray2[$j]=\"${array2[$k]}\"\
    \n\t\t\t\t\tarray2[$k]=\"$temp\"\n\t\t\t\tfi\n\t\t\tdone\n\t\tdone\n\t\t# Print\
    \ sorted char\n\t\tfor (( j=0; j<${#array2[@]}; j++ ))\n\t\tdo\n\t\t\tprintf \"\
    ${array2[$j]}\"\n\t\tdone\n\t\t# Print space between words\n\t\tif [ \"$i\" -lt\
    \ \"$(( ${#array[@]} - 1 ))\" ]\n\t\tthen\n\t\t\tprintf \" \"\n\t\tfi\n\tdone\n\
    \tprintf \"\\n\"", "  # Create a new empty string\n  local newstr=\"\"\n  # Split\
    \ the first string into words and iterate over them\n  for word in $1; do\n  \
    \  # Create an empty string for each word\n    local w=\"\"\n    # Go over the\
    \ characters of each word and add them to the temp word\n    for (( i=0; i<${#word};\
    \ i++ )); do\n      w=\"$w${word:$i:1}\"\n    done\n    # Sort the characters\
    \ of the word and add the result to the\n    # resulting string\n    newstr=\"\
    $newstr$(echo -e \"$w\" | sort)\"\n  done\n  # Return the resulting string\n \
    \ echo -e \"$newstr\"", "\tlocal str=$1 ret\n\t# shellcheck disable=SC2016\n\t\
    while read -r word; do\n\t\tret+=\"$(echo \"$word\" | grep -o . | sort -n | tr\
    \ -d '\\n')\"\n\tdone <<< \"$str\"\n\techo \"$ret\"", "    # TODO\n    echo \"\
    \"", '    # TODO: add your code here']
stop_tokens:
- "\n}"
