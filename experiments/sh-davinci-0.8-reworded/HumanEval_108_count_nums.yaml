name: HumanEval_108_count_nums
language: sh
prompt: "#!/bin/bash\n# Write a function count_nums which takes an array of integers\
  \ and returns\n# the number of elements which has a sum of digits > 0.\n# If a number\
  \ is negative, then its first signed digit will be negative:\n# e.g. -123 has signed\
  \ digits -1, 2, and 3.\n# >>> $(count_nums \"\")\n# \"0\"\n# >>> $(count_nums \"\
  -1 11 -11\")\n# \"1\"\n# >>> $(count_nums \"1 1 2\")\n# \"3\"\n#\n# $1 is a space-separated\
  \ list\ncount_nums() {\n"
tests: "}\n\ncandidate() {\n    count_nums \"$@\"\n}\n\nset -e\nrun_test() {\n   \
  \ [[ $(candidate \"\") = \"0\" ]]\n    [[ $(candidate \"-1 -2 0\") = \"0\" ]]\n\
  \    [[ $(candidate \"1 1 2 -2 3 4 5\") = \"6\" ]]\n    [[ $(candidate \"1 6 9 -6\
  \ 0 1 5\") = \"5\" ]]\n    [[ $(candidate \"1 100 98 -7 1 -1\") = \"4\" ]]\n   \
  \ [[ $(candidate \"12 23 34 -45 -56 0\") = \"5\" ]]\n    [[ $(candidate \"0 1\"\
  ) = \"1\" ]]\n    [[ $(candidate \"1\") = \"1\" ]]\n}\n\nrun_test"
completions: ["    sum=0\n    for n in $1; do\n        sum=0\n        if [ $n -lt\
    \ 0 ]; then\n            n=$((n*-1))\n        fi\n        while [ $n -gt 0 ];\
    \ do\n            sum=$((sum+n%10))\n            n=$((n/10))\n        done\n \
    \       if [ $sum -gt 0 ]; then\n            echo -n \"1 \"\n        else\n  \
    \          echo -n \"0 \"\n        fi\n    done", "    local n=0\n    for x in\
    \ $@\n    do\n        if [[ $x == -* ]]\n        then\n            local a=$(($x\
    \ * -1))\n        else\n            local a=$x\n        fi\n        local sum=0\n\
    \        while [ $a -gt 0 ]\n        do\n            ((sum+=a%10))\n         \
    \   ((a/=10))\n        done\n        if [[ $sum > 0 ]]\n        then\n       \
    \     ((n+=1))\n        fi\n    done\n    echo $n", "    count=0\n    for num\
    \ in $1; do\n        if [[ \"$num\" -lt 0 ]]; then\n            num=$(( -1 * num\
    \ ))\n        fi\n        while [[ \"$num\" -ne 0 ]]; do\n            num=$((\
    \ num / 10 ))\n            count=$(( count + 1 ))\n        done\n    done\n  \
    \  echo \"$count\"", "\techo \"$1\" | \\\n\t\tawk 'BEGIN { FS = \" \" }\n\t\t\t\
    {\n\t\t\t\tcnt = 0\n\t\t\t\tfor (i = 1; i <= NF; i++) {\n\t\t\t\t\ta = $i\n\t\t\
    \t\t\tif (a < 0) {\n\t\t\t\t\t\t# take the first signed digit\n\t\t\t\t\t\ta =\
    \ substr(a, 2, 1)\n\t\t\t\t\t}\n\t\t\t\t\twhile (a > 0) {\n\t\t\t\t\t\tcnt +=\
    \ a % 10\n\t\t\t\t\t\ta = int(a / 10)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tprint cnt\n\
    \t\t\t}'", "    local -i cnt=0\n    for num in $1\n    do\n        local -i sum=0\n\
    \        local -i pos_num=${num#-}\n        while (( pos_num > 0 ))\n        do\n\
    \            sum=$(( sum + pos_num % 10 ))\n            pos_num=$(( pos_num /\
    \ 10 ))\n        done\n        if (( num < 0 ))\n        then\n            ((\
    \ --sum ))\n        fi\n        if (( sum != 0 ))\n        then\n            ((\
    \ ++cnt ))\n        fi\n    done\n    echo $cnt", "    elements=(\"$@\")\n   \
    \ sum=0\n    for i in ${elements[@]}; do\n        temp=${i//-/}\n        for ((j=0;\
    \ j<${#temp}; j++)); do\n            sum=$((sum + ${temp:$j:1}))\n        done\n\
    \        if [[ $sum -gt 0 ]]; then\n            count=$((count + 1))\n       \
    \ fi\n        sum=0\n    done\n    echo $count", "    local sum=0\n    for x in\
    \ \"${@:1}\"; do\n        if (( x < 0 )); then\n            x=${x#-}\n       \
    \ fi\n        sum=0\n        while (( x > 0 )); do\n            (( sum += x %\
    \ 10 ))\n            (( x /= 10 ))\n        done\n        (( sum > 0 )) && ((\
    \ count++ ))\n    done\n    echo \"$count\"", "    local x\n    local count=0\n\
    \    for x in $1; do\n        if [ ${x:0:1} = '-' ]; then\n            x=${x:1}\n\
    \        fi\n        local sum=0\n        local d\n        for d in $(echo $x\
    \ | sed 's/./& /g'); do\n            sum=$((sum + d))\n        done\n        if\
    \ [ $sum -gt 0 ]; then\n            count=$((count + 1))\n        fi\n    done\n\
    \    echo $count", "    local sum=0 i ans=0\n    for i in $@; do\n        if [\
    \ $i -lt 0 ]; then\n            sum=$((-i))\n        else\n            sum=$i\n\
    \        fi\n        while [ $sum -gt 0 ]; do\n            i=$((sum % 10))\n \
    \           sum=$((sum / 10))\n            ans=$((ans + i))\n        done\n  \
    \      [ $ans -gt 0 ] && ((count++))\n        ans=0\n    done\n    echo $count",
  "  nums=($1)\n  count=0\n  for num in ${nums[@]}; do\n    if [[ $num -gt 0 ]]; then\n\
    \      ((count++))\n    elif [[ $num -lt 0 ]]; then\n      ((count++))\n    fi\n\
    \  done\n  echo \"$count\"", "    # This is extremely ugly for the sake of portability\
    \ (hello, Windows!)\n    # but the code is pretty simple to follow.\n    # You\
    \ can write this in a much simpler way in a POSIX compliant shell\n    declare\
    \ -i n=0\n    for num in $1; do\n        declare -i s=0\n        for digit in\
    \ $(tr -d '-' <<< \"$num\"); do\n            s=\"$((s + digit))\"\n        done\n\
    \        if [[ \"${num}\" == \"-\"* ]]; then\n            s=\"$((-s))\"\n    \
    \    fi\n        if [[ \"$s\" != \"0\" ]]; then\n            n=\"$((n + 1))\"\n\
    \        fi\n    done\n    echo \"$n\"", "    local num count\n    for num in\
    \ $@; do\n        if [ $num -lt 0 ]; then\n            num=$((-$num))\n      \
    \  fi\n        count=0\n        while [ $num -gt 0 ]; do\n            count=$((count\
    \ + (num % 10)))\n            num=$((num / 10))\n        done\n        if [ $count\
    \ -gt 0 ]; then\n            echo 1\n        else\n            echo 0\n      \
    \  fi\n    done | awk '{c+=$1} END {print c}'", "    # YOUR CODE HERE\n    # This\
    \ is a stub, replace this line with your answer\n    echo \"\"", "  declare -a\
    \ numbers=($1)\n  count=0\n  for num in \"${numbers[@]}\"; do\n    value=0\n \
    \   for ((i=0; i<${#num}; i++)); do\n      value=$((value + ${num:$i:1}))\n  \
    \  done\n    if [[ $value -gt 0 ]]; then\n      count=$((count + 1))\n    fi\n\
    \  done\n  echo $count", "    if [ -z \"$1\" ]; then\n        echo 0\n       \
    \ return\n    fi\n    s=$(echo \"$1\" | sed -e 's/^-//' -e 's/ / + /g')\n    echo\
    \ $(echo $s | bc)", "  local nums\n  local count=0\n  local sum\n  local i\n\n\
    \  nums=($1)\n  for i in \"${nums[@]}\"; do\n    sum=0\n    while [[ $i -ne 0\
    \ ]]; do\n      sum=$((sum + (i % 10)))\n      i=$((i / 10))\n    done\n    [[\
    \ $sum -gt 0 ]] && count=$((count + 1))\n  done\n  echo \"$count\"", "  local\
    \ nums\n  local sum\n  nums=($1)\n  for num in \"${nums[@]}\"; do\n    for ((\
    \ i=${#num}-1; i>=0; i-- )); do\n      (( sum+=${num:$i:1} ))\n    done\n    [[\
    \ $sum -eq 0 ]] && sum=0 || sum=1\n    echo -n \"$sum \"\n    sum=0\n  done",
  "  local digits sum x\n  digits=($(echo \"$1\" | sed 's/[^-0-9]/ /g'))\n  for x\
    \ in \"${digits[@]}\"; do\n    sum=0\n    while [[ $x -ne 0 ]]; do\n      sum=$((sum\
    \ + (x % 10)))\n      x=$((x / 10))\n    done\n    if [[ $sum -gt 0 ]]; then\n\
    \      echo -n \"$x \"\n    fi\n  done", "    # count=0\n    # for el in $1; do\n\
    \    #     sum=0\n    #     for (( i=0; i<${#el}; i++ )); do\n    #         if\
    \ [[ ${el:$i:1} =~ ^-?[0-9]+$ ]]; then\n    #             sum=$((sum + ${el:$i:1}))\n\
    \    #         fi\n    #     done\n    #     if (( sum > 0 )); then\n    #   \
    \      count=$((count + 1))\n    #     fi\n    # done\n    # echo $count\n\n \
    \   # Alternative solution\n    local count=0\n    for el in $1; do\n        sum=0\n\
    \        for (( i=0; i<${#el}; i++ )); do\n            if [[ ${el:$i:1} =~ ^-?[0-9]+$\
    \ ]]; then\n                sum=$((sum + ${el:$i:1}))\n            fi\n      \
    \  done\n        if (( sum > 0 )); then\n            count=$((count + 1))\n  \
    \      fi\n    done\n    echo $count", "  # Do not change the following line\n\
    \  local nums=($1)\n  # Your code goes below\n  local num count\n  count=0\n \
    \ for num in ${nums[@]}; do\n    sum=0\n    while [ $num -ne 0 ]; do\n      sum=$((\
    \ $sum + $num % 10 ))\n      num=$(( $num / 10 ))\n    done\n    if [ $sum -gt\
    \ 0 ]; then\n      (( count++ ))\n    fi\n  done\n  echo $count", "\tnum_string=\"\
    $1\"\n\tcount=0\n\tfor number in $num_string; do\n\t\tif [[ $number -lt 0 ]];\
    \ then\n\t\t\tnumber=$((number*-1))\n\t\tfi\n\t\tsum=0\n\t\twhile [[ $number -gt\
    \ 0 ]]; do\n\t\t\tsum=$((sum+number%10))\n\t\t\tnumber=$((number/10))\n\t\tdone\n\
    \t\tif [[ $sum -gt 0 ]]; then\n\t\t\tcount=$((count+1))\n\t\tfi\n\tdone\n\techo\
    \ $count", "  declare -i pos=0\n  declare -i minus=0\n  for n in \"$@\"; do\n\
    \    declare -i s=0\n    for d in $(echo \"$n\" | grep -o .); do\n      declare\
    \ -i d=${d}\n      if (( ${d} < 0 )); then\n        minus=1\n        d=${d#-}\n\
    \      fi\n      s=$(( ${s} + ${d} ))\n    done\n    (( ${s} > 0 )) && (( pos+=1\
    \ ))\n  done\n  minus && echo \"${pos}\" || echo \"0\"", "   total=0;\n   for\
    \ num in $1; do\n      #calculate the absolute value\n      if [ $num -lt 0 ];\
    \ then\n         num=$((-$num));\n      fi\n      while [ $num -gt 0 ]; do\n \
    \        digit=$((num % 10));\n         total=$((total + digit));\n         num=$((num\
    \ / 10));\n      done\n      if [ $total -gt 0 ]; then\n         total=$((total+1));\n\
    \      fi\n   done\n   echo $total;", "  local input=\"$1\"\n  local sum digits\
    \ result\n  for n in $input; do\n    if [[ $n -lt 0 ]]; then\n      n=\"-$n\"\n\
    \    fi\n    digits=$(echo $n | sed 's/./& /g')\n    sum=0\n    for d in $digits;\
    \ do\n      sum=$((sum + d))\n    done\n    if [[ $sum -gt 0 ]]; then\n      result=$((result\
    \ + 1))\n    fi\n  done\n  echo $result", "  local numbers=(${1// / })\n  for\
    \ i in \"${numbers[@]}\"; do\n    if [[ ${i:0:1} = \"-\" ]]; then\n      local\
    \ sum=$((sum+${i:1:1}))\n    else\n      local sum=$((sum+${i:0:1}))\n    fi\n\
    \  done\n  echo $sum", "    if [ $# -eq 0 ]; then\n        echo \"0\"\n      \
    \  return\n    fi\n    local tmp=\"\"\n    # This is a more robust way of ensuring\
    \ that $@ is a space-separated list.\n    local list=($@)\n    for number in \"\
    ${list[@]}\"; do\n        if [ \"$number\" -lt 0 ]; then\n            # Remove\
    \ the leading -1 and use the absolute value of the rest.\n            number=$(echo\
    \ $number | sed -e 's/^-1//' | awk '{print abs($0)}')\n        fi\n        # Sum\
    \ of digits is the total of all digits.\n        local sum=$(echo $number | awk\
    \ '{sum = 0; for (i = 1; i <= NF; i++) {sum += $i}} END {print sum}')\n      \
    \  if [ \"$sum\" -gt 0 ]; then\n            # Append number to tmp\n         \
    \   tmp=\"$tmp $number\"\n        fi\n    done\n    # Count elements in tmp\n\
    \    echo $(echo $tmp | wc -w)", "  local cnt=0\n  for x in $1; do\n    # x %\
    \ 10 will return the last digit\n    # for -13, $x % 10 will return -3\n    local\
    \ sum=0\n    # If x is negative, reverse x\n    if [[ $x -lt 0 ]]; then\n    \
    \  x=$(( $x * -1 ))\n    fi\n    while [[ $x -gt 0 ]]; do\n      sum=$(( $sum\
    \ + $x % 10 ))\n      x=$(( $x / 10 ))\n    done\n    if [[ $sum -gt 0 ]]; then\n\
    \      cnt=$(( $cnt + 1 ))\n    fi\n  done\n  echo $cnt", "  for num in $1; do\n\
    \    if [[ $(($num)) -eq 0 ]]; then\n      echo \"0\"\n      return\n    fi\n\
    \    if [[ $(($num)) -lt 0 ]]; then\n      num=$(($num * -1))\n    fi\n    sum=0\n\
    \    for (( i=0; i<${#num}; i++ )); do\n      digit=$((${num:$i:1}))\n      sum=$(($sum\
    \ + $digit))\n    done\n    if [[ $(($sum)) -gt 0 ]]; then\n      echo \"$num\"\
    \n    fi\n  done | wc -l", "  # TODO\n  nums=$(echo $1 | tr \" \" \"\\n\")\n \
    \ sum=0\n  for n in $nums\n  do\n    abs_n=$(echo $n | sed 's/-//g')\n    sum_digits=$(echo\
    \ $abs_n | sed 's/[0-9]//g' | wc -c)\n    while [ $sum_digits -gt 0 ]\n    do\n\
    \      last_digit=$(echo $abs_n | tail -c 1)\n      sum=$(($sum + $last_digit))\n\
    \      abs_n=$(echo $abs_n | sed 's/.$//')\n      sum_digits=$(($sum_digits -\
    \ 1))\n    done\n    if [ $sum -eq 0 ]\n    then\n      sum_num=$(($sum_num +\
    \ 1))\n    fi\n    sum=0\n  done\n  echo $sum_num", "    local arr=(\"$@\")\n\
    \    local count=0\n    for num in \"${arr[@]}\"; do\n        local sum=0\n  \
    \      if [[ $num -lt 0 ]]; then\n            sum=$((-$num))\n        else\n \
    \           sum=$num\n        fi\n        while (( sum > 0 )); do\n          \
    \  local digit=$((sum % 10))\n            sum=$((sum / 10))\n            sum=$((sum\
    \ + digit))\n        done\n        if (( sum > 0 )); then\n            count=$((count\
    \ + 1))\n        fi\n    done\n    echo \"$count\"", "    result=0\n    #separate\
    \ by space\n    OLDIFS=$IFS\n    IFS=' '\n    read -a nums <<< \"$1\"\n    for\
    \ i in \"${nums[@]}\"\n    do\n        #separate each digit by space\n       \
    \ OLDIFS=$IFS\n        IFS=''\n        #skip the sign for negative number\n  \
    \      if [[ $i == -* ]]; then\n            read -a digits <<< \"${i:1}\"\n  \
    \      else\n            read -a digits <<< \"$i\"\n        fi\n        #reset\
    \ IFS\n        IFS=$OLDIFS\n        #use a flag to mark that whether a number\
    \ has any non-zero digits\n        flag=0\n        for j in \"${digits[@]}\"\n\
    \        do\n            if [[ $j != 0 ]]; then\n                flag=1\n    \
    \            break\n            fi\n        done\n        #add count by the flag\n\
    \        result=$(($result+$flag))\n    done\n    echo $result", "    local list=\"\
    $@\"\n    local sum=0\n    local res=0\n    for num in $list; do\n        if [\
    \ $num -lt 0 ]; then\n            num=$((num * -1))\n        fi\n        while\
    \ [ $num -gt 0 ]; do\n            sum=$((sum + num % 10))\n            num=$((num\
    \ / 10))\n        done\n        if [ $sum -gt 0 ]; then\n            res=$((res\
    \ + 1))\n        fi\n        sum=0\n    done\n    echo $res", "    (( $# == 0\
    \ )) && echo \"0\" && return\n    local args=($@)\n    local count=0\n    for\
    \ (( i = 0; i < ${#args[@]}; i++ )); do\n        local num=${args[$i]}\n     \
    \   local sum=0\n        local str=${num#-}\n        while (( str > 0 )); do\n\
    \            ((sum += str % 10))\n            ((str /= 10))\n        done\n  \
    \      if (( num < 0 )) ; then\n            ((sum += 1))\n        fi\n       \
    \ ((sum > 0)) && ((count++))\n    done\n    echo \"$count\"", "\tinput=\"$1\"\n\
    \tcount=0\n\tfor i in $input; do\n\t\t#if [ $i -lt 0 ]; then\n\t\t#\ti=${i:1}\n\
    \t\t#fi\n\t\tif [ $(echo \"$i < 0\" | bc) -eq 1 ]; then\n\t\t\ti=${i:1}\n\t\t\
    fi\n\t\tsum=0\n\t\tfor (( j=0; j<${#i}; j++ )); do\n\t\t\tsum=$(echo \"$sum +\
    \ ${i:$j:1}\" | bc)\n\t\tdone\n\t\tif [ $sum -gt 0 ]; then\n\t\t\t((count++))\n\
    \t\tfi\n\tdone\n\techo $count", "    echo $1 | sed -e 's/-[0-9]/-*&/g' |\\\n \
    \       sed -e 's/[0-9]/&/g' |\\\n        sed -e 's/-\\*[0-9]/-&/g' |\\\n    \
    \    bc -l |\\\n        sed -e 's/[.]//g' |\\\n        sed -e 's/^/1/' |\\\n \
    \       sed -e 's/10/0/g' |\\\n        grep -c .", "  local sum=0\n  local count=0\n\
    \  local r\n  local lastdigit\n  local i\n\n  for i in $1; do\n    [[ \"$i\" ==\
    \ \"-\"* ]] && lastdigit=\"${i:0:1}\" && sum=\"$(($sum + ${i:1}))\" || sum=\"\
    $(($sum + $i))\"\n    while [[ \"$sum\" -gt 0 ]]; do\n      r=\"$(($sum % 10))\"\
    \n      sum=\"$(($sum / 10))\"\n      if [[ \"$sum\" -eq 0 ]]; then\n        count=\"\
    $(($count + $r))\"\n      else\n        count=\"$(($count + $r + $sum))\"\n  \
    \    fi\n    done\n    sum=0\n  done\n  echo \"$count\"", "  for num in $@; do\n\
    \    local tot=0\n    echo $num | sed -E 's/([-]?)([[:digit:]])/\\1 \\2 /g' |\
    \ while read n; do\n      let tot+=$n\n    done\n    if [[ $tot > 0 ]]; then\n\
    \      echo -n 1\n    else\n      echo -n 0\n    fi\n  done | awk '{for(i=1;i<=NF;i++)c+=substr($i,1,1)}END{print\
    \ c}'", "    sum=0\n    for num in $1; do\n        num=$(echo $num | sed 's/^-//')\
    \ # remove leading '-'\n        sum=0\n        while [ $num -gt 0 ]; do\n    \
    \        # add the last digit of the number to sum\n            sum=$((sum + num\
    \ % 10))\n            # update the number to exclude the last digit\n        \
    \    num=$((num / 10))\n        done\n        echo $sum\n    done | grep -v '^0$'\
    \ | wc -l", "    # Implement this function\n    for i in $1\n    do\n        if\
    \ [ \"$i\" -lt 0 ]\n        then\n            let sum=sum+`echo $i | sed 's/-//'\
    \ | cut -c 1`\n        else\n            let sum=sum+`echo $i | cut -c 1`\n  \
    \      fi\n    done\n    echo $sum", "    local count=0\n    local array=()\n\
    \    local n\n    for n in $1; do\n        if ((n<0)); then\n            array+=(\"\
    ${n#-}\")\n        else\n            array+=(\"$n\")\n        fi\n    done\n \
    \   for n in \"${array[@]}\"; do\n        local digits=$(echo $n | sed 's/[0-9]/&\
    \ /g')\n        local sum=0\n        for d in $digits; do\n            ((sum+=d))\n\
    \        done\n        if ((sum>0)); then\n            ((count++))\n        fi\n\
    \    done\n    echo \"$count\"", "    COUNT=0\n    while read -d ' ' INTEGER;\
    \ do\n        if [ \"$INTEGER\" -ge 0 ]; then\n            SUM=$(echo \"$INTEGER\"\
    \ | grep -o '[0-9]' | tr -d '\\n' | awk '{ s = 0; for (i = 1; i <= length($0);\
    \ i++) s += substr($0, i, 1) } END { print s }')\n        else\n            SUM=$(echo\
    \ \"$INTEGER\" | grep -o '[0-9]' | tr -d '\\n' | awk '{ s = 0; for (i = 1; i <=\
    \ length($0); i++) s += substr($0, i, 1) } END { print 0 - s }')\n        fi\n\
    \        if [ \"$SUM\" -gt 0 ]; then\n            COUNT=$((COUNT + 1))\n     \
    \   fi\n    done <<< \"$1\"\n    echo \"$COUNT\"", '    echo "Not implemented"',
  "    local arr=($1)\n    local out=0\n    for((i=0;i<${#arr[@]};i++)); do\n    \
    \    local v=${arr[$i]}\n        local s=0\n        for((j=0;j<${#v};j++)); do\n\
    \            local d=${v:$j:1}\n            if [[ \"$d\" =~ ^[0-9]$ ]]; then\n\
    \                s=$((s+d))\n            fi\n        done\n        if [[ $s >\
    \ 0 ]]; then\n            out=$((out+1))\n        fi\n    done\n    echo $out",
  "  # return a list of the signed digits of each number in $1:\n  signed_digits()\
    \ {\n    local number n\n    for number in $1; do\n      [ \"$number\" -lt 0 ]\
    \ && echo -n \"$((-number % 10)) \" || echo -n \"$((number % 10)) \"\n      for\
    \ ((n=10; n<number; n*=10)); do\n        echo -n \"$((number % n / (n/10))) \"\
    \n      done\n    done\n  }\n  # return the sum of a list of numbers\n  sum()\
    \ {\n    local number sum=0\n    for number in $1; do\n      sum=$((sum + number))\n\
    \    done\n    echo $sum\n  }\n  local result\n  # return the number of elements\
    \ in $1 whose sum of digits is > 0\n  for number in $1; do\n    result=$((result\
    \ + $(sum \"$(signed_digits \"$number\")\") > 0))\n  done\n  echo $result", " \
    \   # For your convenience, we declare the function for you\n    for n in $1;\
    \ do\n      sd=0\n      for(( i=${#n}; i>0; i-- )); do\n        sd=$(( sd + ${n:i-1:1}\
    \ ))\n      done\n      (( sd > 0 )) && (( c++ ))\n    done\n    echo $c", " \
    \   local -i num=0\n    local word=0\n    # Iterate through arguments\n    for\
    \ word in \"$@\"; do\n        if [[ \"$word\" =~ ^-?[0-9]+$ ]]; then\n       \
    \     local -i digit=0 sum=0\n            while [[ \"$word\" -ne 0 ]]; do\n  \
    \              # Get the last digit of the number\n                digit=$(( word\
    \ % 10 ))\n                # Add it to the sum\n                sum=$(( sum +\
    \ digit ))\n                # Remove the last digit from the number\n        \
    \        word=$(( word / 10 ))\n            done\n            # If the sum is\
    \ more than 0, increment\n            # the count\n            if [[ \"$sum\"\
    \ -gt 0 ]]; then\n                num=$(( num + 1 ))\n            fi\n       \
    \ fi\n    done\n    echo \"$num\"", "  # Trim leading spaces, and replace spaces\
    \ with newlines\n  # then count the number of lines with a non-zero sum\n  # e.g.\
    \ \"-1 11 -11\" => \\n-1\\n11\\n-11\\n\n  #      => -1 2 -1\n  #      => 2 (line\
    \ count)\n  local args=$(echo $1 | sed -e 's/^ *//' -e 's/ *$//' -e 's/ /\\n/g')\n\
    \  echo \"$args\" | awk 'BEGIN { i=0 } {\n    if ( $1 < 0 ) { # handle negative\
    \ numbers\n      $1 = -1 * $1\n    }\n    for ( j=1; j<=length($1); j++ ) {\n\
    \      i += substr($1, j, 1)\n    }\n  } END { print i }'", "  nums=($1)\n  count=0\n\
    \  for num in ${nums[@]}; do\n    sum=0\n    for digit in $(echo \"$num\" | sed\
    \ 's/-\\|//g'); do\n      sum=$((sum + digit))\n    done\n    if [ $sum -gt 0\
    \ ]; then\n      count=$((count + 1))\n    fi\n  done\n  echo $count", '    #
    Write your code here', "    # TODO(zafar@cs.umass.edu): Implement this function\n\
    \    local n\n    local count=0\n    for n in $1\n    do\n        local m=$n\n\
    \        local sum=0\n        if [ $n -lt 0 ]\n        then\n            m=-$n\n\
    \        fi\n        while [ $m -gt 0 ]\n        do\n            n=$(($m % 10))\n\
    \            sum=$(($sum + $n))\n            m=$(($m / 10))\n        done\n  \
    \      if [ $sum -gt 0 ]\n        then\n            count=$(($count + 1))\n  \
    \      fi\n    done\n    echo $count", '    # your code here', '    echo "The
    implementation of count_nums is incomplete"', "  if [ -z \"$1\" ]; then\n    echo\
    \ 0\n    return\n  fi\n  local -a nums=($(echo \"$1\"))\n  local N=${#nums[@]}\n\
    \  local count=0\n  for ((i=0; i<N; i++)); do\n    local num=${nums[$i]}\n   \
    \ if ((num < 0)); then\n      num=${num:1}\n    fi\n    local sum=0\n    while\
    \ ((num > 0)); do\n      ((sum += num % 10))\n      ((num /= 10))\n    done\n\
    \    if ((sum > 0)); then\n      ((count++))\n    fi\n  done\n  echo $count",
  "  local sum=0\n  local count=0\n  for number in $1; do\n    local current_sum=0\n\
    \    local absolute_number=${number#-}\n    while [ $absolute_number -gt 0 ];\
    \ do\n      let current_sum+=absolute_number%10\n      let absolute_number/=10\n\
    \    done\n    [ $number -lt 0 ] && let current_sum*=-1\n    ((current_sum > 0))\
    \ && ((++count))\n  done\n  echo $count", "    count=0\n    for x in $1; do\n\
    \        # if $x is positive\n        if [ $x -ge 0 ]; then\n            sum=0\n\
    \            while [ $x -gt 0 ]; do\n                sum=$(( $sum + (x % 10) ))\n\
    \                x=$(( x / 10 ))\n            done\n            # if sum is non-zero\n\
    \            if [ $sum -gt 0 ]; then\n                count=$(( $count + 1 ))\n\
    \            fi\n        else\n            x=$(( -1 * $x ))\n            sum=0\n\
    \            while [ $x -gt 0 ]; do\n                sum=$(( $sum + (x % 10) ))\n\
    \                x=$(( x / 10 ))\n            done\n            # if sum is non-zero\n\
    \            if [ $sum -gt 0 ]; then\n                count=$(( $count + 1 ))\n\
    \            fi\n        fi\n    done\n    echo $count", '    # Write your code
    here', "\tlocal sum\n\tfor num in $1\n\tdo\n\t\tsum=0\n\t\tif [ $num -lt 0 ]\n\
    \t\tthen\n\t\t\tnum=${num#-}\n\t\tfi\n\t\tfor (( i=0; i<${#num}; i++ ))\n\t\t\
    do\n\t\t\tsum=$(( sum + ${num:$i:1} ))\n\t\tdone\n\t\tif [ $sum -gt 0 ]\n\t\t\
    then\n\t\t\tcount=$(( count + 1 ))\n\t\tfi\n\tdone\n\techo $count", '  # write
    your code here', "    # TODO: Complete count_nums\n    local -i num num_len\n\
    \    local -i count=0\n    local -i i\n    local -i dig\n    local tmp\n    for\
    \ num in \"$@\"; do\n        dig=0\n        if ((num < 0)); then\n           \
    \ num=-num\n            dig=-(($num % 10))\n        fi\n        tmp=$num\n   \
    \     while ((tmp > 0)); do\n            dig=$((dig + tmp % 10))\n           \
    \ tmp=$((tmp / 10))\n        done\n        if ((dig > 0)); then\n            ((count++))\n\
    \        fi\n    done\n    echo \"$count\"", "    [ -z \"$1\" ] && echo \"0\"\
    \ && return 0\n    digits=$(echo \"$1\" | sed -e 's/-/ -/g' | tr ' ' '\\n' | sed\
    \ -e 's/-/ -/g' |\n        grep -Pv '^[\\s-]$' | tr -d '-')\n    summ=$(echo \"\
    $digits\" | awk '{s+=$1} END {print s}')\n    echo $summ", "  [[ -z \"$1\" ]]\
    \ && echo \"0\" && return\n  IFS=\" \" read -r -a ary <<< \"$1\"\n  num_of_elements=0\n\
    \  for i in \"${ary[@]}\"; do\n    i=${i#-}\n    sum=0\n    while [[ $i -gt 0\
    \ ]]; do\n      sum=$((sum + i % 10))\n      i=$((i / 10))\n    done\n    if [[\
    \ $sum -gt 0 ]]; then\n      num_of_elements=$((num_of_elements + 1))\n    fi\n\
    \  done\n  echo \"$num_of_elements\"", "\tlocal N=0\n\tfor i in $1\n\tdo\n\t\t\
    if [ \"${i#-}\" != \"$i\" ]\n\t\tthen\n\t\t\ti=${i#-}\n\t\tfi\n\t\tlocal SUM=0\n\
    \t\tfor j in $(echo $i | sed 's/./& /g')\n\t\tdo\n\t\t\tlet SUM=$SUM+$j\n\t\t\
    done\n\t\tif [ $SUM -gt 0 ]\n\t\tthen\n\t\t\tlet N=$N+1\n\t\tfi\n\tdone\n\techo\
    \ $N", "    echo \"$1\" | awk '\n    BEGIN {count = 0}\n    {\n        for (i\
    \ = 1; i <= NF; i++) {\n            if ($i < 0) {\n                $i = -$i\n\
    \            }\n            sum = 0\n            while ($i > 0) {\n          \
    \      sum += $i % 10\n                $i = int($i / 10)\n            }\n    \
    \        if (sum > 0) {\n                count++\n            }\n        }\n \
    \   }\n    END {print count}\n    '", "  local nums=\"$@\"\n  local count=\"0\"\
    \n  local num=\"\"\n  local sum=\"\"\n  local c=\"\"\n  for num in $nums; do\n\
    \    sum=\"0\"\n    for c in $(echo \"$num\" | tr -d '-'); do\n      sum=$((sum\
    \ + c))\n    done\n    [ \"$sum\" -gt \"0\" ] && count=$((count + 1))\n  done\n\
    \  echo \"$count\"", "  counter=0\n  for num in \"$@\"; do\n    (( num < 0 ))\
    \ && num=$((num * -1))\n    while (( num > 0 )); do\n      (( counter += num %\
    \ 10 ))\n      (( num /= 10 ))\n    done\n    (( counter > 0 )) && (( counter\
    \ = 1 ))\n  done\n  echo $counter", "    declare -a elements=($1)\n    echo ${elements[@]}\n\
    \    echo \"In count_nums\"\n    total=0\n    for i in ${elements[@]}; do\n  \
    \      echo \"i=${i}\"\n        if [ $i -lt 0 ]; then\n            temp=$((0-$i))\n\
    \            echo \"temp=${temp}\"\n            sum_digits_of_single_number $temp\n\
    \            total=$((total+sum))\n        else\n            sum_digits_of_single_number\
    \ $i\n            total=$((total+sum))\n        fi\n    done\n    echo $total",
  "    # In your function, you should use a variable to hold the return value\n  \
    \  # instead of a constant like \"1\"\n    return_value=0\n    # Type your code\
    \ here\n    for num in $1\n    do\n        if [[ $(echo ${num} | grep '-') !=\
    \ \"\" ]]\n        then\n            num=${num//-/}\n        fi\n        for i\
    \ in $(echo ${num} | sed 's/./& /g')\n        do\n            return_value=$((${return_value}\
    \ + ${i}))\n        done\n        if [[ ${return_value} -gt 0 ]]\n        then\n\
    \            echo ${return_value}\n        fi\n        return_value=0\n    done\n\
    \    # End of your code", "  nums=$1\n  printf \"$nums\" |\n    tr ' ' '\\n' |\n\
    \    sed '/^-/s/^-//' |\n    sed '/^0/d' |\n    tr -d '\\n' |\n    sed 's/./&\\\
    n/g' |\n    tr -d '\\n' |\n    wc -m", "    local sum1=0\n    local sum2=0\n \
    \   for i in $1; do\n        if [[ $i -lt 0 ]]; then\n            (( sum1 += -$((\
    \ -$i % 10 )) ))\n            (( sum2 += -$(( -$i / 10 )) ))\n        else\n \
    \           (( sum1 += $(( i % 10 )) ))\n            (( sum2 += $(( i / 10 ))\
    \ ))\n        fi\n    done\n    if [[ $sum1 -gt 0 ]]; then\n        echo 1\n \
    \   elif [[ $sum2 -gt 0 ]]; then\n        echo 2\n    else\n        echo 0\n \
    \   fi", "    echo \"$1\" | tr ' ' '\\n' |\\\n    awk '{\n        # split number\
    \ by each digit\n        command = \"echo \" $1 \" | grep -o . | awk \\'{sum+=$1}\\\
    ' END {print sum}\";\n        system(command);\n    }' |\\\n    awk '{\n     \
    \   if ($1 > 0)\n            print 1;\n        else\n            print 0;\n  \
    \  }' | tr '\\n' '+' | sed 's/+$//' | bc", "  sum_digits_by_signed() {\n    printf\
    \ '%s\\n' \"$@\" | while read number; do\n      echo \"$number\" | grep -Eq '^-'\
    \ && sign=-1 || sign=1\n      printf '%s\\n' \"$number\" | sed -E 's/^-?(.*)/\\\
    1/' | grep -Eo . | awk '{sum+=$1} END {print sum*sign}'\n    done\n  }\n  printf\
    \ '%s\\n' \"$@\" | sum_digits_by_signed | grep -Eq '^-?[1-9]' | wc -l", "    for\
    \ i in $1; do\n        sum=0\n        for (( j=0; j<${#i}; j++ )); do\n      \
    \      digit=\"${i:$j:1}\"\n            if [ \"$digit\" == \"-\" ]; then\n   \
    \             (( j++ ))\n                digit=\"${i:$j:1}\"\n            fi\n\
    \            (( sum+=digit ))\n        done\n        echo $sum\n    done | grep\
    \ -c '[1-9]'", "  local digits=0\n  local count=0\n  local num\n  for num in $1;\
    \ do\n    if [[ $num -lt 0 ]]; then\n      digits=$(( -$num % 10 ))\n    else\n\
    \      digits=$(( $num % 10 ))\n    fi\n    if [[ $digits -gt 0 ]]; then\n   \
    \   count=$(( $count + 1 ))\n    fi\n  done\n  echo $count", "  # TODO implement\
    \ this function\n  set -f\n  set -- $1\n  i=0\n  for var in \"$@\"\n  do\n   \
    \ if [ $var -lt 0 ]\n    then\n      set -- $var\n      set -- ${1:1}\n      set\
    \ -- \"$@\"\n      set -- $var\n      set -- ${1:1}\n      set -- \"$@\"\n   \
    \   set -- $var\n      set -- ${1:1}\n      set -- \"$@\"\n    fi\n    set --\
    \ $var\n    set -- $1 $2 $3\n    count=0\n    for num in \"$@\"\n    do\n    \
    \  count=$(($count + $num))\n    done\n    if [ $count -gt 0 ]\n    then\n   \
    \   i=$(($i + 1))\n    fi\n  done\n  echo $i", "  echo \"$1\" | tr ' ' '\\n' |\
    \ awk '{sum = 0\n    for (i = 1; i <= length($1); i++)\n      sum += substr($1,\
    \ i, 1)\n    if (sum > 0) print $1\n  }' | wc -l", "    local nums=($@)\n    local\
    \ count=0\n    for ((i=0; i<${#nums[@]}; i++)); do\n        local num=\"${nums[$i]}\"\
    \n        if ((num < 0)); then\n            num=${num#-}\n        fi\n       \
    \ local sum=0\n        for ((j=0; j<${#num}; j++)); do\n            local digit=\"\
    ${num:$j:1}\"\n            sum=$((sum + digit))\n        done\n        if ((sum\
    \ > 0)); then\n            count=$((count + 1))\n        fi\n    done\n    echo\
    \ \"$count\"", "    # Hint: awk has a built-in function for summing digits\n \
    \   # TODO: fix this \n    #awk '{s = 0; for (i = 1; i <= NF; i++) s += length($i);\
    \ if (s) print $0}'\n    #awk '{s = 0; for (i = 1; i <= NF; i++) s += $i; if (s)\
    \ print $0}'\n    awk '{s = 0; for (i = 1; i <= NF; i++) s += $i; if (s) print\
    \ $0}'", "\t# Your code here\n\tcount_nums() {\n\t\t# Your code here\n\t\tsum=0\n\
    \t\tcount=0\n\t\tfor i in $1\n\t\tdo\n\t\t\ttemp=$i\n\t\t\tsum=0\n\t\t\twhile\
    \ [ $temp -ne 0 ]\n\t\t\tdo\n\t\t\t\trem=$(( $temp % 10 ))\n\t\t\t\ttemp=$(( $temp\
    \ / 10 ))\n\t\t\t\tsum=$(( $sum + $rem ))\n\t\t\tdone\n\t\t\tif [ $sum -gt 0 ]\n\
    \t\t\tthen\n\t\t\t\tcount=$(( $count + 1 ))\n\t\t\tfi\n\t\tdone\n\t\techo $count\n\
    \t}\n\tcount_nums", "  local count=0\n  for num in $1; do\n    # Don't count negative\
    \ numbers\n    if [[ $num -ge 0 ]]; then\n      continue\n    fi\n    # If there\
    \ is at least one positive digit, it's a hit\n    if printf \"%d\" \"$num\" |\
    \ grep -q \"^-.*[^0-9]\"; then\n      ((count++))\n    fi\n  done\n  echo \"$count\"",
  "    # shellcheck disable=SC2046\n    local result=\"$(echo $1 | tr ' ' '\\n' |\
    \ awk -v OFS='' '{sum=0; for (i=1; i<=NF; i++) {sum+=$i; sub(/^-/, \"\", $i);\
    \ sum+=length($i);} print sum;}')\"\n    echo \"$result\" | grep -c \"[1-9]\"",
  "  echo \"$1\" | awk 'BEGIN {count=0};\n                   {if ($1 < 0) signed_digit\
    \ = -1*substr($1,2,1);\n                    else signed_digit = substr($1,1,1);\n\
    \                    if (signed_digit > 0) count+=1};\n                    END\
    \ {print count}'", "    n=0\n    for i in $1\n    do\n        sum=0\n        for\
    \ d in $(echo \"$i\" | grep -o .); do\n            if [ \"$d\" != \"-\" ]; then\n\
    \                sum=$((sum + $d))\n            fi\n        done\n        if [\
    \ $sum -gt 0 ]; then\n            n=$((n + 1))\n        fi\n    done\n    echo\
    \ $n", "    COUNT=0\n    for i in $1; do\n        SUM=0\n        # If a number\
    \ is negative, then its first signed digit will be negative\n        SIGN=\"\"\
    \n        if [[ $i -lt 0 ]]; then\n            SIGN=\"-\"\n            i=$(( -i\
    \ ))\n        fi\n        while [[ $i -gt 0 ]]; do\n            (( SUM += (i %\
    \ 10) ))\n            (( i /= 10 ))\n        done\n        if [[ $SUM -gt 0 ]];\
    \ then\n            (( COUNT++ ))\n        fi\n    done\n    echo $COUNT", "\t\
    # substitute dash with space\n\t# extract digits\n\t# remove leading zeros\n\t\
    # sum and check if greater than zero\n\t# count results\n\techo \"$1\" | sed 's/-/\
    \ /g' | sed 's/[^[:digit:]]/ /g' | sed 's/^0*//' | awk '{sum = 0; for (i = 1;\
    \ i <= NF; i++) sum += $i; if (sum > 0) {print 1}}' | wc -l", "  local integers=(\"\
    $@\")\n  local count=0\n  local sum_of_digits=0\n  for integer in \"${integers[@]}\"\
    ; do\n    # iterate through all the digits and count the sum of digits\n    while\
    \ [[ $integer -ne 0 ]]; do\n      sum_of_digits=$((sum_of_digits + integer % 10))\n\
    \      integer=$((integer / 10))\n    done\n    if [[ $sum_of_digits -gt 0 ]];\
    \ then\n      ((count++))\n    fi\n    sum_of_digits=0\n  done\n  echo \"$count\"",
  '  # Your code here', "  local arr=${1//-/ -}\n  local sum=0\n  for n in $arr; do\n\
    \    n=${n##-}\n    local tmp=0\n    for d in $(seq 1 ${#n}); do\n      tmp=$((tmp\
    \ + n % 10))\n      n=$((n / 10))\n    done\n    if (( tmp > 0 )); then\n    \
    \  sum=$((sum + 1))\n    fi\n  done\n  echo $sum", "    local sum=0\n    local\
    \ count=0\n    local arg=0\n    for arg in $@\n    do\n        while [ $arg -ne\
    \ 0 ]\n        do\n            sum=$(( $arg % 10 + $sum ))\n            arg=$((\
    \ $arg / 10 ))\n        done\n        if [ $sum -gt 0 ]\n        then\n      \
    \      count=$(( $count + 1 ))\n        fi\n        sum=0\n    done\n    echo\
    \ $count", "    if [[ $# -eq 0 ]]; then\n        echo \"0\"\n        return\n\
    \    fi\n    # count the number of input numbers\n    N=$(echo \"$@\" | wc -w)\n\
    \    # signed digits can be negative\n    # -1 is to escape the last newline added\
    \ by tr\n    for v in $(echo \"$@\" | tr ' ' '\\n' | tr -d '\\n' | sed 's/-/ -/g'\
    \ | tr ' ' '\\n'); do\n        digit=$(($v % 10))\n        v=$(($v / 10))\n  \
    \      ((v < 0)) && ((digit *= -1))\n        while ((v != 0)); do\n          \
    \  digit=$(($digit + $v % 10))\n            v=$(($v / 10))\n        done\n   \
    \     # a number has sum of digits > 0\n        # we need to decrement N\n   \
    \     ((digit > 0)) && ((N--))\n    done\n    echo \"$N\"", "    local sum\n \
    \   local i\n    local nums\n    local count=0\n    nums=($1)\n    for i in \"\
    ${nums[@]}\"; do\n        sum=0\n        while [ $i -ne 0 ]; do\n            i=$((i/10))\n\
    \            sum=$((sum+i%10))\n        done\n        ((sum > 0)) && ((count++))\n\
    \    done\n    echo $count", "\tlist=\"$1\"\n\t# read builtin can take input from\
    \ stdin and read space-separated fields\n\t# into a list of variables. As a special\
    \ case, if there are no variables\n\t# read will take in one line from stdin.\n\
    \tread -a array <<< \"$list\"\n\t# We iterate over array, and print each element\
    \ that has a sum of digits\n\t# greater than 0\n\tfor element in \"${array[@]}\"\
    ; do\n\t\t# We loop until the number is greater than zero\n\t\twhile [ \"$element\"\
    \ -gt 0 ]; do\n\t\t\t# We use expr $element % 10 to get the last digit in the\
    \ number\n\t\t\t# and add it to our running sum\n\t\t\tsum=$((sum + element %\
    \ 10))\n\t\t\t# Now we divide $element by 10 to remove the last digit\n\t\t\t\
    element=$((element / 10))\n\t\tdone\n\t\t# If the number is less than zero, then\
    \ we do the same process but\n\t\t# with the absolute value.\n\t\twhile [ \"$element\"\
    \ -lt 0 ]; do\n\t\t\tsum=$((sum + element % 10))\n\t\t\telement=$((element / 10))\n\
    \t\tdone\n\t\t# If the sum is greater than 0, then we print the number.\n\t\t\
    if [ \"$sum\" -gt 0 ]; then\n\t\t\techo \"$element\"\n\t\tfi\n\t\t# Set sum back\
    \ to 0 for the next iteration\n\t\tsum=0\n\tdone", "    declare -i sum signed_digits\
    \ i num count\n    for num in $1; do\n        i=0\n        sum=0\n        while\
    \ [ $i -lt ${#num} ]; do\n            signed_digits=${num:$i:1}\n            ((i++))\n\
    \            if [[ $signed_digits == \"-\" ]]; then\n                signed_digits=-${num:$i:1}\n\
    \                ((i++))\n            fi\n            ((sum+=signed_digits))\n\
    \        done\n        if [[ $sum -gt 0 ]]; then\n            ((count++))\n  \
    \      fi\n    done\n    echo $count", "    local args=$(echo $1 | tr ' ' '\\\
    n')\n\n    # converts to abs, then adds up all digits\n    local num_sum() {\n\
    \        echo $(( $(echo ${1#-} | tr -d '\\n' | sed 's/./&+/g') 0 ))\n    }\n\n\
    \    local sum\n    for i in $args; do\n        sum=$(num_sum $i)\n        if\
    \ [ $sum -gt 0 ]; then\n            echo $i\n        fi\n    done | wc -l", " \
    \ sum=0\n  for i in $1; do\n    sum=0\n    for digit in $(echo \"$i\" | grep -o\
    \ .); do\n      sum=$(( $sum + ${digit#-} ))\n    done\n    [[ $sum -gt 0 ]] &&\
    \ (( counter++ ))\n  done\n  echo $counter", '    # your code here', "  for i\
    \ in $1; do\n    sum=0\n    for j in $(echo $i | grep -o .); do\n      sum=$((sum\
    \ + j))\n    done\n    if [ $sum -gt 0 ]; then\n      ((counter++))\n    fi\n\
    \  done\n  echo $counter", "    local sum\n    for num in $1; do\n        sum=0\n\
    \        num=$(echo $num | sed 's/-//')\n        while [ $num -gt 0 ]; do\n  \
    \          sum=$((sum + num % 10))\n            num=$((num / 10))\n        done\n\
    \        [ $sum -gt 0 ] && echo $sum\n    done | wc -l", "  count=0\n  for var\
    \ in $1\n  do\n    sum=0\n    if [[ $var < 0 ]]; then\n      var=$((-1 * var))\n\
    \    fi\n    while [[ $var > 0 ]]; do\n      sum=$((sum + var % 10))\n      var=$((var\
    \ / 10))\n    done\n    if [[ $sum -gt 0 ]]; then\n      count=$((count + 1))\n\
    \    fi\n  done\n  echo $count", "  declare -a arr=($1)\n  local -i i=0 j=0\n\
    \  local -i digits\n\n  for i in \"${arr[@]}\"; do\n    if ((i<0)); then\n   \
    \   local digits=($(echo \"${i:1}\" | grep -o .))\n    else\n      local digits=($(echo\
    \ \"$i\" | grep -o .))\n    fi\n    local -i sum=0\n    for digit in \"${digits[@]}\"\
    ; do\n      ((sum+=digit))\n    done\n    ((sum!=0)) && ((j++))\n  done\n  echo\
    \ \"$j\"", "  count=0\n  for num in $1; do\n    nums=0\n    if [[ $num =~ ^- ]];\
    \ then\n      nums+=$(echo $num | cut -c 2- | tr -d '\\-')\n    else\n      nums+=$(echo\
    \ $num | tr -d '\\-')\n    fi\n    if [[ $nums -gt 0 ]]; then\n      count=$((count+1))\n\
    \    fi\n  done\n  echo $count", "  declare -a input=($1)\n  echo \"input is:\
    \ ${input[@]}\"\n  local num_count=0\n  for num in ${input[@]}; do\n    local\
    \ signed_num=${num#-} # remove negative sign and save as local var\n    echo \"\
    signed_num is $signed_num\"\n    local -i sum=0\n    while [ $signed_num -gt 0\
    \ ]; do\n      sum=$((sum + signed_num % 10))\n      signed_num=$((signed_num\
    \ / 10))\n    done\n    echo \"sum is $sum\"\n    if [ $sum -gt 0 ]; then\n  \
    \    ((num_count++))\n    fi\n  done\n  echo $num_count", "  # Passed in numbers\
    \ can be any length, so we need to get their length\n  # and if their length is\
    \ less than 2, then we don't need to do the substring\n  # calculation, we can\
    \ just send those back after we check to see if it's\n  # negative or not.\n \
    \ #\n  # If the length is 2 or greater, then we need to substring the positive\n\
    \  # numbers so that we can get each digit and calculate the sum\n  local sum\
    \ counter=0\n  local arr=( $1 )\n  for num in \"${arr[@]}\"; do\n    length=${#num}\n\
    \    if [ $length -lt 2 ]; then\n      # If the length is less than 2, then we\
    \ can just check to see if it's a\n      # negative number. If it is, then we\
    \ need to do the calculation, so we\n      # pass the number to substr and then\
    \ use bc to get the digit, if it's\n      # not, then we just send it back.\n\
    \      if [ \"${num:0:1}\" == \"-\" ]; then\n        substring=$(substr $num 0)\n\
    \        sum=$(bc <<< \"$substring + $num\")\n      else\n        sum=$num\n \
    \     fi\n    else\n      # If the length is 2 or greater, then we need to do\
    \ the substring\n      # calculation, so we pass the number to substr and then\
    \ use bc to get\n      # the digit.\n      substring=$(substr $num 0)\n      sum=$(bc\
    \ <<< \"$substring + $num\")\n    fi\n    # If the sum is greater than 0, we increment\
    \ the counter by 1.\n    if [ $sum -gt 0 ]; then\n      counter=$((counter + 1))\n\
    \    fi\n  done\n  echo $counter", '    # your code here', "    local -i tot=0\n\
    \    for i in $1; do\n        while (( i )); do\n            (( tot += i % 10\
    \ ))\n            (( i /= 10 ))\n        done\n    done\n    echo $tot", "   \
    \ local input=\"$1\"\n    local nums=( $input )\n    for ((i=0; i<${#nums[@]};\
    \ i++)); do\n        local sum=0\n        local num=\"${nums[$i]}\"\n        local\
    \ sign=\"\"\n        # If the number is negative, then remove the sign and add\
    \ it\n        # back to the sum at the end\n        if [[ \"$num\" =~ ^- ]]; then\n\
    \            sign=\"-\"\n            num=\"${num#-}\"\n        fi\n        while\
    \ [ \"$num\" -gt 0 ]; do\n            sum=$((sum + num % 10))\n            num=$((num\
    \ / 10))\n        done\n        nums[$i]=\"$((sum * 10 + sign))\"\n    done\n\
    \    local positives=\"${nums[*]}\"\n    local count=0\n    for num in $positives;\
    \ do\n        if [ $num -gt 0 ]; then\n            count=$((count + 1))\n    \
    \    fi\n    done\n    echo \"$count\"", "    local array=$(echo $1 | tr ' ' '\\\
    n')\n    local count=0\n    for num in $array; do\n        sum=0\n        # add\
    \ the absolute value of signed digits\n        # using the modulus operator and\
    \ integer division\n        while [ $num -ne 0 ]; do\n            sum=$(( $sum\
    \ + $(( $num % 10 )) ))\n            num=$(( $num / 10 ))\n        done\n    \
    \    if [ $sum -gt 0 ]; then\n            count=$(( $count + 1 ))\n        fi\n\
    \    done\n    echo $count", "  sum=0\n  n=0\n  for num in $1; do\n    if [[ \"\
    $num\" -eq \"0\" ]]; then\n      sum=0\n    elif [[ \"$num\" -lt \"0\" ]]; then\n\
    \      sum=$(expr \"$num\" \\* -1)\n    else\n      sum=$num\n    fi\n    while\
    \ [[ \"$sum\" -gt \"0\" ]]; do\n      digit=$(expr \"$sum\" % 10)\n      sum=$(expr\
    \ \"$sum\" / 10)\n      sum=$(expr \"$sum\" + \"$digit\")\n    done\n    if [[\
    \ \"$sum\" -gt \"0\" ]]; then\n      n=$(expr \"$n\" + 1)\n    fi\n  done\n  echo\
    \ \"$n\"", "  sum=0\n  for i in $1; do\n    num=${i//-/} # remove -\n    while\
    \ [ $num -ne 0 ]; do\n      sum=$((sum + num % 10))\n      num=$((num / 10))\n\
    \    done\n    if [ $sum -gt 0 ]; then\n      echo -n \"$sum \"\n    fi\n    sum=0\n\
    \  done", "  # Our solution does not depend on bash but is written in Python\n\
    \  # because we have no way to know how to do this in Bash.\n\n  local -r input=$1\n\
    \  local -r tmp_file=$(mktemp)\n  echo \"$input\" > $tmp_file\n  cat $tmp_file\
    \ | ./count_nums.py\n  rm $tmp_file", "  declare -a digits=($1)\n  local sum=0\n\
    \  local total=0\n  for i in ${digits[@]}; do\n    if [ $i -lt 0 ]; then\n   \
    \   i=$((-1 * $i))\n    fi\n    while [ $i -gt 0 ]; do\n      sum=$((sum + $i\
    \ % 10))\n      i=$((i / 10))\n    done\n    [ $sum -gt 0 ] && total=$((total\
    \ + 1))\n    sum=0\n  done\n  echo $total", "    echo $1 | tr \" \" \"\\n\" |\
    \ awk 'BEGIN {sum = 0} {\n                                           for (i =\
    \ 1; i <= length($1); i++) {\n                                               ch\
    \ = substr($1, i, 1);\n                                               if (ch ==\
    \ \"-\") {\n                                                   continue;\n   \
    \                                            }\n                             \
    \                  sum += ch;\n                                           }\n\
    \                                           if (sum > 0) {\n                 \
    \                              print $1;\n                                   \
    \        }\n                                           sum = 0;\n            \
    \                             }' | wc -l", "  local input=\"$1\"\n  local count=0\n\
    \  for x in ${input}; do\n    # Extract the signed digits and sum them.\n    local\
    \ x_sum=0\n    for c in $(seq 1 ${#x}); do\n      # Extract character and convert\
    \ to digit.\n      x_sum=$((x_sum + ${x:c-1:1}))\n    done\n    if [[ ${x_sum}\
    \ -gt 0 ]]; then\n      count=$((count + 1))\n    fi\n  done\n  echo ${count}",
  "    # puts the list into array and then removes all negative signs\n    # from\
    \ first digit of negative numbers\n    local arr=(${1/-/ })\n    # a counter for\
    \ array elements that satisfy the condition\n    local positive_sums=0\n    for\
    \ i in \"${arr[@]}\"; do\n        # in bash, you can use (()) to do math\n   \
    \     local digits=($i)\n        local sum=0\n        for j in \"${digits[@]}\"\
    ; do\n            # in bash, ((sum+=(10#$j))) would be better,\n            #\
    \ but it is not supported by Zsh\n            sum=$((sum+10#$j))\n        done\n\
    \        if ((sum>0)); then\n            positive_sums=$((positive_sums+1))\n\
    \        fi\n    done\n    echo \"$positive_sums\"", "    local count=0\n    for\
    \ i in $1; do\n        num=\"$(echo \"$i\" | grep '^[-]\\?[0-9]\\+$')\"\n    \
    \    if [ -n \"$num\" ]; then\n            sum=0\n            for j in $(echo\
    \ \"$num\" | fold -w1); do\n                sum=$(( sum + j ))\n            done\n\
    \            if [ \"$sum\" -gt 0 ]; then\n                count=$(( count + 1\
    \ ))\n            fi\n        fi\n    done\n    echo \"$count\"", "  count=0\n\
    \  for num in $1; do\n    sum=0\n    absnum=${num#-}\n    while [ \"$absnum\"\
    \ -gt 0 ]; do\n      ((sum+=absnum%10))\n      ((absnum/=10))\n    done\n    if\
    \ [ \"$sum\" -gt 0 ]; then\n      ((count++))\n    fi\n  done\n  echo \"$count\"",
  "    local result=0\n    for i in $@; do\n        local sum=0\n        for j in\
    \ `echo $i | sed 's/-//g'`; do\n            let sum+=j\n        done\n       \
    \ if [[ $i =~ ^- ]]; then\n            ((sum = -sum))\n        fi\n        if\
    \ [[ $sum -gt 0 ]]; then\n            ((result += 1))\n        fi\n    done\n\
    \    echo $result", "\tlocal -a list\n\tlocal num\n\tlocal sd\n\tlocal sum\n\t\
    local count\n\tlist=($1)\n\tcount=0\n\tfor num in \"${list[@]}\"; do\n\t\tsum=0\n\
    \t\t# signed digits\n\t\tfor sd in $(seq -1 -1 \"$num\"); do\n\t\t\tsum=$((sum\
    \ + sd))\n\t\tdone\n\t\tif ((sum)); then\n\t\t\tcount=$((count + 1))\n\t\tfi\n\
    \tdone\n\techo \"$count\"", "    if [[ -z \"$1\" ]]; then\n        echo \"0\"\n\
    \        return\n    fi\n    # $1 is a space-separated list\n    # build an array\
    \ by splitting the string on spaces\n    read -a nums <<< \"$1\"\n    local count=0\n\
    \    for num in \"${nums[@]}\"; do\n        if [[ $num -lt 0 ]]; then\n      \
    \      num=${num:1}\n        fi\n        local num_sum=0\n        while [[ $num\
    \ -gt 0 ]]; do\n            num_sum=$((num_sum + num % 10))\n            num=$((num\
    \ / 10))\n        done\n        if [[ $num_sum -gt 0 ]]; then\n            count=$((count\
    \ + 1))\n        fi\n    done\n    echo \"$count\"", "    awk '\n    BEGIN {\n\
    \        z = 0\n    }\n    {\n        # do not accept \"0\" as positive number\n\
    \        if ($1 ~ /^-?[1-9]/ ) {\n            s = 0\n            for (i = 1; i\
    \ <= length($1); i++) {\n                s += substr($1, i, 1)\n            }\n\
    \            if (s > 0) {\n                z++\n            }\n        }\n   \
    \ }\n    END {\n        print z\n    }\n    ' <(echo \"$1\")", "\tfor i in $1;\
    \ do\n\t\tsum=0\n\t\tfor d in `echo \"$i\" | sed -e 's/^\\(-\\)*//'`; do\n\t\t\
    \tsum=$((sum + d))\n\t\tdone\n\t\tif [[ sum -gt 0 ]]; then\n\t\t\techo -n \"$i\
    \ \"\n\t\tfi\n\tdone", "    declare -a nums=($1)\n    declare count=0\n    for\
    \ num in \"${nums[@]}\"; do\n        declare sum=0\n        for digit in $(echo\
    \ \"$num\" | grep -o .); do\n            declare d=$(echo \"$digit\" | sed -e\
    \ 's/^-//')\n            declare n=$(($d+0))\n            sum=$(($sum+$n))\n \
    \       done\n        if [ \"$sum\" -gt 0 ]; then\n            count=$(($count+1))\n\
    \        fi\n    done\n    echo \"$count\"", "  # Split the input string by whitespace\
    \ and assign the tokens to an array\n  local array=( $1 )\n  local count=0\n \
    \ local i=0\n  local sum=0\n  local number=0\n  local sign=1\n  # Iterate through\
    \ the array of integers\n  for number in \"${array[@]}\"; do\n    # Check if the\
    \ element is negative\n    if [ $number -lt 0 ]; then\n      # Set the sign to\
    \ negative\n      sign=-1\n      # Get the absolute value of the number\n    \
    \  number=$(( -number ))\n    else\n      # Set the sign to positive\n      sign=1\n\
    \    fi\n    # Set the sum to 0\n    sum=0\n    # Perform the sum of digits calculation\n\
    \    while [ $number -gt 0 ]; do\n      # Extract the last digit from the number\n\
    \      sum=$(( sum + number % 10 ))\n      # Remove the last digit from the number\n\
    \      number=$(( number / 10 ))\n    done\n    # Set the sum to the sum of digits\
    \ multiplied by the sign\n    sum=$(( sum * sign ))\n    # Check if the sum is\
    \ greater than 0\n    if [ $sum -gt 0 ]; then\n      # Increment the counter\n\
    \      count=$(( count + 1 ))\n    fi\n  done\n  # Print the number of numbers\
    \ that sum to a number greater than 0\n  echo $count", "    local ar=\"$@\"\n\
    \    local count=0\n    local num\n    # declare a hash and initialize it to a\
    \ blank value\n    declare -A digits\n    for num in ${ar}; do\n        local\
    \ sum=0\n        local digit\n        # split the number into digits\n       \
    \ for digit in $(echo \"${num}\" | fold -w1); do\n            # deal with negative\
    \ numbers\n            if [ \"${digit}\" == \"-\" ]; then\n                digit=0\n\
    \            fi\n            sum=$(( ${sum} + ${digit} ))\n        done\n    \
    \    # if the sum of the digits is non-zero, add 1 to the count\n        if [\
    \ ${sum} -gt 0 ]; then\n            ((count++))\n        fi\n    done\n    echo\
    \ \"${count}\"", "    if [ -z \"$1\" ]; then\n        echo \"0\"\n        return\n\
    \    fi\n    local IFS=\" \"\n    local numbers=($1)\n    local total=0\n    for\
    \ number in \"${numbers[@]}\"; do\n        local digit_sum=0\n        local int_number=${number#-}\n\
    \        local digits=$(to_digits \"$int_number\")\n        for digit in $digits;\
    \ do\n            digit_sum=$((digit_sum + digit))\n        done\n        if ((digit_sum\
    \ > 0)); then\n            total=$((total + 1))\n        fi\n    done\n    echo\
    \ \"$total\"", "\t# FIXME\n\techo \"0\"", "  if [[ -z \"$1\" ]]; then\n    echo\
    \ \"0\"\n    return\n  fi\n  declare -a arr=(\"$@\")\n  count=0\n  for i in \"\
    ${arr[@]}\"; do\n    if (( $i < 0 )); then\n      i=${i:1}\n    fi\n    while\
    \ [[ \"$i\" -gt 0 ]]; do\n      rem=$(( i % 10 ))\n      (( count += rem ))\n\
    \      (( i /= 10 ))\n    done\n    if (( count > 0 )); then\n      (( count=0\
    \ ))\n      (( cnt++ ))\n    fi\n  done\n  echo \"$cnt\"", "    echo \"$1\" |\
    \ awk 'BEGIN { sum = 0 }{\n        if ($1 > 0) {\n            sum += $1\n    \
    \    } else {\n            sum += -$1\n        }\n    }\n    END { print sum }'",
  '    echo -n ""', "\tlocal arr=($1)\n\tlocal nums=0\n\tfor num in ${arr[@]}; do\n\
    \t\tlocal sum=0\n\t\tlocal pos=$num\n\t\twhile [[ $pos -ne 0 ]]; do\n\t\t\tlocal\
    \ rem=$((pos % 10))\n\t\t\tpos=$((pos / 10))\n\t\t\tsum=$((sum + rem))\n\t\tdone\n\
    \t\tif [[ $sum -gt 0 ]]; then\n\t\t\tnums=$((nums + 1))\n\t\tfi\n\tdone\n\techo\
    \ $nums", "  # BEGIN\n  wc -w <<< $1\n  # END", "    local n z\n    n=0\n    for\
    \ z in $1; do\n        if (( z < 0 )); then\n            z=${z:1}\n        fi\n\
    \        [[ $z =~ [^0-9] ]] && continue\n        (( z % 9 == 0 )) && (( n++ ))\n\
    \    done\n    echo $n", "\techo $(echo $1 | tr ' ' '\\n' | grep '[^-]\\d*' |\
    \ grep -v '[^-]\\d\\d*' | wc -l)", "  local n\n  local result\n  local tmp\n \
    \ result=0\n  for n in $1; do\n    tmp=$n\n    if [[ $n -lt 0 ]]; then\n     \
    \ n=$(( -n ))\n    fi\n    tmp=0\n    while [[ $n -gt 0 ]]; do\n      tmp=$((\
    \ tmp + n % 10 ))\n      n=$(( n / 10 ))\n    done\n    if [[ $tmp -gt 0 ]]; then\n\
    \      result=$(( result + 1 ))\n    fi\n  done\n  echo $result", "    echo \"\
    $1\" | awk '{\n        sum=0\n        for (i=1; i<=NF; i++) {\n            if\
    \ ($i < 0) {\n                sum += -1 * (int(-$i/10) + -$i%10)\n           \
    \ } else {\n                sum += int($i/10) + $i%10\n            }\n       \
    \ }\n        if (sum > 0) {\n            printf(\"%d \", sum)\n        }\n   \
    \ }' | wc -w", "    array=($1)\n    count=0\n    for i in \"${array[@]}\"; do\n\
    \        num=\"$i\"\n        sum=0\n        if [ \"$i\" -lt 0 ]; then\n      \
    \      num=\"$((-1 * i))\"\n        fi\n        while [ \"$num\" -gt 0 ]; do\n\
    \            sum=$((sum + num % 10))\n            num=$((num / 10))\n        done\n\
    \        if [ \"$sum\" -gt 0 ]; then\n            count=$((count + 1))\n     \
    \   fi\n    done\n    echo \"$count\"", "\tlocal total=0\n\tlocal number\n\tfor\
    \ number in $@; do\n\t\t# Trim leading '-' sign from number\n\t\tnumber=${number##-}\n\
    \t\tlocal sum=0\n\t\twhile [ $number -gt 0 ]; do\n\t\t\tsum=$((sum + number %\
    \ 10))\n\t\t\tnumber=$((number / 10))\n\t\tdone\n\t\t[ $sum -gt 0 ] && total=$((total\
    \ + 1))\n\tdone\n\techo $total", "    local nums=($1)\n    local cnt=0\n    for\
    \ num in ${nums[@]}; do\n        sum=0\n        while [ $num -ne 0 ]; do\n   \
    \         sum=$((sum + num % 10))\n            num=$((num / 10))\n        done\n\
    \        if [ $sum -gt 0 ]; then\n            cnt=$((cnt + 1))\n        fi\n \
    \   done\n    echo $cnt", "  local -i count=0\n\n  for e in $1; do\n    local\
    \ sum=0\n    local n=$e\n    if (( $e < 0 )); then\n      n=$(($e * -1))\n   \
    \ fi\n    while (( $n > 0 )); do\n      sum=$(($sum + ($n % 10)))\n      n=$(($n\
    \ / 10))\n    done\n    if (( $sum > 0 )); then\n      count=$(($count + 1))\n\
    \    fi\n  done\n\n  echo $count", "    local -a array\n    array=($1)\n    local\
    \ size=${#array[@]}\n    local result=0\n    for ((i=0; i<size; i++)); do\n  \
    \      local sum=0\n        local num=${array[$i]}\n        while [ $num -ne 0\
    \ ]; do\n            local sign=${num#-}\n            local digit=${sign#*[^0-9]}\n\
    \            sum=$((sum + digit))\n            num=$((num / 10))\n        done\n\
    \        if [ $sum -gt 0 ]; then\n            result=$((result + 1))\n       \
    \ fi\n    done\n    echo $result", "\tlocal result=0\n\tfor i in $1\n\tdo\n\t\t\
    local sum=0\n\t\t# Compute sum of digits\n\t\tfor j in $(echo $i | tr -d '-')\n\
    \t\tdo\n\t\t\tsum=$((sum + j))\n\t\tdone\n\t\t# Is this number positive?\n\t\t\
    if [ $(echo $i | sed 's/-//') -eq $i ]\n\t\tthen\n\t\t\tif [ $sum -gt 0 ]\n\t\t\
    \tthen\n\t\t\t\tresult=$((result + 1))\n\t\t\tfi\n\t\telse\n\t\t\tif [ $sum -lt\
    \ 0 ]\n\t\t\tthen\n\t\t\t\tresult=$((result + 1))\n\t\t\tfi\n\t\tfi\n\tdone\n\t\
    echo $result", "  for item in $1\n  do\n    if [ $item -lt 0 ]\n    then\n   \
    \   # don't have to worry about wrapping around using the mod operator\n     \
    \ # but it's a good idea to take the absolute value anyway\n      first_digit=$((\
    \ ($item % -10) * -1 ))\n    else\n      first_digit=$(( $item % 10 ))\n    fi\n\
    \    # since we can't have an array, we'll have to concatenate the elements\n\
    \    # in string form and then eval it\n    str+=\" $first_digit\"\n  done\n \
    \ # set the special shell variable IFS to a newline, so bash will split the\n\
    \  # string into an array on the newline character\n  IFS=$'\\n'\n  # this is\
    \ to prevent counting leading whitespace\n  str=${str#\" \"}\n  # this is to prevent\
    \ counting trailing whitespace\n  str=${str%\" \"}\n  # now we can turn the string\
    \ back into an array\n  array=($str)\n  # and finally, return the length of the\
    \ array\n  echo \"${#array[@]}\"", "  local input=\"$1\"\n  # TODO: your code\
    \ goes here!\n  # 1. Split the space-separated list into an array.\n  #    (Google\
    \ is your friend).\n  # 2. Check whether each element has a non-zero sum of digits.\n\
    \  #    (use a for loop).\n  # 3. Count and return the number of elements with\
    \ a non-zero sum of digits.\n  #    (use a variable to store the count).\n  local\
    \ count=0\n  local num_arr=()\n  #read -a num_arr <<< $(echo $input)\n  echo $input\n\
    \  for elem in $(echo $input)\n  do\n    num_arr+=(\"$elem\")\n  done\n  local\
    \ elem\n  for elem in ${num_arr[@]}\n  do\n    echo $elem\n    local sum=0\n \
    \   local num=$elem\n    local s_dig=${num:0:1}\n    if [ \"$s_dig\" = \"-\" ]\n\
    \    then\n      num=${num:1}\n    fi\n    local d\n    for d in $(echo $num)\n\
    \    do\n      sum=$((sum+d))\n    done\n    echo $sum\n    if [ \"$sum\" -gt\
    \ \"0\" ]\n    then\n      count=$((count+1))\n    fi\n  done\n  echo $count",
  "    for i in $1\n    do\n        signed_digits=\"$(echo $i | grep -o -e [0-9] -e\
    \ '-' | tr -d '\\n')\"\n        sum=0\n        for digit in $signed_digits\n \
    \       do\n            sum=$(( sum + digit ))\n        done\n        if [ $sum\
    \ -gt 0 ]\n        then\n            count=$(( count + 1 ))\n        fi\n    done\n\
    \    echo $count", "    declare -a numbers=($1)\n    local signed_digits\n   \
    \ local count=0\n    for i in \"${numbers[@]}\"; do\n        signed_digits=${i#-}\n\
    \        signed_digits=${signed_digits//[^[:digit:]]/}\n        if [ $((${signed_digits//[^[:digit:]]/}))\
    \ -gt 0 ]; then\n            count=$((count + 1))\n        fi\n    done\n    echo\
    \ $count", "  local sign\n  local i\n  local t\n  local nums\n\n  for i in $1;\
    \ do\n    sign=1\n    if [ $i -lt 0 ]; then\n      sign=-1\n    fi\n    t=0\n\
    \    while [ $i -ne 0 ]; do\n      t=$((t + sign * (i % 10)))\n      i=$((i /\
    \ 10))\n    done\n    if [ $t -gt 0 ]; then\n      nums=$((nums + 1))\n    fi\n\
    \  done\n  echo $nums", "  local cnt=0\n  for num in $1; do\n    sum=0\n    for\
    \ digit in $(echo $num | sed -e 's/\\-//g'); do\n      sum=$((sum + digit))\n\
    \    done\n    if [[ $sum -gt 0 ]]; then\n      cnt=$((cnt + 1))\n    fi\n  done\n\
    \  echo $cnt", "    nums=$(echo $1 | tr ' ' '\\n')\n    count=0\n    for num in\
    \ $nums; do\n        sum_of_digits=$(($(echo ${num//-/} | tr -d '0-9' | sed 's/./&+/g'\
    \ | tr -d '\\n')0))\n        if [ \"$sum_of_digits\" -gt 0 ]; then\n         \
    \   count=$((count+1))\n        fi\n    done\n    echo $count", "  local list=$1\n\
    \  sum=0\n  for n in $list; do\n    if [[ $n -lt 0 ]]; then\n      n=${n:1}\n\
    \    fi\n    sum=$((sum + $(get_nums_sum $n)))\n  done\n  echo \"$sum\"", "  \
    \  local nums=\"$1\"\n    local num\n    local sum\n    local count=0\n    for\
    \ num in $nums; do\n        # negate num if it is negative, else num itself\n\
    \        sum=$(echo \"$num\" | tr -d - | tr -cd 0-9 | awk '{sum=0; for(i=1;i<=NF;i++)\
    \ sum+=$i; print sum}')\n        [ $sum -gt 0 ] && count=$((count+1))\n    done\n\
    \    echo $count", "  n=0\n  for i in $1; do\n    s=0\n    if ((i<0)); then s+=$((-i%10));\
    \ i=$((-i/10)); else s+=$((i%10)); i=$((i/10)); fi\n    while ((i>0)); do\n  \
    \    s+=$((i%10))\n      i=$((i/10))\n    done\n    ((s>0)) && ((n++))\n  done\n\
    \  echo $n", "    local arr=($1)\n    local count=0\n    for i in \"${arr[@]}\"\
    ; do\n        if !(( $i < 0 )); then\n            i=$(( i < 0 ? -i : i ))\n  \
    \      fi\n        local sum=0\n        while (( i > 0 )); do\n            local\
    \ digit=$(( i % 10 ))\n            sum=$(( sum + digit ))\n            i=$(( i\
    \ / 10 ))\n        done\n        (( sum > 0 )) && (( count++ ))\n    done\n  \
    \  echo \"$count\"", "  #  if [[ \"$1\" == \"\" ]]; then\n  #    echo \"0\"\n\
    \  #  else\n  #    echo \"$1\" | awk '{sum=0; for (i=1; i<=NF; i++) {for (j=1;\
    \ j<=length($i); j++) {sum+=substr($i,j,1)};if (sum>0) print \"1\"};}' | wc -l\n\
    \  #  fi\n  awk '{sum=0; for (i=1; i<=NF; i++) {for (j=1; j<=length($i); j++)\
    \ {sum+=substr($i,j,1)};if (sum>0) print \"1\"};}' <<< \"$1\" | wc -l", "    list=\"\
    $1\"\n    count=0\n    for num in $list; do\n        sum_digits \"$num\" | \\\n\
    \            awk '{if ($1 > 0) print}' | \\\n            read && count=$((count\
    \ + 1))\n    done\n    echo \"$count\"", "    # TODO: write your code here!\n\
    \    nums=($1)\n    count=0\n    for i in ${nums[@]}; do\n        if [ $i -lt\
    \ 0 ]; then\n            sum_digits=$((-$i%10-$i/10%10-$i/100%10))\n        else\n\
    \            sum_digits=$((i%10+i/10%10+i/100%10))\n        fi\n        if [ $sum_digits\
    \ -gt 0 ]; then\n            count=$((count+1))\n        fi\n    done\n    echo\
    \ $count", "    local sum=0\n    for i in $1; do\n        local n=${i##-}\n  \
    \      local sum=0\n        for ((j=0; j<${#n}; j++)); do\n            ((sum +=\
    \ n[j]))\n        done\n        ((sum > 0)) && echo \"$i\"\n    done | wc -l",
  "  local sum\n  local nums_list=($1)\n  local num\n  for num in \"${nums_list[@]}\"\
    ; do\n    (( $(abs_sum_digits $num) > 0 )) && ((sum++))\n  done\n  echo $sum",
  "    # TODO: Implement count_nums function.\n    #\n    # Hint: If you are unfamiliar\
    \ with bash, you may find the following\n    # resources useful:\n    #  - http://mywiki.wooledge.org/BashFAQ/001\n\
    \    #  - http://mywiki.wooledge.org/BashGuide\n    #  - http://wiki.bash-hackers.org/start\n\
    \    #  - http://www.gnu.org/software/bash/manual/bashref.html\n    #  - http://linuxcommand.org/lc3_adv_tput.php\n\
    \    #  - http://tldp.org/LDP/abs/html/arithexp.html\n    #  - http://tldp.org/LDP/abs/html/string-manipulation.html\n\
    \    #  - http://tldp.org/LDP/abs/html/dblparens.html\n    #  - http://wiki.bash-hackers.org/commands/classictest\n\
    \    #  - http://mywiki.wooledge.org/ArithmeticExpression\n    declare -i cnt=0\n\
    \    declare -i a\n    declare -i b\n    declare -i c\n    declare -i d\n    declare\
    \ -i e\n    declare -i f\n    declare -i g\n    declare -i h\n    declare -i i\n\
    \    declare -i j\n    declare -i k\n    declare -i l\n    declare -i m\n    declare\
    \ -i n\n    declare -i o\n    declare -i p\n    declare -i q\n    declare -i r\n\
    \    declare -i s\n    declare -i t\n    declare -i u\n    declare -i v\n    declare\
    \ -i w\n    declare -i x\n    declare -i y\n    declare -i z\n    for i in $1\n\
    \    do\n        if [ $i -lt 0 ]\n        then\n            a=$i\n           \
    \ b=$(( -a ))\n            c=$(($b % 10))\n            d=$(( $b / 10 ))\n    \
    \        e=$(( $d % 10 ))\n            f=$(( $d / 10 ))\n            g=$(( $f\
    \ % 10", "    local nums=\"$1\"\n    local num\n\n    local count=0\n    for num\
    \ in $nums; do\n        #\n        # Modify the following line to add counting\
    \ logic\n        #\n        :\n    done\n\n    echo \"$count\"", "  local IFS=$'\
    \ '\n  local numbers=()\n  for value in $1; do\n    numbers+=( $value )\n  done\n\
    \  for ((i=0; i<${#numbers[@]}; i++)); do\n    local value=${numbers[$i]}\n  \
    \  local abs_value=${value#-}\n    local sum=0\n    for ((j=0; j<${#abs_value};\
    \ j++)); do\n      sum=$(( sum + ${abs_value:$j:1} ))\n    done\n    [[ $value\
    \ -lt 0 ]] && (( sum = sum - 9 ))\n    (( sum > 0 )) && echo \"${numbers[$i]}\"\
    \n  done | wc -l", "  local IFS=\n  for v in $1; do\n    local C=0\n    for c\
    \ in $(echo $v | sed 's/-\\(.\\)/\\1/'); do\n      C=$((C + c))\n    done\n  \
    \  if [[ $C -gt 0 ]]; then\n      echo -n \"$v \"\n    fi\n  done", "  local -i\
    \ i n sum\n  local -a arr=()\n\n  i=0; arr=(); sum=0\n  while read n; do\n   \
    \ arr[i++]=$n\n  done <<< \"$1\"\n\n  i=0; sum=0\n  while (( i < ${#arr[@]} ));\
    \ do\n    n=${arr[i++]}\n    if (( n < 0 )); then\n      sum=$(( n - n ))\n  \
    \  else\n      sum=$n\n    fi\n    while (( sum > 0 )); do\n      sum=$(( sum\
    \ / 10 ))\n      (( sum > 0 )) && (( n = n + 1 ))\n    done\n    if (( n > 0 ));\
    \ then\n      (( i = i + 1 ))\n    fi\n  done\n\n  echo \"$i\"", "    echo \"\
    $1\" | tr ' ' '\\n' | \n        while read num; do\n            if [[ $num ==\
    \ -* ]]; then\n                # compute_sum of digits\n                sum=$(echo\
    \ $num | sed -E 's/[-0-9]+//g' | sed -E 's/./&+/g' | bc)\n                echo\
    \ $sum\n            else\n                echo $num\n            fi\n        done\
    \ |\n        tr '\\n' ' ' | sed -E 's/([0-9]+) /\\1\\n/g' | wc -l", "  sum=0\n\
    \  for i in $1; do\n    if [[ $i < 0 ]]; then\n      i=${i:1}\n    fi\n    for\
    \ j in $(echo $i | sed 's/./& /g'); do\n      ((sum += $j))\n    done\n    if\
    \ [[ $sum > 0 ]]; then\n      ((count++))\n    fi\n    sum=0\n  done\n  echo $count",
  "    local -i i=0 j=0\n    local numsum=0\n    local -a nums=( $1 )\n    for ((i=0;\
    \ i<${#nums[@]}; i++)); do\n        numsum=0\n        for ((j=0; j<${#nums[i]};\
    \ j++)); do\n            (( numsum += ${nums[i]:$j:1} ))\n        done\n     \
    \   if (( numsum > 0 )); then\n            (( counter++ ))\n        fi\n    done\n\
    \    echo \"$counter\"", "    # Put your code here.\n    echo $#", "  declare\
    \ -a nums=($1)\n  declare -i count=0\n  for num in \"${nums[@]}\"; do\n    declare\
    \ -i sum=0\n    for digit in $(echo $num | sed -e 's/-//' | sed -e 's/\\(.\\)/\\\
    1 /g'); do\n      let sum+=$digit\n    done\n    if [ $sum -gt 0 ]; then\n   \
    \   let count++\n    fi\n  done\n  echo $count", "  declare -a ary=(\"$@\")\n\
    \  declare sum num\n  for num in \"${ary[@]}\"; do\n    if (( 0 < num )); then\n\
    \      sum=0\n      while (( 0 < num )); do\n        (( sum += num % 10 ))\n \
    \       (( num /= 10 ))\n      done\n      (( 0 < sum )) && (( ++i ))\n    elif\
    \ (( 0 > num )); then\n      num=-num\n      sum=0\n      while (( 0 < num ));\
    \ do\n        (( sum += num % 10 ))\n        (( num /= 10 ))\n      done\n   \
    \   (( 0 < sum )) && (( ++i ))\n    fi\n  done\n  echo \"$i\"", "  read -a nums\
    \ <<< \"$1\"\n  count=0\n  for n in \"${nums[@]}\"; do\n    if (($n < 0)); then\n\
    \      n=$((-$n))\n    fi\n    sum=0\n    while (($n > 0)); do\n      m=$((n %\
    \ 10))\n      n=$((n / 10))\n      sum=$((sum + m))\n    done\n    if (($sum >\
    \ 0)); then\n      count=$((count + 1))\n    fi\n  done\n  echo \"$count\"", " \
    \ local sum=0\n  local count=0\n  local num\n  for num in $1; do\n    sum=0\n\
    \    while [ $num -ne 0 ]; do\n      let sum+=$num%10\n      let num/=10\n   \
    \ done\n    if [ $sum -gt 0 ]; then\n      let count+=1\n    fi\n  done\n  echo\
    \ $count", "    local arr=\"$1\"\n    local count=0\n    for num in $arr; do\n\
    \        local digits=()\n        local sign=1\n        if [ \"$num\" -lt 0 ];\
    \ then\n            sign=-1\n            num=$((-num))\n        fi\n        while\
    \ [ \"$num\" -gt 0 ]; do\n            digits+=($((num % 10)))\n            num=$((num\
    \ / 10))\n        done\n        local sum=0\n        for digit in ${digits[@]};\
    \ do\n            sum=$((sum + digit))\n        done\n        sum=$((sum * sign))\n\
    \        if [ \"$sum\" -gt 0 ]; then\n            count=$((count + 1))\n     \
    \   fi\n    done\n    echo \"$count\"", "    local total=\"0\"\n    for number\
    \ in $1; do\n        if ((number < 0)); then\n            local num_sign=\"-1\"\
    \n        else\n            local num_sign=\"1\"\n        fi\n        local sum=\"\
    0\"\n        for ((digit = number; digit; digit /= 10)); do\n            ((sum\
    \ += digit % 10))\n        done\n        if ((num_sign * sum > 0)); then\n   \
    \         ((total++))\n        fi\n    done\n    echo \"$total\"", "\tlocal n\n\
    \tlocal n_abs\n\tlocal n_num_digits\n\tlocal n_sum_digits=0\n\tlocal n_sum_digits_abs\n\
    \tlocal count=0\n\tlocal i\n\tlocal sig\n\t\n\tfor n in $1; do\n\t\tn_abs=${n#-}\
    \ # remove leading minus if any\n\t\tn_num_digits=${#n_abs}\n\t\tn_sum_digits=0\n\
    \t\t\n\t\t# Compute the sum of digits\n\t\tfor ((i=0; i<n_num_digits; i++)); do\n\
    \t\t\t((n_sum_digits+=${n_abs:i:1}))\n\t\tdone\n\t\t\n\t\t# If the number is negative,\
    \ then its first signed digit is negative\n\t\t# hence need to subtract it\n\t\
    \tsig=${n:0:1}\n\t\t((sig=='-')) && ((n_sum_digits+=${n:1:1}))\n\t\t\n\t\t((n_sum_digits>0))\
    \ && ((count++))\n\tdone\n\t\n\techo \"$count\"", "  local cnt=0\n  for num in\
    \ $@; do\n    signed_digits=0\n    for (( i=1; i<=${#num}; i++ )); do\n      [\
    \ \"${num:$i-1:1}\" -lt 0 ] && signed_digits=$((num)) && break\n      signed_digits=$((signed_digits\
    \ + ${num:$i-1:1}))\n    done\n    (( signed_digits > 0 )) && (( cnt++ ))\n  done\n\
    \  echo $cnt", "\tlocal list=\"$1\"\n\tlocal sum\n\tlocal count=0\n\tfor num in\
    \ $list; do\n\t\tlocal sum=0\n\t\tlocal sign=1\n\t\tif [ $num -lt 0 ]; then\n\t\
    \t\tlocal sign=-1\n\t\t\tnum=$((-num))\n\t\tfi\n\t\twhile [ $num -gt 0 ]; do\n\
    \t\t\tlocal digit=$((num % 10))\n\t\t\tsum=$((sum + digit))\n\t\t\tnum=$((num\
    \ / 10))\n\t\tdone\n\t\tif [ $((sign * sum)) -gt 0 ]; then\n\t\t\tcount=$((count\
    \ + 1))\n\t\tfi\n\tdone\n\techo $count", "  local sum=0\n  for i in $1; do\n \
    \   sum=0\n    for (( ; $i != 0; i=$i/10 )) do\n      sum=$(( sum + ($i % 10)\
    \ ))\n    done\n    (( sum > 0 )) && echo $i\n  done | wc -l", "    # echo \"\
    $@\"\n    # create new array with only positive elements\n    s=$(echo \"$@\"\
    \ | tr ' ' '\\n' | grep -E '^[0-9]+$')\n    #echo \"$s\"\n    # convert to array\n\
    \    a=($s)\n    #echo \"${a[@]}\"\n    b=()\n    for x in \"${a[@]}\"; do\n \
    \       # echo \"$x\"\n        # check if its negative\n        if [[ $x =~ ^\\\
    - ]]; then\n            x=${x:1}\n        fi\n        # now test if its positive\n\
    \        if [[ $x =~ ^[0-9]+$ ]]; then\n            # echo \"$x\"\n          \
    \  # sum of digits\n            d=($(echo \"$x\" | grep -o .))\n            #echo\
    \ \"${d[@]}\"\n            sum=0\n            for i in \"${d[@]}\"; do\n     \
    \           sum=$((sum + i))\n            done\n            # echo \"$sum\"\n\
    \            # if sum greater than 0, add it to the new array\n            if\
    \ [[ $sum -gt 0 ]]; then\n                b+=(\"$x\")\n            fi\n      \
    \  fi\n    done\n    # count elements in the new array\n    n=${#b[@]}\n    echo\
    \ \"$n\"", "  local -i sum=0\n  for num in $1; do\n    ((num < 0)) && ((num =\
    \ -num))\n    while ((num > 0)); do\n      ((sum += num % 10))\n      ((num /=\
    \ 10))\n    done\n    ((sum > 0)) && ((sum=1)) || ((sum=0))\n    echo -n \"$sum\
    \ \"\n  done", "  local input=($1)\n  local output=0\n  for i in \"${input[@]}\"\
    ; do\n    local num_abs=$(echo $i | sed 's/-//g')\n    local sum=0\n    while\
    \ [ $num_abs -gt 0 ]; do\n      local digit=$((num_abs % 10))\n      sum=$((sum\
    \ + digit))\n      num_abs=$((num_abs / 10))\n    done\n    if [ $sum -gt 0 ];\
    \ then\n      output=$((output + 1))\n    fi\n  done\n  echo $output", "\tlocal\
    \ sum=0\n\tlocal i=0\n\tlocal nums=$1\n\tfor num in $nums; do\n\t\tfor digit in\
    \ $(echo \"$num\" | sed -E \"s/[^0-9]+/ /g\"); do\n\t\t\tsum=$(( $sum + $digit\
    \ ))\n\t\tdone\n\t\tif [ $sum -gt 0 ]; then\n\t\t\ti=$(( $i + 1 ))\n\t\tfi\n\t\
    \tsum=0\n\tdone\n\techo $i", "    IFS=' ' read -ra NUMBERS <<< \"$1\"\n    local\
    \ -i cnt=0\n    for number in \"${NUMBERS[@]}\"; do\n        if (( number < 0\
    \ )); then\n            (( number = 0 - number ))\n        fi\n        local -i\
    \ sum=0\n        while (( number > 0 )); do\n            (( sum += number % 10\
    \ ))\n            (( number /= 10 ))\n        done\n        if (( sum > 0 ));\
    \ then\n            (( cnt++ ))\n        fi\n    done\n    echo \"$cnt\"", " \
    \   # Fill in this function.\n    # You can use `bc` to do arbitrary precision\
    \ calculations.\n    # See: http://www.gnu.org/software/bc/manual/html_mono/bc.html\n\
    \    # http://www.unix.com/shell-programming-scripting/153428-bc-command-non-numeric-argument.html\n\
    \    local string_arr=($1)\n    local count=0\n    for element in ${string_arr[@]}\n\
    \    do\n        num=${element#-}\n        sum=0\n        for i in `seq 1 ${#num}`\n\
    \        do\n            digit=${num:$((i-1)):1}\n            sum=$(($sum + $digit))\n\
    \        done\n        if [ $sum -gt 0 ]\n        then\n            count=$(($count\
    \ + 1))\n        fi\n    done\n    echo $count", "  declare -i sum=0\n  declare\
    \ -i count=0\n  for i in $1; do\n    if [ $i -lt 0 ]; then\n      i=-$i\n    fi\n\
    \    for j in $(echo $i | sed -e 's/\\(.\\)/\\1 /g'); do\n      sum=$(( sum +\
    \ j ))\n    done\n    if [ $sum -gt 0 ]; then\n      count=$(( count + 1 ))\n\
    \    fi\n    sum=0\n  done\n  echo $count", "  local args=( $1 )\n  local num=0\n\
    \  for arg in \"${args[@]}\"; do\n    if [[ $arg < 0 ]]; then\n      arg=$(( $arg\
    \ * -1 ))\n    fi\n    local sum=0\n    for (( ; arg > 0; arg /= 10 )); do\n \
    \     local digit=$(( arg % 10 ))\n      (( sum += digit ))\n    done\n    ((\
    \ sum > 0 )) && (( num++ ))\n  done\n  echo $num", "  # local IFS=$'\\n'  # break\
    \ on newline\n  local IFS=' '\n  local -a args=($1)\n  # iterate over args\n \
    \ local result=0\n  for arg in \"${args[@]}\"; do\n    local sum=0\n    local\
    \ -i number=arg\n    if ((number < 0)); then\n      number=-number\n    fi\n \
    \   while ((number > 0)); do\n      sum+=$((number % 10))\n      number=$((number\
    \ / 10))\n    done\n    if ((sum > 0)); then\n      ((result++))\n    fi\n  done\n\
    \  echo $result", "    local total=0\n    for i in $@; do\n        local sum=0\n\
    \        local num=${i#-}\n        while [ $num -gt 0 ]; do\n            local\
    \ rem=$((num % 10))\n            sum=$((sum + rem))\n            num=$((num /\
    \ 10))\n        done\n        if [ $i -lt 0 ]; then\n            sum=$((sum -\
    \ (i % 10)))\n        fi\n        if [ $sum -gt 0 ]; then\n            total=$((total\
    \ + 1))\n        fi\n    done\n    echo $total", '  echo "not implemented"', " \
    \ local cnt\n  cnt=0\n  for num in $1; do\n    # Naive solution\n    #\n    #\
    \ local sum\n    # sum=0\n    # for digit in $(echo \"$num\" | grep -o '.'); do\n\
    \    #   ((sum += digit))\n    # done\n    # if ((sum > 0)); then\n    #   ((cnt++))\n\
    \    # fi\n\n    # Elegant solution\n    if [ \"$num\" -gt 0 ]; then\n      ((cnt++))\n\
    \    else\n      ((num *= -1))\n      local first_digit\n      first_digit=\"\
    ${num:0:1}\"\n      if ((first_digit > 0)); then\n        ((cnt++))\n      fi\n\
    \    fi\n  done\n  echo \"$cnt\"", "    local array=($1)\n    local len=${#array[@]}\n\
    \    local count=0\n    for ((i=0; i<$len; i++)); do\n        sum=0\n        #\
    \ sum all the digits of the number\n        local n=${array[$i]}\n        if [[\
    \ $n -lt 0 ]]; then\n            n=$((n * -1))\n        fi\n        while [[ $n\
    \ -gt 0 ]]; do\n            sum=$((sum + n % 10))\n            n=$((n / 10))\n\
    \        done\n        if [[ $sum -gt 0 ]]; then\n            count=$((count +\
    \ 1))\n        fi\n    done\n    echo $count", "    local i j res=0\n    for i\
    \ in $1; do\n        j=${i:1}\n        j=${j//[^0-9]/}\n        j=${j//[0-9]/\\\
    \ +}\n        (( ${#j} == 0 || $((${j::-1})) > 0 )) && (( res++ ))\n    done\n\
    \    echo $res", "    local list=\"$@\"\n    local count=0\n    for el in $list;\
    \ do\n        if [ $el -lt 0 ]; then\n            el=${el:1}\n        fi\n   \
    \     local sum=0\n        for (( i=0; i<${#el}; i++ )); do\n            sum=$((\
    \ $sum + ${el:$i:1} ))\n        done\n        if [ $sum -gt 0 ]; then\n      \
    \      count=$(( $count + 1 ))\n        fi\n    done\n    echo $count", "    local\
    \ nums=($1)\n    local sum=0\n    local count=0\n    for n in \"${nums[@]}\";\
    \ do\n        if (( n < 0 )); then\n            n=$((-n))\n        fi\n      \
    \  sum=0\n        while (( n > 0 )); do\n            sum=$((sum + n % 10))\n \
    \           n=$((n / 10))\n        done\n        if (( sum > 0 )); then\n    \
    \        count=$((count + 1))\n        fi\n    done\n    echo \"$count\"", "\t\
    local -a array=($1)\n\tlocal count=0\n\tfor item in \"${array[@]}\"; do\n\t\t\
    if [[ \"$item\" =~ ^-?[0-9]+$ ]]; then\n\t\t\tsum=0\n\t\t\tfor (( i=0; i<${#item};\
    \ i++ )); do\n\t\t\t\t(( sum+=${item:$i:1} ))\n\t\t\tdone\n\t\t\tif (( sum>0 ));\
    \ then\n\t\t\t\t(( count++ ))\n\t\t\tfi\n\t\tfi\n\tdone\n\techo \"$count\"", " \
    \   nums=($1)\n    for i in \"${nums[@]}\"; do\n        total=0\n        for ((j=0;\
    \ j<${#i}; j++)); do\n            total=$((total + ${i:$j:1}))\n        done\n\
    \        if [ $total -gt 0 ]; then\n            count=$((count + 1))\n       \
    \ fi\n    done\n    echo $count", "  local arg=\"$1\"\n  echo $arg | \\\n    tr\
    \ ' ' '\\n' | \\\n    awk '{\n      split($1, a, \"\");\n      for (i in a) {\n\
    \        if (a[i] == \"-\") {\n          sign = -1;\n        } else {\n      \
    \    sum += a[i];\n        }\n      }\n      if (sign * sum > 0) {\n        res\
    \ += 1;\n      }\n      sum = 0;\n      sign = 1;\n    } END {\n      print res;\n\
    \    }'", "  # write your function here\n  readarray -t arr <<< \"$1\"\n  counter=0\n\
    \  for i in \"${arr[@]}\"; do\n      [ $i -lt 0 ] && i=${i:1}\n      i=$(printf\
    \ \"%s\" \"$i\" | fold -w1 | paste -sd+ | bc)\n      [ $i -gt 0 ] && counter=$((counter+1))\n\
    \  done\n  echo $counter", "    local result=0\n    local item=0\n    local sum=0\n\
    \    local digit=0\n    local digits=$(echo \"$1\" | tr \" \" \"\\n\")\n    for\
    \ item in $digits; do\n        sum=0\n        for digit in $(echo $item | grep\
    \ -o \".\"); do\n            sum=$((sum + digit))\n        done\n        if [\
    \ $sum -gt 0 ]; then\n            result=$((result + 1))\n        fi\n    done\n\
    \    echo $result", "  local i\n  local count=0\n  for i in $1\n  do\n    local\
    \ signed_digits=$(get_signed_digits $i)\n    local sum=$(add $signed_digits)\n\
    \    if [ \"$sum\" -gt \"0\" ]\n    then\n      (( count += 1 ))\n    fi\n  done\n\
    \  echo $count", "    local num_str=\"$1\"\n    local count=0\n    for num in\
    \ ${num_str}; do\n        count=$((count + 1))\n    done\n    echo \"${count}\"",
  "    local cnt=0\n    local sum=0\n    local num\n    for num in $@; do\n      \
    \  if [[ $num = -* ]]; then\n            sum=$(( ${num:1:1} ))\n        else\n\
    \            sum=$(( ${num:0:1} ))\n        fi\n        num=${num#[+-]?}\n   \
    \     while [[ $num ]]; do\n            (( sum += ${num:0:1} ))\n            num=${num#?}\n\
    \        done\n        (( sum > 0 )) && (( ++cnt ))\n    done\n    echo $cnt",
  "    n=0\n    for i in $1; do\n        d=0\n        for j in $(seq 0 $((${#i}-1)));\
    \ do\n            d=$((d + ${i:$j:1}))\n        done\n        (( d > 0 )) && ((\
    \ ++n ))\n    done\n    echo $n"]
stop_tokens:
- "\n}"
