name: HumanEval_19_sort_numbers
language: sh
prompt: "#!/bin/bash\n# Input is a space-delimited string of numberals from 'zero'\
  \ to 'nine'.\n# Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five',\
  \ 'six', 'seven', 'eight' and 'nine'.\n# Return the string with numbers sorted from\
  \ smallest to largest\n# >>> $(sort_numbers \"three one five\")\n# \"one three five\"\
  \n#\n# $1 is a string\nsort_numbers() {\n"
tests: "}\n\ncandidate() {\n    sort_numbers \"$@\"\n}\n\nset -e\nrun_test() {\n \
  \   [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"three\") = \"three\" ]]\n\
  \    [[ $(candidate \"three five nine\") = \"three five nine\" ]]\n    [[ $(candidate\
  \ \"five zero four seven nine eight\") = \"zero four five seven eight nine\" ]]\n\
  \    [[ $(candidate \"six five four three two one zero\") = \"zero one two three\
  \ four five six\" ]]\n}\n\nrun_test"
completions: ["  local -a array_of_numbers=$1\n  printf \"%s\\n\" ${array_of_numbers[@]}\
    \ | sort -n", "\t# TODO: ensure $1 is a string\n\t# TODO: ensure $1 contains only\
    \ valid words\n\t# TODO: ensure $1 contains no words not in the word_to_digit\
    \ map\n\t# TODO: sort the words using the word_to_digit map\n\t# TODO: reassemble\
    \ the string and echo it\n\tlocal words=$1\n\tlocal sort_array\n\tlocal word\n\
    \tlocal i=0\n\tfor word in ${words}; do\n\t\tsort_array[$i]=$(word_to_digit ${word})\n\
    \t\t(( i += 1 ))\n\tdone\n\techo \"${sort_array[@]}\" | tr ' ' '\\n' | sort -n\
    \ | tr '\\n' ' '", "    local number_text\n    local -i i\n    local num\n   \
    \ local tmp\n    local -i n\n    local -i nn\n    local sorted\n    local sorted_string\n\
    \n    number_text=($1)\n    num_text_length=${#number_text[@]}\n    sorted=($1)\n\
    \    sorted_string=\"\"\n\n    # Sort\n    for ((i=0; i<num_text_length; i++))\n\
    \    do\n        for ((j=i+1; j<num_text_length; j++))\n        do\n         \
    \   num=$(num_from_string ${number_text[i]})\n            nn=$(num_from_string\
    \ ${number_text[j]})\n            if [ $num -gt $nn ]\n            then\n    \
    \            tmp=${number_text[i]}\n                number_text[i]=${number_text[j]}\n\
    \                number_text[j]=$tmp\n            fi\n        done\n    done\n\
    \n    # Combine into string\n    for ((i=0; i<num_text_length; i++))\n    do\n\
    \        sorted_string=\"$sorted_string ${number_text[i]}\"\n    done\n\n    echo\
    \ $sorted_string", "    local numbers=($1)\n    local sorted=( )\n    local index=0\n\
    \    # \"declare -A\" creates an associative array (hash table)\n    declare -A\
    \ numbersToDigits=(\n        [zero]=0 [one]=1 [two]=2 [three]=3 [four]=4 [five]=5\
    \ [six]=6 [seven]=7 [eight]=8 [nine]=9\n    )\n    # Insertion sort: https://en.wikipedia.org/wiki/Insertion_sort\n\
    \    for ((i=0; i<${#numbers[@]}; i++)); do\n        # Search for the position\
    \ where the current element should be inserted\n        while ((index>0 && numbersToDigits[${numbers[$i]}]\
    \ < numbersToDigits[${sorted[$((index-1))]}])); do\n            let index--\n\
    \        done\n        # Insert the element to the sorted array\n        sorted[$index]=${numbers[$i]}\n\
    \        let index++\n    done\n    # Echo the sorted array, keeping only the\
    \ values (not the keys)\n    echo \"${sorted[@]}\"", "    local -r numbers_str=\"\
    $1\"\n    numbers=$(echo $numbers_str | tr ' ' '\\n' | sed 's/^0*//')\n    echo\
    \ $numbers | tr ' ' '\\n' | sort -n | tr '\\n' ' '", "    # Step 1: change the\
    \ string into a list\n    # list=($(echo $1 | tr \" \" \"\\n\"))\n    list=($(echo\
    \ $1))\n    # Step 2: setup an array to store result\n    result=()\n    # Step\
    \ 3: setup a dict to map numbers to numberal\n    num_dict=([zero]=0 [one]=1 [two]=2\
    \ [three]=3 [four]=4 [five]=5 [six]=6 [seven]=7 [eight]=8 [nine]=9)\n    # Step\
    \ 4: loop through list\n    for i in ${list[@]}; do\n        result[${num_dict[$i]}]=$i\n\
    \    done\n    # Step 5: output sorted list\n    for i in ${!result[@]}; do\n\
    \        echo ${result[$i]}\n    done", '  echo "$1" | tr " " "\n" | sort | tr
    "\n" " "', '  echo $1 | sort -n', "    #echo \"$1\" | tr ' ' '\\n' | sort -n |\
    \ tr '\\n' ' '\n    echo \"$1\" | tr ' ' '\\n' | sort -n | paste -sd ' ' -", " \
    \ declare -A num_map\n  num_map=([zero]=0 [one]=1 [two]=2 [three]=3 [four]=4 [five]=5\
    \ [six]=6 [seven]=7 [eight]=8 [nine]=9)\n  local result=\n  local -a int_list\n\
    \  while IFS= read -r num; do\n    int_list+=(${num_map[$num]})\n  done <<< \"\
    ${1// /$'\\n'}\"\n  for i in \"${int_list[@]}\"; do\n    for j in \"${int_list[@]}\"\
    ; do\n      if [[ $i -lt $j ]]; then\n        result+=\"${!num_map[$i]} \"\n \
    \       break\n      fi\n    done\n  done\n  echo $result", "  echo $1 | tr '\
    \ ' '\\n' | sort -n | tr '\\n' ' '", "    # This is not the best way to do this.\
    \ For example, if user includes \"one\" twice then it will only appear once in\
    \ output.\n    # Better: use array\n    # Bash guide says 'echo' is slow, as opposed\
    \ to 'printf'\n    declare -a sortedNums=$(printf %s\\\\n \"$1\" | tr ' ' '\\\
    n' | sort -k1,1 )\n    # s = string\n    # n = newline\n    # k1,1 = field 1\n\
    \    echo \"${sortedNums[@]}\"", "    # ----------\n    # Your code goes here\n\
    \    # ----------\n    echo \"$1\" | tr ' ' '\\n' | sort -n | tr '\\n' ' ' | xargs",
  "    local unsorted_numbers=(${1})\n    local numeral=\"\"\n    local sorted_numbers=()\n\
    \    declare -A numbers\n    numbers=( [\"zero\"]=0 [\"one\"]=1 [\"two\"]=2 [\"\
    three\"]=3 [\"four\"]=4 [\"five\"]=5 [\"six\"]=6 [\"seven\"]=7 [\"eight\"]=8 [\"\
    nine\"]=9 )\n    for numeral in \"${unsorted_numbers[@]}\"; do\n        sorted_numbers+=(${numbers[$numeral]})\n\
    \    done\n    IFS=$' ' sorted_numbers=($(for i in \"${sorted_numbers[@]}\"; do\
    \ echo \"$i\"; done | sort -n))\n    unset IFS\n    for i in \"${!sorted_numbers[@]}\"\
    ; do\n        for k in \"${!numbers[@]}\"; do\n            if [[ ${sorted_numbers[$i]}\
    \ -eq ${numbers[$k]} ]]; then\n                sorted_numbers[$i]=$k\n       \
    \     fi\n        done\n    done\n    echo \"${sorted_numbers[@]}\"", "    local\
    \ -a words=($1)\n    echo \"${words[@]}\" | tr ' ' '\\n' | sort | tr '\\n' ' '",
  "    # TODO: implement sort_numbers\n    # This is a stub that simply prints the\
    \ input.\n    # Delete this when you are ready.\n    echo $1", "    local numbers=($1)\n\
    \    local sorted=()\n    local max_num=9\n    local idx=0\n    while [ $idx -le\
    \ $max_num ]; do\n        for number in \"${numbers[@]}\"; do\n            [ \"\
    $(number_to_digit $number)\" == \"$idx\" ] && sorted+=($number)\n        done\n\
    \        idx=$((idx+1))\n    done\n    echo \"${sorted[@]}\"", "  # insert code\
    \ here\n  echo \"$1\" | tr ' ' '\\n' | sort | tr '\\n' ' '", "\techo \"$1\" |\
    \ tr ' ' '\\n' | sort -n | xargs", "\tif [ -z \"$1\" ]; then return; fi\n\tlocal\
    \ str=\"$1\"\n\tlocal arr=($str)\n\tlocal result=\"\"\n\t\n\t# Map numberal words\
    \ to their integer counterparts\n\tdeclare -A MAPPING=( [\"zero\"]=0 [\"one\"\
    ]=1 [\"two\"]=2 [\"three\"]=3 [\"four\"]=4 [\"five\"]=5 [\"six\"]=6 [\"seven\"\
    ]=7 [\"eight\"]=8 [\"nine\"]=9 )\n\t\n\t# Create a parallel array that contains\
    \ the corresponding integer for each word in the input\n\tfor i in ${!arr[@]};\
    \ do\n\t\tarr[$i]=${MAPPING[${arr[$i]}]}\n\tdone\n\t\n\t# Sort the parallel array\n\
    \tsort -n -k1 <<<\"${arr[*]}\" | read -a sort_arr\n\t\n\t# Write back to the $str\n\
    \tfor i in ${!sort_arr[@]}; do\n\t\tstr=${str//${arr[$i]}/${sort_arr[$i]}}\n\t\
    done\n\t\n\t# Map integer counterparts back to their numberal words\n\tfor i in\
    \ ${!sort_arr[@]}; do\n\t\tstr=${str//${sort_arr[$i]}/${MAPPING[${sort_arr[$i]}]}}\n\
    \tdone\n\t\n\t# Return the sorted string\n\techo \"$str\"", "    if [ \"$#\" -ne\
    \ 1 ]; then\n        echo \"Invalid arguments.\"\n        exit 1\n    fi\n\n \
    \   numbers=$1\n    echo $numbers | xargs -n1 | sort -n | xargs", "    # Ensure\
    \ string is of form 'a b c d'\n    if [ \"${1}\" = \"zero\" ]; then\n        printf\
    \ \"zero\\n\"\n    elif [ \"${1}\" = \"one\" ]; then\n        printf \"one\\n\"\
    \n    elif [ \"${1}\" = \"two\" ]; then\n        printf \"two\\n\"\n    elif [\
    \ \"${1}\" = \"three\" ]; then\n        printf \"three\\n\"\n    elif [ \"${1}\"\
    \ = \"four\" ]; then\n        printf \"four\\n\"\n    elif [ \"${1}\" = \"five\"\
    \ ]; then\n        printf \"five\\n\"\n    elif [ \"${1}\" = \"six\" ]; then\n\
    \        printf \"six\\n\"\n    elif [ \"${1}\" = \"seven\" ]; then\n        printf\
    \ \"seven\\n\"\n    elif [ \"${1}\" = \"eight\" ]; then\n        printf \"eight\\\
    n\"\n    elif [ \"${1}\" = \"nine\" ]; then\n        printf \"nine\\n\"\n    else\n\
    \        printf \"zero one two three four five six seven eight nine\\n\"\n   \
    \ fi", '    # Write your code here', "    echo -n $1 | tr ' ' '\\n' | sort | tr\
    \ '\\n' ' '", "    DICT=\"zero one two three four five six seven eight nine\"\n\
    \    for n in $(echo $1 | sed 's/ /\\n/g' | sort -g -k1,1 -t\" \"); do\n     \
    \   echo -n \"${DICT%% *} \"\n        DICT=\"${DICT#* }\"\n    done\n    echo",
  "    echo \"$1\" | awk '{\n        split(\"zero one two three four five six seven\
    \ eight nine\", n, \" \");\n        for (i = 1; i <= NF; i++) {\n            for\
    \ (j = 1; j <= 9; j++) {\n                if ($i == n[j]) {\n                \
    \    a[j] = $i;\n                }\n            }\n        }\n        for (i =\
    \ 1; i <= 9; i++) {\n            printf(\"%s%s\", a[i], (i < 9 ? OFS : ORS));\n\
    \        }\n    }'", "\t\n\t[ $# -eq 0 ] && return 1\n\t\n\tsort_numbers_helper\
    \ \"$1\" | tr '\\n' ' '\n\techo", "\t# YOUR CODE HERE\n\tlocal word=$1\n\tlocal\
    \ result=\"\"\n\tIFS=' ' read -r -a arr <<< \"$word\"\n\t# arr=(\"${arr[@]}\"\
    \ \"zero\")\n\n\t# echo $arr\n\t# echo ${#arr[@]}\n\t# echo ${arr[@]}\n\t# sort\
    \ arr \n\t# echo ${arr[@]}\n\tfor i in $(seq 0 9); do\n\t\tfor j in \"${arr[@]}\"\
    ; do\n\t\t\tif [ $j == \"zero\" ]; then\n\t\t\t\tresult+=\"0 \"\n\t\t\telif [\
    \ $j == \"one\" ]; then\n\t\t\t\tresult+=\"1 \"\n\t\t\telif [ $j == \"two\" ];\
    \ then\n\t\t\t\tresult+=\"2 \"\n\t\t\telif [ $j == \"three\" ]; then\n\t\t\t\t\
    result+=\"3 \"\n\t\t\telif [ $j == \"four\" ]; then\n\t\t\t\tresult+=\"4 \"\n\t\
    \t\telif [ $j == \"five\" ]; then\n\t\t\t\tresult+=\"5 \"\n\t\t\telif [ $j ==\
    \ \"six\" ]; then\n\t\t\t\tresult+=\"6 \"\n\t\t\telif [ $j == \"seven\" ]; then\n\
    \t\t\t\tresult+=\"7 \"\n\t\t\telif [ $j == \"eight\" ]; then\n\t\t\t\tresult+=\"\
    8 \"\n\t\t\telif [ $j == \"nine\" ]; then\n\t\t\t\tresult+=\"9 \"\n\t\t\tfi\n\t\
    \tdone\n\tdone\n\techo $result", "    # return if input is empty\n    if [ -z\
    \ \"$1\" ]; then\n        echo \"$1\"\n        return 0\n    fi\n\n    local src=$1\n\
    \    local temp=()\n    local nums=()\n    local idx=0\n\n    # convert number\
    \ to digit\n    for num in $src; do\n        temp[$idx]=$(($num))\n        idx=$(($idx\
    \ + 1))\n    done\n\n    # sort\n    for (( i = 0; i < ${#temp[@]}; i++ )); do\n\
    \        for (( j = 0; j < ${#temp[@]}; j++ )); do\n            if [ $((10#${temp[$i]}))\
    \ -lt $((10#${temp[$j]})) ]; then\n                # swap\n                nums[$i]=${temp[$j]}\n\
    \                temp[$j]=${temp[$i]}\n                temp[$i]=${nums[$i]}\n\
    \            fi\n        done\n    done\n\n    # convert digit to number\n   \
    \ idx=0\n    for num in ${temp[@]}; do\n        case \"$num\" in\n           \
    \ 0) nums[$idx]=\"zero\" ;;\n            1) nums[$idx]=\"one\" ;;\n          \
    \  2) nums[$idx]=\"two\" ;;\n            3) nums[$idx]=\"three\" ;;\n        \
    \    4) nums[$idx]=\"four\" ;;\n            5) nums[$idx]=\"five\" ;;\n      \
    \      6) nums[$idx]=\"six\" ;;\n            7) nums[$idx]=\"seven\" ;;\n    \
    \        8) nums[$idx]=\"eight\" ;;\n            9) nums[$idx]=\"nine\" ;;\n \
    \       esac\n        idx=$(($idx + 1))\n    done\n\n    echo \"${nums[@]}\"",
  "  local elements\n  elements=( $1 )\n  for i in {0..10}; do\n    for j in ${elements[@]};\
    \ do\n      [[ $j == $i ]] && echo -n \"$j \"\n    done\n  done", "\t# TODO: Fill\
    \ in this function\n\t# my approach\n\t#echo \"$1\" |\n\t#sed -e 's/zero/0/g'\
    \ -e 's/one/1/g' -e 's/two/2/g' -e 's/three/3/g' -e 's/four/4/g' -e 's/five/5/g'\
    \ -e 's/six/6/g' -e 's/seven/7/g' -e 's/eight/8/g' -e 's/nine/9/g' |\n\t#sort\
    \ -n |\n\t#sed -e 's/0/zero/g' -e 's/1/one/g' -e 's/2/two/g' -e 's/3/three/g'\
    \ -e 's/4/four/g' -e 's/5/five/g' -e 's/6/six/g' -e 's/7/seven/g' -e 's/8/eight/g'\
    \ -e 's/9/nine/g' |\n\t#tr '\\n' ' '\n\t# answer\n\techo \"$1\" |\n\tsed -e 's/zero/00/g'\
    \ -e 's/one/01/g' -e 's/two/02/g' -e 's/three/03/g' -e 's/four/04/g' -e 's/five/05/g'\
    \ -e 's/six/06/g' -e 's/seven/07/g' -e 's/eight/08/g' -e 's/nine/09/g' |\n\tsort\
    \ -n |\n\tsed -e 's/00/zero/g' -e 's/01/one/g' -e 's/02/two/g' -e 's/03/three/g'\
    \ -e 's/04/four/g' -e 's/05/five/g' -e 's/06/six/g' -e 's/07/seven/g' -e 's/08/eight/g'\
    \ -e 's/09/nine/", "  if [ -z \"$1\" ]; then return 1; fi\n  echo \"$1\" | tr\
    \ ' ' '\\n' | sort -n | tr '\\n' ' '", "    # convert $1 into a space-delimited\
    \ array\n    declare -a numbers=${1// / }\n    # convert names of numbers into\
    \ their corresponding integers\n    declare -a converted_numbers=()\n    for number\
    \ in ${numbers[@]}; do\n        case ${number} in\n            zero) converted_numbers+=(0)\
    \ ;;\n            one) converted_numbers+=(1) ;;\n            two) converted_numbers+=(2)\
    \ ;;\n            three) converted_numbers+=(3) ;;\n            four) converted_numbers+=(4)\
    \ ;;\n            five) converted_numbers+=(5) ;;\n            six) converted_numbers+=(6)\
    \ ;;\n            seven) converted_numbers+=(7) ;;\n            eight) converted_numbers+=(8)\
    \ ;;\n            nine) converted_numbers+=(9) ;;\n        esac\n    done\n  \
    \  # sort array of integers\n    sorted_numbers=$(echo ${converted_numbers[@]}\
    \ | tr ' ' '\\n' | sort -n | tr '\\n' ' ')\n    # convert integers back into names\
    \ of numbers\n    declare -a sorted_strings=()\n    for number in ${sorted_numbers[@]};\
    \ do\n        case ${number} in\n            0) sorted_strings+=(zero) ;;\n  \
    \          1) sorted_strings+=(one) ;;\n            2) sorted_strings+=(two) ;;\n\
    \            3) sorted_strings+=(three) ;;\n            4) sorted_strings+=(four)\
    \ ;;\n            5) sorted_strings+=(five) ;;\n            6) sorted_strings+=(six)\
    \ ;;\n            7) sorted_strings+=(seven) ;;\n            8) sorted_strings+=(eight)\
    \ ;;\n            9) sorted_strings+=(nine) ;;\n        esac\n    done\n    #\
    \ return sorted array of strings\n    echo ${sorted_strings[@]}", "    local words=($1)\n\
    \    local numbers=()\n    local number\n    local i=0\n    local n=${#words[@]}\n\
    \    while [ $i -lt $n ]; do\n        number=$(word_to_number ${words[$i]})\n\
    \        numbers[$i]=$number\n        i=$((i+1))\n    done\n    i=0\n    quicksort\
    \ 0 $((n-1))\n    while [ $i -lt $n ]; do\n        numbers[$i]=$(number_to_word\
    \ ${numbers[$i]})\n        i=$((i+1))\n    done\n    echo ${numbers[@]}", "  #\
    \ your code here\n  echo $1 | sed -e 's/nine/9/g' \\\n\t\t\t  -e 's/eight/8/g'\
    \ \\\n\t\t\t  -e 's/seven/7/g' \\\n\t\t\t  -e 's/six/6/g' \\\n\t\t\t  -e 's/five/5/g'\
    \ \\\n\t\t\t  -e 's/four/4/g' \\\n\t\t\t  -e 's/three/3/g' \\\n\t\t\t  -e 's/two/2/g'\
    \ \\\n\t\t\t  -e 's/one/1/g' \\\n\t\t\t  -e 's/zero/0/g' |\n\t\t\t  tr ' ' '\\\
    n' |\n\t\t\t  sort -n |\n\t\t\t  tr '\\n' ' ' |\n\t\t\t  sed -e 's/9/nine/g' \\\
    \n\t\t\t  \t  -e 's/8/eight/g' \\\n\t\t\t  \t  -e 's/7/seven/g' \\\n\t\t\t  \t\
    \  -e 's/6/six/g' \\\n\t\t\t  \t  -e 's/5/five/g' \\\n\t\t\t  \t  -e 's/4/four/g'\
    \ \\\n\t\t\t  \t  -e 's/3/three/g' \\\n\t\t\t  \t  -e 's/2/two/g' \\\n\t\t\t \
    \ \t  -e 's/1/one/g' \\\n\t\t\t  \t  -e 's/0/zero/g'", "  local output=\"\"\n\
    \  local -A num_dict\n  num_dict=( [\"zero\"]=0 [\"one\"]=1 [\"two\"]=2 [\"three\"\
    ]=3 [\"four\"]=4 [\"five\"]=5 [\"six\"]=6 [\"seven\"]=7 [\"eight\"]=8 [\"nine\"\
    ]=9 )\n  for num in $1\n  do\n    output=\"$output ${num_dict[$num]}\"\n  done\n\
    \  echo $(echo $output | tr ' ' '\\n' | sort -n | tr '\\n' ' ')", "  # your solution\
    \ here\n  local array=($1)\n  local len=${#array[@]}\n  local index=0\n  while\
    \ [ $index -lt $len ]\n  do\n    local jndex=$index\n    while [ $jndex -lt $len\
    \ ]\n    do\n      local num1=$(echo ${array[$index]} | sed 's/zero/0/g' | sed\
    \ 's/one/1/g' | sed 's/two/2/g' | sed 's/three/3/g' | sed 's/four/4/g' | sed 's/five/5/g'\
    \ | sed 's/six/6/g' | sed 's/seven/7/g' | sed 's/eight/8/g' | sed 's/nine/9/g')\n\
    \      local num2=$(echo ${array[$jndex]} | sed 's/zero/0/g' | sed 's/one/1/g'\
    \ | sed 's/two/2/g' | sed 's/three/3/g' | sed 's/four/4/g' | sed 's/five/5/g'\
    \ | sed 's/six/6/g' | sed 's/seven/7/g' | sed 's/eight/8/g' | sed 's/nine/9/g')\n\
    \      if [ $num1 -gt $num2 ]\n      then\n        local temp=${array[$index]}\n\
    \        array[$index]=${array[$jndex]}\n        array[$jndex]=$temp\n      fi\n\
    \      let jndex++\n    done\n    let index++\n  done\n  local array2=()\n  local\
    \ value\n  for value in ${array[@]}\n  do\n    if [ $value = \"0\" ]\n    then\n\
    \      value=\"zero\"\n    elif [ $value = \"1\" ]\n    then\n      value=\"one\"\
    \n    elif [ $value = \"2\" ]\n    then\n      value=\"two\"\n    elif [ $value\
    \ = \"3\" ]\n    then\n      value=\"three\"\n    elif [ $value = \"4\" ]", "\t\
    # Validate input\n\tis_numbers_string \"$1\"\n\tif [[ $? -ne 0 ]]; then\n\t\t\
    echo \"ERROR: $1 is not a valid string of numbers from 'zero' to 'nine'\" >&2\n\
    \t\treturn 1\n\tfi\n\n\t# Define the mapping between numbers and their lexicographical\
    \ order.\n\tdeclare -A number_to_order=([\"zero\"]=0 [\"one\"]=1 [\"two\"]=2 [\"\
    three\"]=3 [\"four\"]=4 [\"five\"]=5 [\"six\"]=6 [\"seven\"]=7 [\"eight\"]=8 [\"\
    nine\"]=9)\n\n\t# Sort the array\n\tIFS=\" \" read -r -a numbers <<< \"$1\"\n\t\
    for ((i=0; i<${#numbers[@]}; i++)); do\n\t\tnumbers[$i]=$(printf \"%02d %s\" \"\
    ${number_to_order[${numbers[$i]}]}\" \"${numbers[$i]}\")\n\tdone\n\tsorted_numbers=($(sort\
    \ <<< \"${numbers[*]}\"))\n\n\t# Remove the leading number from each sorted string\n\
    \tfor ((i=0; i<${#sorted_numbers[@]}; i++)); do\n\t\tsorted_numbers[$i]=$(echo\
    \ \"${sorted_numbers[$i]}\" | awk '{ print $2 }')\n\tdone\n\n\t# Print the sorted\
    \ strings\n\techo \"${sorted_numbers[*]}\"", "    IFS=' ' read -r -a array <<<\
    \ \"$1\"\n    declare -A num_map=([\"zero\"]=0 [\"one\"]=1 [\"two\"]=2 [\"three\"\
    ]=3 [\"four\"]=4 [\"five\"]=5 [\"six\"]=6 [\"seven\"]=7 [\"eight\"]=8 [\"nine\"\
    ]=9)\n    declare -a arr_map=()\n    for num in \"${array[@]}\"; do\n        arr_map=(\"\
    ${arr_map[@]}\" \"${num_map[$num]}\")\n    done\n    IFS=$'\\n' sorted=($(sort\
    \ <<<\"${arr_map[*]}\"))\n    unset IFS\n    for sorted_num in \"${sorted[@]}\"\
    ; do\n        for num in \"${!num_map[@]}\"; do\n            if [[ \"${num_map[$num]}\"\
    \ == \"$sorted_num\" ]]; then\n                echo -n \"$num \"\n           \
    \ fi\n        done\n    done\n    echo", "\tNUMBERS=($(echo \"$1\" | tr ' ' '\\\
    n' | sort))\n\techo \"${NUMBERS[@]}\"", "  local -a num_array=(\"zero\" \"one\"\
    \ \"two\" \"three\" \"four\" \"five\" \"six\" \"seven\" \"eight\" \"nine\")\n\
    \  local -a temp_array\n  local -a final_array\n  for i in $1; do\n    for j in\
    \ ${!num_array[@]}; do\n      if [ \"$i\" == \"${num_array[$j]}\" ]; then\n  \
    \      temp_array+=($j)\n      fi\n    done\n  done\n  IFS=$'\\n' sorted=($(sort\
    \ <<<\"${temp_array[*]}\"))\n  for j in ${sorted[@]}; do\n    final_array+=(${num_array[$j]})\n\
    \  done\n  printf \"%s \" \"${final_array[@]}\"", "\t# print the numbers in sorted\
    \ order\n\techo $@ | tr ' ' '\\n' | sort | tr '\\n' ' '", "\tlocal string=$1\n\
    \tIFS=' ' read -r -a words <<< \"$string\"\n\tlocal numbers=()\n\tfor word in\
    \ \"${words[@]}\"; do\n\t\tcase \"$word\" in\n\t\t\t\"zero\") numbers+=0 ;;\n\t\
    \t\t\"one\") numbers+=1 ;;\n\t\t\t\"two\") numbers+=2 ;;\n\t\t\t\"three\") numbers+=3\
    \ ;;\n\t\t\t\"four\") numbers+=4 ;;\n\t\t\t\"five\") numbers+=5 ;;\n\t\t\t\"six\"\
    ) numbers+=6 ;;\n\t\t\t\"seven\") numbers+=7 ;;\n\t\t\t\"eight\") numbers+=8 ;;\n\
    \t\t\t\"nine\") numbers+=9 ;;\n\t\tesac\n\tdone\n\tnumbers=($(printf \"%s\\n\"\
    \ \"${numbers[@]}\" | sort -n))\n\tlocal words=()\n\tfor number in \"${numbers[@]}\"\
    ; do\n\t\tcase \"$number\" in\n\t\t\t0) words+=zero ;;\n\t\t\t1) words+=one ;;\n\
    \t\t\t2) words+=two ;;\n\t\t\t3) words+=three ;;\n\t\t\t4) words+=four ;;\n\t\t\
    \t5) words+=five ;;\n\t\t\t6) words+=six ;;\n\t\t\t7) words+=seven ;;\n\t\t\t\
    8) words+=eight ;;\n\t\t\t9) words+=nine ;;\n\t\tesac\n\tdone\n\techo \"${words[@]}\"",
  "  echo $1 | tr ' ' '\\n' | sort -n | tr '\\n' ' '", "  # declare -a num_array=(\"\
    zero\" \"one\" \"two\" \"three\" \"four\" \"five\" \"six\" \"seven\" \"eight\"\
    \ \"nine\")\n  echo $1 | tr ' ' '\\n' | sort -n | tr '\\n' ' '", "    # write\
    \ your code here\n    arr=`echo $1 | sed -e 's/ /\\n/g'`\n    echo \"$arr\" |\
    \ sort -n | tr '\\n' ' '", "  if [ $# -eq 0 ]; then\n    exit 1\n  fi\n  echo\
    \ $1 | tr \" \" \"\\n\" | sort | tr \"\\n\" \" \"", "    # TODO\n    echo $1 |\
    \ tr \" \" \"\\n\" | sort -n | tr \"\\n\" \" \"", "\tsorted=($(echo \"$1\" | xargs\
    \ -n1 | sort -k1.1))\n\techo \"${sorted[@]}\"", "    # replace all spaces with\
    \ line break\n    local -a number_array=($(echo $1 | tr ' ' '\\n'))\n    # sort\
    \ array and replace all line breaks with space and output\n    echo \"${number_array[@]}\"\
    \ | sort | tr '\\n' ' '", "    for i in $(echo $1 | sed 's/ /\\n/g' | sort -n);\
    \ do\n        echo -n $i | tr 0 zero | tr 1 one | tr 2 two | tr 3 three | tr 4\
    \ four | tr 5 five | tr 6 six | tr 7 seven | tr 8 eight | tr 9 nine | tr \"\\\
    n\" \" \";\n    done;\n    echo;", "  (($# == 1)) || err \"sort_numbers() requires\
    \ one argument\"\n  local string=\"$1\"\n  # Return the sorted string here\n \
    \ echo \"${string}\"", "   declare -A numtodig\n   numtodig=( [\"zero\"]=0 [\"\
    one\"]=1 [\"two\"]=2 [\"three\"]=3 [\"four\"]=4 [\"five\"]=5 [\"six\"]=6 [\"seven\"\
    ]=7 [\"eight\"]=8 [\"nine\"]=9 )\n   local -i tmp\n   for i in $1; do\n      tmp+=\"\
    \ ${numtodig[$i]}\"\n   done\n   printf \"%s\" $( echo $tmp | tr \" \" \"\\n\"\
    \ | sort -n | tr \"\\n\" \" \" )", "  local result=\"\"\n  IFS=' ' read -ra nums\
    \ <<< \"$1\"\n  local -A num_map=(\n    [zero]=0\n    [one]=1\n    [two]=2\n \
    \   [three]=3\n    [four]=4\n    [five]=5\n    [six]=6\n    [seven]=7\n    [eight]=8\n\
    \    [nine]=9\n  )\n  for num in \"${nums[@]}\"; do\n    for i in \"${!num_map[@]}\"\
    ; do\n      if [[ \"$num\" == \"$i\" ]]; then\n        result=\"$result ${num_map[$i]}\"\
    \n      fi\n    done\n  done\n  echo \"$result\" | sort -n | sed -e 's/^ *//g'\
    \ -e 's/ / /g' | tr ' ' '\\n' | xargs -I {} echo \"$(sed -n $(echo {} | sed 's/^/\\\
    '/;s/$/p/'))\"", "    numbers=($1)\n    sorted_numbers=()\n    for (( i=0; i<${#numbers[@]};\
    \ i++ )); do\n        for (( j=0; j<${#numbers[@]}; j++ )); do\n            if\
    \ [[ ${numbers[$i]} == ${numbers[$j]} ]]; then\n                continue\n   \
    \         fi\n            if [[ $(( $(str_to_num ${numbers[$i]}) - $(str_to_num\
    \ ${numbers[$j]}) )) -le 0 ]]; then\n                tmp_num=${numbers[$i]}\n\
    \                numbers[$i]=${numbers[$j]}\n                numbers[$j]=$tmp_num\n\
    \            fi\n        done\n    done\n    for (( i=0; i<${#numbers[@]}; i++\
    \ )); do\n        sorted_numbers+=(\"${numbers[$i]}\")\n    done\n    echo \"\
    ${sorted_numbers[@]}\"", "\techo \"Given string: $1\"\n\techo \"Sorted string:\
    \ $(echo $1 | tr ' ' '\\n' | sort | tr '\\n' ' ')\"", "    if [[ $# -ne 1 ]];\
    \ then\n        echo \"ERROR: Need exactly one argument\"\n        return\n  \
    \  fi\n    echo \"$1\" | tr \" \" \"\\n\" | sort -n | tr \"\\n\" \" \"", "  echo\
    \ \"$1\" | tr ' ' '\\n' | sort -g | tr '\\n' ' '", "  if [ \"$#\" -ne 1 ]; then\n\
    \    echo \"sort_numbers() requires exactly one argument\"\n    exit 1\n  fi\n\
    \  local -A nums\n  nums[zero]=0\n  nums[one]=1\n  nums[two]=2\n  nums[three]=3\n\
    \  nums[four]=4\n  nums[five]=5\n  nums[six]=6\n  nums[seven]=7\n  nums[eight]=8\n\
    \  nums[nine]=9\n  local -a converted\n  local -a converted_keys\n  local -a returned\n\
    \  local retval=\"\"\n  local max=0\n  local i=0\n  local j=0\n  local k=0\n \
    \ # Convert the string to numbers\n  for word in $1; do\n    word=$(to_lower \"\
    $word\")\n    if [ -z \"${nums[$word]}\" ]; then\n      echo \"\\\"$word\\\" is\
    \ not a valid number\"\n      exit 1\n    fi\n    converted[$i]=${nums[$word]}\n\
    \    i=$((i+1))\n  done\n  # Sort the array\n  max=$((i-1))\n  for ((j=0; j<=max;\
    \ j++)); do\n    for ((k=0; k<=max; k++)); do\n      if [ ${converted[$j]} -lt\
    \ ${converted[$k]} ]; then\n        temp=${converted[$j]}\n        converted[$j]=${converted[$k]}\n\
    \        converted[$k]=$temp\n      fi\n    done\n  done\n  # Convert the numbers\
    \ back to strings\n  for i in ${converted[@]}; do\n    for j in ${!nums[@]}; do\n\
    \      if [ $i -eq ${nums[$j]} ]; then\n        returned[${#returned[@]}]=$j\n\
    \      fi\n    done\n  done\n  # Join the array into a space-delimited string\n\
    \  retval=$(join \" \" \"${returned[@]}\")\n  echo \"$retval\"", "\tlocal sortedStr=\"\
    \"\n\tlocal i\n\t# if $1 is empty, skip the loop\n\tif [ -z \"$1\" ]; then\n\t\
    \treturn\n\tfi\n\t# get a sorted array of the words in $1\n\tsortedArr=($(echo\
    \ $1 | sed -e 's/ /\\n/g' | sort))\n\t# for each word in the sorted array\n\t\
    for i in \"${sortedArr[@]}\"; do\n\t\t# if it's already in the string $sortedStr,\
    \ skip it\n\t\tif [ \"${sortedStr/#$i/}\" = \"$sortedStr\" ]; then\n\t\t\t# if\
    \ not, append it to the string\n\t\t\tsortedStr=\"$sortedStr $i\"\n\t\tfi\n\t\
    done\n\t# return $sortedStr\n\techo \"$sortedStr\"", "  local numbers=($1)\n \
    \ # Rename numbers from 0 to 9.\n  for i in ${!numbers[@]}; do\n    case ${numbers[$i]}\
    \ in\n      zero) numbers[$i]=0 ;;\n      one) numbers[$i]=1 ;;\n      two) numbers[$i]=2\
    \ ;;\n      three) numbers[$i]=3 ;;\n      four) numbers[$i]=4 ;;\n      five)\
    \ numbers[$i]=5 ;;\n      six) numbers[$i]=6 ;;\n      seven) numbers[$i]=7 ;;\n\
    \      eight) numbers[$i]=8 ;;\n      nine) numbers[$i]=9 ;;\n    esac\n  done\n\
    \  # Sort and rename back numbers from 0 to 9.\n  for i in ${!numbers[@]}; do\n\
    \    case ${numbers[$i]} in\n      0) numbers[$i]=zero ;;\n      1) numbers[$i]=one\
    \ ;;\n      2) numbers[$i]=two ;;\n      3) numbers[$i]=three ;;\n      4) numbers[$i]=four\
    \ ;;\n      5) numbers[$i]=five ;;\n      6) numbers[$i]=six ;;\n      7) numbers[$i]=seven\
    \ ;;\n      8) numbers[$i]=eight ;;\n      9) numbers[$i]=nine ;;\n    esac\n\
    \  done\n  echo \"${numbers[@]}\"", "    local arr\n    arr=($(echo $1 | tr '\
    \ ' '\\n' | sort -n))\n    echo ${arr[@]}", "    local -a num_array\n    num_array=($1)\n\
    \    printf \"%s\\n\" \"${num_array[@]}\" | sort -n", "\tlocal -a result\n\tlocal\
    \ -a nums\n\tresult=()\n\tnums=()\n\t\n\tfor word in $1; do\n\t\tif [[ \"$word\"\
    \ = \"zero\" ]]; then\n\t\t\tnums+=(\"0\")\n\t\telif [[ \"$word\" = \"one\" ]];\
    \ then\n\t\t\tnums+=(\"1\")\n\t\telif [[ \"$word\" = \"two\" ]]; then\n\t\t\t\
    nums+=(\"2\")\n\t\telif [[ \"$word\" = \"three\" ]]; then\n\t\t\tnums+=(\"3\"\
    )\n\t\telif [[ \"$word\" = \"four\" ]]; then\n\t\t\tnums+=(\"4\")\n\t\telif [[\
    \ \"$word\" = \"five\" ]]; then\n\t\t\tnums+=(\"5\")\n\t\telif [[ \"$word\" =\
    \ \"six\" ]]; then\n\t\t\tnums+=(\"6\")\n\t\telif [[ \"$word\" = \"seven\" ]];\
    \ then\n\t\t\tnums+=(\"7\")\n\t\telif [[ \"$word\" = \"eight\" ]]; then\n\t\t\t\
    nums+=(\"8\")\n\t\telif [[ \"$word\" = \"nine\" ]]; then\n\t\t\tnums+=(\"9\")\n\
    \t\tfi\n\tdone\n\t\n\tfor num in \"${nums[@]}\"; do\n\t\t\n\t\tif [[ -z \"${result[0]}\"\
    \ ]]; then\n\t\t\tresult+=(\"$num\")\n\t\telse\n\t\t\tlocal -i inserted=0\n\t\t\
    \tfor index in \"${!result[@]}\"; do\n\t\t\t\tif [[ \"$num\" -lt \"${result[$index]}\"\
    \ ]]; then\n\t\t\t\t\tresult=(\"${result[@]:0:$index}\" \"$num\" \"${result[@]:$index}\"\
    )\n\t\t\t\t\tinserted=1\n\t\t\t\t\tbreak\n\t\t\t\tfi\n\t\t\tdone\n\t\t\tif [[\
    \ \"$inserted\" -eq 0 ]]; then\n\t\t\t\tresult+=(\"$num\")\n\t\t\tfi\n\t\tfi\n\
    \tdone\n\t\n\tfor index in \"${!result[@", "  local -A numbers=(\n    [zero]=0\n\
    \    [one]=1\n    [two]=2\n    [three]=3\n    [four]=4\n    [five]=5\n    [six]=6\n\
    \    [seven]=7\n    [eight]=8\n    [nine]=9\n  )\n  local -i number_count=0\n\
    \  for word in $1; do\n    (( number_count += 1 ))\n    local number_index=\"\
    number_$number_count\"\n    local -i number=${numbers[$word]}\n    local -i i=0\n\
    \    for (( i = number_count - 1; i > 0; i -= 1 )); do\n      local previous_number_index=\"\
    number_$i\"\n      local -i previous_number=${!previous_number_index}\n      if\
    \ (( number < previous_number )); then\n        local temp=${!number_index}\n\
    \        eval \"$number_index=$previous_number\"\n        eval \"$previous_number_index=$temp\"\
    \n      fi\n    done\n  done\n  local result=\"\"\n  for (( i = 1; i <= number_count;\
    \ i += 1 )); do\n    local number_index=\"number_$i\"\n    local -i number=${!number_index}\n\
    \    for key in \"${!numbers[@]}\"; do\n      if (( number == numbers[$key] ));\
    \ then\n        result=\"$result $key\"\n      fi\n    done\n  done\n  echo $result",
  "  nums=(${1// / })\n  sed -E \"s/seven|seven/7/g\" | sed -E \"s/eight|eight/8/g\"\
    \ | sed -E \"s/nine|nine/9/g\" | sed -E \"s/zero|zero/0/g\" | sed -E \"s/one|one/1/g\"\
    \ | sed -E \"s/two|two/2/g\" | sed -E \"s/three|three/3/g\" | sed -E \"s/four|four/4/g\"\
    \ | sed -E \"s/five|five/5/g\" | sed -E \"s/six|six/6/g\" | sort -n | sed -E \"\
    s/7/seven/g\" | sed -E \"s/8/eight/g\" | sed -E \"s/9/nine/g\" | sed -E \"s/0/zero/g\"\
    \ | sed -E \"s/1/one/g\" | sed -E \"s/2/two/g\" | sed -E \"s/3/three/g\" | sed\
    \ -E \"s/4/four/g\" | sed -E \"s/5/five/g\" | sed -E \"s/6/six/g\"", "    numbers=$(echo\
    \ \"$1\" | tr ' ' '\\n' | sed 's/\\b/\\n/g')\n    python -c \"print(sorted('$numbers',\
    \ key=lambda x: 'zero one two three four five six seven eight nine'.index(x)))\"",
  '    echo "$1" | tr " " "\n" | sort -n | tr "\n" " "', "  local -a numbers_array=()\n\
    \  local -i n\n\n  # Convert the string to an array\n  IFS=' ' read -r -a numbers_array\
    \ <<< \"$1\"\n\n  # Convert each number word to a digit and then sort the array\n\
    \  for (( n=0; n<${#numbers_array[@]}; n++ )); do\n    case \"${numbers_array[$n]}\"\
    \ in\n      zero) numbers_array[$n]=0 ;;\n      one) numbers_array[$n]=1 ;;\n\
    \      two) numbers_array[$n]=2 ;;\n      three) numbers_array[$n]=3 ;;\n    \
    \  four) numbers_array[$n]=4 ;;\n      five) numbers_array[$n]=5 ;;\n      six)\
    \ numbers_array[$n]=6 ;;\n      seven) numbers_array[$n]=7 ;;\n      eight) numbers_array[$n]=8\
    \ ;;\n      nine) numbers_array[$n]=9 ;;\n    esac\n  done\n\n  # Sort the array\n\
    \  printf \"%s\\n\" \"${numbers_array[@]}\" | sort -n | tr '\\n' ' '\n\n  return\
    \ 0", "\t_local_mapping=( zero one two three four five six seven eight nine )\n\
    \tIFS=' ' read -a local_array <<< \"$1\"\n\t_local_sorted=($(echo ${local_array[@]}\
    \ | tr ' ' '\\n' | sort -n | tr '\\n' ' '))\n\t_local_result=\"\"\n\tfor i in\
    \ \"${_local_sorted[@]}\"; do\n\t\t_local_result=\"$_local_result ${_local_mapping[$i]}\"\
    \n\tdone\n\techo \"$_local_result\"", "  echo $(echo \"$1\" | tr ' ' '\\n' | sort\
    \ -n | tr '\\n' ' ')", '    # IMPLEMENTATION STARTS HERE', "    echo $1 | awk\
    \ '{for(i=1;i<=NF;i++)printf(\"%s\\n\",$i)}' | sort -k1.1n", "    sort_numbers_sorted=()\n\
    \    for numeral in $1; do\n        case $numeral in\n            zero)   sort_numbers_sorted+=0\
    \ ;;\n            one)    sort_numbers_sorted+=1 ;;\n            two)    sort_numbers_sorted+=2\
    \ ;;\n            three)  sort_numbers_sorted+=3 ;;\n            four)   sort_numbers_sorted+=4\
    \ ;;\n            five)   sort_numbers_sorted+=5 ;;\n            six)    sort_numbers_sorted+=6\
    \ ;;\n            seven)  sort_numbers_sorted+=7 ;;\n            eight)  sort_numbers_sorted+=8\
    \ ;;\n            nine)   sort_numbers_sorted+=9 ;;\n        esac\n    done\n\
    \    for numeral in $(echo ${sort_numbers_sorted[@]} | sed -e 's/ /\\n/g' | sort\
    \ -n); do\n        case $numeral in\n            0) sort_numbers_sorted[$numeral]=zero\
    \ ;;\n            1) sort_numbers_sorted[$numeral]=one ;;\n            2) sort_numbers_sorted[$numeral]=two\
    \ ;;\n            3) sort_numbers_sorted[$numeral]=three ;;\n            4) sort_numbers_sorted[$numeral]=four\
    \ ;;\n            5) sort_numbers_sorted[$numeral]=five ;;\n            6) sort_numbers_sorted[$numeral]=six\
    \ ;;\n            7) sort_numbers_sorted[$numeral]=seven ;;\n            8) sort_numbers_sorted[$numeral]=eight\
    \ ;;\n            9) sort_numbers_sorted[$numeral]=nine ;;\n        esac\n   \
    \ done\n    echo ${sort_numbers_sorted[@]}", "  echo \"$1\" | \\\n    sed -E 's/zero/0/g'\
    \ | \\\n    sed -E 's/one/1/g' | \\\n    sed -E 's/two/2/g' | \\\n    sed -E 's/three/3/g'\
    \ | \\\n    sed -E 's/four/4/g' | \\\n    sed -E 's/five/5/g' | \\\n    sed -E\
    \ 's/six/6/g' | \\\n    sed -E 's/seven/7/g' | \\\n    sed -E 's/eight/8/g' |\
    \ \\\n    sed -E 's/nine/9/g' | \\\n    sort -n | \\\n    sed -E 's/0/zero/g'\
    \ | \\\n    sed -E 's/1/one/g' | \\\n    sed -E 's/2/two/g' | \\\n    sed -E 's/3/three/g'\
    \ | \\\n    sed -E 's/4/four/g' | \\\n    sed -E 's/5/five/g' | \\\n    sed -E\
    \ 's/6/six/g' | \\\n    sed -E 's/7/seven/g' | \\\n    sed -E 's/8/eight/g' |\
    \ \\\n    sed -E 's/9/nine/g'", "\t# This is a tricky way to convert a string\
    \ to an array.\n\t# source: https://stackoverflow.com/questions/12785204/how-to-explode-a-string-into-array-of-single-character-strings-in-bash\n\
    \tlocal number_list=($(echo \"$1\" | grep -o .))\n\t#echo \"number_list = ${number_list[@]}\"\
    \n\t\n\t# Create an array of number values in string form\n\tdeclare -a num_values\n\
    \tfor num in \"${number_list[@]}\"; do\n\t\tnum_values+=(\"$(word_to_number $num)\"\
    )\n\tdone\n\t#echo \"num_values = ${num_values[@]}\"\n\t\n\t# Sort numerically\n\
    \tIFS=$'\\n' sorted_num_values=($(sort -n <<<\"${num_values[*]}\"))\n\t#echo \"\
    sorted_num_values = ${sorted_num_values[@]}\"\n\t\n\t# Convert back to words\n\
    \tdeclare -a sorted_words\n\tfor num in \"${sorted_num_values[@]}\"; do\n\t\t\
    sorted_words+=(\"$(number_to_word $num)\")\n\tdone\n\t#echo \"sorted_words = ${sorted_words[@]}\"\
    \n\t\n\t# Join words into string\n\tsorted_string=\"$(IFS=' '; echo \"${sorted_words[*]}\"\
    )\"\n\t#echo \"sorted_string = $sorted_string\"\n\t\n\techo \"$sorted_string\"",
  "    if [[ \"$1\" == *\"$2\"* ]]; then\n      echo \"yes\"\n    else\n      echo\
    \ \"no\"\n    fi", "  local _numbers=(zero one two three four five six seven eight\
    \ nine)\n  local _sorted_numbers=\n  for _num in $(echo $1 | sed -e 's/ /\\n/g'\
    \ | sort)\n  do\n    _sorted_numbers+=\"${_numbers[$_num]} \"\n  done\n  echo\
    \ \"${_sorted_numbers% }\"", "    local nums=(one two three four five six seven\
    \ eight nine zero)\n    local nums_no_sort=$1\n    local nums_sort=\"\"\n    local\
    \ num_array=($nums_no_sort)\n    local i=0\n    local j=0\n    local k=0\n   \
    \ for ((i=0; i<${#num_array[@]}; i++)); do\n        for ((j=0; j<${#nums[@]};\
    \ j++)); do\n            if [[ ${num_array[$i]} == ${nums[$j]} ]]; then\n    \
    \            nums_sort[$k]=$j\n                k=$(($k+1))\n            fi\n \
    \       done\n    done\n    for ((i=0; i<${#nums_sort[@]}; i++)); do\n       \
    \ nums_sort[$i]=${nums[${nums_sort[$i]}]}\n    done\n    echo \"${nums_sort[@]}\"",
  "\techo \"$1\" | tr ' ' '\\n' | sort -g | tr '\\n' ' '", "\t# put your code here",
  "  echo $1 | tr ' ' '\\n' | sort -g | tr '\\n' ' '", '  sort -n', "  if [ -z \"\
    $1\" ]; then return; fi\n\n  local number_map=(zero one two three four five six\
    \ seven eight nine)\n  local numbers=$(\n    for number in $1; do\n      for index\
    \ in ${!number_map[@]}; do\n        if [ \"$number\" == \"${number_map[$index]}\"\
    \ ]; then\n          echo \"$index\"\n        fi\n      done\n    done | sort\
    \ -n\n  )\n\n  for number in $numbers; do\n    echo \"${number_map[$number]}\"\
    \n  done", "    echo $1 | tr ' ' '\\n' | sort | tr '\\n' ' '", "  local nums=${1//\
    \ /,}\n  local -A num=([zero]=0 [one]=1 [two]=2 [three]=3 [four]=4 [five]=5 [six]=6\
    \ [seven]=7 [eight]=8 [nine]=9)\n  local new_nums\n  local new_num\n  IFS=','\
    \ read -r -a new_nums <<< \"$(printf \"%d\\n\" ${nums[@]} | sort -n)\"\n  for\
    \ new_num in \"${new_nums[@]}\"; do\n    for num in \"${!num[@]}\"; do\n     \
    \ if [ \"${num[$num]}\" = \"$new_num\" ]; then\n        printf \"%s\" \"$num \"\
    \n      fi\n    done\n  done\n  printf \"\\n\"", "  echo \"$1\" | tr ' ' '\\n'\
    \ | sort -n | tr '\\n' ' '", "    local numbers=($1)\n    local num_map=(zero\
    \ one two three four five six seven eight nine)\n    local num_str=\"\"\n    local\
    \ str_len=${#num_map[@]}\n    local i\n    local j\n    local temp\n    for ((i=0;\
    \ i<str_len; i++)); do\n        for ((j=i+1; j<str_len; j++)); do\n          \
    \  if [[ ${num_map[$i]} > ${num_map[$j]} ]]; then\n                temp=${num_map[$i]}\n\
    \                num_map[$i]=${num_map[$j]}\n                num_map[$j]=$temp\n\
    \            fi\n        done\n    done\n    for ((i=0; i<str_len; i++)); do\n\
    \        for ((j=0; j<str_len; j++)); do\n            if [[ ${numbers[$i]} ==\
    \ ${num_map[$j]} ]]; then\n                num_str+=\"${numbers[$i]} \"\n    \
    \        fi\n        done\n    done\n    echo $num_str", '    # ...', "    echo\
    \ $1 | tr ' ' '\\n' | sort -n | tr '\\n' ' ' | sed 's/ $//'", "  # #1 start solution\n\
    \  local NUMBERS=(zero one two three four five six seven eight nine)\n  local\
    \ words=($1)\n  local NUM_LIST=()\n  for word in \"${words[@]}\"; do\n    for\
    \ number in \"${NUMBERS[@]}\"; do\n      if [[ \"${word}\" == \"${number}\" ]];\
    \ then\n        NUM_LIST+=(${number})\n      fi\n    done\n  done\n  local sorted=($(echo\
    \ \"${NUM_LIST[@]}\" | tr ' ' '\\n' | sort -g | tr '\\n' ' '))\n  echo \"${sorted[@]}\"\
    \n  # #1 end solution", "    if [ -z \"$1\" ]; then\n        echo \"Error: No\
    \ numbers provided\"\n        return 1\n    fi\n\n    echo $1 | tr \" \" \"\\\
    n\" | sort -n | tr \"\\n\" \" \"", "    local dictionary;\n    dictionary=(0 zero\
    \ 1 one 2 two 3 three 4 four 5 five 6 six 7 seven 8 eight 9 nine)\n    sort_with_dictionary\
    \ \"$1\" \"${dictionary[@]}\"", "\t# https://stackoverflow.com/questions/19049671/how-to-convert-string-to-integer-in-bash\n\
    \t# https://unix.stackexchange.com/questions/112883/how-to-declare-a-bash-array-with-variables-as-elements\n\
    \t# https://stackoverflow.com/questions/1527049/bash-join-elements-of-an-array\n\
    \t# https://stackoverflow.com/questions/8213328/bash-associative-array-print-all-values\n\
    \t# https://unix.stackexchange.com/questions/112883/how-to-declare-a-bash-array-with-variables-as-elements\n\
    \tdeclare -A number=(\n\t\t[\"zero\"]=0\n\t\t[\"one\"]=1\n\t\t[\"two\"]=2\n\t\t\
    [\"three\"]=3\n\t\t[\"four\"]=4\n\t\t[\"five\"]=5\n\t\t[\"six\"]=6\n\t\t[\"seven\"\
    ]=7\n\t\t[\"eight\"]=8\n\t\t[\"nine\"]=9\n\t)\n\tdeclare -a given=($1)\n\t# https://stackoverflow.com/questions/1527049/bash-join-elements-of-an-array\n\
    \techo \"${given[@]}\" | tr ' ' '\\n' | sort -n -t ' ' -k 1 -k 2 -k 3 | tr '\\\
    n' ' '", "    local numbers=($1)\n    local i=0\n\n    for ((i=0; i<${#numbers[@]};\
    \ i++)); do\n        local n=${numbers[$i]}\n        case \"$n\" in\n        \
    \    \"zero\") numbers[$i]=0 ;;\n            \"one\") numbers[$i]=1 ;;\n     \
    \       \"two\") numbers[$i]=2 ;;\n            \"three\") numbers[$i]=3 ;;\n \
    \           \"four\") numbers[$i]=4 ;;\n            \"five\") numbers[$i]=5 ;;\n\
    \            \"six\") numbers[$i]=6 ;;\n            \"seven\") numbers[$i]=7 ;;\n\
    \            \"eight\") numbers[$i]=8 ;;\n            \"nine\") numbers[$i]=9\
    \ ;;\n        esac\n    done\n\n    IFS=$' ' sorted_numbers=($(printf \"%s\\n\"\
    \ \"${numbers[@]}\" | sort -n))\n\n    for ((i=0; i<${#sorted_numbers[@]}; i++));\
    \ do\n        local n=${sorted_numbers[$i]}\n        case \"$n\" in\n        \
    \    0) sorted_numbers[$i]=\"zero\" ;;\n            1) sorted_numbers[$i]=\"one\"\
    \ ;;\n            2) sorted_numbers[$i]=\"two\" ;;\n            3) sorted_numbers[$i]=\"\
    three\" ;;\n            4) sorted_numbers[$i]=\"four\" ;;\n            5) sorted_numbers[$i]=\"\
    five\" ;;\n            6) sorted_numbers[$i]=\"six\" ;;\n            7) sorted_numbers[$i]=\"\
    seven\" ;;\n            8) sorted_numbers[$i]=\"eight\" ;;\n            9) sorted_numbers[$i]=\"\
    nine\" ;;\n        esac\n    done\n\n    echo ${sorted_numbers[@]}", "    local\
    \ -a numbers=($1)\n    echo ${numbers[@]} | tr ' ' '\\n' | sort -n | tr '\\n'\
    \ ' '", "\t# YOUR CODE HERE\n\techo \" ${1// /$'\\n'} \" | sort -g | tr '\\n'\
    \ ' '", "\tif [ $# -eq 0 ]; then\n\t\techo \"Usage: $(basename $0) STRING\"\n\t\
    \treturn 1\n\tfi\n\tnumbers=(zero one two three four five six seven eight nine)\n\
    \ti=0\n\tfor n in \"${numbers[@]}\"; do\n\t\tif echo \"$1\" | grep -q \"$n\";\
    \ then\n\t\t\techo $i\n\t\tfi\n\t\t((i++))\n\tdone | sort -n | xargs -I % echo\
    \ ${numbers[%]}", "    #echo \"$1\" | sed 's/zero/0/g' | sed 's/one/1/g' | sed\
    \ 's/two/2/g' | sed 's/three/3/g' | sed 's/four/4/g' | sed 's/five/5/g' | sed\
    \ 's/six/6/g' | sed 's/seven/7/g' | sed 's/eight/8/g' | sed 's/nine/9/g' | sed\
    \ 's/  / /g' | sed 's/ /\\n/g' | sort -n | sed 's/0/zero/g' | sed 's/1/one/g'\
    \ | sed 's/2/two/g' | sed 's/3/three/g' | sed 's/4/four/g' | sed 's/5/five/g'\
    \ | sed 's/6/six/g' | sed 's/7/seven/g' | sed 's/8/eight/g' | sed 's/9/nine/g'\
    \ | sed 's/\\n/ /g'\n    #echo \"$1\" | sed 's/zero/0/g' | sed 's/one/1/g' | sed\
    \ 's/two/2/g' | sed 's/three/3/g' | sed 's/four/4/g' | sed 's/five/5/g' | sed\
    \ 's/six/6/g' | sed 's/seven/7/g' | sed 's/eight/8/g' | sed 's/nine/9/g' | sed\
    \ 's/  / /g' | sed 's/ /\\n/g' | sort -n | sed 's/0/zero/g' | sed 's/1/one/g'\
    \ | sed 's/2/two/g' | sed 's/3/three/g' | sed 's/4/four/g' | sed 's/5/five/g'\
    \ | sed 's/6/six/g' | sed 's/7/seven/g' | sed 's/8/eight/g' | sed 's/9/nine",
  "\tlocal -i count=0\n\tlocal -i array_index=0\n\tlocal sorted_array\n\tlocal sorted_string\n\
    \tlocal number\n\tlocal -i number_index\n\tlocal -i nums_len=0\n\t# 0 9 8 7 6\
    \ 5 4 3 2 1\n\tlocal -a numbers=(zero one two three four five six seven eight\
    \ nine)\n\tlocal key\n\n\tnums_len=${#numbers[@]}\n\tsorted_array=(\"zero\" \"\
    zero\" \"zero\" \"zero\" \"zero\" \"zero\" \"zero\" \"zero\" \"zero\" \"zero\"\
    )\n\n\t# Extract each of the numbers from the string\n\tfor number in $1; do\n\
    \t\tcount=$count+1\n\t\tif [[ \"$number\" = \"one\" ]]; then\n\t\t\tnumber_index=1\n\
    \t\telif [[ \"$number\" = \"two\" ]]; then\n\t\t\tnumber_index=2\n\t\telif [[\
    \ \"$number\" = \"three\" ]]; then\n\t\t\tnumber_index=3\n\t\telif [[ \"$number\"\
    \ = \"four\" ]]; then\n\t\t\tnumber_index=4\n\t\telif [[ \"$number\" = \"five\"\
    \ ]]; then\n\t\t\tnumber_index=5\n\t\telif [[ \"$number\" = \"six\" ]]; then\n\
    \t\t\tnumber_index=6\n\t\telif [[ \"$number\" = \"seven\" ]]; then\n\t\t\tnumber_index=7\n\
    \t\telif [[ \"$number\" = \"eight\" ]]; then\n\t\t\tnumber_index=8\n\t\telif [[\
    \ \"$number\" = \"nine\" ]]; then\n\t\t\tnumber_index=9\n\t\telse\n\t\t\tnumber_index=0\n\
    \t\tfi\n\t\tsorted_array[$number_index]=$number\n\tdone\n\n\t# Check if there\
    \ are any zeros in the array.\n\t# If there are, loop through and remove them.\n\
    \tkey=0\n\twhile [[ $key -lt $nums_len ]]; do\n\t\tif [[ \"${sorted_array[$key]}\"\
    \ = \"zero\" ]]; then\n\t\t\t# Overwrite that index with the last non-zero", " \
    \ declare -A num_map=(\n    [zero]=0\n    [one]=1\n    [two]=2\n    [three]=3\n\
    \    [four]=4\n    [five]=5\n    [six]=6\n    [seven]=7\n    [eight]=8\n    [nine]=9\n\
    \  )\n  declare -A p_num_map=(\n    [0]=zero\n    [1]=one\n    [2]=two\n    [3]=three\n\
    \    [4]=four\n    [5]=five\n    [6]=six\n    [7]=seven\n    [8]=eight\n    [9]=nine\n\
    \  )\n  declare -a num_array\n  num_array=(${1// / })\n  declare -a sorted_num_array\n\
    \  for num in ${num_array[@]}; do\n    sorted_num_array[${num_map[$num]}]=$num\n\
    \  done\n  echo ${sorted_num_array[@]}", "    echo $1 | awk 'BEGIN {FS=\" \";\
    \ OFS=\" \"} {for (i=1; i<=NF; i++) {a[$i] = $i}} END {j=0; for (i in a) {if (j\
    \ > 0) {printf(\" \");}; printf(\"%s\", a[i]); j=1}}'", "\t# Two arguments required\n\
    \tif [ $# -lt 2 ]; then\n\t\treturn 1\n\tfi\n\n\t# Sort array of numbers\n\tsorted=($(printf\
    \ '%s\\n' \"$@\" | sort))\n\n\t# Format output\n\tprintf '%s' \"${sorted[@]}\"",
  "    local input=$1\n    local numbers=()\n    for num in $input; do\n        case\
    \ $num in\n            zero) numbers+=0;;\n            one) numbers+=1;;\n   \
    \         two) numbers+=2;;\n            three) numbers+=3;;\n            four)\
    \ numbers+=4;;\n            five) numbers+=5;;\n            six) numbers+=6;;\n\
    \            seven) numbers+=7;;\n            eight) numbers+=8;;\n          \
    \  nine) numbers+=9;;\n        esac\n    done\n    echo ${numbers[@]} | tr ' '\
    \ '\\n' | sort -n | tr '\\n' ' '", "\t# your code goes here\n\t# if you want to\
    \ write to stderr, use echo -e \"$@\" >&2\n\techo \"$@\" | tr \" \" \"\\n\" |\
    \ sort -n | tr \"\\n\" \" \" | sed 's/[ ]\\+$//'", '  echo "No idea where to go
    from here"', "\t# Your code here\n\t# sort the string\n\t# return the sorted string\n\
    \tres=\"\";\n\tnum_list=($1);\n\tfor num in ${num_list[@]}; do\n\t\tcase $num\
    \ in\n\t\t\t\"zero\") num_to_sort[0]=0;;\n\t\t\t\"one\") num_to_sort[1]=1;;\n\t\
    \t\t\"two\") num_to_sort[2]=2;;\n\t\t\t\"three\") num_to_sort[3]=3;;\n\t\t\t\"\
    four\") num_to_sort[4]=4;;\n\t\t\t\"five\") num_to_sort[5]=5;;\n\t\t\t\"six\"\
    ) num_to_sort[6]=6;;\n\t\t\t\"seven\") num_to_sort[7]=7;;\n\t\t\t\"eight\") num_to_sort[8]=8;;\n\
    \t\t\t\"nine\") num_to_sort[9]=9;;\n\t\tesac\n\tdone\n\tfor i in $(seq 0 9); do\n\
    \t\tif [ ${num_to_sort[$i]} -eq 0 ]; then\n\t\t\tres=$res\" zero\";\n\t\telif\
    \ [ ${num_to_sort[$i]} -eq 1 ]; then\n\t\t\tres=$res\" one\";\n\t\telif [ ${num_to_sort[$i]}\
    \ -eq 2 ]; then\n\t\t\tres=$res\" two\";\n\t\telif [ ${num_to_sort[$i]} -eq 3\
    \ ]; then\n\t\t\tres=$res\" three\";\n\t\telif [ ${num_to_sort[$i]} -eq 4 ]; then\n\
    \t\t\tres=$res\" four\";\n\t\telif [ ${num_to_sort[$i]} -eq 5 ]; then\n\t\t\t\
    res=$res\" five\";\n\t\telif [ ${num_to_sort[$i]} -eq 6 ]; then\n\t\t\tres=$res\"\
    \ six\";\n\t\telif [ ${num_to_sort[$i]} -eq 7 ]; then\n\t\t\tres=$res\" seven\"\
    ;\n\t\telif [ ${num_to_sort[$i]} -eq 8 ]; then\n", "    echo $1 | tr ' ' '\\n'\
    \ | sort -n | tr '\\n' ' '", "  for n in $(echo $1 | tr ' ' '\\n' | sort -n);\
    \ do echo -n $n\" \"; done", "  local tmp_file=$(mktemp)\n  local -a number_map=(zero\
    \ one two three four five six seven eight nine)\n  local -a result_array\n\n \
    \ for numeral in $1; do\n    for index in ${!number_map[@]}; do\n      if [[ $numeral\
    \ == ${number_map[$index]} ]]; then\n        echo \"$index\" >> $tmp_file\n  \
    \      break\n      fi\n    done\n  done\n\n  local sorted_list=$(cat $tmp_file\
    \ | sort -n)\n  while read index; do\n    result_array+=(${number_map[$index]})\n\
    \  done <<< \"$sorted_list\"\n\n  printf \"%s \" \"${result_array[@]}\"\n  printf\
    \ \"\\n\"", "    local input=\"$1\"\n    local words=(zero one two three four\
    \ five six seven eight nine)\n    local -A numbers\n    local w c\n    local i\
    \ n t\n\n    # Build an array of the number words and their values\n    for ((\
    \ i=0; i<${#words[@]}; i++ )); do\n        numbers[${words[$i]}]=$i\n    done\n\
    \n    # Sort the input words according to the value in the 'numbers' array\n \
    \   t=$(printf \"%s\\n\" $input | while read w; do\n        echo -n \"$(printf\
    \ '%2.2d\\n' ${numbers[$w]})\"\n    done | sort -n)\n\n    # Iterate over the\
    \ sorted numbers and build the output string\n    for (( i=0; i<${#t}; i+=2 ));\
    \ do\n        n=${t:$i:2}\n        for c in \"${!numbers[@]}\"; do\n         \
    \   [[ ${numbers[$c]} == $n ]] && printf \"%s \" $c\n        done\n    done\n\
    \    echo", "  local numbers=$1\n  local -a number_words=()\n  local -a number_values=()\n\
    \  local -a output=()\n  local item\n  local tmp\n  IFS=\" \" read -r -a number_words\
    \ <<< \"$numbers\"\n  for item in \"${number_words[@]}\"; do\n    case \"$item\"\
    \ in\n      zero)\n        number_values+=(\"0\")\n        ;;\n      one)\n  \
    \      number_values+=(\"1\")\n        ;;\n      two)\n        number_values+=(\"\
    2\")\n        ;;\n      three)\n        number_values+=(\"3\")\n        ;;\n \
    \     four)\n        number_values+=(\"4\")\n        ;;\n      five)\n       \
    \ number_values+=(\"5\")\n        ;;\n      six)\n        number_values+=(\"6\"\
    )\n        ;;\n      seven)\n        number_values+=(\"7\")\n        ;;\n    \
    \  eight)\n        number_values+=(\"8\")\n        ;;\n      nine)\n        number_values+=(\"\
    9\")\n        ;;\n      *)\n        number_values+=(\"\")\n        ;;\n    esac\n\
    \  done\n  IFS=$'\\n' sorted=($(sort <<<\"${number_values[*]}\"))\n  for item\
    \ in \"${sorted[@]}\"; do\n    case \"$item\" in\n      \"0\")\n        output+=(\"\
    zero\")\n        ;;\n      \"1\")\n        output+=(\"one\")\n        ;;\n   \
    \   \"2\")\n        output+=(\"two\")\n        ;;\n      \"3\")\n        output+=(\"\
    three\")\n        ;;\n      \"4\")\n        output+=(\"four\")\n        ;;\n \
    \     \"5\")\n        output+=(\"five\")\n        ;;\n      \"6\")\n        output+=(\"\
    six\")\n        ;;\n      \"7\")\n        output+=(\"seven\")\n        ;;\n  \
    \    \"8\")\n        output+=(\"eight\")\n        ;;\n      \"9\")\n        output+=(\"\
    nine\")\n        ;;\n      *)\n        output+=(\"\")\n        ;;\n    esac\n\
    \  done\n  echo \"${output[*]}\"", '  echo "$1" | tr " " "\n" | sort | tr "\n"
    " "', "    declare -a arr=(\"$@\")\n    arr=($(echo \"${arr[@]}\" | xargs -n1\
    \ | sort -n | xargs))\n    echo \"${arr[@]}\"", "    local numbers=$1\n    local\
    \ num_list=()\n    for num in $numbers; do\n        case $num in\n           \
    \ 'zero')\n                num_list+=(0)\n                ;;\n            'one')\n\
    \                num_list+=(1)\n                ;;\n            'two')\n     \
    \           num_list+=(2)\n                ;;\n            'three')\n        \
    \        num_list+=(3)\n                ;;\n            'four')\n            \
    \    num_list+=(4)\n                ;;\n            'five')\n                num_list+=(5)\n\
    \                ;;\n            'six')\n                num_list+=(6)\n     \
    \           ;;\n            'seven')\n                num_list+=(7)\n        \
    \        ;;\n            'eight')\n                num_list+=(8)\n           \
    \     ;;\n            'nine')\n                num_list+=(9)\n               \
    \ ;;\n            *)\n                ;;\n        esac\n    done\n    IFS=$' '\n\
    \    echo \"${num_list[*]}\" | tr ' ' '\\n' | sort -n | tr '\\n' ' '", "  # Your\
    \ solution here\n\n  #sort numbers by array of numbers\n  declare -a arr;\n  arr=($1);\n\
    \  len=${#arr[@]};\n  for ((i=0; i<$len; i++)); do\n  \tfor ((j=i+1; j<$len; j++));\
    \ do\n  \t\tif [ \"${arr[i]}\" -gt \"${arr[j]}\" ]; then\n  \t\t\ttmp=${arr[i]};\n\
    \  \t\t\tarr[i]=${arr[j]};\n  \t\t\tarr[j]=$tmp;\n  \t\tfi\n  \tdone\n  done\n\
    \  echo \"${arr[@]}\";", "    # Handle empty strings\n    if [ -z \"$1\" ]; then\n\
    \        echo ''\n        return\n    fi\n\n    # Set up data structures for the\
    \ problem\n    declare -A nums_to_numvals\n    nums_to_numvals['zero']=0\n   \
    \ nums_to_numvals['one']=1\n    nums_to_numvals['two']=2\n    nums_to_numvals['three']=3\n\
    \    nums_to_numvals['four']=4\n    nums_to_numvals['five']=5\n    nums_to_numvals['six']=6\n\
    \    nums_to_numvals['seven']=7\n    nums_to_numvals['eight']=8\n    nums_to_numvals['nine']=9\n\
    \n    declare -A numvals_to_nums\n    numvals_to_nums[0]='zero'\n    numvals_to_nums[1]='one'\n\
    \    numvals_to_nums[2]='two'\n    numvals_to_nums[3]='three'\n    numvals_to_nums[4]='four'\n\
    \    numvals_to_nums[5]='five'\n    numvals_to_nums[6]='six'\n    numvals_to_nums[7]='seven'\n\
    \    numvals_to_nums[8]='eight'\n    numvals_to_nums[9]='nine'\n\n    # Convert\
    \ the string to an array\n    read -a nums <<< $1\n\n    # Convert nums to numvals\n\
    \    numvals=()\n    for num in \"${nums[@]}\"; do\n        numvals+=(${nums_to_numvals[$num]})\n\
    \    done\n\n    # Sort numvals\n    IFS=$'\\n' numvals=($(sort -n <<<\"${numvals[*]}\"\
    ))\n    unset IFS\n\n    # Convert numvals to nums\n    nums=()\n    for numval\
    \ in \"${numvals[@]}\"; do\n        nums+=(${numvals_to_nums[$numval]})", "  \
    \  echo $1 | sed 's/zero/0/g' | sed 's/one/1/g' | sed 's/two/2/g' | sed 's/three/3/g'\
    \ | sed 's/four/4/g' | sed 's/five/5/g' | sed 's/six/6/g' | sed 's/seven/7/g'\
    \ | sed 's/eight/8/g' | sed 's/nine/9/g' | sort -n | sed 's/0/zero/g' | sed 's/1/one/g'\
    \ | sed 's/2/two/g' | sed 's/3/three/g' | sed 's/4/four/g' | sed 's/5/five/g'\
    \ | sed 's/6/six/g' | sed 's/7/seven/g' | sed 's/8/eight/g' | sed 's/9/nine/g'",
  "  local -A nums\n  nums[\"zero\"]=0\n  nums[\"one\"]=1\n  nums[\"two\"]=2\n  nums[\"\
    three\"]=3\n  nums[\"four\"]=4\n  nums[\"five\"]=5\n  nums[\"six\"]=6\n  nums[\"\
    seven\"]=7\n  nums[\"eight\"]=8\n  nums[\"nine\"]=9\n  local sorted_keys\n  IFS=\"\
    \ \" read -r -a keys <<< \"$1\"\n  sorted_keys=$(for i in \"${keys[@]}\"; do echo\
    \ $i; done | sort -n -k 1)\n  sorted_keys=($sorted_keys)\n  local result=\"\"\n\
    \  for i in \"${sorted_keys[@]}\"; do\n    result+=\" $i\"\n  done\n  echo $result",
  "  declare -A NUMBER_MAP\n  NUMBER_MAP=([zero]=0 [one]=1 [two]=2 [three]=3 [four]=4\
    \ [five]=5 [six]=6 [seven]=7 [eight]=8 [nine]=9)\n  declare -a input\n  input=($1)\n\
    \  declare -a result\n  for i in ${input[@]}; do\n    result[${NUMBER_MAP[$i]}]=$i\n\
    \  done\n  echo ${result[@]}", '    echo $1 | tr " " "\n" | sort -g | tr "\n"
    " "', "  local numbers=\"$1\"\n  local n\n  local clean\n  local -a array\n\n\
    \  for n in $numbers; do\n    case $n in\n      zero)    clean=\"$clean 0\" ;;\n\
    \      one)     clean=\"$clean 1\" ;;\n      two)     clean=\"$clean 2\" ;;\n\
    \      three)   clean=\"$clean 3\" ;;\n      four)    clean=\"$clean 4\" ;;\n\
    \      five)    clean=\"$clean 5\" ;;\n      six)     clean=\"$clean 6\" ;;\n\
    \      seven)   clean=\"$clean 7\" ;;\n      eight)   clean=\"$clean 8\" ;;\n\
    \      nine)    clean=\"$clean 9\" ;;\n      *)       clean=\"$clean ${n//[^0-9]/}\"\
    \ ;;\n    esac\n  done\n\n  clean=$(echo \"$clean\" | tr ' ' '\\n' | sort -n |\
    \ tr '\\n' ' ')\n  while read -r n; do\n    array[$n]=\"$(number_to_word $n)\"\
    \n  done <<< \"$clean\"\n\n  echo \"${array[*]}\"", '  echo $1 | tr " " "\n" |
    sort -n | tr "\n" " "', "  if [ -z \"$1\" ]; then\n    return 0\n  fi\n  local\
    \ str=$1\n  local arr=()\n  local i=0\n  for number in $str; do\n    case $number\
    \ in\n      zero) arr[$i]=0;;\n      one) arr[$i]=1;;\n      two) arr[$i]=2;;\n\
    \      three) arr[$i]=3;;\n      four) arr[$i]=4;;\n      five) arr[$i]=5;;\n\
    \      six) arr[$i]=6;;\n      seven) arr[$i]=7;;\n      eight) arr[$i]=8;;\n\
    \      nine) arr[$i]=9;;\n    esac\n    ((i++))\n  done\n  local newstr=$(echo\
    \ ${arr[@]} | tr ' ' '\\n' | sort -n | tr '\\n' ' ')\n  echo \"$newstr\"", " \
    \ echo \"$1\" | awk 'BEGIN { \n      split(\"zero one two three four five six\
    \ seven eight nine\", a, \" \") \n    } \n    {\n      n = split($0, words, \"\
    \ \")\n      for (i = 1; i <= n; i++) \n        for (j = 1; j <= n - 1; j++)\n\
    \          if (a[words[j]] > a[words[j + 1]]) {\n            temp = words[j]\n\
    \            words[j] = words[j + 1]\n            words[j + 1] = temp\n      \
    \    }\n      for (i = 1; i <= n; i++)\n        printf \"%s%s\", words[i], (i\
    \ < n ? \" \" : \"\")\n      printf \"\\n\"\n    }'", "  local input=\"$1\"\n\
    \  local numbers_in_numerical_order=$(echo $input | sed -e 's/zero/0/g' -e 's/one/1/g'\
    \ -e 's/two/2/g' -e 's/three/3/g' -e 's/four/4/g' -e 's/five/5/g' -e 's/six/6/g'\
    \ -e 's/seven/7/g' -e 's/eight/8/g' -e 's/nine/9/g' | xargs -n1 | sort -n | xargs)\n\
    \  echo $numbers_in_numerical_order | sed -e 's/0/zero/g' -e 's/1/one/g' -e 's/2/two/g'\
    \ -e 's/3/three/g' -e 's/4/four/g' -e 's/5/five/g' -e 's/6/six/g' -e 's/7/seven/g'\
    \ -e 's/8/eight/g' -e 's/9/nine/g'", "  local regexp='\\b(?:(?:one|two|three|four|five|six|seven|eight|nine)\\\
    b)+'\n  if [[ $1 =~ $regexp ]]; then\n    echo $1 | tr ' ' '\\n' | sort | tr '\\\
    n' ' '\n  else\n    echo \"Invalid input. Please use space-delimited words of\
    \ 'zero' to 'nine'.\"\n  fi", "  case $1 in\n  zero)\n  echo \"zero\"\n  ;;\n\
    \  one)\n  echo \"one\"\n  ;;\n  two)\n  echo \"two\"\n  ;;\n  three)\n  echo\
    \ \"three\"\n  ;;\n  four)\n  echo \"four\"\n  ;;\n  five)\n  echo \"five\"\n\
    \  ;;\n  six)\n  echo \"six\"\n  ;;\n  seven)\n  echo \"seven\"\n  ;;\n  eight)\n\
    \  echo \"eight\"\n  ;;\n  nine)\n  echo \"nine\"\n  ;;\n  esac", "  echo \"$@\"\
    \ | awk '{\n    num[\"zero\"]=0;\n    num[\"one\"]=1;\n    num[\"two\"]=2;\n \
    \   num[\"three\"]=3;\n    num[\"four\"]=4;\n    num[\"five\"]=5;\n    num[\"\
    six\"]=6;\n    num[\"seven\"]=7;\n    num[\"eight\"]=8;\n    num[\"nine\"]=9;\n\
    \    for (i=1; i<=NF; i++) {\n      digit[i]=num[$i];\n    }\n    asort(digit);\n\
    \    for (i=1; i<=NF; i++) {\n      if (digit[i]==0) {\n        digit[i]=\"zero\"\
    ;\n      } else if (digit[i]==1) {\n        digit[i]=\"one\";\n      } else if\
    \ (digit[i]==2) {\n        digit[i]=\"two\";\n      } else if (digit[i]==3) {\n\
    \        digit[i]=\"three\";\n      } else if (digit[i]==4) {\n        digit[i]=\"\
    four\";\n      } else if (digit[i]==5) {\n        digit[i]=\"five\";\n      }\
    \ else if (digit[i]==6) {\n        digit[i]=\"six\";\n      } else if (digit[i]==7)\
    \ {\n        digit[i]=\"seven\";\n      } else if (digit[i]==8) {\n        digit[i]=\"\
    eight\";\n      } else if (digit[i]==9) {\n        digit[i]=\"nine\";\n      }\n\
    \    }\n    for (i=1; i<=NF; i++) {\n      printf \"%s \", digit[i];\n    }\n\
    \    printf \"\\n\";\n  }'", "\tif [[ $# -ne 1 ]]; then\n\t\techo \"$0: sort_numbers(string):\
    \ Invalid number of arguments: $#\"\n\t\texit 1\n\tfi\n\tlocal input=\"$1\"\n\t\
    local IFS=' '\n\tlocal numbers=($input)\n\tsort <<< \"${numbers[*]}\"", '    echo
    "Correct sort_numbers not implemented."', "    local input=$1\n    local -a digits\n\
    \    local -a NUMS=('zero' 'one' 'two' 'three' 'four' 'five' 'six' 'seven' 'eight'\
    \ 'nine')\n    for num in $input; do\n        for (( i=0; i<${#NUMS[@]}; i++ ));\
    \ do\n            if [[ $num == ${NUMS[$i]} ]]; then\n                digits+=($i)\n\
    \            fi\n        done\n    done\n    output=$(printf '%s\\n' \"${digits[@]}\"\
    \ | sort -n | sed 's/^/'\"${NUMS[0]} /g; s/[[:space:]]/ /g')\n    echo $output",
  "    # implement this function\n    declare -A dict=([\"zero\"]=0 [\"one\"]=1 [\"\
    two\"]=2 [\"three\"]=3 [\"four\"]=4 [\"five\"]=5 [\"six\"]=6 [\"seven\"]=7 [\"\
    eight\"]=8 [\"nine\"]=9)\n    arr1=($1)\n    arr2=()\n    for ((i=0; i<${#arr1[@]};\
    \ i++)); do\n        arr2[i]=${dict[${arr1[i]}]}\n    done\n    arr3=($(printf\
    \ '%s\\n' \"${arr2[@]}\" | sort -n))\n    for ((i=0; i<${#arr3[@]}; i++)); do\n\
    \        for k in \"${!dict[@]}\"; do\n            if [[ ${dict[$k]} == ${arr3[i]}\
    \ ]]; then\n                arr3[i]=$k\n            fi\n        done\n    done\n\
    \    printf \"%s \" \"${arr3[@]}\"", "  # your code here\n  echo $1 | tr ' ' '\\\
    n' | sort -n | tr '\\n' ' '", "    local numbers=\"zero one two three four five\
    \ six seven eight nine\"\n    echo $1 | tr ' ' '\\n' | sort -n | tr '\\n' ' '\
    \ | xargs -n1 -I '{}' echo -n \"$(echo $numbers | cut -d' ' -f{}) \"", "    case\
    \ $1 in\n        \"zero\") echo \"0\" ;;\n        \"one\") echo \"1\" ;;\n   \
    \     \"two\") echo \"2\" ;;\n        \"three\") echo \"3\" ;;\n        \"four\"\
    ) echo \"4\" ;;\n        \"five\") echo \"5\" ;;\n        \"six\") echo \"6\"\
    \ ;;\n        \"seven\") echo \"7\" ;;\n        \"eight\") echo \"8\" ;;\n   \
    \     \"nine\") echo \"9\" ;;\n    esac", "    result=\"\"\n    for number in\
    \ $1; do\n        case $number in\n            zero)\n                result+=\"\
    \ 0\"\n                ;;\n            one)\n                result+=\" 1\"\n\
    \                ;;\n            two)\n                result+=\" 2\"\n      \
    \          ;;\n            three)\n                result+=\" 3\"\n          \
    \      ;;\n            four)\n                result+=\" 4\"\n               \
    \ ;;\n            five)\n                result+=\" 5\"\n                ;;\n\
    \            six)\n                result+=\" 6\"\n                ;;\n      \
    \      seven)\n                result+=\" 7\"\n                ;;\n          \
    \  eight)\n                result+=\" 8\"\n                ;;\n            nine)\n\
    \                result+=\" 9\"\n                ;;\n            *)\n        \
    \        echo \"Please input valid numberal from 'zero' to 'nine'\"\n        \
    \        exit 1\n                ;;\n        esac\n    done\n    echo \"$result\"\
    \ | sort -n | sed 's/[0-9]/& /g'", "  local sorted_numbers=\"$(echo $1 | tr \"\
    \ \" \"\\n\" | sort -n)\"\n  echo \"$sorted_numbers\"", "\techo $1 | tr ' ' '\\\
    n' | sort | tr '\\n' ' '", "    if [ -z \"$1\" ]; then\n        echo \"\"\n  \
    \      return 0\n    fi\n\n    numbers=\"zero one two three four five six seven\
    \ eight nine\"\n    numbers_array=($numbers)\n    numbers_array_len=${#numbers_array[@]}\n\
    \n    IFS=' ' read -r -a string_array <<< \"$1\"\n    string_array_len=${#string_array[@]}\n\
    \n    for ((i=0; i<string_array_len; i++)); do\n        string_array[$i]=$(find_number\
    \ \"${string_array[$i]}\" \"$numbers_array\" \"$numbers_array_len\")\n    done\n\
    \n    for ((i=0; i<string_array_len; i++)); do\n        for ((j=i+1; j<string_array_len;\
    \ j++)); do\n            if [ ${string_array[$i]} -gt ${string_array[$j]} ]; then\n\
    \                temp=${string_array[$i]}\n                string_array[$i]=${string_array[$j]}\n\
    \                string_array[$j]=$temp\n            fi\n        done\n    done\n\
    \n    for ((i=0; i<string_array_len; i++)); do\n        string_array[$i]=$(find_number\
    \ \"${string_array[$i]}\" \"$numbers\" \"$numbers_array_len\")\n    done\n\n \
    \   printf \"%s \" \"${string_array[@]}\"\n    echo \"\"", "  local numbers=\"\
    zero one two three four five six seven eight nine\"\n  #numbers=($numbers)\n\n\
    \  #declare -A numMap\n  #for i in ${!numbers[@]}; do\n  #  numMap[${numbers[$i]}]=$i\n\
    \  #done\n\n  local sorted=\"\"\n  for num in $1; do\n    local char=$(echo -n\
    \ $num | cut -c 1)\n    if [[ \"$char\" == \"z\" ]]; then\n      sorted=\"$sorted\
    \ 0\"\n    elif [[ \"$char\" == \"o\" ]]; then\n      sorted=\"$sorted 1\"\n \
    \   elif [[ \"$char\" == \"t\" ]]; then\n      sorted=\"$sorted 2\"\n    elif\
    \ [[ \"$char\" == \"f\" ]]; then\n      sorted=\"$sorted 3\"\n    elif [[ \"$char\"\
    \ == \"s\" ]]; then\n      sorted=\"$sorted 4\"\n    elif [[ \"$char\" == \"e\"\
    \ ]]; then\n      sorted=\"$sorted 5\"\n    elif [[ \"$char\" == \"n\" ]]; then\n\
    \      sorted=\"$sorted 6\"\n    elif [[ \"$char\" == \"h\" ]]; then\n      sorted=\"\
    $sorted 7\"\n    elif [[ \"$char\" == \"i\" ]]; then\n      sorted=\"$sorted 8\"\
    \n    elif [[ \"$char\" == \"n\" ]]; then\n      sorted=\"$sorted 9\"\n    fi\n\
    \  done\n\n  # Sort the numbers from smallest to largest\n  # https://www.cyberciti.biz/faq/unix-linux-sort-numerical-values/\n\
    \  local sorted=`echo $sorted | tr ' ' '\\n' | sort -n | tr '\\n' ' '`\n\n  for\
    \ num in $sorted; do\n    local result=$result\" \"${numbers[$num]}\n  done\n\n\
    \  echo $result", "  # Use the function 'map' to map each element in the array\
    \ using the 'str' function\n  map \"$1\" \"$(str \"one\" \"two\" \"three\" \"\
    four\" \"five\" \"six\" \"seven\" \"eight\" \"nine\" \"zero\")\"", "\twords=($1)\n\
    \tfor i in {0..9}; do\n\t\tfor word in \"${words[@]}\"; do\n\t\t\tif [[ ${numbers[$i]}\
    \ == $word ]]; then\n\t\t\t\techo -n \"$word \"\n\t\t\tfi\n\t\tdone\n\tdone\n\t\
    echo", '  echo "$1" | tr " " "\n" | sort -n | tr "\n" " "', "  echo $1 | tr '\
    \ ' '\\n' | sort -n | tr '\\n' ' '", "    local -a nums\n    local -a res\n  \
    \  local num\n    local -i i\n    local -i n\n\n    IFS=\" \" read -a nums <<<\
    \ \"$1\"\n    n=${#nums[@]}\n    for ((i=0; i<n; i++)); do\n        case ${nums[i]}\
    \ in\n            zero)\n                num=0\n                ;;\n         \
    \   one)\n                num=1\n                ;;\n            two)\n      \
    \          num=2\n                ;;\n            three)\n                num=3\n\
    \                ;;\n            four)\n                num=4\n              \
    \  ;;\n            five)\n                num=5\n                ;;\n        \
    \    six)\n                num=6\n                ;;\n            seven)\n   \
    \             num=7\n                ;;\n            eight)\n                num=8\n\
    \                ;;\n            nine)\n                num=9\n              \
    \  ;;\n            *)\n                echo \"error\"\n                exit 1\n\
    \                ;;\n        esac\n        res+=($num)\n    done\n    res=($(printf\
    \ \"%s\\n\" \"${res[@]}\" | sort -n))\n    for ((i=0; i<n; i++)); do\n       \
    \ case ${res[i]} in\n            0)\n                num=\"zero\"\n          \
    \      ;;\n            1)\n                num=\"one\"\n                ;;\n \
    \           2)\n                num=\"two\"\n                ;;\n            3)\n\
    \                num=\"three\"\n                ;;\n            4)\n         \
    \       num=\"four\"\n                ;;\n            5)\n                num=\"\
    five\"\n                ;;\n            6)\n                num=\"six\"\n    \
    \            ;;\n            7)\n                num=\"seven\"\n             \
    \   ;;\n            8)\n                num=\"eight\"\n                ;;\n  \
    \          9)\n                num=\"nine\"\n                ;;\n            *)\n\
    \                echo \"error\"\n                exit 1\n                ;;\n\
    \        esac\n        res[i]=$num\n    done\n    echo \"${res[@]}\"", "  local\
    \ result=\"\"\n  # your code goes here\n  echo \"$result\"", "  local arr=($(echo\
    \ $1 | tr ' ' '\\n'))\n  echo \"${arr[@]}\" | sort", "    DICT=${DICT:-$(dict_load)}\n\
    \    NUMBER=\"zero one two three four five six seven eight nine\"\n    __sort_numbers\
    \ \"$1\" \"$DICT\" \"$NUMBER\"", "\t\t#sorts the input string numerically in decending\
    \ order\t\n\t\techo $1 | tr ' ' '\\n' | sort -n | tr '\\n' ' '", "    local numbers=$1\n\
    \    local sorted=$(echo $numbers | tr \" \" \"\\n\" | sort | tr \"\\n\" \" \"\
    )\n    echo $sorted", "  # IMPLEMENT ME\n  local arg=($1)\n  local arg2=${arg[@]}\n\
    \  local numbers=( \"zero\" \"one\" \"two\" \"three\" \"four\" \"five\" \"six\"\
    \ \"seven\" \"eight\" \"nine\" )\n  local arg_number=( \"${numbers[@]}\" )\n \
    \ local number_index=()\n  local index=0\n  local sorted=()\n  local sorted_i=0\n\
    \  for key in ${arg[@]}; do\n    for index in ${!arg_number[@]}; do\n      if\
    \ [ \"${arg_number[$index]}\" == \"$key\" ]; then\n\t      number_index[$sorted_i]=$index\n\
    \t      let sorted_i++\n      fi\n    done\n  done\n  for i in ${number_index[@]};\
    \ do\n    sorted[$index]=${arg[$i]}\n    let index++\n  done\n  echo ${sorted[@]}",
  "  echo $@ | tr ' ' '\\n' | sort -g | tr '\\n' ' '", '  echo $1 | xargs -n1 | sort
    -n | xargs', "    SORTED_STRING=\"\"\n    for WORD in $(echo $1 | tr \" \" \"\\\
    n\")\n    do\n        NBR=0\n        if [ \"$WORD\" == \"zero\" ]; then\n    \
    \        NBR=0\n        elif [ \"$WORD\" == \"one\" ]; then\n            NBR=1\n\
    \        elif [ \"$WORD\" == \"two\" ]; then\n            NBR=2\n        elif\
    \ [ \"$WORD\" == \"three\" ]; then\n            NBR=3\n        elif [ \"$WORD\"\
    \ == \"four\" ]; then\n            NBR=4\n        elif [ \"$WORD\" == \"five\"\
    \ ]; then\n            NBR=5\n        elif [ \"$WORD\" == \"six\" ]; then\n  \
    \          NBR=6\n        elif [ \"$WORD\" == \"seven\" ]; then\n            NBR=7\n\
    \        elif [ \"$WORD\" == \"eight\" ]; then\n            NBR=8\n        elif\
    \ [ \"$WORD\" == \"nine\" ]; then\n            NBR=9\n        fi\n        SORTED_STRING=\"\
    $SORTED_STRING $NBR\"\n    done\n    SORTED_STRING=$(echo $SORTED_STRING | tr\
    \ \" \" \"\\n\" | sort -n | tr \"\\n\" \" \")\n    echo $SORTED_STRING", "   \
    \ numbers=($1)\n    echo \"${numbers[@]}\" | tr ' ' '\\n' | sort | tr '\\n' '\
    \ '", "    echo $1 | sed 's/\\(.*\\)/ \\1/' | sed 's/zero/0/g' | sed 's/one/1/g'\
    \ | sed 's/two/2/g' | sed 's/three/3/g' | sed 's/four/4/g' | sed 's/five/5/g'\
    \ | sed 's/six/6/g' | sed 's/seven/7/g' | sed 's/eight/8/g' | sed 's/nine/9/g'\
    \ | sed 's/ /\\n/g' | sort -n | sed 's/0/zero/g' | sed 's/1/one/g' | sed 's/2/two/g'\
    \ | sed 's/3/three/g' | sed 's/4/four/g' | sed 's/5/five/g' | sed 's/6/six/g'\
    \ | sed 's/7/seven/g' | sed 's/8/eight/g' | sed 's/9/nine/g' | sed 's/\\(.*\\\
    )/ \\1/' | sed 's/ /\\n/g' | tr '\\n' ' ' | sed 's/\\(.*\\)/\\1/'", "  local numbers=($1)\n\
    \  local sorted\n  local number_words=( zero one two three four five six seven\
    \ eight nine )\n  local number_order=( 0 1 2 3 4 5 6 7 8 9 )\n  local j=1\n\n\
    \  # Sort array\n  while [ $j -lt 10 ]; do\n    local i=0\n    while [ $i -lt\
    \ ${#numbers[@]} ]; do\n      if [ ${numbers[$i]} = ${number_words[$j]} ]; then\n\
    \        sorted+=\"${number_words[$j]} \"\n      fi\n      ((i++))\n    done\n\
    \    ((j++))\n  done\n\n  # Do not print last space\n  echo ${sorted::-1}", '    echo
    "$1" | tr " " "\n" | sort -n | tr "\n" " "', "    echo \"$1\" | tr ' ' '\\n' |\
    \ sort -n | tr '\\n' ' '", "    # your solution here\n    echo $1 | awk 'BEGIN{OFS=\"\
    \ \"} {print $1,$2,$3}' | sort -n", "    local i\n    for i in {0..9}; do\n  \
    \      echo \"$1\" | sed \"s/\\\\b${numberals[$i]}\\\\b/${numbers[$i]}/g\"\n \
    \   done | sort -n | tr '\\n' ' ' | xargs -n 1 -d ' ' -i sed \"s/\\\\b${numbers[$i]}\\\
    \\b/${numberals[$i]}/g\" | tr '\\n' ' ' | xargs", "    # TODO: your implementation\
    \ here\n    # examples:\n    # numbers=( $(echo $1 | awk '{print $1, $2, $3}')\
    \ )\n    # case ${numbers[0]} in\n    #    \"zero\") a=0;;\n    #    \"one\")\
    \ a=1;;\n    #    \"two\") a=2;;\n    #    \"three\") a=3;;\n    #    \"four\"\
    ) a=4;;\n    #    \"five\") a=5;;\n    #    \"six\") a=6;;\n    #    \"seven\"\
    ) a=7;;\n    #    \"eight\") a=8;;\n    #    \"nine\") a=9;;\n    #    *) a=-1;;\n\
    \    # esac\n    # echo \"$a\"\n    numbers=( $(echo $1 | awk '{print $1, $2,\
    \ $3}') )\n    for n in \"${numbers[@]}\"; do\n        case $n in\n          \
    \  \"zero\") a=0;;\n            \"one\") a=1;;\n            \"two\") a=2;;\n \
    \           \"three\") a=3;;\n            \"four\") a=4;;\n            \"five\"\
    ) a=5;;\n            \"six\") a=6;;\n            \"seven\") a=7;;\n          \
    \  \"eight\") a=8;;\n            \"nine\") a=9;;\n            *) a=-1;;\n    \
    \    esac\n        array+=($a)\n    done\n    sorted=($(printf '%s\\n' \"${array[@]}\"\
    \ | sort -n))\n    for i in \"${sorted[@]}\"; do\n        case $i in\n       \
    \     0) a=\"zero\";;\n            1) a=\"one\";;\n            2) a=\"two\";;\n\
    \            3) a=\"three\";;\n            4) a=\"four\";;\n            5) a=\"\
    five\";;\n            6) a=\"six\";;\n            7) a=\"seven\";;\n         \
    \   8) a=\"eight\";;\n            9) a=\"nine\";;\n            *) a=\"-1\";;\n\
    \        esac\n        result+=($a)\n    done\n    echo \"${result[@]}\"", " \
    \   test $# -eq 1 || return 1\n    local -a a=( $1 ) i=0 j=0 s='' n=${#a[@]}\n\
    \    for ((i=0; i<n; i++)); do\n        s=${a[i]}\n        for ((j=i+1; j<n; j++));\
    \ do\n            if [[ ${a[j]} < $s ]]; then\n                a[i]=${a[j]}\n\
    \                a[j]=$s\n                s=${a[i]}\n            fi\n        done\n\
    \    done\n    echo ${a[@]}", "    if [[ ! $1 =~ ^[a-z]+$ ]]; then\n        echo\
    \ 'string should consist of lowercase alphabets'\n        return 1\n    fi\n\n\
    \    echo \"$1\" | awk '{ print length, $0 }' | sort -n -s | cut -d\" \" -f2-",
  "    args=(\"$@\")\n    declare -a sorted\n    for arg in ${args[@]}; do\n     \
    \   sorted+=(\"$(number_to_number_id $arg)\")\n    done\n    echo \"${sorted[@]}\"\
    \ | tr ' ' '\\n' | sort -n | tr '\\n' ' '", "    # Write your code here\n    echo\
    \ $1 | xargs -n1 | sort | xargs", "  if [ $# -ne 1 ]; then\n    echo \"usage:\
    \ sort_numbers arg\"\n    return 1\n  fi\n  echo \"$1\" | tr ' ' '\\n' | sort\
    \ -g | tr '\\n' ' '", "  local string=()\n  for num in $1; do\n    case $num in\n\
    \      'zero') string+=(0) ;;\n      'one') string+=(1) ;;\n      'two') string+=(2)\
    \ ;;\n      'three') string+=(3) ;;\n      'four') string+=(4) ;;\n      'five')\
    \ string+=(5) ;;\n      'six') string+=(6) ;;\n      'seven') string+=(7) ;;\n\
    \      'eight') string+=(8) ;;\n      'nine') string+=(9) ;;\n    esac\n  done\n\
    \  echo \"${string[@]}\" | tr ' ' '\\n' | sort -n | tr '\\n' ' '", "\tresult=\"\
    \"\n\tfor num in $1; do\n\t\tresult+=\"$(num_to_int $num) \"\n\tdone\n\techo \"\
    $result\" | sort -n | awk '{ for (i=1; i<=NF; i++) { printf $i \" \" }; printf\
    \ \"\\n\" }' | while read line; do\n\t\tresult=\"\"\n\t\tfor num in $line; do\n\
    \t\t\tresult+=\"$(int_to_num $num) \"\n\t\tdone\n\t\techo \"$result\"\n\tdone",
  "  python -c \"print ' '.join(['one', 'two', 'three', 'four', 'five', 'six', 'seven',\
    \ 'eight', 'nine', 'zero'][i] for i in sorted(map(int, raw_input().split())))\"",
  "  local IFS=' '\n  declare -a array=($1)\n  local index=0\n  local tmp=0\n  local\
    \ len=${#array[@]}\n  while [ $index -lt $len ]; do\n    while [ $index -lt $len\
    \ ]; do\n      if [ \"${array[$index]}\" \\> \"${array[$((index+1))]}\" ]; then\n\
    \        tmp=${array[$index]}\n        array[$index]=${array[$((index+1))]}\n\
    \        array[$((index+1))]=$tmp\n      fi\n      index=$((index+1))\n    done\n\
    \    index=0\n  done\n  local res=${array[@]}\n  echo $res", "  local -a arr=()\n\
    \  local result=\"\"\n  while read -r line; do\n    arr+=( \"$line\" )\n  done\
    \ <<< \"$(echo \"$1\" | sed 's/[[:space:]]/\\n/g')\"\n  for i in \"${arr[@]}\"\
    ; do\n    case \"$i\" in\n      \"zero\")\n        result=\"$result 0\"\n    \
    \    ;;\n      \"one\")\n        result=\"$result 1\"\n        ;;\n      \"two\"\
    )\n        result=\"$result 2\"\n        ;;\n      \"three\")\n        result=\"\
    $result 3\"\n        ;;\n      \"four\")\n        result=\"$result 4\"\n     \
    \   ;;\n      \"five\")\n        result=\"$result 5\"\n        ;;\n      \"six\"\
    )\n        result=\"$result 6\"\n        ;;\n      \"seven\")\n        result=\"\
    $result 7\"\n        ;;\n      \"eight\")\n        result=\"$result 8\"\n    \
    \    ;;\n      \"nine\")\n        result=\"$result 9\"\n        ;;\n    esac\n\
    \  done\n  result=\"$(echo \"$result\" | sed 's/[[:space:]]/\\n/g' | sort -n |\
    \ sed 's/[[:space:]]/ /g')\"\n  for i in \"${result[@]}\"; do\n    case \"$i\"\
    \ in\n      \"0\")\n        result=\"$result zero\"\n        ;;\n      \"1\")\n\
    \        result=\"$result one\"\n        ;;\n      \"2\")\n        result=\"$result\
    \ two\"\n        ;;\n      \"3\")\n        result=\"$result three\"\n        ;;\n\
    \      \"4\")\n        result=\"$result four\"\n        ;;\n      \"5\")\n   \
    \     result=\"$result five\"\n        ;;\n      \"6\")\n        result=\"$result\
    \ six\"\n        ;;\n      \"7\")\n        result=\"$result seven\"\n        ;;\n\
    \      \"8\")\n        result=\"$result eight\"\n        ;;\n      \"9\")\n  \
    \      result=\"$result nine\"\n        ;;\n    esac\n  done\n  echo \"$result\"",
  "    local -a arr\n    local -a result\n    local i\n    local j\n    declare -A\
    \ ai\n    local min\n\n    arr=( $1 )\n    for ((i=0; i<${#arr[@]}; i++)); do\n\
    \        ai[${arr[$i]}]=$i\n    done\n\n    for ((i=0; i<${#arr[@]}; i++)); do\n\
    \        min=${arr[0]}\n        for ((j=1; j<${#arr[@]}; j++)); do\n         \
    \   if [[ \"${arr[$j]}\" < \"$min\" ]]; then\n                min=${arr[$j]}\n\
    \            fi\n        done\n        result[${ai[$min]}]=$min\n        unset\
    \ arr[$j]\n    done\n\n    echo ${result[@]}", "    # TODO\n    local num_array=$(echo\
    \ $1 | tr ' ' '\\n' | tr 'one' '1' | tr 'two' '2' | tr 'three' '3' | tr 'four'\
    \ '4' | tr 'five' '5' | tr 'six' '6' | tr 'seven' '7' | tr 'eight' '8' | tr 'nine'\
    \ '9' | sort -n | tr '1' 'one' | tr '2' 'two' | tr '3' 'three' | tr '4' 'four'\
    \ | tr '5' 'five' | tr '6' 'six' | tr '7' 'seven' | tr '8' 'eight' | tr '9' 'nine'\
    \ | tr '\\n' ' ')\n    echo $num_array", "    local numbers=$1\n    printf '%s\\\
    n' $numbers | sort -n", "  local -i len=${#1} i=0 j=0 next=0\n  local -a numbers=($1)\n\
    \  for ((i=0; i<len; i++)); do\n    for ((j=i+1; j<len; j++)); do\n      if [[\
    \ ${numbers[$i]} -gt ${numbers[$j]} ]]; then\n        next=${numbers[$i]}\n  \
    \      numbers[$i]=${numbers[$j]}\n        numbers[$j]=$next\n      fi\n    done\n\
    \  done\n  echo \"${numbers[@]}\"", "    ## handle invalid input\n    if ! [[\
    \ $1 =~ ^([A-Za-z]+) ]]; then\n        >&2 echo \"Usage: sort_numbers <space-delimited\
    \ string of numbers>\"\n        return 1\n    fi\n\n    local numbers=($1)\n\n\
    \    local number_digits=(\n        [zero]=0\n        [one]=1\n        [two]=2\n\
    \        [three]=3\n        [four]=4\n        [five]=5\n        [six]=6\n    \
    \    [seven]=7\n        [eight]=8\n        [nine]=9\n    )\n\n    local -A numbers_map\n\
    \    for number in \"${numbers[@]}\"; do\n        numbers_map[$number]=${number_digits[$number]}\n\
    \    done\n\n    IFS=' ' read -r -a sorted_numbers <<< \"$(for key in \"${!numbers_map[@]}\"\
    ; do echo \"$key\"; done | sort -n -k1 | xargs)\"\n\n    echo \"${sorted_numbers[@]}\"",
  "  local words=(\"$@\")\n  local numbers=()\n  local tmp=\"\"\n  for word in \"\
    ${words[@]}\"; do\n    tmp=${word//[!0-9]/}\n    if [ \"$tmp\" != \"\" ]; then\n\
    \      numbers+=($tmp)\n    fi\n  done\n  echo ${numbers[@]} | xargs -n1 | sort\
    \ -n | xargs", "    echo \"$1\" | tr ' ' '\\n' | sort -n | tr '\\n' ' '", "  \
    \  echo $1 | sed 's/zero/0/g' | sed 's/one/1/g' | sed 's/two/2/g' | sed 's/three/3/g'\
    \ | sed 's/four/4/g' | sed 's/five/5/g' | sed 's/six/6/g' | sed 's/seven/7/g'\
    \ | sed 's/eight/8/g' | sed 's/nine/9/g' | tr ' ' '\\n' | sort -n | tr '\\n' '\
    \ ' | sed 's/0/zero/g' | sed 's/1/one/g' | sed 's/2/two/g' | sed 's/3/three/g'\
    \ | sed 's/4/four/g' | sed 's/5/five/g' | sed 's/6/six/g' | sed 's/7/seven/g'\
    \ | sed 's/8/eight/g' | sed 's/9/nine/g'", "    if [[ $# -ne 1 ]]; then\n    \
    \    echo \"Usage: sort_numbers <space-delimited string of numbers>\" >&2\n  \
    \      exit 1\n    fi\n\n    local number_string=\"$1\"\n    local -a numbers=(\
    \ $number_string )\n    local -a sorted_numbers\n    local -a mapping_numbers=('zero'\
    \ 'one' 'two' 'three' 'four' 'five' 'six' 'seven' 'eight' 'nine')\n    local digit=0\n\
    \n    for number in \"${numbers[@]}\"; do\n        for (( i=0; i<${#mapping_numbers[@]};\
    \ i++ )); do\n            if [[ \"${mapping_numbers[$i]}\" == \"$number\" ]];\
    \ then\n                digit=$i\n                break\n            fi\n    \
    \    done\n        sorted_numbers+=( $digit )\n    done\n\n    echo \"${sorted_numbers[@]}\"\
    \ | xargs -n1 | sort -n | xargs -I {} echo -n \"${mapping_numbers[$((${sorted_numbers[$((${sorted_numbers[$((${sorted_numbers[$((${sorted_numbers[$((${sorted_numbers[$((${sorted_numbers[$((${sorted_numbers[$((${sorted_numbers[$((${sorted_numbers[$((${sorted_numbers[$((${sorted_numbers[$((${sorted_numbers[$((${sorted_numbers[$((${sorted_numbers[$((${sorted_numbers[$((${sorted_numbers[$((${sorted_numbers[$((${sorted_numbers[$((${sorted_numbers[$((${sorted_numbers[$((${sorted_numbers[$((${sorted_numbers[$((${sorted_numbers[$((${sorted_numbers[$((${sorted_numbers[$((${sorted_numbers[$(",
  "    local numbers=( ${1// / } )\n\n    local number_to_digit=(\n        ['zero']=0\n\
    \        ['one']=1\n        ['two']=2\n        ['three']=3\n        ['four']=4\n\
    \        ['five']=5\n        ['six']=6\n        ['seven']=7\n        ['eight']=8\n\
    \        ['nine']=9\n    )\n\n    # Convert the numberals to digits\n    for ((i=0;\
    \ i<${#numbers[@]}; i++)); do\n        numbers[i]=${number_to_digit[${numbers[i]}]}\n\
    \    done\n\n    # Sort the array\n    for ((i=0; i<${#numbers[@]}; i++)); do\n\
    \        for ((j=i+1; j<${#numbers[@]}; j++)); do\n            if [[ ${numbers[i]}\
    \ -gt ${numbers[j]} ]]; then\n                local tmp=${numbers[i]}\n      \
    \          numbers[i]=${numbers[j]}\n                numbers[j]=$tmp\n       \
    \     fi\n        done\n    done\n\n    # Convert the numbers back to numberals\n\
    \    local digit_to_number=(\n        [0]='zero'\n        [1]='one'\n        [2]='two'\n\
    \        [3]='three'\n        [4]='four'\n        [5]='five'\n        [6]='six'\n\
    \        [7]='seven'\n        [8]='eight'\n        [9]='nine'\n    )\n\n    for\
    \ ((i=0; i<${#numbers[@]}; i++)); do\n        numbers[i]=${digit_to_number[${numbers[i]}]}\n\
    \    done\n\n    echo ${numbers[@]}", "\tlocal str=\"$1\"\n\tlocal tmp=\"${str//\
    \ /_}\"\n\t\n\techo \"${tmp//zero/0}\" |\n\tsed 's/one/1/g;s/two/2/g;s/three/3/g;s/four/4/g;s/five/5/g;s/six/6/g;s/seven/7/g;s/eight/8/g;s/nine/9/g'\
    \ |\n\tsort -n |\n\ttr '\\n' ' ' |\n\tsed 's/ 0/ zero/g;s/ 1/ one/g;s/ 2/ two/g;s/\
    \ 3/ three/g;s/ 4/ four/g;s/ 5/ five/g;s/ 6/ six/g;s/ 7/ seven/g;s/ 8/ eight/g;s/\
    \ 9/ nine/g' |\n\tsed 's/  */ /g' |\n\tsed 's/_/ /g'", "  local numbers=\"zero\
    \ one two three four five six seven eight nine\"\n  local words=\"$(echo $1 |\
    \ tr \" \" \"\\n\")\"\n  local nums=\"\"\n  local result=\"\"\n  for word in $words;\
    \ do\n    nums=\"$nums $(echo $numbers | awk '{print $1}' | grep -ob $word | awk\
    \ -F \":\" '{print $1}')\"\n  done\n  nums=\"$(echo $nums | tr \" \" \"\\n\" |\
    \ sort -g)\"\n  for num in $nums; do\n    result=\"$result $(echo $numbers | awk\
    \ '{print $1}' | head -n $num | tail -n 1)\"\n  done\n  echo $result", "  local\
    \ numbers=($1)\n  local sorted=()\n  for number in ${numbers[@]}; do\n    case\
    \ $number in\n      'zero') sorted+=(0) ;;\n      'one') sorted+=(1) ;;\n    \
    \  'two') sorted+=(2) ;;\n      'three') sorted+=(3) ;;\n      'four') sorted+=(4)\
    \ ;;\n      'five') sorted+=(5) ;;\n      'six') sorted+=(6) ;;\n      'seven')\
    \ sorted+=(7) ;;\n      'eight') sorted+=(8) ;;\n      'nine') sorted+=(9) ;;\n\
    \    esac\n  done\n  for number in $(echo ${sorted[@]} | tr ' ' '\\n' | sort -n);\
    \ do\n    case $number in\n      0) echo -n 'zero ' ;;\n      1) echo -n 'one\
    \ ' ;;\n      2) echo -n 'two ' ;;\n      3) echo -n 'three ' ;;\n      4) echo\
    \ -n 'four ' ;;\n      5) echo -n 'five ' ;;\n      6) echo -n 'six ' ;;\n   \
    \   7) echo -n 'seven ' ;;\n      8) echo -n 'eight ' ;;\n      9) echo -n 'nine\
    \ ' ;;\n    esac\n  done", "    numbers=($1)\n    numbers=($(for n in ${numbers[@]};\
    \ do echo $n; done | sort))\n    echo ${numbers[@]}", "    a=( $1 )\n    b=();\
    \ i=0\n    while [ $i -lt 10 ]; do\n        for s in \"${a[@]}\"; do\n       \
    \     if [ \"$s\" == \"zero\" ] && [ $i -eq 0 ]; then\n                b+=( $s\
    \ )\n            elif [ \"$s\" == \"one\" ] && [ $i -eq 1 ]; then\n          \
    \      b+=( $s )\n            elif [ \"$s\" == \"two\" ] && [ $i -eq 2 ]; then\n\
    \                b+=( $s )\n            elif [ \"$s\" == \"three\" ] && [ $i -eq\
    \ 3 ]; then\n                b+=( $s )\n            elif [ \"$s\" == \"four\"\
    \ ] && [ $i -eq 4 ]; then\n                b+=( $s )\n            elif [ \"$s\"\
    \ == \"five\" ] && [ $i -eq 5 ]; then\n                b+=( $s )\n           \
    \ elif [ \"$s\" == \"six\" ] && [ $i -eq 6 ]; then\n                b+=( $s )\n\
    \            elif [ \"$s\" == \"seven\" ] && [ $i -eq 7 ]; then\n            \
    \    b+=( $s )\n            elif [ \"$s\" == \"eight\" ] && [ $i -eq 8 ]; then\n\
    \                b+=( $s )\n            elif [ \"$s\" == \"nine\" ] && [ $i -eq\
    \ 9 ]; then\n                b+=( $s )\n            fi\n        done\n       \
    \ (( i++ ))\n    done\n    echo \"${b[@]}\"", "    local VALUES=(\"zero\" \"one\"\
    \ \"two\" \"three\" \"four\" \"five\" \"six\" \"seven\" \"eight\" \"nine\")\n\
    \    local ARRAY_SORTED=()\n    for i in ${VALUES[@]}; do\n        if [[ \"$1\"\
    \ =~ \"$i\" ]]; then\n            ARRAY_SORTED+=( \"$i\" )\n        fi\n    done\n\
    \    echo \"${ARRAY_SORTED[@]}\"", '    # TODO: Implement script', "  echo \"\
    $1\" | awk '{\n    split($0, a, \" \");\n    b[length(a)] = $0;\n    for (i in\
    \ a) {\n      b[NR] = $i;\n    }\n    asort(b);\n    for (i in b) {\n      printf\
    \ \"%s \", b[i];\n    }\n    printf \"\\n\";\n  }'", "  if [[ -z \"$1\" ]]; then\n\
    \    return\n  fi\n\n  local -a arry=( $(echo \"$1\" | tr ' ' '\\n' | sort -n)\
    \ )\n  echo \"${arry[@]}\"", '    echo "$1" | tr " " "\n" | sort -n | tr "\n"
    " "', '  # Your code here', "    # your code goes here\n    numbers_list=$(echo\
    \ $1 | tr ' ' '\\n')\n    digits_list=(\"zero\" \"one\" \"two\" \"three\" \"four\"\
    \ \"five\" \"six\" \"seven\" \"eight\" \"nine\")\n    number_index=(zero one two\
    \ three four five six seven eight nine)\n    for num in ${numbers_list[@]}; do\n\
    \        number_index[${digits_list[@]/$num}]=${number_index[@]/$num}\n    done\n\
    \    output=\"\"\n    for num in ${number_index[@]}; do\n        [ \"$num\" !=\
    \ \"\" ] && output=\"$output $num\"\n    done\n    echo $output", "  if [ $# -eq\
    \ 0 ]; then\n    return 1\n  fi\n  echo \"$1\" | tr ' ' '\\n' | sort -n | tr '\\\
    n' ' '", "    local nums=($1) # Array of numbers\n    local -A numeral_to_number\
    \ # Declare associative array\n\n    # Fill associative array\n    numeral_to_number=(\n\
    \        [zero]=0\n        [one]=1\n        [two]=2\n        [three]=3\n     \
    \   [four]=4\n        [five]=5\n        [six]=6\n        [seven]=7\n        [eight]=8\n\
    \        [nine]=9\n    )\n\n    # Initialize an array of the same size as nums\
    \ to store the numbers\n    local numbers=()\n    for ((i=0; i<${#nums[@]}; i++));\
    \ do\n        numbers[i]=${numeral_to_number[${nums[i]}]}\n    done\n\n    # Sort\
    \ the numbers\n    for ((i=0; i<${#numbers[@]}; i++)); do\n        for ((j=i+1;\
    \ j<${#numbers[@]}; j++)); do\n            if [[ ${numbers[i]} -gt ${numbers[j]}\
    \ ]]; then\n                local swap=$(( numbers[i] ))\n                numbers[i]=${numbers[j]}\n\
    \                numbers[j]=$swap\n            fi\n        done\n    done\n\n\
    \    # Swap the numbers back to numerals and store in an array\n    local -A number_to_numeral\n\
    \    for ((i=0; i<${#numbers[@]}; i++)); do\n        for numeral in \"${!numeral_to_number[@]}\"\
    ; do\n            if [[ ${numeral_to_number[$numeral]} -eq ${numbers[i]} ]]; then\n\
    \                number_to_numeral[$i]=$numeral\n            fi\n        done\n\
    \    done\n\n    # Get the sorted string\n    local sorted=()\n    for numeral\
    \ in \"${number_to_numeral[@]}\"; do\n        sorted+=(\"$numeral\")\n    done\n\
    \n    echo ${sorted[@]}", "    case $1 in\n    \"zero\"*) echo \"zero\";;\n  \
    \  \"one\"*) echo \"one\";;\n    \"two\"*) echo \"two\";;\n    \"three\"*) echo\
    \ \"three\";;\n    \"four\"*) echo \"four\";;\n    \"five\"*) echo \"five\";;\n\
    \    \"six\"*) echo \"six\";;\n    \"seven\"*) echo \"seven\";;\n    \"eight\"\
    *) echo \"eight\";;\n    \"nine\"*) echo \"nine\";;\n    esac", "\t# convert the\
    \ number words to numbers and sort the numbers\n\tstr=\"$1\"\n\t\n\tstr=${str//zero/0}\n\
    \tstr=${str//one/1}\n\tstr=${str//two/2}\n\tstr=${str//three/3}\n\tstr=${str//four/4}\n\
    \tstr=${str//five/5}\n\tstr=${str//six/6}\n\tstr=${str//seven/7}\n\tstr=${str//eight/8}\n\
    \tstr=${str//nine/9}\n\t\n\tarr=($str)\n\tarr=($(echo \"${arr[@]}\" | tr ' ' '\\\
    n' | sort -g | tr '\\n' ' '))\n\t\n\tstr=${arr[@]}\n\t\n\tstr=${str//0/zero}\n\
    \tstr=${str//1/one}\n\tstr=${str//2/two}\n\tstr=${str//3/three}\n\tstr=${str//4/four}\n\
    \tstr=${str//5/five}\n\tstr=${str//6/six}\n\tstr=${str//7/seven}\n\tstr=${str//8/eight}\n\
    \tstr=${str//9/nine}\n\t\n\techo \"$str\"", "  if [ -z \"$1\" ]; then\n    echo\
    \ \"No input\"\n    return 0\n  fi\n  local s=$(echo \"$1\" | tr ' ' '\\n' | sort\
    \ -k1.1,1.3 -u)\n  echo \"$s\""]
stop_tokens:
- "\n}"
