name: HumanEval_78_hex_key
language: sh
prompt: "#!/bin/bash\n# You have been tasked to write a function that receives \n\
  # a hexadecimal number as a string and counts the number of hexadecimal \n# digits\
  \ that are primes (prime number, or a prime, is a natural number \n# greater than\
  \ 1 that is not a product of two smaller natural numbers).\n# Hexadecimal digits\
  \ are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n# Prime numbers are 2, 3,\
  \ 5, 7, 11, 13, 17,...\n# So you have to determine a number of the following digits:\
  \ 2, 3, 5, 7, \n# B (=decimal 11), D (=decimal 13).\n# Note: you may assume the\
  \ input is always correct or empty string, \n# and symbols A,B,C,D,E,F are always\
  \ uppercase.\n# Examples:\n# >>> $(hex_key \"AB\")\n# \"1\"\n# >>> $(hex_key \"\
  1077E\")\n# \"2\"\n# >>> $(hex_key \"ABED1A33\")\n# \"4\"\n# >>> $(hex_key \"123456789ABCDEF0\"\
  )\n# \"6\"\n# >>> $(hex_key \"2020\")\n# \"2\"\n#\n# $1 is a string\nhex_key() {\n"
tests: "}\n\ncandidate() {\n    hex_key \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
  \ $(candidate \"AB\") = \"1\" ]]\n    [[ $(candidate \"1077E\") = \"2\" ]]\n   \
  \ [[ $(candidate \"ABED1A33\") = \"4\" ]]\n    [[ $(candidate \"2020\") = \"2\"\
  \ ]]\n    [[ $(candidate \"123456789ABCDEF0\") = \"6\" ]]\n    [[ $(candidate \"\
  112233445566778899AABBCCDDEEFF00\") = \"12\" ]]\n}\n\nrun_test"
completions: ["\tlocal str=\"$1\"\n\tstr=\"${str//2/}\"\n\tstr=\"${str//3/}\"\n\t\
    str=\"${str//5/}\"\n\tstr=\"${str//7/}\"\n\tstr=\"${str//B/}\"\n\tstr=\"${str//D/}\"\
    \n\techo \"${#str}\"", "    echo $(($(echo -n \"$1\" | sed 's/[^ABD]//g' | wc\
    \ -m)))", "  declare -i n prime=0 n_prime=0\n\n  [[ -z $1 ]] && { echo 0; return;\
    \ }\n\n  for((n=0; n<${#1}; n++)); do\n    case ${1:n:1} in\n      ([2-7B-DF])\n\
    \        for((prime=2; prime<=${1:n:1}; prime++)); do\n          (( ${1:n:1} %\
    \ prime == 0 )) && break\n        done\n        (( prime == ${1:n:1} )) && ((n_prime++))\n\
    \        ;;\n    esac\n  done\n  echo $n_prime", "  local result=0\n  local -a\
    \ hexa_prime=(2 3 5 7 B D)\n  # if the argument is empty return 0\n  if [ -z \"\
    $1\" ]; then\n    echo \"$result\"\n    return\n  fi\n  for d in $(echo \"$1\"\
    \ | grep -o .); do\n    if [[ \" ${hexa_prime[@]} \" =~ \" ${d} \" ]]; then\n\
    \      ((result++))\n    fi\n  done\n  echo \"$result\"", "  local result=\"\"\
    \n  local digits=\"0 1 2 3 4 5 6 7 8 9 A B C D E F\"\n  local primes=\"2 3 5 7\
    \ B D\"\n  for i in $digits; do\n    if [[ $1 == *$i* ]]; then\n      if [[ $primes\
    \ == *$i* ]]; then\n        result=\"$result $i\"\n      fi\n    fi\n  done\n\
    \  echo \"$result\"", '    echo ${1^^} | tr -cd "[2-7B-DF]" | wc -c', "\techo\
    \ ${1//[^2357BDF]/} | wc -c", "\tgrep -o [2357BD] <<< \"$1\" | wc -l", " \n  \
    \  if [ \"$#\" -ne 1 ]; then\n    echo \"Usage: $0 <string>\"\n    exit 1\n  \
    \  fi\n    arg=$1\n \n    # convert string to array\n    arg=($(echo $arg | grep\
    \ -o .))\n \n    # loop through array\n    count=0\n    for i in \"${arg[@]}\"\
    \n    do\n        if [[ $i == \"2\" || $i == \"3\" || $i == \"5\" || $i == \"\
    7\" || $i == \"B\" || $i == \"D\" ]]; then\n            let count+=1\n       \
    \ fi\n    done\n \n    echo $count", "    declare -i COUNTER=0\n    for i in ${1//\"\
    0\"/\" 1 \"}\n    do\n        if [[ \"$i\" =~ [1357BD] ]]\n        then\n    \
    \        let COUNTER++\n        fi\n    done\n    echo \"$COUNTER\"", "\t# Create\
    \ a string of all the valid hex characters\n\tdeclare -r CHARS=\"23456789ABD\"\
    \n\t# Count the number of valid hex characters in the input string\n\techo \"\
    $1\" | grep -o -E \"[$CHARS]\" | wc -l", "    local hex_number=\"$1\"\n    # the\
    \ variable \"is_prime\" is set by \"check_prime\" function\n    # it is 0 if the\
    \ number is a prime, otherwise non-zero\n    local is_prime=0\n    local i=0\n\
    \    local counter=0\n    local ch\n    for ((i=0; i<${#hex_number}; i++)); do\n\
    \        ch=${hex_number:$i:1}\n        check_prime $(( 16#$ch ))\n        if\
    \ [[ $is_prime -eq 0 ]]; then\n            (( counter++ ))\n        fi\n    done\n\
    \    echo $counter", "  # Here we check if the input string is empty\n  # Otherwise\
    \ we use 'tr' command to translate the input string \n  # from hexadecimal format\
    \ to decimal, \n  # then we use 'grep' command to check if the decimal value \n\
    \  # is prime, and if so, we pipe it to the 'wc' command \n  # to count the number\
    \ of prime digits.\n  # We use '-' symbol in the beginning to indicate that \n\
    \  # we don't need the header with number of lines, words, characters.\n  if [\
    \ -z \"$1\" ]; then\n    echo \"\"\n  else\n    echo \"$1\" | tr '[A-F]' '[10-15]'\
    \ | grep -Ev '[02468]' | wc -l\n  fi", "    res=0\n    for (( i=0; i<${#1}; i++\
    \ )); do\n        case ${1:$i:1} in\n            2|3|5|7|B|D) res=$(( res + 1\
    \ ));;\n        esac\n    done\n    echo $res", "\tlocal temp=\" \"\n\tlocal cnt=0\n\
    \tlocal i=0\n\tlocal digits=\"0 1 2 3 4 5 6 7 8 9 A B C D E F\"\n\tlocal res=\"\
    \"\n\t\n\t[[ $1 == \"\" ]] && return 0\n\t\n\tfor ((i=0; i<${#1}; i++)); do\n\t\
    \t[[ $temp == *\"${1:$i:1}\"* ]] && (( cnt++ ))\n\tdone\n\t\n\techo $cnt", " \
    \   # TODO: write the function and replace the \"HERE\"\n    echo \"HERE\"", " \
    \ # define string\n  local STRING=$1\n  # initialize counter\n  local COUNTER=0\n\
    \  # iterate string and add to counter\n  for (( i=0; i<${#STRING}; i++ )); do\n\
    \    if [[ ${STRING:$i:1} == \"2\" ]] || [[ ${STRING:$i:1} == \"3\" ]] || [[ ${STRING:$i:1}\
    \ == \"5\" ]] || [[ ${STRING:$i:1} == \"7\" ]] || [[ ${STRING:$i:1} == \"B\" ]]\
    \ || [[ ${STRING:$i:1} == \"D\" ]]; then\n      COUNTER=$((COUNTER+1))\n    fi\n\
    \  done\n  # return counter\n  echo \"$COUNTER\"", "\tdeclare -i prime\n\tprime=0\n\
    \tfor ((i=0; i<${#1}; i++)); do\n\t\tcase ${1:$i:1} in\n\t\t\t[2357BD]) prime=$((prime+1));;\n\
    \t\tesac\n\tdone\n\techo \"$prime\"", "\tif [ -z \"$1\" ]; then\n\t\techo \"0\"\
    \n\t\treturn\n\tfi\n\techo \"$1\" | tr -dc '2-79B-DF' | wc -c", "    if [ \"$1\"\
    \ = \"\" ]; then\n        echo \"0\"\n    else\n        echo \"$1\" | tr -cd '[2-7ABD]'\
    \ | wc -c\n    fi"]
stop_tokens:
- "\n}"
