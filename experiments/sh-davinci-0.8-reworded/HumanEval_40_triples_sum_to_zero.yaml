name: HumanEval_40_triples_sum_to_zero
language: sh
prompt: "#!/bin/bash\n# triples_sum_to_zero takes a list of integers as an input.\n\
  # it returns true if there are three distinct elements in the list that\n# sum to\
  \ zero, and false otherwise.\n# >>> $(triples_sum_to_zero \"1 3 5 0\")\n# \"false\"\
  \n# >>> $(triples_sum_to_zero \"1 3 -2 1\")\n# \"true\"\n# >>> $(triples_sum_to_zero\
  \ \"1 2 3 7\")\n# \"false\"\n# >>> $(triples_sum_to_zero \"2 4 -5 3 9 7\")\n# \"\
  true\"\n# >>> $(triples_sum_to_zero \"1\")\n# \"false\"\n#\n# $1 is a space-separated\
  \ list\ntriples_sum_to_zero() {\n"
tests: "}\n\ncandidate() {\n    triples_sum_to_zero \"$@\"\n}\n\nset -e\nrun_test()\
  \ {\n    [[ $(candidate \"1 3 5 0\") = \"false\" ]]\n    [[ $(candidate \"1 3 5\
  \ -1\") = \"false\" ]]\n    [[ $(candidate \"1 3 -2 1\") = \"true\" ]]\n    [[ $(candidate\
  \ \"1 2 3 7\") = \"false\" ]]\n    [[ $(candidate \"1 2 5 7\") = \"false\" ]]\n\
  \    [[ $(candidate \"2 4 -5 3 9 7\") = \"true\" ]]\n    [[ $(candidate \"1\") =\
  \ \"false\" ]]\n    [[ $(candidate \"1 3 5 -100\") = \"false\" ]]\n    [[ $(candidate\
  \ \"100 3 5 -100\") = \"false\" ]]\n}\n\nrun_test"
completions: ["  # TODO: write the body of your function here\n  return", "  local\
    \ i j k\n  local list=($1)\n  local len=${#list[@]}\n  for ((i=0; i<len; i++));\
    \ do\n    for ((j=i+1; j<len; j++)); do\n      for ((k=j+1; k<len; k++)); do\n\
    \        if (((list[i] + list[j] + list[k]) == 0)); then\n          echo \"true\"\
    \n          return\n        fi\n      done\n    done\n  done\n  echo \"false\"",
  "  # remove spaces\n  input=$(echo $1 | tr -d ' ')\n  # brute force.\n  # iterate\
    \ over the first and second elements.\n  # is there a third element that gives\
    \ us zero?\n  for (( i=0; i<${#input}; i++ )); do\n    a=${input:$i:1}\n    for\
    \ (( j=i+1; j<${#input}; j++ )); do\n      b=${input:$j:1}\n      for (( k=j+1;\
    \ k<${#input}; k++ )); do\n        c=${input:$k:1}\n        if [ $(($a + $b +\
    \ $c)) -eq 0 ]; then\n          echo \"true\"\n          return\n        fi\n\
    \      done\n    done\n  done\n  echo \"false\"", "  local input=($1)\n  local\
    \ sum=0\n  local len=${#input[@]}\n  # base case 1\n  if [ $len -lt 3 ]; then\n\
    \    echo \"false\"\n    return 0\n  fi\n  # base case 2\n  if [ $len -eq 3 ];\
    \ then\n    sum=$((${input[0]} + ${input[1]} + ${input[2]}))\n    if [ $sum -eq\
    \ 0 ]; then\n      echo \"true\"\n    else\n      echo \"false\"\n    fi\n   \
    \ return 0\n  fi\n  for (( i=0; i<${#input[@]}; i++ )); do\n    for (( j=0; j<${#input[@]};\
    \ j++ )); do\n      for (( k=0; k<${#input[@]}; k++ )); do\n        if [[ $i -ne\
    \ $j && $i -ne $k && $j -ne $k ]]; then\n          sum=$((${input[$i]} + ${input[$j]}\
    \ + ${input[$k]}))\n          if [ $sum -eq 0 ]; then\n            echo \"true\"\
    \n            return 0\n          fi\n        fi\n      done\n    done\n  done\n\
    \  echo \"false\"", "  for i in $1; do\n    for j in $1; do\n      for k in $1;\
    \ do\n        [[ $i == $j ]] && continue\n        [[ $i == $k ]] && continue\n\
    \        [[ $j == $k ]] && continue\n        [[ $(($i + $j + $k)) == 0 ]] && echo\
    \ \"true\" && return\n      done\n    done\n  done\n  echo \"false\"", "    for\
    \ i in $1; do\n        for j in $1; do\n            for k in $1; do\n        \
    \        if [ $i -ne $j ] && [ $j -ne $k ] && [ $i -ne $k ] && [ $((i+j+k)) -eq\
    \ 0 ]; then\n                    echo \"true\"\n                    return\n \
    \               fi\n            done\n        done\n    done\n    echo \"false\"",
  "  # $triples is an array of arrays of triples that sum to zero\n  # $triples will\
    \ never have duplicate entries\n  # $triples will be empty if there are no triples\n\
    \  triples=()\n  for ((i=0; i<${#1}; i++)); do\n    # $a is the next integer in\
    \ the list\n    a=${1:i:1}\n    # $b is the sum of all integers after $a\n   \
    \ b=$(\n      # start with an empty string\n      expr \"\"\n      # enumerate\
    \ all integers after $a\n      for ((j=i+1; j<${#1}; j++)); do\n        # append\
    \ each integer to the string\n        expr \"$b\" + ${1:j:1}\n      done\n   \
    \ )\n    # $c is the difference between $a and $b\n    c=$(expr $a - $b)\n   \
    \ # if the difference is in the list, the triple\n    #   (a, [b], c) sums to\
    \ zero\n    if [[ \"$1\" =~ $c ]]; then\n      # only add the triple to $triples\
    \ if it does not exist\n      # this ensures that triples will never have duplicate\
    \ entries\n      for t in \"${triples[@]}\"; do\n        if [[ \"$t\" =~ ${a}${b}${c}\
    \ ]]; then\n          # triple already exists\n          break\n        fi\n \
    \     done\n      # add the triple to $triples\n      triples+=(\"${a}${b}${c}\"\
    )\n    fi\n  done\n  # if $triples is empty, there are no triples that sum to\
    \ zero\n  if [[ \"${#triples[@]}\" -eq 0 ]]; then\n    echo \"false\"\n  else\n\
    \    echo \"true\"\n  fi", "  # TODO: write this\n  if [[ $# < 3 ]]; then\n  \
    \  echo \"false\"\n    return 0\n  fi\n\n  local flag=0\n  local sum=0\n  local\
    \ arg1=$1\n  local arg2=$2\n  local arg3=$3\n\n  if [[ \"$arg1\" == \"0\" ]];\
    \ then\n    sum=$(($arg2 + $arg3))\n    if [[ $sum == 0 ]]; then\n      echo \"\
    true\"\n      return 0\n    fi\n  fi\n\n  if [[ \"$arg2\" == \"0\" ]]; then\n\
    \    sum=$(($arg1 + $arg3))\n    if [[ $sum == 0 ]]; then\n      echo \"true\"\
    \n      return 0\n    fi\n  fi\n\n  if [[ \"$arg3\" == \"0\" ]]; then\n    sum=$(($arg1\
    \ + $arg2))\n    if [[ $sum == 0 ]]; then\n      echo \"true\"\n      return 0\n\
    \    fi\n  fi\n\n  shift\n  shift\n  shift\n\n  for item in $@; do\n    sum=$(($arg1\
    \ + $arg2 + $item))\n    if [[ $sum == 0 ]]; then\n      echo \"true\"\n     \
    \ return 0\n    fi\n  done\n\n  sum=$(($arg1 + $arg2 + $arg3))\n  if [[ $sum ==\
    \ 0 ]]; then\n    echo \"true\"\n    return 0\n  fi\n\n  echo \"false\"\n  return\
    \ 0", "    local nums=($1)\n    local p1=0\n    local p2=0\n    local p3=0\n \
    \   local len=${#nums[@]}\n    local n1=0\n    local n2=0\n    local n3=0\n  \
    \  local i=0\n    local j=0\n    local k=0\n    for ((i=0; i<(len-2); i++)); do\n\
    \        p1=${nums[i]}\n        for ((j=i+1; j<(len-1); j++)); do\n          \
    \  p2=${nums[j]}\n            for ((k=j+1; k<len; k++)); do\n                p3=${nums[k]}\n\
    \                n1=$(($p1 + $p2 + $p3))\n                if [[ $n1 -eq 0 ]];\
    \ then\n                    echo \"true\"\n                    return\n      \
    \          fi\n            done\n        done\n    done\n    echo \"false\"",
  "  # if there are less than 3 numbers, it's not possible to find 3 numbers\n  #\
    \ that sum to zero\n  if [ $(wc -w <<< \"$1\") -lt 3 ]; then\n    echo \"false\"\
    \n    return\n  fi\n\n  # a b c are the variables for the 2nd, 3rd, and 4th words\n\
    \  for a in $(echo \"$1\" | cut -d' ' -f2-); do\n    for b in $(echo \"$1\" |\
    \ cut -d' ' -f3-); do\n      for c in $(echo \"$1\" | cut -d' ' -f4-); do\n  \
    \      if [[ $(echo \"$1\" | head -1) -eq \"$((a+b+c))\" ]]; then\n          echo\
    \ \"true\"\n          return\n        fi\n      done\n    done\n  done\n\n  echo\
    \ \"false\"", "  if [ $# -lt 3 ]; then\n    echo \"false\"\n    return\n  fi\n\
    \  # make an array from arguments\n  arr=($@)\n  len=${#arr[@]}\n  # iterate over\
    \ pairs\n  for (( i=0; i<$len-2; i++ )); do\n    for (( j=i+1; j<$len-1; j++ ));\
    \ do\n      for (( k=j+1; k<$len; k++ )); do\n        if [ $((${arr[$i]} + ${arr[$j]}\
    \ + ${arr[$k]})) -eq 0 ]; then\n          echo \"true\"\n          return\n  \
    \      fi\n      done\n    done\n  done\n  echo \"false\"", "    # TODO: implement\
    \ this function and remove the following line\n    echo \"true\"", "    local\
    \ list=\"$1\"\n    local count\n    local i\n    local j\n    local k\n    # Build\
    \ an array of list element.\n    local -a array\n    local ii=0\n    for i in\
    \ $list; do\n        array[$ii]=$i\n        ii=$(( $ii + 1 ))\n    done\n    local\
    \ len=$ii\n    # We do an exhaustive search for a triple.\n    for (( i=0; i<$len;\
    \ i++ )); do\n        for (( j=i+1; j<$len; j++ )); do\n            for (( k=j+1;\
    \ k<$len; k++ )); do\n                if [[ $(( ${array[$i]} + ${array[$j]} +\
    \ ${array[$k]} )) -eq 0 ]]; then\n                    echo \"true\"\n        \
    \            return\n                fi\n            done\n        done\n    done\n\
    \    echo \"false\"", "\t\t## Complete the function below.\n\t\t## Start writing\
    \ your code here.\n\t\ti=0\n\t\tsum=0\n\t\twhile [ $i -lt $(($#-2)) ]\n\t\tdo\n\
    \t\t\tj=$(($i+1))\n\t\t\twhile [ $j -lt $(($#-1)) ]\n\t\t\tdo\n\t\t\t\tk=$(($j+1))\n\
    \t\t\t\twhile [ $k -lt $# ]\n\t\t\t\tdo\n\t\t\t\t\tsum=$((${!i}+${!j}+${!k}))\n\
    \t\t\t\t\tif [ $sum -eq 0 ]\n\t\t\t\t\tthen\n\t\t\t\t\t\techo \"true\"\n\t\t\t\
    \t\t\texit\n\t\t\t\t\tfi\n\t\t\t\t\tk=$(($k+1))\n\t\t\t\tdone\n\t\t\t\tj=$(($j+1))\n\
    \t\t\tdone\n\t\t\ti=$(($i+1))\n\t\tdone\n\t\techo \"false\"", "  LEN=$(echo $1\
    \ | wc -w)\n  for i in $(seq 1 $LEN); do\n    for j in $(seq 1 $LEN); do\n   \
    \   for k in $(seq 1 $LEN); do\n        if [ $i -ne $j ] && [ $i -ne $k ] && [\
    \ $j -ne $k ]; then\n          A=$(echo $1 | cut -d ' ' -f $i)\n          B=$(echo\
    \ $1 | cut -d ' ' -f $j)\n          C=$(echo $1 | cut -d ' ' -f $k)\n        \
    \  if [ $(expr $A + $B + $C) -eq 0 ]; then\n            echo \"true\"\n      \
    \      return\n          fi\n        fi\n      done\n    done\n  done\n  echo\
    \ \"false\"", "    SORTED_INPUT=$(echo $1 | tr \" \" \"\\n\" | sort)\n    for\
    \ x in $SORTED_INPUT; do\n        for y in $SORTED_INPUT; do\n            if [\
    \ $x != $y ]; then\n                for z in $SORTED_INPUT; do\n             \
    \       if [ $x != $z ] && [ $y != $z ]; then\n                        if [ $x\
    \ -eq $((-$y - $z)) ]; then\n                            echo \"true\"\n     \
    \                       return\n                        fi\n                 \
    \   fi\n                done\n            fi\n        done\n    done\n    echo\
    \ \"false\"", "    local list\n    read -r -a list <<< \"$1\"\n    # TODO: return\
    \ true if there are three elements in list that sum to zero\n    # HINT: you can\
    \ use the array_contains_three_sum_to_zero function\n    # HINT: you can use the\
    \ array_contains_sum_to function\n    if array_contains_three_sum_to_zero \"${list[@]}\"\
    ; then\n        echo \"true\"\n    else\n        echo \"false\"\n    fi", "  local\
    \ input=$1\n\n  # echo \"input is ${input}\"\n\n  local first=true\n  local triple=\"\
    true\"\n  local nums_str=''\n  local nums=()\n  local sum=0\n  local sum_str=''\n\
    \  local str=''\n\n  IFS=' ' read -r -a nums <<< \"${input}\"\n\n  # echo \"array\
    \ nums is ${nums[@]}\"\n\n  for i in \"${nums[@]}\"; do\n    for j in \"${nums[@]}\"\
    ; do\n      for k in \"${nums[@]}\"; do\n        if [[ \"${i}\" != \"${j}\" &&\
    \ \"${j}\" != \"${k}\" && \"${i}\" != \"${k}\" ]]; then\n          sum=$((i +\
    \ j + k))\n          # echo \"sum is ${sum}\"\n          if [[ \"${sum}\" == \"\
    0\" ]]; then\n            # echo \"first is ${first}\"\n            if [[ \"${first}\"\
    \ == \"true\" ]]; then\n              first=false\n              triple=\"true\"\
    \n            else\n              triple=\"false\"\n            fi\n         \
    \ fi\n        fi\n      done\n    done\n  done\n\n  echo \"${triple}\"", "   \
    \ local a b c\n\n    while read a b c; do\n        [ $(( a + b + c )) -eq 0 ]\
    \ && { echo \"true\"; return; }\n    done < <(echo \"$1\" | xargs -n 3)\n\n  \
    \  echo \"false\"", "  for ((i=0; i<$(wc -w <<< \"$1\"); i++)); do\n    for ((j=i+1;\
    \ j<$(wc -w <<< \"$1\"); j++)); do\n      for ((k=j+1; k<$(wc -w <<< \"$1\");\
    \ k++)); do\n        if [[ \"${1[i]}\" -eq \"0\" ]] || [[ \"${1[j]}\" -eq \"0\"\
    \ ]] || [[ \"${1[k]}\" -eq \"0\" ]]; then\n          continue\n        fi\n  \
    \      if (( $(echo \"${1[i]} + ${1[j]} + ${1[k]}\" | bc) == 0 )); then\n    \
    \      echo \"true\"\n          return\n        fi\n      done\n    done\n  done\n\
    \  echo \"false\"", "  # Your code here.\n  declare -A visited\n  for x in $1;\
    \ do\n    if [ ${visited[$x]} ]; then\n      echo \"true\"\n      return\n   \
    \ fi\n    ((visited[$x] = 1))\n  done\n  echo \"false\"", "    # No need to loop\
    \ over the elements in the array if there are\n    # fewer than three of them.\n\
    \    if [ $# -lt 3 ]; then\n        echo false\n        return\n    fi\n\n   \
    \ # For each element, loop over all later elements in the array\n    # and see\
    \ if they sum to zero.\n    while [ \"$1\" ]; do\n        # Skip over the element\
    \ we're currently on.\n        shift\n        for x in \"$@\"; do\n          \
    \  for y in \"$@\"; do\n                if [ $(( x + y )) -eq $(( 0 - $1 )) ];\
    \ then\n                    echo true\n                    return\n          \
    \      fi\n            done\n        done\n    done\n\n    echo false", "    result=$(solution_triples_sum_to_zero\
    \ \"$@\")\n    printf \"$result\"", "  for ((i=0; i<$(wc -w <<< \"$1\"); i++));\
    \ do\n    for ((j=i+1; j<$(wc -w <<< \"$1\"); j++)); do\n      for ((k=j+1; k<$(wc\
    \ -w <<< \"$1\"); k++)); do\n        local i=$(sed -n \"$((i+1))p\" <<< \"$1\"\
    )\n        local j=$(sed -n \"$((j+1))p\" <<< \"$1\")\n        local k=$(sed -n\
    \ \"$((k+1))p\" <<< \"$1\")\n        if [ $((i+j+k)) -eq 0 ]; then\n         \
    \ echo \"true\"\n          return\n        fi\n      done\n    done\n  done\n\
    \  echo \"false\"", "  if [[ $# -lt 3 ]]; then\n    echo \"false\"\n    return\n\
    \  fi\n  local arr=(\"$@\")\n  local res=false\n  local i=0\n  local j=0\n  local\
    \ k=0\n  for ((i=0; i<${#arr[@]}; i++)); do\n    for ((j=i+1; j<${#arr[@]}; j++));\
    \ do\n      for ((k=j+1; k<${#arr[@]}; k++)); do\n        local sum=$((arr[i]\
    \ + arr[j] + arr[k]))\n        if [[ $sum -eq 0 ]]; then\n          res=true\n\
    \          break\n        fi\n      done\n    done\n  done\n  echo \"$res\"",
  "    ret=\"false\"\n    # read the list into an array\n    i=0\n    while read -r\
    \ num; do\n        nums[$i]=$num\n        i=$((i+1))\n    done <<< \"$1\"\n  \
    \  nums_len=${#nums[@]}\n    #for ((i=0; i<nums_len; i++)); do\n    #    echo\
    \ \"${nums[$i]}\"\n    #done\n    # need to check all possible combinations of\
    \ 3 numbers\n    for ((i=0; i<nums_len; i++)); do\n        for ((j=i+1; j<nums_len;\
    \ j++)); do\n            for ((k=j+1; k<nums_len; k++)); do\n                sum=$((nums[$i]+nums[$j]+nums[$k]))\n\
    \                if [ $sum -eq 0 ]; then\n                    ret=\"true\"\n \
    \                   break\n                fi\n            done\n        done\n\
    \    done\n    echo \"$ret\"", "  typeset -a a=()\n  typeset -i i j k\n  a=($1)\n\
    \n  n=${#a[@]}\n  i=0\n  while (( i < n-2 )); do\n    j=i+1\n    while (( j <\
    \ n-1 )); do\n      k=j+1\n      while (( k < n )); do\n        if (( a[i] + a[j]\
    \ + a[k] == 0 )); then\n          echo \"true\"\n          return\n        fi\n\
    \        (( k++ ))\n      done\n      (( j++ ))\n    done\n    (( i++ ))\n  done\n\
    \  echo \"false\"", "  is_true=1\n  for ((i=0; i<$#; i++))\n  do\n    for ((j=i+1;\
    \ j<$#; j++))\n    do\n      for ((k=j+1; k<$#; k++))\n      do\n        if [[\
    \ $((${@:$i:1} + ${@:$j:1} + ${@:$k:1})) -eq 0 ]]\n        then\n          is_true=0\n\
    \        fi\n      done\n    done\n  done\n  if [[ $is_true -eq 0 ]]\n  then\n\
    \    echo \"true\"\n  else\n    echo \"false\"\n  fi", "  # Write your solution\
    \ code below this line\n  local INPUT_LIST=($1)\n  # i is the index of the first\
    \ number in the potential triplet\n  for ((i=0; i<${#INPUT_LIST[@]}-2; i++));\
    \ do\n    # j is the index of the second number in the potential triplet\n   \
    \ for ((j=i+1; j<${#INPUT_LIST[@]}-1; j++)); do\n      # k is the index of the\
    \ third number in the potential triplet\n      for ((k=j+1; k<${#INPUT_LIST[@]};\
    \ k++)); do\n        if [ $(( INPUT_LIST[i] + INPUT_LIST[j] + INPUT_LIST[k] ))\
    \ -eq 0 ]; then\n          echo true\n          return\n        fi\n      done\n\
    \    done\n  done\n  echo false", "  # TODO: your code here\n  return 0", "  #\
    \ put your code here\n  echo \"false\"", "  local triplesumtozero=false\n  local\
    \ first second third\n  for first in $1; do\n    for second in $1; do\n      for\
    \ third in $1; do\n        if [[ $first == $second || $first == $third || $second\
    \ == $third ]]; then\n          continue\n        fi\n        if [[ $(( $first\
    \ + $second + $third )) == 0 ]]; then\n          triplesumtozero=true\n      \
    \  fi\n      done\n    done\n  done\n  echo $triplesumtozero", "\tlist=($1)\n\t\
    for a in ${list[@]}; do\n\t\tfor b in ${list[@]}; do\n\t\t\tfor c in ${list[@]};\
    \ do\n\t\t\t\tif [[ $a + $b + $c -eq 0 ]]; then\n\t\t\t\t\treturn 0\n\t\t\t\t\
    fi\n\t\t\tdone\n\t\tdone\n\tdone\n\treturn 1", "  inp_array=( $1 )\n  n=${#inp_array[@]}\n\
    \  for ((i=0; i<n; i++))\n  do\n    ((j=i+1))\n    ((k=i+2))\n    while [[ $j\
    \ -lt $n ]]\n    do\n      while [[ $k -lt $n ]]\n      do\n        if [[ $((inp_array[i]\
    \ + inp_array[j] + inp_array[k])) -eq 0 ]]\n        then\n          echo \"true\"\
    \n          return\n        fi\n        ((k++))\n      done\n      ((j++))\n \
    \     ((k=j+1))\n    done\n  done\n  echo \"false\"", "  local list=\"$1\"\n \
    \ local size=$(echo $list | wc -w)\n  local i\n  for i in `seq 1 $size`; do\n\
    \    for j in `seq $i $(($size - 1))`; do\n      for k in `seq $(($j + 1)) $size`;\
    \ do\n        if [ $(echo $list | awk \"{print \\$$i + \\$$j + \\$$k}\") == 0\
    \ ]; then\n          echo true\n          return\n        fi\n      done\n   \
    \ done\n  done\n  echo false", "  local result=\"false\"\n  local input_array=($1)\n\
    \  for i in \"${input_array[@]}\"\n  do\n    for j in \"${input_array[@]}\"\n\
    \    do\n      for k in \"${input_array[@]}\"\n      do\n        if [[ $i != $j\
    \ && $j != $k && $i != $k && $i + $j + $k == 0 ]]\n        then\n          result=\"\
    true\"\n        fi\n      done\n    done\n  done\n  echo $result", "  echo $1\
    \ | xargs -n 3 | grep -e \"^\\([0-9]\\+ \\)\\{2\\}[-]\\?[0-9]\\+$\" | grep -E\
    \ \"^[-]?[0-9]+ [0-9]+ [0-9]+$\" | awk '{ if ($1 + $2 + $3 == 0) print \"true\"\
    ; else print \"false\"; }'", "\tinput=\"$1\"\n\tresult=\"false\"\n\t# do not waste\
    \ time on cases where it is clear that there can't be a\n\t# triple to sum to\
    \ zero\n\tif [[ \"${#input}\" -gt 4 ]]; then\n\t\t# do not waste time on cases\
    \ where there is only one unique number\n\t\t# in the list\n\t\tif [[ \"$(echo\
    \ \"${input}\" | sed 's/ /\\n/g' | sort | uniq | wc -l)\" -gt 1 ]]; then\n\t\t\
    \tfor a in ${input}; do\n\t\t\t\tfor b in ${input}; do\n\t\t\t\t\tfor c in ${input};\
    \ do\n\t\t\t\t\t\tif [[ $(( a + b + c )) -eq 0 ]]; then\n\t\t\t\t\t\t\tif [[ \"\
    ${a}\" != \"${b}\" ]] && [[ \"${b}\" != \"${c}\" ]] && [[ \"${a}\" != \"${c}\"\
    \ ]]; then\n\t\t\t\t\t\t\t\tresult=\"true\"\n\t\t\t\t\t\t\t\tbreak 3\n\t\t\t\t\
    \t\t\tfi\n\t\t\t\t\t\tfi\n\t\t\t\t\tdone\n\t\t\t\tdone\n\t\t\tdone\n\t\tfi\n\t\
    fi\n\techo \"${result}\"", '  echo "error"', "  local a\n  local b\n  local c\n\
    \  local sum\n  for ((i=0; i<${#1}; i++)); do\n    a=${1:i:1}\n    (( i++ ))\n\
    \    b=${1:i:1}\n    (( i++ ))\n    c=${1:i:1}\n    sum=$((a+b+c))\n    [[ $sum\
    \ -eq 0 ]] && echo \"true\" && return\n  done\n  echo \"false\"", "\t# YOUR CODE\
    \ HERE\n\tnumbers=($1)\n\tfor ((i=0; i<${#numbers[@]}; i++))\n\tdo\n\t\t#echo\
    \ \"i=${i}\"\n\t\tx=${numbers[i]}\n\t\tfor ((j=i+1; j<${#numbers[@]}; j++))\n\t\
    \tdo\n\t\t\t#echo \"j=${j}\"\n\t\t\ty=${numbers[j]}\n\t\t\tfor ((k=j+1; k<${#numbers[@]};\
    \ k++))\n\t\t\tdo\n\t\t\t\t#echo \"k=${k}\"\n\t\t\t\tz=${numbers[k]}\n\t\t\t\t\
    if [ $(($x+$y+$z)) -eq 0 ]\n\t\t\t\tthen\n\t\t\t\t\techo \"true\"\n\t\t\t\t\t\
    return\n\t\t\t\tfi\n\t\t\tdone\n\t\tdone\n\tdone\n\techo \"false\"", "\tlocal\
    \ my_list=\"$1\"\n\t# Insert code here\n\tlocal result=\"false\"\n\tlocal N=0\n\
    \tlocal my_array[$N]=\"\"\n\tfor i in $my_list; do\n\t\tmy_array[$N]=$i\n\t\t\
    N=$(($N+1))\n\tdone\n\tfor (( i=0; i<$N; i++ )) do\n\t\tfor (( j=i+1; j<$N; j++\
    \ )) do\n\t\t\tfor (( k=j+1; k<$N; k++ )) do\n\t\t\t\tif [ $((${my_array[$i]}+${my_array[$j]}+${my_array[$k]}))\
    \ -eq 0 ]; then\n\t\t\t\t\tresult=\"true\"\n\t\t\t\tfi\n\t\t\tdone\n\t\tdone\n\
    \tdone\n\techo $result", "  # your code here\n  local input=\"$@\"\n  local sum=0\n\
    \  local var1=0\n  local var2=0\n  local var3=0\n  local var4=0\n  local var5=0\n\
    \  local var6=0\n  local test=0\n  for var1 in $input; do\n    for var2 in $input;\
    \ do\n      for var3 in $input; do\n        test=$(( $var1 + $var2 + $var3 ))\n\
    \        if [ $test -eq 0 ]; then\n          echo \"true\"\n          return\n\
    \        fi\n      done\n    done\n  done\n  echo \"false\"", "    # TODO: Implement\
    \ this function.\n    return 0", "    # your code here\n    return 0", "  declare\
    \ -a triple_list=($1)\n  for ((i=0; i<${#triple_list[@]}; i++))\n  do\n    for\
    \ ((j=i+1; j<${#triple_list[@]}; j++))\n    do\n      for ((k=j+1; k<${#triple_list[@]};\
    \ k++))\n      do\n        if [ $(( ${triple_list[$i]} + ${triple_list[$j]} +\
    \ ${triple_list[$k]} )) -eq 0 ]\n        then\n          echo true\n         \
    \ return\n        fi\n      done\n    done\n  done\n  echo false", "  local ls=$(echo\
    \ $1 | tr \" \" \"\\n\")\n  for i in $ls; do\n    for j in $ls; do\n      for\
    \ k in $ls; do\n        if [ $i -ne $j ] && [ $j -ne $k ] && [ $i -ne $k ] &&\n\
    \           [ $((i + j + k)) -eq 0 ]; then\n          echo \"true\"\n        \
    \  return\n        fi\n      done\n    done\n  done\n  echo \"false\"", "    #\
    \ ++++ +++ ++ -++ +-+ --+ --- -+-\n    # $1 $2 $3 $3 $2 $1 $1 $2 $3\n    # $3\
    \ $2 $1 $1 $2 $3\n    # $2 $1 $3 $1 $2 $3\n    # $1 $2 $3\n    # find three distinct\
    \ triplets that sum to zero\n    sum_to_zero=0\n    for i in $1; do\n        let\
    \ sum_to_zero++\n        let sum_to_zero--\n    done\n    echo $sum_to_zero",
  "    # Input checking\n    if [[ ! $1 =~ ^[0-9 ]+$ ]]; then\n        echo \"Invalid\
    \ input.\"\n        return 1\n    fi\n\n    # Main algorithm\n\n    # Now, let's\
    \ suppose that we have a list of unique integers, that\n    # we have sorted.\
    \ Let's see if we can find three of them that sum to\n    # zero, using only comparisons\
    \ and arithmetics. First, let's see what we\n    # can do with a single list:\n\
    \n    # We'll use the array \"a\" to represent the sorted list. Here is how\n\
    \    # we can find an element x in the list:\n    # $ find_in_list a[@] x\n  \
    \  # This will return 0 if x is found in the list, and 1 otherwise.\n    # We\
    \ will use it like this:\n    # if [[ $? -eq 0 ]]; then\n    #     echo \"x is\
    \ in the list\"\n    # else\n    #     echo \"x is not in the list\"\n    # fi\n\
    \    #\n    # Now, let's see how we can find two integers that sum to zero:\n\
    \    # for (( i = 0; i < a.length; i++)); do\n    #     if [[ $(find_in_list a[@]\
    \ -a[i]) -eq 0 ]]; then\n    #         echo \"a[i] and -a[i] are in the list\"\
    \n    #     fi\n    # done\n    #\n    # Let's generalize this for three numbers:\
    \ we first fix one number, and\n    # look for two others that sum to -this_number.\n\
    \    # for (( i = 0; i < a.length; i++)); do\n    #     look_for=-a[i]\n    #\
    \     for (( j = 0; j < a.length; j++)); do\n    #         if [[ $(find_in_list\
    \ a[@] look_for-a[j]) -eq 0 ]]; then\n    #             echo \"a[i], a[j] and\
    \ look_for-a[j] are in the list\"\n    #         fi\n    #     done\n    # done\n\
    \    #\n    # Since we have to consider all combinations of two numbers, we have\n",
  "  # replace this code with your code\n  echo \"true\"", "    # YOUR CODE HERE\n\
    \    return 0", "  # Add your code here\n  for a in $1; do\n    for b in $1; do\n\
    \      for c in $1; do\n        if [ $a -ne $b ] && [ $a -ne $c ] && [ $b -ne\
    \ $c ] && [ $((a+b+c)) -eq 0 ]; then\n          echo true\n          return\n\
    \        fi\n      done\n    done\n  done\n  echo false", "    local arr=()\n\
    \    for x in $1; do\n        arr+=(\"$x\")\n    done\n    # we want to loop over\
    \ all combinations of indices of elements in the array.\n    # normally, we would\
    \ use something like this:\n    # for i in \"${!arr[@]}\"; do for j in \"${!arr[@]}\"\
    ; do\n    # but this won't work as intended, because j will be re-initialised\
    \ each\n    # time we go through the inner loop! we can get around this by using\
    \ a\n    # while loop instead.\n    local i=0\n    while [[ $i -lt ${#arr[@]}\
    \ ]]; do\n        local j=$i\n        while [[ $j -lt ${#arr[@]} ]]; do\n    \
    \        # since i starts at 0 and j starts at i, there is no need to\n      \
    \      # check if arr[i] == arr[j]\n            local k=$j\n            while\
    \ [[ $k -lt ${#arr[@]} ]]; do\n                if [[ (${arr[$i]} + ${arr[$j]}\
    \ + ${arr[$k]}) -eq 0 ]]; then\n                    echo \"true\"\n          \
    \          return\n                fi\n                ((k++))\n            done\n\
    \            ((j++))\n        done\n        ((i++))\n    done\n    echo \"false\"",
  "  for i in $1; do\n    for j in $1; do\n      for k in $1; do\n        if [[ $i\
    \ -ne $j ]] && [[ $j -ne $k ]] && [[ $i -ne $k ]] && [[ $i + $j + $k -eq 0 ]];\
    \ then\n          echo \"true\"\n          return 0\n        fi\n      done\n\
    \    done\n  done\n  echo \"false\"", "  # step 1: start with a loop that looks\
    \ at the first two numbers and the rest\n  # of the numbers.\n  # Once the loop\
    \ is working, you can uncomment the break statement to ensure\n  # that the loop\
    \ is only running for a few iterations.\n  for i in $(seq $#)\n  do\n    for j\
    \ in $(seq $#)\n    do\n      for k in $(seq $#)\n      do\n        # echo \"\
    $i $j $k\"\n        if [[ $i -ne $j ]] && [[ $i -ne $k ]] && [[ $j -ne $k ]]\n\
    \        then\n          # This is the case where all three numbers are distinct.\n\
    \          # Now, the sum of these three numbers is equal to 0\n          if [[\
    \ $(($1 + $2 + $3)) -eq 0 ]]\n          then\n            # echo $1 $2 $3\n  \
    \          echo \"true\"\n            return\n          fi\n        fi\n     \
    \ done\n    done\n  done\n  echo \"false\"", "    seq=($(echo $1 | tr \" \" \"\
    \\n\"))\n    n=$((${#seq[@]}-2))\n    ((n < 0)) && return\n    for i in $(seq\
    \ 0 $n); do\n        ((i+2 > n)) && break\n        ((seq[i]+seq[i+1]+seq[i+2]\
    \ == 0)) && echo true && return\n    done\n    echo false", "    # fill in this\
    \ function\n    echo \"false\"", "  for ((i=0; i<$(echo $1 | wc -w); i++)); do\n\
    \    for ((j=i+1; j<$(echo $1 | wc -w); j++)); do\n      for ((k=j+1; k<$(echo\
    \ $1 | wc -w); k++)); do\n        if [[ $(( $(echo $1 | cut -d' ' -f$((i+1)))\
    \ + $(echo $1 | cut -d' ' -f$((j+1))) + $(echo $1 | cut -d' ' -f$((k+1))) )) -eq\
    \ 0 ]]; then\n          echo \"true\"\n          return\n        fi\n      done\n\
    \    done\n  done\n  echo \"false\"", "\t#\n\t# put your code here\n\t#\n\tIFS=$'\
    \ '\n\tread -a array <<< \"$1\"\n\ti=0\n\tj=0\n\tk=0\n\twhile ((i < ${#array[@]}))\
    \ ; do\n\t\tj=$((i+1))\n\t\twhile ((j < ${#array[@]})) ; do\n\t\t\tk=$((j+1))\n\
    \t\t\twhile ((k < ${#array[@]})) ; do\n\t\t\t\tif [[ $((${array[i]} + ${array[j]}\
    \ + ${array[k]})) -eq 0 ]] ; then\n\t\t\t\t\techo \"true\"\n\t\t\t\t\treturn 0\n\
    \t\t\t\tfi\n\t\t\t\tk=$((k+1))\n\t\t\tdone\n\t\t\tj=$((j+1))\n\t\tdone\n\t\ti=$((i+1))\n\
    \tdone\n\techo \"false\"\n\treturn 0", "  #the_triples=\"$(printf \" %s\" $1)\"\
    \n  the_triples=$1\n  echo \"the triples are: $the_triples\"\n  for i in $the_triples;\
    \ do\n    for j in $the_triples; do\n      if [ \"$i\" == \"$j\" ]; then\n   \
    \     continue\n      fi\n      for k in $the_triples; do\n        if [ \"$k\"\
    \ == \"$i\" -o \"$k\" == \"$j\" ]; then\n          continue\n        fi\n    \
    \    if [ \"$i\" -eq \"$(($j + $k))\" ]; then\n          echo \"true\"\n     \
    \     return\n        fi\n      done\n    done\n  done\n  echo \"false\"", " \
    \   declare -a num_list=()\n    for number in $1; do\n        declare -i is_zero=0\n\
    \        if [[ $number -eq 0 ]]; then\n            ((is_zero++))\n        fi\n\
    \        if [[ $is_zero -ge 3 ]]; then\n            echo \"true\"\n          \
    \  return\n        fi\n        num_list[${#num_list[@]}]=$number\n    done\n \
    \   declare -i len=${#num_list[@]}\n    for ((i=0; i<$len; i++)); do\n       \
    \ for ((j=i+1; j<$len; j++)); do\n            for ((k=j+1; k<$len; k++)); do\n\
    \                declare -i sum=$((num_list[i] + num_list[j] + num_list[k]))\n\
    \                if [[ $sum -eq 0 ]]; then\n                    echo \"true\"\n\
    \                    return\n                fi\n            done\n        done\n\
    \    done\n    echo \"false\"", "    local -a int_array\n    local -i i\n    local\
    \ -i j\n    local -i k\n    local -i sum\n    local -i num_args\n    int_array=($1)\n\
    \    num_args=${#int_array[@]}\n    for ((i=0; i<$num_args-2; i++)); do\n    \
    \    for ((j=i+1; j<$num_args-1; j++)); do\n            for ((k=j+1; k<$num_args;\
    \ k++)); do\n                sum=$((int_array[i] + int_array[j] + int_array[k]))\n\
    \                if [[ $sum -eq 0 ]]; then\n                    echo \"true\"\n\
    \                    return\n                fi\n            done\n        done\n\
    \    done\n    echo \"false\"", "    local -a nums=($1)\n    for ((i=0; i<${#nums[@]};\
    \ i++)); do\n        for ((j=i+1; j<${#nums[@]}; j++)); do\n            for ((k=j+1;\
    \ k<${#nums[@]}; k++)); do\n                if [[ \"$(( ${nums[i]} + ${nums[j]}\
    \ + ${nums[k]} ))\" == \"0\" ]]; then\n                    echo \"true\"\n   \
    \                 return\n                fi\n            done\n        done\n\
    \    done\n    echo \"false\"", "  # perform any error checking here\n  if [ $#\
    \ -eq 0 ]; then\n    echo \"false\"\n    return 1\n  fi\n\n  # your code here\n\
    \  sorted_list=$(echo $@ | tr \" \" \"\\n\" | sort -n)\n  has_triple=$(echo $sorted_list\
    \ | tr \" \" \"\\n\" |\\\n      awk '{ for (i=3; i<=NF; i++) print $i \" \" $1\
    \ \" \" $2 }' |\\\n      awk '{ if ($1+$2+$3 == 0) print \"true\"; else print\
    \ \"false\" }')\n  if [[ \"$has_triple\" == \"true\" ]]; then\n    echo \"true\"\
    \n  else\n    echo \"false\"\n  fi", "  array=()\n  sum=0\n  for item in $1; do\n\
    \    sum=$((sum + item))\n    array+=($item)\n  done\n  if [ $sum -eq 0 ]; then\n\
    \    echo \"true\"\n  else\n    echo \"false\"\n  fi", "  local nums=($1)\n  #\
    \ put code here\n  # hint: use a nested loop", "  integers=\"$@\"\n  integer_array=($integers)\n\
    \n  ### INSERT CODE HERE ###\n  declare -a array\n  array=($integers)\n  len=${#array[@]}\n\
    \  for ((i=0; i<$len-2; i++))\n  do\n    for ((j=i+1; j<$len-1; j++))\n    do\n\
    \      for ((k=j+1; k<$len; k++))\n      do\n        if [[ $((${array[i]} + ${array[j]}\
    \ + ${array[k]})) -eq 0 ]]\n        then\n          echo \"true\"\n          return\n\
    \        fi\n      done\n    done\n  done\n  echo \"false\"", "  echo \"$1\" |\
    \ tr \" \" \"\\n\" | sort -g | sed '/^$/d' | uniq -c | awk '$1==3 { print \"true\"\
    ; exit } END { print \"false\" }'", '    echo 0', "  readonly input_array=($1)\n\
    \  for ((i=0; i<${#input_array[@]}; i++)); do\n    readonly a=${input_array[$i]}\n\
    \    for ((j=i+1; j<${#input_array[@]}; j++)); do\n      readonly b=${input_array[$j]}\n\
    \      for ((k=j+1; k<${#input_array[@]}; k++)); do\n        readonly c=${input_array[$k]}\n\
    \        if [ $(($a + $b + $c)) -eq 0 ]; then\n          echo \"true\"\n     \
    \     return\n        fi\n      done\n    done\n  done\n  echo \"false\"", " \
    \   python3 -c \"def triples_sum_to_zero(arr):\n        for i in range(len(arr)):\n\
    \            for j in range(i + 1, len(arr)):\n                for k in range(j\
    \ + 1, len(arr)):\n                    if (arr[i] + arr[j] + arr[k] == 0):\n \
    \                       return True\n        return False\n    print(triples_sum_to_zero([int(x)\
    \ for x in '$1'.split()]))\"", "  local nums=\"$1\"\n  # write your code here\n\
    \  local arr=($nums)\n  local size=${#arr[@]}\n  local i=0\n  local j=0\n  local\
    \ k=0\n  for ((i=0; i<size-2; i++)) {\n    for ((j=i+1; j<size-1; j++)) {\n  \
    \    for ((k=j+1; k<size; k++)) {\n        if [ $((${arr[i]} + ${arr[j]} + ${arr[k]}))\
    \ -eq 0 ]; then\n          echo \"true\"\n          return\n        fi\n     \
    \ done\n    }\n  }\n  echo \"false\"", "    # TODO: write this function.\n   \
    \ return 1", "    # \tWrite your code here\n    input=$1\n    arr=()\n    for\
    \ i in $input; do\n        arr+=(\"$i\")\n    done\n    len=${#arr[@]}\n    if\
    \ [ $len -lt 3 ]; then\n        echo \"false\"\n        return\n    fi\n    for\
    \ i in $(seq 0 $(($len - 3))); do\n        for j in $(seq $((i + 1)) $(($len -\
    \ 2))); do\n            for k in $(seq $((j + 1)) $(($len - 1))); do\n       \
    \         if [ $((arr[i] + arr[j] + arr[k])) -eq 0 ]; then\n                 \
    \   echo \"true\"\n                    return\n                fi\n          \
    \  done\n        done\n    done\n    echo \"false\"", "  for i in $1; do\n   \
    \ for j in $1; do\n      for k in $1; do\n        if [ $i != $j ] && [ $j != $k\
    \ ] && [ $i != $k ] && [ $(( $i + $j + $k )) -eq 0 ]; then\n          echo \"\
    true\"\n          return\n        fi\n      done\n    done\n  done\n  echo \"\
    false\"", "  # Do your work here\n  for i in \"$@\"\n  do\n    for j in \"$@\"\
    \n    do\n      for k in \"$@\"\n      do\n        if [[ \"$i\" -ne \"$j\" &&\
    \ \"$j\" -ne \"$k\" && \"$i\" -ne \"$k\" ]] && [[ $((i+j+k)) -eq 0 ]]\n      \
    \  then\n          echo \"true\"\n          return\n        fi\n      done\n \
    \   done\n  done\n  echo \"false\"", "  local list; list=($1)\n  local i; local\
    \ j; local k\n  local answer=\"false\"\n  for ((i=0; i<${#list[@]}; i++)); do\n\
    \    for ((j=i+1; j<${#list[@]}; j++)); do\n      for ((k=j+1; k<${#list[@]};\
    \ k++)); do\n        if [[ $(expr ${list[i]} + ${list[j]} + ${list[k]}) -eq 0\
    \ ]]; then\n          answer=\"true\"\n        fi\n      done\n    done\n  done\n\
    \  echo $answer", "  # FIXME: implement this function\n  return 1", "  # your\
    \ code here\n  # sort the input list by ascending order\n  sorted_list=`echo $1\
    \ | tr ' ' '\\n' | sort -n`\n  # initialize flag to false\n  flag=0\n  # declare\
    \ array\n  declare -a array\n\n  # create a function which push item to array\n\
    \  function push_to_array(){\n    array[${#array[@]}]=$1\n  }\n\n  # create a\
    \ function which compare items in array that sum to zero\n  function compare_array(){\n\
    \    if [[ $(( ${array[0]} + ${array[1]} + ${array[2]} )) -eq 0 ]]; then\n   \
    \   flag=1\n    fi\n  }\n\n  # create a function which remove first item in array\n\
    \  function remove_first_item(){\n    for i in \"${!array[@]}\"; do\n      if\
    \ [[ \"$i\" -gt 0 ]]; then\n        array[$i-1]=${array[$i]}\n      fi\n    done\n\
    \    unset \"array[${#array[@]}-1]\"\n  }\n\n  # for every element in sorted_list\n\
    \  for i in $sorted_list; do\n    # if the item is not in array\n    if [[ ! ${array[*]}\
    \ =~ $i ]]; then\n      # push item to array\n      push_to_array $i\n      #\
    \ if the length of array is 3\n      if [[ ${#array[@]} -eq 3 ]]; then\n     \
    \   # compare items in array that sum to zero\n        compare_array\n       \
    \ # remove first item in array\n        remove_first_item\n      fi\n    fi\n\
    \  done\n\n  # if flag is 1\n  if [[ $flag -eq 1 ]]; then\n    # return true\n\
    \    echo \"true\"\n  else\n    # return false\n    echo \"false\"\n  fi", " \
    \   local -a args=(\"$@\")\n    local ret=\"\"\n    local i j k\n    local l=${#args[@]}\n\
    \    local x1 x2\n    local s\n    local start=0\n    local end=$(($l-1))\n  \
    \  local mid=$((($l+1)/2))\n    local v\n    local found=false\n    local last\n\
    \n    function cmp() {\n        local arg1=${args[$1]}\n        local arg2=${args[$2]}\n\
    \        if [[ $arg1 -lt $arg2 ]]; then\n            return -1\n        elif [[\
    \ $arg1 -gt $arg2 ]]; then\n            return 1\n        else\n            return\
    \ 0\n        fi\n    }\n\n    function xchg() {\n        local tmp=${args[$1]}\n\
    \        args[$1]=${args[$2]}\n        args[$2]=$tmp\n    }\n\n    function partition()\
    \ {\n        start=$1\n        end=$2\n        local pivot=${args[$3]}\n     \
    \   xchg $3 $end\n        local i=$start\n        local j=$end\n        while\
    \ [[ $i -lt $j ]]; do\n            while [[ $i -lt $j ]] && [[ $(cmp $i $end)\
    \ -eq -1 ]]; do\n                ((i++))\n            done\n            while\
    \ [[ $i -lt $j ]] && [[ $(cmp $j $end) -eq 1 ]]; do\n                ((j--))\n\
    \            done\n            if [[ $i -lt $j ]]; then\n                xchg\
    \ $i $j\n            fi\n        done\n        xchg $i $end\n        return $i\n\
    \    }\n\n    function qsort() {\n        if [[ $1 -lt $2 ]]; then\n         \
    \   partition $1 $2 $3\n            local p=$?\n            qsort $1 $((p-1))\
    \ $1\n            qsort $((p+1)) $2 $((p+1))\n        fi\n    }\n\n    qsort 0\
    \ $(($l-1)) 0\n\n    for ((i=0; i<$(($l-2)); i++)); do\n        for ((j=$((i+1));",
  "    local answer=\"false\"\n    local -a inputs=(\"$@\")\n    for (( i=0; i<${#inputs[@]};\
    \ i++ )); do\n        for (( j=i+1; j<${#inputs[@]}; j++ )); do\n            for\
    \ (( k=j+1; k<${#inputs[@]}; k++ )); do\n                if [[ ${inputs[i]} -eq\
    \ $(( -1 * (${inputs[j]} + ${inputs[k]}) )) ]]; then\n                    answer=\"\
    true\"\n                fi\n            done\n        done\n    done\n    echo\
    \ \"$answer\"", "  local input=($1)\n  local array_length=${#input[@]}\n  if [[\
    \ $array_length -lt 3 ]]; then\n    echo false\n    return\n  fi\n  for (( i=0;\
    \ i<array_length-2; i++ )); do\n    for (( j=i+1; j<array_length-1; j++ )); do\n\
    \      for (( k=j+1; k<array_length; k++ )); do\n        local a=${input[i]}\n\
    \        local b=${input[j]}\n        local c=${input[k]}\n        if [[ $((a+b+c))\
    \ -eq 0 ]]; then\n          echo true\n          return\n        fi\n      done\n\
    \    done\n  done\n  echo false", "  for i in $1; do\n    for j in $1; do\n  \
    \    for k in $1; do\n        if [[ $i != $j && $j != $k && $i != $k && $i + $j\
    \ + $k -eq 0 ]]; then\n          echo \"true\"\n          return\n        fi\n\
    \      done\n    done\n  done\n  echo \"false\"", "    local result=\"false\"\n\
    \    for i in $1; do\n        for j in $1; do\n            for k in $1; do\n \
    \               if [ $i -ne $j ] && [ $j -ne $k ] && [ $i -ne $k ] && [ $(( $i\
    \ + $j + $k )) -eq 0 ]; then\n                    result=\"true\"\n          \
    \      fi\n            done\n        done\n    done\n    echo $result", "    #\
    \ if there are not at least three elements, the answer is false\n    if [ \"$#\"\
    \ -lt 3 ]; then\n        echo \"false\"\n        return 0\n    fi\n\n    # loop\
    \ through the list and check if the sum of each triple is zero\n    for a in \"\
    $@\"; do\n        # remove $a from the list\n        list_without_a=\"$@\"\n \
    \       unset list_without_a[$(($# - 1))]\n        list_without_a=(\"${list_without_a[@]}\"\
    )\n\n        for b in \"${list_without_a[@]}\"; do\n            # remove $b from\
    \ the list\n            list_without_ab=(\"${list_without_a[@]}\")\n         \
    \   unset list_without_ab[$(($# - 2))]\n            list_without_ab=(\"${list_without_ab[@]}\"\
    )\n\n            for c in \"${list_without_ab[@]}\"; do\n                if [\
    \ $((a + b + c)) -eq 0 ]; then\n                    echo \"true\"\n          \
    \          return 0\n                fi\n            done\n        done\n    done\n\
    \n    echo \"false\"", "    local local_list\n    # convert list to array\n  \
    \  local_list=(\"$@\")\n    local i\n    local j\n    local k\n    for ((i=0;\
    \ i<${#local_list[@]}; i++)); do\n        for ((j=i+1; j<${#local_list[@]}; j++));\
    \ do\n            for ((k=j+1; k<${#local_list[@]}; k++)); do\n              \
    \  if [[ $(( local_list[i] + local_list[j] + local_list[k] )) -eq 0 ]]; then\n\
    \                    echo \"true\"\n                    return\n             \
    \   fi\n            done\n        done\n    done\n    echo \"false\"", "  # Your\
    \ code here\n  local sum=0\n  local sum_list=\"\"\n  while read -r n; do\n   \
    \ sum_list=\"$sum_list $((sum + n))\"\n    sum=$((sum + n))\n  done <<< \"$1\"\
    \n  echo \"$sum_list\" | tr ' ' '\\n' | sort -nu | tr '\\n' ' '", "    # Implement\
    \ this function.\n    # \"a\" is the first integer, \"b\" is the second, and \"\
    c\" is the third.\n    # You can use \"a\" twice, as long as \"b\" and \"c\" are\
    \ distinct, as in\n    # the case of 1 3 -2 1, where \"b\" and \"c\" will both\
    \ be -2.\n    for ((a=0; a<$#; a++)); do\n        for ((b=a+1; b<$#; b++)); do\n\
    \            for ((c=b+1; c<$#; c++)); do\n                if [ \"${!a}\" == \"\
    0\" ]; then\n                    if [ \"${!b}\" == \"0\" ] && [ \"${!c}\" == \"\
    0\" ]; then\n                        echo \"true\"\n                        return\n\
    \                    fi\n                elif [ \"${!b}\" == \"0\" ]; then\n \
    \                   if [ \"${!a}\" == \"0\" ] && [ \"${!c}\" == \"0\" ]; then\n\
    \                        echo \"true\"\n                        return\n     \
    \               fi\n                elif [ \"${!c}\" == \"0\" ]; then\n      \
    \              if [ \"${!a}\" == \"0\" ] && [ \"${!b}\" == \"0\" ]; then\n   \
    \                     echo \"true\"\n                        return\n        \
    \            fi\n                elif [ $(( ${!a} + ${!b} + ${!c} )) == 0 ]; then\n\
    \                    echo \"true\"\n                    return\n             \
    \   fi\n            done\n        done\n    done\n    echo \"false\"", "    #\
    \ your solution here\n    nums=$1\n    n=0\n    for n in $nums\n    do\n     \
    \   sub_list=\"${nums/$n/}\"\n        for i in $sub_list\n        do\n       \
    \     second_sub_list=\"${sub_list/$i/}\"\n            for j in $second_sub_list\n\
    \            do\n                if [ $((n+i+j)) -eq 0 ]\n                then\n\
    \                    echo \"true\"\n                    return\n             \
    \   fi\n            done\n        done\n    done\n    echo \"false\"", "  # initialize\
    \ a space-separated string of 0s\n  count=$(echo \"$1\" | awk '{print NF}')\n\
    \  zeros=$(printf \"0 \"; printf \"%0.s0 \" $(seq 1 $(($count - 1))))\n  # get\
    \ positive / negative pairs\n  positive_negative_pairs=$(bash \"$(dirname \"$0\"\
    )/combinations.sh\" \"$1\" \"$zeros\")\n  positive_negative_pairs_count=$(echo\
    \ \"$positive_negative_pairs\" | wc -l)\n  # get all pairs\n  all_pairs=$(bash\
    \ \"$(dirname \"$0\")/combinations.sh\" \"$1\" \"$1\")\n  all_pairs_count=$(echo\
    \ \"$all_pairs\" | wc -l)\n  # get all triples\n  all_triples=$(bash \"$(dirname\
    \ \"$0\")/combinations.sh\" \"$1\" \"$1\" \"$1\")\n  all_triples_count=$(echo\
    \ \"$all_triples\" | wc -l)\n  # get all triples whose members are all from 1\
    \ set\n  same_triples=$(bash \"$(dirname \"$0\")/combinations.sh\" \"$1\" \"$1\"\
    \ \"$1\" \"$1\")\n  same_triples_count=$(echo \"$same_triples\" | wc -l)\n  #\
    \ subtract off all of the triples whose members are all from 1 set\n  valid_triples_count=$(($all_triples_count\
    \ - $same_triples_count))\n  if [ \"$positive_negative_pairs_count\" -eq 0 ];\
    \ then\n    echo \"false\"\n  elif [ \"$valid_triples_count\" -eq 0 ]; then\n\
    \    echo \"false\"\n  elif [ \"$valid_triples_count\" -eq 1 ]; then\n    echo\
    \ \"true\"\n  else\n    echo \"true\"\n  fi", "    if [ $# -lt 3 ]; then\n   \
    \     echo \"false\"\n        return\n    fi\n    for (( i=0; i<$#-2; i++ ));\
    \ do\n        for (( j=i+1; j<$#-1; j++ )); do\n            for (( k=j+1; k<$#;\
    \ k++ )); do\n                if [ $((${@:$i+1:1} + ${@:$j+1:1} + ${@:$k+1:1}))\
    \ -eq 0 ]; then\n                    echo \"true\"\n                    return\n\
    \                fi\n            done\n        done\n    done\n    echo \"false\"",
  "  list=\"$*\"\n  # print the number of integer triples that sum to zero:\n  echo\
    \ $list | awk '\n    BEGIN { FS=\" \" }\n    {\n      for (i=1; i<=NF; i++) {\n\
    \        for (j=i+1; j<=NF; j++) {\n          for (k=j+1; k<=NF; k++) {\n    \
    \        if ($i + $j + $k == 0) {\n              print \"true\"\n            \
    \  return\n            }\n          }\n        }\n      }\n      print \"false\"\
    \n    }\n  '", "  local nums=($1)\n\n  # loop through each number\n  for (( i=0;\
    \ i<${#nums[@]}; i++ )); do\n    # loop through each number after the first one\n\
    \    for (( j=i+1; j<${#nums[@]}; j++ )); do\n      # loop through each number\
    \ after the second one\n      for (( k=j+1; k<${#nums[@]}; k++ )); do\n      \
    \  # see if these three numbers sum to zero\n        if [ $(( ${nums[i]} + ${nums[j]}\
    \ + ${nums[k]} )) -eq 0 ]; then\n          echo \"true\"\n          return\n \
    \       fi\n      done\n    done\n  done\n\n  echo \"false\"", "    local list=\"\
    $1\"\n    local IFS=$' '\n\n    # split the list into an array\n    read -r -a\
    \ array <<< \"$list\"\n\n    # check each triplet\n    for (( i=0; i<$((${#array[@]}-2));\
    \ i++ )); do\n        for (( j=i+1; j<$((${#array[@]}-1)); j++ )); do\n      \
    \      for (( k=j+1; k<${#array[@]}; k++ )); do\n                # return true\
    \ if the triplet sums to zero\n                if [ $(( ${array[i]} + ${array[j]}\
    \ + ${array[k]} )) -eq 0 ]; then\n                    echo \"true\"\n        \
    \            return\n                fi\n            done\n        done\n    done\n\
    \n    # we haven't returned true if we get here, so the list does not contain\n\
    \    # a triple that sums to zero\n    echo \"false\"", "  # Write your solution\
    \ here\n  return 0", "  declare -a list=($1)\n  # loop over each member of the\
    \ list\n  for (( i=0; i<${#list[@]}; i++ )); do\n    # loop over the rest of the\
    \ list\n    for (( j=i+1; j<${#list[@]}; j++ )); do\n      for (( k=j+1; k<${#list[@]};\
    \ k++ )); do\n        # add the three numbers together\n        if [ \"${list[i]}\"\
    \ -eq $((-${list[j]}-${list[k]})) ]; then\n          echo \"true\"\n         \
    \ return\n        fi\n      done\n    done\n  done\n  echo \"false\"", "    local\
    \ sum=0\n    local list=()\n    for value in $1; do\n        sum=$(( sum + value\
    \ ))\n        list=( \"${list[@]}\" \"$value\" )\n    done\n    if [[ $sum -eq\
    \ 0 ]]; then\n        for (( i=0; i<${#list[@]}; i++ )); do\n            for ((\
    \ j=i+1; j<${#list[@]}; j++ )); do\n                for (( k=j+1; k<${#list[@]};\
    \ k++ )); do\n                    if [[ $((${list[i]} + ${list[j]} + ${list[k]}))\
    \ -eq 0 ]]; then\n                        echo true\n                        return\n\
    \                    fi\n                done\n            done\n        done\n\
    \    fi\n    echo false", "  len=$(wc -w <<< $1)\n  if [ $len -lt 3 ]; then\n\
    \    echo \"false\"\n    return\n  fi\n  for i in $1; do\n    for j in $1; do\n\
    \      for k in $1; do\n        sum=$(($i + $j + $k))\n        if [ $sum -eq 0\
    \ ]; then\n          echo \"true\"\n          return\n        fi\n      done\n\
    \    done\n  done\n  echo \"false\"", "  local numbers=$1\n  local number_list=($numbers)\n\
    \  local number_of_elements=${#number_list[@]}\n  local i\n  local j\n  local\
    \ k\n  for ((i=0; i<number_of_elements; i++)); do\n    for ((j=i+1; j<number_of_elements;\
    \ j++)); do\n      for ((k=j+1; k<number_of_elements; k++)); do\n        if [[\
    \ $(expr ${number_list[$i]} + ${number_list[$j]} + ${number_list[$k]}) -eq 0 ]];\
    \ then\n          echo \"true\"\n          return\n        fi\n      done\n  \
    \  done\n  done\n  echo \"false\"", "    local sum=0\n    local i=0\n    local\
    \ j=0\n    local k=0\n    local number=0\n    local numbers=($1)\n    for ((i=0;\
    \ i<${#numbers[@]}; i++)) do\n        number=${numbers[$i]}\n        for ((j=i+1;\
    \ j<${#numbers[@]}; j++)) do\n            for ((k=j+1; k<${#numbers[@]}; k++))\
    \ do\n                sum=$((number + ${numbers[$j]} + ${numbers[$k]}))\n    \
    \            if [ $sum -eq 0 ]; then\n                    echo \"true\"\n    \
    \                return\n                fi\n            done\n        done\n\
    \    done\n    echo \"false\"", "    eval \"local -a i=($1)\"\n    local len=${#i[@]}\n\
    \    # len 1 or 2 is false by definition\n    if [[ $len -lt 3 ]]; then\n    \
    \    echo false\n        return\n    fi\n    # Brute force O(n^3)\n    # loop\
    \ through each integer\n    for (( i=0; i<$len; i++ )); do\n        # loop through\
    \ every other integer\n        for (( j=$((i+1)); j<$len; j++ )); do\n       \
    \     # loop through every other other integer\n            for (( k=$((j+1));\
    \ k<$len; k++ )); do\n                # check for 0 and return true if found\n\
    \                if [[ $((i[$i]+i[$j]+i[$k])) -eq 0 ]]; then\n               \
    \     echo true\n                    return\n                fi\n            done\n\
    \        done\n    done\n    # default to false\n    echo false", "    local IFS=\"\
    \ \" read -a arr <<< \"$1\"\n    for (( i=0; i<${#arr[@]}-2; i++ )); do\n    \
    \    for (( j=i+1; j<${#arr[@]}-1; j++ )); do\n            for (( k=j+1; k<${#arr[@]};\
    \ k++ )); do\n                if [[ \"$(( ${arr[i]} + ${arr[j]} + ${arr[k]} ))\"\
    \ -eq 0 ]]; then\n                    echo \"true\"\n                    return\n\
    \                fi\n            done\n        done\n    done\n    echo \"false\"",
  "    # check to see if there are exactly three arguments\n    if [ \"$#\" -ne 3\
    \ ]; then\n        return 1\n    fi\n\n    # check to see if the sum of the arguments\
    \ is zero\n    if [ \"$(($1 + $2 + $3))\" -eq 0 ]; then\n        echo true\n \
    \   else\n        echo false\n    fi", "  local list=($1) # get the input list\n\
    \  local length=${#list[@]}\n  local i1=$(($length - 1))\n  local j1=$(($length\
    \ - 2))\n  local k1=$(($length - 3))\n  for ((i=0; i<$i1; i++)); do\n    for ((j=i+1;\
    \ j<$j1; j++)); do\n      for ((k=j+1; k<$k1; k++)); do\n        local n1=${list[$i]}\n\
    \        local n2=${list[$j]}\n        local n3=${list[$k]}\n        if [[ $((n1\
    \ + n2 + n3)) -eq 0 ]]; then\n          echo \"true\"\n          return\n    \
    \    fi\n      done\n    done\n  done\n  echo \"false\"", "    for i in \"$@\"\
    ; do\n        for j in \"$@\"; do\n            for k in \"$@\"; do\n         \
    \       if [[ \"$i\" == \"$j\" || \"$i\" == \"$k\" || \"$j\" == \"$k\" ]]; then\n\
    \                    continue\n                fi\n                if [[ $(( i\
    \ + j + k )) == 0 ]]; then\n                    echo true\n                  \
    \  return\n                fi\n            done\n        done\n    done\n    echo\
    \ false", "  local list=\"$1\"\n  # return true if there are three unique elements\
    \ in the list that\n  # sum to zero, and false otherwise\n  echo false", "\techo\
    \ $1", "  local a=($(echo $1))\n\n  (( ${#a[@]} < 3 )) && echo \"false\" && return\n\
    \n  # loop through the given numbers\n  for ((i=0; i<$((${#a[@]}-2)); i++)); do\n\
    \    n1=${a[$i]}\n\n    # loop through the given numbers that come after n1\n\
    \    for ((j=$(($i+1)); j<$((${#a[@]}-1)); j++)); do\n      n2=${a[$j]}\n\n  \
    \    # loop through the given numbers that come after n2\n      for ((k=$(($j+1));\
    \ k<${#a[@]}; k++)); do\n        n3=${a[$k]}\n\n        if (( n1 + n2 + n3 ==\
    \ 0 )); then\n          echo \"true\"\n          return\n        fi\n      done\n\
    \    done\n  done\n\n  echo \"false\"", "    for (( i=0; i<$((${#1}-2)); i++ ));\
    \ do\n        for (( j=i+1; j<$((${#1}-1)); j++ )); do\n            for (( k=j+1;\
    \ k<${#1}; k++ )); do\n                if [[ $((${1:$i:1} + ${1:$j:1} + ${1:$k:1}))\
    \ -eq 0 ]]; then\n                    echo \"true\"\n                    return\n\
    \                fi\n            done\n        done\n    done\n    echo \"false\"",
  "  local numbers=($1)\n  local length=${#numbers[@]}\n  local i=0\n  local a\n \
    \ local b\n  local c\n  while [ $i -lt $length ]; do\n    a=${numbers[$i]}\n \
    \   let i++\n    let j=$i\n    while [ $j -lt $length ]; do\n      b=${numbers[$j]}\n\
    \      let j++\n      let k=$j\n      while [ $k -lt $length ]; do\n        c=${numbers[$k]}\n\
    \        let k++\n        if [ $(expr $a + $b + $c) -eq 0 ]; then\n          echo\
    \ \"true\"\n          return\n        fi\n      done\n    done\n  done\n  echo\
    \ \"false\"", "  declare -a num_array\n  while IFS= read -r -d $' '; do\n    num_array+=(\"\
    $REPLY\")\n  done <<< \"$@\"\n  for ((i=0; i<${#num_array[@]}; i++)); do\n   \
    \ for ((j=i+1; j<${#num_array[@]}; j++)); do\n      for ((k=j+1; k<${#num_array[@]};\
    \ k++)); do\n        if [ $(( ${num_array[i]} + ${num_array[j]} + ${num_array[k]}\
    \ )) -eq 0 ]; then\n          echo true\n          return\n        fi\n      done\n\
    \    done\n  done\n  echo false", '  # your code here', "  # skip all but three\
    \ arguments\n  for i in $(seq 1 3 $(($#-2)))\n  do\n    for j in $(seq 2 3 $(($#-1)))\n\
    \    do\n      for k in $(seq 3 3 $#)\n      do\n        if [[ $(( $1 + $2 + $3\
    \ )) -eq 0 ]]\n        then\n          echo \"true\"\n          return\n     \
    \   fi\n      done\n    done\n  done\n  echo \"false\"", "  for ((i=0; i<${#1};\
    \ i++)); do\n    for ((j=i+1; j<${#1}; j++)); do\n      for ((k=j+1; k<${#1};\
    \ k++)); do\n        if [[ \"${1[i]}+${1[j]}+${1[k]}\" == \"0\" ]]; then\n   \
    \       return 0\n        fi\n      done\n    done\n  done\n  return 1", '  #
    YOUR CODE HERE', "  declare -a list=(\"$@\")\n  N=$((${#list[@]}-2))\n  (( N<0\
    \ )) && return 1\n  for (( i=0; i<N; i++ )); do\n    (( i>0 )) && [[ ${list[i]}\
    \ == ${list[i-1]} ]] && continue\n    for (( j=i+1; j<N+1; j++ )); do\n      ((\
    \ j>i+1 )) && [[ ${list[j]} == ${list[j-1]} ]] && continue\n      for (( k=j+1;\
    \ k<N+2; k++ )); do\n        (( k>j+1 )) && [[ ${list[k]} == ${list[k-1]} ]] &&\
    \ continue\n        (( ${list[i]}+${list[j]}+${list[k]} == 0 )) && echo \"true\"\
    \ && return 0\n      done\n    done\n  done\n  echo \"false\"\n  return 1", " \
    \ local sum=0;\n  local count=$(wc -w <<<\"$1\");\n  local idx1;\n  local idx2;\n\
    \  local idx3;\n  local i;\n  local j;\n  local z;\n  local arr;\n  local val;\n\
    \  local matches;\n  if [[ $count -gt 3 ]]; then\n    idx1=0;\n    idx2=1;\n \
    \   idx3=2;\n    while [[ $idx1 -lt $count ]]; do\n      val=$(cut -d' ' -f\"\
    $idx1\" <<<\"$1\");\n      arr=();\n      i=0;\n      while [[ $i -lt $count ]];\
    \ do\n        if [[ $i -ne $idx1 ]]; then\n          arr[i]=$(cut -d' ' -f\"$i\"\
    \ <<<\"$1\");\n        fi\n        (( i++ ));\n      done\n      j=0;\n      while\
    \ [[ $j -lt $(( count - 1 )) ]]; do\n        z=$(( j + 1 ));\n        while [[\
    \ $z -lt $(( count - 1 )) ]]; do\n          sum=$(( val + arr[j] + arr[z] ));\n\
    \          if [[ $sum -eq 0 ]]; then\n            echo \"true\";\n           \
    \ return;\n          fi\n          (( z++ ));\n        done\n        (( j++ ));\n\
    \      done\n      (( idx1++ ));\n    done\n  fi\n  echo \"false\";", '    # FIXME:
    implement me', "  declare -a l=($1)\n  length=${#l[@]}\n  for (( i=0; i<$length-2;\
    \ i++ )); do\n    for (( j=i+1; j<$length-1; j++ )); do\n      for (( k=j+1; k<$length;\
    \ k++ )); do\n        if [ $((${l[$i]} + ${l[$j]} + ${l[$k]})) -eq 0 ]; then\n\
    \          echo \"true\"\n          return\n        fi\n      done\n    done\n\
    \  done\n  echo \"false\"", "    local input=($1)\n    local i\n    local j\n\
    \    local k\n    for ((i=0; i<${#input[@]}; i++)); do\n        for ((j=i+1; j<${#input[@]};\
    \ j++)); do\n            for ((k=j+1; k<${#input[@]}; k++)); do\n            \
    \    if [[ $(expr ${input[i]} + ${input[j]} + ${input[k]}) -eq 0 ]]; then\n  \
    \                  echo \"true\"\n                    return\n               \
    \ fi\n            done\n        done\n    done\n    echo \"false\"", "    x=$1\n\
    \    for i in $x\n    do\n        for j in $x\n        do\n            for k in\
    \ $x\n            do\n                if [[ \"$i\" -ne \"$j\" && \"$j\" -ne \"\
    $k\" && \"$i\" -ne \"$k\" ]]\n                then\n                    if [[\
    \ \"$i\" -eq \"$((j + k))\" ]]\n                    then\n                   \
    \     echo \"true\"\n                        return\n                    fi\n\
    \                fi\n            done\n        done\n    done\n    echo \"false\"",
  "  triple=\"\"\n  for (( i=0; i<${#1}; i++ )); do\n    # iterate through the list\
    \ once\n    # with $i as the first digit.\n    if [[ \"$1\" =~ \"$i\" ]]; then\n\
    \      # once we find $i, find the other two digits\n      # $i can be any one\
    \ of the elements in the input array.\n      for (( j=0; j<${#1}; j++ )); do\n\
    \        if [[ \"$1\" =~ \"$j\" ]]; then\n          for (( k=0; k<${#1}; k++ ));\
    \ do\n            if [[ \"$1\" =~ \"$k\" ]]; then\n              # if $i + $j\
    \ + $k = 0, we found a set of three numbers that\n              # sum to zero.\n\
    \              if [[ $(( $i + $j + $k )) -eq 0 ]]; then\n                # If\
    \ the input array contains three or more values\n                # that sum to\
    \ zero, the program should find one triplet\n                # and return \"true\"\
    .\n                if [[ \"$triple\" == \"\" ]]; then\n                  triple=\"\
    true\"\n                fi\n              fi\n            fi\n          done\n\
    \        fi\n      done\n    fi\n  done\n  if [[ \"$triple\" == \"\" ]]; then\n\
    \    triple=\"false\"\n  fi\n  echo \"$triple\"", "    # TODO: write triples_sum_to_zero\n\
    \    # If a triple (a, b, c) sums to zero, then (b, c, a) also sums to zero,\n\
    \    # so you should first sort the list.\n    # If you're stuck, take a look\
    \ at the practice problems at the end of\n    # the lecture slides:\n    #   https://docs.google.com/presentation/d/1zj1VKV7uF_XjpCB7CpjYDuZg7VuJhADL-7VuBEX-OKI/edit#slide=id.g2a634fbe0_0_0\n\
    \    #\n    # Also, you can use the value of $0 to refer to the name of the script\n\
    \    # (triples_sum_to_zero).\n    #\n    # Let us know if you need help.\n  \
    \  # --YOUR CODE HERE--\n    # Sort the list using the following command.\n  \
    \  sorted=( $(echo $1 | tr \" \" \"\\n\" | sort -n) )\n    echo ${sorted[@]}\n\
    \    # The command will split the list by space and pass each element to sort.\
    \ \n    # It also uses -n to sort in numerical order.\n    # You can then access\
    \ each element in the sorted list using indices.\n    # If the list has N elements,\
    \ their indices will be from 0 to N-1.\n    # For example, if sorted=(4 5 -2 3\
    \ 1), then sorted[0]=4 and sorted[1]=5.\n    #\n    # One more hint: use tail\
    \ to remove the first element.\n    # For example, if sorted=(4 5 -2 3 1), then\
    \ tail -n +2 sorted=(5 -2 3 1).\n    # -------------------------------------------------------------------------\n\
    \    return", "  declare -a numbers=($1)\n  for ((i=0; i<${#numbers[@]}; i++));\
    \ do\n    for ((j=i+1; j<${#numbers[@]}; j++)); do\n      for ((k=j+1; k<${#numbers[@]};\
    \ k++)); do\n        if [ $(( ${numbers[i]} + ${numbers[j]} + ${numbers[k]} ))\
    \ -eq 0 ]; then\n          echo \"true\"\n          return\n        fi\n     \
    \ done\n    done\n  done\n  echo \"false\"", "    # Get the number of numbers\
    \ in the list.\n    local num_numbers=\"$(wc -w <<<\"$1\")\"\n    # Create an\
    \ array of the numbers.\n    local number_array=( $1 )\n    # Iterate through\
    \ each distinct pair of numbers in the list.\n    # j will equal i when the inner\
    \ loop starts, so we only get\n    # distinct pairs here.\n    for (( i=0; i<num_numbers-1;\
    \ i++ )); do\n        for (( j=i+1; j<num_numbers; j++ )); do\n            # Subtract\
    \ the two numbers to get the third number\n            # that would make a triple\
    \ sum to zero.\n            local third_number=$((-1 * (${number_array[i]} + ${number_array[j]})))\n\
    \            # Iterate through each remaining number in the list\n           \
    \ # to check if it is the third number.\n            for (( k=j+1; k<num_numbers;\
    \ k++ )); do\n                if [ ${number_array[k]} -eq $third_number ]; then\n\
    \                    # We found a triple that sums to zero.\n                \
    \    echo \"true\"\n                    return\n                fi\n         \
    \   done\n        done\n    done\n    # We didn't find a triple that sums to zero.\n\
    \    echo \"false\"", "   \n    if [ $# -eq 0 ]; then \n        echo false\n \
    \       return\n    fi\n    let i=0\n    while [ $i -lt $# ]; do\n        if [[\
    \ $i -ne 0 ]]; then\n            let sum=${!i}\n            let j=0\n        \
    \    while [ $j -lt $# ]; do\n                if [[ $j -ne $i ]]; then\n     \
    \               let sum=${!i}+${!j}\n                    let k=0\n           \
    \         while [ $k -lt $# ]; do\n                        if [[ $k -ne $i &&\
    \ $k -ne $j ]]; then\n                            let sum=${!i}+${!j}+${!k}\n\
    \                            if [[ $sum -eq 0 ]]; then\n                     \
    \           echo true\n                                return\n              \
    \              fi\n                        fi\n                        let k=k+1\n\
    \                    done\n                fi\n                let j=j+1\n   \
    \         done\n        fi\n        let i=i+1\n    done\n    echo false", "  #\
    \ compute the number of integers\n  # if it is not three, it is false\n  N=$(echo\
    \ $1 | wc -w)\n  if [ $N -ne 3 ]; then\n    echo \"false\"\n    return\n  fi\n\
    \n  # extract the three integers\n  INTS=$(echo $1 | tr \" \" \"\\n\")\n  for\
    \ i in $INTS; do\n    for j in $INTS; do\n      for k in $INTS; do\n        if\
    \ [ $i -eq $j ]; then\n          continue\n        fi\n        if [ $i -eq $k\
    \ ]; then\n          continue\n        fi\n        if [ $j -eq $k ]; then\n  \
    \        continue\n        fi\n        if [ $i -eq 0 ]; then\n          continue\n\
    \        fi\n        if [ $j -eq 0 ]; then\n          continue\n        fi\n \
    \       if [ $k -eq 0 ]; then\n          continue\n        fi\n        if [ $((i\
    \ + j + k)) -eq 0 ]; then\n          echo \"true\"\n          return\n       \
    \ fi\n      done\n    done\n  done\n  echo \"false\"", "    input_array=($1)\n\
    \    for (( i=0; i<${#input_array[@]}; i++ )); do\n      for (( j=i+1; j<${#input_array[@]};\
    \ j++ )); do\n        for (( k=j+1; k<${#input_array[@]}; k++ )); do\n       \
    \   if [ \"$((input_array[i] + input_array[j] + input_array[k]))\" -eq 0 ]; then\n\
    \            echo \"true\"\n            return\n          fi\n        done\n \
    \     done\n    done\n    echo \"false\"", "  for i in $1; do\n    for j in $1;\
    \ do\n      for k in $1; do\n        if [[ $i -ne $j ]] && [[ $j -ne $k ]] &&\
    \ [[ $i -ne $k ]] && [[ $i -eq $((-$j - $k)) ]]; then\n          echo \"true\"\
    \n          return\n        fi\n      done\n    done\n  done\n  echo \"false\"",
  "  # TODO: start your code here.\n  return", "  NUMBERS=($1)\n  LENGTH=${#NUMBERS[@]}\n\
    \  # iterate through NUMBERS array\n  for ((i=0; i<LENGTH; i++)); do\n    for\
    \ ((j=i+1; j<LENGTH; j++)); do\n      for ((k=j+1; k<LENGTH; k++)); do\n     \
    \   if [ $((${NUMBERS[$i]} + ${NUMBERS[$j]} + ${NUMBERS[$k]})) -eq 0 ]; then\n\
    \          echo \"true\"\n          return\n        fi\n      done\n    done\n\
    \  done\n  echo \"false\"", "  new_list=()\n  local temp\n  for element in $1;\
    \ do\n    temp=$(( $element*$element ))\n    new_list+=(\"$temp\")\n  done\n \
    \ new_list=${new_list[@]}\n  echo ${new_list[@]}\n  count=0\n  for (( i=0; i<${#new_list[@]};\
    \ i++ )); do\n    for (( j=i+1; j<${#new_list[@]}; j++ )); do\n      for (( k=j+1;\
    \ k<${#new_list[@]}; k++ )); do\n        if [[ $(( ${new_list[i]} + ${new_list[j]}\
    \ + ${new_list[k]} )) -eq 0 ]]; then\n          count=$(( $count + 1 ))\n    \
    \    fi\n      done\n    done\n  done\n  if [[ $count -eq 0 ]]; then\n    echo\
    \ false\n  else\n    echo true\n  fi", "    local -i sum=0\n    local -i count=0\n\
    \    local -a elements=($1)\n    local -i element=0\n    local -i i=0\n    local\
    \ -i j=0\n    local -i k=0\n    local -i loop_count=0\n    for i in \"${elements[@]}\"\
    ; do\n        for j in \"${elements[@]}\"; do\n            for k in \"${elements[@]}\"\
    ; do\n                if [[ \"$i\" != \"$j\" && \"$j\" != \"$k\" && \"$i\" !=\
    \ \"$k\" ]]; then\n                    ((loop_count++))\n                    sum=$((i\
    \ + j + k))\n                    if [[ $sum -eq 0 ]]; then\n                 \
    \       echo \"true\"\n                        return\n                    fi\n\
    \                fi\n            done\n        done\n    done\n    echo \"false\"",
  "    # NOTE: this works, but it is quadratic runtime O(n^2).\n    # It can be improved\
    \ to be O(n log n) by sorting and using pointers\n    # See other solutions\n\
    \    local list=()\n    while read -r num; do\n        list+=($num)\n    done\
    \ <<< \"$1\"\n    local num_trials=$(seq 0 $((${#list[@]} - 1)))\n    for i in\
    \ $num_trials; do\n        for j in $num_trials; do\n            for k in $num_trials;\
    \ do\n                if [ \"$i\" != \"$j\" ] && [ \"$j\" != \"$k\" ] && [ \"\
    $i\" != \"$k\" ]; then\n                    if [ \"${list[$i]}\" -eq \"$((${list[$j]}\
    \ + ${list[$k]}))\" ]; then\n                        echo \"true\"\n         \
    \               return\n                    fi\n                fi\n         \
    \   done\n        done\n    done\n    echo \"false\"", "  nums=$1\n  for i in\
    \ $nums; do\n    for j in $nums; do\n      for k in $nums; do\n        if [ $i\
    \ != $j ] && [ $j != $k ] && [ $i != $k ] && [ $((i+j+k)) -eq 0 ]; then\n    \
    \      echo \"true\"\n          return\n        fi\n      done\n    done\n  done\n\
    \  echo \"false\"", "  local -a arr\n\n  # read the input into an array\n  read\
    \ -a arr <<< \"$1\"\n\n  # initialize a hash for easier lookups\n  declare -A\
    \ hash\n\n  for num in \"${arr[@]}\"; do\n    # store the value in the hash with\
    \ a key of the negation of the value\n    hash[$(( -num ))]=1\n  done\n\n  for\
    \ num in \"${arr[@]}\"; do\n    # check if the value exists in the hash,\n   \
    \ # and if it does, whether the remainder exists in the hash.\n    # that remainder\
    \ can be found by negating the number and adding the\n    # number twice, to \"\
    undo\" the negation.\n    if [ \"${hash[$num]}\" ] && [ \"${hash[$(( num + (num\
    \ + num) ))]}\" ]; then\n      echo \"true\"\n      return\n    fi\n  done\n\n\
    \  echo \"false\"", '  # Your code here', "    # YOUR CODE HERE\n    return 0",
  "  # IMPLEMENT HERE\n  # should probably check the number of arguments passed\n\
    \  numargs=$#\n  if [ $numargs -ne 1 ]; then\n    echo \"false\"\n    return\n\
    \  fi\n  array=(\"$@\")\n  len=${#array[@]}\n  result=\"false\"\n  if [ $len -gt\
    \ 2 ]; then\n    for i in $(seq 0 $(($len-3))); do\n      for j in $(seq $(($i+1))\
    \ $(($len-2))); do\n        for k in $(seq $(($j+1)) $(($len-1))); do\n      \
    \    if [ $((array[$i]+array[$j]+array[$k])) -eq 0 ]; then\n            result=\"\
    true\"\n            break 3\n          fi\n        done\n      done\n    done\n\
    \  fi\n  echo $result", "    local ARRAY=()\n    local IFS=$'\\n'\n    for VAR\
    \ in $1; do\n        ARRAY+=(\"$VAR\")\n    done\n    local ARRAY_LENGTH=${#ARRAY[@]}\n\
    \    for ((I=0; I<$ARRAY_LENGTH; I++)); do\n        for ((J=I+1; J<$ARRAY_LENGTH;\
    \ J++)); do\n            for ((K=J+1; K<$ARRAY_LENGTH; K++)); do\n           \
    \     if [[ $((${ARRAY[$I]} + ${ARRAY[$J]} + ${ARRAY[$K]})) -eq 0 ]]; then\n \
    \                   echo \"true\"\n                    return\n              \
    \  fi\n            done\n        done\n    done\n    echo \"false\"", "    local\
    \ sums=\"\"\n    local list=\"\"\n    for i in \"$@\"; do\n        for j in \"\
    $@\"; do\n            for k in \"$@\"; do\n                if [ \"$i\" -ne \"\
    $j\" ] && [ \"$j\" -ne \"$k\" ] && [ \"$i\" -ne \"$k\" ]; then\n             \
    \       sums=$(printf \"%s %s\" \"$sums\" \"$((i + j + k))\")\n              \
    \  fi\n            done\n        done\n    done\n    if [[ $sums =~ \" 0\" ]];\
    \ then\n        echo \"true\"\n    else\n        echo \"false\"\n    fi", "  \
    \  local ints=\"$1\"\n    # your code goes here", "    local sum=$(echo \"$1\"\
    \ | awk '{ sum=0; for (i=1; i<=NF; i++) { sum+=$i; } print sum }')\n    if [[\
    \ \"$sum\" -eq 0 ]]; then\n        echo \"true\"\n    else\n        echo \"false\"\
    \n    fi", "  for first in $1; do\n    for second in $1; do\n      for third in\
    \ $1; do\n        if [[ $first != $second && $second != $third && $first != $third\
    \ ]]; then\n          if [[ $((first + second + third)) -eq 0 ]]; then\n     \
    \       echo \"true\"\n            return\n          fi\n        fi\n      done\n\
    \    done\n  done\n  echo \"false\"", "\t# check for single argument\n\tif [ $#\
    \ -eq 1 ]; then\n\t\treturn 1\n\tfi\n\n\tlocal -a array=($1)\n\tlocal length=${#array[@]}\n\
    \tlocal i=0\n\tlocal a=0\n\tlocal b=0\n\tlocal c=0\n\n\t# cycle through every\
    \ possible triple combination\n\tfor ((i=0; i<length-2; i++)); do\n\t\tfor ((a=i+1;\
    \ a<length-1; a++)); do\n\t\t\tfor ((b=a+1; b<length; b++)); do\n\t\t\t\t# check\
    \ the elements of the triple sum to zero\n\t\t\t\tif [ $(expr ${array[$i]} + ${array[$a]}\
    \ + ${array[$b]}) -eq 0 ]; then\n\t\t\t\t\treturn 0\n\t\t\t\tfi\n\t\t\tdone\n\t\
    \tdone\n\tdone\n\n\treturn 1", "  a=$1\n  # code goes here\n  echo \"false\"",
  "  # your code here\n  readarray -t line < <(printf '%s\\n' \"$1\")\n  size=${#line[@]}\n\
    \  if [[ $size < 3 ]]; then\n      echo \"false\"\n      return\n  fi\n  for ((i=0;\
    \ i<size-2; i++)); do\n      for ((j=i+1; j<size-1; j++)); do\n          for ((k=j+1;\
    \ k<size; k++)); do\n              if (($((line[i] + line[j] + line[k])) == 0));\
    \ then\n                  echo \"true\"\n                  return\n          \
    \    fi\n          done\n      done\n  done\n  echo \"false\"", "    # your code\
    \ here\n    if [[ $# -lt 3 ]]; then\n        echo \"false\"\n        return\n\
    \    fi\n    for (( i=0; i<$#-2; i++ )); do\n        for (( j=i+1; j<$#-1; j++\
    \ )); do\n            for (( k=j+1; k<$#; k++ )); do\n                if [[ $((\
    \ ${1[$i]} + ${1[$j]} + ${1[$k]} )) -eq 0 ]]; then\n                    echo \"\
    true\"\n                    return\n                fi\n            done\n   \
    \     done\n    done\n    echo \"false\"", "    # just splitting by space\n  \
    \  local ints=($1)\n    local sum\n    for ((i=0; i<${#ints[@]}; i++)); do\n \
    \       for ((j=i+1; j<${#ints[@]}; j++)); do\n            for ((k=j+1; k<${#ints[@]};\
    \ k++)); do\n                sum=$((ints[i] + ints[j] + ints[k]))\n          \
    \      if [[ $sum -eq 0 ]]; then\n                    echo \"true\"\n        \
    \            return\n                fi\n            done\n        done\n    done\n\
    \    echo \"false\"", "  declare i j k\n  for i in $1; do\n    for j in $1; do\n\
    \      if [ \"$i\" -ne \"$j\" ]; then\n        for k in $1; do\n          if [\
    \ \"$i\" -ne \"$k\" ] && [ \"$j\" -ne \"$k\" ]; then\n            if [ \"$((i\
    \ + j + k))\" -eq 0 ]; then\n              echo true\n              return\n \
    \           fi\n          fi\n        done\n      fi\n    done\n  done\n  echo\
    \ false", "    # Your code here\n    array=(${1// / })\n    flag=0\n    for ((i=0;\
    \ i<${#array[@]}; i++))\n    do\n        for ((j=i+1; j<${#array[@]}; j++))\n\
    \        do\n            for ((k=j+1; k<${#array[@]}; k++))\n            do\n\
    \                if [[ $((array[i]+array[j]+array[k])) -eq 0 ]]\n            \
    \    then\n                    flag=1\n                fi\n            done\n\
    \        done\n    done\n    if [[ $flag -eq 1 ]]\n    then\n        echo \"true\"\
    \n    else\n        echo \"false\"\n    fi", "  local -a nums=( $1 )\n  # only\
    \ proceed if we have 3 numbers to work with\n  if [ ${#nums[@]} -lt 3 ]; then\n\
    \    echo \"false\"\n    return\n  fi\n  for ((i=0; i<${#nums[@]}; i++)); do\n\
    \    for ((j=i+1; j<${#nums[@]}; j++)); do\n      for ((k=j+1; k<${#nums[@]};\
    \ k++)); do\n        if [ $((${nums[$i]} + ${nums[$j]} + ${nums[$k]})) -eq 0 ];\
    \ then\n          echo \"true\"\n          return\n        fi\n      done\n  \
    \  done\n  done\n  echo \"false\"", "  # your code here\n  return", "    # I always\
    \ forget how to do 'for loops' in bash.  So I cheated a bit.\n    # $1 is our\
    \ space-separated list.  Using cut with a delimiter of ' '\n    # gives me an\
    \ array from $1.  I then use paste to convert the array\n    # into a newline-separated\
    \ list with a trailing newline.  I then\n    # pipe that list into a while loop\
    \ where I read each line into a var.\n    paste -sd '\\n' <(echo $1 | cut -d '\
    \ ' -f 1-) |\n        while read val; do\n            # if our outer for loop\
    \ iterator is not equal to the value\n            # we just read in, then increment\
    \ the iterator.\n            if [ $val -ne \"$outer\" ]; then\n              \
    \  # check to see if our outer value and our next value sum\n                #\
    \ to zero.  If so, we've found our triple.\n                let \"sum = $outer\
    \ + $val\"\n                if [ $sum -eq 0 ]; then\n                    echo\
    \ true\n                    # if we find our triple, we don't need to keep\n \
    \                   # checking, so exit.\n                    exit\n         \
    \       fi\n            fi\n            # otherwise, set outer to the value we\
    \ just read.\n            outer=$val\n        done\n    # since we didn't find\
    \ our triple and exit, we return false.\n    echo false", '  echo "$1"', "   \
    \ # Using a loop\n    for i in $1; do\n        for j in $1; do\n            for\
    \ k in $1; do\n                if [ $i -ne $j ] && [ $j -ne $k ] && [ $i -ne $k\
    \ ] \\\n                && [ $(( $i + $j + $k )) -eq 0 ]; then\n             \
    \       echo \"true\"\n                    return\n                fi\n      \
    \      done\n        done\n    done\n    echo \"false\"", '    # TODO Write your
    code here', "  # num_numbers is the number of numbers in the input\n  num_numbers=$(echo\
    \ \"$1\" | wc -w)\n  if [[ $num_numbers -lt 3 ]]; then\n    echo \"false\"\n \
    \   return\n  fi\n  # loop through the outermost (first) number.\n  for i in $1;\
    \ do\n    # loop through the second number.\n    for j in $1; do\n      # loop\
    \ through the third number.\n      for k in $1; do\n        # if all three numbers\
    \ are distinct,\n        # and their sum is zero, return true.\n        if [[\
    \ $i != $j && $i != $k && $j != $k && $i + $j + $k == 0 ]]; then\n          echo\
    \ \"true\"\n          return\n        fi\n      done\n    done\n  done\n  # if\
    \ no such three distinct numbers are found, return false.\n  echo \"false\"",
  '    :', "    sum=0\n    for i in $1; do\n        for j in $1; do\n            for\
    \ k in $1; do\n                if [ $i -ne $j ] && [ $j -ne $k ] && [ $i -ne $k\
    \ ]; then\n                    sum=$(($i + $j + $k))\n                    if [\
    \ $sum -eq 0 ]; then\n                        echo \"true\"\n                \
    \        return\n                    fi\n                fi\n            done\n\
    \        done\n    done\n    echo \"false\"", "  local result=\"false\"\n  local\
    \ num_list=($1)\n  local len=${#num_list[@]}\n  local i=0\n  local j=0\n  local\
    \ k=0\n  for ((i=0; i<$len; i++)); do\n    for ((j=$i+1; j<$len; j++)); do\n \
    \     for ((k=$j+1; k<$len; k++)); do\n        if [[ $((${num_list[$i]} + ${num_list[$j]}\
    \ + ${num_list[$k]})) -eq 0 ]]; then\n          result=\"true\"\n        fi\n\
    \      done\n    done\n  done\n  echo $result", "  seq $1 | awk '{\n      for\
    \ (i = 1; i <= NF; i++) {\n        for (j = i + 1; j <= NF; j++) {\n         \
    \ for (k = j + 1; k <= NF; k++) {\n            if ($i + $j + $k == 0) {\n    \
    \          print \"true\";\n              exit;\n            }\n          }\n\
    \        }\n      }\n      print \"false\";\n    }'", "    # TODO: your implementation\
    \ here\n    zerosum=false\n    for (( i=0; i<$#; i++ ))\n    do\n        num1=${!i}\n\
    \        # echo $num1\n        for (( j=i+1; j<$#; j++ ))\n        do\n      \
    \      num2=${!j}\n            # echo $num2\n            for (( k=j+1; k<$#; k++\
    \ ))\n            do\n                num3=${!k}\n                # echo $num3\n\
    \                let sum=$num1+$num2+$num3\n                if [[ $sum -eq 0 ]]\n\
    \                then\n                    zerosum=true\n                fi\n\
    \            done\n        done\n    done\n    echo $zerosum", "  local -a l=($(echo\
    \ $1 | tr ' ' '\\n'))\n  local n=${#l[@]}\n  local i j k\n  for ((i=0; i<$n; i++));\
    \ do\n    for ((j=i+1; j<$n; j++)); do\n      for ((k=j+1; k<$n; k++)); do\n \
    \       if [ $((${l[$i]} + ${l[$j]} + ${l[$k]})) -eq 0 ]; then\n          echo\
    \ \"true\"\n          return\n        fi\n      done\n    done\n  done\n  echo\
    \ \"false\"", "    # > your code here <\n    OLDIFS=$IFS\n    IFS=\" \"\n    numbers=($1)\n\
    \    IFS=$OLDIFS\n    n=${#numbers[@]}\n    if [ $n -lt 3 ]; then\n        echo\
    \ \"false\"\n        return 0\n    fi\n    for i in $(seq 0 $((n-3))); do\n  \
    \      for j in $(seq $((i+1)) $((n-2))); do\n            for k in $(seq $((j+1))\
    \ $((n-1))); do\n                if [ $((numbers[i]+numbers[j]+numbers[k])) -eq\
    \ 0 ]; then\n                    echo \"true\"\n                    return 0\n\
    \                fi\n            done\n        done\n    done\n    echo \"false\"",
  "  # It's easy to do using an O(n^3) algorithm. It's difficult to do\n  # using\
    \ a better approach, because the brute force approach is a little\n  # easier\
    \ to reason about.\n  local num_triplets=0\n  for ((i=0; i<$(echo $1 | wc -w);\
    \ i++)); do\n    local current=$(echo $1 | cut -d ' ' -f $((i+1)))\n    for ((j=0;\
    \ j<$(echo $1 | wc -w); j++)); do\n      local next=$(echo $1 | cut -d ' ' -f\
    \ $((j+1)))\n      for ((k=0; k<$(echo $1 | wc -w); k++)); do\n        local next_next=$(echo\
    \ $1 | cut -d ' ' -f $((k+1)))\n        if [[ $current -eq -$((next + next_next))\
    \ ]]; then\n          ((num_triplets++))\n        fi\n      done\n    done\n \
    \ done\n  if [[ $num_triplets -eq 0 ]]; then\n    echo false\n  else\n    echo\
    \ true\n  fi", "  local count=0\n  local num1\n  local num2\n  local num3\n  for\
    \ num1 in $1; do\n    for num2 in $1; do\n      for num3 in $1; do\n        if\
    \ [ $num1 -ne $num2 ] && [ $num2 -ne $num3 ] && [ $num1 -ne $num3 ]; then\n  \
    \        if [ $(($num1 + $num2 + $num3)) -eq 0 ]; then\n            echo true\n\
    \            count=1\n            break\n          fi\n        fi\n      done\n\
    \      if [ $count -eq 1 ]; then\n        break\n      fi\n    done\n    if [\
    \ $count -eq 1 ]; then\n      break\n    fi\n  done\n  if [ $count -eq 0 ]; then\n\
    \    echo false\n  fi", "  for i in $1; do\n    for j in $1; do\n      for k in\
    \ $1; do\n        if [ $i -ne $j ] && [ $j -ne $k ] && [ $i -ne $k ] && [ $((i+j+k))\
    \ -eq 0 ]; then\n          echo \"true\"\n          return 0\n        fi\n   \
    \   done\n    done\n  done\n  echo \"false\"", "  # we are going to use the same\
    \ strategy as \"pairs_sum_to_value\"\n  # for each element in the array we will\
    \ run a search for -value.\n  # since we want to use three distinct elements,\
    \ we can't use that\n  # same approach.\n  # instead, we should take each element,\
    \ search for -value, and then\n  # remove the value we used from the array.\n\
    \  #\n  # $remaining_values is a space-separated list\n  remaining_values=$1\n\
    \  # $index is an integer\n  index=0\n  # we need to have at least three elements\
    \ in the array to even have a\n  # chance of having three values that sum to zero\n\
    \  while [ \"$index\" -lt \"$((${#remaining_values} / 3))\" ]; do\n    # $value\
    \ is an integer\n    value=\"$( echo \"$remaining_values\" | cut -d' ' -f$(( $index\
    \ + 1 )) )\"\n    # the value we are searching for is the negation of $value\n\
    \    # $target is an integer\n    target=\"$(( -1 * $value ))\"\n    # now we\
    \ want to see if that $target is in the rest of the array\n    # $success is a\
    \ boolean\n    success=\"$( bin_search \"$target\" \"$remaining_values\" )\"\n\
    \    # if $success is \"true\", then we found two other values that sum to zero\n\
    \    if [ \"$success\" = \"true\" ]; then\n      # $(...) returns a string, so\
    \ we can just return \"true\"\n      echo \"true\"\n      # return to exit the\
    \ function\n      return\n    fi\n    # increment $index\n    index=\"$(( $index\
    \ + 1 ))\"\n  done\n  # if we get here, then we couldn't find three values that\
    \ sum to zero\n  # $remaining_values is a space-separated list\n  remaining_values=$1\n\
    \  # now we need to remove the value we just used from the array\n  # $remaining_values\
    \ is a space-separated list\n  remaining_values=\"$( echo \"$remaining_values\"\
    \ | cut -d' ' -f\"$(( $index + 2 ))\"-\"$(( ${#remaining_values", "    # first,\
    \ sort the list\n    list=($(echo $1 | tr \" \" \"\\n\" | sort -n))\n    # len\
    \ is the number of elements in the list\n    len=${#list[@]}\n    for ((i=0; i<$len-2;\
    \ i++)); do\n        for ((j=i+1; j<$len-1; j++)); do\n            for ((k=j+1;\
    \ k<$len; k++)); do\n                if [ $((${list[$i]} + ${list[$j]} + ${list[$k]}))\
    \ -eq 0 ]; then\n                    echo \"true\"\n                    return\n\
    \                fi\n            done\n        done\n    done\n    echo \"false\"",
  "  for i in $1; do\n    for j in $1; do\n      for k in $1; do\n        if [ $(($i\
    \ + $j + $k)) == 0 ]; then\n          if [ $i != $j ] && [ $j != $k ] && [ $i\
    \ != $k ]; then\n            echo \"true\"\n            return\n          fi\n\
    \        fi\n      done\n    done\n  done\n  echo \"false\"", '    echo "not implemented"',
  "  list=(\"$@\")\n  if [[ \"${#list[@]}\" -lt 3 ]]; then\n    echo \"false\"\n \
    \   return\n  fi\n  for i in $(seq 0 $(( ${#list[@]} - 3 ))); do\n    for j in\
    \ $(seq $(( i + 1 )) $(( ${#list[@]} - 2 ))); do\n      for k in $(seq $(( j +\
    \ 1 )) $(( ${#list[@]} - 1 ))); do\n        if [[ \"${list[$i]}\" -eq \"$(( 0\
    \ - ${list[$j]} - ${list[$k]} ))\" ]]; then\n          echo \"true\"\n       \
    \   return\n        fi\n      done\n    done\n  done\n  echo \"false\"", "  #\
    \ your code here\n  for i in $1\n  do\n    for j in $1\n    do\n      for k in\
    \ $1\n      do\n        if [[ $i -ne $j && $j -ne $k && $i -ne $k ]]\n       \
    \ then\n          if [[ $i + $j + $k -eq 0 ]]\n          then\n            echo\
    \ \"true\"\n            return\n          fi\n        fi\n      done\n    done\n\
    \  done\n  echo \"false\"", "\tlist=($1)\n\tfor i in ${list[@]}; do\n\t\tfor j\
    \ in ${list[@]}; do\n\t\t\tfor k in ${list[@]}; do\n\t\t\t\tif [ $i -ne $j ] &&\
    \ [ $j -ne $k ] && [ $i -ne $k ] && [ $(($i + $j + $k)) -eq 0 ]; then\n\t\t\t\t\
    \techo \"true\"\n\t\t\t\t\treturn\n\t\t\t\tfi\n\t\t\tdone\n\t\tdone\n\tdone\n\t\
    echo \"false\"", "  # your code here\n  if [ $# -le 2 ]; then\n    echo \"false\"\
    \n    return\n  fi\n  for (( i=0; i<$#-2; i++ )); do\n    for (( j=i+1; j<$#-1;\
    \ j++ )); do\n      for (( k=j+1; k<$#; k++ )); do\n        if [ $(( ${1:$i:1}\
    \ + ${1:$j:1} + ${1:$k:1} )) -eq 0 ]; then\n          echo \"true\"\n        \
    \  return\n        fi\n      done\n    done\n  done\n  echo \"false\"", "  set\
    \ -f\n  input_list=($1)\n  input_size=${#input_list[@]}\n  for ((i=0; i<$input_size;\
    \ i++))\n  do\n    for ((j=i+1; j<$input_size; j++))\n    do\n      for ((k=j+1;\
    \ k<$input_size; k++))\n      do\n        if [[ $(( ${input_list[$i]} + ${input_list[$j]}\
    \ + ${input_list[$k]} )) == 0 ]]\n        then\n          echo \"true\"\n    \
    \      return\n        fi\n      done\n    done\n  done\n  echo \"false\"", " \
    \ # A list, a state, and an i all get passed in. The list is a working\n  # list,\
    \ which gets smaller and smaller each time. The state is an integer\n  # which\
    \ tells whether the algorithm is searching for the first element,\n  # the second\
    \ element, or if it has found a triple and is going to return.\n  # The i is a\
    \ counter for the value of the iteratation.\n  # echo 0\n  # echo $1\n  is_zero(){\n\
    \    if [ $(($1 + $2 + $3)) -eq 0 ]; then\n      echo true\n    else\n      echo\
    \ false\n    fi\n  }\n  # echo \"calling search_for_triple\"\n  # echo $1\n  search_for_triple(){\n\
    \    if [ $3 -gt $(( $# - 2 )) ]; then\n      echo false\n    else\n      # echo\
    \ \"going to search_for_second\"\n      search_for_second $@ $1\n    fi\n  }\n\
    \  # echo \"calling search_for_second\"\n  # echo $1\n  search_for_second(){\n\
    \    if [ $4 -gt $(( $# - 1 )) ]; then\n      echo false\n    else\n      # echo\
    \ \"going to search_for_third\"\n      search_for_third $@ $1 $2\n    fi\n  }\n\
    \  # echo \"calling search_for_third\"\n  # echo $1\n  search_for_third(){\n \
    \   if [ $5 -gt $# ]; then\n      echo false\n    else\n      # echo \"calling\
    \ is_zero\"\n      # echo $1\n      # echo $2\n      # echo $3\n      if [ $(is_zero\
    \ $1 $2 $3) == true ]; then\n        echo true\n      else\n        # echo \"\
    going to search_for_third\"\n        search_for_third $@ $1 $2 $3\n      fi\n\
    \    fi\n  }\n  # echo \"calling search_for_triple\"\n  search_for_triple $@ $1\
    \ 0", "\tinput_list=\"$1\"\n\tnum_elements=$(echo \"$1\" | wc -w)\n\tif [ $num_elements\
    \ -lt 3 ]; then\n\t\techo \"false\"\n\t\treturn 0\n\tfi\n\tfor element in $input_list;\
    \ do\n\t\trest_of_input_list=\"$(echo \"$input_list\" | sed -e \"s/$element//\"\
    )\"\n\t\tif $(distinct_pairs_sum_to_negative \"$element\" \"$rest_of_input_list\"\
    ); then\n\t\t\techo \"true\"\n\t\t\treturn 0\n\t\tfi\n\tdone\n\techo \"false\"",
  "    # Write your solution here\n    if [[ ${#} -eq 0 ]]; then\n        return 1\n\
    \    fi\n    declare -a arr1=(\"${@}\")\n    for ((i=0; i<${#arr1[@]}; i++));\
    \ do\n        for ((j=i+1; j<${#arr1[@]}; j++)); do\n            for ((k=j+1;\
    \ k<${#arr1[@]}; k++)); do\n                if [[ $((${arr1[$i]} + ${arr1[$j]}\
    \ + ${arr1[$k]})) -eq 0 ]]; then\n                    echo \"true\"\n        \
    \            return 0\n                fi\n            done\n        done\n  \
    \  done\n    echo \"false\"\n    return 0", "  [ $# -lt 3 ] && echo \"false\"\
    \ && return\n  for i in $@; do\n    for j in $@; do\n      for k in $@; do\n \
    \       if [ \"$i\" != \"$j\" ] && [ \"$j\" != \"$k\" ] && [ \"$i\" != \"$k\"\
    \ ]; then\n          if [ \"$(($i + $j + $k))\" -eq 0 ]; then\n            echo\
    \ \"true\"\n            return\n          fi\n        fi\n      done\n    done\n\
    \  done\n  echo \"false\"", "  local list=(${1// / })\n\n  # your code goes here\n\
    \n  echo \"false\"", "    local list=($1)\n    (( ${#list[@]} < 3 )) && echo \"\
    false\" && return\n\n    local i\n    local j\n    local k\n    for (( i=0; i<${#list[@]}-2;\
    \ i++ )); do\n        for (( j=i+1; j<${#list[@]}-1; j++ )); do\n            for\
    \ (( k=j+1; k<${#list[@]}; k++ )); do\n                if [[ $((${list[i]} + ${list[j]}\
    \ + ${list[k]})) -eq 0 ]]; then\n                    echo \"true\"\n         \
    \           return\n                fi\n            done\n        done\n    done\n\
    \    echo \"false\"", "\tfor i in $1; do\n\t\tfor j in $1; do\n\t\t\tfor k in\
    \ $1; do\n\t\t\t\tif [ $i -ne $j ] && [ $j -ne $k ] && [ $i -ne $k ] && [ $((i+j+k))\
    \ -eq 0 ]; then\n\t\t\t\t\techo \"true\"\n\t\t\t\t\treturn 0\n\t\t\t\tfi\n\t\t\
    \tdone\n\t\tdone\n\tdone\n\techo \"false\"", "  local numbers=(${1})\n  local\
    \ number\n  local other_numbers=(${1})\n  local other_number\n  local others_numbers\n\
    \  local other_other_number\n  for number in ${numbers[@]}; do\n    for other_number\
    \ in ${other_numbers[@]}; do\n      others_numbers=(\"${other_numbers[@]/$other_number}\"\
    )\n      for other_other_number in ${others_numbers[@]}; do\n        if [ \"$(($number\
    \ + $other_number + $other_other_number))\" -eq 0 ]; then\n          echo \"true\"\
    \n          return\n        fi\n      done\n    done\n  done\n  echo \"false\"",
  "    # your code here\n    # input: a space-separated list of integers\n    # output:\
    \ \"true\" or \"false\"\n\n    array=($1)\n\n    for ((i=0; i<${#array[@]}; i++))\n\
    \    do\n        for ((j=i+1; j<${#array[@]}; j++))\n        do\n            for\
    \ ((k=j+1; k<${#array[@]}; k++))\n            do\n                if [[ $((${array[i]}\
    \ + ${array[j]} + ${array[k]})) -eq 0 ]]\n                then\n             \
    \       echo \"true\"\n                    return\n                fi\n      \
    \      done\n        done\n    done\n\n    echo \"false\"\n    return", "    local\
    \ list=\"$1\"\n    local numbers=($list)\n    local i j k x y z\n    local length=${#numbers[@]}\n\
    \    local sum\n\n    # This loop iterates through each possible triplet of numbers.\n\
    \    # it stops when i=length-2 and j=length-1\n    for ((i=0; i<length-2; i++));\
    \ do\n        x=${numbers[i]}\n        for ((j=i+1; j<length-1; j++)); do\n  \
    \          y=${numbers[j]}\n            for ((k=j+1; k<length; k++)); do\n   \
    \             z=${numbers[k]}\n                sum=$((x+y+z))\n              \
    \  # For debugging:\n                # echo -e \"${numbers[@]}\\nx=$x y=$y z=$z\
    \ sum=$sum\"\n                if [[ $sum -eq 0 ]]; then\n                    echo\
    \ \"true\"\n                    return\n                fi\n            done\n\
    \        done\n    done\n    echo \"false\"", "    array=($1)\n    for ((i=0;\
    \ i<${#array[@]}; i++))\n    do\n        for ((j=i+1; j<${#array[@]}; j++))\n\
    \        do\n            for ((k=j+1; k<${#array[@]}; k++))\n            do\n\
    \                if [ $((${array[$i]} + ${array[$j]} + ${array[$k]})) == 0 ]\n\
    \                then\n                    echo \"true\"\n                   \
    \ return 0\n                fi\n            done\n        done\n    done\n   \
    \ echo \"false\"", "  # 3 distinct sums\n  sums=`\n    for i in $1; do\n     \
    \ for j in $1; do\n        for k in $1; do\n          if [[ $i != $j && $i !=\
    \ $k && $j != $k ]]; then\n            sum=$(($i + $j + $k))\n            if [[\
    \ $sum -eq 0 ]]; then\n              echo true\n              break\n        \
    \    fi\n          fi\n        done\n      done\n    done\n  `\n  if [[ $sums\
    \ == \"true\" ]]; then\n    echo true\n  else\n    echo false\n  fi", '    #TODO:
    Write your code here', '  # TODO: implement me', "  if [[ \"$#\" -lt 3 ]]; then\n\
    \    echo false\n    return\n  fi\n  if [[ $(sum_of_two_equals_neg_of_third \"\
    $@\") ]]; then\n    echo true\n  else\n    triples_sum_to_zero \"${@:2}\"\n  fi",
  "  local list=($1)\n  local len=${#list[@]}\n  local a b c\n  for ((a=0; a<len;\
    \ a++)); do\n    for ((b=a+1; b<len; b++)); do\n      for ((c=b+1; c<len; c++));\
    \ do\n        local abc=${list[a]}+${list[b]}+${list[c]}\n        if [[ $abc -eq\
    \ 0 ]]; then\n          echo \"true\"\n          return\n        fi\n      done\n\
    \    done\n  done\n  echo \"false\"", "  for (( i=0; i<\"${#1}\"; i++ )); do\n\
    \    for (( j=i+1; j<\"${#1}\"; j++ )); do\n      for (( k=j+1; k<\"${#1}\"; k++\
    \ )); do\n        if [ \"$((${1:i:1} + ${1:j:1} + ${1:k:1}))\" -eq 0 ]; then\n\
    \          echo \"true\"\n          return\n        fi\n      done\n    done\n\
    \  done\n  echo \"false\"", "    # TODO: implement the script here\n    if [[\
    \ $# -lt 3 ]]; then\n        echo \"false\"\n        return\n    fi\n    for item\
    \ in $@; do\n        sum=0\n        for i in $@; do\n            if [[ $item -ne\
    \ $i ]]; then\n                sum=$(( $sum + $i ))\n            fi\n        done\n\
    \        if [[ $sum -eq $item ]]; then\n            echo \"true\"\n          \
    \  return\n        fi\n    done\n    echo \"false\"", "  for i in $1; do\n   \
    \ for j in $1; do\n      for k in $1; do\n        if [[ $i != $j && $j != $k &&\
    \ $i != $k && $i + $j + $k == 0 ]]; then\n          echo \"true\"\n          return\n\
    \        fi\n      done\n    done\n  done\n  echo \"false\"", "    for x in $1;\
    \ do\n        for y in $1; do\n            for z in $1; do\n                if\
    \ [ \"$x\" != \"$y\" ] && [ \"$y\" != \"$z\" ] && [ \"$x\" != \"$z\" ]; then\n\
    \                    if [ \"$(( $x + $y + $z ))\" == \"0\" ]; then\n         \
    \               echo \"true\"\n                        return\n              \
    \      fi\n                fi\n            done\n        done\n    done\n    echo\
    \ \"false\"", "    # check for the special case of only one input\n    if [ \"\
    $#\" -eq 1 ]; then\n        echo \"false\"\n        return\n    fi\n\n    # set\
    \ x, y, and z to the arguments given\n    x=$1\n    y=$2\n    z=$3\n\n    # loop\
    \ through the arguments and check to see if any triples sum to zero\n    for i\
    \ in \"$@\"; do\n        # if the sum of x, y, and z is zero\n        if [ $((\
    \ x + y + z )) -eq 0 ]; then\n            # then we have found a triple that sums\
    \ to zero\n            echo \"true\"\n            return\n        fi\n\n     \
    \   # shift the x, y, and z arguments by one\n        x=$y\n        y=$z\n   \
    \     z=$4\n        shift\n    done\n\n    # if we make it to here, we didn't\
    \ find any triples\n    echo \"false\"", "  # Your code here\n  return", "   \
    \ local -a list=($1)\n    local i=0\n    local j=0\n    local k=0\n    local len=${#list[@]}\n\
    \    local -a a\n    local -a b\n    local -a c\n    for ((i=0; i<len; i++));\
    \ do\n        for ((j=i+1; j<len; j++)); do\n            for ((k=j+1; k<len; k++));\
    \ do\n                a=${list[i]}\n                b=${list[j]}\n           \
    \     c=${list[k]}\n                if [[ \"$a\" -eq \"$b\" || \"$b\" -eq \"$c\"\
    \ || \"$a\" -eq \"$c\" ]]; then\n                    echo \"false\"\n        \
    \            return\n                fi\n                if [[ \"$a\" + \"$b\"\
    \ + \"$c\" -eq 0 ]]; then\n                    echo \"true\"\n               \
    \     return\n                fi\n            done\n        done\n    done\n \
    \   echo \"false\""]
stop_tokens:
- "\n}"
