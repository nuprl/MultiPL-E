name: HumanEval_31_is_prime
language: sh
prompt: "#!/bin/bash\n# Return true if a given number is prime, and false otherwise.\n\
  # >>> $(is_prime \"6\")\n# \"false\"\n# >>> $(is_prime \"101\")\n# \"true\"\n# >>>\
  \ $(is_prime \"11\")\n# \"true\"\n# >>> $(is_prime \"13441\")\n# \"true\"\n# >>>\
  \ $(is_prime \"61\")\n# \"true\"\n# >>> $(is_prime \"4\")\n# \"false\"\n# >>> $(is_prime\
  \ \"1\")\n# \"false\"\n#\n# $1 is an integer\nis_prime() {\n"
tests: "}\n\ncandidate() {\n    is_prime \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
  \ $(candidate \"6\") = \"false\" ]]\n    [[ $(candidate \"101\") = \"true\" ]]\n\
  \    [[ $(candidate \"11\") = \"true\" ]]\n    [[ $(candidate \"13441\") = \"true\"\
  \ ]]\n    [[ $(candidate \"61\") = \"true\" ]]\n    [[ $(candidate \"4\") = \"false\"\
  \ ]]\n    [[ $(candidate \"1\") = \"false\" ]]\n    [[ $(candidate \"5\") = \"true\"\
  \ ]]\n    [[ $(candidate \"11\") = \"true\" ]]\n    [[ $(candidate \"17\") = \"\
  true\" ]]\n    [[ $(candidate \"85\") = \"false\" ]]\n    [[ $(candidate \"77\"\
  ) = \"false\" ]]\n    [[ $(candidate \"255379\") = \"false\" ]]\n}\n\nrun_test"
completions: ["  [ \"$1\" -eq \"1\" ] && return 1\n  local prime=\"2\"\n  local sqrt=$(sqrt\
    \ \"$1\")\n  while [ \"$prime\" -le \"$sqrt\" ]; do\n    [ \"$(($1 % $prime))\"\
    \ -eq \"0\" ] && return 1\n    prime=$(($prime + 1))\n  done\n  return 0", " \
    \   if [ \"$1\" -le \"1\" ]; then\n        echo \"false\"\n    else\n        local\
    \ i=2\n        while [ \"$(($i * $i))\" -le \"$1\" ]; do\n            if [ \"\
    $(($1 % $i))\" -eq \"0\" ]; then\n                echo \"false\"\n           \
    \     return\n            fi\n            i=$(($i + 1))\n        done\n      \
    \  echo \"true\"\n    fi", "  declare -i number=$1\n  declare -i i\n  declare\
    \ -i sqrt_number\n\n  if [[ $number -le 1 ]]; then\n    echo \"false\"\n    return\
    \ 0\n  fi\n\n  # Check if the number is a multiple of 2\n  if [[ $(( number %\
    \ 2 )) -eq 0 ]]; then\n    echo \"false\"\n    return 0\n  fi\n\n  # Only check\
    \ odd numbers up to the square root of the number\n  sqrt_number=$(sqrt $number)\n\
    \  for (( i=3; i<=sqrt_number; i+=2 )); do\n    if [[ $(( number % i )) -eq 0\
    \ ]]; then\n      echo \"false\"\n      return 0\n    fi\n  done\n\n  echo \"\
    true\"", "    if [[ $1 -eq 2 ]]; then\n        echo true\n        return\n   \
    \ fi\n    if [[ $1 -le 1 ]]; then\n        echo false\n        return\n    fi\n\
    \    if [[ $(($1 % 2)) -eq 0 ]]; then\n        echo false\n        return\n  \
    \  fi\n    for i in $(seq 3 2 $(($1 - 1))); do\n        if [[ $(($1 % $i)) -eq\
    \ 0 ]]; then\n            echo false\n            return\n        fi\n    done\n\
    \    echo true", "    local number=\"$1\"\n    local i=\"2\"\n    local max=\"\
    $(( $number / 2 ))\"\n    while [[ $i -le $max ]]; do\n        if [[ $(( $number\
    \ % $i )) -eq 0 ]]; then\n            echo \"false\"\n            return\n   \
    \     fi\n        i=$(( $i + 1 ))\n    done\n    echo \"true\"", " \n  if [[ $1\
    \ =~ ^[0-9]+$ ]]; then\n    #loop through the numbers 2 through argument / 2\n\
    \    for (( i=2; i<=$(( $1 / 2 )); i++ )); do\n      #check if $1 is evenly divisible\n\
    \      if [[ $(( $1 % $i )) -eq 0 ]]; then\n        echo \"false\"\n        return\
    \ 1\n      fi\n    done\n    echo \"true\"\n    return 0\n  else\n    #argument\
    \ is not an integer\n    echo \"false\"\n    return 1\n  fi", "    local num=$1\n\
    \    local i=0\n    if [[ $num -le 1 ]]; then\n        echo \"false\"\n      \
    \  return 0\n    fi\n    for ((i=2; i < $num; i++)); do\n        if [[ $((num\
    \ % i)) -eq 0 ]]; then\n            echo \"false\"\n            return 0\n   \
    \     fi\n    done\n    echo \"true\"", "    local n=$1\n    local max=$((n/2))\n\
    \    for ((i=2; i<=max; i++)); do\n        if [[ $((n%i)) -eq 0 ]]; then\n   \
    \         echo \"false\"\n            return\n        fi\n    done\n    echo \"\
    true\"", "  number=\"$1\"\n  if [[ \"$number\" -eq 2 ]]; then\n    echo \"true\"\
    \n  elif [[ \"$number\" -le 1 ]]; then\n    echo \"false\"\n  else\n    if [[\
    \ $(($number % 2)) -eq 0 ]]; then\n      echo \"false\"\n    else\n      sqrt=$(bc\
    \ <<< \"sqrt($number)\")\n      is_prime_helper \"$number\" \"3\" \"$sqrt\"\n\
    \    fi\n  fi", "    local result=\"\"\n    local number=$1\n    local integer_reg='^[0-9]+$'\n\
    \    if ! [[ $number =~ $integer_reg ]] ; then\n        echo \"false\"\n     \
    \   return\n    fi\n    local divisor=2\n    local root_of_number=$(python -c\
    \ \"import math; print(math.sqrt($number))\")\n    while [ $divisor -le $root_of_number\
    \ ]\n    do\n        if [[ $(($number % $divisor)) -eq 0 ]] ; then\n         \
    \   result=\"false\"\n            break\n        fi\n        ((divisor++))\n \
    \   done\n    if [[ -z $result ]] ; then\n        result=\"true\"\n    fi\n  \
    \  echo $result", "    if (( $1 <= 1 )); then\n        echo \"false\"\n    else\n\
    \        for (( i=2; i<$1; i++ )); do\n            if (( $1 % i == 0 )); then\n\
    \                echo \"false\"\n                return\n            fi\n    \
    \    done\n        echo \"true\"\n    fi", '  [[ $1 -gt 1 ]] && echo "true" ||
    echo "false"', "  local i\n  for ((i=2; i<$1; i++)); do\n    if [[ $(( $1 % $i\
    \ )) -eq 0 ]]; then\n      echo \"false\"\n      return\n    fi\n  done\n  echo\
    \ \"true\"", "  local x=$1\n  if [[ $x -lt 2 ]]; then\n    echo \"false\"\n  else\n\
    \    for i in $(seq 2 $((x - 1))); do\n      if [[ $((x % i)) -eq 0 ]]; then\n\
    \        echo \"false\"\n        return\n      fi\n    done\n    echo \"true\"\
    \n  fi", "    local input=$1\n\n    [[ $input -eq 1 ]] && echo \"false\" && return\n\
    \    [[ $input -eq 2 ]] && echo \"true\" && return\n\n    for (( i=2; i<=$input/2;\
    \ i++ ))\n    do\n        if [[ $(( $input % $i )) -eq 0 ]]\n        then\n  \
    \          echo \"false\"\n            return\n        fi\n    done\n\n    echo\
    \ \"true\"", "  if [[ $1 -eq 2 ]]; then\n    echo \"true\"\n  elif [[ $1 -eq 1\
    \ ]]; then\n    echo \"false\"\n  elif [[ $1 -gt 2 ]]; then\n    primes=$(seq\
    \ 2 $(expr $1 - 1))\n    num_primes=$(echo $primes | xargs -n 1 | grep -c $1)\n\
    \    if [[ $num_primes -eq 0 ]]; then\n      echo \"true\"\n    else\n      echo\
    \ \"false\"\n    fi\n  fi", "    re='^[0-9]+$'\n    if ! [[ $1 =~ $re ]] ; then\n\
    \        echo \"error: Not a number\" >&2; return 1\n    fi\n    local n=$1\n\
    \    if [ \"$n\" -le 1 ]; then\n        echo \"false\"\n        return 0\n   \
    \ fi\n    if [ \"$n\" -le 3 ]; then\n        echo \"true\"\n        return 0\n\
    \    fi\n    if [ \"$((n % 2))\" -eq 0 ] || [ \"$((n % 3))\" -eq 0 ]; then\n \
    \       echo \"false\"\n        return 0\n    fi\n    local i=5\n    while [ \"\
    $((i * i))\" -le \"$n\" ]; do\n        if [ \"$((n % i))\" -eq 0 ] || [ \"$((n\
    \ % (i + 2)))\" -eq 0 ]; then\n            echo \"false\"\n            return\
    \ 0\n        fi\n        i=$((i + 6))\n    done\n    echo \"true\"", "  local\
    \ -u number=$1\n  if [[ \"$number\" =~ [^0-9] ]]; then\n    echo \"false\"\n \
    \   return 0\n  fi\n  local -i num_divisors=0\n  local -i divisor=0\n  while ((\
    \ ++divisor <= number )); do\n    if (( number % divisor == 0 )); then\n     \
    \ (( ++num_divisors ))\n    fi\n  done\n  if (( num_divisors == 2 )); then\n \
    \   echo \"true\"\n  else\n    echo \"false\"\n  fi", "    n=$1\n    if [[ \"\
    $n\" -eq 2 ]]; then\n        echo \"true\"\n    elif [[ \"$n\" -le 1 ]]; then\n\
    \        echo \"false\"\n    else\n        prime=\"true\"\n        for (( i=2;\
    \ i<$n; i++ )); do\n            if [[ $(( $n % $i )) -eq 0 ]]; then\n        \
    \        prime=\"false\"\n                break\n            fi\n        done\n\
    \        echo \"$prime\"\n    fi", "    local is_prime=$(prime \"$1\")\n    if\
    \ [[ $is_prime == \"\" ]]; then\n        echo \"false\"\n    else\n        echo\
    \ \"true\"\n    fi"]
stop_tokens:
- "\n}"
