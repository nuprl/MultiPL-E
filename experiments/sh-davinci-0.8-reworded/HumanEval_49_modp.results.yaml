language: sh
name: HumanEval_49_modp
results:
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \  LC_NUMERIC=C # Set radix to \".\"\n  printf \"%'d\\n\" \"$((2**$1 % $2))\"\n\
    }\n\ncandidate() {\n    modp \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n \
    \   [[ $(candidate \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\"\
    ) = \"8\" ]]\n    [[ $(candidate \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate\
    \ \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\n\
    run_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024853
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    local n=\"$1\"\n    local p=\"$2\"\n    if [ \"$n\" == \"0\" ]; then\n  \
    \      echo \"1\"\n        return\n    fi\n    if [ \"$n\" == \"1\" ]; then\n\
    \        echo \"$p\"\n        return\n    fi\n    if [ \"$n\" == \"2\" ]; then\n\
    \        echo \"$(mul \"$p\" \"$p\" \"$p\")\"\n        return\n    fi\n    if\
    \ [ \"$n\" == \"3\" ]; then\n        echo \"$(mul \"$(mul \"$p\" \"$p\" \"$p\"\
    )\" \"$p\" \"$p\")\"\n        return\n    fi\n    local r=\"$(modp \"$(bin \"\
    $n\" \"2\")\" \"$p\")\"\n    local b=\"$(modp \"$(bin \"$n\" \"1\")\" \"$p\")\"\
    \n    local k=\"$(bin \"$n\" \"1\")\"\n    if [ \"$k\" == \"1\" ]; then\n    \
    \    echo \"$(mul \"$r\" \"$r\" \"$p\")\"\n        return\n    fi\n    echo \"\
    $(mul \"$(mul \"$r\" \"$r\" \"$p\")\" \"$b\" \"$p\")\"\n}\n\ncandidate() {\n \
    \   modp \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3\" \"5\") =\
    \ \"3\" ]]\n    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n    [[ $(candidate\
    \ \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\") = \"8\" ]]\n   \
    \ [[ $(candidate \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate \"30\" \"5\"\
    ) = \"4\" ]]\n    [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmpofio38xg.sh: line 32: mul: command not found

    /tmp/tmpofio38xg.sh: line 32: mul: command not found

    '
  stdout: ''
  timestamp: 1660024853
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    # XXX: I think it's ok to use bc because this is only run when you want\n\
    \    #      the modp of a given prime.\n    echo $(( $1 % $2 )) | bc\n}\n\ncandidate()\
    \ {\n    modp \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3\" \"5\"\
    ) = \"3\" ]]\n    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n    [[ $(candidate\
    \ \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\") = \"8\" ]]\n   \
    \ [[ $(candidate \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate \"30\" \"5\"\
    ) = \"4\" ]]\n    [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024853
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    local -u a=$1\n    local -u p=$2\n    # echo \"modp: $a $p\"\n    if ((a==0));\
    \ then\n        # 0^n % p == 0\n        echo \"1\"\n    elif ((a==1)); then\n\
    \        # 1^n % p == 1\n        echo \"1\"\n    elif ((a<p)); then\n        #\
    \ 2^n % p == (2^n % (p-1)) + 1\n        local -u one=\"1\"\n        local -u a_=$(bc\
    \ -l <<< \"$a % $((p-1))\")\n        local -u t=$(modp \"$a_\" \"$((p-1))\")\n\
    \        bc -l <<< \"$t % $p + $one\"\n    else\n        local -u a_=$(bc -l <<<\
    \ \"$a % $p\")\n        modp \"$a_\" \"$p\"\n    fi\n}\n\ncandidate() {\n    modp\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n\
    \    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n    [[ $(candidate \"0\" \"\
    101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate\
    \ \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate \"30\" \"5\") = \"4\" ]]\n \
    \   [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024853
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    local n=\"$1\"\n    local p=\"$2\"\n    local tmp=$((n % p))\n    local res=1\n\
    \    while [ $tmp -gt 0 ]; do\n        res=$(((res * 2) % p))\n        tmp=$((tmp\
    \ - 1))\n    done\n    echo $res\n}\n\ncandidate() {\n    modp \"$@\"\n}\n\nset\
    \ -e\nrun_test() {\n    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate\
    \ \"1101\" \"101\") = \"2\" ]]\n    [[ $(candidate \"0\" \"101\") = \"1\" ]]\n\
    \    [[ $(candidate \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate \"100\" \"101\"\
    ) = \"1\" ]]\n    [[ $(candidate \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate\
    \ \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024853
- exit_code: 0
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    # All possible residues of 2^k modulo p, k=0..n\n    modp_A=$(bc <<< \"2^$1\
    \ % $2\")\n    # n modulo (p-1)\n    modp_N=$(bc <<< \"$1 % ($2-1)\")\n    # New\
    \ residue 2^(n modulo (p-1)) modulo p\n    modp_R=$(bc <<< \"2^$modp_N % $2\"\
    )\n    echo $modp_R\n}\n\ncandidate() {\n    modp \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"1101\" \"\
    101\") = \"2\" ]]\n    [[ $(candidate \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate\
    \ \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate \"100\" \"101\") = \"1\" ]]\n \
    \   [[ $(candidate \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate \"31\" \"5\")\
    \ = \"3\" ]]\n}\n\nrun_test"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660024853
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \  local n=$1\n  local p=$2\n  local b=1\n  local a=$n\n  local s=\"$(( ${#n}\
    \ - 1 ))\"\n  while [[ $s -ge 0 ]]; do\n    b=$(( (b * b) % p ))\n    if [[ ${n:$s:1}\
    \ -eq 1 ]]; then\n      b=$(( (b * a) % p ))\n    fi\n    s=$(( s - 1 ))\n  done\n\
    \  echo $b\n}\n\ncandidate() {\n    modp \"$@\"\n}\n\nset -e\nrun_test() {\n \
    \   [[ $(candidate \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"1101\" \"101\"\
    ) = \"2\" ]]\n    [[ $(candidate \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate\
    \ \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate \"100\" \"101\") = \"1\" ]]\n \
    \   [[ $(candidate \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate \"31\" \"5\")\
    \ = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024853
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    local MODP_RESULT=$1\n    if [ -z \"$MODP_RESULT\" ]; then\n        MODP_RESULT=1\n\
    \    fi\n    local MODP_P=$2\n    if [ -z \"$MODP_P\" ]; then\n        MODP_P=2\n\
    \    fi\n    local MODP_T\n    while [ \"$MODP_RESULT\" -ge \"$MODP_P\" ]; do\n\
    \        MODP_T=$(($MODP_RESULT % $MODP_P))\n        MODP_RESULT=$(($MODP_RESULT\
    \ - $MODP_T))\n        MODP_RESULT=$(($MODP_RESULT / $MODP_P))\n        MODP_RESULT=$(($MODP_RESULT\
    \ + $MODP_T))\n    done\n    echo $MODP_RESULT\n}\n\ncandidate() {\n    modp \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n\
    \    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n    [[ $(candidate \"0\" \"\
    101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate\
    \ \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate \"30\" \"5\") = \"4\" ]]\n \
    \   [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024853
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    printf \"%d\" \"$(printf \"%d\\n\" \"$1\" | bc -l | ./modp \"$2\")\"\n}\n\
    \ncandidate() {\n    modp \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n \
    \   [[ $(candidate \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\"\
    ) = \"8\" ]]\n    [[ $(candidate \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate\
    \ \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\n\
    run_test"
  status: Exception
  stderr: '/tmp/tmp49q8qy27.sh: line 17: ./modp: No such file or directory

    '
  stdout: ''
  timestamp: 1660024853
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \t# print \"2^\"$1 \"mod\" $2\" =\"\n\techo \"$1\" | awk '{print 2^$1%'$2'}'\n\
    }\n\ncandidate() {\n    modp \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n \
    \   [[ $(candidate \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\"\
    ) = \"8\" ]]\n    [[ $(candidate \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate\
    \ \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\n\
    run_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024853
- exit_code: 2
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \  if [ -z \"$2\" ]; then\n    echo \"At least 2 arguments are needed!\" >&2\n\
    \    exit 1\n  fi\n  if [ \"$2\" -lt 2 ]; then\n    echo \"Base must be greater\
    \ than 1!\" >&2\n    exit 1\n  fi\n  if [ \"$(echo \"$1 < 0\" | bc)\" -eq 1 ];\
    \ then\n    echo \"Number must be greater than or equal to 0!\" >&2\n    exit\
    \ 1\n  fi\n  if [ \"$(echo \"$2 < 0\" | bc)\" -eq 1 ]; then\n    echo \"Modulo\
    \ must be greater than or equal to 0!\" >&2\n    exit 1\n  fi\n  # Uncomment the\
    \ following line if you want to enforce\n  # that number be less than modulo (the\
    \ inversion will be slower).\n  # if [ \"$(echo \"$1 >= $2\" | bc)\" -eq 1 ];\
    \ then\n  #   echo \"Number must be less than modulo!\" >&2\n  #   exit 1\n  #\
    \ fi\n  if [ \"$1\" -eq 0 ]; then\n    echo 1\n    return\n  fi\n  if [ \"$1\"\
    \ -eq 1 ]; then\n    echo \"$1\"\n    return\n  fi\n  if [ \"$2\" -eq 1 ]; then\n\
    \    echo 0\n    return\n  fi\n  if [ \"$2\" -eq 2 ]; then\n    echo \"$(echo\
    \ \"$1 % 2\" | bc)\"\n    return\n  fi\n  # Write $1 in base $2\n  local total=\"\
    \"\n  while [ \"$1\" -ne 0 ]; do\n    local remain=\"$(echo \"$1 % $2\" | bc)\"\
    \n    total=\"$remain$total\"\n    local tmp=\"$(echo \"$1 / $2\" | bc)\"\n  \
    \  local tmp2=\"$(echo \"$tmp % 2\" | bc)\"\n    if [ \"$tmp2\" -eq 1 ]; then\n\
    \      tmp=\"$(echo \"$tmp + 1\" | bc)\"\n    fi\n    local num=\"$(echo \"$tmp\
    \ / 2\" | bc)\"\n    local tmp3=\"$(echo \"$num % 2\" | bc)\"\n    if [ \"$tmp3\"\
    \ -eq 1 ]; then\n      num=\"$(echo \"$num + 1\" |\n}\n\ncandidate() {\n    modp\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n\
    \    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n    [[ $(candidate \"0\" \"\
    101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate\
    \ \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate \"30\" \"5\") = \"4\" ]]\n \
    \   [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmps6zleblh.sh: line 68: unexpected EOF while looking for matching
    `)''

    /tmp/tmps6zleblh.sh: line 87: syntax error: unexpected end of file

    '
  stdout: ''
  timestamp: 1660024853
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    (echo \"scale=$((${#1}*8)); 2^$1 % $2\" | bc)\n}\n\ncandidate() {\n    modp\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n\
    \    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n    [[ $(candidate \"0\" \"\
    101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate\
    \ \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate \"30\" \"5\") = \"4\" ]]\n \
    \   [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024853
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \  local n=\"$1\"\n  local p=\"$2\"\n  local __modp=\"$(echo \"ibase=2;obase=10;ibase=2;$n^2^\"\
    \ | bc | tr -d '\\n')\"\n  local __modp=$(($__modp % $p))\n  echo \"$__modp\"\n\
    }\n\ncandidate() {\n    modp \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n \
    \   [[ $(candidate \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\"\
    ) = \"8\" ]]\n    [[ $(candidate \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate\
    \ \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\n\
    run_test"
  status: SyntaxError
  stderr: '(standard_in) 2: syntax error

    /tmp/tmppslszn15.sh: line 20: % 5: syntax error: operand expected (error token
    is "% 5")

    '
  stdout: ''
  timestamp: 1660024853
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \  # We want to make sure we use bc for these operations, so we call it\n  # separately\
    \ rather than using $().\n  if [ \"$1\" -eq \"0\" ]; then\n    echo \"1\"\n  else\n\
    \    local n=$(bc -l <<< \"( $1 * 2 ) % $2\")\n    echo $n\n  fi\n}\n\ncandidate()\
    \ {\n    modp \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3\" \"5\"\
    ) = \"3\" ]]\n    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n    [[ $(candidate\
    \ \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\") = \"8\" ]]\n   \
    \ [[ $(candidate \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate \"30\" \"5\"\
    ) = \"4\" ]]\n    [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024853
- exit_code: 2
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \  local n=$1\n  local p=$2\n  local r=1\n  local c=0\n  local q=1\n  local d=$n\n\
    \  local s=\"\"\n  local len=${#d}\n  local i=0\n  local base=10\n  local b=$((base*base))\n\
    \  local bb=$((b*base))\n  local bbb=$((bb*base))\n  while [ $c -lt $len ]; do\n\
    \    case $((d/bbb)) in\n      0) s=\"000$s\" ;;\n      1) s=\"001$s\" ;;\n  \
    \    2) s=\"010$s\" ;;\n      3) s=\"011$s\" ;;\n      4) s=\"100$s\" ;;\n   \
    \   5) s=\"101$s\" ;;\n      6) s=\"110$s\" ;;\n      7) s=\"111$s\" ;;\n    esac\n\
    \    d=$((d%bbb))\n    bbb=$((bbb/base))\n    case $((d/bb)) in\n      0) s=\"\
    000$s\" ;;\n      1) s=\"001$s\" ;;\n      2) s=\"010$s\" ;;\n      3) s=\"011$s\"\
    \ ;;\n      4) s=\"100$s\" ;;\n      5) s=\"101$s\" ;;\n      6) s=\"110$s\" ;;\n\
    \      7) s=\"111$s\" ;;\n    esac\n    d=$((d%bb))\n    bb=$((bb/base))\n   \
    \ case $((d/b)) in\n      0) s=\"000$s\" ;;\n      1) s=\"001$s\" ;;\n      2)\
    \ s=\"010$s\" ;;\n      3) s=\"011$s\" ;;\n      4) s=\"100$s\" ;;\n      5) s=\"\
    101$s\" ;;\n      6) s=\"110$s\" ;;\n      7) s=\"111$s\" ;;\n    esac\n    d=$((d%b))\n\
    \    b=$((b/base))\n    case $((d/base)) in\n      0) s=\"000$s\" ;;\n      1)\
    \ s=\"001$s\" ;;\n      2) s=\"010$s\n}\n\ncandidate() {\n    modp \"$@\"\n}\n\
    \nset -e\nrun_test() {\n    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate\
    \ \"1101\" \"101\") = \"2\" ]]\n    [[ $(candidate \"0\" \"101\") = \"1\" ]]\n\
    \    [[ $(candidate \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate \"100\" \"101\"\
    ) = \"1\" ]]\n    [[ $(candidate \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate\
    \ \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp4wuxzai7.sh: line 85: unexpected EOF while looking for matching
    `"''

    /tmp/tmp4wuxzai7.sh: line 89: syntax error: unexpected end of file

    '
  stdout: ''
  timestamp: 1660024853
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \  if [ \"$1\" == \"0\" ]; then\n    echo \"1\"\n    return\n  fi\n  p=$2\n  n=$1\n\
    \  while [ ${#n} -gt ${#p} ]; do\n    k=$(echo \"$n\" | wc -c)\n    k=$(( k -\
    \ 1 ))\n    p=$(dc -e \"$p\"k\"$k\"p)\n    if [ $(echo \"$n>$p\" | bc) -eq 1 ];\
    \ then\n      n=$(echo \"$n-$p\" | bc)\n    fi\n  done\n  if [ $(echo \"$n>$p\"\
    \ | bc) -eq 1 ]; then\n    n=$(echo \"$n-$p\" | bc)\n  fi\n  echo \"$n\"\n}\n\n\
    candidate() {\n    modp \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n \
    \   [[ $(candidate \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\"\
    ) = \"8\" ]]\n    [[ $(candidate \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate\
    \ \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\n\
    run_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024856
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    if (( $1 == 0 )); then\n        echo \"1\"\n        return\n    fi\n    local\
    \ binary=\"$(to_binary \"$1\")\"\n    local p=\"$2\"\n    local result=\"1\"\n\
    \    local n=\"$((${#binary} - 1))\"\n    local i=\"0\"\n    while (( i <= n ));\
    \ do\n        if (( ${binary:$i:1} == 1 )); then\n            result=$(( (result\
    \ * result) % p ))\n            if (( i < n )); then\n                result=$((\
    \ (result * 2) % p ))\n            fi\n        else\n            result=$(( (result\
    \ * result) % p ))\n        fi\n        i=$((i + 1))\n    done\n    echo \"$result\"\
    \n}\n\ncandidate() {\n    modp \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n \
    \   [[ $(candidate \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\"\
    ) = \"8\" ]]\n    [[ $(candidate \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate\
    \ \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\n\
    run_test"
  status: Exception
  stderr: '/tmp/tmplzbm4562.sh: line 21: to_binary: command not found

    '
  stdout: ''
  timestamp: 1660024853
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    local p=\"$2\"\n    local n=\"$1\"\n    local x=\"$n\"\n    local y=1\n \
    \   local b=1\n    local shift=\"\"\n    if [[ $n == 0 ]]; then\n        echo\
    \ 1\n        return\n    fi\n    while [[ $b != 0 ]]; do\n        if [[ $(( $b\
    \ & 1 )) == 1 ]]; then\n            y=$(( (($y * $x) % $p) ))\n        fi\n  \
    \      x=$(( (($x * $x) % $p) ))\n        b=$(( $b >> 1 ))\n    done\n    echo\
    \ $y\n}\n\ncandidate() {\n    modp \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n \
    \   [[ $(candidate \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\"\
    ) = \"8\" ]]\n    [[ $(candidate \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate\
    \ \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\n\
    run_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024853
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    [[ \"${1}\" == \"0\" ]] && { echo \"1\"; return; }\n    printf \"%d\" \"\
    2\" | bc -l \\\n        | bc -l | tr -d '\\n' | gawk -v \"p=${2}\" '{printf(\"\
    %d\", $0 % p)}'\n}\n\ncandidate() {\n    modp \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"1101\" \"\
    101\") = \"2\" ]]\n    [[ $(candidate \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate\
    \ \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate \"100\" \"101\") = \"1\" ]]\n \
    \   [[ $(candidate \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate \"31\" \"5\")\
    \ = \"3\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '(standard_in) 1: syntax error

    '
  stdout: ''
  timestamp: 1660024853
- exit_code: -1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    local y=\"1\"\n    while [ \"$1\" != \"0\" ]; do\n        local bit=\"$(bitchop\
    \ \"$1\")\"\n        if [ \"$bit\" = \"1\" ]; then\n            y=\"$(modmulti\
    \ \"$y\" \"2\" \"$2\")\"\n        fi\n        local x=\"$(modmulti \"2\" \"2\"\
    \ \"$2\")\"\n        shift\n    done\n    echo \"$y\"\n}\n\ncandidate() {\n  \
    \  modp \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3\" \"5\") = \"\
    3\" ]]\n    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n    [[ $(candidate \"\
    0\" \"101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate\
    \ \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate \"30\" \"5\") = \"4\" ]]\n \
    \   [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: Timeout
  stderr: <_io.TextIOWrapper name=37 encoding='utf-8'>
  stdout: <_io.TextIOWrapper name=9 encoding='utf-8'>
  timestamp: 1660024858
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    local _n=\"$1\"\n    local _p=\"$2\"\n    local _r=\"1\"\n    local _nbits=\"\
    $(echo \"$_n\" | wc -c)\"\n    for ((i=1; i<_nbits; i++)); do\n        _r=$(($_r\
    \ * $_r % $_p))\n    done\n    # Now _r == 2^(nbits-1) mod _p\n    _r=$(($_r *\
    \ _r % $_p))\n    _r=$(($_r * $_n % $_p))\n    echo \"$_r\"\n}\n\ncandidate()\
    \ {\n    modp \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3\" \"5\"\
    ) = \"3\" ]]\n    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n    [[ $(candidate\
    \ \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\") = \"8\" ]]\n   \
    \ [[ $(candidate \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate \"30\" \"5\"\
    ) = \"4\" ]]\n    [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024853
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \  local A=$1\n  local P=$2\n  local MODP\n  if [ $P -le 256 ]; then\n    MODP=$(echo\
    \ \"obase=16; $A % $P\" | bc)\n  else\n    MODP=$(echo \"$A % $P\" | bc)\n  fi\n\
    \  echo $MODP\n}\n\ncandidate() {\n    modp \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"1101\" \"101\"\
    ) = \"2\" ]]\n    [[ $(candidate \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate\
    \ \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate \"100\" \"101\") = \"1\" ]]\n \
    \   [[ $(candidate \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate \"31\" \"5\")\
    \ = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024853
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \tlocal base=\"$1\"\n\tlocal p=\"$2\"\n\tlocal exp=$(echo \"a = 2^$base % $p;\
    \ if (a < 0) {print a + $p} else {print a}\" | octave | tail -n 1)\n\tprintf \"\
    $exp\"\n}\n\ncandidate() {\n    modp \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
    \ $(candidate \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"1101\" \"101\") =\
    \ \"2\" ]]\n    [[ $(candidate \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate \"\
    3\" \"11\") = \"8\" ]]\n    [[ $(candidate \"100\" \"101\") = \"1\" ]]\n    [[\
    \ $(candidate \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate \"31\" \"5\") = \"\
    3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmpw0qkqi3u.sh: line 19: octave: command not found

    '
  stdout: ''
  timestamp: 1660024853
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    local a=\"$1\"\n    local p=\"$2\"\n    local exp=$(($((${#a}-1))*4))\n \
    \   local res=1\n    for ((i=0; i<${#a}; i++)); do\n        res=$(($res*$res))\n\
    \        res=$(($res%$p))\n        char=${a:$i:1}\n        if [[ $char == \"1\"\
    \ ]]; then\n            res=$(($res*$(echo \"2^$exp\" | bc)))\n            res=$(($res%$p))\n\
    \        fi\n        exp=$(($exp-4))\n    done\n    printf %s \"$res\"\n}\n\n\
    candidate() {\n    modp \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n \
    \   [[ $(candidate \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\"\
    ) = \"8\" ]]\n    [[ $(candidate \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate\
    \ \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\n\
    run_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024853
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \tNUM=$1\n\tMOD=$2\n\tSUM=0\n\tfor i in $(seq 1 ${#NUM}); do\n\t\tDIGIT=${NUM:(-i):1}\n\
    \t\tif [ $DIGIT -eq 1 ]; then\n\t\t\tTMP=$(echo \"$SUM*2 + 1\" | bc)\n\t\t\tSUM=$(echo\
    \ \"$TMP % $MOD\" | bc)\n\t\telif [ $DIGIT -eq 0 ]; then\n\t\t\tTMP=$(echo \"\
    $SUM*2\" | bc)\n\t\t\tSUM=$(echo \"$TMP % $MOD\" | bc)\n\t\telse\n\t\t\t>&2 echo\
    \ \"Unexpected input\"\n\t\t\texit 1\n\t\tfi\n\tdone\n\techo $SUM\n}\n\ncandidate()\
    \ {\n    modp \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3\" \"5\"\
    ) = \"3\" ]]\n    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n    [[ $(candidate\
    \ \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\") = \"8\" ]]\n   \
    \ [[ $(candidate \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate \"30\" \"5\"\
    ) = \"4\" ]]\n    [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: 'Unexpected input

    '
  stdout: ''
  timestamp: 1660024853
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \  if [ \"$1\" == \"0\" ]; then\n    echo \"1\"\n    return\n  fi\n  modp \"$((\
    \ $1 % 2 ))\" \"$2\"\n  if [ \"$modp\" == \"1\" ]; then\n    modp=$(( ($modp *\
    \ $2) % $2 ))\n  fi\n  modp=$(( $modp ** 2 % $2 ))\n}\n\ncandidate() {\n    modp\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n\
    \    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n    [[ $(candidate \"0\" \"\
    101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate\
    \ \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate \"30\" \"5\") = \"4\" ]]\n \
    \   [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024854
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    local x=$1; shift\n    local p=$1; shift\n    local r=1\n    #echo \"* $x\
    \ $p $r\" >&2\n    while [ ${#x} -gt 0 ]; do\n        d=${x: -1}\n        if [\
    \ \"$d\" == \"1\" ]; then\n            r=$(($r * $r % $p))\n        fi\n     \
    \   x=${x:0:-1}\n        if [ ${#x} -gt 0 ]; then\n            r=$(($r * $r %\
    \ $p))\n        fi\n        #echo \"-- $x $p $r\" >&2\n    done\n    echo $r\n\
    }\n\ncandidate() {\n    modp \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n \
    \   [[ $(candidate \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\"\
    ) = \"8\" ]]\n    [[ $(candidate \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate\
    \ \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\n\
    run_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024853
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \  local x=\"$1\"\n  local p=\"$2\"\n  local result=\"1\"\n  local multiplier=\"\
    2\"\n  local b\n  for ((b=0; b<${#x}; b++)); do\n    local bit=\"${x:$b:1}\"\n\
    \    if [ \"$bit\" == \"1\" ]; then\n      result=$(imul \"$result\" \"$multiplier\"\
    \ \"$p\")\n    fi\n    multiplier=$(imul \"$multiplier\" \"$multiplier\" \"$p\"\
    )\n  done\n  echo \"$result\"\n}\n\ncandidate() {\n    modp \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"\
    1101\" \"101\") = \"2\" ]]\n    [[ $(candidate \"0\" \"101\") = \"1\" ]]\n   \
    \ [[ $(candidate \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate \"100\" \"101\"\
    ) = \"1\" ]]\n    [[ $(candidate \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate\
    \ \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmpeq1q3jz6.sh: line 27: imul: command not found

    '
  stdout: ''
  timestamp: 1660024853
- exit_code: -1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    if [ ! $# -eq 2 ]; then\n        echo \"modp() requires two arguments\"\n\
    \        return 1\n    fi\n    n=\"$1\"\n    p=\"$2\"\n    #echo \"n=$n\"\n  \
    \  #echo \"p=$p\"\n    # base case\n    if [ \"$n\" == \"0\" ]; then\n       \
    \ echo \"1\"\n        return 0\n    fi\n    # get the last bit\n    lastbit=$(echo\
    \ \"$n\" | rev | cut -c 1)\n    #echo \"lastbit=$lastbit\"\n    # remove the last\
    \ bit\n    n=$(echo \"$n\" | rev | cut -c 2- | rev)\n    #echo \"n=$n\"\n    next=$(modp\
    \ \"$n\" \"$p\")\n    if [ $? -ne 0 ]; then\n        return 1\n    fi\n    #echo\
    \ \"next=$next\"\n    next=$(echo \"$next\" | awk -v mod=\"$p\" '{printf(\"%d\"\
    , $1*$1 % mod)}')\n    #echo \"next=$next\"\n    if [ \"$lastbit\" == \"1\" ];\
    \ then\n        next=$(echo \"$next\" | awk -v mod=\"$p\" '{printf(\"%d\", $1*2\
    \ % mod)}')\n        #echo \"next=$next\"\n    fi\n    echo \"$next\"\n}\n\ncandidate()\
    \ {\n    modp \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3\" \"5\"\
    ) = \"3\" ]]\n    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n    [[ $(candidate\
    \ \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\") = \"8\" ]]\n   \
    \ [[ $(candidate \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate \"30\" \"5\"\
    ) = \"4\" ]]\n    [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: Timeout
  stderr: <_io.TextIOWrapper name=7 encoding='utf-8'>
  stdout: <_io.TextIOWrapper name=31 encoding='utf-8'>
  timestamp: 1660024858
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \t# Return $2^$1 modulo $3\n\tlocal power=\"$1\"\n\tlocal base=\"$2\"\n\tlocal\
    \ modulo=\"$3\"\n\tlocal a=\"$base\"\n\tlocal i\n\t[ \"$power\" = \"0\" ] && return\
    \ 1\n\n\tfor ((i=0; i<$power-1; i++)); do\n\t\t# TODO: Check if numerics are correct\n\
    \t\ta=$((a*base))\n\t\tif [ $a -ge $modulo ]; then\n\t\t\ta=$((a%modulo))\n\t\t\
    fi\n\tdone\n\techo \"$a\"\n}\n\ncandidate() {\n    modp \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"\
    1101\" \"101\") = \"2\" ]]\n    [[ $(candidate \"0\" \"101\") = \"1\" ]]\n   \
    \ [[ $(candidate \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate \"100\" \"101\"\
    ) = \"1\" ]]\n    [[ $(candidate \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate\
    \ \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmp5uxkejqt.sh: line 28: [: 25: unary operator expected

    /tmp/tmp5uxkejqt.sh: line 28: [: 125: unary operator expected

    '
  stdout: ''
  timestamp: 1660024853
- exit_code: -1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \tlocal n=\"$1\"\n\tlocal p=\"$2\"\n\tlocal a=\"$p\"\n\tlocal p0=\"$p\"\n\tlocal\
    \ q0=\"1\"\n\tlocal q1=\"0\"\n\tlocal r0=\"$n\"\n\tlocal r1=\"$(( p % n ))\"\n\
    \tlocal i=0\n\tif [ $n -eq 0 ]; then\n\t\t# 0^k mod p\n\t\techo \"1\"\n\t\treturn\n\
    \tfi\n\tif [ $n -lt $p ]; then\n\t\t# n^k mod p\n\t\techo \"$n\"\n\t\treturn\n\
    \tfi\n\tlocal m=\"$n\"\n\twhile [ \"$r1\" -ne 0 ]; do\n\t\tlet i=$i+1\n\t\tlet\
    \ q=$(( p / n ))\n\t\tlet p=$(( p % n ))\n\t\tlet q0=$(( q1 ))\n\t\tlet q1=$((\
    \ q0 - q * q1 ))\n\t\tlet r0=$(( r1 ))\n\t\tlet r1=$(( r0 - q * r1 ))\n\t\tlet\
    \ m=$(( m * q0 + p0 ))\n\tdone\n\t# Output the inverse with sign corresponding\
    \ to q0 and p0\n\tlocal s=\"$(( q0 * p0 ))\"\n\tlet m=$(( (s + m) % s ))\n\techo\
    \ \"$m\"\n}\n\ncandidate() {\n    modp \"$@\"\n}\n\nset -e\nrun_test() {\n   \
    \ [[ $(candidate \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"1101\" \"101\"\
    ) = \"2\" ]]\n    [[ $(candidate \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate\
    \ \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate \"100\" \"101\") = \"1\" ]]\n \
    \   [[ $(candidate \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate \"31\" \"5\")\
    \ = \"3\" ]]\n}\n\nrun_test"
  status: Timeout
  stderr: <_io.TextIOWrapper name=13 encoding='utf-8'>
  stdout: <_io.TextIOWrapper name=19 encoding='utf-8'>
  timestamp: 1660024858
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    if [[ \"$1\" == \"0\" ]]; then\n        echo \"1\"\n        return\n    fi\n\
    \    local num=\"$1\"\n    local p=\"$2\"\n    while [[ \"${#num}\" -gt \"1\"\
    \ ]]; do\n        local rem=\"$(echo \"$num\" | sed 's/^.*\\(.\\)$/\\1/')\"\n\
    \        local tmp=\"$(echo \"$num\" | sed 's/^\\(.*\\).$/\\1/')\"\n        local\
    \ tmp2=\"$(echo \"$rem\"$'\\n'\"$p\" | awk '{ print $1 % $2 }')\"\n        local\
    \ num=\"$tmp$tmp2\"\n    done\n    local ret=\"$(echo \"$num\"$'\\n'\"$p\" | awk\
    \ '{ print $1 % $2 }')\"\n    echo \"$ret\"\n}\n\ncandidate() {\n    modp \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n    [[\
    \ $(candidate \"1101\" \"101\") = \"2\" ]]\n    [[ $(candidate \"0\" \"101\")\
    \ = \"1\" ]]\n    [[ $(candidate \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate\
    \ \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate \"30\" \"5\") = \"4\" ]]\n \
    \   [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: 'awk: cmd. line:1: (FILENAME=- FNR=1) fatal: division by zero attempted
    in `%''

    '
  stdout: ''
  timestamp: 1660024853
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \tif [ $1 -eq 0 ]; then\n\t\techo \"1\"\n\telse\n\t\ti=0\n\t\ttmp=0\n\t\twhile\
    \ [ $i -lt $1 ]; do\n\t\t\ttmp=$(($tmp * 2))\n\t\t\ttmp=$(($tmp % $2))\n\t\t\t\
    i=$(($i + 1))\n\t\tdone\n\t\techo $tmp\n\tfi\n}\n\ncandidate() {\n    modp \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n\
    \    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n    [[ $(candidate \"0\" \"\
    101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate\
    \ \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate \"30\" \"5\") = \"4\" ]]\n \
    \   [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024853
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    echo $(( $1 % $2 ))\n}\n\ncandidate() {\n    modp \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"1101\" \"\
    101\") = \"2\" ]]\n    [[ $(candidate \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate\
    \ \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate \"100\" \"101\") = \"1\" ]]\n \
    \   [[ $(candidate \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate \"31\" \"5\")\
    \ = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024853
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    local base=$1\n    local p=$2\n    local result=1\n    local i\n    for ((i=${#base}-1;\
    \ i>=0; i--)); do\n        (( result = ($result * $result) % $p ))\n        if\
    \ [[ ${base:$i:1} -eq 1 ]]; then\n            (( result = ($result * $base) %\
    \ $p ))\n        fi\n    done\n    echo $result\n}\n\ncandidate() {\n    modp\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n\
    \    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n    [[ $(candidate \"0\" \"\
    101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate\
    \ \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate \"30\" \"5\") = \"4\" ]]\n \
    \   [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024853
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \tlocal n=$1\n\tlocal p=$2\n\tlocal coeffs=(0 1)\n\twhile [[ \"$n\" -gt 0 ]];\
    \ do\n\t\tlocal digit=$((n%2))\n\t\tcoeffs=($((digit*coeffs[1])) $((coeffs[0]+digit*coeffs[1])))\n\
    \t\tcoeffs=($((coeffs[0]%p)) $((coeffs[1]%p)))\n\t\tn=$((n/2))\n\tdone\n\techo\
    \ ${coeffs[0]}\n}\n\ncandidate() {\n    modp \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"1101\" \"101\"\
    ) = \"2\" ]]\n    [[ $(candidate \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate\
    \ \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate \"100\" \"101\") = \"1\" ]]\n \
    \   [[ $(candidate \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate \"31\" \"5\")\
    \ = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024853
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \  if [ $1 -eq 0 ]; then\n    echo \"1\"\n  else\n    local power=$1\n    local\
    \ prime=$2\n    local reminder=1\n    while [ $power -gt 0 ]; do\n      if [ $((power\
    \ & 1)) -eq 1 ]; then\n        reminder=$((reminder * $reminder % $prime))\n \
    \     fi\n      power=$((power >> 1))\n    done\n    echo $reminder\n  fi\n}\n\
    \ncandidate() {\n    modp \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n \
    \   [[ $(candidate \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\"\
    ) = \"8\" ]]\n    [[ $(candidate \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate\
    \ \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\n\
    run_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024853
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    local n=\"$1\"\n    local p=\"$2\"\n    local b\n    local nb\n    local\
    \ rem\n    local m\n    m=\"$(integer_power_mod \"$p\" \"2\" \"$p\")\"\n    rem=\"\
    $n\"\n    if [[ \"$rem\" -lt \"$p\" ]]; then\n        rem=\"$(($rem * $m))\"\n\
    \    fi\n    while read -r b; do\n        nb=\"$(integer_power_mod \"$p\" \"$b\"\
    \ \"$p\")\"\n        rem=\"$(($rem * $nb))\"\n        if [[ \"$rem\" -lt \"$p\"\
    \ ]]; then\n            rem=\"$(($rem * $m))\"\n        fi\n    done < <(integer_to_binary\
    \ \"$n\")\n    echo \"$(($rem % $p))\"\n}\n\ncandidate() {\n    modp \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n    [[\
    \ $(candidate \"1101\" \"101\") = \"2\" ]]\n    [[ $(candidate \"0\" \"101\")\
    \ = \"1\" ]]\n    [[ $(candidate \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate\
    \ \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate \"30\" \"5\") = \"4\" ]]\n \
    \   [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpqgtg0j5l.sh: line 23: integer_power_mod: command not found

    /tmp/tmpqgtg0j5l.sh: line 26: 3 * : syntax error: operand expected (error token
    is "* ")

    '
  stdout: ''
  timestamp: 1660024853
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    # this is expensive.\n    if [ \"$1\" == \"0\" ]; then\n        echo \"1\"\
    \n        return\n    fi\n    modp=$(printf \"mod(%s,%s)\" \"$1\" \"$2\")\n  \
    \  # printf \"%s\\n\" \"$modp\"\n    echo $modp | bc\n}\n\ncandidate() {\n   \
    \ modp \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3\" \"5\") = \"\
    3\" ]]\n    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n    [[ $(candidate \"\
    0\" \"101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate\
    \ \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate \"30\" \"5\") = \"4\" ]]\n \
    \   [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: 'Runtime error (func=(main), adr=8): Function mod not defined.

    '
  stdout: ''
  timestamp: 1660024853
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \  declare -i p=${2:-1}\n  declare -i n=\"$1\"\n  declare -i a=\"$n\"\n  while\
    \ [ \"${#a}\" -gt 1 ]; do\n    declare -i b=\"${a}\"\n    declare -i c=0\n   \
    \ while [ \"${#b}\" -gt 1 ]; do\n      c=\"$((c+${b:0:2}))\"\n      b=\"${b:2}\"\
    \n    done\n    c=\"$((c+${b}))\"\n    a=\"$((a*c))\"\n  done\n  printf \"$((a%p))\"\
    \n}\n\ncandidate() {\n    modp \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n \
    \   [[ $(candidate \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\"\
    ) = \"8\" ]]\n    [[ $(candidate \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate\
    \ \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\n\
    run_test"
  status: Exception
  stderr: '/tmp/tmpc4889ocw.sh: line 25: 09728: value too great for base (error token
    is "09728")

    '
  stdout: ''
  timestamp: 1660024853
- exit_code: -1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    local p=$2\n    # While n is not zero\n    while [[ $1 != 0 ]]; do\n    \
    \    # If lsb of n is one\n        if [[ $(( $1 & 1 )) -eq 1 ]]; then\n      \
    \      # p = p*2 - 1\n            p=$(( ( $p << 1 ) - 1 ))\n        else\n   \
    \         # p = p*2\n            p=$(( $p << 1 ))\n        fi\n        # n = n\
    \ >> 1\n        n=$(( $1 >> 1 ))\n    done\n    # Return p % 2^m\n    echo $((\
    \ $p % $(( 1 << ${#2} )) ))\n}\n\ncandidate() {\n    modp \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"\
    1101\" \"101\") = \"2\" ]]\n    [[ $(candidate \"0\" \"101\") = \"1\" ]]\n   \
    \ [[ $(candidate \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate \"100\" \"101\"\
    ) = \"1\" ]]\n    [[ $(candidate \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate\
    \ \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: Timeout
  stderr: <_io.TextIOWrapper name=38 encoding='utf-8'>
  stdout: <_io.TextIOWrapper name=21 encoding='utf-8'>
  timestamp: 1660024858
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \tpython -c \"print(pow($1, 2, $2))\"\n}\n\ncandidate() {\n    modp \"$@\"\n}\n\
    \nset -e\nrun_test() {\n    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate\
    \ \"1101\" \"101\") = \"2\" ]]\n    [[ $(candidate \"0\" \"101\") = \"1\" ]]\n\
    \    [[ $(candidate \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate \"100\" \"101\"\
    ) = \"1\" ]]\n    [[ $(candidate \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate\
    \ \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024853
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    if [ -z \"$1\" ]; then\n        echo \"**ERROR** Missing first argument to\
    \ modp\"\n        exit -1\n    fi\n    if [ -z \"$2\" ]; then\n        echo \"\
    **ERROR** Missing second argument to modp\"\n        exit -1\n    fi\n    x=$(python\
    \ -c \"print(($1**$2 % $3))\")\n    if [ \"$x\" == \"-1\" ]; then\n        echo\
    \ \"$(( $x + $3 ))\"\n    else\n        echo \"$x\"\n    fi\n}\n\ncandidate()\
    \ {\n    modp \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3\" \"5\"\
    ) = \"3\" ]]\n    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n    [[ $(candidate\
    \ \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\") = \"8\" ]]\n   \
    \ [[ $(candidate \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate \"30\" \"5\"\
    ) = \"4\" ]]\n    [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: "  File \"<string>\", line 1\n    print((3**5 % ))\n                  ^\n\
    SyntaxError: invalid syntax\n"
  stdout: ''
  timestamp: 1660024853
- exit_code: 0
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    [[ \"$#\" -ne 2 ]] && {\n        echo \"Wrong number of arguments\";\n  \
    \      exit 1;\n    }\n    bc <<< \"(2^$1)%$2\"\n}\n\ncandidate() {\n    modp\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n\
    \    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n    [[ $(candidate \"0\" \"\
    101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate\
    \ \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate \"30\" \"5\") = \"4\" ]]\n \
    \   [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660024853
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \  local result=\"1\"\n  local i=0\n  for (( i=0; i<${#1}; i++ )); do\n    if\
    \ [[ \"${1:$i:1}\" -eq \"1\" ]]; then\n      if (( i == 0 )); then\n        result=\"\
    $(($result * 2))\"\n      else\n        result=\"$(($result * 4))\"\n      fi\n\
    \    fi\n    if (( result >= $2 )); then\n      result=\"$(($result % $2))\"\n\
    \    fi\n  done\n  echo $result\n}\n\ncandidate() {\n    modp \"$@\"\n}\n\nset\
    \ -e\nrun_test() {\n    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate\
    \ \"1101\" \"101\") = \"2\" ]]\n    [[ $(candidate \"0\" \"101\") = \"1\" ]]\n\
    \    [[ $(candidate \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate \"100\" \"101\"\
    ) = \"1\" ]]\n    [[ $(candidate \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate\
    \ \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024853
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \tlocal result=\"1\"\n\t# Not allowed to use bc\n\tlocal n=$1\n\twhile [[ \"$n\"\
    \ -ne \"0\" ]]; do\n\t\tif [[ \"$(($n & 1))\" -eq \"1\" ]]; then\n\t\t\tresult=$(($result\
    \ * 2))\n\t\t\tresult=$(($result % $2))\n\t\tfi\n\t\tn=$(($n >> 1))\n\tdone\n\t\
    echo $result\n}\n\ncandidate() {\n    modp \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"1101\" \"101\"\
    ) = \"2\" ]]\n    [[ $(candidate \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate\
    \ \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate \"100\" \"101\") = \"1\" ]]\n \
    \   [[ $(candidate \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate \"31\" \"5\")\
    \ = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024853
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    local p=$2\n    local res=1\n    for (( i=${#1}-1; i>=0; i-- )); do\n   \
    \     bit=${1:$i:1}\n        if [[ $bit -eq 1 ]]; then\n            res=$((res*res%p))\n\
    \            res=$((res*2%p))\n        else\n            res=$((res*res%p))\n\
    \        fi\n    done\n    echo $res\n}\n\ncandidate() {\n    modp \"$@\"\n}\n\
    \nset -e\nrun_test() {\n    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate\
    \ \"1101\" \"101\") = \"2\" ]]\n    [[ $(candidate \"0\" \"101\") = \"1\" ]]\n\
    \    [[ $(candidate \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate \"100\" \"101\"\
    ) = \"1\" ]]\n    [[ $(candidate \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate\
    \ \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024853
- exit_code: 0
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    [ $# -ne 2 ] && return 1\n    printf \"%d\" \"$(($(bc <<< \"2^$1 % $2\" )\
    \ + 0))\"\n}\n\ncandidate() {\n    modp \"$@\"\n}\n\nset -e\nrun_test() {\n  \
    \  [[ $(candidate \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"1101\" \"101\"\
    ) = \"2\" ]]\n    [[ $(candidate \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate\
    \ \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate \"100\" \"101\") = \"1\" ]]\n \
    \   [[ $(candidate \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate \"31\" \"5\")\
    \ = \"3\" ]]\n}\n\nrun_test"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660024853
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    if [ \"$1\" == \"0\" ]; then\n        echo \"1\"\n        return\n    fi\n\
    \    if [ \"$2\" == \"0\" ]; then\n        echo \"Error: divisor is 0.\"\n   \
    \     return\n    fi\n    if [ \"$1\" == \"0\" ]; then\n        echo \"0\"\n \
    \       return\n    fi\n    local result=\"1\"\n    local denom=\"$2\"\n    local\
    \ num=\"$1\"\n    local mod=$((${num} % ${denom}))\n    local remainder=$((${num}\
    \ - ${mod}))\n    num=$((${remainder} / ${denom}))\n    mod=$((${mod} * 2))\n\
    \    result=$((${result} + ${mod}))\n    while [ \"${num}\" != \"0\" ]; do\n \
    \       mod=$((${num} % ${denom}))\n        remainder=$((${num} - ${mod}))\n \
    \       num=$((${remainder} / ${denom}))\n        mod=$((${mod} * 2))\n      \
    \  result=$((${result} + ${mod}))\n    done\n    result=$((${result} % ${denom}))\n\
    \    echo \"${result}\"\n}\n\ncandidate() {\n    modp \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"1101\" \"\
    101\") = \"2\" ]]\n    [[ $(candidate \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate\
    \ \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate \"100\" \"101\") = \"1\" ]]\n \
    \   [[ $(candidate \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate \"31\" \"5\")\
    \ = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024853
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    # Shell arguments are not interpreted as numbers, so we need to convert\n\
    \    # them to integer. For example, $((2**2)) doesn't work.\n    local n\n  \
    \  local p\n    n=$(echo \"$1\" | tr -d '-')\n    p=$(echo \"$2\" | tr -d '-')\n\
    \    modulo=$(echo \"obase=10;ibase=2;$n^$p\" | bc)\n    echo \"$modulo\"\n}\n\
    \ncandidate() {\n    modp \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n \
    \   [[ $(candidate \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\"\
    ) = \"8\" ]]\n    [[ $(candidate \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate\
    \ \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\n\
    run_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024853
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    local n=$1\n    local p=$2\n    local result=1\n    #echo -n \"${n}^1 mod\
    \ ${p} = \"\n    echo -n \"${result} \"\n    while [[ $n -gt 0 ]]; do\n      \
    \  local exp=$((n%2))\n        if [[ $exp -eq 1 ]]; then\n            result=$((result*result%p))\n\
    \            #echo -n \"${n}^2 mod ${p} = \"\n            echo -n \"${result}\
    \ \"\n        fi\n        n=$((n/2))\n    done\n    echo \"mod ${p} = ${result}\"\
    \n    echo $result\n}\n\ncandidate() {\n    modp \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"1101\" \"\
    101\") = \"2\" ]]\n    [[ $(candidate \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate\
    \ \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate \"100\" \"101\") = \"1\" ]]\n \
    \   [[ $(candidate \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate \"31\" \"5\")\
    \ = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024853
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \  local TMP\n  local x\n  local exp\n  local mod\n\n  TMP=$(mktemp)\n  x=$1\n\
    \  exp=$2\n  mod=$(echo \"scale=0; $x^$exp\" | bc)\n  echo \"$mod\" | bc > $TMP\n\
    \  mod=$(cat $TMP)\n  rm $TMP\n  echo \"$mod\"\n}\n\ncandidate() {\n    modp \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n\
    \    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n    [[ $(candidate \"0\" \"\
    101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate\
    \ \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate \"30\" \"5\") = \"4\" ]]\n \
    \   [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024853
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    local p=$2\n    local binary_rep=$(IFS=''; bc <<< \"obase=2; $1\")\n    local\
    \ res=1\n    for char in $(echo \"$binary_rep\" | sed 's/./& /g'); do\n      \
    \  if [ \"$char\" == \"1\" ]; then\n            # echo \"char is 1\"\n       \
    \     res=$(mulmod \"$res\" \"$res\" \"$p\")\n            res=$(mulmod \"$res\"\
    \ \"$1\" \"$p\")\n        else\n            # echo \"char is 0\"\n           \
    \ res=$(mulmod \"$res\" \"$res\" \"$p\")\n        fi\n    done\n    # echo \"\
    res is $res\"\n    echo \"$res\"\n}\n\ncandidate() {\n    modp \"$@\"\n}\n\nset\
    \ -e\nrun_test() {\n    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate\
    \ \"1101\" \"101\") = \"2\" ]]\n    [[ $(candidate \"0\" \"101\") = \"1\" ]]\n\
    \    [[ $(candidate \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate \"100\" \"101\"\
    ) = \"1\" ]]\n    [[ $(candidate \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate\
    \ \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmph6ud9alo.sh: line 23: mulmod: command not found

    /tmp/tmph6ud9alo.sh: line 24: mulmod: command not found

    /tmp/tmph6ud9alo.sh: line 23: mulmod: command not found

    /tmp/tmph6ud9alo.sh: line 24: mulmod: command not found

    '
  stdout: ''
  timestamp: 1660024853
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \  local n=\"$1\"\n  local p=\"$2\"\n  local res=\"1\"\n  local i\n\n  for ((i=0;\
    \ i<${#n}; i++)); do\n    res=$(($res*$res % $p))\n    if [[ \"${n:$i:1}\" ==\
    \ \"1\" ]]; then\n      res=$(($res*2 % $p))\n    fi\n  done\n\n  echo $res\n\
    }\n\ncandidate() {\n    modp \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n \
    \   [[ $(candidate \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\"\
    ) = \"8\" ]]\n    [[ $(candidate \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate\
    \ \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\n\
    run_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024853
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \  local m=$1\n  local p=$2\n  local rez=$m\n  local i\n\n  for ((i=1; i<${#1};\
    \ i++)); do\n    local n_rez\n    # $((10#n)) is needed because bash seems to\
    \ become $m*2 a very big number\n    # and then % is done in 32 bits at most.\n\
    \    if ! n_rez=$(($(($(($((${m:$i:1}*2))%10))#10+$rez))%$p)); then\n      # $((10#n))\
    \ failed, so either the operand was not a number or the result\n      # is too\
    \ big. Fallback to python.\n      if ! n_rez=$(python -c \"print(int('$m')*2%$p)\"\
    ); then\n        echo \"Can't return 2^$m modulo $p, sorry.\" >&2\n        return\
    \ 1\n      fi\n    fi\n    rez=$n_rez\n  done\n\n  echo $rez\n}\n\ncandidate()\
    \ {\n    modp \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3\" \"5\"\
    ) = \"3\" ]]\n    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n    [[ $(candidate\
    \ \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\") = \"8\" ]]\n   \
    \ [[ $(candidate \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate \"30\" \"5\"\
    ) = \"4\" ]]\n    [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmpqjv5jy97.sh: line 26: 0#10: invalid number (error token is "0#10")

    '
  stdout: ''
  timestamp: 1660024853
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \tlocal n=$1\n\tlocal p=$2\n\twhile [[ $n -ge $p ]]; do\n\t\tn=$(($n-$p))\n\t\
    done\n\tprintf '%s' \"$n\"\n}\n\ncandidate() {\n    modp \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"\
    1101\" \"101\") = \"2\" ]]\n    [[ $(candidate \"0\" \"101\") = \"1\" ]]\n   \
    \ [[ $(candidate \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate \"100\" \"101\"\
    ) = \"1\" ]]\n    [[ $(candidate \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate\
    \ \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024853
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \tlocal n=\"$1\"\n\tlocal p=\"$2\"\n\tlocal r=\"${n}\"\n\tlocal b=\"${n: -1}\"\
    \n\tif [ \"$b\" = \"1\" ]; then\n\t\tlocal s=\"$((( r * 2 ) % p))\"\n\telse\n\t\
    \tlocal s=\"$(( r * 2 ))\"\n\tfi\n\tlocal m=\"${n:0:-1}\"\n\tif [ \"$m\" = \"\"\
    \ ]; then\n\t\techo \"${s}\"\n\telse\n\t\tmodp \"${m}\" \"${p}\"\n\tfi\n}\n\n\
    candidate() {\n    modp \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n \
    \   [[ $(candidate \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\"\
    ) = \"8\" ]]\n    [[ $(candidate \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate\
    \ \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\n\
    run_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024853
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    local n=$1\n    local p=$2\n    local res=1\n    local pow2=2\n    local\
    \ pow2c=$((2 % p))\n    local nc=$((n % p))\n    local one=1\n    local zero=0\n\
    \    local t\n\n    while ((nc)); do\n        #echo -n \"$n: \"\n        #echo\
    \ -n \"$nc: \"\n        #echo -n \"$pow2c: \"\n        #echo -n \"$res: \"\n \
    \       if ((nc % 2)); then\n            t=$((res * pow2c))\n            t=$((t\
    \ % p))\n            res=$t\n        fi\n        nc=$((nc / 2))\n        t=$((pow2c\
    \ * pow2c))\n        t=$((t % p))\n        pow2c=$t\n        #echo \"$pow2c\"\n\
    \    done\n    echo \"$res\"\n}\n\ncandidate() {\n    modp \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"\
    1101\" \"101\") = \"2\" ]]\n    [[ $(candidate \"0\" \"101\") = \"1\" ]]\n   \
    \ [[ $(candidate \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate \"100\" \"101\"\
    ) = \"1\" ]]\n    [[ $(candidate \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate\
    \ \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024853
- exit_code: 0
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    _num=$1\n    _mod=$2\n    _result=1\n    if [ \"${_num}\" -eq 0 ]; then\n\
    \        _result=1\n    else\n        _i=1\n        while [ ${_i} -le ${_num}\
    \ ]; do\n            _result=$((${_result}*2))\n            _result=$((${_result}%${_mod}))\n\
    \            _i=$((${_i}+1))\n        done\n    fi\n    echo ${_result}\n}\n\n\
    candidate() {\n    modp \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n \
    \   [[ $(candidate \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\"\
    ) = \"8\" ]]\n    [[ $(candidate \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate\
    \ \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\n\
    run_test"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660024853
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    local _x=\"$1\"\n    local _p=\"$2\"\n    local _y\n    # Fast power algorithm\n\
    \    local _res=\"1\"\n    while [ \"$_x\" -gt \"0\" ]; do\n        _y=$((_x%2))\n\
    \        _x=$((_x/2))\n        if [ \"$_y\" -eq \"1\" ]; then\n            _res=$(((_res*_res)%_p))\n\
    \        fi\n        _res=$(((_res*_res)%_p))\n    done\n    echo \"$_res\"\n\
    }\n\ncandidate() {\n    modp \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n \
    \   [[ $(candidate \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\"\
    ) = \"8\" ]]\n    [[ $(candidate \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate\
    \ \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\n\
    run_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024853
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    echo $(( $1 % $2 ))\n}\n\ncandidate() {\n    modp \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"1101\" \"\
    101\") = \"2\" ]]\n    [[ $(candidate \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate\
    \ \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate \"100\" \"101\") = \"1\" ]]\n \
    \   [[ $(candidate \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate \"31\" \"5\")\
    \ = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024853
- exit_code: 0
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \tbc <<< \"2^$1 % $2\"\n}\n\ncandidate() {\n    modp \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"1101\" \"\
    101\") = \"2\" ]]\n    [[ $(candidate \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate\
    \ \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate \"100\" \"101\") = \"1\" ]]\n \
    \   [[ $(candidate \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate \"31\" \"5\")\
    \ = \"3\" ]]\n}\n\nrun_test"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660024853
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \tlocal n=\"$1\"\n\tlocal p=\"$2\"\n\tlocal x=\"1\"\n\t\n\t[[ \"$n\" == \"0\"\
    \ ]] && echo \"$x\" && return 0\n\t\n\tlocal c\n\tfor ((c=0; c<${#n}; c++)); do\n\
    \t\t[[ \"${n:$c:1}\" == \"1\" ]] && x=$(modmul \"$x\" \"$x\" \"$p\")\n\t\tx=$(modmul\
    \ \"$x\" \"$x\" \"$p\")\n\tdone\n\t\n\techo \"$x\"\n}\n\ncandidate() {\n    modp\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n\
    \    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n    [[ $(candidate \"0\" \"\
    101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate\
    \ \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate \"30\" \"5\") = \"4\" ]]\n \
    \   [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmpfy3mgzq6.sh: line 26: modmul: command not found

    '
  stdout: ''
  timestamp: 1660024853
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \tdec2bin \"$((2**$1%$2))\"\n}\n\ncandidate() {\n    modp \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"\
    1101\" \"101\") = \"2\" ]]\n    [[ $(candidate \"0\" \"101\") = \"1\" ]]\n   \
    \ [[ $(candidate \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate \"100\" \"101\"\
    ) = \"1\" ]]\n    [[ $(candidate \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate\
    \ \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmptomlgo9u.sh: line 17: dec2bin: command not found

    '
  stdout: ''
  timestamp: 1660024853
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \tlocal n=\"$1\"\n\tlocal p=\"$2\"\n\tlocal len=\"${#n}\"\n\tlocal i=0\n\tlocal\
    \ c\n\tlocal result=\"1\"\n\twhile [ $i -lt $len ]; do\n\t\tc=\"${n:$i:1}\"\n\t\
    \t#echo \"c: $c\"\n\t\tif [ \"$c\" = \"1\" ]; then\n\t\t\tresult=$(mult \"$result\"\
    \ \"2\" \"$p\")\n\t\tfi\n\t\t#echo \"result: $result\"\n\t\tresult=$(mod \"$result\"\
    \ \"$p\")\n\t\t#echo \"result: $result\"\n\t\ti=$((i+1))\n\tdone\n\techo \"$result\"\
    \n}\n\ncandidate() {\n    modp \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n \
    \   [[ $(candidate \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\"\
    ) = \"8\" ]]\n    [[ $(candidate \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate\
    \ \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\n\
    run_test"
  status: Exception
  stderr: '/tmp/tmpxebx08e0.sh: line 30: mod: command not found

    '
  stdout: ''
  timestamp: 1660024853
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    printf \"%d\" $(dc -e \"$1 2 ^ $2 % p\")\n}\n\ncandidate() {\n    modp \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n\
    \    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n    [[ $(candidate \"0\" \"\
    101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate\
    \ \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate \"30\" \"5\") = \"4\" ]]\n \
    \   [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024853
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \  echo $1\n  echo $2\n  expr $1 '%' $2\n}\n\ncandidate() {\n    modp \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n    [[\
    \ $(candidate \"1101\" \"101\") = \"2\" ]]\n    [[ $(candidate \"0\" \"101\")\
    \ = \"1\" ]]\n    [[ $(candidate \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate\
    \ \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate \"30\" \"5\") = \"4\" ]]\n \
    \   [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024853
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \tlocal p=$2\n\tlocal a=$1\n\twhile [ \"$a\" -gt \"$p\" ]; do\n\t\ta=$(($a-$p))\n\
    \tdone\n\techo $a\n}\n\ncandidate() {\n    modp \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"1101\" \"\
    101\") = \"2\" ]]\n    [[ $(candidate \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate\
    \ \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate \"100\" \"101\") = \"1\" ]]\n \
    \   [[ $(candidate \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate \"31\" \"5\")\
    \ = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024853
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    # Rather than 2^n modulo p, we return 2^(n mod (p-1)) modulo p.\n    # This\
    \ is equivalent. However, it is easier to do this way,\n    #   because we can\
    \ avoid overflow concerns with large exponents.\n    # The exponent is modulo\
    \ (p-1), not p, because\n    #   2^(p-1) == 1 mod p.\n    local n p x\n    n=\"\
    $1\"\n    p=\"$2\"\n    # Ensure that n < p-1.\n    n=$((\"$n\" % \"$((\"$p\"\
    \ - 1))\" ))\n    # Now compute x = 2^n mod p\n    x=1\n    while [ \"$n\" -gt\
    \ 0 ]; do\n        if [ \"$((\"$n\" % 2))\" -eq 1 ]; then\n            x=$((\"\
    $x\" * 2))\n            x=$((\"$x\" % \"$p\"))\n        fi\n        n=$((\"$n\"\
    \ / 2))\n    done\n    echo \"$x\"\n}\n\ncandidate() {\n    modp \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate\
    \ \"1101\" \"101\") = \"2\" ]]\n    [[ $(candidate \"0\" \"101\") = \"1\" ]]\n\
    \    [[ $(candidate \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate \"100\" \"101\"\
    ) = \"1\" ]]\n    [[ $(candidate \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate\
    \ \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024853
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \t# Validate input\n\ttest $# -eq 2 || {\n\t\techo \"Usage: $(basename $0) <integer>\
    \ <integer>\"\n\t\texit 1\n\t}\n\t# Trim leading zeros\n\t_num=$(echo \"$1\" |\
    \ sed 's/^0*//')\n\t# Compute 2^(num.length) mod p.\n\t# The value of (1 << num.length)\
    \ is one greater than $p, i.e. not in\n\t# the field, thus we need to normalize\
    \ it.\n\t_res=1\n\tfor ((i=1; i <= ${#_num}; i++)); do\n\t\t_res=$(( (_res * _res)\
    \ % $2 ))\n\tdone\n\t# Compute the result of 2^num mod p\n\tfor ((i=${#_num}-1;\
    \ i >= 0; i--)); do\n\t\t_digit=$(echo \"$_num\" | cut -c $((i+1)))\n\t\tif [\
    \ \"$_digit\" -eq 1 ]; then\n\t\t\t_res=$(( (_res * _res) % $2 ))\n\t\tfi\n\t\
    done\n\techo \"$_res\"\n}\n\ncandidate() {\n    modp \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"1101\" \"\
    101\") = \"2\" ]]\n    [[ $(candidate \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate\
    \ \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate \"100\" \"101\") = \"1\" ]]\n \
    \   [[ $(candidate \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate \"31\" \"5\")\
    \ = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024853
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    n=$1\n    p=$2\n    n=$(python -c \"print($n) % $p\")\n    echo \"$n\"\n\
    }\n\ncandidate() {\n    modp \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n \
    \   [[ $(candidate \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\"\
    ) = \"8\" ]]\n    [[ $(candidate \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate\
    \ \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\n\
    run_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024853
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    l=${#1}\n    lp=${#2}\n    if [ \"$l\" -lt \"$lp\" ]; then\n        printf\
    \ \"%d\" \"$1\"\n        return\n    fi\n    j=$l\n    r=0\n    while [ \"$j\"\
    \ -gt 0 ]; do\n        let r=$r*2\n        let j=$j-1\n        d=${1:$j:1}\n \
    \       if [ \"$d\" -eq 1 ]; then\n            let r=$r+1\n        fi\n      \
    \  if [ \"$r\" -ge \"$2\" ]; then\n            let r=$r-$2\n        fi\n    done\n\
    \    printf \"%d\" \"$r\"\n}\n\ncandidate() {\n    modp \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"\
    1101\" \"101\") = \"2\" ]]\n    [[ $(candidate \"0\" \"101\") = \"1\" ]]\n   \
    \ [[ $(candidate \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate \"100\" \"101\"\
    ) = \"1\" ]]\n    [[ $(candidate \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate\
    \ \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024853
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    local c=1;\n    local m=$2;\n    local n=$1;\n    local tmp;\n    local n_bin;\n\
    \    local c_bin;\n    local m_bin;\n    local i;\n    local ii;\n    local m_mask;\n\
    \    local n_mask;\n    local m_bit;\n    local n_bit;\n    if [ $2 -eq 0 ]; then\n\
    \        echo 0;\n        return 1;\n    fi\n    if [ $1 -eq 0 ]; then\n     \
    \   echo 1;\n        return 0;\n    fi\n    if [ $1 -lt 0 ]; then\n        echo\
    \ $(modp $(($2 - $1)) $2);\n        return 0;\n    fi\n    if [ $2 -lt 0 ]; then\n\
    \        echo $(modp $1 $(($2 + $1)));\n        return 0;\n    fi\n    n_bin=$(dec2bin\
    \ $n);\n    c_bin=$(dec2bin $c);\n    m_bin=$(dec2bin $m);\n    for ((i=${#n_bin}-1;\
    \ i>=0; i--)); do\n        for ((ii=0; ii<8; ii++)); do\n            m_mask=$((1\
    \ << ii));\n            m_bit=$((($m_bin & $m_mask) >> ii));\n            n_mask=$((1\
    \ << i));\n            n_bit=$((($n_bin & $n_mask) >> i));\n            if [ $m_bit\
    \ -eq 0 ]; then\n                continue;\n            fi\n            if [ $n_bit\
    \ -eq 0 ]; then\n                continue;\n            fi\n            if [ $ii\
    \ -eq 0 ]; then\n                c=$(($c * $m))\n            elif [ $ii -eq 1\
    \ ]; then\n                c=$(($c + $m))\n            else\n                c=$(($c\
    \ * $m))\n                c=$(($c % $m))\n            fi\n        done\n    done\n\
    \    echo $c;\n}\n\ncandidate() {\n    modp \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"1101\" \"101\"\
    ) = \"2\" ]]\n    [[ $(candidate \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate\
    \ \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate \"100\" \"101\") = \"1\" ]]\n \
    \   [[ $(candidate \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate \"31\" \"5\")\
    \ = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmp6_ifg6ow.sh: line 46: dec2bin: command not found

    /tmp/tmp6_ifg6ow.sh: line 47: dec2bin: command not found

    /tmp/tmp6_ifg6ow.sh: line 48: dec2bin: command not found

    '
  stdout: ''
  timestamp: 1660024853
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \  local i l n p=$2 r=\"\" t=\"\"\n  if [ $1 -eq 0 ]; then\n    echo \"1\"\n \
    \   return\n  fi\n  # log2\n  i=$((p-1))\n  l=0\n  while [ $(($i>>1)) -ne 0 ];\
    \ do\n    i=$(($i>>1))\n    l=$(($l+1))\n  done\n  r=$(($1%$p))\n  for ((i=0;\
    \ i<l; i++)); do\n    r=$(($r*$r))\n    r=$(($r%$p))\n  done\n  echo $r\n}\n\n\
    candidate() {\n    modp \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n \
    \   [[ $(candidate \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\"\
    ) = \"8\" ]]\n    [[ $(candidate \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate\
    \ \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\n\
    run_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024853
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    if [ $1 -eq 0 ]; then\n        printf \"%d\" 1\n    elif [ $1 -eq 1 ]; then\n\
    \        printf \"%d\" $1\n    else\n        P=$2\n        shift 2\n        RESULT=1\n\
    \        BINARY=$(to_binary \"$1\")\n        for BIT in $BINARY; do\n        \
    \    if [ $BIT -eq 1 ]; then\n                RESULT=$(( (RESULT * RESULT) % P\
    \ ))\n            else\n                RESULT=$(( (RESULT * RESULT) % P ))\n\
    \                RESULT=$(( (RESULT * $1) % P ))\n            fi\n        done\n\
    \        printf \"%d\" $RESULT\n    fi\n}\n\ncandidate() {\n    modp \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n    [[\
    \ $(candidate \"1101\" \"101\") = \"2\" ]]\n    [[ $(candidate \"0\" \"101\")\
    \ = \"1\" ]]\n    [[ $(candidate \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate\
    \ \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate \"30\" \"5\") = \"4\" ]]\n \
    \   [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmpyyz_ib1l.sh: line 25: to_binary: command not found

    '
  stdout: ''
  timestamp: 1660024853
- exit_code: 0
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    echo \"2^${1}%${2}\" | bc\n}\n\ncandidate() {\n    modp \"$@\"\n}\n\nset\
    \ -e\nrun_test() {\n    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate\
    \ \"1101\" \"101\") = \"2\" ]]\n    [[ $(candidate \"0\" \"101\") = \"1\" ]]\n\
    \    [[ $(candidate \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate \"100\" \"101\"\
    ) = \"1\" ]]\n    [[ $(candidate \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate\
    \ \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660024853
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    local i_n=\"$1\"\n    local i_p=\"$2\"\n    local i_acc=\"1\"\n    local\
    \ i_n_length=$((${#i_n} - 1))\n    local i_char\n    for ((i=0; i<=i_n_length;\
    \ i++)); do\n        i_char=${i_n:i:1}\n        if [[ \"$i_char\" == \"1\" ]];\
    \ then\n            i_acc=$(($i_acc * 2 % $i_p))\n        fi\n    done\n    echo\
    \ \"$i_acc\"\n}\n\ncandidate() {\n    modp \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"1101\" \"101\"\
    ) = \"2\" ]]\n    [[ $(candidate \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate\
    \ \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate \"100\" \"101\") = \"1\" ]]\n \
    \   [[ $(candidate \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate \"31\" \"5\")\
    \ = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024853
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    n=$1\n    p=$2\n    res=1\n    # iterate through the bits of n\n    while\
    \ [ -n \"$n\" ]; do\n        bit=$((${n:0:1}))\n        n=${n:1}\n        if [\
    \ $bit -eq 1 ]; then\n            res=$(($res * 2 % $p))\n        fi\n       \
    \ res=$(($res * $res % $p))\n    done\n    echo $res\n}\n\ncandidate() {\n   \
    \ modp \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3\" \"5\") = \"\
    3\" ]]\n    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n    [[ $(candidate \"\
    0\" \"101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate\
    \ \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate \"30\" \"5\") = \"4\" ]]\n \
    \   [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024853
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    # ${1: -1} is the last character in $1\n    if [ \"${1: -1}\" -eq \"0\" ];\
    \ then\n        echo \"1\"\n    else\n        echo \"$(($(modp $(($1/2)) $2)*2%$2))\"\
    \n    fi\n}\n\ncandidate() {\n    modp \"$@\"\n}\n\nset -e\nrun_test() {\n   \
    \ [[ $(candidate \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"1101\" \"101\"\
    ) = \"2\" ]]\n    [[ $(candidate \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate\
    \ \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate \"100\" \"101\") = \"1\" ]]\n \
    \   [[ $(candidate \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate \"31\" \"5\")\
    \ = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024853
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \  local a=\"$1\"\n  local p=\"$2\"\n  local T=\"1\"\n  local i=\n  for ((i =\
    \ ${#a} - 1; i >= 0; i--)); do\n    if [[ \"${a:$i:1}\" == \"1\" ]]; then\n  \
    \    T=$(mul \"$T\" \"$T\" \"$p\")\n      T=$(mul \"$T\" \"$p\" \"$p\")\n    else\n\
    \      T=$(mul \"$T\" \"$T\" \"$p\")\n    fi\n  done\n  echo \"$T\"\n}\n\ncandidate()\
    \ {\n    modp \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3\" \"5\"\
    ) = \"3\" ]]\n    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n    [[ $(candidate\
    \ \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\") = \"8\" ]]\n   \
    \ [[ $(candidate \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate \"30\" \"5\"\
    ) = \"4\" ]]\n    [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmpiwih2me2.sh: line 26: mul: command not found

    '
  stdout: ''
  timestamp: 1660024853
- exit_code: 2
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    printf '%s' \"$1\"\n    while [ \"$(printf '%s' \"$1\" | wc -c)\" -gt 1 ];\
    \ do\n        printf '%s' \"$1\" | tail -c 3 | bc <<EOF\ndefine mul(x,y) {\n \
    \   auto t,a,b\n    a=x\n    b=y\n    while(b > 0) {\n        t=b\n        b=a\
    \ %% b\n        a=t\n    }\n    return a\n}\n\ncandidate() {\n    modp \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n    [[\
    \ $(candidate \"1101\" \"101\") = \"2\" ]]\n    [[ $(candidate \"0\" \"101\")\
    \ = \"1\" ]]\n    [[ $(candidate \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate\
    \ \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate \"30\" \"5\") = \"4\" ]]\n \
    \   [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp1lziw5at.sh: line 47: warning: here-document at line 19 delimited
    by end-of-file (wanted `EOF'')

    /tmp/tmp1lziw5at.sh: line 48: syntax error: unexpected end of file

    '
  stdout: ''
  timestamp: 1660024853
- exit_code: 0
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    local a=$1\n    local p=$2\n    if [[ $a -eq 0 ]]; then\n        echo \"\
    1\"\n    else\n        local b=$(modp $((\"$a\" / 2)) \"$p\")\n        if [[ $((\"\
    $a\" % 2)) -eq 0 ]]; then\n            echo $((\"$b\" * \"$b\" % \"$p\"))\n  \
    \      else\n            echo $((\"$b\" * \"$b\" * 2 % \"$p\"))\n        fi\n\
    \    fi\n}\n\ncandidate() {\n    modp \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
    \ $(candidate \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"1101\" \"101\") =\
    \ \"2\" ]]\n    [[ $(candidate \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate \"\
    3\" \"11\") = \"8\" ]]\n    [[ $(candidate \"100\" \"101\") = \"1\" ]]\n    [[\
    \ $(candidate \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate \"31\" \"5\") = \"\
    3\" ]]\n}\n\nrun_test"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660024853
- exit_code: -1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    local N=$1\n    local p=$2\n    local B=$(bc <<< \"$N % $p\")\n    local\
    \ R=$B\n    while [[ \"$B\" -ge \"1\" ]]; do\n        ((B=B*2))\n        ((B=B%p))\n\
    \        if [[ \"$B\" -ge \"1\" ]]; then\n            ((R=R+B))\n            ((R=R%p))\n\
    \        fi\n    done\n    echo \"$R\"\n}\n\ncandidate() {\n    modp \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n    [[\
    \ $(candidate \"1101\" \"101\") = \"2\" ]]\n    [[ $(candidate \"0\" \"101\")\
    \ = \"1\" ]]\n    [[ $(candidate \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate\
    \ \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate \"30\" \"5\") = \"4\" ]]\n \
    \   [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: Timeout
  stderr: <_io.TextIOWrapper name=33 encoding='utf-8'>
  stdout: <_io.TextIOWrapper name=14 encoding='utf-8'>
  timestamp: 1660024858
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \  local p=$1\n  local x=$2\n  if [[ \"${x}\" -eq 0 ]]; then\n    echo \"1\"\n\
    \  else\n    if [[ \"${x}\" -lt 0 ]]; then\n      echo \"$(modp \"${p}\" \"$((2**32+x))\"\
    )\"\n    else\n      if [[ \"${x}\" -lt \"${p}\" ]]; then\n        echo \"${x}\"\
    \n      else\n        echo \"$(modp \"${p}\" \"$((x % p))\")\"\n      fi\n   \
    \ fi\n  fi\n}\n\ncandidate() {\n    modp \"$@\"\n}\n\nset -e\nrun_test() {\n \
    \   [[ $(candidate \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"1101\" \"101\"\
    ) = \"2\" ]]\n    [[ $(candidate \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate\
    \ \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate \"100\" \"101\") = \"1\" ]]\n \
    \   [[ $(candidate \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate \"31\" \"5\")\
    \ = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024853
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \  printf \"%s\\n\" \"$(($(printf \"%s\\n\" \"2^$1\" | bc) % $2))\"\n}\n\ncandidate()\
    \ {\n    modp \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3\" \"5\"\
    ) = \"3\" ]]\n    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n    [[ $(candidate\
    \ \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\") = \"8\" ]]\n   \
    \ [[ $(candidate \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate \"30\" \"5\"\
    ) = \"4\" ]]\n    [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp_h1d6emg.sh: line 17: 27165970580987716985547028567185335572069876938634890994970393394556\

    26185508483697441078416641512118459715652590769476695007745108646985\

    99423110966856012574437715269988127806635657282883293614615336743210\

    52446353025596871544259913106710572064406160761551519464640397970189\

    768008138232246168295750874367316934930297897581105488330752 % 101: syntax error:
    invalid arithmetic operator (error token is "\

    26185508483697441078416641512118459715652590769476695007745108646985\

    99423110966856012574437715269988127806635657282883293614615336743210\

    52446353025596871544259913106710572064406160761551519464640397970189\

    768008138232246168295750874367316934930297897581105488330752 % 101")

    '
  stdout: ''
  timestamp: 1660024853
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    if (( $1 < 0 )) || (( $2 < 0 )); then\n        echo \"No negative values\
    \ allowed\"\n        exit 1\n    fi\n    if (( $2 == 0 )); then\n        echo\
    \ \"Division by zero not allowed\"\n        exit 1\n    fi\n    if (( $1 == 0\
    \ )); then\n        echo 1\n        return\n    fi\n    a=$(echo \"obase=2;$1\"\
    \ | bc)\n    p=$(echo \"obase=2;$2\" | bc)\n    r=$(echo \"obase=2;2^(${#a}-1)%$p\"\
    \ | bc)\n    s=1\n    for i in $(seq 1 $(( ${#a} - 1 ))); do\n        if [[ \"\
    ${a:$i:1}\" == \"1\" ]]; then\n            s=$(echo \"obase=2;$s*$r%$p\" | bc)\n\
    \        fi\n        r=$(echo \"obase=2;$r*$r%$p\" | bc)\n    done\n    echo \"\
    obase=10;$s\" | bc\n}\n\ncandidate() {\n    modp \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"1101\" \"\
    101\") = \"2\" ]]\n    [[ $(candidate \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate\
    \ \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate \"100\" \"101\") = \"1\" ]]\n \
    \   [[ $(candidate \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate \"31\" \"5\")\
    \ = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024853
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \  local n=\"$1\"\n  local p=\"$2\"\n  # Check for correct parameter(s).\n  if\
    \ [[ ! \"$n\" =~ ^[0-9]+$ ]]; then\n    echo \"The first parameter must be an\
    \ integer.\"\n    return 1\n  fi\n  if [[ ! \"$p\" =~ ^[0-9]+$ ]]; then\n    echo\
    \ \"The second parameter must be an integer.\"\n    return 1\n  fi\n  # Compute\
    \ remainder of the binary representation of n.\n  local rem=\"$n\"\n  local res=\"\
    1\"\n  while [[ ! \"$rem\" =~ ^[0]*$ ]]; do\n    if [[ \"$rem\" =~ ^[0-9]+1[0-9]*$\
    \ ]]; then\n      res=$((\"$res\" * \"2\" % \"$p\"))\n    fi\n    rem=$((\"$rem\"\
    \ / \"2\"))\n    res=$((\"$res\" * \"$res\" % \"$p\"))\n  done\n  echo \"$res\"\
    \n}\n\ncandidate() {\n    modp \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n \
    \   [[ $(candidate \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\"\
    ) = \"8\" ]]\n    [[ $(candidate \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate\
    \ \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\n\
    run_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024853
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    local m=\"$1\"\n    local p=\"$2\"\n    local r=\"1\"\n    local s=\"0\"\n\
    \    local t=\"1\"\n    while [[ $m -gt 0 ]]; do\n        if [[ $((m&1)) -eq 1\
    \ ]]; then\n            r=$((r*t))\n            r=$((r%p))\n        fi\n     \
    \   t=$((t*t))\n        t=$((t%p))\n        m=$((m>>1))\n    done\n    echo \"\
    $r\"\n}\n\ncandidate() {\n    modp \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n \
    \   [[ $(candidate \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\"\
    ) = \"8\" ]]\n    [[ $(candidate \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate\
    \ \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\n\
    run_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024853
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \  local n=$1\n  local p=$2\n  local r=1\n  while [ $n -gt 0 ]; do\n    if [ $(expr\
    \ $n % 2) -eq 1 ]; then\n      r=$(expr $r \\* $r % $p)\n    fi\n    n=$(expr\
    \ $n / 2)\n    r=$(expr $r \\* $r % $p)\n  done\n  echo $r\n}\n\ncandidate() {\n\
    \    modp \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3\" \"5\") =\
    \ \"3\" ]]\n    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n    [[ $(candidate\
    \ \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\") = \"8\" ]]\n   \
    \ [[ $(candidate \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate \"30\" \"5\"\
    ) = \"4\" ]]\n    [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024853
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \  local exp=$1\n  local p=$2\n  local prod=1\n  local i=0\n  # Binary exponentiation\n\
    \  for ((i=${#exp}-1; i>=0; i--)); do\n    if [ ${exp:$i:1} -eq 1 ]; then\n  \
    \    prod=$((prod*2%p))\n    fi\n    if [ $i -gt 0 ]; then\n      prod=$((prod*prod%p))\n\
    \    fi\n  done\n  echo \"$prod\"\n}\n\ncandidate() {\n    modp \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate\
    \ \"1101\" \"101\") = \"2\" ]]\n    [[ $(candidate \"0\" \"101\") = \"1\" ]]\n\
    \    [[ $(candidate \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate \"100\" \"101\"\
    ) = \"1\" ]]\n    [[ $(candidate \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate\
    \ \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024853
- exit_code: -1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    local n=$1\n    local p=$2\n    n=$(mod $n $p)\n    while [ ! \"$n\" = \"\
    1\" ]; do\n        n=$(mod $n $(mul $n $p))\n    done\n    echo \"$n\"\n}\n\n\
    candidate() {\n    modp \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n \
    \   [[ $(candidate \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\"\
    ) = \"8\" ]]\n    [[ $(candidate \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate\
    \ \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\n\
    run_test"
  status: Timeout
  stderr: <_io.TextIOWrapper name=24 encoding='utf-8'>
  stdout: <_io.TextIOWrapper name=28 encoding='utf-8'>
  timestamp: 1660024858
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \tbc -q <<< \"\n\t\tibase=2\n\t\tobase=10\n\t\tdefine pow(x,y) {\n\t\t\tif (y\
    \ == 0) {\n\t\t\t\treturn(1)\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn(x * pow(x,\
    \ y - 1))\n\t\t\t}\n\t\t}\n\t\tdefine p2(x) {\n\t\t\tfor (i = 1; i <= x; i++)\
    \ {\n\t\t\t\ta *= 2\n\t\t\t}\n\t\t\treturn(a)\n\t\t}\n\t\tdefine mod(a, b) {\n\
    \t\t\tif (a < b) {\n\t\t\t\treturn(a)\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn(mod(a\
    \ - b, b))\n\t\t\t}\n\t\t}\n\t\ta = 0\n\t\t$1\n\t\tpow(2, a)\n\t\tp2($2 - 1)\n\
    \t\tmod(pow(2, a), p2($2 - 1))\n\t\t\"\n}\n\ncandidate() {\n    modp \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n    [[\
    \ $(candidate \"1101\" \"101\") = \"2\" ]]\n    [[ $(candidate \"0\" \"101\")\
    \ = \"1\" ]]\n    [[ $(candidate \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate\
    \ \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate \"30\" \"5\") = \"4\" ]]\n \
    \   [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '(standard_in) 8: syntax error

    (standard_in) 22: syntax error

    Runtime error (func=(main), adr=7): Function pow not defined.

    Runtime error (func=(main), adr=7): Function pow not defined.

    '
  stdout: ''
  timestamp: 1660024853
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    echo \"$(($(binary $1) % $(binary $2)))\"\n}\n\ncandidate() {\n    modp \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n\
    \    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n    [[ $(candidate \"0\" \"\
    101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate\
    \ \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate \"30\" \"5\") = \"4\" ]]\n \
    \   [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp46_qmmw5.sh: line 17: binary: command not found

    /tmp/tmp46_qmmw5.sh: line 17: binary: command not found

    /tmp/tmp46_qmmw5.sh: line 17: % : syntax error: operand expected (error token
    is "% ")

    '
  stdout: ''
  timestamp: 1660024853
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    modp__n=$1\n    modp__p=$2\n    modp__res=1\n    modp__two=2\n    modp__tmp=1\n\
    \    modp__tmp2=1\n    while test \"$modp__n\" -gt \"0\"; do\n        modp__tmp=$(expr\
    \ \"$modp__res\" \"*\" \"$modp__res\")\n        modp__tmp2=$(expr \"$modp__tmp\"\
    \ \"%\" \"$modp__p\")\n        modp__res=$modp__tmp2\n        modp__n=$(expr \"\
    $modp__n\" - 1)\n    done\n    echo $modp__res\n}\n\ncandidate() {\n    modp \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n\
    \    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n    [[ $(candidate \"0\" \"\
    101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate\
    \ \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate \"30\" \"5\") = \"4\" ]]\n \
    \   [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024853
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \tlocal n=$1\n\tlocal p=$2\n\tfor (( i=${#n}-1; i>=0; i-- )); do\n\t\t[[ ${n:$i:1}\
    \ == \"1\" ]] && n=$(((n^p)%p))\n\t\tp=$((p*p%p))\n\tdone\n\techo $((n%p))\n}\n\
    \ncandidate() {\n    modp \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n \
    \   [[ $(candidate \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\"\
    ) = \"8\" ]]\n    [[ $(candidate \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate\
    \ \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\n\
    run_test"
  status: Exception
  stderr: '/tmp/tmpuk_cvq_h.sh: line 23: n%p: division by 0 (error token is "p")

    '
  stdout: ''
  timestamp: 1660024853
- exit_code: -1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \  local a=\"$1\"\n  local b=\"$2\"\n  echo \"$a\"\n  while [ \"$a\" -gt 0 ];\
    \ do\n    local c=$((a & 1))\n    if [ \"$c\" -eq 1 ]; then\n      a=$((a >> 1))\n\
    \      if [ \"$a\" -gt 0 ]; then\n        a=$((a * b))\n      fi\n    else\n \
    \     a=$((a >> 1))\n    fi\n    echo \"$a\"\n  done\n}\n\ncandidate() {\n   \
    \ modp \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3\" \"5\") = \"\
    3\" ]]\n    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n    [[ $(candidate \"\
    0\" \"101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate\
    \ \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate \"30\" \"5\") = \"4\" ]]\n \
    \   [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: Timeout
  stderr: <_io.TextIOWrapper name=47 encoding='utf-8'>
  stdout: <_io.TextIOWrapper name=42 encoding='utf-8'>
  timestamp: 1660024858
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    local n=\"$1\" p=\"$2\"\n    if [[ \"$n\" -lt \"0\" ]]; then\n        n=$((p+n))\n\
    \    fi\n    while [[ \"$n\" -ge \"$p\" ]]; do\n        n=$((n-p))\n    done\n\
    \    echo \"$n\"\n}\n\ncandidate() {\n    modp \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"1101\" \"\
    101\") = \"2\" ]]\n    [[ $(candidate \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate\
    \ \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate \"100\" \"101\") = \"1\" ]]\n \
    \   [[ $(candidate \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate \"31\" \"5\")\
    \ = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024853
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \  a=$1\n  m=$2\n  p=1\n  while [[ $a != 0 ]]; do\n    if [[ $((a & 1)) == 1 ]];\
    \ then\n      p=$(((p * m) % $2))\n    fi\n    a=$((a >> 1))\n    m=$(((m * m)\
    \ % $2))\n  done\n  echo $p\n}\n\ncandidate() {\n    modp \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"\
    1101\" \"101\") = \"2\" ]]\n    [[ $(candidate \"0\" \"101\") = \"1\" ]]\n   \
    \ [[ $(candidate \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate \"100\" \"101\"\
    ) = \"1\" ]]\n    [[ $(candidate \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate\
    \ \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024853
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \tlocal num=\"$1\"\n\tlocal base=\"$2\"\n\tlocal cur=\"$base\"\n\tlocal last\n\
    \tlocal res=\"1\"\n\twhile true; do\n\t\tlast=\"$(bc <<< \"scale=10; $cur%10\"\
    )\"\n\t\tif [ \"$last\" = \"1\" ]; then\n\t\t\tres=\"$(bc <<< \"scale=10; ($res*$num)%$base\"\
    )\"\n\t\tfi\n\t\tcur=\"$(bc <<< \"scale=10; $cur/10\")\"\n\t\tif [ \"$cur\" =\
    \ \"0\" ]; then\n\t\t\tbreak\n\t\tfi\n\t\tnum=\"$(bc <<< \"scale=10; ($num*$num)%$base\"\
    )\"\n\tdone\n\techo \"$res\"\n}\n\ncandidate() {\n    modp \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"\
    1101\" \"101\") = \"2\" ]]\n    [[ $(candidate \"0\" \"101\") = \"1\" ]]\n   \
    \ [[ $(candidate \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate \"100\" \"101\"\
    ) = \"1\" ]]\n    [[ $(candidate \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate\
    \ \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024853
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    local a=\"$1\"\n    local b=\"$2\"\n    local r\n    local s\n\n    if [\
    \ \"$a\" == \"0\" ]; then\n        echo \"1\"\n        return\n    fi\n\n    if\
    \ [ \"$a\" == \"1\" ]; then\n        echo \"$a\"\n        return\n    fi\n\n \
    \   r=\"$((a % 2))\"\n    s=\"$(($a / 2))\"\n\n    if [ \"$r\" == \"0\" ]; then\n\
    \        echo \"$(modp \"$(modp \"$s\" \"$b\")\" \"$b\")\"\n        return\n \
    \   fi\n\n    if [ \"$r\" == \"1\" ]; then\n        echo \"$(modp \"$((2 * $(modp\
    \ \"$s\" \"$b\") % b))\" \"$b\")\"\n        return\n    fi\n}\n\ncandidate() {\n\
    \    modp \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3\" \"5\") =\
    \ \"3\" ]]\n    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n    [[ $(candidate\
    \ \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\") = \"8\" ]]\n   \
    \ [[ $(candidate \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate \"30\" \"5\"\
    ) = \"4\" ]]\n    [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024853
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    local base=$1\n    local modulus=$2\n    local result=\"1\"\n    while [\
    \ \"$base\" -gt \"0\" ]; do\n        if [ \"$(echo \"$base % 2\" | bc)\" -ne \"\
    0\" ]; then\n            result=$(echo \"$result * $result % $modulus\" | bc)\n\
    \        fi\n        base=$(echo \"$base / 2\" | bc)\n        result=$(echo \"\
    $result * $result % $modulus\" | bc)\n    done\n    echo \"$result\"\n}\n\ncandidate()\
    \ {\n    modp \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3\" \"5\"\
    ) = \"3\" ]]\n    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n    [[ $(candidate\
    \ \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\") = \"8\" ]]\n   \
    \ [[ $(candidate \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate \"30\" \"5\"\
    ) = \"4\" ]]\n    [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024853
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    echo \"$1\" | bc -l | awk -v \"p=$2\" '{ print int(2^$1 % p) }'\n}\n\ncandidate()\
    \ {\n    modp \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3\" \"5\"\
    ) = \"3\" ]]\n    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n    [[ $(candidate\
    \ \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\") = \"8\" ]]\n   \
    \ [[ $(candidate \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate \"30\" \"5\"\
    ) = \"4\" ]]\n    [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024853
- exit_code: 0
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    local a=\"$1\" b=\"$2\" res=\"1\"\n    for i in $(seq 1 \"$a\"); do\n   \
    \     res=$(($res * 2))\n        res=$(($res % $b))\n    done\n    echo \"$res\"\
    \n}\n\ncandidate() {\n    modp \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n \
    \   [[ $(candidate \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\"\
    ) = \"8\" ]]\n    [[ $(candidate \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate\
    \ \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\n\
    run_test"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660024853
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    gmpy-modp \"$1\" \"$2\"\n}\n\ncandidate() {\n    modp \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"\
    1101\" \"101\") = \"2\" ]]\n    [[ $(candidate \"0\" \"101\") = \"1\" ]]\n   \
    \ [[ $(candidate \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate \"100\" \"101\"\
    ) = \"1\" ]]\n    [[ $(candidate \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate\
    \ \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmpfakqhqvc.sh: line 17: gmpy-modp: command not found

    '
  stdout: ''
  timestamp: 1660024853
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \tif [ \"$#\" -ne 2 ]; then\n\t\techo 1>&2 \"$0: two arguments (integers) required\"\
    \n\t\treturn 1\n\tfi\n\t# Call out to Python script to do the rest\n\tpython -c\
    \ \"from __future__ import print_function; \\\n\t\tfrom utils import modp; \\\n\
    \t\tprint(modp($1, $2))\"\n}\n\ncandidate() {\n    modp \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"\
    1101\" \"101\") = \"2\" ]]\n    [[ $(candidate \"0\" \"101\") = \"1\" ]]\n   \
    \ [[ $(candidate \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate \"100\" \"101\"\
    ) = \"1\" ]]\n    [[ $(candidate \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate\
    \ \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"<string>\", line 1, in <module>\n\
    ImportError: No module named utils\n"
  stdout: ''
  timestamp: 1660024853
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \  if [ -z \"${1}\" ] || [ -z \"${2}\" ]; then\n    fail \"modp() requires two\
    \ arguments\"\n  fi\n  local result=$((${1} % ${2}))\n  # Modulo returns negative\
    \ values for some values.  This ensures\n  # that the result is non-negative.\n\
    \  if [ ${result} -lt 0 ]; then\n    result=$((${result} + ${2}))\n  fi\n  echo\
    \ \"${result}\"\n}\n\ncandidate() {\n    modp \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"1101\" \"\
    101\") = \"2\" ]]\n    [[ $(candidate \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate\
    \ \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate \"100\" \"101\") = \"1\" ]]\n \
    \   [[ $(candidate \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate \"31\" \"5\")\
    \ = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024853
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \techo \"$1\" | modp2 \"$2\"\n}\n\ncandidate() {\n    modp \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"\
    1101\" \"101\") = \"2\" ]]\n    [[ $(candidate \"0\" \"101\") = \"1\" ]]\n   \
    \ [[ $(candidate \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate \"100\" \"101\"\
    ) = \"1\" ]]\n    [[ $(candidate \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate\
    \ \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmpmf_h81k4.sh: line 17: modp2: command not found

    '
  stdout: ''
  timestamp: 1660024853
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \tif [ -z \"$1\" ] || [ -z \"$2\" ]; then\n\t\techo \"modp: requires two arguments\"\
    \ >&2\n\t\treturn 1\n\tfi\n\techo \"$1\" | bc -l | sed -r 's/\\.[0-9]+//g' | awk\
    \ 'BEGIN{print 2^'$1'}' | bc -l | sed -r 's/\\.[0-9]+//g' | bc -l | sed -r 's/\\\
    .[0-9]+//g' | sed -r 's/^0*//g' | awk 'BEGIN{print $1%'$2'}'\n}\n\ncandidate()\
    \ {\n    modp \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3\" \"5\"\
    ) = \"3\" ]]\n    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n    [[ $(candidate\
    \ \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\") = \"8\" ]]\n   \
    \ [[ $(candidate \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate \"30\" \"5\"\
    ) = \"4\" ]]\n    [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024853
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    ./bin/modp \"$1\" \"$2\"\n}\n\ncandidate() {\n    modp \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"\
    1101\" \"101\") = \"2\" ]]\n    [[ $(candidate \"0\" \"101\") = \"1\" ]]\n   \
    \ [[ $(candidate \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate \"100\" \"101\"\
    ) = \"1\" ]]\n    [[ $(candidate \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate\
    \ \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmpbp325rrw.sh: line 17: ./bin/modp: No such file or directory

    '
  stdout: ''
  timestamp: 1660024853
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \  local x=$1\n  local p=$2\n  # TODO: Add 'type' guard\n  # TODO: Add 'p >= 2'\
    \ guard\n  if [ \"$x\" == \"0\" ]; then\n    echo 1\n  else\n    $(bc <<< \"2^$x\
    \ % $p\")\n  fi\n}\n\ncandidate() {\n    modp \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"1101\" \"\
    101\") = \"2\" ]]\n    [[ $(candidate \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate\
    \ \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate \"100\" \"101\") = \"1\" ]]\n \
    \   [[ $(candidate \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate \"31\" \"5\")\
    \ = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmpywj_mver.sh: line 24: 3: command not found

    '
  stdout: ''
  timestamp: 1660024853
- exit_code: -1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    local n=\"$1\" p=\"$2\" r=\"\"\n\n    [ -z \"$n\" ] && n=\"0\"\n    [ -z\
    \ \"$p\" ] && p=\"0\"\n\n    if [ \"$n\" -lt 0 ]; then\n        n=$((p+n))\n \
    \   fi\n\n    if [ \"$p\" -lt 0 ]; then\n        p=$((p+n))\n    fi\n\n    if\
    \ [ \"$n\" -lt \"$p\" ]; then\n        r=\"$n\"\n    else\n        if [ \"$n\"\
    \ -lt 2 ]; then\n            r=\"$n\"\n        else\n            n=$((n-1))\n\
    \            r=$(modp \"$n\" \"$p\")\n            r=$(((r+r)%p))\n           \
    \ if [ \"$r\" -lt \"$p\" ]; then\n                r=$((r+1))\n            else\n\
    \                r=$((r-p))\n            fi\n        fi\n    fi\n\n    echo \"\
    $r\"\n}\n\ncandidate() {\n    modp \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n \
    \   [[ $(candidate \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\"\
    ) = \"8\" ]]\n    [[ $(candidate \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate\
    \ \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\n\
    run_test"
  status: Timeout
  stderr: <_io.TextIOWrapper name=60 encoding='utf-8'>
  stdout: <_io.TextIOWrapper name=58 encoding='utf-8'>
  timestamp: 1660024858
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \  echo \"$1\" | bc | awk '{print $1%('\"$2\"')}'\n}\n\ncandidate() {\n    modp\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n\
    \    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n    [[ $(candidate \"0\" \"\
    101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate\
    \ \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate \"30\" \"5\") = \"4\" ]]\n \
    \   [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024853
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    local result\n    result=\"$(echo \"($1)^2\" | bc | sed 's/[eE]/*10^/g')\"\
    \n    result=\"$(echo \"($result+0)%$2\" | bc)\"\n    echo \"$result\"\n}\n\n\
    candidate() {\n    modp \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n \
    \   [[ $(candidate \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\"\
    ) = \"8\" ]]\n    [[ $(candidate \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate\
    \ \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\n\
    run_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024853
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \  modp_result=$1\n  modp_m=$2\n  modp_last=$modp_result\n  modp_result=$(($modp_result\
    \ % $modp_m))\n  for modp_i in $(seq ${#1} -1 1); do\n    modp_last=$modp_result\n\
    \    modp_val=$((${1:$modp_i-1:1} * 2))\n    modp_result=$(($modp_result * 2))\n\
    \    modp_result=$(($modp_result % $modp_m))\n    modp_tmp=$(($modp_result + $modp_val))\n\
    \    modp_result=$(($modp_tmp % $modp_m))\n  done\n  echo $modp_result\n}\n\n\
    candidate() {\n    modp \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n \
    \   [[ $(candidate \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\"\
    ) = \"8\" ]]\n    [[ $(candidate \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate\
    \ \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\n\
    run_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024853
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    m=\"$1\"\n    p=\"$2\"\n    counter=\"$(echo \"$m\" | wc -c)\"\n    result=\"\
    1\"\n    while [ \"$counter\" -gt \"0\" ]; do\n        d=\"$(echo \"$m\" | cut\
    \ -c\"$counter\")\"\n        if [ \"$d\" == \"1\" ]; then\n            mul=\"\
    $(mul \"$result\" \"2\")\"\n            result=\"$(modulo \"$mul\" \"$p\")\"\n\
    \        fi\n        counter=\"$(echo \"$counter-1\" | bc)\"\n    done\n    echo\
    \ \"$result\"\n}\n\ncandidate() {\n    modp \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"1101\" \"101\"\
    ) = \"2\" ]]\n    [[ $(candidate \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate\
    \ \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate \"100\" \"101\") = \"1\" ]]\n \
    \   [[ $(candidate \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate \"31\" \"5\")\
    \ = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024853
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \  local n=\"$1\"\n  local p=\"$2\"\n  local m=\"$((2 ** n % p))\"\n  echo \"\
    $m\"\n}\n\ncandidate() {\n    modp \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n \
    \   [[ $(candidate \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\"\
    ) = \"8\" ]]\n    [[ $(candidate \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate\
    \ \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\n\
    run_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024853
- exit_code: -1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \  local n=$1\n  local p=$2\n  local s=$n\n  echo $s\n  while true; do\n    local\
    \ s=$(bn_mod \"$s*$s\" \"$p\")\n    echo $s\n    if [ \"$s\" == \"1\" ]; then\n\
    \      echo \"1\"\n      break\n    fi\n  done\n}\n\ncandidate() {\n    modp \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n\
    \    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n    [[ $(candidate \"0\" \"\
    101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate\
    \ \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate \"30\" \"5\") = \"4\" ]]\n \
    \   [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: Timeout
  stderr: <_io.TextIOWrapper name=65 encoding='utf-8'>
  stdout: <_io.TextIOWrapper name=56 encoding='utf-8'>
  timestamp: 1660024858
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    local n=\"$1\"\n    local p=\"$2\"\n    local m=\"1\"\n    local i\n    for\
    \ ((i=${#n}-1; i>=0; i--)); do\n        local digit=\"${n:$i:1}\"\n        m=$(((m*m)%p))\n\
    \        if [[ \"$digit\" == \"1\" ]]; then\n            m=$(((m*2)%p))\n    \
    \    fi\n    done\n    echo \"$m\"\n}\n\ncandidate() {\n    modp \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate\
    \ \"1101\" \"101\") = \"2\" ]]\n    [[ $(candidate \"0\" \"101\") = \"1\" ]]\n\
    \    [[ $(candidate \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate \"100\" \"101\"\
    ) = \"1\" ]]\n    [[ $(candidate \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate\
    \ \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024853
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \tinput_num=$1\n\tmodulo=$2\n\tdecimal_input_num=$(b2d \"$input_num\")\n\tdecimal_output_num=$(echo\
    \ \"($decimal_input_num % $modulo + $modulo) % $modulo\" | bc)\n\techo $(d2b \"\
    $decimal_output_num\")\n}\n\ncandidate() {\n    modp \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"1101\" \"\
    101\") = \"2\" ]]\n    [[ $(candidate \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate\
    \ \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate \"100\" \"101\") = \"1\" ]]\n \
    \   [[ $(candidate \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate \"31\" \"5\")\
    \ = \"3\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmph3pghg83.sh: line 19: b2d: command not found

    (standard_in) 1: syntax error

    (standard_in) 1: syntax error

    /tmp/tmph3pghg83.sh: line 21: d2b: command not found

    '
  stdout: ''
  timestamp: 1660024853
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    echo \"$1\" | awk '\n    function twoexp(x, n, p, t) {\n        if (n ==\
    \ 0) {\n            t = 1\n        } else if (n % 2 == 0) {\n            t = twoexp(x,\
    \ n / 2, p) ^ 2\n            if (t >= p) {\n                t = t % p\n      \
    \      }\n        } else {\n            t = x * twoexp(x, n - 1, p)\n        \
    \    if (t >= p) {\n                t = t % p\n            }\n        }\n    \
    \    return t\n    }\n    {\n        print twoexp($1, '\"$2\"', '\"$2\"')\n  \
    \  }'\n}\n\ncandidate() {\n    modp \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
    \ $(candidate \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"1101\" \"101\") =\
    \ \"2\" ]]\n    [[ $(candidate \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate \"\
    3\" \"11\") = \"8\" ]]\n    [[ $(candidate \"100\" \"101\") = \"1\" ]]\n    [[\
    \ $(candidate \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate \"31\" \"5\") = \"\
    3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024853
- exit_code: -1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    if [ \"$1\" -eq \"0\" ]; then\n        echo \"1\"\n        return\n    fi\n\
    \    local s=$(echo \"$1\" | sed 's/^[0-1]*1//')\n    local a=$(modp \"$s\" \"\
    $2\")\n    a=$(mul \"2\" \"$a\" \"$2\")\n    local r=$(sub \"$1\" \"$s\")\n  \
    \  if [ \"$r\" -gt \"0\" ]; then\n        a=$(add \"$a\" \"1\" \"$2\")\n    fi\n\
    \    echo \"$a\"\n}\n\ncandidate() {\n    modp \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"1101\" \"\
    101\") = \"2\" ]]\n    [[ $(candidate \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate\
    \ \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate \"100\" \"101\") = \"1\" ]]\n \
    \   [[ $(candidate \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate \"31\" \"5\")\
    \ = \"3\" ]]\n}\n\nrun_test"
  status: Timeout
  stderr: <_io.TextIOWrapper name=67 encoding='utf-8'>
  stdout: <_io.TextIOWrapper name=59 encoding='utf-8'>
  timestamp: 1660024858
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    let \"p = $2\"\n    if (( $1 == 0 ))\n    then\n        let \"r = 1 % p\"\
    \n    else\n        local n=$1\n        let \"r = 2 % p\"\n        while [ $n\
    \ -gt 1 ]\n        do\n            let \"r = (r * r) % p\"\n            let \"\
    n = n - 1\"\n        done\n    fi\n    echo \"$r\"\n}\n\ncandidate() {\n    modp\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n\
    \    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n    [[ $(candidate \"0\" \"\
    101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate\
    \ \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate \"30\" \"5\") = \"4\" ]]\n \
    \   [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024853
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \  if [ \"$1\" == \"0\" ]; then\n    echo \"1\"\n    return\n  fi\n  if [ \"$1\"\
    \ == \"1\" ]; then\n    echo \"$2\"\n    return\n  fi\n  if [ \"$1\" == \"2\"\
    \ ]; then\n    local n=$(( \"$2\" * \"$2\" ))\n    echo \"$n\"\n    return\n \
    \ fi\n  if [ \"$1\" == \"3\" ]; then\n    local n=$(( \"$2\" * \"$2\" * \"$2\"\
    \ ))\n    echo \"$n\"\n    return\n  fi\n  local p2=$(modp \"$(($1 / 2))\" \"\
    $2\")\n  local p3=$(modp \"$(($1 - $1 / 2))\" \"$2\")\n  local n=$(( \"$p2\" *\
    \ \"$p2\" * \"$p3\" ))\n  echo \"$n\"\n}\n\ncandidate() {\n    modp \"$@\"\n}\n\
    \nset -e\nrun_test() {\n    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate\
    \ \"1101\" \"101\") = \"2\" ]]\n    [[ $(candidate \"0\" \"101\") = \"1\" ]]\n\
    \    [[ $(candidate \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate \"100\" \"101\"\
    ) = \"1\" ]]\n    [[ $(candidate \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate\
    \ \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024853
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    local n=$1\n    local p=$2\n    local x=1\n    local i\n    if [[ $n == 0\
    \ ]]; then\n        echo 1\n        return\n    fi\n    while [[ $n != 0 ]]; do\n\
    \        if [[ $(($n % 2)) == 1 ]]; then\n            x=$(($x * 2 % $p))\n   \
    \     fi\n        n=$(($n / 2))\n    done\n    echo $x\n}\n\ncandidate() {\n \
    \   modp \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3\" \"5\") =\
    \ \"3\" ]]\n    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n    [[ $(candidate\
    \ \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\") = \"8\" ]]\n   \
    \ [[ $(candidate \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate \"30\" \"5\"\
    ) = \"4\" ]]\n    [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024853
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    local v=\"${1}\"\n    local p=\"${2}\"\n    local result=1\n    local i=0\n\
    \    while [ \"${i}\" -lt \"${#v}\" ]; do\n        if [ \"${v:${i}:1}\" -eq 1\
    \ ]; then\n            result=$((result * 2))\n            result=$((result %\
    \ p))\n        fi\n        i=$((i + 1))\n    done\n    echo \"${result}\"\n}\n\
    \ncandidate() {\n    modp \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n \
    \   [[ $(candidate \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\"\
    ) = \"8\" ]]\n    [[ $(candidate \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate\
    \ \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\n\
    run_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024853
- exit_code: -1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    local x=\"$1\"\n    local p=\"$2\"\n    local m=\"$p\"\n    local res=1\n\
    \    while [ -n \"$x\" ]; do\n        while [ \"$x\" -ge \"2\" ]; do\n       \
    \     y=$((x%2))\n            x=$((x/2))\n            if [ \"$y\" -ne \"0\" ];\
    \ then\n                res=$(((res*m)%p))\n            fi\n            m=$(((m*m)%p))\n\
    \        done\n        if [ \"$x\" -ne \"0\" ]; then\n            res=$(((res*m)%p))\n\
    \        fi\n        x=$((x/2))\n        m=$(((m*m)%p))\n    done\n    echo \"\
    $res\"\n}\n\ncandidate() {\n    modp \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
    \ $(candidate \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"1101\" \"101\") =\
    \ \"2\" ]]\n    [[ $(candidate \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate \"\
    3\" \"11\") = \"8\" ]]\n    [[ $(candidate \"100\" \"101\") = \"1\" ]]\n    [[\
    \ $(candidate \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate \"31\" \"5\") = \"\
    3\" ]]\n}\n\nrun_test"
  status: Timeout
  stderr: <_io.TextIOWrapper name=53 encoding='utf-8'>
  stdout: <_io.TextIOWrapper name=51 encoding='utf-8'>
  timestamp: 1660024858
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \  mod=$2\n  echo $1 | \\\n    awk \"{pow=\\$1;\n          for (i=1; i<pow; i++)\
    \ {\n            printf(\\\"%d\\\", 2%mod);\n          }\n          printf(\\\"\
    %d\\\", 1%mod); }\"\n}\n\ncandidate() {\n    modp \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"1101\" \"\
    101\") = \"2\" ]]\n    [[ $(candidate \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate\
    \ \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate \"100\" \"101\") = \"1\" ]]\n \
    \   [[ $(candidate \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate \"31\" \"5\")\
    \ = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: 'awk: cmd. line:3: (FILENAME=- FNR=1) fatal: division by zero attempted
    in `%''

    '
  stdout: ''
  timestamp: 1660024854
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    n=$1\n    p=$2\n    len=${#n}\n    len_bits=$(($len * 4))\n    # 1 << 100\
    \ will produce a non-terminating integer (with gawk), thus we only use the last\n\
    \    # 4 bits of each number.\n    if [ $len_bits -le 31 ]; then\n        num=$((\
    \ 1 << $len_bits ))\n    else\n        num=$(( 1 << 31 ))\n    fi\n    if [ $len\
    \ -gt 0 ]; then\n        for i in $(seq $len); do\n            num=$(( num * num\
    \ % p ))\n            if [ \"${n:$(( $len - $i )):1}\" -gt 0 ]; then\n       \
    \         num=$(( num * 2 % p ))\n            fi\n        done\n    fi\n    echo\
    \ $num\n}\n\ncandidate() {\n    modp \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
    \ $(candidate \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"1101\" \"101\") =\
    \ \"2\" ]]\n    [[ $(candidate \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate \"\
    3\" \"11\") = \"8\" ]]\n    [[ $(candidate \"100\" \"101\") = \"1\" ]]\n    [[\
    \ $(candidate \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate \"31\" \"5\") = \"\
    3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024854
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \techo \"($1 ** ($1 % ($2 - 1)) % $2)\" | bc\n}\n\ncandidate() {\n    modp \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n\
    \    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n    [[ $(candidate \"0\" \"\
    101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate\
    \ \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate \"30\" \"5\") = \"4\" ]]\n \
    \   [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '(standard_in) 1: syntax error

    (standard_in) 1: syntax error

    '
  stdout: ''
  timestamp: 1660024854
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \  local a=$1\n  local p=$2\n  local x=\"1\"\n  local i\n  for ((i=0; i<${#a};\
    \ i++)); do\n    local bit=\"${a:$i:1}\"\n    if [[ \"$bit\" == \"1\" ]]; then\n\
    \      x=$((${x}*${x} % ${p}))\n    fi\n    x=$((${x}*${x} % ${p}))\n  done\n\
    \  echo \"${x}\"\n}\n\ncandidate() {\n    modp \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"1101\" \"\
    101\") = \"2\" ]]\n    [[ $(candidate \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate\
    \ \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate \"100\" \"101\") = \"1\" ]]\n \
    \   [[ $(candidate \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate \"31\" \"5\")\
    \ = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024853
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    perl -e '\n    $i = $ARGV[0];\n    $p = $ARGV[1];\n    $pow = 2;\n    for\
    \ ( $j = 0; $j < $i; $j++ ) {\n        $pow = $pow * 2;\n        $pow = $pow %\
    \ $p;\n    }\n    print $pow\n    ' \"$1\" \"$2\"\n}\n\ncandidate() {\n    modp\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n\
    \    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n    [[ $(candidate \"0\" \"\
    101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate\
    \ \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate \"30\" \"5\") = \"4\" ]]\n \
    \   [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024853
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \  echo \"($1 * $1)%$2\" | bc\n}\n\ncandidate() {\n    modp \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"\
    1101\" \"101\") = \"2\" ]]\n    [[ $(candidate \"0\" \"101\") = \"1\" ]]\n   \
    \ [[ $(candidate \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate \"100\" \"101\"\
    ) = \"1\" ]]\n    [[ $(candidate \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate\
    \ \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024854
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \tif [ $1 -eq 0 ]; then\n\t\techo \"1\"\n\t\treturn\n\tfi\n\t# convert $1 to binary\
    \ and remove any leading 0s\n\tbin=$(echo \"obase=2; $1\" | bc)\n\tbin=${bin#0}\n\
    \t# create an accumulator of 1\n\tacc=\"1\"\n\t# the current power of 2\n\tpow=\"\
    2\"\n\t# the maximum power of 2 (1 less than the modulus)\n\tmax=\"$(( $2 - 1\
    \ ))\"\n\t# iterate until we've found the maximum power of 2\n\twhile [ $pow -le\
    \ $max ]; do\n\t\t# if the next digit of the binary is 1, multiply the accumulator\
    \ by\n\t\t# the current power of 2 modulo the modulus\n\t\tif [ ${bin:0:1} -eq\
    \ 1 ]; then\n\t\t\tacc=$(( ($acc * $pow) % $2 ))\n\t\tfi\n\t\t# iterate to the\
    \ next digit of the binary and the next power of 2\n\t\tbin=${bin:1}\n\t\tpow=$((\
    \ $pow * 2 ))\n\tdone\n\t# finally, multiply the accumulator by the last digit\
    \ of the binary\n\techo \"$(( ($acc * ${bin:0:1}) % $2 ))\"\n}\n\ncandidate()\
    \ {\n    modp \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3\" \"5\"\
    ) = \"3\" ]]\n    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n    [[ $(candidate\
    \ \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\") = \"8\" ]]\n   \
    \ [[ $(candidate \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate \"30\" \"5\"\
    ) = \"4\" ]]\n    [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpshx6xhpa.sh: line 42: (3 * ) % 5 : syntax error: operand expected
    (error token is ") % 5 ")

    '
  stdout: ''
  timestamp: 1660024854
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    if (( $1 < $2 )); then\n        echo $1\n    else\n        echo $(($1 % $2))\n\
    \    fi\n}\n\ncandidate() {\n    modp \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
    \ $(candidate \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"1101\" \"101\") =\
    \ \"2\" ]]\n    [[ $(candidate \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate \"\
    3\" \"11\") = \"8\" ]]\n    [[ $(candidate \"100\" \"101\") = \"1\" ]]\n    [[\
    \ $(candidate \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate \"31\" \"5\") = \"\
    3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024854
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \tlocal n=$1\n\tlocal p=$2\n\tlocal r=0\n\tlocal m=1\n\t\n\twhile [ \"$n\" -gt\
    \ 0 ]; do\n\t\tr=$((r + m * (n & 1)))\n\t\tn=$((n >> 1))\n\t\tm=$((m * m % p))\n\
    \tdone\n\t\n\techo $r\n}\n\ncandidate() {\n    modp \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"1101\" \"\
    101\") = \"2\" ]]\n    [[ $(candidate \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate\
    \ \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate \"100\" \"101\") = \"1\" ]]\n \
    \   [[ $(candidate \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate \"31\" \"5\")\
    \ = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024854
- exit_code: 0
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \  if [ $# -ne 2 ]; then\n    echo \"Usage: $(basename $0) n p\" >&2\n    return\
    \ 1\n  fi\n  awk -v n=\"$1\" -v p=\"$2\" 'BEGIN {\n    s = 1;\n    for (i = 1;\
    \ i <= n; i++) {\n      s = (s * 2) % p;\n    }\n    print s;\n  }'\n}\n\ncandidate()\
    \ {\n    modp \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3\" \"5\"\
    ) = \"3\" ]]\n    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n    [[ $(candidate\
    \ \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\") = \"8\" ]]\n   \
    \ [[ $(candidate \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate \"30\" \"5\"\
    ) = \"4\" ]]\n    [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660024854
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    local a=$1\n    local b=$2\n    # BUG: you can't use the pipe form of bc's\
    \ modulus operator because\n    # large numbers are always interpreted as octal.\
    \ (long)\n    if [[ $b == 2 ]]; then\n        bc <<< \"x=l($a)/l(2); if(x==int(x)){print\
    \ 1;exit;}print 0;exit;\"\n    else\n        bc <<< \"x=l($a)/l($b); if(x==int(x)){print\
    \ $b;exit;}print $a%$b;exit;\"\n    fi\n}\n\ncandidate() {\n    modp \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n    [[\
    \ $(candidate \"1101\" \"101\") = \"2\" ]]\n    [[ $(candidate \"0\" \"101\")\
    \ = \"1\" ]]\n    [[ $(candidate \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate\
    \ \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate \"30\" \"5\") = \"4\" ]]\n \
    \   [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '(standard_in) 1: syntax error

    '
  stdout: ''
  timestamp: 1660024854
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \  local n=\"$1\"\n  local p=\"$2\"\n  echo \"$n\" | ./bc.sh -l -e \"\n    auto\
    \ a;\n    a = 1;\n    while (a < $p) {\n      if (0 == $n % 2) {\n        a =\
    \ a * 2;\n        $n = $n / 2;\n      } else {\n        a = (a + $p) % 2;\n  \
    \      $n = ($n - 1) / 2;\n      }\n    }\n    print a;\n  \"\n}\n\ncandidate()\
    \ {\n    modp \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3\" \"5\"\
    ) = \"3\" ]]\n    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n    [[ $(candidate\
    \ \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\") = \"8\" ]]\n   \
    \ [[ $(candidate \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate \"30\" \"5\"\
    ) = \"4\" ]]\n    [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmp96v02ju6.sh: line 19: ./bc.sh: No such file or directory

    '
  stdout: ''
  timestamp: 1660024854
- exit_code: 2
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \tif [ \"$2\" == \"0\" ]; then\n\t\treturn 1\n\tfi\n\tif [ \"$1\" == \"0\" ];\
    \ then\n\t\techo \"1\"\n\t\treturn 0\n\tfi\n\t# normalize\n\tlocal x=$(echo \"\
    $1\" | sed 's/0*$//g')\n\tlocal q=$(echo \"$2\" | sed 's/0*$//g')\n\tif [ \"$x\"\
    \ == \"\" ]; then\n\t\techo \"1\"\n\t\treturn 0\n\tfi\n\tif [ \"$q\" == \"\" ];\
    \ then\n\t\treturn 1\n\tfi\n\t#\n\tlocal x_len=$(echo -n \"$x\" | wc -c)\n\tlocal\
    \ q_len=$(echo -n \"$q\" | wc -c)\n\t#\n\tif [ \"$x_len\" -gt \"$q_len\" ]; then\n\
    \t\tlocal x_rest=$(echo \"$x\" | tail -c +$(( q_len + 1 )))\n\t\tlocal r=$(modp\
    \ \"$x_rest\" \"$q\")\n\t\techo \"$(( 10 ** q_len * $(echo \"$x\" | head -c \"\
    $q_len\") ))\"\n\t\techo \"$(( 10 ** q_len * $(echo \"$x\" | head -c \"$q_len\"\
    ) ))\" | bc -l\n\t\t#echo \"$(( (10 ** q_len * $(echo \"$x\" | head -c \"$q_len\"\
    )) * $r ))\"\n\t\t#echo \"$(( 10 ** q_len * $(echo \"$x\" | head -c \"$q_len\"\
    ) ))\" | bc -l\n\t\t#echo \"$(( (10 ** q_len * $(echo \"$x\" | head -c \"$q_len\"\
    )) * $r ))\" | bc -l\n\t\t#echo \"$(( (10 ** q_len * $(echo \"$x\" | head -c \"\
    $q_len\")) * $r ))\" | bc -l\n\t\t#echo \"$(( 10 ** q_len * $(echo \"$x\" | head\
    \ -c \"$q_len\") + $r ))\"\n\t\t#echo \"$(( 10 ** q_len * $(echo \"$x\" | head\
    \ -c \"$q_len\") + $r ))\"\n}\n\ncandidate() {\n    modp \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"\
    1101\" \"101\") = \"2\" ]]\n    [[ $(candidate \"0\" \"101\") = \"1\" ]]\n   \
    \ [[ $(candidate \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate \"100\" \"101\"\
    ) = \"1\" ]]\n    [[ $(candidate \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate\
    \ \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpbo788m1u.sh: line 49: syntax error near unexpected token `}''

    /tmp/tmpbo788m1u.sh: line 49: `}''

    '
  stdout: ''
  timestamp: 1660024854
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \  local n=$1\n  local p=$2\n  local a=1\n  while [[ $n -gt 0 ]]; do\n    if [[\
    \ $((n&1)) -eq 1 ]]; then\n      a=$((a*2%p))\n    fi\n    n=$((n>>1))\n  done\n\
    \  echo $a\n}\n\ncandidate() {\n    modp \"$@\"\n}\n\nset -e\nrun_test() {\n \
    \   [[ $(candidate \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"1101\" \"101\"\
    ) = \"2\" ]]\n    [[ $(candidate \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate\
    \ \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate \"100\" \"101\") = \"1\" ]]\n \
    \   [[ $(candidate \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate \"31\" \"5\")\
    \ = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024854
- exit_code: -1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \tset -e\n\tlocal tmp=\"$(mktemp)\"\n\tlocal res=\"1\"\n\tlocal n=\"$1\"\n\tlocal\
    \ p=\"$2\"\n\t[ \"0\" = \"${n}\" ] && echo \"${res}\" && return 0\n\twhile [ \"\
    \" != \"${n}\" ]; do\n\t\tlocal bit=\"$(echo \"${n}\" | tail -c1)\"\n\t\t[ \"\
    1\" = \"${bit}\" ] && res=\"$(echo \"(${res}*2)%${p}\" | bc -l)\"\n\t\tn=\"$(echo\
    \ \"${n}\" | head -c-1)\"\n\t\tres=\"$(echo \"(${res}*${res})%${p}\" | bc -l)\"\
    \n\tdone\n\techo \"${res}\"\n}\n\ncandidate() {\n    modp \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"\
    1101\" \"101\") = \"2\" ]]\n    [[ $(candidate \"0\" \"101\") = \"1\" ]]\n   \
    \ [[ $(candidate \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate \"100\" \"101\"\
    ) = \"1\" ]]\n    [[ $(candidate \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate\
    \ \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: Timeout
  stderr: <_io.TextIOWrapper name=62 encoding='utf-8'>
  stdout: <_io.TextIOWrapper name=45 encoding='utf-8'>
  timestamp: 1660024859
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \tlocal n=$1\n\tlocal p=$2\n\tlocal n2\n\twhile true; do\n\t\tn2=$((n*2%p))\n\t\
    \tif [[ ${#n2} -eq 1 ]]; then\n\t\t\tbreak\n\t\tfi\n\t\tn=$n2\n\tdone\n\techo\
    \ $n2\n}\n\ncandidate() {\n    modp \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
    \ $(candidate \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"1101\" \"101\") =\
    \ \"2\" ]]\n    [[ $(candidate \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate \"\
    3\" \"11\") = \"8\" ]]\n    [[ $(candidate \"100\" \"101\") = \"1\" ]]\n    [[\
    \ $(candidate \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate \"31\" \"5\") = \"\
    3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024854
- exit_code: -1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \tlocal num=$1\n\tlocal mod=$2\n\tlocal bin=$(printf \"%d\" $num | sed -r 's/^0b(.*)/\\\
    1/')\n\n\tif [[ $bin == \"0\" ]]; then\n\t\techo 1\n\t\treturn\n\tfi\n\n\tlocal\
    \ bits=$(echo \"$bin\" | wc -c)\n\tlocal odd=$(echo \"$bin\" | cut -c $bits)\n\
    \tlocal even=$(echo \"$bin\" | cut -c 1-$(( $bits - 1)))\n\n\tif [[ $odd == \"\
    1\" ]]; then\n\t\techo $(( ($(modp $even $mod) * $(modp $even $mod)) % $mod ))\n\
    \telse\n\t\techo $(( ($(modp $even $mod) * $(modp $even $mod) * 2) % $mod ))\n\
    \tfi\n}\n\ncandidate() {\n    modp \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n \
    \   [[ $(candidate \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\"\
    ) = \"8\" ]]\n    [[ $(candidate \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate\
    \ \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\n\
    run_test"
  status: Timeout
  stderr: <_io.TextIOWrapper name=66 encoding='utf-8'>
  stdout: <_io.TextIOWrapper name=61 encoding='utf-8'>
  timestamp: 1660024859
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    # 2^n modulo 101\n    powp() {\n        if [ \"$1\" == \"0\" ]; then\n  \
    \          echo \"1\"\n        else\n            a=\"$(powp \"$(($1-1))\")\"\n\
    \            echo \"$((($a*2)%$2))\"\n        fi\n    }\n    powp \"$1\"\n}\n\n\
    candidate() {\n    modp \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n \
    \   [[ $(candidate \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\"\
    ) = \"8\" ]]\n    [[ $(candidate \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate\
    \ \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\n\
    run_test"
  status: SyntaxError
  stderr: '/tmp/tmpq2dqjl_w.sh: line 23: (1*2)%: syntax error: operand expected (error
    token is "%")

    /tmp/tmpq2dqjl_w.sh: line 23: (*2)%: syntax error: operand expected (error token
    is "*2)%")

    /tmp/tmpq2dqjl_w.sh: line 23: (*2)%: syntax error: operand expected (error token
    is "*2)%")

    '
  stdout: ''
  timestamp: 1660024854
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \tlocal a=\"$1\"\n\tlocal p=\"$2\"\n\tlocal modp=\"1\"\n\tfor (( i=0; i<${#a};\
    \ i++ )); do\n\t\t(( modp *= modp ))\n\t\t(( modp %= p ))\n\t\tif (( ${a:$i:1}\
    \ )); then\n\t\t\t(( modp *= 2 ))\n\t\t\t(( modp %= p ))\n\t\tfi\n\tdone\n\techo\
    \ $modp\n}\n\ncandidate() {\n    modp \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
    \ $(candidate \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"1101\" \"101\") =\
    \ \"2\" ]]\n    [[ $(candidate \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate \"\
    3\" \"11\") = \"8\" ]]\n    [[ $(candidate \"100\" \"101\") = \"1\" ]]\n    [[\
    \ $(candidate \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate \"31\" \"5\") = \"\
    3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024854
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \  local n=$1\n  local p=$2\n  local n_numbits=$(num_bits $n)\n  local n_orig=$n\n\
    \  local n_numbits_orig=$n_numbits\n  local result=1\n  local i=0\n  while [ $i\
    \ -lt $n_numbits ]\n  do\n    local current_bit=$(get_bit $n $i)\n    if [ $current_bit\
    \ -eq 1 ]\n    then\n      let n=$n-$(two_power $i)\n      let i=$i+1\n      let\
    \ result=$result*$result\n      let result=$result%$p\n    else\n      let i=$i+1\n\
    \      let result=$result*$result\n      let result=$result%$p\n    fi\n  done\n\
    \  echo $result\n}\n\ncandidate() {\n    modp \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"1101\" \"\
    101\") = \"2\" ]]\n    [[ $(candidate \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate\
    \ \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate \"100\" \"101\") = \"1\" ]]\n \
    \   [[ $(candidate \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate \"31\" \"5\")\
    \ = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmpx1q_sarg.sh: line 19: num_bits: command not found

    /tmp/tmpx1q_sarg.sh: line 24: [: 0: unary operator expected

    '
  stdout: ''
  timestamp: 1660024854
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \tlocal i=$1\n\tlocal p=$2\n\twhile [ ${#i} -ge $(( ${#p} - 1 )) ]; do\n\t\tlocal\
    \ m=$(($i % $p))\n\t\ti=$(($i / $p))\n\t\ti=\"$m$i\"\n\tdone\n\techo \"$i\"\n\
    }\n\ncandidate() {\n    modp \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n \
    \   [[ $(candidate \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\"\
    ) = \"8\" ]]\n    [[ $(candidate \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate\
    \ \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\n\
    run_test"
  status: Exception
  stderr: '/tmp/tmp21wezamy.sh: line 20: 09: value too great for base (error token
    is "09")

    '
  stdout: ''
  timestamp: 1660024854
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    p=$(echo \"$2\" | tr -d \" \")\n    exp=$(echo \"$1\" | tr -d \" \")\n  \
    \  tmp=\"0 1\"\n    for (( i=1; i<${#exp}; i++ ))\n    do\n        tmp=\"$(echo\
    \ \"$tmp\" | awk '{print ($1*$1)%'$p'}') $(echo \"$tmp\" | awk '{print ($1*$2)%'$p'}')\"\
    \n    done\n    echo \"$tmp\" | cut -d\" \" -f$(echo \"$exp\" | sed 's/./& /g'\
    \ | sed 's/0 //g' | sed 's/1 /1/g' | tr -d \" \" | bc)\n}\n\ncandidate() {\n \
    \   modp \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3\" \"5\") =\
    \ \"3\" ]]\n    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n    [[ $(candidate\
    \ \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\") = \"8\" ]]\n   \
    \ [[ $(candidate \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate \"30\" \"5\"\
    ) = \"4\" ]]\n    [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024854
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \tlocal X=\"$1\"\n\tlocal P=\"$2\"\n\t[[ -z \"$X\" ]] && return 1\n\t[[ -z \"\
    $P\" ]] && return 1\n\t[[ \"$X\" == \"0\" ]] && echo \"1\" && return 0\n\tlocal\
    \ t=\"1\"\n\twhile ((X>0)); do\n\t\tif (((X&1)==1)); then\n\t\t\tt=$(modmul \"\
    $t\" \"$t\" \"$P\")\n\t\tfi\n\t\tX=$((X>>1))\n\t\tt=$(modmul \"$t\" \"$t\" \"\
    $P\")\n\tdone\n\techo \"$t\"\n}\n\ncandidate() {\n    modp \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"\
    1101\" \"101\") = \"2\" ]]\n    [[ $(candidate \"0\" \"101\") = \"1\" ]]\n   \
    \ [[ $(candidate \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate \"100\" \"101\"\
    ) = \"1\" ]]\n    [[ $(candidate \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate\
    \ \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmpkv51q8uo.sh: line 25: modmul: command not found

    /tmp/tmpkv51q8uo.sh: line 28: modmul: command not found

    /tmp/tmpkv51q8uo.sh: line 25: modmul: command not found

    /tmp/tmpkv51q8uo.sh: line 28: modmul: command not found

    '
  stdout: ''
  timestamp: 1660024854
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \t[[ \"${#1}\" -lt 100 ]] || {\n\t\techo 'ERROR: \"$1\" is too large in modp'\n\
    \t\texit 1\n\t}\n\t[[ \"${#2}\" -lt 100 ]] || {\n\t\techo 'ERROR: \"$2\" is too\
    \ large in modp'\n\t\texit 1\n\t}\n\techo \"$((2**$1 % $2))\"\n}\n\ncandidate()\
    \ {\n    modp \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3\" \"5\"\
    ) = \"3\" ]]\n    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n    [[ $(candidate\
    \ \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\") = \"8\" ]]\n   \
    \ [[ $(candidate \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate \"30\" \"5\"\
    ) = \"4\" ]]\n    [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024854
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    local n=$1\n    local p=$2\n    local r\n    local rv\n    local q\n    local\
    \ t\n    local u\n\n    if [[ $n == 0 ]]; then\n        echo 1\n        return\n\
    \    fi\n\n    t=1\n    u=$p\n    rv=$(((p-1)/2))\n    while [[ $n -ne 0 ]]; do\n\
    \        if [[ $((n&1)) == 1 ]]; then\n            t=$((t*r%p))\n        fi\n\
    \        r=$((r*r%p))\n        n=$((n>>1))\n    done\n    echo $t\n}\n\ncandidate()\
    \ {\n    modp \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3\" \"5\"\
    ) = \"3\" ]]\n    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n    [[ $(candidate\
    \ \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\") = \"8\" ]]\n   \
    \ [[ $(candidate \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate \"30\" \"5\"\
    ) = \"4\" ]]\n    [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024854
- exit_code: 0
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \t# Note: we are performing modular exponentiation,\n\t# so this function may\
    \ be called recursively, but\n\t# to a depth of no more than log(x) times (where\
    \ x\n\t# is the input), so we don't need to worry about it\n\t# overflowing the\
    \ stack.\n\tif [ \"$1\" -eq \"0\" ]; then\n\t\techo \"1\"\n\t\treturn\n\tfi\n\t\
    # If the exponent is even, we can reduce the\n\t# problem by half.\n\tif [ $((\
    \ $1 % 2 )) -eq 0 ]; then\n\t\tlocal temp=$( modp $(( $1 / 2 )) $2 )\n\t\t# (x*x)\
    \ % p = (x%p * x%p) % p\n\t\techo $(( ( ( $temp * $temp ) % $2 ) ))\n\t\treturn\n\
    \tfi\n\t# If the exponent is odd, we just have to\n\t# perform the full calculation.\n\
    \tlocal temp=$( modp $(( ( $1 - 1 ) / 2 )) $2 )\n\t# (x*x*2) % p = (x%p * x%p\
    \ * 2%p) % p\n\techo $(( ( ( ( $temp * $temp ) % $2 ) * 2 ) % $2 ))\n}\n\ncandidate()\
    \ {\n    modp \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3\" \"5\"\
    ) = \"3\" ]]\n    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n    [[ $(candidate\
    \ \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\") = \"8\" ]]\n   \
    \ [[ $(candidate \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate \"30\" \"5\"\
    ) = \"4\" ]]\n    [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660024854
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    echo \"$1\" | bc -l |\n    (bc -l &&\n     echo \"define modp(x,y) {\n  \
    \   auto out\n     out = x %% y\n     if (out < 0) {\n         out += y\n    \
    \ }\n     return out\n }\n p = $2\n if (p <= 1) {\n     1\n } else {\n     p\n\
    \ }\n 2 ^ $1\n modp(2 ^ $1, p)\n \") | tail -1\n}\n\ncandidate() {\n    modp \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n\
    \    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n    [[ $(candidate \"0\" \"\
    101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate\
    \ \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate \"30\" \"5\") = \"4\" ]]\n \
    \   [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024854
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    local n=$1; local p=$2\n    local prod=1\n    local i=0\n    for (( i=0;\
    \ i<${#n}; i++ )); do\n        if [[ ${n:$i:1} -eq 1 ]]; then\n            prod=$((prod*2%p))\n\
    \        fi\n        if [[ $i -lt $((${#n}-1)) ]]; then\n            prod=$((prod*prod%p))\n\
    \        fi\n    done\n    echo $prod\n}\n\ncandidate() {\n    modp \"$@\"\n}\n\
    \nset -e\nrun_test() {\n    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate\
    \ \"1101\" \"101\") = \"2\" ]]\n    [[ $(candidate \"0\" \"101\") = \"1\" ]]\n\
    \    [[ $(candidate \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate \"100\" \"101\"\
    ) = \"1\" ]]\n    [[ $(candidate \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate\
    \ \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024854
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    echo \"$1\" | awk '{print $1^'$2'%'$3'}'\n}\n\ncandidate() {\n    modp \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n\
    \    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n    [[ $(candidate \"0\" \"\
    101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate\
    \ \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate \"30\" \"5\") = \"4\" ]]\n \
    \   [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: 'awk: cmd. line:1: {print $1^5%}

    awk: cmd. line:1:             ^ syntax error

    '
  stdout: ''
  timestamp: 1660024854
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \  local -i p=2**${#1}\n\n  echo $(( ${1} % ${2} ))\n}\n\ncandidate() {\n    modp\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n\
    \    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n    [[ $(candidate \"0\" \"\
    101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate\
    \ \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate \"30\" \"5\") = \"4\" ]]\n \
    \   [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024854
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \tif [ $# -ne 2 ]; then\n\t\techo \"Usage: $0 <integer> <integer>\"\n\t\treturn\
    \ 1\n\tfi\n\tpython -c \"print(pow($1,$2,$2))\"\n}\n\ncandidate() {\n    modp\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n\
    \    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n    [[ $(candidate \"0\" \"\
    101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate\
    \ \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate \"30\" \"5\") = \"4\" ]]\n \
    \   [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024854
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    if [[ -z \"$1\" || -z \"$2\" ]]; then\n        echo \"modp: two args required\"\
    \n        return 1\n    fi\n    declare -i x=\"$1\"\n    declare -i p=\"$2\"\n\
    \    declare -i y\n    while [ \"$x\" -ge \"$p\" ]; do\n        y=$x\n       \
    \ x=0\n        while [ \"$y\" -gt 0 ]; do\n            declare -i z\n        \
    \    z=$((y%2))\n            y=$((y/2))\n            x=$((2*x+z))\n        done\n\
    \        x=$((x-p))\n    done\n    echo \"$x\"\n}\n\ncandidate() {\n    modp \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n\
    \    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n    [[ $(candidate \"0\" \"\
    101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate\
    \ \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate \"30\" \"5\") = \"4\" ]]\n \
    \   [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024854
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    local bin=$1\n    local p=$2\n    local res=\"1\"\n    for c in $(seq 1 ${#bin});\
    \ do\n        c=$(expr ${c} - 1)\n        if [[ ${bin:${c}:1} -eq 1 ]]; then\n\
    \            res=$((${res} * 2))\n            res=$((${res} % ${p}))\n       \
    \ fi\n    done\n    echo ${res}\n}\n\ncandidate() {\n    modp \"$@\"\n}\n\nset\
    \ -e\nrun_test() {\n    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate\
    \ \"1101\" \"101\") = \"2\" ]]\n    [[ $(candidate \"0\" \"101\") = \"1\" ]]\n\
    \    [[ $(candidate \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate \"100\" \"101\"\
    ) = \"1\" ]]\n    [[ $(candidate \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate\
    \ \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024854
- exit_code: -1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    local i\n    local p=$2\n    local exp=$1\n    local res=1\n    local modinv\n\
    \    local sqrmod=3\n    local bitmask=1\n    local bitsize=1\n    local bitshift\n\
    \    local sqr\n    local sqrexp=1\n    local bit\n    local work\n    local inv\n\
    \n    if [ $(($1 & 1)) -eq 0 ]; then\n        echo \"1\"\n        return\n   \
    \ fi\n\n    # Make sure that p is odd.\n    if [ $(($p & 1)) -eq 0 ]; then\n \
    \       echo \"Invalid p=$p. This is not an odd number.\"\n        return\n  \
    \  fi\n\n    # If a is larger than p, reduce a modulo p.\n    if [ $1 -ge $p ];\
    \ then\n        exp=$(($1 % $p))\n    fi\n\n    # Compute the size of p.\n   \
    \ bitsize=1\n    i=$p\n    while [ $i -gt 1 ]; do\n        i=$(($i >> 1))\n  \
    \      bitsize=$(($bitsize + 1))\n    done\n\n    bitshift=$(($bitsize - 1))\n\
    \    bitmask=$((1 << $bitshift))\n\n    # Compute modular inverse of 2 modulo\
    \ p.\n    sqrmod=$((3 % $p))\n    inv=0\n    while [ $inv -eq 0 ]; do\n      \
    \  if [ $(($sqrmod * $sqrmod % $p)) -eq 2 ]; then\n            inv=$sqrmod\n \
    \       fi\n        sqrmod=$((($sqrmod * $sqrmod) % $p))\n    done\n\n    modinv=$inv\n\
    \n    # Check if a == 0, 1, or 2.\n    if [ $exp -eq 0 ]; then\n        echo \"\
    1\"\n        return\n    fi\n    if [ $exp -eq 1 ]; then\n        echo \"2\"\n\
    \        return\n    fi\n    if [ $exp -eq 2 ]; then\n        echo \"4\"\n   \
    \     return\n    fi\n\n    # Reduce a to a' := a / 2.\n    exp=$(($exp >> 1))\n\
    \n    # From now on, the modulus is the odd number p.\n    # The algorithm works\
    \ in time O(\n}\n\ncandidate() {\n    modp \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"1101\" \"101\"\
    ) = \"2\" ]]\n    [[ $(candidate \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate\
    \ \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate \"100\" \"101\") = \"1\" ]]\n \
    \   [[ $(candidate \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate \"31\" \"5\")\
    \ = \"3\" ]]\n}\n\nrun_test"
  status: Timeout
  stderr: <_io.TextIOWrapper name=52 encoding='utf-8'>
  stdout: <_io.TextIOWrapper name=41 encoding='utf-8'>
  timestamp: 1660024859
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \  if [[ -z \"$1\" || -z \"$2\" ]]; then\n    return 1\n  fi\n  # Python 3 is\
    \ the standard for EC2s.\n  # shellcheck disable=SC2086\n  python3 -c \"print(pow($1,\
    \ $2, $3))\"\n}\n\ncandidate() {\n    modp \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"1101\" \"101\"\
    ) = \"2\" ]]\n    [[ $(candidate \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate\
    \ \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate \"100\" \"101\") = \"1\" ]]\n \
    \   [[ $(candidate \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate \"31\" \"5\")\
    \ = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024854
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \tlocal n p N P x t bit i\n\tn=\"$1\"\n\tp=\"$2\"\n\tN=\"$n\"\n\tP=\"$p\"\n\t\
    x=1\n\tt=2\n\tfor ((i=${#n}-1; i>=0; i--)); do\n\t\tbit=\"${n:$i:1}\"\n\t\tif\
    \ [[ \"$bit\" == \"1\" ]]; then\n\t\t\tN=$(( N * t % P ))\n\t\tfi\n\t\tif [[ $N\
    \ -eq 1 ]]; then\n\t\t\tx=0\n\t\t\tbreak\n\t\tfi\n\t\tt=$(( t * t % P ))\n\tdone\n\
    \tif [[ $x -eq 1 ]]; then\n\t\techo $(( n % p ))\n\telse\n\t\techo $(( p - 1 ))\n\
    \tfi\n}\n\ncandidate() {\n    modp \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n \
    \   [[ $(candidate \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\"\
    ) = \"8\" ]]\n    [[ $(candidate \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate\
    \ \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\n\
    run_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024854
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \  local T=$(trim \"$1\")\n  local P=$(trim \"$2\")\n  local L\n  if [ -z \"$T\"\
    \ ] ; then\n    # Empty input return 0\n    echo \"0\"\n  elif [ \"${T:0:1}\"\
    \ = \"0\" ] ; then\n    # Leading zero get removed\n    echo \"0\"\n  elif [ $(cmp\
    \ $T 0) -eq 0 ] ; then\n    # 0 return 1\n    echo \"1\"\n  elif [ $(cmp $T 1)\
    \ -eq 0 ] ; then\n    # 1 return 1\n    echo \"1\"\n  elif [ $(cmp $T -1) -eq\
    \ 0 ] ; then\n    # -1 return $P-1\n    sub $P 1\n  elif [ $(cmp $T 2) -eq 0 ]\
    \ ; then\n    # 2 is a special case\n    # Will return $P-1 if $P is even and\
    \ return $P-2 if $P is odd\n    if [ $(modp 2 $P) -eq 0 ] ; then\n      # P is\
    \ even\n      sub $P 1\n    else\n      # P is odd\n      sub $P 2\n    fi\n \
    \ elif [ $(modp $T 2) -eq 0 ] ; then\n    # Even number\n    # $T^2 mod $P = $(modp\
    \ $(modp $T 2) $P)\n    modp $(modp $T 2) $P\n  else\n    # Odd number\n    #\
    \ $(modp $T 2) is an even number,\n    # $T^2 mod $P = $(modp $(modp $T 2) $P)\n\
    \    # $T^n mod $P = $T * $(modp $T^(n-1) $P)\n    # A * B mod P = (A mod P) *\
    \ (B mod P) mod P\n    mul $(modp $T 2) $(modp $(mul $T $(modp $(mul 2 -1) $P))\
    \ $P)\n  fi\n}\n\ncandidate() {\n    modp \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"1101\" \"101\"\
    ) = \"2\" ]]\n    [[ $(candidate \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate\
    \ \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate \"100\" \"101\") = \"1\" ]]\n \
    \   [[ $(candidate \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate \"31\" \"5\")\
    \ = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmpimgd3163.sh: line 17: trim: command not found

    /tmp/tmpimgd3163.sh: line 18: trim: command not found

    '
  stdout: ''
  timestamp: 1660024854
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \tlocal n=\"$1\"\n\tlocal p=\"$2\"\n\tlocal x=\"$(printf '%d' \"0b$n\")\"\n\t\
    local y=\"$(printf '%d' \"0b$p\")\"\n\tlocal z=\"$x\"\n\tlocal a=\"1\"\n\twhile\
    \ [ $((z/2)) -ne 0 ]; do\n\t\tlet \"z = z/2\"\n\t\tlet \"a = (a*a) % y\"\n\t\t\
    if [ $((z%2)) -ne 0 ]; then\n\t\t\tlet \"a = (a*x) % y\"\n\t\tfi\n\tdone\n\techo\
    \ \"$a\"\n}\n\ncandidate() {\n    modp \"$@\"\n}\n\nset -e\nrun_test() {\n   \
    \ [[ $(candidate \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"1101\" \"101\"\
    ) = \"2\" ]]\n    [[ $(candidate \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate\
    \ \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate \"100\" \"101\") = \"1\" ]]\n \
    \   [[ $(candidate \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate \"31\" \"5\")\
    \ = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmp08kwam8_.sh: line 19: printf: 0b3: invalid number

    /tmp/tmp08kwam8_.sh: line 20: printf: 0b5: invalid number

    '
  stdout: ''
  timestamp: 1660024854
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \  echo \"$1\" | bc -l \\\n    | awk \"{print \\\"scale=${#2};2^\\$1%$2\\\" |\
    \ bc -l}\"\n}\n\ncandidate() {\n    modp \"$@\"\n}\n\nset -e\nrun_test() {\n \
    \   [[ $(candidate \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"1101\" \"101\"\
    ) = \"2\" ]]\n    [[ $(candidate \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate\
    \ \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate \"100\" \"101\") = \"1\" ]]\n \
    \   [[ $(candidate \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate \"31\" \"5\")\
    \ = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: 'sh: 1: 0: not found

    '
  stdout: ''
  timestamp: 1660024854
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    local X=$1\n    local P=$2\n    local c=0\n    local d=1\n    local TMP\n\
    \    while [[ $X -gt 0 ]]; do\n        if [[ $(( X & 1 )) -eq 1 ]]; then\n   \
    \         c=$(( (c + d) % P ))\n        fi\n        X=$(( X >> 1 ))\n        d=$((\
    \ (d * 2) % P ))\n    done\n    echo $c\n}\n\ncandidate() {\n    modp \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n    [[\
    \ $(candidate \"1101\" \"101\") = \"2\" ]]\n    [[ $(candidate \"0\" \"101\")\
    \ = \"1\" ]]\n    [[ $(candidate \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate\
    \ \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate \"30\" \"5\") = \"4\" ]]\n \
    \   [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024854
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \  local n=\"$1\"\n  local p=\"$2\"\n  if [[ \"$n\" == \"0\" ]]; then\n    echo\
    \ 1\n    return\n  fi\n  local bit_length=\"$(bit_length $n)\"\n  local result=\"\
    1\"\n  local power=\"2\"\n  local i\n  for ((i=1; i<=bit_length; i++)); do\n \
    \   if (($(get_bit $n $i) == 1)); then\n      result=$(($result * $power % $p))\n\
    \    fi\n    power=$(($power * $power % $p))\n  done\n  echo $result\n}\n\ncandidate()\
    \ {\n    modp \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3\" \"5\"\
    ) = \"3\" ]]\n    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n    [[ $(candidate\
    \ \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\") = \"8\" ]]\n   \
    \ [[ $(candidate \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate \"30\" \"5\"\
    ) = \"4\" ]]\n    [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmpoq9e95tu.sh: line 23: bit_length: command not found

    '
  stdout: ''
  timestamp: 1660024854
- exit_code: 0
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    local n=\"$1\"\n    local p=\"$2\"\n    local f=\"$(bc <<< \"2^$n\")\"\n\
    \    echo \"$(bc <<< \"$f % $p\")\"\n}\n\ncandidate() {\n    modp \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate\
    \ \"1101\" \"101\") = \"2\" ]]\n    [[ $(candidate \"0\" \"101\") = \"1\" ]]\n\
    \    [[ $(candidate \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate \"100\" \"101\"\
    ) = \"1\" ]]\n    [[ $(candidate \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate\
    \ \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660024854
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    if [[ $1 == \"0\" ]]; then\n        echo \"1\"\n        return\n    fi\n\
    \    # We set the random number generator\n    local b=$(echo \"$1\" | sed 's/^0*//')\n\
    \    local a=$(echo \"$2\" | sed 's/^0*//')\n    local r\n    # We get the radix\
    \ (the number of digits base 2)\n    local radix=$(echo \"obase=2; ibase=10; ${a}\"\
    \ | bc)\n    radix=${#radix}\n    local result=\"1\"\n    local counter=0\n  \
    \  while [[ ${counter} -lt ${radix} ]]; do\n        result=$((${result}*${result}))\n\
    \        result=$((${result}%${a}))\n        counter=$((${counter}+1))\n    done\n\
    \    # We get the random radix using the seed as the digits\n    r=$(($(echo \"\
    ${b}\" | sed 's/[0-1]//g' | sed 's/./&/g' | sed 's/[^0-9]/ /g' | tr ' ' '\\n'\
    \ | xargs -I {} echo \"${RANDOM}+{}\" | bc)))\n    counter=0\n    while [[ ${counter}\
    \ -lt ${r} ]]; do\n        result=$((${result}*${result}))\n        result=$((${result}%${a}))\n\
    \        counter=$((${counter}+1))\n    done\n    if [[ $1 != \"0\" ]]; then\n\
    \        for i in $(echo \"$1\" | rev | grep -o .); do\n            if [[ ${i}\
    \ == \"1\" ]]; then\n                result=$((${result}*${result}))\n       \
    \         result=$((${result}%${a}))\n            fi\n            result=$((${result}*${result}))\n\
    \            result=$((${result}%${a}))\n        done\n    fi\n    echo \"${result}\"\
    \n}\n\ncandidate() {\n    modp \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n \
    \   [[ $(candidate \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\"\
    ) = \"8\" ]]\n    [[ $(candidate \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate\
    \ \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\n\
    run_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024854
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \tbc <<< \"\n\t\tp=${2};\n\t\tt=1;\n\t\tn=0;\n\t\td=0;\n\t\tb=2;\n\t\tif(p > 1)\
    \ {\n\t\t\twhile(b <= p) {\n\t\t\t\tb=b*2;\n\t\t\t\tn=n+1;\n\t\t\t}\n\t\t\tb=b/2;\n\
    \t\t\tn=n-1;\n\t\t\td=p-b;\n\t\t\tfor(i=1; i<=n; i++) {\n\t\t\t\tt=t*t;\n\t\t\t\
    \tt=t-2*d*t;\n\t\t\t\twhile(t<0) {\n\t\t\t\t\tt=t+p;\n\t\t\t\t}\n\t\t\t\twhile(t>=p)\
    \ {\n\t\t\t\t\tt=t-p;\n\t\t\t\t}\n\t\t\t\td=2*d;\n\t\t\t\tif(d>=p) {\n\t\t\t\t\
    \td=d-p;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprint t;\n\t\"\n}\n\ncandidate() {\n\
    \    modp \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3\" \"5\") =\
    \ \"3\" ]]\n    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n    [[ $(candidate\
    \ \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\") = \"8\" ]]\n   \
    \ [[ $(candidate \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate \"30\" \"5\"\
    ) = \"4\" ]]\n    [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024854
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \  local n=\"$1\"\n  local p=\"$2\"\n  # Find the largest power of 2 dividing\
    \ $n.\n  local i=0\n  local m=$(( 1 << i ))\n  while [[ $m -le $n ]]; do\n   \
    \ i=$(( i + 1 ))\n    m=$(( 1 << i ))\n  done\n  # Compute $n modulo $p.\n  local\
    \ v=$(( 1 << (i - 1) ))\n  for ((; i >= 0; i--)); do\n    m=$(( 1 << i ))\n  \
    \  if [[ $(( m & n )) -ne 0 ]]; then\n      v=$(( (v * v) % p ))\n    else\n \
    \     v=$(( (v * v * 2) % p ))\n    fi\n  done\n  echo $v\n}\n\ncandidate() {\n\
    \    modp \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3\" \"5\") =\
    \ \"3\" ]]\n    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n    [[ $(candidate\
    \ \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\") = \"8\" ]]\n   \
    \ [[ $(candidate \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate \"30\" \"5\"\
    ) = \"4\" ]]\n    [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024854
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    local n=\"$1\"\n    local p=\"$2\"\n    local base=\"$p\"\n    local out=\"\
    1\"\n    local outn\n    local i\n    for ((i=${#n}-1; i>=0; i--)); do\n     \
    \   local c=\"${n:$i:1}\"\n        if [ \"$c\" == \"1\" ]; then\n            out=\"\
    $(($out * $base))\"\n            out=\"$(($out % $p))\"\n        fi\n        base=\"\
    $(($base * $base))\"\n        base=\"$(($base % $p))\"\n    done\n    echo \"\
    $out\"\n}\n\ncandidate() {\n    modp \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
    \ $(candidate \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"1101\" \"101\") =\
    \ \"2\" ]]\n    [[ $(candidate \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate \"\
    3\" \"11\") = \"8\" ]]\n    [[ $(candidate \"100\" \"101\") = \"1\" ]]\n    [[\
    \ $(candidate \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate \"31\" \"5\") = \"\
    3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024854
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \  local n=$1\n  local p=$2\n  local t=1\n  while [ ${#n} -gt 0 ]; do\n    if\
    \ [ \"${n: -1}\" -eq 1 ]; then\n      t=$(( (t * t) % p ))\n    fi\n    n=${n%?}\n\
    \  done\n  echo \"$t\"\n}\n\ncandidate() {\n    modp \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"1101\" \"\
    101\") = \"2\" ]]\n    [[ $(candidate \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate\
    \ \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate \"100\" \"101\") = \"1\" ]]\n \
    \   [[ $(candidate \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate \"31\" \"5\")\
    \ = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024854
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \tif (( $1 == 0 )); then\n\t\techo \"1\"\n\t\treturn\n\tfi\n\t# Compute $1 % $2\n\
    \tmodulus=$(($1 % $2))\n\t# Compute $(2^(n-1)) mod $2\n\tx=$(modp \"$((modulus/2))\"\
    \ \"$2\")\n\tif (( modulus % 2 == 0 )); then\n\t\tx=$((x * x % $2))\n\telse\n\t\
    \tx=$((x * x * 2 % $2))\n\tfi\n\techo \"$x\"\n}\n\ncandidate() {\n    modp \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n\
    \    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n    [[ $(candidate \"0\" \"\
    101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate\
    \ \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate \"30\" \"5\") = \"4\" ]]\n \
    \   [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024854
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \  B=$1\n  # Some versions of bc need the leading zero to treat input as octal.\n\
    \  P=0$2\n  echo \"$(echo \"obase=16; ibase=2; $B\" | bc)%$P\" | bc\n}\n\ncandidate()\
    \ {\n    modp \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3\" \"5\"\
    ) = \"3\" ]]\n    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n    [[ $(candidate\
    \ \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\") = \"8\" ]]\n   \
    \ [[ $(candidate \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate \"30\" \"5\"\
    ) = \"4\" ]]\n    [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024854
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    local num=${1}\n    local p=${2}\n    if [[ -z \"${num}\" ]]; then\n    \
    \    echo \"Error: num not defined\" >&2\n        exit 1\n    fi\n    if [[ -z\
    \ \"${p}\" ]]; then\n        echo \"Error: p not defined\" >&2\n        exit 1\n\
    \    fi\n    while [[ ${num} -ge ${p} ]]; do\n        num=$((${num} - ${p}))\n\
    \    done\n    echo ${num}\n}\n\ncandidate() {\n    modp \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"\
    1101\" \"101\") = \"2\" ]]\n    [[ $(candidate \"0\" \"101\") = \"1\" ]]\n   \
    \ [[ $(candidate \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate \"100\" \"101\"\
    ) = \"1\" ]]\n    [[ $(candidate \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate\
    \ \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024854
- exit_code: -1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    base=$1\n    mod=$2\n    echo \"$base\" | awk -v mod=\"$mod\" '{\n      \
    \  if ($1 == 0) print 1;\n        else {\n            b = $1;\n            while\
    \ (b != 1) {\n                b = b / 2;\n                print b, \",\";\n  \
    \          }\n        }\n    }' | \\\n    awk -v mod=\"$mod\" '\n        BEGIN\
    \ { prod = 1; prev = 1; }\n        {\n            prod = prod * prev;\n      \
    \      prod = prod % mod;\n            prev = $1;\n        }\n        END {\n\
    \            if (prev == 1) {\n                print prod;\n            } else\
    \ {\n                print prod * prev;\n            }\n        }\n    '\n}\n\n\
    candidate() {\n    modp \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n \
    \   [[ $(candidate \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\"\
    ) = \"8\" ]]\n    [[ $(candidate \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate\
    \ \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\n\
    run_test"
  status: Timeout
  stderr: <_io.TextIOWrapper name=44 encoding='utf-8'>
  stdout: <_io.TextIOWrapper name=34 encoding='utf-8'>
  timestamp: 1660024859
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    n=$1\n    p=$2\n    if [ \"$n\" == \"0\" ]; then\n        echo \"1\"\n  \
    \      return\n    fi\n    if [ \"$n\" == \"1\" ]; then\n        echo \"$p\"\n\
    \        return\n    fi\n    if [ \"$(echo \"$n % 2\" | bc)\" == \"0\" ]; then\n\
    \        a=$(modp \"$(echo \"$n / 2\" | bc)\" \"$p\")\n        echo \"$(echo \"\
    ($a * $a) % $p\" | bc)\"\n        return\n    fi\n    a=$(modp \"$(echo \"$n -\
    \ 1\" | bc)\" \"$p\")\n    echo \"$(echo \"($a * $p) % $p\" | bc)\"\n}\n\ncandidate()\
    \ {\n    modp \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3\" \"5\"\
    ) = \"3\" ]]\n    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n    [[ $(candidate\
    \ \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\") = \"8\" ]]\n   \
    \ [[ $(candidate \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate \"30\" \"5\"\
    ) = \"4\" ]]\n    [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024854
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    local input=$1\n    local modulus=$2\n    local result=1\n    local i=0\n\
    \    local pow=0\n    local len=${#input}\n    # (echo \"$input $modulus\" ; echo\
    \ \"$input $modulus\") | bc\n    for ((i=0; i<$len; i++)); do\n        pow=$((pow*2))\n\
    \        if [[ \"$pow\" -ge \"$modulus\" ]]; then\n            pow=$((pow-modulus))\n\
    \        fi\n        if [[ \"${input:$i:1}\" == \"1\" ]]; then\n            result=$((result+pow))\n\
    \            if [[ \"$result\" -ge \"$modulus\" ]]; then\n                result=$((result-modulus))\n\
    \            fi\n        fi\n    done\n    echo \"$result\"\n}\n\ncandidate()\
    \ {\n    modp \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3\" \"5\"\
    ) = \"3\" ]]\n    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n    [[ $(candidate\
    \ \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\") = \"8\" ]]\n   \
    \ [[ $(candidate \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate \"30\" \"5\"\
    ) = \"4\" ]]\n    [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024854
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    echo \"$((2**$1 % $2))\"\n}\n\ncandidate() {\n    modp \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"\
    1101\" \"101\") = \"2\" ]]\n    [[ $(candidate \"0\" \"101\") = \"1\" ]]\n   \
    \ [[ $(candidate \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate \"100\" \"101\"\
    ) = \"1\" ]]\n    [[ $(candidate \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate\
    \ \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024854
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    # Start with the largest power of two.\n    p=1\n    n=$(echo \"obase=10;\
    \ ibase=2; $1\" | bc -l)\n    # Find the largest power of two that is less than\
    \ n.\n    while [ \"$n\" -ge \"$p\" ]; do\n        p=$(($p << 1))\n    done\n\
    \    # Start with our result as 1.\n    result=1\n    # Now work our way down\n\
    \    while [ \"$p\" -ge 1 ]; do\n        # Multiply the current result by the\
    \ result of 2^p mod p.\n        result=$(($result * $(modp_subp \"$p\" \"$2\"\
    )))\n        # Find the next power of two.\n        p=$(($p >> 1))\n        #\
    \ Multiply the current result by the result of 2^p mod p.\n        result=$(($result\
    \ * $(modp_subp \"$p\" \"$2\")))\n        # If the current result is not one,\
    \ then work out the\n        # remainder and store that result.\n        if [\
    \ \"$result\" -ne 1 ]; then\n            result=$(($result % $2))\n        fi\n\
    \    done\n    echo $result\n}\n\ncandidate() {\n    modp \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"\
    1101\" \"101\") = \"2\" ]]\n    [[ $(candidate \"0\" \"101\") = \"1\" ]]\n   \
    \ [[ $(candidate \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate \"100\" \"101\"\
    ) = \"1\" ]]\n    [[ $(candidate \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate\
    \ \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpaasvq5qh.sh: line 29: modp_subp: command not found

    /tmp/tmpaasvq5qh.sh: line 29: 1 * : syntax error: operand expected (error token
    is "* ")

    '
  stdout: ''
  timestamp: 1660024854
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    local b=$1 p=$2\n    local two=2\n    local r=$b\n    if [ \"$r\" -eq 0 ];\
    \ then\n        echo \"$two\"\n        return\n    fi\n    if [ \"$r\" -eq 1 ];\
    \ then\n        echo \"$p\"\n        return\n    fi\n    if [ \"$r\" -eq 2 ];\
    \ then\n        expr \"$p\" / \"$two\" \\* \"$two\"\n        return\n    fi\n\
    \    local n=$(( $r / 2 ))\n    local m=$(( $r - $n ))\n    local a=$(modp \"\
    $n\" \"$p\")\n    local b=$(modp \"$m\" \"$p\")\n    local x=$(($b * $b))\n  \
    \  local y=$(($a * $x))\n    local z=$(($y % $p))\n    if [ \"$r\" -gt \"$(( $p\
    \ / 2 ))\" ]; then\n        expr \"$p\" - \"$z\"\n    else\n        echo \"$z\"\
    \n    fi\n}\n\ncandidate() {\n    modp \"$@\"\n}\n\nset -e\nrun_test() {\n   \
    \ [[ $(candidate \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"1101\" \"101\"\
    ) = \"2\" ]]\n    [[ $(candidate \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate\
    \ \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate \"100\" \"101\") = \"1\" ]]\n \
    \   [[ $(candidate \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate \"31\" \"5\")\
    \ = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024854
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \tlocal a=\"$1\"\n\tlocal b=\"$2\"\n\tlocal res=0\n\tlocal mul=1\n\twhile [[ \"\
    $a\" -ne 0 ]]; do\n\t\tif [[ \"$((a & 1))\" -eq 1 ]]; then\n\t\t\tlet res+=mul\n\
    \t\t\tres=$((res % b))\n\t\tfi\n\t\tlet a/=2\n\t\tlet mul*=2\n\t\tmul=$((mul %\
    \ b))\n\tdone\n\techo \"$res\"\n}\n\ncandidate() {\n    modp \"$@\"\n}\n\nset\
    \ -e\nrun_test() {\n    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate\
    \ \"1101\" \"101\") = \"2\" ]]\n    [[ $(candidate \"0\" \"101\") = \"1\" ]]\n\
    \    [[ $(candidate \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate \"100\" \"101\"\
    ) = \"1\" ]]\n    [[ $(candidate \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate\
    \ \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024854
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \  local n=\"$1\"\n  local p=\"$2\"\n  local x=\"1\"\n  local i\n  for ((i=0;\
    \ i<${#n}; i++)); do\n    if [ \"${n:$i:1}\" = \"1\" ]; then\n      x=$(modmul\
    \ \"$x\" \"$x\" \"$p\")\n    fi\n    x=$(modmul \"$x\" \"$x\" \"$p\")\n  done\n\
    \  echo \"$x\"\n}\n\ncandidate() {\n    modp \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"1101\" \"101\"\
    ) = \"2\" ]]\n    [[ $(candidate \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate\
    \ \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate \"100\" \"101\") = \"1\" ]]\n \
    \   [[ $(candidate \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate \"31\" \"5\")\
    \ = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmpd50_p5ha.sh: line 25: modmul: command not found

    '
  stdout: ''
  timestamp: 1660024854
- exit_code: 0
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    local i\n    local z=1\n    local x=${1}\n    local p=${2}\n    if [ \"${x}\"\
    \ -eq 0 ]; then\n        echo ${z}\n        return\n    fi\n    for ((i=1; i<=${x};\
    \ i++)); do\n        z=$(( (${z} * 2) % ${p} ))\n    done\n    echo ${z}\n}\n\n\
    candidate() {\n    modp \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n \
    \   [[ $(candidate \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\"\
    ) = \"8\" ]]\n    [[ $(candidate \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate\
    \ \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\n\
    run_test"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660024854
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    local out=\"${1}\"\n    local p=\"${2}\"\n    while (( ${#out} >= ${#p} ));\
    \ do\n        out=$(mul \"${out}\" \"${out}\" | mod \"${p}\")\n    done\n    echo\
    \ \"${out}\"\n}\n\ncandidate() {\n    modp \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"1101\" \"101\"\
    ) = \"2\" ]]\n    [[ $(candidate \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate\
    \ \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate \"100\" \"101\") = \"1\" ]]\n \
    \   [[ $(candidate \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate \"31\" \"5\")\
    \ = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmpbsvudor5.sh: line 20: mul: command not found

    /tmp/tmpbsvudor5.sh: line 20: mod: command not found

    '
  stdout: ''
  timestamp: 1660024854
- exit_code: -1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \  local num=$1\n  local mod=$2\n  local out=1\n  local digit\n\n  if [ \"$num\"\
    \ == \"0\" ]; then\n    printf %s \"$out\"\n    return\n  fi\n\n  while [ \"$num\"\
    \ != \"0\" ]; do\n    digit=$(echo \"$num\" | tail -c 2)\n    num=$(echo \"$num\"\
    \ | sed -e 's/.$//')\n    if [ \"$digit\" == \"1\" ]; then\n      out=$((out *\
    \ 2 % mod))\n    fi\n    out=$((out * out % mod))\n  done\n\n  printf %s \"$out\"\
    \n}\n\ncandidate() {\n    modp \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n \
    \   [[ $(candidate \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\"\
    ) = \"8\" ]]\n    [[ $(candidate \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate\
    \ \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\n\
    run_test"
  status: Timeout
  stderr: <_io.TextIOWrapper name=57 encoding='utf-8'>
  stdout: <_io.TextIOWrapper name=46 encoding='utf-8'>
  timestamp: 1660024859
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    local base=\"$1\"\n    local modulus=\"$2\"\n    local result=\"$base\"\n\
    \    # How many bits are in the base?\n    local bits=$(printf \"%s\" \"$base\"\
    \ | wc -c)\n    # Let's start at index 2 because index 1 is the base itself.\n\
    \    for (( i=2; i<bits; i++ )); do\n        local digit=\"${base:$i:1}\"\n  \
    \      # If there's a 1 at this index, we want to square the base and\n      \
    \  # multiply the result by the base.\n        if [[ \"$digit\" -eq \"1\" ]];\
    \ then\n            result=$(modmul \"$result\" \"$result\" \"$modulus\")\n  \
    \          result=$(modmul \"$result\" \"$base\" \"$modulus\")\n        else\n\
    \            # If there's a 0 at this index, we square the base.\n           \
    \ result=$(modmul \"$result\" \"$result\" \"$modulus\")\n        fi\n    done\n\
    \    echo \"$result\"\n}\n\ncandidate() {\n    modp \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"1101\" \"\
    101\") = \"2\" ]]\n    [[ $(candidate \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate\
    \ \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate \"100\" \"101\") = \"1\" ]]\n \
    \   [[ $(candidate \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate \"31\" \"5\")\
    \ = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmp5i3uvcn9.sh: line 32: modmul: command not found

    /tmp/tmp5i3uvcn9.sh: line 28: modmul: command not found

    /tmp/tmp5i3uvcn9.sh: line 29: modmul: command not found

    '
  stdout: ''
  timestamp: 1660024854
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \  if [[ \"$1\" == \"0\" ]]; then\n    echo \"1\"\n    return\n  fi\n  local n=$1\n\
    \  local p=$2\n  local r=1\n  local m=$(( 2**32 ))\n  local e=$(( m % p ))\n \
    \ local b=1\n  while [[ \"$n\" != \"0\" ]]; do\n    if [[ \"$(( n & 1 ))\" ==\
    \ \"1\" ]]; then\n      b=$(( b * e % p ))\n    fi\n    e=$(( e * e % p ))\n \
    \   n=$(( n >> 1 ))\n  done\n  echo \"$b\"\n}\n\ncandidate() {\n    modp \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n    [[\
    \ $(candidate \"1101\" \"101\") = \"2\" ]]\n    [[ $(candidate \"0\" \"101\")\
    \ = \"1\" ]]\n    [[ $(candidate \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate\
    \ \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate \"30\" \"5\") = \"4\" ]]\n \
    \   [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024854
- exit_code: 2
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    #echo \"$(bc <<< \"scale=${#2}; 2^$1 % $2\")\"\n    #echo \"2^$1 % $2\" |\
    \ bc\n    #echo \"2^$1 % $2\" | bc -l\n    #echo \"2^$1 % $2\" | bc -l -i\n  \
    \  #echo \"2^$1 % $2\" | bc -l -i | tr -d '\\\\'\n    #echo \"2^$1 % $2\" | bc\
    \ -l -i | sed 's/\\\\//g'\n    #echo \"2^$1 % $2\" | bc -l -i | sed 's/\\\\//g'\
    \ | sed 's/.$//'\n    #echo \"2^$1 % $2\" | bc -l -i | sed 's/\\\\//g' | sed 's/.$//'\
    \ | sed 's/^0*//'\n    #echo \"2^$1 % $2\" | bc -l -i | sed 's/\\\\//g' | sed\
    \ 's/.$//' | sed 's/^0*//' | tr -d '.'\n    #echo \"2^$1 % $2\" | bc -l -i | sed\
    \ 's/\\\\//g' | sed 's/.$//' | sed 's/^0*//' | tr -d '.' | tr -d '\\\\'\n    #echo\
    \ \"2^$1 % $2\" | bc -l -i | sed 's/\\\\//g' | sed 's/.$//' | sed 's/^0*//' |\
    \ tr -d '.' | tr -d '\\\\' | tr -d '-'\n    #echo \"2^$1 % $2\" | bc -l -i | sed\
    \ 's/\\\\//g' | sed 's/.$//' | sed 's/^0*//' | tr -d '.' | tr -d '\\\\' | tr -d\
    \ '-' | sed 's/^[ ]*//'\n    #echo \"2^$1 % $2\" | bc -l -i | sed 's/\\\\//g'\
    \ | sed 's/.$//' | sed 's/^0*//' | tr\n}\n\ncandidate() {\n    modp \"$@\"\n}\n\
    \nset -e\nrun_test() {\n    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate\
    \ \"1101\" \"101\") = \"2\" ]]\n    [[ $(candidate \"0\" \"101\") = \"1\" ]]\n\
    \    [[ $(candidate \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate \"100\" \"101\"\
    ) = \"1\" ]]\n    [[ $(candidate \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate\
    \ \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp23t1skol.sh: line 30: syntax error near unexpected token `}''

    /tmp/tmp23t1skol.sh: line 30: `}''

    '
  stdout: ''
  timestamp: 1660024854
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \  local n=\"$1\"\n  local p=\"$2\"\n  if [ $n -eq 0 ]; then\n    echo '1'\n \
    \   return\n  fi\n  local m=\n  local result=1\n  for (( i=0; i<${#n}; i++ ));\
    \ do\n    local digit=\"${n:$i:1}\"\n    if [ \"$digit\" == \"1\" ]; then\n  \
    \    m=\"$(($result * 2))\"\n      result=\"$(($m % $p))\"\n    fi\n    m=\"$(($result\
    \ * 2))\"\n    result=\"$(($m % $p))\"\n  done\n  echo \"$result\"\n}\n\ncandidate()\
    \ {\n    modp \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3\" \"5\"\
    ) = \"3\" ]]\n    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n    [[ $(candidate\
    \ \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\") = \"8\" ]]\n   \
    \ [[ $(candidate \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate \"30\" \"5\"\
    ) = \"4\" ]]\n    [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024854
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    python -c \"print(int($1) % int($2))\"\n}\n\ncandidate() {\n    modp \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n    [[\
    \ $(candidate \"1101\" \"101\") = \"2\" ]]\n    [[ $(candidate \"0\" \"101\")\
    \ = \"1\" ]]\n    [[ $(candidate \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate\
    \ \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate \"30\" \"5\") = \"4\" ]]\n \
    \   [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024854
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \  bit=$1\n  p=$2\n  p1=$(($p-1))\n  mp=$p1\n  m=$(($p-1))\n  for ((i=1; i<$((${#bit}+1));\
    \ i++)); do\n    bit1=$(echo $bit | cut -c$i)\n    #echo \"$bit1\"\n    if [ \"\
    $bit1\" = \"1\" ]; then\n      m=$(($m*$mp))\n      m=$(($m%$p))\n    fi\n   \
    \ mp=$(($mp*$mp))\n    mp=$(($mp%$p))\n  done\n  echo \"$m\"\n}\n\ncandidate()\
    \ {\n    modp \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3\" \"5\"\
    ) = \"3\" ]]\n    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n    [[ $(candidate\
    \ \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\") = \"8\" ]]\n   \
    \ [[ $(candidate \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate \"30\" \"5\"\
    ) = \"4\" ]]\n    [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024854
- exit_code: -1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \  if [ \"$1\" == \"0\" ]; then\n    echo \"1\"\n    return\n  fi\n  if [ \"$2\"\
    \ == \"1\" ]; then\n    echo \"0\"\n    return\n  fi\n  local r=$1\n  local i=0\n\
    \  local bpow2=2\n  while true; do\n    local r=$((${r}*${r}%${2}))\n    if [\
    \ \"$i\" == \"0\" ]; then\n      bpow2=2\n    else\n      bpow2=$((${bpow2}*${bpow2}%${2}))\n\
    \    fi\n    if [ $(isPowerOf2 $i) == \"1\" ]; then\n      bpow2=$((${bpow2}*${1}%${2}))\n\
    \    fi\n    if [ $(isPowerOf2 $i) == \"1\" ]; then\n      local bpow2\n     \
    \ if [ \"$bpow2\" == \"0\" ]; then\n        break\n      fi\n      while [ $(modpp\
    \ \"${r}\" \"${bpow2}\" \"${2}\") == \"0\" ]; do\n        local r=$((${r}/${bpow2}))\n\
    \      done\n    fi\n    i=$((${i}+1))\n  done\n  echo \"${r}\"\n}\n\ncandidate()\
    \ {\n    modp \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3\" \"5\"\
    ) = \"3\" ]]\n    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n    [[ $(candidate\
    \ \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\") = \"8\" ]]\n   \
    \ [[ $(candidate \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate \"30\" \"5\"\
    ) = \"4\" ]]\n    [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: Timeout
  stderr: <_io.TextIOWrapper name=16 encoding='utf-8'>
  stdout: <_io.TextIOWrapper name=55 encoding='utf-8'>
  timestamp: 1660024859
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \  local n=\"$1\"\n  local p=\"$2\"\n  local r=\"1\"\n  [[ \"$n\" == \"0\" ]]\
    \ && echo \"$r\" && return 0\n  for (( i=0; i<\"${#n}\"; i++ )); do\n    [[ \"\
    ${n:$i:1}\" == \"1\" ]] && r=$(($r*$r % $p))\n    r=$(($r*$r % $p))\n  done\n\
    \  echo \"$r\"\n}\n\ncandidate() {\n    modp \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"1101\" \"101\"\
    ) = \"2\" ]]\n    [[ $(candidate \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate\
    \ \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate \"100\" \"101\") = \"1\" ]]\n \
    \   [[ $(candidate \"30\" \"5\") = \"4\" ]]\n    [[ $(candidate \"31\" \"5\")\
    \ = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024854
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    local n=$1\n    local p=$2\n    local r=1\n    for i in $(seq 1 $((${#n}\
    \ - 1))); do\n        if [[ ${n:$i:1} == \"1\" ]]; then\n            r=$(($r *\
    \ 2))\n            r=$(($r % $p))\n        fi\n    done\n    echo $r\n}\n\ncandidate()\
    \ {\n    modp \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3\" \"5\"\
    ) = \"3\" ]]\n    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n    [[ $(candidate\
    \ \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\") = \"8\" ]]\n   \
    \ [[ $(candidate \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate \"30\" \"5\"\
    ) = \"4\" ]]\n    [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024854
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    echo $1 | perl -ane '\n        for (reverse split //) {\n            $n .=\
    \ $_;\n            $n %= $mod;\n            $n = \"1$n\";\n        }\n       \
    \ $mod = @F[1];\n        $n %= $mod;\n        print $n;\n    '\n}\n\ncandidate()\
    \ {\n    modp \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3\" \"5\"\
    ) = \"3\" ]]\n    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n    [[ $(candidate\
    \ \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\") = \"8\" ]]\n   \
    \ [[ $(candidate \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate \"30\" \"5\"\
    ) = \"4\" ]]\n    [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: 'Illegal modulus zero at -e line 4, <> line 1.

    '
  stdout: ''
  timestamp: 1660024854
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    local n=$1\n    local p=$2\n    local result=1\n    local x=2\n    local\
    \ b\n    local shift\n\n    if [[ -z $n ]]; then\n        echo 0\n        return\n\
    \    fi\n\n    if [[ -z $p ]]; then\n        echo 1\n        return\n    fi\n\n\
    \    # $n is a 1\n    if [[ $n -eq 1 ]]; then\n        echo 1\n        return\n\
    \    fi\n\n    # $n is not divisible by 2 (implies $n is even, since 0<=$n<=p)\n\
    \    if [[ $((n % 2)) -ne 0 ]]; then\n        echo 0\n        return\n    fi\n\
    \n    # $n is a power of 2\n    if [[ $((p % 2)) -eq 0 ]]; then\n        echo\
    \ 1\n        return\n    fi\n\n    # $n is not divisible by $p\n    # this ensures\
    \ that all result values are in the range 0<=result<=$p\n    if [[ $((n % p))\
    \ -eq 0 ]]; then\n        echo 0\n        return\n    fi\n\n    # $n must be even,\
    \ so we can do two divisions at once\n    while [[ $n -gt 1 ]]; do\n        b=$(tobinary\
    \ $n)\n        n=$(shiftright \"$b\")\n        shift=$(countones \"$b\")\n   \
    \     x=$(((x * x) % p))\n        if [[ $shift -eq 1 ]]; then\n            x=$(((x\
    \ * 2) % p))\n        fi\n    done\n\n    echo $x\n}\n\ncandidate() {\n    modp\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3\" \"5\") = \"3\" ]]\n\
    \    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n    [[ $(candidate \"0\" \"\
    101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\") = \"8\" ]]\n    [[ $(candidate\
    \ \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate \"30\" \"5\") = \"4\" ]]\n \
    \   [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024854
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \    local n=\"$1\"\n    local p=\"$2\"\n    local result=1\n    # Drop the first\
    \ character.\n    while [ -n \"$n\" ]; do\n        local first=\"${n:0:1}\"\n\
    \        if [ \"$first\" == 1 ]; then\n            result=$((result * 2 % p))\n\
    \        fi\n        n=\"${n:1}\"\n    done\n    echo \"$result\"\n}\n\ncandidate()\
    \ {\n    modp \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3\" \"5\"\
    ) = \"3\" ]]\n    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n    [[ $(candidate\
    \ \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\") = \"8\" ]]\n   \
    \ [[ $(candidate \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate \"30\" \"5\"\
    ) = \"4\" ]]\n    [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024854
- exit_code: 1
  program: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
    \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp\
    \ \"0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"\
    100\" \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n\
    \t[ -z \"$1\" ] && echo 1 && return\n\t[ -z \"$2\" ] && echo 1 && return\n\t#[\
    \ \"$1\" -le 1 ] && echo \"$1\" && return\n\t#[ \"$2\" -le 1 ] && echo \"$2\"\
    \ && return\n\t# FIXME: BASH Arithmetic Expansion is not powerful enough\n\t#echo\
    \ $((2**$1 % $2))\n\t# FIXME: bc is not precise enough\n\t#echo \"$(echo \"2^$1\"\
    \ | bc) % $2\" | bc\n\t# FIXME: is there a way to use python in bash?\n\t#echo\
    \ \"$(python -c \"print 2**$1 % $2\")\"\n\t# FIXME: Fails when $1 >= 100000\n\t\
    #echo \"$(lshw 2 $1) % $2\"\n\t# FIXME: perl is even less precise than bc\n\t\
    #echo \"$(echo \"2^$1\" | perl -MPOSIX -e 'print strftime \"%s\", gmtime shift;')\
    \ % $2\"\n\t# FIXME: Cannot use bc with num >= 16 digits, but echo could\n\t#echo\
    \ \"$(echo \"2^$1\" | echo \"$(echo \"2^$1\" | perl -MPOSIX -e 'print strftime\
    \ \"%s\", gmtime shift;') % $2\")\"\n\t# FIXME: Cannot use bc with num >= 16 digits,\
    \ but echo could\n\techo \"$(echo \"2^$1\" | echo \"$(echo \"2^$1\" | perl -MPOSIX\
    \ -e 'print strftime \"%s\", gmtime shift;') % $2\")\"\n}\n\ncandidate() {\n \
    \   modp \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3\" \"5\") =\
    \ \"3\" ]]\n    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n    [[ $(candidate\
    \ \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\") = \"8\" ]]\n   \
    \ [[ $(candidate \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate \"30\" \"5\"\
    ) = \"4\" ]]\n    [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660024854
