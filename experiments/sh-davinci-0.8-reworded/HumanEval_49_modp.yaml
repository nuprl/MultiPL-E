name: HumanEval_49_modp
language: sh
prompt: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> $(modp\
  \ \"3\" \"5\")\n# \"3\"\n# >>> $(modp \"1101\" \"101\")\n# \"2\"\n# >>> $(modp \"\
  0\" \"101\")\n# \"1\"\n# >>> $(modp \"3\" \"11\")\n# \"8\"\n# >>> $(modp \"100\"\
  \ \"101\")\n# \"1\"\n#\n# $1 is an integer\n# $2 is an integer\nmodp() {\n"
tests: "}\n\ncandidate() {\n    modp \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
  \ \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n   \
  \ [[ $(candidate \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\") = \"\
  8\" ]]\n    [[ $(candidate \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate \"30\"\
  \ \"5\") = \"4\" ]]\n    [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
completions: ["  LC_NUMERIC=C # Set radix to \".\"\n  printf \"%'d\\n\" \"$((2**$1\
    \ % $2))\"", "    local n=\"$1\"\n    local p=\"$2\"\n    if [ \"$n\" == \"0\"\
    \ ]; then\n        echo \"1\"\n        return\n    fi\n    if [ \"$n\" == \"1\"\
    \ ]; then\n        echo \"$p\"\n        return\n    fi\n    if [ \"$n\" == \"\
    2\" ]; then\n        echo \"$(mul \"$p\" \"$p\" \"$p\")\"\n        return\n  \
    \  fi\n    if [ \"$n\" == \"3\" ]; then\n        echo \"$(mul \"$(mul \"$p\" \"\
    $p\" \"$p\")\" \"$p\" \"$p\")\"\n        return\n    fi\n    local r=\"$(modp\
    \ \"$(bin \"$n\" \"2\")\" \"$p\")\"\n    local b=\"$(modp \"$(bin \"$n\" \"1\"\
    )\" \"$p\")\"\n    local k=\"$(bin \"$n\" \"1\")\"\n    if [ \"$k\" == \"1\" ];\
    \ then\n        echo \"$(mul \"$r\" \"$r\" \"$p\")\"\n        return\n    fi\n\
    \    echo \"$(mul \"$(mul \"$r\" \"$r\" \"$p\")\" \"$b\" \"$p\")\"", "    # XXX:\
    \ I think it's ok to use bc because this is only run when you want\n    #    \
    \  the modp of a given prime.\n    echo $(( $1 % $2 )) | bc", "    local -u a=$1\n\
    \    local -u p=$2\n    # echo \"modp: $a $p\"\n    if ((a==0)); then\n      \
    \  # 0^n % p == 0\n        echo \"1\"\n    elif ((a==1)); then\n        # 1^n\
    \ % p == 1\n        echo \"1\"\n    elif ((a<p)); then\n        # 2^n % p == (2^n\
    \ % (p-1)) + 1\n        local -u one=\"1\"\n        local -u a_=$(bc -l <<< \"\
    $a % $((p-1))\")\n        local -u t=$(modp \"$a_\" \"$((p-1))\")\n        bc\
    \ -l <<< \"$t % $p + $one\"\n    else\n        local -u a_=$(bc -l <<< \"$a %\
    \ $p\")\n        modp \"$a_\" \"$p\"\n    fi", "    local n=\"$1\"\n    local\
    \ p=\"$2\"\n    local tmp=$((n % p))\n    local res=1\n    while [ $tmp -gt 0\
    \ ]; do\n        res=$(((res * 2) % p))\n        tmp=$((tmp - 1))\n    done\n\
    \    echo $res", "    # All possible residues of 2^k modulo p, k=0..n\n    modp_A=$(bc\
    \ <<< \"2^$1 % $2\")\n    # n modulo (p-1)\n    modp_N=$(bc <<< \"$1 % ($2-1)\"\
    )\n    # New residue 2^(n modulo (p-1)) modulo p\n    modp_R=$(bc <<< \"2^$modp_N\
    \ % $2\")\n    echo $modp_R", "  local n=$1\n  local p=$2\n  local b=1\n  local\
    \ a=$n\n  local s=\"$(( ${#n} - 1 ))\"\n  while [[ $s -ge 0 ]]; do\n    b=$((\
    \ (b * b) % p ))\n    if [[ ${n:$s:1} -eq 1 ]]; then\n      b=$(( (b * a) % p\
    \ ))\n    fi\n    s=$(( s - 1 ))\n  done\n  echo $b", "    local MODP_RESULT=$1\n\
    \    if [ -z \"$MODP_RESULT\" ]; then\n        MODP_RESULT=1\n    fi\n    local\
    \ MODP_P=$2\n    if [ -z \"$MODP_P\" ]; then\n        MODP_P=2\n    fi\n    local\
    \ MODP_T\n    while [ \"$MODP_RESULT\" -ge \"$MODP_P\" ]; do\n        MODP_T=$(($MODP_RESULT\
    \ % $MODP_P))\n        MODP_RESULT=$(($MODP_RESULT - $MODP_T))\n        MODP_RESULT=$(($MODP_RESULT\
    \ / $MODP_P))\n        MODP_RESULT=$(($MODP_RESULT + $MODP_T))\n    done\n   \
    \ echo $MODP_RESULT", '    printf "%d" "$(printf "%d\n" "$1" | bc -l | ./modp
    "$2")"', "\t# print \"2^\"$1 \"mod\" $2\" =\"\n\techo \"$1\" | awk '{print 2^$1%'$2'}'",
  "  if [ -z \"$2\" ]; then\n    echo \"At least 2 arguments are needed!\" >&2\n \
    \   exit 1\n  fi\n  if [ \"$2\" -lt 2 ]; then\n    echo \"Base must be greater\
    \ than 1!\" >&2\n    exit 1\n  fi\n  if [ \"$(echo \"$1 < 0\" | bc)\" -eq 1 ];\
    \ then\n    echo \"Number must be greater than or equal to 0!\" >&2\n    exit\
    \ 1\n  fi\n  if [ \"$(echo \"$2 < 0\" | bc)\" -eq 1 ]; then\n    echo \"Modulo\
    \ must be greater than or equal to 0!\" >&2\n    exit 1\n  fi\n  # Uncomment the\
    \ following line if you want to enforce\n  # that number be less than modulo (the\
    \ inversion will be slower).\n  # if [ \"$(echo \"$1 >= $2\" | bc)\" -eq 1 ];\
    \ then\n  #   echo \"Number must be less than modulo!\" >&2\n  #   exit 1\n  #\
    \ fi\n  if [ \"$1\" -eq 0 ]; then\n    echo 1\n    return\n  fi\n  if [ \"$1\"\
    \ -eq 1 ]; then\n    echo \"$1\"\n    return\n  fi\n  if [ \"$2\" -eq 1 ]; then\n\
    \    echo 0\n    return\n  fi\n  if [ \"$2\" -eq 2 ]; then\n    echo \"$(echo\
    \ \"$1 % 2\" | bc)\"\n    return\n  fi\n  # Write $1 in base $2\n  local total=\"\
    \"\n  while [ \"$1\" -ne 0 ]; do\n    local remain=\"$(echo \"$1 % $2\" | bc)\"\
    \n    total=\"$remain$total\"\n    local tmp=\"$(echo \"$1 / $2\" | bc)\"\n  \
    \  local tmp2=\"$(echo \"$tmp % 2\" | bc)\"\n    if [ \"$tmp2\" -eq 1 ]; then\n\
    \      tmp=\"$(echo \"$tmp + 1\" | bc)\"\n    fi\n    local num=\"$(echo \"$tmp\
    \ / 2\" | bc)\"\n    local tmp3=\"$(echo \"$num % 2\" | bc)\"\n    if [ \"$tmp3\"\
    \ -eq 1 ]; then\n      num=\"$(echo \"$num + 1\" |", '    (echo "scale=$((${#1}*8));
    2^$1 % $2" | bc)', "  local n=\"$1\"\n  local p=\"$2\"\n  local __modp=\"$(echo\
    \ \"ibase=2;obase=10;ibase=2;$n^2^\" | bc | tr -d '\\n')\"\n  local __modp=$(($__modp\
    \ % $p))\n  echo \"$__modp\"", "  # We want to make sure we use bc for these operations,\
    \ so we call it\n  # separately rather than using $().\n  if [ \"$1\" -eq \"0\"\
    \ ]; then\n    echo \"1\"\n  else\n    local n=$(bc -l <<< \"( $1 * 2 ) % $2\"\
    )\n    echo $n\n  fi", "  local n=$1\n  local p=$2\n  local r=1\n  local c=0\n\
    \  local q=1\n  local d=$n\n  local s=\"\"\n  local len=${#d}\n  local i=0\n \
    \ local base=10\n  local b=$((base*base))\n  local bb=$((b*base))\n  local bbb=$((bb*base))\n\
    \  while [ $c -lt $len ]; do\n    case $((d/bbb)) in\n      0) s=\"000$s\" ;;\n\
    \      1) s=\"001$s\" ;;\n      2) s=\"010$s\" ;;\n      3) s=\"011$s\" ;;\n \
    \     4) s=\"100$s\" ;;\n      5) s=\"101$s\" ;;\n      6) s=\"110$s\" ;;\n  \
    \    7) s=\"111$s\" ;;\n    esac\n    d=$((d%bbb))\n    bbb=$((bbb/base))\n  \
    \  case $((d/bb)) in\n      0) s=\"000$s\" ;;\n      1) s=\"001$s\" ;;\n     \
    \ 2) s=\"010$s\" ;;\n      3) s=\"011$s\" ;;\n      4) s=\"100$s\" ;;\n      5)\
    \ s=\"101$s\" ;;\n      6) s=\"110$s\" ;;\n      7) s=\"111$s\" ;;\n    esac\n\
    \    d=$((d%bb))\n    bb=$((bb/base))\n    case $((d/b)) in\n      0) s=\"000$s\"\
    \ ;;\n      1) s=\"001$s\" ;;\n      2) s=\"010$s\" ;;\n      3) s=\"011$s\" ;;\n\
    \      4) s=\"100$s\" ;;\n      5) s=\"101$s\" ;;\n      6) s=\"110$s\" ;;\n \
    \     7) s=\"111$s\" ;;\n    esac\n    d=$((d%b))\n    b=$((b/base))\n    case\
    \ $((d/base)) in\n      0) s=\"000$s\" ;;\n      1) s=\"001$s\" ;;\n      2) s=\"\
    010$s", "  if [ \"$1\" == \"0\" ]; then\n    echo \"1\"\n    return\n  fi\n  p=$2\n\
    \  n=$1\n  while [ ${#n} -gt ${#p} ]; do\n    k=$(echo \"$n\" | wc -c)\n    k=$((\
    \ k - 1 ))\n    p=$(dc -e \"$p\"k\"$k\"p)\n    if [ $(echo \"$n>$p\" | bc) -eq\
    \ 1 ]; then\n      n=$(echo \"$n-$p\" | bc)\n    fi\n  done\n  if [ $(echo \"\
    $n>$p\" | bc) -eq 1 ]; then\n    n=$(echo \"$n-$p\" | bc)\n  fi\n  echo \"$n\"",
  "    if (( $1 == 0 )); then\n        echo \"1\"\n        return\n    fi\n    local\
    \ binary=\"$(to_binary \"$1\")\"\n    local p=\"$2\"\n    local result=\"1\"\n\
    \    local n=\"$((${#binary} - 1))\"\n    local i=\"0\"\n    while (( i <= n ));\
    \ do\n        if (( ${binary:$i:1} == 1 )); then\n            result=$(( (result\
    \ * result) % p ))\n            if (( i < n )); then\n                result=$((\
    \ (result * 2) % p ))\n            fi\n        else\n            result=$(( (result\
    \ * result) % p ))\n        fi\n        i=$((i + 1))\n    done\n    echo \"$result\"",
  "    local p=\"$2\"\n    local n=\"$1\"\n    local x=\"$n\"\n    local y=1\n   \
    \ local b=1\n    local shift=\"\"\n    if [[ $n == 0 ]]; then\n        echo 1\n\
    \        return\n    fi\n    while [[ $b != 0 ]]; do\n        if [[ $(( $b & 1\
    \ )) == 1 ]]; then\n            y=$(( (($y * $x) % $p) ))\n        fi\n      \
    \  x=$(( (($x * $x) % $p) ))\n        b=$(( $b >> 1 ))\n    done\n    echo $y",
  "    [[ \"${1}\" == \"0\" ]] && { echo \"1\"; return; }\n    printf \"%d\" \"2\"\
    \ | bc -l \\\n        | bc -l | tr -d '\\n' | gawk -v \"p=${2}\" '{printf(\"%d\"\
    , $0 % p)}'", "    local y=\"1\"\n    while [ \"$1\" != \"0\" ]; do\n        local\
    \ bit=\"$(bitchop \"$1\")\"\n        if [ \"$bit\" = \"1\" ]; then\n         \
    \   y=\"$(modmulti \"$y\" \"2\" \"$2\")\"\n        fi\n        local x=\"$(modmulti\
    \ \"2\" \"2\" \"$2\")\"\n        shift\n    done\n    echo \"$y\""]
stop_tokens:
- "\n}"
