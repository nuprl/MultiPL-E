name: HumanEval_94_skjkasdkd
language: sh
prompt: "#!/bin/bash\n# You are given a list of integers.\n# You need to find the\
  \ largest prime value and return the sum of its digits.\n# Examples:\n# >>> $(skjkasdkd\
  \ \"0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3\")\n# \"10\"\n# >>> $(skjkasdkd\
  \ \"1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1\")\n# \"25\"\n# >>> $(skjkasdkd \"1\
  \ 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3\")\n# \"13\"\n# >>> $(skjkasdkd\
  \ \"0 724 32 71 99 32 6 0 5 91 83 0 5 6\")\n# \"11\"\n# >>> $(skjkasdkd \"0 81 12\
  \ 3 1 21\")\n# \"3\"\n# >>> $(skjkasdkd \"0 8 1 2 1 7\")\n# \"7\"\n#\n# $1 is a\
  \ space-separated list\nskjkasdkd() {\n"
tests: "}\n\ncandidate() {\n    skjkasdkd \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
  \ $(candidate \"0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3\") = \"10\" ]]\n\
  \    [[ $(candidate \"1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1\") = \"25\" ]]\n \
  \   [[ $(candidate \"1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3\") = \"\
  13\" ]]\n    [[ $(candidate \"0 724 32 71 99 32 6 0 5 91 83 0 5 6\") = \"11\" ]]\n\
  \    [[ $(candidate \"0 81 12 3 1 21\") = \"3\" ]]\n    [[ $(candidate \"0 8 1 2\
  \ 1 7\") = \"7\" ]]\n    [[ $(candidate \"8191\") = \"19\" ]]\n    [[ $(candidate\
  \ \"8191 123456 127 7\") = \"19\" ]]\n    [[ $(candidate \"127 97 8192\") = \"10\"\
  \ ]]\n}\n\nrun_test"
completions: ["\tsolution=''\n\tsolution=`echo $1 | tr ' ' '\\n' | sort -nr | head\
    \ -n 1`\n\techo \"Solution is: $solution\"\n\tsum=0\n\tsum=`echo $solution | sed\
    \ 's/\\(.\\)/\\1 + /g' | sed 's/\\(.*\\) + $/\\1/' | bc`\n\techo \"Sum of digits\
    \ is: $sum\"", "  # Wrote your code here\n  local max_prime=0\n  local sum=0\n\
    \  local num\n  local i\n\n  for num in $1; do\n    is_prime=1\n    for ((i=2;\
    \ i<=num/2; i++)); do\n      if (( $num % $i == 0 )); then\n        is_prime=0\n\
    \        break\n      fi\n    done\n    if (( is_prime && num > max_prime ));\
    \ then\n      max_prime=$num\n    fi\n  done\n\n  for (( i=0; i<${#max_prime};\
    \ i++ )); do\n    sum=$(( 10 * sum + ${max_prime:$i:1} ))\n  done\n\n  echo $sum",
  "  local primes=($(echo \"$1\" |\n    tr ' ' '\\n' |\n    sort -n |\n    uniq |\n\
    \    awk '$1>1{for(i=2;i<=$1;i++){if($1%i==0){break};if(i==$1-1){print $1}}}'))\n\
    \  local biggest=\"${primes[-1]}\"\n  local biggest_list=($(echo \"$biggest\"\
    \ | grep -o .)\n  local sum=0\n  for n in \"${biggest_list[@]}\"; do\n    sum=$((sum\
    \ + n))\n  done\n  echo \"$sum\"", "    local max=0\n    for i in $1; do\n   \
    \     if [ $i -gt $max ]; then\n            max=$i\n        fi\n    done\n   \
    \ # max is now the largest number in the list\n\n    for (( i=$max; i>0; i-- ));\
    \ do\n        is_prime $i && break\n    done\n    echo \"$i\" | sed 's/\\(.\\\
    )/\\1\\n/g' | paste -sd+ | bc", "  result=\"\"\n  for num in $1; do\n    if [\
    \ $num -gt $result ]; then\n      result=$num\n    fi\n  done\n  # if $result\
    \ is prime\n  if [ $(($result % 2)) -eq 0 ] || [ $(($result % 3)) -eq 0 ] || [\
    \ $(($result % 5)) -eq 0 ] || [ $(($result % 7)) -eq 0 ]; then\n    result=\"\
    0\"\n  fi\n  echo $result", "    local prime=2\n    for ((i=0; i<${#1}; i++));\
    \ do\n        [ ${1:$i:1} -gt $prime ] && prime=${1:$i:1}\n    done\n    echo\
    \ $prime | tr -d 0 | sed 's/./&\\n/g' | paste -sd+ | bc", "    local -a numbers=($1)\n\
    \    local -i greatest_prime=0\n    local -i current_number\n    local -i i\n\
    \    for current_number in \"${numbers[@]}\"; do\n        i=2\n        while [[\
    \ $((i*i)) -le $current_number ]]; do\n            if [[ $((current_number%i))\
    \ -eq 0 ]]; then\n                break\n            fi\n            i=$((i+1))\n\
    \        done\n        if [[ $((i*i)) -gt $current_number ]]; then\n         \
    \   if [[ $current_number -gt $greatest_prime ]]; then\n                greatest_prime=$current_number\n\
    \            fi\n        fi\n    done\n    echo $greatest_prime | tr -cd [:digit:]\
    \ | fold -w1 | paste -sd+ | bc", "\tlocal list_of_numbers=$1\n\tlocal largest_prime=0\n\
    \tlocal tmp\n\tlocal sum=0\n\tfor i in $list_of_numbers; do\n\t\tif [[ $i -eq\
    \ 0 ]]; then\n\t\t\tcontinue\n\t\tfi\n\t\ttmp=$(awk -v num=$i 'BEGIN { if (num\
    \ % 2 == 0) { print 0; exit } for (i = 3; i <= sqrt(num); i += 2) { if (num %\
    \ i == 0) { print 0; exit } } print 1 }')\n\t\tif [[ $tmp -eq 1 ]]; then\n\t\t\
    \tif [[ $i -gt $largest_prime ]]; then\n\t\t\t\tlargest_prime=$i\n\t\t\tfi\n\t\
    \tfi\n\tdone\n\twhile [[ $largest_prime -gt 0 ]]; do\n\t\tsum=$(( $sum + $largest_prime\
    \ % 10 ))\n\t\tlargest_prime=$(( $largest_prime / 10 ))\n\tdone\n\techo $sum",
  '  # write your code here', "    local input=($1)\n    local largest_prime=0\n \
    \   local prime_sum=0\n    for e in ${input[@]}; do\n        if [[ $(is_prime\
    \ $e) -eq 1 ]]; then\n            if [[ $e -gt $largest_prime ]]; then\n     \
    \           largest_prime=$e\n            fi\n        fi\n    done\n    local\
    \ digits=$(echo \"$largest_prime\" | sed -e 's/\\(.\\)/\\1 /g')\n    local sum=0\n\
    \    for e in $digits; do\n        sum=$((sum + e))\n    done\n    echo $sum",
  "    arr=($@)\n    arr=($(for e in \"${arr[@]}\"; do echo \"$e\"; done | sort -nr))\n\
    \    largest_prime=0\n    for (( i=0; i<${#arr[@]}; i++ )); do\n        if [[\
    \ \"${arr[$i]}\" -gt 1 ]]; then\n            prime=1\n            for (( j=2;\
    \ j<${arr[$i]}; j++ )); do\n                if [ $((${arr[$i]}%$j)) == 0 ]; then\n\
    \                    prime=0\n                    break\n                fi\n\
    \            done\n            if [ $prime == 1 ]; then\n                largest_prime=${arr[$i]}\n\
    \                break\n            fi\n        fi\n    done\n    largest_prime_as_str=$(echo\
    \ $largest_prime | grep -o .)\n    largest_prime_sum=0\n    for (( i=0; i<${#largest_prime_as_str[@]};\
    \ i++ )); do\n        largest_prime_sum=$(($largest_prime_sum+${largest_prime_as_str[$i]}))\n\
    \    done\n    echo $largest_prime_sum", "  local largest=0\n  for x in $1\n \
    \ do\n    if [[ $x -gt $largest ]]\n    then\n      largest=$x\n    fi\n  done\n\
    \  local prime=$(get_prime_number $largest)\n  local sum=0\n  for (( i=0; i<${#prime};\
    \ i++ ))\n  do\n    digit=\"${prime:$i:1}\"\n    sum=$((sum + digit))\n  done\n\
    \  echo $sum", "    echo \"$1\" | tr ' ' '\\n' |\n        awk '$1==int($1) { a[$1]\
    \ = 1; next } END { for (i in a) {print i} }' |\n        awk 'length($1)>1 {print;\
    \ next}\n        $1==int($1) {\n            for (i=2; i<=$1; i++) {\n        \
    \        if ($1 % i == 0) next\n            }\n            print $1\n        }'\
    \ |\n        awk '$1>largest {largest=$1} END { print largest }' |\n        awk\
    \ '{split($1,arr,\"\"); \n            for (i in arr) {\n                sum +=\
    \ arr[i]\n            }\n            print sum}'", "\tlocal IFS=$' '\n\tlocal\
    \ max_number=0\n\tlocal sum=0\n\tlocal arr=(\"$@\")\n\tfor number in \"${arr[@]}\"\
    ; do\n\t\tif [[ $number > $max_number ]]; then\n\t\t\tlocal max_number=$number\n\
    \t\tfi\n\tdone\n\tfor((i=2; i <= $max_number; i++)); do\n\t\tlocal prime=1\n\t\
    \tfor((j=2; j <= i/2; j++)); do\n\t\t\tif [[ $((i%j)) -eq 0 ]]; then\n\t\t\t\t\
    local prime=0\n\t\t\t\tbreak\n\t\t\tfi\n\t\tdone\n\t\tif [[ $prime -eq 1 ]]; then\n\
    \t\t\tfor number in \"${arr[@]}\"; do\n\t\t\t\tif [[ $number -eq $i ]]; then\n\
    \t\t\t\t\tlocal sum=$((sum + i))\n\t\t\t\tfi\n\t\t\tdone\n\t\tfi\n\tdone\n\techo\
    \ \"$sum\"", "  local primes=$(echo \"$1\" | tr ' ' '\\n' | uniq |\n    sort --numeric-sort\
    \ --reverse)\n  local largest_prime=0\n  local largest_prime_sum=0\n  for prime\
    \ in $primes; do\n    local is_prime=1\n    for (( i=2; i < $prime; i++ )); do\n\
    \      (( $prime % $i == 0 )) && is_prime=0 && break\n    done\n    if (( $is_prime\
    \ )); then\n      local sum=0\n      for digit in $(echo \"$prime\" | sed 's/./&\
    \ /g'); do\n        (( sum += $digit ))\n      done\n      if (( $sum > $largest_prime_sum\
    \ )); then\n        largest_prime_sum=$sum\n        largest_prime=$prime\n   \
    \   fi\n    fi\n  done\n  echo \"$largest_prime_sum\"", "  local list=$1\n  local\
    \ number\n  local len\n  local x\n  local max=0\n  # Find maximum prime\n  for\
    \ number in $list; do\n    len=${#number}\n    # Check if prime\n    x=2\n   \
    \ while [ $x -lt $len ]; do\n      if [ $(( number % x )) -eq 0 ]; then\n    \
    \    break\n      fi\n      x=$(( x + 1 ))\n    done\n    if [ $x -eq $len ];\
    \ then\n      if [ $number -gt $max ]; then\n        max=$number\n      fi\n \
    \   fi\n  done\n  # Get sum of digits\n  local sum=0\n  for (( i=0; i<${#max};\
    \ i++ )); do\n    sum=$(( sum + ${max:$i:1} ))\n  done\n  echo $sum", "  # $1,\
    \ $2, $3 are the digits of the largest prime value\n  local -i sum=0 max1=0 max2=0\
    \ max3=0\n  # $prime is the current prime number, initialized with the first input\n\
    \  local -i prime=\"$1\"\n  # $n is the current input number\n  local -i n\n \
    \ shift\n\n  # Main cycle: scan all the remaining inputs\n  for n in \"$@\"; do\n\
    \    # If the input number is a multiple of the current prime,\n    # simply skip\
    \ it.\n    if (( n % prime == 0 )); then\n      continue\n    fi\n\n    # If the\
    \ input number is not a multiple of the current prime,\n    # it's not a prime\
    \ number itself.\n    # If it has three digits and is greater than the current\n\
    \    # largest prime value, update the latter.\n    if (( n > prime && n < 1000\
    \ )); then\n      prime=\"$n\"\n      max1=\"$(( prime / 100 ))\"\n      max2=\"\
    $(( prime / 10 % 10 ))\"\n      max3=\"$(( prime % 10 ))\"\n    fi\n  done\n\n\
    \  # Show the output\n  printf '%d' \"$(( max1 + max2 + max3 ))\"", "  # Write\
    \ your code here\n  echo \"\"", "    local res=\"$(echo $1 | tr ' ' '\\n' | sort\
    \ -nr | uniq |\\\n    awk 'BEGIN {res = 0} NR == 1 {res = $1} NR > 1 {if ($1 ==\
    \ 1) {print res; exit 0}; if ($1 % (NR - 1) != 0) {res = $1}} END {print res}')\"\
    \n    echo -n $(echo $res | grep -o . | paste -sd+ | bc)", "  \n  declare -a arr=()\n\
    \  local args=(\"$@\")\n  local c=0\n\n  # Assign each arg a value\n  for arg\
    \ in $@; do\n    arr[$c]=$arg\n    c=$(($c+1))\n  done\n\n  # The first number\
    \ of the list is the length of the list\n  local length=${arr[0]}\n\n  # All possible\
    \ prime numbers between 2 and maximum number of the list\n  local primes=\"2 3\
    \ 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 101 103 107\
    \ 109 113 127 131 137 139 149 151 157 163 167 173 179 181 191 193 197 199 211\
    \ 223 227 229 233 239 241 251 257 263 269 271 277 281 283 293 307 311 313 317\
    \ 331 337 347 349 353 359 367 373 379 383 389 397 401 409 419 421 431 433 439\
    \ 443 449 457 461 463 467 479 487 491 499 503 509 521 523 541 547 557 563 569\
    \ 571 577 587 593 599 601 607 613 617 619 631 641 643 647 653 659 661 673 677\
    \ 683 691 701 709 719 727 733 739 743 751 757 761 769 773 787 797 809 811 821\
    \ 823 827 829 839 853 857 859 863 877 881 883 887 907 911 919 929 937 941 947\
    \ 953 967 971 977 983 991 997\"\n\n  # Iterate through all possible prime numbers.\n\
    \  # If the prime number exists in the list, break.\n  for prime in $primes; do\n\
    \    for i in ${arr[@]}; do\n      if [ $i -eq $prime ]; then\n        final_prime=$prime\n\
    \        break 2\n      fi\n    done\n  done\n\n  # Get the value of the largest\
    \ prime as a string\n  local str_prime=$(echo $final_prime | tr -d \"\\\\n\")\n\
    \n  # Assign each digit to an array\n  c=0\n  for (( i=0; i<${#str_prime}; i++\
    \ )); do\n    arr[$", "  echo \"$1\" | tr ' ' '\\n' | {\n    # found max prime\n\
    \    local p=0\n\n    while read i; do\n      if [[ $i -eq 1 ]]; then\n      \
    \  continue\n      fi\n\n      # check if prime\n      local p0=1\n      for j\
    \ in $(seq 2 $((i-1))); do\n        if [[ $((i%j)) -eq 0 ]]; then\n          p0=0\n\
    \          break\n        fi\n      done\n\n      if [[ $p0 -eq 1 ]]; then\n \
    \       if [[ $i -gt $p ]]; then\n          p=$i\n        fi\n      fi\n    done\n\
    \n    # output sum of digits\n    local sum=0\n    for i in $(seq 0 $((${#p}-1)));\
    \ do\n      sum=$((sum+${p:$i:1}))\n    done\n    echo $sum\n  }", "\tlocal -n\
    \ a\n\ta=($1)\n\tfor i in ${a[@]}; do\n\t\t((i%2)) && ((i%3)) && ((i%5)) && ((i%7))\
    \ && ((i%11)) && ((i%13)) && ((i%17)) && ((i%19)) && echo \"$i\"\n\tdone | sort\
    \ -nr | head -n1 | grep -o . | grep -v 0 | paste -sd+ | bc", "\tlocal arg=$1\n\
    \tlocal n num narg nump numprev numn\n\targ=$(echo \"$arg\" | sed -e 's/ //g')\n\
    \tn=$(echo \"$arg\" | wc -c)\n\tfor (( num=0; num<=n-1; num++ )); do\n\t\tnumprev=${arg:num-1:1}\n\
    \t\tnumn=${arg:num+1:1}\n\t\tnump=${arg:num:1}\n\t\tif [[ \"$nump\" == \"0\" ]];\
    \ then\n\t\t\tcontinue\n\t\tfi\n\t\tnarg=$(echo $arg | sed -e \"s/$nump/0/g\"\
    )\n\t\tif [[ \"$narg\" =~ \"0\" ]]; then\n\t\t\tcontinue\n\t\tfi\n\t\tif [[ \"\
    $numprev\" =~ \"0\" ]]; then\n\t\t\tnumprev=0\n\t\tfi\n\t\tif [[ \"$numn\" =~\
    \ \"0\" ]]; then\n\t\t\tnumn=0\n\t\tfi\n\t\tif [[ \"$nump\" -gt \"$numprev\" ]]\
    \ && [[ \"$nump\" -gt \"$numn\" ]]; then\n\t\t\tbreak\n\t\tfi\n\tdone\n\tnum=$(echo\
    \ $nump | sed -e 's/ //g')\n\techo $num | grep -o . | awk '{s+=$1} END {print\
    \ s}'", "  list=$1\n  # TODO: Your solution here\n  list=\"$(echo $list | tr '\
    \ ' '\\n' | sort -n)\"\n  primes=$(echo $list | tr ' ' '\\n' | tac | uniq)\n \
    \ # echo $primes\n  max=0\n  for n in $primes; do\n    if [[ $(echo $n | tr -cd\
    \ [:digit:]) ]]; then\n      # echo $n\n      max=$n\n      break\n    fi\n  done\n\
    \  if [[ max -eq 0 ]]; then\n    echo 0\n  else\n    max=\"$(echo $max | tr -cd\
    \ [:digit:])\"\n    echo $max | awk '{ total = 0; for (i = 1; i <= NF; i++) {\
    \ total += $i } print total }'\n  fi", "    local result=0\n    local list=$1\n\
    \    for i in $list; do\n        if [ $(is_prime \"$i\") -eq 1 ]; then\n     \
    \       local sum=0\n            sum_digits \"$i\"\n            if [ $sum -gt\
    \ $result ]; then\n                result=$sum\n            fi\n        fi\n \
    \   done\n    echo \"$result\"", "\tif [[ $# -eq 0 ]]; then\n\t\techo '$(skjkasdkd\
    \ \"0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3\")'\n\t\techo '$(skjkasdkd\
    \ \"1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1\")'\n\t\techo '$(skjkasdkd \"1 3 1\
    \ 32 5107 34 83278 109 163 23 2323 32 30 1 9 3\")'\n\t\techo '$(skjkasdkd \"0\
    \ 724 32 71 99 32 6 0 5 91 83 0 5 6\")'\n\t\techo '$(skjkasdkd \"0 81 12 3 1 21\"\
    )'\n\t\techo '$(skjkasdkd \"0 8 1 2 1 7\")'\n\t\treturn\n\tfi\n\tlocal nums=($1)\n\
    \tlocal largest=0\n\tfor num in ${nums[@]}; do\n\t\tif [[ $num -gt $largest ]];\
    \ then\n\t\t\tlargest=$num\n\t\tfi\n\tdone\n\tlargest=$(is_prime $largest)\n\t\
    if [[ $largest -eq 0 ]]; then\n\t\tfor num in ${nums[@]}; do\n\t\t\tif [[ $num\
    \ -lt $largest ]]; then\n\t\t\t\tlargest=$num\n\t\t\tfi\n\t\tdone\n\t\tlargest=$(is_prime\
    \ $largest)\n\tfi\n\tif [[ $largest -eq 0 ]]; then\n\t\techo 0\n\t\treturn\n\t\
    fi\n\tlocal sum=0\n\twhile [[ $largest -gt 0 ]]; do\n\t\tlocal n=$(( $largest\
    \ % 10 ))\n\t\tsum=$(( $sum + $n ))\n\t\tlargest=$(( $largest / 10 ))\n\tdone\n\
    \techo $sum", "    echo \"$1\" | awk '\n        BEGIN {\n            print \"\
    in\"\n        }\n        {\n            printf(\"%s\\n\", $0)\n        }\n   \
    \     END {\n            print \"out\"\n        }\n    '", "\tIFS=' '\n\tlocal\
    \ lst=($1)\n\tIFS=$'\\n'\n\tlocal tmp=${lst[@]}\n\tIFS=' '\n\tlst=($tmp)\n\tunset\
    \ tmp\n\tlocal max=${lst[0]}\n\tfor i in \"${lst[@]}\"; do\n\t\t[[ $i -gt $max\
    \ ]] && max=$i\n\tdone\n\tlocal i=0\n\tlocal sum=0\n\twhile [[ $max != 0 ]]; do\n\
    \t\tlocal digit=$(( max % 10 ))\n\t\t(( sum += digit ))\n\t\t(( max /= 10 ))\n\
    \tdone\n\techo $sum", "  local max=1\n  for i in $(echo $1); do\n    if [[ $i\
    \ -gt $max ]]; then\n      max=$i\n    fi\n  done\n  local x=2\n  local y=$max\n\
    \  local e=1\n  while [ $x -lt $y ]; do\n    while [ $((y % x)) -eq 0 ]; do\n\
    \      local e=$((x))\n      local y=$((y / x))\n    done\n    let x++\n  done\n\
    \  if [ $y -gt $e ]; then\n    local e=$y\n  fi\n  while [ $e -gt 0 ]; do\n  \
    \  local s=$((s + e % 10))\n    local e=$((e / 10))\n  done\n  echo $s", "  local\
    \ nums=\"$1\"\n  local arr=($nums)\n  local max=0\n  for n in \"${arr[@]}\"; do\n\
    \    if (( $(is_prime \"$n\") )); then\n      if (( n > max )); then\n       \
    \ max=\"$n\"\n      fi\n    fi\n  done\n  local sum=0\n  for (( i=0; i<${#max};\
    \ i++ )); do\n    sum=$(( 10*sum + ${max:$i:1} ))\n  done\n  echo \"$sum\"", " \
    \ local args=\"$1\"\n  local prime_num=0\n  local num\n  for num in $args; do\n\
    \    if [[ \"$num\" -gt \"$prime_num\" ]] && [[ $(($num % 2)) -ne 0 ]] && [[ $(($num\
    \ % 3)) -ne 0 ]] && [[ $(($num % 5)) -ne 0 ]] && [[ $(($num % 7)) -ne 0 ]]; then\n\
    \      prime_num=$num\n    fi\n  done\n  local total=0\n  for (( i=0; i<${#prime_num};\
    \ i++ )); do\n    total=$(( $total + ${prime_num:$i:1} ))\n  done\n  echo \"$total\"",
  "  local result=$(echo \"$1\" | tr \" \" \"\\n\" | sort -nr | grep -v \"[^0-9]\"\
    \ | grep -P \"(^|\\D)([2357])($|\\D)\" | head -n 1)\n  local result2=0\n  for\
    \ char in $(echo \"$result\" | fold -w 1); do\n    result2=$((result2 + $char))\n\
    \  done\n  echo \"$result2\"", "  ds=( $1 )\n  max=0\n  for (( i=0; i<${#ds[@]};\
    \ i++ )); do\n    x=${ds[$i]}\n    (( x > max )) && max=$x\n  done\n  maxprime=0\n\
    \  for (( i=2; i<=$max; i++ )); do\n    count=0\n    for (( j=1; j<=$i; j++ ));\
    \ do\n      (( $i % $j == 0 )) && (( count++ ))\n    done\n    (( count == 2 ))\
    \ && (( maxprime = $i ))\n  done\n  maxprime_digits=0\n  while (( maxprime > 0\
    \ )); do\n    maxprime_digits=$(( maxprime_digits + maxprime % 10 ))\n    maxprime=$((\
    \ maxprime / 10 ))\n  done\n  echo \"$maxprime_digits\"", "    MAX_PRIME=$(echo\
    \ $1 | tr ' ' '\\n' | sort -r | grep -x [0-9] | sed 1,1d | head -n 1)\n    echo\
    \ $MAX_PRIME | sed 's/\\(.\\)/\\1\\n/g' | grep -x [0-9] | paste -sd+ | bc", " \
    \   echo $1 | tr ' ' '\\n' | sort -nr | uniq | sed -n '2,$p' | head -n 1 | grep\
    \ -o '[0-9]\\+' | sort -nr | sed -e 's/^/+/' | tr -d '\\n' | bc", "\tlocal primes=$(lkjsdlkdfj\
    \ \"$1\")\n\tlocal max=0\n\tfor i in $primes; do\n\t\t[[ \"$i\" -gt \"$max\" ]]\
    \ && max=\"$i\"\n\tdone\n\tlkjsdlkdfj \"$max\"", "    local -r numbers=\"$1\"\n\
    \    local -r primes=$(factor $numbers | awk '{print $2}' | sort -rn | head -n\
    \ 1)\n    local -r result=\"$(printf \"%s\" \"$primes\" | grep -o . | tr -d '\\\
    n' | tr -d '\\n' | awk '{sum += $1} END {print sum}')\"\n    printf \"%s\" \"\
    $result\"", '  # your solution here', "  local numbers=($1)\n  local result=0\n\
    \  for i in \"${numbers[@]}\"; do\n    if (( i > result )); then\n      result=$i\n\
    \    fi\n  done\n  echo \"$result\"", "    # Write your code here\n    echo $1\
    \ | tr ' ' '\\n' | sort -nr | awk 'NR==1,NR==1' | sed 's/./&+/g' | sed 's/+$//'\
    \ | bc | tr -d '\\n'", "    local prime=\"0\"\n    for number in $1; do\n    \
    \    if is_prime \"$number\"; then\n            if [ \"$prime\" -lt \"$number\"\
    \ ]; then\n                prime=\"$number\"\n            fi\n        fi\n   \
    \ done\n    sum_digits \"$prime\"", "  lst=($(echo $1 | tr ' ' '\\n'))\n  lst=($(echo\
    \ ${lst[@]} | tr ' ' '\\n' | sort -nr))\n  for i in \"${lst[@]}\"; do\n    if\
    \ [[ $(factor $i | sed 's/^: //g' | sed 's/[0-9]//g' | sed 's/ //g') == \"\" ]];\
    \ then\n      echo $(expr $i % 10 + $(expr $i / 10) % 10 + $(expr $i / 100) %\
    \ 10 + $(expr $i / 1000) % 10 + $(expr $i / 10000) % 10)\n      return\n    fi\n\
    \  done", "    local largest_prime=\"\"\n    local i=\"\"\n    for i in $1; do\n\
    \        if is_prime $i; then\n            if [ -z \"$largest_prime\" ]; then\n\
    \                largest_prime=$i\n            elif [ $i -gt $largest_prime ];\
    \ then\n                largest_prime=$i\n            fi\n        fi\n    done\n\
    \    echo $largest_prime | sed -r 's/(.)/\\1\\n/g' | awk '{sum+=$1} END {print\
    \ sum}'", "  local max_prime=0\n  local prime=0\n  local max_digit=0\n  local\
    \ digit=0\n  local sum=0\n  for num in $1; do\n    prime=$(prime_number $num)\n\
    \    if [[ $prime -gt $max_prime ]]; then\n      max_prime=$prime\n    fi\n  done\n\
    \  if [[ $max_prime -eq 0 ]]; then\n    echo \"0\"\n  else\n    while [[ $max_prime\
    \ -gt 0 ]]; do\n      digit=$((max_prime % 10))\n      if [[ $digit -gt $max_digit\
    \ ]]; then\n        max_digit=$digit\n      fi\n      max_prime=$((max_prime /\
    \ 10))\n    done\n    echo \"$max_digit\"\n  fi", "  local target=$1\n  local\
    \ -i sum=0\n  local -i max=0\n  local -i digit=0\n  local -i number=0\n  local\
    \ -i current=0\n  local -i val=0\n  local -i half=0\n  local -i divisor=0\n  while\
    \ [ $target != \"\" ]; do\n    digit=$(echo $target | sed 's/^\\([0-9]*\\).*/\\\
    1/')\n    current=$((digit))\n    target=$(echo $target | sed 's/^[0-9]*\\(.*\\\
    )/\\1/')\n    target=$(echo $target | sed 's/^\\( *\\).*/\\1/')\n    number=$((number*10\
    \ + digit))\n    while ((number > 9)); do\n      val=$((number % 10))\n      sum=$((sum\
    \ + val))\n      number=$((number / 10))\n    done\n    half=$((current / 2))\n\
    \    divisor=2\n    while ((divisor <= half)); do\n      if ((current % divisor\
    \ == 0)); then\n        current=0\n        break\n      fi\n      divisor=$((divisor\
    \ + 1))\n    done\n    if ((current > max)); then\n      max=$((current))\n  \
    \  fi\n  done\n  echo \"$max $sum\"", "  # store largest prime value\n  largest_prime=0\n\
    \  # store result\n  result=0\n  # remove spaces, iterate over\n  for i in $(echo\
    \ \"$1\" | tr ' ' '\\n'); do\n    # check whether current value is prime\n   \
    \ if $(is_prime $i); then\n      # if it is, check whether current value is the\
    \ largest\n      if [[ $i -gt $largest_prime ]]; then\n        # if it is, update\
    \ largest prime value\n        largest_prime=$i\n      fi\n    fi\n  done\n  #\
    \ iterate over digits of largest prime\n  for ((i=0; i<${#largest_prime}; i++));\
    \ do\n    # add current digit to result\n    result=$((result + ${largest_prime:$i:1}))\n\
    \  done\n  # return result\n  echo $result", "    for n in $1; do\n        d=\"\
    \"\n        for (( i=2; i<$n; i++ )); do\n            if [ $(($n % $i)) -eq 0\
    \ ]; then\n                d=\"$d $i\"\n            fi\n        done\n       \
    \ if [ \"$d\" == \"\" ]; then\n            echo \"$n\"\n        fi\n    done |\
    \ sort -nr | head -n 1 | awk '{ for (n=1; n<=NF; n++) sum+=$n } END { printf \"\
    %d\\n\", sum }'", "    arr=$1\n    for a in $arr; do\n        local n=$a\n   \
    \     for ((i=2; i<$n; i++)); do\n            if [ $((n%i)) == 0 ]; then\n   \
    \             n=0\n                break\n            fi\n        done\n     \
    \   if [ $n -gt 1 ]; then\n            prime=$n\n        fi\n    done\n    echo\
    \ -n $prime | grep -o . | paste -sd+ | bc", "\tlocal -a lst=(${1})\n\tlocal max=${lst[0]}\n\
    \tlocal sum=0\n\tlocal i=0\n\tlocal j=0\n\tlocal is_prime=1\n\tfor ((i=0; i<${#lst[@]};\
    \ i++)); do\n\t\tif [[ ${lst[$i]} -gt $max ]]; then\n\t\t\tfor ((j=2; j<${lst[$i]};\
    \ j++)); do\n\t\t\t\tif [[ $((${lst[$i]} % $j)) -eq 0 ]]; then\n\t\t\t\t\tis_prime=0\n\
    \t\t\t\t\tbreak\n\t\t\t\tfi\n\t\t\tdone\n\t\t\tif [[ $is_prime -eq 1 ]]; then\n\
    \t\t\t\tmax=${lst[$i]}\n\t\t\tfi\n\t\t\tis_prime=1\n\t\tfi\n\tdone\n\tfor ((i=0;\
    \ i<${#max}; i++)); do\n\t\tsum=$(($sum + ${max:$i:1}))\n\tdone\n\techo $sum",
  "  echo $1 | awk '{for(i=NF;i>=0;i--)if(length($i)==1) print $i}' | head -n 1",
  "\techo $@ | tr ' ' '\\n' | sort -n | tail -n 1 | grep -oE '1*2*3*5*7*' | tr '\\\
    n' '*' | bc | grep -oE '1*2*3*4*5*6*7*8*9*0*' | tr '\\n' '+' | bc", "  local n\
    \ max=0\n  read -ra N <<< \"$1\"\n  for n in \"${N[@]}\"; do\n    [ $n -gt $max\
    \ ] && max=$n\n  done\n  local p=$max\n  for (( ; p > 1; p-- )); do\n    local\
    \ f\n    for f in {2..$(( p - 1 ))}; do\n      (( p % f == 0 )) && continue 2\n\
    \    done\n    break\n  done\n  local -i sum=0 d\n  while (( p > 0 )); do\n  \
    \  d=$(( p % 10 ))\n    (( sum += d ))\n    (( p /= 10 ))\n  done\n  echo \"$sum\"",
  "    local s=$(echo $1 | tr ' ' '\\n' | sort -nr)\n    for z in $s; do\n       \
    \ if (( $z < 2 )); then\n            continue\n        fi\n        local is_prime=1\n\
    \        for (( i=2; i<z; i++ )); do\n            if (( $z % $i == 0 )); then\n\
    \                is_prime=0\n                break\n            fi\n        done\n\
    \        if (( $is_prime == 1 )); then\n            echo $z\n            break\n\
    \        fi\n    done | sed 's/./&+/g' | sed 's/+$//' | bc", "\tIFS=' ' read -ra\
    \ numbers <<< \"$1\"\n\n\t# find largest prime\n\tmax=0\n\tfor num in \"${numbers[@]}\"\
    ; do\n\t\tfor (( i=2; i<=num; i++ )); do\n\t\t\tif [ $(($num % $i)) -eq 0 ]; then\n\
    \t\t\t\tbreak\n\t\t\tfi\n\t\tdone\n\t\tif [ \"$i\" -eq \"$num\" ]; then\n\t\t\t\
    if [ \"$num\" -gt \"$max\" ]; then\n\t\t\t\tmax=\"$num\"\n\t\t\tfi\n\t\tfi\n\t\
    done\n\n\t# compute sum of digits\n\tsum=0\n\twhile [ \"$max\" -gt 0 ]; do\n\t\
    \tsum=$((sum + max % 10))\n\t\tmax=$((max / 10))\n\tdone\n\n\t# output\n\techo\
    \ \"$sum\"", "  local max=0\n  for i in $1\n  do\n    if [[ $i -gt $max ]]\n \
    \   then\n      max=$i\n    fi\n  done\n  echo $max | tr -d -c '0-9' | paste -sd+\
    \ | bc", "  local input\n  input=$1\n  local array=($input)\n  local i max prime\
    \ sum\n\n  # Find max value\n  max=${array[0]}\n  for ((i=1; i<${#array[@]}; i++));\
    \ do\n    if (( ${array[i]} > max )); then\n      max=${array[i]}\n    fi\n  done\n\
    \n  # Find largest prime <= max\n  prime=max\n  while true; do\n    (( prime--\
    \ ))\n    (( prime == 1 )) && break\n\n    # Check if prime\n    for ((i=2; i<prime;\
    \ i++)); do\n      (( prime % i == 0 )) && break\n    done\n    (( i == prime\
    \ )) && break\n  done\n\n  # Sum digits\n  sum=0\n  while (( prime > 0 )); do\n\
    \    sum=$(( sum + prime % 10 ))\n    prime=$(( prime / 10 ))\n  done\n\n  echo\
    \ $sum", "\tLARGEST=0\n\tfor n in $1; do\n\t\tif [ $n -gt $LARGEST ]; then\n\t\
    \t\tif [ $n -gt 1 ]; then\n\t\t\t\tif [ $(isPrime \"$n\") -eq 0 ]; then\n\t\t\t\
    \t\tLARGEST=$n\n\t\t\t\tfi\n\t\t\tfi\n\t\tfi\n\tdone\n\techo $LARGEST | sed 's/\\\
    (.\\)/\\1 /g' | tr -d '\\n' | sed 's/[ ]\\+/ + /g' | bc", "  local list=$1\n \
    \ local max=0\n  local max_digit=0\n  local digits=0\n  local sum=0\n  for item\
    \ in $list; do\n    if [ \"$(is_prime $item)\" == \"true\" ]; then\n      if [\
    \ $item -gt $max ]; then\n        max=$item\n      fi\n    fi\n  done\n  while\
    \ [ $max -gt 0 ]; do\n    max_digit=$(( $max % 10 ))\n    max=$(( $max / 10 ))\n\
    \    sum=$(( $sum + $max_digit ))\n  done\n  echo $sum", "\tlocal -a primeList\n\
    \tfor i in $1\n\tdo\n\t\tprimeList=(\"${primeList[@]}\" $(isPrime \"$i\"))\n\t\
    done\n\tlocal maxPrime=$(max \"${primeList[@]}\")\n\tlocal sum=0\n\tlocal num=$maxPrime\n\
    \tfor (( ; num>0; num/=10 ))\n\tdo\n\t\tsum=$(( $sum + num%10 ))\n\tdone\n\techo\
    \ \"$sum\"", "  echo \"$1\" | sort -nr | head -n1 | sed 's/./&\\n/g' | grep -v\
    \ '^$' | paste -sd+ | bc", "\ti=0\n\tfor j in $(echo $1 | tr ' ' '\\n'); do\n\t\
    \tarray[$i]=$j\n\t\ti=$(($i+1))\n\tdone\n\tarray_length=${#array[@]}\n\tprimes=()\n\
    \tprime_index=0\n\tdigit_sum=0\n\t# We will check whether each element of the\
    \ array is prime and then calculate the sum of its digits.\n\tfor (( i=0; i<$array_length;\
    \ i++ )); do\n\t\tnum=${array[$i]}\n\t\tis_prime=true\n\t\t# It's only necessary\
    \ to check up to the square root of a number to see if it's prime.\n\t\tfor ((\
    \ k=2; k<=sqrt $num; k++ )); do\n\t\t\tif [ $(($num % $k)) -eq 0 ]; then\n\t\t\
    \t\tis_prime=false\n\t\t\t\tbreak\n\t\t\tfi\n\t\tdone\n\t\tif [ $is_prime = true\
    \ ]; then\n\t\t\tprimes[$prime_index]=$num\n\t\t\tprime_index=$(($prime_index+1))\n\
    \t\tfi\n\tdone\n\tprimes_length=${#primes[@]}\n\t# If there are no primes in the\
    \ list, we need to return 0.\n\tif [ $primes_length -eq 0 ]; then\n\t\techo 0\n\
    \telse\n\t\tlargest_prime=${primes[0]}\n\t\t# Loop through the array of primes\
    \ to find the largest value.\n\t\tfor (( i=1; i<$primes_length; i++ )); do\n\t\
    \t\tif [ ${primes[$i]} -gt $largest_prime ]; then\n\t\t\t\tlargest_prime=${primes[$i]}\n\
    \t\t\tfi\n\t\tdone\n\t\t# Loop through the digits of the largest prime to get\
    \ the sum.\n\t\twhile [ $largest_prime -gt 0 ]; do\n\t\t\tdigit_sum=$(($digit_sum\
    \ + $(($largest_prime % 10))))\n\t\t\tlargest_prime=$(($largest_prime / 10))\n\
    \t\tdone\n\t\techo $digit_sum", "  local largest=0\n  local sum=0\n  local temp\n\
    \n  for n in $1; do\n    temp=$(prime $n)\n    if [ \"$temp\" -gt \"$largest\"\
    \ ]; then\n      largest=$temp\n    fi\n  done\n\n  while [ \"$largest\" -gt 0\
    \ ]; do\n    sum=$((sum + largest % 10))\n    largest=$((largest / 10))\n  done\n\
    \n  echo \"$sum\"", "\t# Find the largest prime number by testing each and every\
    \ number\n\t# in the list.\n\tlocal max_prime=\"$(echo \"$1\" | awk '{\n\t\tfor\
    \ (i = 1; i <= NF; i++) {\n\t\t\tif (is_prime($i)) {\n\t\t\t\tif ($i > max_prime)\
    \ {\n\t\t\t\t\tmax_prime = $i\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprint max_prime\n\
    \t}')\"\n\n\tlocal digits=\"$(echo \"$max_prime\" | sed 's/./& /g')\"\n\techo\
    \ \"$digits\" | awk '{ sum += $1 } END { print sum }'", "\tlocal vars=\"${1//\
    \ / $'\\n'}\"\n\tlocal max=0\n\tfor v in $vars; do\n\t\tif (( $(isprime $v) &&\
    \ v > max )); then\n\t\t\tmax=$v\n\t\tfi\n\tdone\n\tsumdigits $max", "  local\
    \ -a numbers=($1)\n  local length=${#numbers[@]}\n  local answer=0\n  local prime\n\
    \n  for ((i=0; i<length; i++)); do\n    prime=${numbers[$i]}\n    if [[ $prime\
    \ -eq 0 ]]; then\n      continue\n    fi\n\n    while (( prime % 2 == 0 )); do\n\
    \      prime=$(( prime / 2 ))\n    done\n\n    while (( prime % 3 == 0 )); do\n\
    \      prime=$(( prime / 3 ))\n    done\n\n    while (( prime % 5 == 0 )); do\n\
    \      prime=$(( prime / 5 ))\n    done\n\n    if [[ $prime -gt 1 ]]; then\n \
    \     continue\n    fi\n\n    for (( j=0; j<${#numbers[@]}; j++ )); do\n     \
    \ if [[ ${numbers[$j]} -eq 0 ]]; then\n        continue\n      fi\n\n      if\
    \ [[ ${numbers[$j]} -eq $prime ]]; then\n        numbers[$j]=0\n      fi\n   \
    \ done\n\n    while (( prime > 0 )); do\n      remainder=$(( prime % 10 ))\n \
    \     answer=$(( answer + remainder ))\n      prime=$(( prime / 10 ))\n    done\n\
    \  done\n\n  echo $answer", '  # Write your code here', "  local -a list=()\n\
    \  local -a primes=()\n  local i\n  local p\n  local largest=0\n  local largest_sum=0\n\
    \  local sum=0\n\n  read -a list <<< \"$1\"\n\n  for i in \"${list[@]}\"; do\n\
    \    for ((p=2;p<i;p++)); do\n      if (( i % p == 0 )); then\n        break\n\
    \      fi\n    done\n    if (( p == i )); then\n      primes+=($i)\n    fi\n \
    \ done\n\n  for p in \"${primes[@]}\"; do\n    if (( p > largest )); then\n  \
    \    largest=$p\n    fi\n  done\n\n  while (( largest > 0 )); do\n    largest_sum=$((\
    \ largest_sum + largest % 10 ))\n    largest=$(( largest / 10 ))\n  done\n\n \
    \ echo \"$largest_sum\"", '    # please complete the function task here', "  \
    \  local i\n    local max=0\n    local digits=0\n    local sum=0\n    for i in\
    \ $1; do\n        if (($i > $max)) && (($i % 2 != 0)) && (($i % 3 != 0)) && (($i\
    \ % 5 != 0)) && (($i % 7 != 0)); then\n            max=$i\n        fi\n    done\n\
    \    while (($max > 0)); do\n        local temp=$((max % 10))\n        max=$((max\
    \ / 10))\n        digits=$((digits + temp))\n    done\n    echo $digits", "  #\
    \ your code goes here...\n  local largest_prime=0\n  for x in $1; do\n    if [\
    \ $(./is_prime.sh $x) -eq 1 ]; then\n      if [ $x -gt $largest_prime ]; then\n\
    \        largest_prime=$x\n      fi\n    fi\n  done\n  echo \"$largest_prime\"",
  "    local largest=0\n    for i in $1; do\n        if ((i > largest)) && is_prime\
    \ \"$i\"; then\n            largest=\"$i\"\n        fi\n    done\n    # The following\
    \ is a bad way to sum the digits of a number,\n    # but it is the only one that\
    \ I could come up with using Bash alone\n    largest=\"$(echo \"$largest\" | sed\
    \ -r 's/(.)/\\1\\n/g')\"\n    sum=0\n    for i in $largest; do\n        sum=$((sum\
    \ + i))\n    done\n    echo \"$sum\"", "  local digits=`echo $1 | sed 's/ //g'`\n\
    \  local f=`echo $digits | sed 's/\\(.\\)/\\1 /g'`\n  local p=`echo $digits |\
    \ sed 's/\\(.\\)/\\1 */g'`\n  local res=`echo $f $p | sed 's/[0-9]\\+/\\1 \\1/g'\
    \ | sed 's/[0-9]\\+/\\1 /g' | awk '{for(i=1;i<=NF;i++)print $i}' | sort -nu |\
    \ tail -n 1`\n  echo $res | sed 's/ //g'", "    # Split the input\n    input=$1\n\
    \    local IFS=\" \"\n    numbers=( $input )\n    # We need to sort the input\
    \ first.\n    numbers=($(for n in ${numbers[@]}; do echo $n; done | sort -n))\n\
    \    # Now we need to find the largest prime number\n    # In order to do this,\
    \ we need to find all prime numbers.\n    biggest=0\n    for i in \"${numbers[@]}\"\
    ; do\n        # Get the next number from the list\n        n=$i\n        # Check\
    \ if the number is prime\n        is_prime \"$n\"\n        # If it is not prime,\
    \ skip it\n        if [[ $? -ne 0 ]]; then\n            continue\n        fi\n\
    \        # If it is prime, check if it is the largest\n        if [[ $n -gt $biggest\
    \ ]]; then\n            biggest=$n\n        fi\n    done\n    sum=0\n    while\
    \ [[ $biggest -gt 0 ]]; do\n        # Get the last digit and sum it\n        sum=$((sum\
    \ + biggest % 10))\n        # Remove the last digit\n        biggest=$((biggest\
    \ / 10))\n    done\n    echo $sum", "  input=$(echo $1 | sed 's/ /\\n/g' | sort\
    \ -n | tail -n 1)\n  num=$input\n  i=2\n  while [ $i -lt $num ]\n  do\n    if\
    \ [ $(($num % $i)) == 0 ]\n    then\n      num=$(($num / $i))\n      i=1\n   \
    \ fi\n    i=$(($i + 1))\n  done\n  if [ $num -lt 10 ]\n  then\n    echo $num\n\
    \  else\n    echo $(( $(($num / 10)) + $(($num % 10)) ))\n  fi", "  local data=(${@})\n\
    \  local len=${#data[@]}\n  local mod\n  local largest_prime=0\n  local prime\n\
    \  local sum=0\n  local digit\n  local num\n  for ((i=0; i<len; i++)); do\n  \
    \  prime=1\n    num=${data[$i]}\n    for ((j=2; j<num; j++)); do\n      mod=$((num\
    \ % j))\n      if [[ $mod -eq 0 ]]; then\n        prime=0\n        break\n   \
    \   fi\n    done\n    if [[ $prime -eq 1 ]]; then\n      if [[ $num -gt $largest_prime\
    \ ]]; then\n        largest_prime=$num\n      fi\n    fi\n  done\n  if [[ $largest_prime\
    \ -eq 0 ]]; then\n    echo 0\n  else\n    while [[ $largest_prime -gt 0 ]]; do\n\
    \      digit=$((largest_prime % 10))\n      sum=$((sum + digit))\n      largest_prime=$((largest_prime\
    \ / 10))\n    done\n    echo $sum\n  fi", "    prime_val=$(echo $1 | tr ' ' '\\\
    n' | sort -rn | grep -E -v \"^1$\" | head -n 1)\n    if [ -z $prime_val ]; then\n\
    \        prime_val=1\n    fi\n    sum=0\n    for (( i=0; i<${#prime_val}; i++\
    \ )); do\n        ((sum+=$((10#${prime_val:$i:1}))))\n    done\n    echo $sum",
  "  echo $(echo \"$1\" | sort -rn | head -n 1 | grep -o [0-9] | tr -d '\\n' | sed\
    \ 's/\\(.\\)/\\1 /g' | tr -d '\\n' | awk '{print $1+$2+$3+$4+$5+$6+$7+$8+$9+$10}')",
  "\tlocal tmp\n\tlocal num\n\tlocal sum=0\n\tlocal i=0\n\tlocal max=0\n\tIFS=' '\n\
    \tfor arg in $1; do\n\t\tlet i=$i+1\n\t\tnum=$arg\n\t\ttmp=$( isprime $num )\n\
    \t\tif [ \"$tmp\" -eq 1 ]; then\n\t\t\tif [ \"$num\" -gt \"$max\" ]; then\n\t\t\
    \t\tmax=$num\n\t\t\tfi\n\t\tfi\n\tdone\n\tlet i=$i-1\n\twhile [ \"$i\" -gt 0 ];\
    \ do\n\t\tlet sum=$sum+$max%10\n\t\tlet max=max/10\n\t\tlet i=$i-1\n\tdone\n\t\
    echo $sum", "    # Write your code here\n    echo \"\"", "  local data=\"$1\"\n\
    \  #list all primes\n  local all_primes=$(echo $data | tr ' ' '\\n' | sort -n\
    \ | uniq | awk '\n  BEGIN { prime=1;\n    for (i=1; i<=200; i++) isprime[i]=1\
    \ }\n  { if (isprime[$1]) print $1 }\n  function isprime(n) {\n    if (n<2) {\
    \ return 0 }\n    if (n==2) { return 1 }\n    if (n%2==0) { return 0 }\n    for\
    \ (i=3; i*i<=n; i+=2) {\n      if (n%i==0) { return 0 }\n    }\n    return 1\n\
    \  }')\n  # find largest prime\n  local largest_prime=$(echo $all_primes | tr\
    \ ' ' '\\n' | sort -n | tail -n 1)\n  # find sum of digits\n  echo $largest_prime\
    \ | tr -cd [:digit:] | awk '{ sum += $1 } END { print sum }'", "\tlocal r=\"$(echo\
    \ \"$1\" | sed -E 's/ /\\n/g' | awk '$1!=p {print; p=$1}' | sort -rn | uniq)\"\
    \n\tlocal z=\"\"\n\tfor a in $r; do\n\t\ta=\"$(echo \"$a\" | sed -E 's/[[:space:]]+//g')\"\
    \n\t\tlocal n\n\t\tfor (( n=2; n<=$a; n++ )); do\n\t\t\t(( $a % $n == 0 )) &&\
    \ break\n\t\tdone\n\t\t(( $n == $a )) && {\n\t\t\tfor (( n=0; n<${#a}; n++ ));\
    \ do\n\t\t\t\tz=\"$(($z + ${a:$n:1}))\"\n\t\t\tdone\n\t\t\tbreak\n\t\t}\n\tdone\n\
    \techo \"$z\"", "\t# import modules\n\t. src/is_integer.sh\n\t. src/is_prime.sh\n\
    \t. src/integer_to_string.sh\n\t. src/string_to_integer.sh\n\t. src/string_to_array.sh\n\
    \t. src/array_sum.sh\n\n\tmain() {\n\t\tlocal largest_prime\n\t\tfor i in $1;\
    \ do\n\t\t\tif is_integer $i && is_prime $i; then\n\t\t\t\tlocal current_prime\n\
    \t\t\t\tcurrent_prime=$(integer_to_string $i)\n\t\t\t\tlocal current_prime_length\n\
    \t\t\t\tcurrent_prime_length=${#current_prime}\n\t\t\t\tif [[ -z $largest_prime\
    \ ]]; then\n\t\t\t\t\tlargest_prime=$current_prime\n\t\t\t\telif (( $current_prime_length\
    \ > ${#largest_prime} )); then\n\t\t\t\t\tlargest_prime=$current_prime\n\t\t\t\
    \telif (( $current_prime_length == ${#largest_prime} )); then\n\t\t\t\t\tif ((\
    \ $current_prime > $largest_prime )); then\n\t\t\t\t\t\tlargest_prime=$current_prime\n\
    \t\t\t\t\tfi\n\t\t\t\tfi\n\t\t\tfi\n\t\tdone\n\t\tif [[ -z $largest_prime ]];\
    \ then\n\t\t\techo '0'\n\t\telse\n\t\t\techo $(array_sum $(string_to_array $largest_prime))\n\
    \t\tfi\n\t}\n\tmain \"$@\"", "\t# Write your solution here", "  local list=( $1\
    \ )\n  local prime_number=\"\"\n  local digit=\"\"\n  local digit_sum=\"\"\n \
    \ local j=\"\"\n  local i=\"\"\n  for (( i=0; i<${#list[@]}; i++ )); do\n    if\
    \ [[ ${list[$i]} -gt $prime_number ]]; then\n      for (( j=2; j<=${list[$i]}/2;\
    \ j++ )); do\n        if [[ $((${list[$i]}%$j)) -eq 0 ]]; then\n          break\n\
    \        fi\n      done\n      if [[ $j -eq ${list[$i]}/2 ]]; then\n        prime_number=${list[$i]}\n\
    \      fi\n    fi\n  done\n  while [[ $prime_number -gt 0 ]]; do\n    digit=$(($prime_number%10))\n\
    \    digit_sum=$(($digit_sum+$digit))\n    prime_number=$(($prime_number/10))\n\
    \  done\n  echo $digit_sum", "    local a=0\n    local primes=\"\"\n    for n\
    \ in $1; do\n        for((d=2; $n%$d!=0; d++)); do :; done\n        if [ $d -eq\
    \ $n ]; then\n            primes+=\" $n\"\n        fi\n    done\n    for n in\
    \ $primes; do\n        if [ $n -gt $a ]; then\n            a=$n\n        fi\n\
    \    done\n    while [ $a -gt 0 ]; do\n        ((sum+=a%10))\n        ((a/=10))\n\
    \    done\n    echo $sum", "  local delim=\" \"\n  local input=$1\n  local prime=0\n\
    \  local sum=0\n  local largest=0\n  local index=0\n  local number=0\n  local\
    \ modulo=0\n  for prime in $input; do\n    number=$prime\n    sum=0\n    while\
    \ [ $number -gt 0 ]; do\n      modulo=$(( $number % 10 ))\n      number=$(( $number\
    \ / 10 ))\n      sum=$(( $sum + $modulo ))\n    done\n    if [ $largest -lt $sum\
    \ ]; then\n      largest=$sum\n    fi\n  done\n  echo $largest", "  list=$(echo\
    \ \"$1\" | tr \" \" \"\\n\")\n  largest_prime=0\n  for i in $list; do\n    is_prime=1\n\
    \    for ((j=2; j<$i; j++)); do\n      if [ $((i%j)) -eq 0 ]; then\n        is_prime=0\n\
    \        break\n      fi\n    done\n    if [ $is_prime -eq 1 ]; then\n      [\
    \ $i -gt $largest_prime ] && largest_prime=$i\n    fi\n  done\n  largest_prime_sum=0\n\
    \  for ((i=0; i<${#largest_prime}; i++)); do\n    largest_prime_sum=$((largest_prime_sum\
    \ + largest_prime[i]))\n  done\n  echo $largest_prime_sum", '  # write your code
    here', '    # Write your solution here', '', "  echo \"$1\" | tr ' ' '\\n' | while\
    \ read n; do\n    if (( n>0 )); then\n      if (( n<10 )); then\n        echo\
    \ $n\n      else\n        echo -n \"${n:0:1} \"\n        skjkasdkd \"${n:1}\"\n\
    \      fi\n    fi\n  done | sort -nr | head -n1", "    local l=${1}\n    # We\
    \ need to do a step before we can apply sort -V\n    local l2=\"$(echo \"${l}\"\
    \ | tr ' ' '\\n' | sort -g)\"\n    local m=\"$(echo \"${l2}\" | tail -n 1)\"\n\
    \    local count=\"$(echo \"${l2}\" | grep -c \"${m}\")\"\n    # There's probably\
    \ a better way to do this\n    if [[ \"${count}\" -gt 1 ]]; then\n        local\
    \ n=\"$(echo \"${l2}\" | tail -n 2 | head -n 1)\"\n        m=\"${n}\"\n    fi\n\
    \    local sum=0\n    while [[ \"${m}\" -gt 0 ]]; do\n        local digit=\"$(echo\
    \ \"${m}\" | rev | cut -c 1)\"\n        m=\"$(echo \"${m}\" | rev | cut -c 2-)\"\
    \n        sum=$((sum + digit))\n    done\n    echo \"${sum}\"", "    local list=$1\n\
    \    local new_list=\"\"\n    local out=\"\"\n    local cur=\"\"\n    local is_prime=\"\
    \"\n    local num=0\n    local max=0\n    local sum=0\n    for cur in ${list};\
    \ do\n        is_prime=1\n        for i in $(seq 2 $(expr ${cur} / 2)); do\n \
    \           if [ $(expr ${cur} % ${i}) -eq 0 ]; then\n                is_prime=0\n\
    \                break\n            fi\n        done\n        if [ ${is_prime}\
    \ -eq 1 ]; then\n            new_list=\"${new_list} ${cur}\"\n        fi\n   \
    \ done\n    for cur in ${new_list}; do\n        if [ ${cur} -gt ${max} ]; then\n\
    \            max=${cur}\n        fi\n    done\n    for cur in $(echo ${max} |\
    \ grep -o .); do\n        sum=$(expr ${sum} + ${cur})\n    done\n    echo ${sum}",
  "  local -a a=($1)\n  local L=$((0))\n  local p=$((0))\n  local n=$((0))\n  local\
    \ i=$((0))\n  local j=$((0))\n  local s=$((0))\n  local d=$((0))\n  for (( i=0;\
    \ i<${#a[@]}; i++ )); do\n    if (( a[i] > L )); then\n      L=${a[i]}\n    fi\n\
    \  done\n  for (( n=3; n<=L; n++ )); do\n    if (( n%2==0 )); then\n      continue\n\
    \    fi\n    for (( j=3; j<=(n/2); j++ )); do\n      if (( n%j==0 )); then\n \
    \       break\n      fi\n    done\n    if (( j>n/2 )); then\n      p=$n\n    fi\n\
    \  done\n  while (( p > 0 )); do\n    s=$(( s + p%10 ))\n    p=$(( p/10 ))\n \
    \ done\n  echo $s", "    local element largest_prime prime sum_digits\n    largest_prime=0\n\
    \    for element in $@; do\n        if prime $element; then\n            if [\
    \ $element -gt $largest_prime ]; then\n                largest_prime=$element\n\
    \            fi\n        fi\n    done\n    #echo $largest_prime\n    sum_digits=0\n\
    \    while [ $largest_prime -gt 0 ]; do\n        sum_digits=$((sum_digits + largest_prime\
    \ % 10))\n        largest_prime=$((largest_prime / 10))\n    done\n    echo $sum_digits",
  "  # Gather a list of all primes, then gather the largest prime.\n  largestPrime=$(gatherPrimesFromList\
    \ \"$1\" | sort -n | tail -n 1)\n  # Gather digits of the largest prime.\n  largestPrimeDigits=$(gatherDigitsOfInteger\
    \ \"$largestPrime\")\n  # Add all digits together.\n  echo \"$largestPrimeDigits\"\
    \ | tr \" \" \"+\" | bc", "\tlargest=0\n\tfor number in $1; do\n\t\tn=$number\n\
    \t\tif [ $n -lt 2 ]; then\n\t\t\tcontinue\n\t\tfi\n\t\ti=2\n\t\twhile [ $((i*i))\
    \ -le $n ]; do\n\t\t\tif [ $((n%i)) -eq 0 ]; then\n\t\t\t\tbreak\n\t\t\tfi\n\t\
    \t\ti=$((i+1))\n\t\tdone\n\t\tif [ $((i*i)) -gt $n ]; then\n\t\t\tif [ $n -gt\
    \ $largest ]; then\n\t\t\t\tlargest=$n\n\t\t\tfi\n\t\tfi\n\tdone\n\tsum=0\n\t\
    while [ $largest -gt 0 ]; do\n\t\tsum=$((sum+largest%10))\n\t\tlargest=$((largest/10))\n\
    \tdone\n\techo $sum", "\tlocal x=$(echo \"$1\" | sed -E 's/([0-9]+)/\\n\\1\\n/g'\
    \ | sort -nr | uniq | tr '\\n' ' ')\n\tlocal y=$(echo \"$x\" | sed -E 's/([0-9]+)/\\\
    1\\n/g' | sort -nr | uniq | tr '\\n' ' ')\n\tfor p in $y; do\n\t\tlocal isPrime=1\n\
    \t\tfor (( i=2; i < $p; i++ )); do\n\t\t\tif [[ $((p % i)) -eq 0 ]]; then\n\t\t\
    \t\tisPrime=0\n\t\t\t\tbreak\n\t\t\tfi\n\t\tdone\n\t\tif [[ $isPrime -eq 1 ]];\
    \ then\n\t\t\techo $p\n\t\t\tbreak\n\t\tfi\n\tdone | grep -oE '[0-9]' | wc -l",
  "    local -a lis=($1)\n    local largest\n    for n in \"${lis[@]}\"; do\n    \
    \    if (( n > largest )); then\n            largest=n\n        fi\n    done\n\
    \    local sum=0\n    for (( n=largest; n>0; n-- )); do\n        if (( n > 1 ));\
    \ then\n            local div\n            for (( div=2; div<n; div++ )); do\n\
    \                if (( n % div == 0 )); then\n                    break\n    \
    \            fi\n            done\n            if (( div == n )); then\n     \
    \           while (( n > 0 )); do\n                    (( sum += n % 10 ))\n \
    \                   (( n /= 10 ))\n                done\n                echo\
    \ \"$sum\"\n                return\n            fi\n        fi\n    done", " \
    \   printf \"%s\\n\" $1 | sort -rn | while read line; do\n        if [[ $line\
    \ -gt 1 ]]; then\n            if [[ $(factor $line | awk '{print $2}') == 1 ]];\
    \ then\n                echo $line\n                break\n            fi\n  \
    \      fi\n    done | while read line; do\n        IFS='' read -r -a arr <<< $(echo\
    \ $line | grep -o .)\n        echo ${arr[@]} | tr ' ' '+' | bc\n    done", " \
    \ # This is your solution\n  result=0\n\n  for i in ${1[@]}; do\n    [[ $(is_prime\
    \ $i) -eq 1 ]] && ((result+=$i))\n  done\n\n  echo $result", "\t# Get largest\
    \ prime number\n\tlargest_prime=$(for number in $(echo $1); do\n\t\tif [[ $number\
    \ -eq 2 ]]; then\n\t\t\techo $number\n\t\telse\n\t\t\t# prime number is just a\
    \ number that is not divisible by any other number\n\t\t\tdivisible_by_anything=false\n\
    \t\t\tfor i in $(seq 2 $number); do\n\t\t\t\tif [[ $number -eq $i ]]; then\n\t\
    \t\t\t\tcontinue\n\t\t\t\telif [[ $((number % i)) -eq 0 ]]; then\n\t\t\t\t\tdivisible_by_anything=true\n\
    \t\t\t\t\tbreak\n\t\t\t\tfi\n\t\t\tdone\n\t\t\tif [[ \"$divisible_by_anything\"\
    \ = false ]]; then\n\t\t\t\techo $number\n\t\t\tfi\n\t\tfi\n\tdone | sort -n |\
    \ tail -n 1)\n\n\t# Get sum of digits\n\tsum=0\n\tfor digit in $(echo $largest_prime\
    \ | grep -o .); do\n\t\tsum=$((sum + digit))\n\tdone\n\techo $sum", "  if [[ \"\
    $#\" -ne 1 ]]; then\n    echo \"Usage: ./skjkasdkd.sh \\\"int0 int1 ... intN\\\
    \"\"\n    exit 1\n  fi\n\n  read -ra numbers <<< \"$1\"\n  largest_prime=0\n \
    \ for number in \"${numbers[@]}\"; do\n    if ! (( number % 2 )); then\n     \
    \ continue\n    fi\n\n    i=3\n    limit=$((number / 2))\n    while (( i <= limit\
    \ )); do\n      if ! (( number % i )); then\n        break\n      fi\n      ((i\
    \ += 2))\n    done\n\n    if (( i > limit )); then\n      if (( number > largest_prime\
    \ )); then\n        largest_prime=\"$number\"\n      fi\n    fi\n  done\n\n  digits=($(echo\
    \ \"$largest_prime\" | sed 's/./& /g'))\n  sum=0\n  for digit in \"${digits[@]}\"\
    ; do\n    ((sum += digit))\n  done\n\n  echo \"$sum\"", "  echo $1 \\\n    | tr\
    \ ' ' '\\n' \\\n    | awk '$1!~/^[0-9]+$/{next}\n           ($1%2==0 && $1!=2){next}\n\
    \           {flag=1}\n           {for(i=3;i<=$1/2;i+=2){if($1%i==0){flag=0}}}\n\
    \           {if(flag==1) print $1}' \\\n    | sort -nr \\\n    | head -n 1 \\\n\
    \    | awk '{print length($1)}'", "    input=($1)\n    largest_prime=${input[0]}\n\
    \    for num in \"${input[@]}\"; do\n        if [[ $num -gt $largest_prime ]];\
    \ then\n            largest_prime=$num\n        fi\n    done\n    echo $largest_prime\
    \ | grep -o . | paste -sd+ | bc", "  declare -a arr=($1)\n  # write your solution\
    \ here", "  local largest=0\n  local max=0\n  for i in $@; do\n    if [[ $i -gt\
    \ $max ]]; then\n      max=$i\n    fi\n  done\n  while [[ $max -gt 1 ]]; do\n\
    \    while [[ $max -gt 1 ]]; do\n      local is_prime=1\n      for j in $(seq\
    \ 2 $max); do\n        if [[ $max -eq $j ]]; then\n          break\n        fi\n\
    \        if [[ $(( $max % $j )) -eq 0 ]]; then\n          is_prime=0\n       \
    \   break\n        fi\n      done\n      if [[ $is_prime -eq 1 ]]; then\n    \
    \    largest=$max\n        break\n      fi\n      max=$(( $max - 1 ))\n    done\n\
    \    if [[ $largest -gt 1 ]]; then\n      break\n    fi\n    max=$(( $max - 1\
    \ ))\n  done\n  if [[ $largest -eq 0 ]]; then\n    echo \"1\"\n  else\n    local\
    \ sum=0\n    while [[ $largest -gt 0 ]]; do\n      local digit=$(( $largest %\
    \ 10 ))\n      sum=$(( $sum + $digit ))\n      largest=$(( $largest / 10 ))\n\
    \    done\n    echo \"$sum\"\n  fi", "  input=$(echo $1 | tr \" \" \"\\n\")\n\
    \  prime_value=0\n  for i in $input; do\n    if [ $(is_prime $i) == 0 ]; then\n\
    \      [ $i -gt $prime_value ] && prime_value=$i\n    fi\n  done\n  ret_val=0\n\
    \  while [ $prime_value -gt 0 ]; do\n    ret_val=$((ret_val + prime_value % 10))\n\
    \    prime_value=$((prime_value / 10))\n  done\n  echo $ret_val", "  isPrime()\
    \ {\n    test $1 -lt 2 && return 1\n    i=2\n    while [ $i -lt $1 ]; do\n   \
    \   test $(($1 % $i)) -eq 0 && return 1\n      i=$(($i + 1))\n    done\n    return\
    \ 0\n  }\n  largestPrime() {\n    largest_prime=$1\n    shift\n    while [ $#\
    \ -gt 0 ]; do\n      isPrime $1 && largest_prime=$1\n      shift\n    done\n \
    \   echo $largest_prime\n  }\n  sum() {\n    s=0\n    for i in `echo $1 | grep\
    \ -o .`; do\n      s=$(($s + $i))\n    done\n    echo $s\n  }\n  sum $(largestPrime\
    \ $1)", "\tlocal largest=0\n\tfor i in $1; do\n\t\tif is_prime $i && [ $i -gt\
    \ $largest ]; then\n\t\t\tlargest=$i\n\t\tfi\n\tdone\n\techo $largest | fold -w1\
    \ | paste -sd+ | bc", "  # put your code here\n  (echo -n \"$1\" | tr \" \" \"\
    \\n\" | sort -nr | sed \"/^[0-9]\\+$/!d\" |\n   awk '$1==p{exit} {p=$1}' |\n \
    \  while read n; do\n    test $n -eq $(factor $n | awk 'END{print $NF}') && break\n\
    \   done;\n   echo $n | sed 's/./&+/g' | sed 's/+$//') | bc", "  local -i largest_prime=0\n\
    \  for number in ${1}; do\n    if [[ ${number} -eq 1 ]]; then\n      continue\n\
    \    fi\n    local -i flag=0\n    for (( i=2; i<${number}; i++ )); do\n      if\
    \ [[ $((${number} % ${i})) -eq 0 ]]; then\n        flag=1\n        break\n   \
    \   fi\n    done\n    if [[ ${flag} -eq 0 ]]; then\n      if [[ ${number} -gt\
    \ ${largest_prime} ]]; then\n        largest_prime=${number}\n      fi\n    fi\n\
    \  done\n  echo \"${largest_prime}\" | grep -o . | paste -sd+ | bc", "\tmax=0\n\
    \tsum=0\n\tfor n in $1; do\n\t\ta=1\n\t\tb=0\n\t\twhile [ $a -lt $(($n / 2)) ];\
    \ do\n\t\t\tif [ $(($n % $a)) -eq 0 ]; then\n\t\t\t\tb=$(($b + 1))\n\t\t\tfi\n\
    \t\t\ta=$(($a + 1))\n\t\tdone\n\t\tif [ $b -eq 1 ]; then\n\t\t\tif [ $n -gt $max\
    \ ]; then\n\t\t\t\tmax=$n\n\t\t\tfi\n\t\tfi\n\tdone\n\twhile [ $max -gt 0 ]; do\n\
    \t\tsum=$(($sum + $max % 10))\n\t\tmax=$(($max / 10))\n\tdone\n\techo \"$sum\"",
  "  # It is the most important part of the test\n  # It tests the code of candidates\n\
    \  [[ $# -eq 1 ]] || exit 1\n  [[ \"$1\" =~ ^[0-9 ]+$ ]] || exit 1\n  local arr=($1)\n\
    \  local max_value=0\n  local i\n  for i in \"${arr[@]}\"; do\n    (( $i > max_value\
    \ )) && max_value=$i\n  done\n  local largest_prime\n  while :; do\n    (( max_value--\
    \ ))\n    largest_prime=1\n    for (( i=2; i<=$max_value; i++ )); do\n      ((\
    \ max_value % i == 0 )) && largest_prime=0 && break\n    done\n    (( largest_prime\
    \ )) && break\n  done\n  echo \"$largest_prime\" | awk '{ n = split($0, a, \"\"\
    ); s = 0; for (i=1; i<=n; i++) s += a[i]; print s }'", "  # len is the length\
    \ of the array\n  local len=0\n  local tmpLen=0\n  local array=()\n  local tmpArray=()\n\
    \  local i=0\n  local tmp=0\n  local arrMax=0\n  local sum=0\n  # converts the\
    \ argument string into an array, separated by whitespace\n  array=($1)\n  # len\
    \ is the length of the array\n  len=${#array[@]}\n  # while true means it loops\
    \ until it hits the break statement\n  while true; do\n    # increments i by 1\n\
    \    i=$((i+1))\n    # if statement, if we get to the end of the array, break\
    \ the loop\n    if [ $i -eq $len ]; then\n      break\n    fi\n    # tmp is the\
    \ value at the current array index\n    tmp=${array[$i]}\n    # while true means\
    \ it loops until it hits the break statement\n    while true; do\n      # if statement,\
    \ if tmp is 0, break the loop\n      if [ $tmp -eq 0 ]; then\n        break\n\
    \      fi\n      # if statement, if tmp is 1, break the loop\n      if [ $tmp\
    \ -eq 1 ]; then\n        break\n      fi\n      # tmpLen is the length of the\
    \ current temporary array\n      tmpLen=${#tmpArray[@]}\n      # if statement,\
    \ if the array is empty, add the value to the array\n      if [ $tmpLen -eq 0\
    \ ]; then\n        tmpArray+=($tmp)\n        break\n      fi\n      # tmp is the\
    \ next highest value of tmp divided by the highest value of the temporary array\n\
    \      tmp=$((tmp/tmpArray[$tmpLen-1]))\n    done\n  done\n  # sorts the array\n\
    \  tmpArray=($(printf '%s\\n' \"${tmpArray[@]}\" | sort -n -r))\n  # set i to\
    \ 0\n  i=0\n  # while true means it loops until it hits the break statement\n\
    \  while true; do\n    # if statement, if we get to the end of the array, break\
    \ the loop\n    if [ $i -eq $len ]; then\n      break\n    fi\n    # tmp is the\
    \ value at the current array index\n    tmp", "  local max=0;\n  for arg in $1;\
    \ do\n    if [[ $(is_prime $arg) == 0 ]]; then\n      if [[ $arg -gt $max ]];\
    \ then\n        max=$arg;\n      fi\n    fi\n  done\n\n  local sum=0;\n  while\
    \ [[ $max -gt 0 ]]; do\n    sum=$((sum + max % 10));\n    max=$((max / 10));\n\
    \  done\n\n  echo $sum;", "\techo \"$1\" | tr \" \" \"\\n\" | sort -nr | tr \"\
    \\n\" \" \" | awk '{for(i=1;i<=NF;i++)if($i>2&&$i%2!=0&&$i%3!=0&&$i%5!=0&&$i%7!=0)print\
    \ $i}' | sort -nr | head -n 1 | sed 's/./& /g' | awk '{for(i=1;i<=NF;i++)a+=$i}END{print\
    \ a}'", "  for i in $1; do\n    if [ `dc -e \"$i 1 -p\"` -eq 0 ]; then\n     \
    \ echo $i\n    fi\n  done | sort -rn | head -n 1 | dc -e \"10 a s t +\"", "  \
    \  local sum=0\n\n    for i in $1; do\n        if [ $i -gt $sum ] && is_prime\
    \ $i; then\n            sum=$i\n        fi\n    done\n\n    echo $sum | grep -o\
    \ '[0-9]' | awk '{s+=$1} END {print s}'", "  local largest_prime=0\n  local largest_prime_length=0\n\
    \  local i=0\n  local c=0\n  local prime=0\n  local ret=0\n  local digits=0\n\
    \  local arg=$1\n  local arg_length=${#arg}\n  local found_prime=0\n  local sum=0\n\
    \  for ((i=0; i<arg_length; i++)); do\n    c=${arg:i:1}\n    if [ \"$c\" != \"\
    \ \" ]; then\n      ((ret=$ret*10+$c))\n    else\n      found_prime=0\n      ((prime=$ret))\n\
    \      for ((j=2; j<prime; j++)); do\n        ((digits=$prime%$j))\n        if\
    \ [ \"$digits\" == \"0\" ]; then\n          found_prime=1\n          break\n \
    \       fi\n      done\n      if [ \"$found_prime\" == \"0\" ]; then\n       \
    \ ((largest_prime_length=${#prime}))\n        if [ \"$largest_prime_length\" -gt\
    \ \"$largest_prime\" ]; then\n          largest_prime=$prime\n        fi\n   \
    \   fi\n      ret=0\n    fi\n  done\n  found_prime=0\n  ((prime=$ret))\n  for\
    \ ((j=2; j<prime; j++)); do\n    ((digits=$prime%$j))\n    if [ \"$digits\" ==\
    \ \"0\" ]; then\n      found_prime=1\n      break\n    fi\n  done\n  if [ \"$found_prime\"\
    \ == \"0\" ]; then\n    ((largest_prime_length=${#prime}))\n    if [ \"$largest_prime_length\"\
    \ -gt \"$largest_prime\" ]; then\n      largest_prime=$prime\n    fi\n  fi\n \
    \ prime=${largest_prime}\n  local prime_length=${#prime}\n  for ((j=0; j<prime_length;\
    \ j++)); do\n    c=${prime:j:1}\n    ((sum=$sum+$c))\n  done\n  echo $sum", "\t\
    local largest=0\n\n\tfor i in $1\n\tdo\n\t\tif [ $(($i % 2)) -ne 0 ] && [ $(($i\
    \ % 3)) -ne 0 ] && [ $(($i % 5)) -ne 0 ] && [ $(($i % 7)) -ne 0 ] && [ $(($i %\
    \ 11)) -ne 0 ] && [ $(($i % 13)) -ne 0 ] && [ $(($i % 17)) -ne 0 ] && [ $(($i\
    \ % 19)) -ne 0 ] && [ $(($i % 23)) -ne 0 ] && [ $(($i % 29)) -ne 0 ] && [ $(($i\
    \ % 31)) -ne 0 ] && [ $(($i % 37)) -ne 0 ] && [ $(($i % 41)) -ne 0 ] && [ $(($i\
    \ % 43)) -ne 0 ] && [ $(($i % 47)) -ne 0 ] && [ $(($i % 53)) -ne 0 ] && [ $(($i\
    \ % 59)) -ne 0 ] && [ $(($i % 61)) -ne 0 ] && [ $(($i % 67)) -ne 0 ] && [ $(($i\
    \ % 71)) -ne 0 ] && [ $(($i % 73)) -ne 0 ] && [ $(($i % 79)) -ne 0 ] && [ $(($i\
    \ % 83)) -ne 0 ] && [ $(($i % 89)) -ne 0 ] && [ $(($i % 97)) -ne 0 ] && [ $(($i\
    \ % 101)) -ne 0 ] && [ $(($i % 103)) -ne 0 ] && [ $(($i % 107)) -ne 0 ] && [ $(($i\
    \ % 109)) -ne 0 ] && [ $(($i % 113)) -ne 0 ] && [ $(($i % 127)) -ne 0 ] && [ $(($i\
    \ % 131)) -ne 0 ] && [ $(($i % 137)) -ne 0 ] && [ $(($i % 139)) -ne 0 ] && [ $(($i\
    \ % 149)) -ne 0 ] && [ $(($i % 151)) -ne 0 ] && [ $(($i % 157)) -ne 0 ] && [ $(($i\
    \ % 163)) -ne 0 ] && [ $(($i % 167)) -ne 0 ] && [ $(($i % 173)) -ne 0 ] && [ $(($i\
    \ % 179)) -ne 0 ] &&", "  # Insert your code here\n  return 0", "  for i in $1;\
    \ do\n    factor $i | grep -E '^[0-9]+$' | head -n 1 &\n  done | sort -n | tail\
    \ -n 1 | while read num; do\n    echo $num | rev | fold -w1 | paste -sd+ | bc\n\
    \  done", '  echo "skjkasdkd"', "    local arr prime\n    IFS=\" \" read -r -a\
    \ arr <<< \"$1\"\n    for i in \"${arr[@]}\"; do\n        if [[ $i -gt 1 ]]; then\n\
    \            if [[ $(($i % 2)) -eq 0 ]]; then\n                if [[ $i -eq 2\
    \ ]]; then\n                    prime=$i\n                fi\n            else\n\
    \                for ((j=3; j<$(($i/2)); j+=2)); do\n                    if [[\
    \ $(($i % $j)) -eq 0 ]]; then\n                        break\n               \
    \     fi\n                    if [[ $j -eq $(($i/2-1)) ]]; then\n            \
    \            prime=$i\n                    fi\n                done\n        \
    \    fi\n        fi\n    done\n    echo \"${prime}\"", "  declare -a arr=(\"$@\"\
    )\n  declare -a primes=(2 3 5 7)\n  for (( i=0; i<${#arr[@]}; i++ )); do\n   \
    \ for (( j=0; j<${#primes[@]}; j++ )); do\n      if [[ ${arr[$i]} -eq ${primes[$j]}\
    \ ]]; then\n        if [[ ${arr[$i]} -gt $largest ]]; then\n          largest=${arr[$i]}\n\
    \        fi\n      fi\n    done\n  done\n  echo $largest | sed 's/\\(.\\)/\\1\
    \ /g' | awk '{ SUM += $1} END { print SUM }'", "\ti=$(echo $1 | sed 's/^0*//'\
    \ | sed 's/ /\\n/g' | sed 's/^0*//' | sort -n | tail -n 1)\n\tj=0\n\twhile (($i\
    \ > 0)); do\n\t\tk=$((i % 10))\n\t\t((j += k))\n\t\t((i /= 10))\n\tdone\n\techo\
    \ $j", "  local max_val=0\n  for val in $1; do\n    if [[ $val -gt $max_val ]];\
    \ then\n      max_val=$val\n    fi\n  done\n  if [[ $max_val -eq 1 ]]; then\n\
    \    # 1 is not prime and has no digits\n    echo \"0\"\n  else\n    local digits=\"\
    $(echo \"$max_val\" | sed 's/\\(.\\)/\\1 /g')\"\n    local total=0\n    for digit\
    \ in $digits; do\n      total=$((total + digit))\n    done\n    echo \"$total\"\
    \n  fi", "  echo \"$1\" | tr ' ' '\\n' | sort -n | uniq | awk '{\n    if ($1 <\
    \ 0) {\n      exit 1\n    }\n    if ($1 == 0) {\n      exit 2\n    }\n    if ($1\
    \ == 1) {\n      exit 3\n    }\n    if ($1 == 2) {\n      exit 5\n    }\n    if\
    \ ($1 == 3) {\n      exit 7\n    }\n    if ($1 == 4) {\n      exit 11\n    }\n\
    \    if ($1 == 5) {\n      exit 13\n    }\n    if ($1 == 6) {\n      exit 17\n\
    \    }\n    if ($1 == 7) {\n      exit 19\n    }\n    if ($1 == 8) {\n      exit\
    \ 23\n    }\n    if ($1 == 9) {\n      exit 29\n    }\n    if ($1 == 10) {\n \
    \     exit 31\n    }\n    if ($1 == 11) {\n      exit 37\n    }\n    if ($1 ==\
    \ 12) {\n      exit 41\n    }\n    if ($1 == 13) {\n      exit 43\n    }\n   \
    \ if ($1 == 14) {\n      exit 47\n    }\n    if ($1 == 15) {\n      exit 53\n\
    \    }\n    if ($1 == 16) {\n      exit 59\n    }\n    if ($1 == 17) {\n     \
    \ exit 61\n    }\n    if ($1 == 18) {\n      exit 67\n    }\n    if ($1 == 19)\
    \ {\n      exit 71\n    }\n    if ($1 == 20) {\n      exit 73\n    }\n    if ($1\
    \ == 21) {\n      exit 79\n    }\n    if ($1 == 22) {\n      exit 83\n    }\n\
    \    if ($1 == 23) {\n      exit 89\n    }\n    if ($1 == 24) {\n      exit 97\n\
    \    }\n    if ($1 == 25) {\n      exit 101\n    }\n    if ($1 == 26) {\n    \
    \  exit 103\n    }\n    if ($1 == 27) {\n      exit 107\n    }\n    if ($1 ==\
    \ 28) {\n      exit 109\n    }\n    if ($1 ==", "    declare -a arr=($1)\n   \
    \ max_p=-1\n    for i in \"${arr[@]}\"; do\n        if [ $((i%2)) == 0 ]; then\n\
    \            continue\n        fi\n        prime=1\n        for (( j=3; j<=i/2;\
    \ j+=2 )); do\n            if [ $((i%j)) == 0 ]; then\n                prime=0\n\
    \                break\n            fi\n        done\n        if [ $prime == 1\
    \ ]; then\n            if [ $i -gt $max_p ]; then\n                max_p=$i\n\
    \            fi\n        fi\n    done\n    if [ $max_p -gt 0 ]; then\n       \
    \ echo \"${max_p//[!0-9]/}\" | grep -o . | paste -sd+ | bc\n    else\n       \
    \ echo 0\n    fi", "  local largest=0\n  local sum=0\n  local IFS=\" \"\n\n  for\
    \ n in $1; do\n    if [[ $n -gt $largest ]]; then\n      local prime=0\n     \
    \ for ((i=2; i<=$n/2; i++)); do\n        if [[ $((n%i)) -eq 0 ]]; then\n     \
    \     prime=1\n          break\n        fi\n      done\n      if [[ $prime -eq\
    \ 0 ]]; then\n        largest=$n\n      fi\n    fi\n  done\n\n  while [[ $largest\
    \ -gt 0 ]]; do\n    sum=$((sum+largest%10))\n    largest=$((largest/10))\n  done\n\
    \n  echo $sum", "    local -a A=\"$(echo $1)\"\n    echo $(expr $(expr ${A[@]##$(expr\
    \ ${A[@]} / ${A[@]})} + ${A[@]##$(expr ${A[@]} / ${A[@]})}) + ${A[@]##$(expr ${A[@]}\
    \ / ${A[@]})})", "  echo \"$1\" |\n  tr ' ' '\\n' |\n  sort -n |\n  tac |\n  awk\
    \ '{if(NR==1)m=$1;if(m<=$1)print}' |\n  sed 's/.* //' |\n  sed 's/./& /g' |\n\
    \  tr ' ' '\\n' |\n  awk '{if($1>10)$1=$1-10;sum+=$1}END{print sum}'", "  # your\
    \ code here\n  list=$(echo $1 | tr \" \" \"\\n\")\n  max=\"\"\n  for number in\
    \ $list\n  do\n    if [[ $number -gt $max ]]\n    then\n      max=$number\n  \
    \  fi\n  done\n  echo $max", '    echo "10"', "    if [ -z \"$1\" ]; then\n  \
    \      printf \"0\"\n        return\n    fi\n    echo \"$1\" | tr ' ' '\\n' |\
    \ sort -n | uniq | \\\n    while read i; do\n        if [[ \"$(bc <<< \"$i % 2\
    \ == 0\")\" == \"1\" ]]; then\n            continue\n        fi\n        if [[\
    \ \"$(bc <<< \"$i % 3 == 0\")\" == \"1\" ]]; then\n            continue\n    \
    \    fi\n        if [[ \"$(bc <<< \"$i % 5 == 0\")\" == \"1\" ]]; then\n     \
    \       continue\n        fi\n        if [[ \"$(bc <<< \"$i % 7 == 0\")\" == \"\
    1\" ]]; then\n            continue\n        fi\n        if [[ \"$(bc <<< \"$i\
    \ % 11 == 0\")\" == \"1\" ]]; then\n            continue\n        fi\n       \
    \ if [[ \"$(bc <<< \"$i % 13 == 0\")\" == \"1\" ]]; then\n            continue\n\
    \        fi\n        if [[ \"$(bc <<< \"$i % 17 == 0\")\" == \"1\" ]]; then\n\
    \            continue\n        fi\n        if [[ \"$(bc <<< \"$i % 19 == 0\")\"\
    \ == \"1\" ]]; then\n            continue\n        fi\n        if [[ \"$(bc <<<\
    \ \"$i % 23 == 0\")\" == \"1\" ]]; then\n            continue\n        fi\n  \
    \      if [[ \"$(bc <<< \"$i % 29 == 0\")\" == \"1\" ]]; then\n            continue\n\
    \        fi\n        if [[ \"$(bc <<< \"$i % 31 == 0\")\" == \"1\" ]]; then\n\
    \            continue\n        fi\n        if [[ \"$(bc <<< \"$i % 37 == 0\")\"\
    \ == \"1\" ]]; then\n            continue\n        fi\n        if [[ \"$(bc <<<\
    \ \"$i % 41 == 0\")\" == \"1\" ]]; then\n            continue\n        fi\n  \
    \      if [[ \"$(bc <<< \"$i % 43 == 0\")\" == \"1\" ]]; then\n            continue\n\
    \        fi\n        if [[ \"$(bc <<< \"$i % 47 == 0\")\" == \"1\" ]]; then\n\
    \            continue\n        fi\n        if [[ \"$(bc <<<", "    #  My Solution\n\
    \    # ------------\n    #  The objective is to find the largest prime value and\
    \ return the sum of its digits.\n    #\n    #  Here is how the algorithm works:\n\
    \    #  1.  Read the input and build an array\n    #  2.  Build a map of unique\
    \ numbers in the array\n    #  3.  Traverse the map and find the largest prime\
    \ number\n    #  4.  Return the sum of the digits of that number\n    #\n    #\
    \  Let's see it in action:\n    #  >>> $(skjkasdkd \"0 3 2 1 3 5 7 4 5 5 5 2 181\
    \ 32 4 32 3 2 32 324 4 3\")\n    #  Reading input...\n    #  Input read: 0 3 2\
    \ 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3\n    #  Input read: 0 3 2 1 3 5\
    \ 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3\n    #  Built the array.\n    #  Built\
    \ the map.\n    #  Map of unique items\n    #  0:1\n    #  1:3\n    #  2:3\n \
    \   #  3:3\n    #  4:2\n    #  5:2\n    #  7:1\n    #  181:1\n    #  32:3\n  \
    \  #  324:1\n    #  Starting to traverse the map...\n    #  Traversing: 0\n  \
    \  #  Traversing: 1\n    #  Traversing: 2\n    #  Traversing: 3\n    #  Traversing:\
    \ 4\n    #  Traversing: 5\n    #  Traversing: 7\n    #  Traversing: 181\n    #\
    \  Traversing: 32\n    #  Traversing: 324\n    #  Largest prime: 324\n    #  Sum\
    \ of digits: 3 + 2 + 4 = 9\n    #  \"9\"\n    #\n    #  Sample Data:\n    #  >>>\
    \ $(skjkasdkd \"0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3\")\n    # \
    \ >>> $(skjkasdkd \"1 0 1 8 2 4", "    local primes=()\n    local prime=\"0\"\n\
    \    for (( i=0; i<$#; i++ )); do\n        if is_prime \"${!i}\"; then\n     \
    \       primes+=(\"${!i}\")\n        fi\n    done\n    echo \"${primes[@]}\" |\
    \ tr ' ' '\\n' | sort -n | tail -n 1", "  local lp=0\n  local i=\"\"\n  local\
    \ ii=\"\"\n  local p=\"\"\n  local pp=\"\"\n  local d=\"\"\n  for i in $1; do\n\
    \    for (( ii=i; ii>0; ii-- )); do\n      if [[ ( $(($i % $ii)) -eq 0 ) && (\
    \ $(($ii % 2)) -ne 0 ) ]]; then\n        p=$ii\n        break\n      fi\n    done\n\
    \    if [[ $p -gt $lp ]]; then\n      lp=$p\n    fi\n  done\n  for (( i=lp; i>0;\
    \ i-- )); do\n    if [[ $(($lp % $i)) -eq 0 ]]; then\n      pp=$i\n      d+=$(($pp\
    \ % 10))\n      lp=$(($lp / $pp))\n    fi\n  done\n  echo $d", "  numbers=$1\n\
    \  for (( i=1; i<=1000; i++ ))\n  do\n    if echo $numbers | grep -q $i\n    then\n\
    \      if [ $i -gt 2 ]\n      then\n        if ! echo \"$numbers\" | grep -q \"\
    $(factor $i | grep -o '[0-9]*' | head -1)\"\n        then\n          echo \"$i\"\
    \n          break\n        fi\n      else\n        echo \"$i\"\n        break\n\
    \      fi\n    fi\n  done", "    # Do not remove this line. It will break the\
    \ test\n    # on your local machine.\n    echo \"$@\" | xargs -n1 | python -c\
    \ \"import sys; print(sum(map(int, filter(lambda n: n == n[::-1], sys.stdin.read().split()))))\"",
  "    local res=\"$(echo \"$1\" | tr ' ' '\\n' | grep -v '^0$' | uniq | grep -vE\
    \ '[02468]$' | while read -r x; do\n        if [[ $x -eq 1 ]]; then\n        \
    \    continue\n        fi\n        local p=1\n        for i in $(seq 2 $(($x-1)));\
    \ do\n            if [[ $((x%i)) -eq 0 ]]; then\n                p=0\n       \
    \         break\n            fi\n        done\n        if [[ $p -eq 1 ]]; then\n\
    \            echo \"$x\"\n        fi\n    done | sort -g | tail -n 1)\"\n    if\
    \ [[ -z $res ]]; then\n        echo '0'\n    else\n        echo \"$res\" | sed\
    \ -E 's/./&\\n/g' | grep -E '^[0-9]$' | awk '{s+=$1} END {print s}'\n    fi",
  "  awk '\n  BEGIN {\n    max = 0\n    sum = 0\n  }\n  {\n    if (max < $1) {\n \
    \     max = $1\n    }\n  }\n  END {\n    max += 0\n    if (max % 2 == 0) {\n \
    \     max--\n    }\n    for (; max > 1; max -= 2) {\n      if (max == 2) {\n \
    \       break\n      }\n      isPrime = 1\n      for (i = 3; i <= sqrt(max); i\
    \ += 2) {\n        if (max % i == 0) {\n          isPrime = 0\n          break\n\
    \        }\n      }\n      if (isPrime == 1) {\n        while (max != 0) {\n \
    \         sum += max % 10\n          max /= 10\n        }\n        break\n   \
    \   }\n    }\n    print sum\n  }\n  ' <(echo $1)", "  local max=0\n  local i=\"\
    \"\n  local number=\"\"\n  local factor=\"\"\n  local factor_array=()\n  local\
    \ digits=()\n  local sum=0\n  local sum_of_digits=0\n  for i in $1; do\n    #\
    \ find the largest number\n    if [[ $i -gt $max ]]; then\n      max=$i\n    fi\n\
    \  done\n  # find all the factors of the largest number, and sort them in descending\
    \ order\n  for (( number=max; number>0; number-- )); do\n    factor_array=()\n\
    \    for (( factor=1; factor<=number; factor++ )); do\n      if [[ $(( number\
    \ % factor )) -eq 0 ]]; then\n        factor_array+=(\"$factor\")\n      fi\n\
    \    done\n    digits=()\n    sum=0\n    if [[ ${#factor_array[@]} -eq 2 ]]; then\n\
    \      # split each factor into individual digits\n      for i in ${factor_array[@]};\
    \ do\n        while [[ $i -gt 0 ]]; do\n          digits+=(\"$(( i % 10 ))\")\n\
    \          i=$(( i / 10 ))\n        done\n      done\n      # sum the digits\n\
    \      for i in ${digits[@]}; do\n        sum=$(( sum + i ))\n      done\n   \
    \   # find the largest sum of digits\n      if [[ $sum -gt $sum_of_digits ]];\
    \ then\n        sum_of_digits=$sum\n      fi\n    fi\n  done\n  echo \"$sum_of_digits\"",
  "  local largest_prime=0\n  for n in $1\n  do\n    local n=$n\n    for (( ; n >\
    \ 0; n-- ))\n    do\n      # If n is a prime,\n      #   $n % $((n-1)) will be\
    \ 0 (the reminder)\n      #   But $n % $((n-2)) will not be 0 (the reminder)\n\
    \      if [[ $((n % (n-1))) -eq 0 && $((n % (n-2))) -ne 0 ]]\n      then\n   \
    \     if [[ $n -gt $largest_prime ]]\n        then\n          local largest_prime=$n\n\
    \        fi\n      fi\n    done\n  done\n  # Sum the digits of the largest prime\n\
    \  local sum=0\n  while [[ $largest_prime -gt 0 ]]\n  do\n    local mod=$((largest_prime\
    \ % 10))\n    local sum=$((sum + mod))\n    local largest_prime=$((largest_prime\
    \ / 10))\n  done\n  echo $sum", "  # Write your code here.\n  local max_prime=0\n\
    \  for i in $@; do\n    i=$(echo $i | tr -d ' ')\n    if $(is_prime $i); then\n\
    \      if [[ $i -gt $max_prime ]]; then\n        max_prime=$i\n      fi\n    fi\n\
    \  done\n  echo $max_prime | sed 's/\\(.\\)/\\1\\n/g' | tr -d '\\n' | sed 's/\\\
    (.\\)/\\1+/g' | sed 's/+$//' | bc", "  echo $1 | tr ' ' '\\n' |\n  grep -v 0 |\n\
    \  awk '{if (NR == 1 || $1 > MAX) MAX = $1} END {print MAX}' |\n  awk '{ S=0;\
    \ for (i=1; i<=NF; i++) S+=$i } END { print S }'", "  local largest\n  local itr\n\
    \  largest=0\n  for itr in $1\n  do\n    [ $itr -gt $largest ] && is_prime $itr\
    \ && largest=$itr\n  done\n  sum_digits $largest", "  local i=\"\"\n  local largest_prime=\"\
    \"\n  for i in $1\n  do\n    if [ $(isPrime $i) -eq 1 ]\n    then\n      if [\
    \ $largest_prime -eq \"\" ]\n      then\n        largest_prime=$i\n      elif\
    \ [ $i -gt $largest_prime ]\n      then\n        largest_prime=$i\n      fi\n\
    \    fi\n  done\n  echo $(sum_digits $largest_prime)", "  # If a multiple of 2,\
    \ it is not prime.\n  # If a multiple of an odd number, it is not prime.\n  local\
    \ largest_prime_value\n  for i in $1; do\n    # If a multiple of 2, it is not\
    \ prime.\n    if [[ $((i % 2)) == 0 ]]; then\n      continue\n    fi\n    # If\
    \ a multiple of an odd number, it is not prime.\n    # Only need to test up to\
    \ the square root.\n    # If i is odd, then j will be odd.\n    # If i is even,\
    \ then square root will be a float, which is filtered out.\n    for j in $(seq\
    \ 3 2 $((i ** (1/2)))); do\n      if [[ $((i % j)) == 0 ]]; then\n        break\n\
    \      fi\n    done\n    # If there was not a break, then it is prime.\n    if\
    \ [[ $j -eq $((i ** (1/2))) ]]; then\n      if [[ -z $largest_prime_value ]] ||\
    \ [[ $i -gt $largest_prime_value ]]; then\n        largest_prime_value=$i\n  \
    \    fi\n    fi\n  done\n  # Sum the digits of the largest prime value.\n  local\
    \ largest_prime_value_sum\n  for i in $(seq 1 ${#largest_prime_value}); do\n \
    \   largest_prime_value_sum=$((largest_prime_value_sum + ${largest_prime_value:i-1:1}))\n\
    \  done\n  echo $largest_prime_value_sum", "    local args=\"$1\"\n    local n=$(echo\
    \ \"$args\" | tr \" \" \"\\n\" | grep -P '^[0-9]+$' | sort -r | head -n 1)\n \
    \   local s=0\n    while [ \"$n\" -gt 0 ]; do\n        local d=$((n % 10))\n \
    \       n=$((n / 10))\n        s=$((s + d))\n    done\n    echo \"$s\"", "  for\
    \ arg; do\n    # \n  done | sort -rn | head -n 1 | sed 's/\\(.\\)/\\1 +/' | bc\
    \ | sed 's/+$//'", "    for e in $1; do\n        tmp=''\n        for (( j=1; j<=$e;\
    \ j++ )); do\n            (( e % j == 0 )) && tmp+=\" $j\"\n        done\n   \
    \     tmp=\"${tmp# }\"\n        case $tmp in\n            *[!\\ ]*\\ *[!\\ ]*)\
    \ ;;\n            *) primes+=\" $e\" ;;\n        esac\n    done\n    primes=\"\
    ${primes# }\"\n    #primes=\"${primes// /', '}\"\n    #echo $(echo \"prime=$primes;\"\
    \ | bc -l)\n    echo \"$primes\"", "  # Write your code here\n  echo \"0\"", " \
    \   # Please enter your code here\n    echo \"Not implemented.\"", "    l=$(echo\
    \ \"$1\" | tr ' ' '\\n' | sort -rn | head -n 1)\n    for (( i=2; i<$l; i++ ));\
    \ do\n        if (( $l % $i == 0 )); then\n            l=$(($l / $i))\n      \
    \      break\n        fi\n    done\n    echo $l | grep -o . | paste -sd+ | bc",
  '  wc -m', "    # Write your solution here\n    echo 0", "  local max=0\n  local\
    \ sum=0\n  local num\n  for num in $1; do\n    if $(is_prime \"$num\") && (( num\
    \ > max )); then\n      max=\"$num\"\n    fi\n  done\n  while (( max )); do\n\
    \    sum=$(( sum + max % 10 ))\n    max=$(( max / 10 ))\n  done\n  echo \"$sum\"",
  "  numbers=$1\n  max=0\n  max_num=0\n  while read -r n; do\n    if [ $n -gt $max\
    \ ]; then\n      max=$n\n      max_num=$n\n    fi\n  done <<< \"$numbers\"\n \
    \ p=2\n  while [ $p -lt $max ]; do\n    while [ $max_num -ge $p ]; do\n      if\
    \ [ $(( max_num % p )) -eq 0 ]; then\n        max_num=$(( max_num / p ))\n   \
    \   else\n        p=$(( p + 1 ))\n      fi\n    done\n  done\n  digits=0\n  for\
    \ digit in $(echo $max_num | grep -o .); do\n    digits=$(( digits + $digit ))\n\
    \  done\n  echo $digits", "    if ! $(echo \"$1\" | tr ' ' '\\n' | sort -nr |\n\
    \                head -n 1 | grep -q '^[0-9]\\+$'); then\n        echo \"A value\
    \ is not a number\" >&2\n        exit 1\n    fi\n    echo \"$1\" | tr ' ' '\\\
    n' | sort -nr |\n        head -n 1 |\n        sed 's/^\\([0-9]\\+\\)$/\\1/' |\n\
    \        sed 's/^\\([0-9]\\+\\)\\([0-9]\\+\\)$/\\1\\\n            +\\2/' |\n \
    \       sed 's/^\\([0-9]\\+\\)\\([0-9]\\+\\)\\([0-9]\\+\\)$/\\1\\\n          \
    \  +\\2\\\n            +\\3/' |\n        sed 's/^\\([0-9]\\+\\)\\([0-9]\\+\\)\\\
    ([0-9]\\+\\)\\([0-9]\\+\\)$/\\1\\\n            +\\2\\\n            +\\3\\\n  \
    \          +\\4/' |\n        sed 's/^\\([0-9]\\+\\)\\([0-9]\\+\\)\\([0-9]\\+\\\
    )\\([0-9]\\+\\)\\([0-9]\\+\\)$/\\1\\\n            +\\2\\\n            +\\3\\\n\
    \            +\\4\\\n            +\\5/' |\n        sed 's/^\\([0-9]\\+\\)\\([0-9]\\\
    +\\)\\([0-9]\\+\\)\\([0-9]\\+\\)\\([0-9]\\+\\)\\([0-9]\\+\\)$/\\1\\\n        \
    \    +\\2\\\n            +\\3\\\n            +\\4\\\n            +\\5\\\n    \
    \        +\\6/' |\n        sed 's/^\\([0-9]\\+\\)\\([0-9]\\+\\)\\([0-9]\\+\\)\\\
    ([0-9]\\+\\)\\([0-9]\\+\\)\\([0-9]", "  # write your code here\n  list=$1\n  prime=0\n\
    \  largest=0\n  for n in $list\n  do\n    # echo $n\n    isPrime=1\n    for ((i=2;\
    \ i<$n; i++))\n    do\n      if [ $(( $n % $i )) -eq 0 ]\n      then\n       \
    \ isPrime=0\n        break\n      fi\n    done\n    if [ $isPrime -eq 1 ]\n  \
    \  then\n      prime=$n\n      if [ $prime -gt $largest ]\n      then\n      \
    \  largest=$prime\n      fi\n    fi\n  done\n  sum=0\n  n=$largest\n  while [\
    \ $n -gt 0 ]\n  do\n    digit=$(( $n % 10 ))\n    n=$(( $n / 10 ))\n    sum=$((\
    \ $sum + $digit ))\n  done\n  echo $sum", "  local -a arr arr2 arr3\n  arr=($1)\n\
    \  arr2=($(echo ${arr[@]} | tr ' ' '\\n' | sort -n))\n  arr3=($(echo ${arr2[@]}\
    \ | tr ' ' '\\n' | rev))\n  for i in ${arr3[@]}; do\n    if [[ $i -eq 1 ]]; then\n\
    \      continue\n    elif [[ $i -eq 0 ]]; then\n      continue\n    elif [[ $i\
    \ -eq 2 ]]; then\n      echo $i | grep -o '[0-9]' | tr -d '\\n' | wc -c\n    \
    \  return\n    elif [[ $i -eq 3 ]]; then\n      echo $i | grep -o '[0-9]' | tr\
    \ -d '\\n' | wc -c\n      return\n    elif [[ $i -eq 5 ]]; then\n      echo $i\
    \ | grep -o '[0-9]' | tr -d '\\n' | wc -c\n      return\n    elif [[ $i -eq 7\
    \ ]]; then\n      echo $i | grep -o '[0-9]' | tr -d '\\n' | wc -c\n      return\n\
    \    elif (( $i % 2 == 0 )); then\n      continue\n    elif (( $i % 3 == 0 ));\
    \ then\n      continue\n    elif (( $i % 5 == 0 )); then\n      continue\n   \
    \ elif (( $i % 7 == 0 )); then\n      continue\n    else\n      echo $i | grep\
    \ -o '[0-9]' | tr -d '\\n' | wc -c\n      return\n    fi\n  done", "  # Your code\
    \ here\n  list=($1)\n  max=${list[0]}\n  for i in \"${list[@]}\"\n  do\n    if\
    \ [[ $i -gt $max ]]\n    then\n      max=$i\n    fi\n  done\n  for (( n=2; n<$max;\
    \ n++ ))\n  do\n    b=0\n    for (( i=2; i<n; i++ ))\n    do\n      if [ $((n%i))\
    \ -eq 0 ]\n      then\n        b=1\n        break\n      fi\n    done\n    if\
    \ [ $b -eq 0 ]\n    then\n      let \"sum += $n\"\n    fi\n  done\n  echo \"$sum\"",
  "  local numbers=($1)\n  local largest_prime=\"\"\n  for number in ${numbers[@]};\
    \ do\n    if [ $number -gt $largest_prime ]; then\n      if is_prime $number;\
    \ then\n        largest_prime=$number\n      fi\n    fi\n  done\n  echo $largest_prime\
    \ | fold -w1 | paste -sd+ | bc", "\tlocal -a a=($1)\n\tlocal -i i=${#a[@]}\n\t\
    local -i p=0\n\twhile [ $i -gt 0 ]; do\n\t\tif [ $((a[$i] % 2)) -ne 0 ] && [ $((a[$i]\
    \ % 3)) -ne 0 ] && [ $((a[$i] % 5)) -ne 0 ] && [ $((a[$i] % 7)) -ne 0 ]; then\n\
    \t\t\tp=${a[$i]}\n\t\tfi\n\t\tlet i--\n\tdone\n\ti=${#p}\n\tlocal -i s=0\n\twhile\
    \ [ $i -gt 0 ]; do\n\t\ts=$((s + p % 10))\n\t\tp=$((p / 10))\n\t\tlet i--\n\t\
    done\n\techo $s", "  local numbers=($1)\n  local prime=0\n  for i in \"${numbers[@]}\"\
    ; do\n    if [[ $prime -lt $i ]]; then\n      if $(is_prime $i); then\n      \
    \  prime=$i\n      fi\n    fi\n  done\n  echo $prime | sum_digits", "  if [ \"\
    $1\" == \"\" ]; then\n    echo \"No input provided\"\n    return\n  fi\n  local\
    \ largest=0\n  for number in $1; do\n    if [ $number -gt $largest ]; then\n \
    \     largest=$number\n    fi\n  done\n  local sum=0\n  while [ $largest -gt 0\
    \ ]; do\n    sum=$((sum + largest % 10))\n    largest=$((largest / 10))\n  done\n\
    \  echo $sum", "   local list=$@\n   local largest=0\n   local sum=0\n   for i\
    \ in $list; do\n      # isprime function\n      local i_is_prime=1\n      for\
    \ (( j=2; j<i; j++ )); do\n         # i is not prime if it is divisible by some\
    \ j in range 2 to i\n         if (( $i % $j == 0 )); then\n            local i_is_prime=0\n\
    \            break\n         fi\n      done\n      # end isprime function\n  \
    \    if (( $i_is_prime == 1 )); then\n         if (( $i > $largest )); then\n\
    \            largest=$i\n         fi\n      fi\n   done\n   for (( i=0; i<${#largest};\
    \ i++ )); do\n      sum=$(( $sum + ${largest:$i:1} ))\n   done\n   echo $sum",
  "  local d\n  local IFS\n  IFS=' '\n  d=($1)\n  d=${d[*]}\n  local n=${#d[@]}\n\
    \  local max=0\n  local i\n  local j\n  local is_prime\n  for ((i=0; i<n; i++));\
    \ do\n    is_prime=1\n    for ((j=2; j<${d[i]}; j++)); do\n      if (($((d[i]\
    \ % j)) == 0)); then\n        is_prime=0\n        break\n      fi\n    done\n\
    \    if ((is_prime == 1 && d[i] > max)); then\n      max=${d[i]}\n    fi\n  done\n\
    \  printf -v is_prime \"%d\" $max\n  local sum=0\n  for ((i=0; i<${#is_prime};\
    \ i++)); do\n    sum=$((sum + ${is_prime:i:1}))\n  done\n  echo $sum", "  local\
    \ result=\"\"\n  local max_prime=\"\"\n  local i=\"\"\n  local j=\"\"\n  local\
    \ k=\"\"\n  local prime=\"\"\n  local digits=\"\"\n  local sum=\"\"\n  local max_sum=\"\
    \"\n  local d=\"\"\n  local n=\"\"\n  local found_prime=\"\"\n  local temp=\"\"\
    \n  local is_prime=\"\"\n  local is_first=\"\"\n  local number_of_primes=\"\"\n\
    \  local primes=\"\"\n  local number_of_primes=\"\"\n  local is_first=\"\"\n \
    \ local first_found=\"\"\n  local temp=\"\"\n  local temp2=\"\"\n  local temp3=\"\
    \"\n  local temp4=\"\"\n  local temp5=\"\"\n  local temp6=\"\"\n  local temp7=\"\
    \"\n  local temp8=\"\"\n  local temp9=\"\"\n  local temp10=\"\"\n  local temp11=\"\
    \"\n  local temp12=\"\"\n  local temp13=\"\"\n  local temp14=\"\"\n  local temp15=\"\
    \"\n  local temp16=\"\"\n  local temp17=\"\"\n  local temp18=\"\"\n  local temp19=\"\
    \"\n  local temp20=\"\"\n  local temp21=\"\"\n  local temp22=\"\"\n  local temp23=\"\
    \"\n  local temp24=\"\"\n  local temp25=\"\"\n  local temp26=\"\"\n  local temp27=\"\
    \"\n  local temp28=\"\"\n  local temp29=\"\"\n  local temp30=\"\"\n  local temp31=\"\
    \"\n  local temp32=\"\"\n  local temp33=\"\"\n  local temp34=\"\"\n  local temp35=\"\
    \"\n  local temp36=\"\"\n  local temp37=\"\"\n  local temp38=\"\"\n  local temp39=\"\
    \"\n  local temp40=\"\"\n  local temp41=\"\"\n  local temp42=\"\"\n  local temp43=\"\
    \"\n  local temp44=\"\"\n  local temp45=\"\"\n  local temp46=\"\"\n  local temp47=\"\
    \"\n  local temp48=\"\"\n  local temp49=\"\"\n  local temp50=\"\"\n  local temp51=\"\
    \"\n  local temp52=\"\"\n  local temp53=\"\"\n  local temp54=\"\"\n  local temp55=\"\
    \"\n  local temp56=\"\"\n  local temp57=\"\"\n  local temp58=\"\"\n  local temp59=\"\
    \"\n  local temp60=\"\"\n  local temp61=\"\"\n  local temp62=\"\"\n  local temp63=\"\
    \"\n  local temp64=\"\"\n  local temp", "  fisPrime() {\n    local a=$1\n    for\
    \ ((i=2; i<=a/2; i++)); do\n      if [ $((a%i)) -eq 0 ]; then\n        return\
    \ 1\n      fi\n    done\n    return 0\n  }\n  local arr=($(echo $1))\n  local\
    \ maxPrime=$1\n  for i in ${arr[@]}; do\n    fisPrime $i\n    if [ $? -eq 0 ]\
    \ && [ $i -gt $maxPrime ]; then\n      maxPrime=$i\n    fi\n  done\n  local sum=0\n\
    \  while [ $maxPrime -gt 0 ]; do\n    sum=$((sum + maxPrime%10))\n    maxPrime=$((maxPrime/10))\n\
    \  done\n  echo $sum", "    # we should check if number is prime, i.e. can it\
    \ be divided by other numbers\n    # we should also keep track of the largest\
    \ prime number found\n    # finally, we should return the sum of the digits of\
    \ the largest prime number\n\n    # the task's examples show that the largest\
    \ prime number is always\n    # the last number in the array, so we can just take\
    \ the last number\n    # and then get its sum of digits, but I will do it the\
    \ right way :)\n\n    if [ $# -eq 0 ]; then\n        echo \"No arguments were\
    \ provided. Exiting.\"\n        exit 1\n    fi\n\n    largest_prime_num=0\n  \
    \  current_sum=0\n\n    # we iterate over the list of numbers (which is actually\
    \ a list of strings)\n    for num in $@; do\n        # we iterate over numbers\
    \ from 2 to num and try to divide num by them\n        for j in $(seq 2 $num);\
    \ do\n            if [ $(($num % $j)) -eq 0 ]; then\n                # we found\
    \ a divisor, so the number is not prime\n                break\n            elif\
    \ [ $j -eq $num ]; then\n                # if we made it here, we can be sure\
    \ that it is prime\n\n                # first, set the largest prime number\n\
    \                largest_prime_num=$num\n\n                # then get the sum\
    \ of its digits\n                current_sum=0\n                while [ $num -gt\
    \ 0 ]; do\n                    # get the rightmost digit\n                   \
    \ current_digit=$(($num % 10))\n                    # add the digit to the sum\n\
    \                    current_sum=$(($current_sum + $current_digit))\n        \
    \            # remove the rightmost digit\n                    num=$(($num / 10))\n\
    \                done\n            fi\n        done\n    done\n\n    echo $current_sum",
  "\tlocal -i t=0\n\tlocal -i p\n\tfor ((i=0; i<$#; i++)); do\n\t\tif [[ ${@:i+1:1}\
    \ -gt $t ]]; then\n\t\t\tif [[ ${@:i+1:1} -eq 2 ]] || [[ ${@:i+1:1} -eq 3 ]] ||\
    \ [[ ${@:i+1:1} -eq 5 ]] || [[ ${@:i+1:1} -eq 7 ]]; then\n\t\t\t\tt=${@:i+1:1}\n\
    \t\t\telif (( ${@:i+1:1} % 2 != 0 )) && (( ${@:i+1:1} % 3 != 0 )) && (( ${@:i+1:1}\
    \ % 5 != 0 )) && (( ${@:i+1:1} % 7 != 0 )); then\n\t\t\t\tfor ((p=2; p<${@:i+1:1};\
    \ p++)); do\n\t\t\t\t\tif (( ${@:i+1:1} % p == 0 )); then\n\t\t\t\t\t\tbreak\n\
    \t\t\t\t\tfi\n\t\t\t\tdone\n\t\t\t\tif (( p >= ${@:i+1:1} )); then\n\t\t\t\t\t\
    t=${@:i+1:1}\n\t\t\t\tfi\n\t\t\tfi\n\t\tfi\n\tdone\n\techo -n $t | sed 's/./&+/g'\
    \ | sed 's/+$//' | bc", "  local sum=0\n  local max=0\n  for n in $(echo $1);\
    \ do\n    for ((i=2; i <= $n/2; i++)); do\n      if (($n % $i == 0)); then\n \
    \       ((n /= i))\n        i=1\n      fi\n    done\n    ((n > max)) && max=$n\n\
    \  done\n  for ((i=0; i < ${#max}; i++)); do\n    ((sum += ${max:$i:1}))\n  done\n\
    \  echo $sum", "    local result=\"0\"\n    local prime=\"\"\n    for i in $1;\
    \ do\n        if [ \"$i\" -gt \"$result\" ]; then\n            prime=$(prime \"\
    $i\")\n            if [ \"$prime\" -eq \"1\" ]; then\n                result=\"\
    $i\"\n            fi\n        fi\n    done\n    echo $result | grep -o . | paste\
    \ -sd+ | bc", '  # FILL THE GAPS', "  space_separated_list=$@\n  python -c '\n\
    import math\n#\n# Checks whether an int is prime or not.\n# n: int to be checked\n\
    def is_prime(n):\n  if n % 2 == 0 and n > 2:\n    return False\n  return all(n\
    \ % i for i in range(3, int(math.sqrt(n)) + 1, 2))\n#\n# Finds largest prime in\
    \ a list\n# l: list to be processed\ndef largest_prime(l):\n  for i in range(max(l),\
    \ 0, -1):\n    if is_prime(i):\n      return i\n#\n# Finds the digits of a number\n\
    # n: the number\ndef digits(n):\n  return [int(i) for i in str(n)]\n#\n# Main\n\
    list_of_ints = [int(i) for i in \"'$space_separated_list'\".split(\" \")]\nlargest_prime_of_list\
    \ = largest_prime(list_of_ints)\ndigits_of_prime = digits(largest_prime_of_list)\n\
    sum_of_digits = sum(digits_of_prime)\nprint(sum_of_digits)\n'", "  # Write your\
    \ code here\n  # Implement a function, called skjkasdkd, that takes an input string\
    \ of space-separated numbers, finds the largest prime value and returns the sum\
    \ of its digits.\n\n  # function isPrime() {\n  #   number=$1\n  #   if [ $(($number\
    \ % 2)) -eq 0 ]; then\n  #     return 0\n  #   fi\n  #   number=$(echo \"sqrt($number)\"\
    \ | bc)\n  #   for (( i=3; i<=$number; i+=2 )); do\n  #     if [ $(($number %\
    \ $i)) -eq 0 ]; then\n  #       return 0\n  #     fi\n  #   done\n  #   return\
    \ 1\n  # }\n\n  # max=0\n  # array=($1)\n  # for i in \"${array[@]}\"; do\n  #\
    \   if [ $i -gt $max ]; then\n  #     max=$i\n  #   fi\n  # done\n\n  # for ((\
    \ i=$max; i>0; i-- )); do\n  #   if $(isPrime $i); then\n  #     max=$i\n  # \
    \    break\n  #   fi\n  # done\n\n  # if [ $max -eq 0 ]; then\n  #   echo 0\n\
    \  #   return\n  # fi\n\n  # max=$(echo $max | sed 's/\\(.\\)/\\1\\n/g' | paste\
    \ -sd+ | bc)\n  # echo $max", "  declare -i i j\n  declare -i prime=0\n  declare\
    \ -a arr=($1)\n  declare -i len=${#arr[@]}\n  declare -i del=0\n  for ((i=0; i<$len;\
    \ i++)); do\n    for ((j=2; j<${arr[$i]}; j++)); do\n      if [[ $(( ${arr[$i]}\
    \ % j )) -eq 0 ]]; then\n        unset arr[$i]\n        del=1\n        break\n\
    \      fi\n    done\n    if [[ $del -eq 0 ]]; then\n      if [[ ${arr[$i]} -gt\
    \ $prime ]]; then\n        prime=${arr[$i]}\n      fi\n    fi\n    del=0\n  done\n\
    \  if [[ $prime -eq 0 ]]; then\n    echo \"0\"\n  else\n    declare -i sum=0\n\
    \    while [[ $prime -gt 0 ]]; do\n      sum=$(( $sum + $prime % 10 ))\n     \
    \ prime=$(( $prime / 10 ))\n    done\n    echo \"$sum\"\n  fi", "    local IFS=\"\
    \ \"\n    local numbers=($1)\n    local largest=$(get_largest_prime ${numbers[@]})\n\
    \    local sum=$(sum_digits $largest)\n    echo $sum", "    echo \"$1\" | \n \
    \   tr ' ' '\\n' |\n    perl -ne 'chomp; print if $_ > 1 && !(int($_/2)..$_).grep\
    \ {$_ % $x == 0}' |\n    sort -nr |\n    head -n 1 |\n    sed 's/\\(.\\)/\\1\\\
    n/g' |\n    paste -sd+ |\n    bc", "  local -a array=($1)\n  local -i max\n  max=${array[0]}\n\
    \  for e in ${array[@]}; do\n    (( $e > $max )) && max=$e\n  done\n  # echo max=$max\n\
    \  # find prime number\n  if (( $max > 3 )); then\n    local -i i\n    for ((\
    \ i=2; i<$max; i++ )); do\n      if (( $max % $i == 0 )); then\n        # $max\
    \ is not prime\n        (( $i > $max/2 )) && break\n        local -i j\n     \
    \   for (( j=2; j<$i; j++ )); do\n          if (( $i % $j == 0 )); then\n    \
    \        # $i is not prime\n            (( $j > $i/2 )) && break\n          else\n\
    \            # $i is prime\n            (( $j > $i/2 )) && max=$i && break\n \
    \         fi\n        done\n      else\n        # $max is prime\n        (( $i\
    \ > $max/2 )) && break\n      fi\n    done\n  fi\n  # echo max=$max\n  # find\
    \ the sum of the digits\n  local -i sum\n  sum=0\n  while (( $max > 0 )); do\n\
    \    (( sum += $max % 10 ))\n    (( max /= 10 ))\n  done\n  echo $sum", "    echo\
    \ -n \"$1\" | tr ' ' '\\n' | sort -nr | egrep '^[0-9]+$' | \\\n        egrep '^[1-9][0-9]*$'\
    \ | egrep '^([1-9]|[1-8][0-9]|9[0-7])$' | \\\n        head -n 1 | awk '{ split($0,a,\"\
    \"); print a[1]+a[2] }'", "  local n\n  local p\n  local d\n  local s\n  IFS='\
    \ ' read -ra n <<< \"$1\"\n  p=0\n  for i in \"${n[@]}\"; do\n    if [[ $i -gt\
    \ $p ]]; then\n      p=$i\n    fi\n  done\n  s=0\n  while [[ $p -gt 0 ]]; do\n\
    \    d=$((p % 10))\n    p=$((p / 10))\n    s=$((s + d))\n  done\n  echo \"$s\"",
  "  local -a nums=($(echo \"$@\" | tr ' ' '\\n' | sort -rn | uniq))\n  local -i i\n\
    \  local -i len=${#nums[@]}\n  local -i prime\n  local -i digit\n  local -i sum=0\n\
    \  local -i found_prime=0\n  for ((i=0; i<len; i++)); do\n    if ((found_prime\
    \ == 0)); then\n      prime=${nums[i]}\n      for ((digit=0; digit<=9; digit++));\
    \ do\n        if ((prime % digit == 0)); then\n          if ((digit != 1 && digit\
    \ != prime)); then\n            break\n          fi\n        fi\n      done\n\
    \      if ((digit == 10)); then\n        found_prime=1\n      fi\n    fi\n  done\n\
    \  while ((prime > 0)); do\n    sum=$((sum + prime % 10))\n    prime=$((prime\
    \ / 10))\n  done\n  echo \"$sum\"", "  # your code here\n  # Echo is not needed,\
    \ just print your result\n  # echo \"10\"\n  echo $@", "  for i in $1\n  do\n\
    \    echo $i\n  done | sort -rn | uniq | head -n 1 | sed 's/\\(.\\)/\\1 + /g'\
    \ | sed 's/+ $//' | bc", "  printf '%s\\n' \"$1\" | tr ' ' '\\n' | awk '{a[$1]++}END{for(i\
    \ in a)print i,a[i]}' | awk '{if ($2==1)print $1}' | awk '{if($1>0)print $1}'\
    \ | awk '{if($1>1)print $1}' | awk 'BEGIN{max=0}{if($1>max)max=$1}END{print max}'\
    \ | awk '{print $1}' | tr -cd 0-9 | awk '{sum=0;for(i=1;i<=NF;i++)sum+=$i;print\
    \ sum}'", "\ta=(${1// / })\n\tr=${a[0]}\n\tl=${#a[@]}\n\tfor ((i=1; i<$l; i++));\
    \ do\n\t\t[ ${a[$i]} -gt $r ] && r=${a[$i]}\n\tdone\n\tt=$(echo $r | tr -cd '0123456789')\n\
    \techo $t | tr -cd '0123456789' | wc -c", "\techo \"${1}\" | tr \" \" \"\\n\"\
    \ | sort -n | uniq | egrep \"^[0-9]+$\" | egrep -v \"^1$\" | while read n; do\n\
    \t\tif [[ $n -gt 2 ]]; then\n\t\t\tif [[ `factor $n | egrep -v \"[:punct:]|[:digit:]\"\
    \ | wc -l` -eq 0 ]]; then\n\t\t\t\techo $n\n\t\t\tfi\n\t\telse\n\t\t\techo $n\n\
    \t\tfi\n\tdone | sort -nr | head -n 1 | sed -e \"s/./&\\n/g\" | awk '{s+=$1} END\
    \ {print s}'", "\t# Check for input\n\tif [[ -z \"$1\" ]]; then\n\t\techo \"ERROR:\
    \ Usage: $0 \\\"0 1 2 3 4\\\"\"\n\t\treturn 1\n\tfi\n\n\t# Define variables\n\t\
    local input=$1\n\tlocal largest=0\n\tlocal prime=0\n\tlocal sum=0\n\n\t# Loop\
    \ through each number in the input\n\tfor number in $input; do\n\t\t# Check if\
    \ the number is prime\n\t\tprime=$(is_prime \"$number\")\n\t\tif [[ \"$prime\"\
    \ = \"1\" ]]; then\n\t\t\t# Check if the number is larger than the largest prime\n\
    \t\t\tif [[ \"$number\" -gt \"$largest\" ]]; then\n\t\t\t\tlargest=\"$number\"\
    \n\t\t\tfi\n\t\tfi\n\tdone\n\n\t# Loop through each digit in the largest prime\n\
    \twhile [[ \"$largest\" -gt 0 ]]; do\n\t\t# Find the sum of the digits\n\t\tsum=$((sum\
    \ + (largest % 10)))\n\t\tlargest=$((largest / 10))\n\tdone\n\n\t# Print the sum\
    \ of the digits\n\techo \"$sum\"", "\tsed 's/ /\\n/g' <<< $1 | sort -nr | grep\
    \ \"^[0-9]*[1-9][0-9]*$\" | head -n 1 | fold -w1 | paste -sd+ | bc", "  ARRAY=()\n\
    \  for i in $1; do\n    ARRAY+=($i)\n  done\n  # Get the index of the max number\n\
    \  indexOfMax=0\n  for (( i=0; i<${#ARRAY[@]}; i++ )); do\n    if (( ${ARRAY[$i]}\
    \ > ${ARRAY[$indexOfMax]} )); then\n      indexOfMax=$i\n    fi\n  done\n  # Loop\
    \ through all numbers less than the max and check if prime\n  largestPrime=0\n\
    \  for (( i=2; i<${ARRAY[$indexOfMax]}; i++ )); do\n    if (( $(isPrime $i) ));\
    \ then\n      largestPrime=$i\n    fi\n  done\n  echo $(sumOfDigits $largestPrime)",
  "    local list=$(echo \"$1\" | tr ' ' '\\n' | sort -n)\n    local r\n    local\
    \ prime\n    # find largest prime in the list\n    for el in $list; do\n     \
    \   r=$(is_prime $el)\n        if [ $r -eq 1 ]; then\n            prime=$el\n\
    \            break\n        fi\n    done\n    # sum digits of largest prime\n\
    \    echo $prime | tr -cd '0-9' | awk '{s+=$1} END {print s}'", "\tlocal num largest\
    \ j\n\tlargest=0\n\tfor num in $@; do\n\t\tif [ \"$num\" -gt \"$largest\" ]; then\n\
    \t\t\tif isPrime \"$num\"; then\n\t\t\t\tlargest=\"$num\"\n\t\t\tfi\n\t\tfi\n\t\
    done\n\tj=\"$largest\"\n\twhile [ \"$j\" -gt 0 ]; do\n\t\tlargest=$((largest -\
    \ (j % 10)))\n\t\tj=$((j / 10))\n\tdone\n\techo \"$largest\"", "  local result=0\n\
    \  local val=0\n  local max=0\n  local sum=0\n  for i in $1; do\n    val=$(echo\
    \ $i | sed 's/\\(.*\\)./\\1/')\n    if [[ $(echo $val | tr -cd '0-9') == $val\
    \ ]]; then\n      if (( $val > $max )); then\n        max=$val\n      fi\n   \
    \ fi\n  done\n  while (( $max > 0 )); do\n    sum=$(( $sum + $max % 10 ))\n  \
    \  max=$(( $max / 10 ))\n  done\n  echo $sum", "  echo \"$1\" \\\n    | tr ' '\
    \ '\\n' \\\n    | xargs -I{} echo '(' {} '% 2);' \\\n    | bc \\\n    | paste\
    \ -sd+ \\\n    | bc \\\n    | tr '0' ' ' \\\n    | wc -w \\\n    | tr -d ' '",
  "  s=0\n  for i in $1\n  do\n    if (( $i > s ))\n    then\n      (( s = $i ))\n\
    \    fi\n  done\n  echo $s", "  local input=($1)\n  local largest_prime=0\n  for\
    \ i in \"${input[@]}\"; do\n    if is_prime \"$i\"; then\n      if [ \"$i\" -gt\
    \ \"$largest_prime\" ]; then\n        largest_prime=\"$i\"\n      fi\n    fi\n\
    \  done\n  local largest_prime_digits=($(echo \"$largest_prime\" | sed -E 's/(.)/\\\
    1 /g'))\n  local largest_prime_digits_sum=0\n  for digit in \"${largest_prime_digits[@]}\"\
    ; do\n    largest_prime_digits_sum=$((largest_prime_digits_sum + digit))\n  done\n\
    \  echo \"$largest_prime_digits_sum\""]
stop_tokens:
- "\n}"
