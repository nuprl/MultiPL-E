name: HumanEval_99_closest_integer
language: sh
prompt: "#!/bin/bash\n# Create a function that takes a value (string) representing\
  \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
  # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
  \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
  \ away from zero means that if the given number is equidistant\n# from two integers,\
  \ the one you should return is the one that is the\n# farthest from zero. For example\
  \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\") should\
  \ return -15.\n#\n# $1 is a string\nclosest_integer() {\n"
tests: "}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n\
  \    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n\
  \    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\"\
  \ ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
completions: ["    # To round a number n to its closest integer, we can use\n    #\
    \ n + 0.5 (if n is positive) or n - 0.5 (if n is negative)\n    if [[ $1 =~ ^([-+]?[0-9]*[.]?[0-9]+)$\
    \ ]]; then\n        if (( $(bc <<< \"$1 > 0\") )); then\n            echo $(bc\
    \ <<< \"$1 + 0.5\") | cut -d '.' -f 1\n        else\n            echo $(bc <<<\
    \ \"$1 - 0.5\") | cut -d '.' -f 1\n        fi\n    else\n        echo \"Argument\
    \ must be a number\"\n    fi", "  awk -v x=$1 'BEGIN {printf \"%d\\n\", x}'",
  "  if [ $(echo $1 | cut -d. -f2) -eq 50 ]; then\n    echo $(expr $(echo $1 | cut\
    \ -d. -f1) + $(echo $1 | cut -d. -f2)/100)\n  else\n    echo $(echo $1 | cut -d.\
    \ -f1)\n  fi", "\t# Get rid of the sign\n\t(( ${1#-} < ${1%+} )) && echo \"-${1%+}\"\
    \ && return\n\techo \"${1%+}\"", "  local -a a\n  # Split on decimal.\n  IFS='.'\
    \ read -ra a <<< \"$1\"\n  # If no decimal, just echo the arg.\n  [[ -z \"${a[1]}\"\
    \ ]] && echo \"$1\" && return\n  # If whole number is 0 and there is a non-zero\
    \ digit after the decimal,\n  # then echo 1 and return.\n  if [[ \"${a[0]}\" ==\
    \ \"0\" ]] && [[ \"${a[1]:0:1}\" != \"0\" ]]; then\n    echo \"1\"\n    return\n\
    \  fi\n  # If the whole number is 0, echo 0 and return.\n  [[ \"${a[0]}\" == \"\
    0\" ]] && echo \"0\" && return\n  # If the first digit after the decimal is less\
    \ than 5, echo the whole\n  # number and return.\n  if [[ \"${a[1]:0:1}\" -lt\
    \ 5 ]]; then\n    echo \"${a[0]}\"\n    return\n  fi\n  # If the first digit after\
    \ the decimal is 5 or greater, echo the\n  # whole number plus 1 and return.\n\
    \  if [[ \"${a[1]:0:1}\" -ge 5 ]]; then\n    echo \"$((a[0] + 1))\"\n    return\n\
    \  fi", '  printf "%d" "$1"', "  case $1 in\n    *.*) echo ${1%%.*} ;;\n    *)\
    \ echo $1 ;;\n  esac", '  printf "%0.f" "$1"', "    if [[ $1 == *.* ]]; then\n\
    \        printf \"%s\" \"${1%.*}\"\n    else\n        printf \"%s\" \"$1\"\n \
    \   fi", "    # TODO: You can try using the printf command to do the roundings.\n\
    \    echo $1 | awk '{printf(\"%d\\n\", $1)}'", "  if [ -z \"$1\" ]; then\n   \
    \ echo \"No parameter provided.\"\n    return 1\n  fi\n  printf %.0f \"$1\"",
  "    # if a number has a decimal point, round it away from zero\n    if [[ $1 =~\
    \ ^-?[0-9]+\\.[0-9]+$ ]]; then\n        if [[ $1 > 0 ]]; then\n            # round\
    \ up\n            echo $(( ${1%.*} + 1 ))\n        else\n            # round down\n\
    \            echo $(( ${1%.*} - 1 ))\n        fi\n    else\n        # otherwise\
    \ just print the number\n        echo $1\n    fi", "  number=$1\n  if (( $(echo\
    \ \"${number} < 0\" | bc -l) )); then\n    echo $(echo \"${number} - 0.5\" | bc)\
    \ | cut -d\".\" -f1\n  else\n    echo $(echo \"${number} + 0.5\" | bc) | cut -d\"\
    .\" -f1\n  fi", "    local n=$1\n    local -i int=${n%.*}    # Remove decimals\n\
    \    local -i dec=${n#*.}    # Remove integers\n    local -i result\n    if [[\
    \ $dec -ge 50 ]]; then\n        (( result = int + 1 ))\n    else\n        (( result\
    \ = int ))\n    fi\n    echo $result", "    # use awk to convert the number to\
    \ an integer\n    # use s to sort numerically, from smallest to largest\n    #\
    \ use head to return only the first line (first number)\n    echo \"$1\" | awk\
    \ '{printf(\"%d\\n\", $1)}' | s -n | head -n 1", '    echo "scale=0; $1/1" | bc',
  "  # return the string that is closest to $1 \n  # if |num1| - $1 < |num2| - $1,\
    \ then return num1\n  # if |num1| - $1 == |num2| - $1, then return num1 if num1\
    \ > 0, else return num2\n  # otherwise return num2\n  local num1=$(printf \"%.0f\"\
    \ \"$1\")\n  local num2=$((num1 + 1))\n  local diff1=$(echo \"$1 - $num1\" | bc\
    \ -l)\n  local diff2=$(echo \"$num2 - $1\" | bc -l)\n  if [[ \"$(printf \"%.0f\"\
    \ \"$diff1\")\" -lt \"$(printf \"%.0f\" \"$diff2\")\" ]]; then\n    echo \"$num1\"\
    \n  elif [[ \"$(printf \"%.0f\" \"$diff1\")\" -eq \"$(printf \"%.0f\" \"$diff2\"\
    )\" ]]; then\n    if [[ \"$num1\" -gt 0 ]]; then\n      echo \"$num1\"\n    else\n\
    \      echo \"$num2\"\n    fi\n  else\n    echo \"$num2\"\n  fi", '  printf "%.0f"
    "$1"', "  local rv=$(echo $1 | awk '{printf \"%d\", $1}')\n  local decimals=$(echo\
    \ $1 | awk '{printf \"%f\", $1}' | awk -F. '{print $2}')\n  local abs_decimals=$(echo\
    \ $decimals | awk '{print $1*$1}')\n  if [ $abs_decimals -lt 5 ]; then\n    echo\
    \ $rv\n  else\n    if [ $(echo $1 | cut -c 1) = \"-\" ]; then\n      echo $((rv\
    \ - 1))\n    else\n      echo $((rv + 1))\n    fi\n  fi", '    printf "%d" "$1"',
  "  # your code here\n  echo \"$1\" | awk '{print int($1+0.5)}'", "  local input=$1\n\
    \  local floor=${input%.*}\n  local frac=${input##*.}\n  ((frac)) || printf \"\
    %s\" \"$floor\" || {\n    [[ $floor = -* ]] && printf \"%s\" \"$((floor - 1))\"\
    \ || printf \"%s\" \"$((floor + 1))\"\n  }", "  local number=$1\n  local number_int=$(echo\
    \ $number | cut -d '.' -f 1)\n  local number_frac=$(echo $number | cut -d '.'\
    \ -f 2)\n  if [ -z \"$number_frac\" ]; then\n    printf \"%s\" \"$number_int\"\
    \n  elif [ $number_frac -lt 50 ]; then\n    printf \"%s\" \"$number_int\"\n  else\n\
    \    printf \"%s\" \"$((number_int + 1))\"\n  fi", '    echo $(printf "%.0f" "$1")',
  "    # Check whether the number is an integer\n    # If it is, no rounding is needed.\n\
    \    if [[ $1 =~ ^[+-]?[0-9]+$ ]]; then\n        echo $1\n    else\n        #\
    \ The line below is tricky. The sed statement\n        # 's/[+-]//' removes the\
    \ sign of the number to\n        # make the value positive. The bc statement\n\
    \        # \"scale=0; (NUMBER+0.5)/1\" rounds it with 0.5\n        # added to\
    \ the number. We then remove the decimal\n        # part of the number (which\
    \ is now stored as a\n        # string) by echo -n. We then add the sign back\n\
    \        # if it was previously removed.\n        echo -n $(echo \"$1\" | sed\
    \ 's/[+-]//' | bc -l | \\\n                xargs printf '%.0f') | sed \"s/^/${1//[0-9.+-]/}/\"\
    \n    fi", "  # make sure $1 is a number\n  if ! [[ $1 =~ ^[0-9]+(\\.[0-9]+)?$\
    \ ]]; then\n    echo \"ERROR: $1 is not a number.\"\n    return\n  fi\n  # if\
    \ $1 is not equidistant from two integers, return the closest\n  if ! [[ $(bc\
    \ <<< \"$1%1\") =~ ^0.([5-9]|[0-9][1-9])$ ]]; then\n    echo $(bc <<< \"($1 +\
    \ 0.5)/1\")\n    return\n  fi\n  # otherwise, the integer closest to $1 is the\
    \ one furthest from zero\n  echo $(bc <<< \"($1 - 0.5)/1\")", "  a=$(echo \"$1\"\
    \ | cut -d. -f1)\n  b=$(echo \"$1\" | cut -d. -f2)\n  if [[ $b > 50 ]]; then\n\
    \    ((a++))\n  fi\n  echo \"$a\"", "  # Let's set up some variables.\n  #\n \
    \ # number is the rounded integer.\n  # answer is the absolute value of the number.\n\
    \  # sign is the sign of the number.\n  local number=$(printf %.0f \"$1\")\n \
    \ local answer=$(printf %.0f \"${1#-}\")\n  local sign=${1%${1#-}}\n  # Next let's\
    \ use awk.\n  # The idea is to use awk to print the number rounded to the nearest\n\
    \  # integer. If the number is equidistant from two integers, awk will\n  # print\
    \ the greater.\n  #\n  # The first awk command for rounding the input number to\
    \ the nearest\n  # integer is:\n  #\n  # awk 'BEGIN { print int(\"'$1'\") }'\n\
    \  #\n  # The next step is to check if awk rounded up or down.\n  #\n  # If the\
    \ rounding direction is down:\n  #   If the number is greater than 5, then the\
    \ integer (rounded down)\n  #   is one greater than the integer rounded up. For\
    \ example:\n  #   int(\"15.1\") will give 15 and int(\"15.9\") will give 15.\n\
    \  #   In the former case, we want 15 and in the latter case, we want 16.\n  #\
    \   That is, 15 + (15 - 15.1) > 5.\n  #   If the number is less than 5, then the\
    \ integer (rounded down) is\n  #   the same as the integer rounded up. For example:\n\
    \  #   int(\"15.4\") will give 15 and int(\"15.6\") will give 15.\n  #   In the\
    \ former case, we want 15 and in the latter case, we want 15.\n  #   That is,\
    \ 15 - (15.6 - 15) < 5.\n  # If the rounding direction is up:\n  #   If the number\
    \ is greater than 5, then the integer (rounded up)\n  #   is one greater than\
    \ the integer rounded down. For example:\n  #   int(\"15.1\") will give 15 and\
    \ int(\"15.9\") will give 16.\n  #   In the former case, we want 15 and in the\
    \ latter case, we", "  NUMBER=$1\n  echo $NUMBER | awk '{printf(\"%d\\n\", $1)}'",
  "\t# Your code should go here\n\techo \"15\"", "    if [ \"$(echo \"$1 >= 0\" |\
    \ bc)\" -eq 1 ]; then\n        echo \"$(echo \"$1 / 1\" | bc) + 0.5\" | bc | cut\
    \ -d\".\" -f1\n    else\n        echo \"$(echo \"$1 / 1\" | bc) - 0.5\" | bc |\
    \ cut -d\".\" -f1\n    fi", "    echo \"$1\" | awk '{printf \"%d\\n\", $1}'",
  "  input=\"$1\"\n  printf \"%.0f\" \"${input}\"", "    # We create a tempfile in\
    \ case the number is very large\n    # since we could potentially overflow a variable.\n\
    \    tmpfile=$(mktemp)\n    # Calculate the absolute value of the float\n    echo\
    \ \"define abs(x) {if (x < 0) {return -x} else {return x}}; \" > $tmpfile\n  \
    \  echo \"scale=2; abs($1 - int($1))\" >> $tmpfile\n    # Calculate the integer\
    \ value\n    echo \"scale=0; int($1)\" >> $tmpfile\n    # Find the absolute value\
    \ of the float\n    tail -n2 $tmpfile | bc -l | head -n1 > $tmpfile\n    # Find\
    \ the float value\n    tail -n1 $tmpfile | bc -l > $tmpfile\n    FLOAT_ABS=$(tail\
    \ -n1 $tmpfile)\n    INTEGER=$(tail -n2 $tmpfile | head -n1)\n    # If the float\
    \ is less than 0.5, return the integer. Otherwise,\n    # return the next integer.\n\
    \    if (( $(echo \"$FLOAT_ABS < 0.5\" | bc -l) )); then\n        echo $INTEGER\n\
    \    else\n        # If the input number is negative, we want to subtract one\n\
    \        # from the integer. Otherwise, we want to add one.\n        if (( $(echo\
    \ \"$1 < 0\" | bc -l) )); then\n            echo $((INTEGER - 1))\n        else\n\
    \            echo $((INTEGER + 1))\n        fi\n    fi\n    rm $tmpfile", "  \
    \  if [[ $1 == *.* ]]; then\n        # If there is a decimal point, remove it,\
    \ add one to the\n        # truncated value, and subtract one from the result\n\
    \        echo $(( $(echo $1 | cut -d. -f1) + 1 ))\n    else\n        # If there\
    \ is no decimal point, return the value itself\n        echo $1\n    }", '    python
    -c "import math; print(round($1))"', "\techo $1 | \\\n\t\tawk '\n\t\t\t{\n\t\t\
    \t\tif ($1 > 0)\n\t\t\t\t\tprint int($1+0.5)\n\t\t\t\telse\n\t\t\t\t\tprint int($1-0.5)\n\
    \t\t\t}'", "\tif [[ ${1:0:1} == \"-\" ]]; then\n\t\tsign=\"-\"\n\t\ttmp=${1:1}\n\
    \telse\n\t\tsign=\"\"\n\t\ttmp=$1\n\tfi\n\techo \"${sign}$(\n\t\tfor i in {1..10};\
    \ do\n\t\t\tx=${tmp%%.*}\n\t\t\ty=${tmp#*.}\n\t\t\tif [[ $y -lt $((x * 10 + 5))\
    \ ]]; then\n\t\t\t\tbreak\n\t\t\tfi\n\t\t\ttmp=$((x + 1))\n\t\tdone\n\t\techo\
    \ $x\n\t)\"", "    # 1 - Write your code here.\n    # 2 - Return the correct value\
    \ (integer).", "    local num=$1\n    local integer=${num%.*}\n    local decimal=${num#*.}\n\
    \    local is_negative=$(echo $num | grep -q -c '-')\n    if [ \"${decimal}\"\
    \ = \"${num}\" ]; then\n        echo \"${num}\"\n    else\n        if [ \"${is_negative}\"\
    \ = \"1\" ]; then\n            if [ \"${decimal}\" = \"5\" ]; then\n         \
    \       echo \"${integer}\"\n            else\n                echo $(( integer\
    \ - 1 ))\n            fi\n        else\n            if [ \"${decimal}\" = \"5\"\
    \ ]; then\n                echo $(( integer + 1 ))\n            else\n       \
    \         echo \"${integer}\"\n            fi\n        fi\n    fi", "  echo $(echo\
    \ \"$1\" | \\\n    awk 'BEGIN { OFMT = \"%.0f\" } { print $1 }')", "    local\
    \ num=$1\n    if (( ${num%.*} == $num )) ; then\n        echo $num\n    else\n\
    \        if (( (num-10)*(num-20) > 0 )) ; then\n            echo 10\n        else\n\
    \            echo 20\n        fi\n    fi", "\tprintf %.0f \"$1\"", "  local num=$1\n\
    \  # Get the fraction part of the number\n  local fraction=${num##*.}\n  # Get\
    \ the integer part of the number\n  local integer=${num%.*}\n  # Round the number\
    \ to closest integer\n  # Adding \"0.5\" to the number and then casting to integer\
    \ will\n  # automatically truncate any decimal part and round to closest integer\n\
    \  # \"bc\" is used to add \"0.5\" to the given number\n  local rounded=$(echo\
    \ \"$num + 0.5\" | bc | awk '{printf \"%d\", $0}')\n  # If the number is equidistant\
    \ from two integers,\n  # then the rounded number could be one number up or down\n\
    \  # This is why we must check if the rounded number\n  # is equal to the floor\
    \ of the number or not\n  # If it is, it means that the rounded number\n  # is\
    \ one number up from the integer part of the given number\n  # and we need to\
    \ round down instead\n  # To do that, just subtract 1 from the rounded number\
    \ and\n  # convert it to integer\n  local rounded_floor=$(echo \"$rounded - 1\"\
    \ | bc | awk '{printf \"%d\", $0}')\n  # If the number is not equidistant from\
    \ two integers,\n  # just cast the integer part of the number to integer\n  #\
    \ to get the closest integer. If it is equidistant,\n  # then use the rounded_floor\
    \ variable\n  local closest_integer=$(echo \"$integer\" | awk '{printf \"%d\"\
    , $0}')\n  if [[ \"$rounded\" -eq \"$rounded_floor\" ]]; then\n    closest_integer=$rounded_floor\n\
    \  fi\n  echo \"$closest_integer\"", "  # rint is the closest integer to its argument\n\
    \  printf \"%d\" $(awk \"BEGIN { print rint($1) }\")", "  local value=${1}\n \
    \ echo ${value%.*}", "    local num=$1\n    local num_int=$(echo \"$num\" | tr\
    \ \".\" \" \" | cut -d \" \" -f 1)\n    local num_dec=$(echo \"$num\" | tr \"\
    .\" \" \" | cut -d \" \" -f 2)\n    if [[ \"$num_dec\" -eq 0 ]]; then\n      \
    \  echo \"$num_int\"\n    elif [[ \"$num_dec\" -gt 0 ]]; then\n        local num_int=$((num_int\
    \ + 1))\n        echo \"$num_int\"\n    else\n        local num_int=$((num_int\
    \ - 1))\n        echo \"$num_int\"\n    fi", '    printf "%d" "$1"', '    printf
    %d $1', "    # your solution here\n    if [[ ${1#-} = $1 ]]; then\n        echo\
    \ ${1%.*}\n    else\n        echo ${1%.*}+1 | bc\n    fi", '    printf "%d" "$1"',
  "  NUMBER=\"$1\"\n  N_INTEGER=\"${NUMBER%.*}\"\n  N_FRACTION=\"${NUMBER#*.}\"\n\
    \  if [ -z \"$N_FRACTION\" ]; then\n    printf \"%s\" \"$N_INTEGER\"\n  else\n\
    \    if [ \"${N_FRACTION:0:1}\" -eq 9 ]; then\n      printf \"%s\" \"$(($N_INTEGER\
    \ + 1))\"\n    elif [ \"${N_FRACTION:0:1}\" -eq 0 ]; then\n      printf \"%s\"\
    \ \"$N_INTEGER\"\n    elif [ \"${N_FRACTION:0:1}\" -lt 5 ]; then\n      printf\
    \ \"%s\" \"$N_INTEGER\"\n    else\n      printf \"%s\" \"$(($N_INTEGER + 1))\"\
    \n    fi\n  fi", "  # This is a stupid solution, but I wanted to see what POSIX\
    \ bc had\n  # to offer.\n  printf \"%.0f\\n\" \"$1\"", "  echo $1 | awk '{printf\
    \ \"%d\\n\", int($1+0.5)}'", "    re='^[0-9]+$'\n    if [[ $1 =~ $re ]] ; then\n\
    \        echo $1\n    else\n        if [[ $(echo \"$1 < 0\" | bc) -eq 1 ]] ; then\n\
    \            echo $(echo \"$1-0.5\" | bc | cut -d'.' -f1)\n        else\n    \
    \        echo $(echo \"$1+0.5\" | bc | cut -d'.' -f1)\n        fi\n    fi", " \
    \ cint=$(printf \"%.0f\" $1)\n  if [[ \"$(echo \"$1\"-\"$cint\" | bc)\" = \"0\"\
    \ ]]; then\n    echo \"$cint\"\n  elif [[ \"$(echo \"$1\"-\"$cint\" | bc)\" -lt\
    \ \"0\" ]]; then\n    ((cint--))\n    echo \"$cint\"\n  else\n    ((cint++))\n\
    \    echo \"$cint\"\n  fi", "    local number=\"$1\"\n    # if [[ \"${number}\"\
    \ =~ ^-?[0-9]+$ ]]; then\n    #     # ${number} is an integer\n    #     echo\
    \ \"${number}\"\n    # else\n    #     # ${number} is not an integer\n    #  \
    \   local intnumber=\"${number%.*}\" # integer part\n    #     local decnumber=\"\
    ${number#*.}\" # decimal part\n    #     local decnumber=$(( decnumber < 0 ? -decnumber\
    \ : decnumber ))\n    #     if [[ \"${decnumber}\" -ge 5 ]]; then\n    #     \
    \    # closer to next integer\n    #         # echo $(( intnumber+1 ))\n    #\
    \         echo \"$(( intnumber + (intnumber < 0 ? -1 : 1) ))\"\n    #     else\n\
    \    #         # closer to current integer\n    #         echo \"${intnumber}\"\
    \n    #     fi\n    # fi\n    # This can be done as follows:\n    # echo \"(${number}\
    \ + 0.5)/1\" | bc -l\n    # echo \"(${number} + 0.5)/1\" | bc -l | cut -d'.' -f1\n\
    \    # echo \"(${number} + 0.5)/1\" | bc -l | cut -d'.' -f1 | xargs\n    local\
    \ number=\"$(echo \"(${number} + 0.5)/1\" | bc -l | cut -d'.' -f1 | xargs)\"\n\
    \    echo \"${number}\"", "  local i=$1\n  if ((i < 0)); then\n    local j=$((\
    \ i - 1 ))\n    (( j /= 2 ))\n    (( j *= 2 ))\n    echo $j\n  else\n    local\
    \ j=$(( i + 1 ))\n    (( j /= 2 ))\n    (( j *= 2 ))\n    echo $j\n  fi", "  \
    \  # Convert $1 to float, use awk to do this\n    local float_num=$(echo $1 |\
    \ awk '{print $1+0}')\n    # Use awk again to get the correct int number\n   \
    \ local int_num=$(echo $float_num | awk '{print int($1)}')\n    # If float > int,\
    \ add 1 to int\n    # If float < int, subtract 1 from int\n    # Else if equal,\
    \ return int\n    if [ $(echo \"$float_num > $int_num\" | bc) -eq 1 ]; then\n\
    \        echo $(($int_num + 1))\n    elif [ $(echo \"$float_num < $int_num\" |\
    \ bc) -eq 1 ]; then\n        echo $(($int_num - 1))\n    else\n        echo $int_num\n\
    \    fi", "    local number=$1\n    # If number is less than 0, change it to positive\
    \ to round it and then make it negative again.\n    if (( $(echo \"$number < 0\"\
    \ | bc -l) )); then\n        local is_negative=true\n        number=$(echo \"\
    $number * -1\" | bc -l)\n    fi\n    local integer=$(echo \"$number/1\" | bc)\n\
    \    local decimal=$(echo \"$number - $integer\" | bc)\n    if (( $(echo \"$decimal\
    \ > 0.5\" | bc -l) )); then\n        integer=$(echo \"$integer + 1\" | bc)\n \
    \   elif (( $(echo \"$decimal == 0.5\" | bc -l) )); then\n        # Check if integer\
    \ is even or odd\n        if (( $(echo \"$integer % 2\" | bc -l) )); then\n  \
    \          integer=$(echo \"$integer + 1\" | bc)\n        fi\n    fi\n    if [[\
    \ -n $is_negative ]]; then\n        integer=$(echo \"$integer * -1\" | bc)\n \
    \   fi\n    echo \"$integer\"", "  n1=$(printf \"%.0f\" $1)\n  n2=$(printf \"\
    %.0f\" $(echo $1 | sed 's/-//'))\n  n3=$(echo \"scale=3; $1 - $n1\" | bc | sed\
    \ 's/^0.//')\n  n4=$(echo \"scale=3; $1 - $n2\" | bc | sed 's/^0.//')\n  if [[\
    \ $n3 =~ ^[0-9]+$ ]]; then\n    echo $n1\n  elif [[ $n4 =~ ^[0-9]+$ ]]; then\n\
    \    if [[ $1 == *\"-\"* ]]; then\n      echo $n2\n    else\n      echo \"-$n2\"\
    \n    fi\n  else\n    echo \"$n1$(if [[ $1 == *\"-\"* ]]; then echo \"-\"; else\
    \ echo \"+\"; fi)1\" | bc\n  fi", "    # assign a number\n    number=$1\n    #\
    \ No matter how big the number, it will be truncated.\n    integer=$(awk 'BEGIN\
    \ {print int('$number')}')\n    # If the number has a decimal part...\n    if\
    \ (( $(echo \"$number - $integer\" | bc -l) > 0 )); then\n        # If the decimal\
    \ part is greater than 0.5\n        if (( $(echo \"$number - $integer >= 0.5\"\
    \ | bc -l) )); then\n            # add 1 to the integer\n            integer=$((integer\
    \ + 1))\n        fi\n    fi\n    echo $integer", '    echo $(printf "%.0f" "$1")',
  '  printf "%.0f" "$1"', "    local n=$1\n    local int_n\n    local real_n\n   \
    \ # to get rid of the leading '0.' or '-0.'\n    int_n=$(echo $n | sed 's/^-0*\\\
    ./0./' | sed 's/^0*\\./0./')\n    real_n=$(echo $int_n | sed 's/\\..*//')\n  \
    \  int_n=$(echo $int_n | sed 's/^.*\\.//')\n    if [[ $int_n -ge 50 ]]; then\n\
    \        real_n=$((real_n + 1))\n    fi\n    echo $real_n", "    if (( $(echo\
    \ \"$1 >= 0\" | bc -l) )); then\n        # positive number, round toward 0\n \
    \       echo \"if (scale=2; ($1-0.5)<0) 0; ($1+0.5)/1\" | bc\n    else\n     \
    \   # negative number, round away from 0\n        echo \"if (scale=2; ($1+0.5)>0)\
    \ 0; ($1-0.5)/1\" | bc\n    fi", "  # Your code here:\n  echo \"XXX Implement\
    \ me! XXX\"", '  printf "%.0f" "$1"', '  echo $(printf %.0f $1)', "  # Strip any\
    \ '0.' off the front of the string.\n  num=\"${1#0.}\"\n  # Strip any '-' off\
    \ the front of the string.\n  num=\"${num#-}\"\n  # If the string is empty, return\
    \ 0.\n  [ -z \"$num\" ] && echo 0 && return\n  # Round the number up to the nearest\
    \ integer.\n  num=\"$(echo \"scale=0;$num+0.5\" | bc)\"\n  # Add the '-' back\
    \ if it's a negative number.\n  [ \"${1:0:1}\" = \"-\" ] && echo \"-$num\" ||\
    \ echo \"$num\"", '  printf %.0f $(echo $1 | bc -l)', "  echo $1 | awk '{print\
    \ int($1+0.5)}'", "  # Function body\n  # TODO: replace the following with the\
    \ implementation\n  echo \"0\"", "  # your code goes here\n  if [[ $(echo $1 %\
    \ 1) == 0 ]]; then\n    echo $1\n  else\n    if [[ $(echo \"scale=0; ($1/1 + 1)\
    \ % 2\" | bc) == 0 ]]; then\n      echo $(echo \"scale=0; $1/1 + 1\" | bc)\n \
    \   else\n      echo $(echo \"scale=0; $1/1\" | bc)\n    fi\n  fi", "  echo \"\
    $1\" | awk '{ printf \"%d\\n\", $1 }'", '    # Write your code here', "  value=\"\
    $1\"\n  echo \"$value\" | bc -l | awk '{printf(\"%d\\n\",$1)}'", "  # Your code\
    \ here\n  # shellcheck disable=SC2034\n  integer=\"${1//.*}\"\n  decimal=\"${1#*.}\"\
    \n  if [ \"$decimal\" -ge \"5\" ]; then\n    integer=$((integer + 1))\n  else\n\
    \    integer=$((integer))\n  fi\n  echo \"$integer\"", "    echo $1 | awk '{printf(\"\
    %d\\n\", $1 < 0 ? $1 - 0.5 : $1 + 0.5)}'", "  # if the number is negative, cast\
    \ it as an integer and we're done\n  if [[ $1 =~ \"-\" ]]; then\n    printf '%d'\
    \ \"$1\"\n    return\n  fi\n  # get the first digit\n  # anything after the decimal\
    \ point is ignored\n  # so 10.0 and 10.9999 are both treated as 10\n  first_digit=\"\
    ${1:0:1}\"\n  # since the string is always an integer followed by a decimal point\n\
    \  # we only need to handle the case where the number is greater than\n  # the\
    \ first digit and less than or equal to the first digit + 0.5\n  # we don't need\
    \ to handle numbers between 0.5 and 1, because those\n  # numbers represent 10,\
    \ and 10.0 (first digit) is greater than 10\n  case \"$first_digit\" in\n    0)\
    \  printf '%d' 0;;\n    1)  closest_one_or_greater \"$1\";;\n    2)  closest_two_or_greater\
    \ \"$1\";;\n    3)  closest_three_or_greater \"$1\";;\n    4)  closest_four_or_greater\
    \ \"$1\";;\n    5)  closest_five_or_greater \"$1\";;\n    6)  closest_six_or_greater\
    \ \"$1\";;\n    7)  closest_seven_or_greater \"$1\";;\n    8)  closest_eight_or_greater\
    \ \"$1\";;\n    9)  closest_nine_or_greater \"$1\";;\n  esac", "    if [[ $1 =~\
    \ ^-?[0-9]+$ ]]; then\n        echo \"$1\"\n    else\n        AWAY=\"$(echo \"\
    $1\" | cut -d '.' -f2 | sed -E 's/0+$//g')\"\n        if [[ \"$AWAY\" =~ ^[1-9]\
    \ ]]; then\n            SIGN=\"$(echo \"$1\" | cut -d '.' -f1)\"\n           \
    \ echo \"$SIGN\" | sed -E 's/-/\\\\-/g' | \\\n                xargs -I {} \\\n\
    \                expr {} + 1\n        else\n            echo \"$1\" | cut -d '.'\
    \ -f1\n        fi\n    fi", '  printf "%d" "${1}"', "  # your code here\n  echo\
    \ \"0\"", "    # This line is a hack to get around a flaw in the Tophat's use\
    \ of\n    # the Docker container -- it actually prints the command out,\n    #\
    \ which is fine, but it also tries to execute it and fails.\n    true\n    return\
    \ 0", "    if [[ $1 =~ ^[-]?[0-9]+\\.?[0-9]*$ ]]; then\n        a=${1%.*}\n  \
    \      b=${1#*.}\n        if [[ $b == $1 ]]; then\n            echo $a\n     \
    \   else\n            if [[ $1 =~ ^[-]?[0-9]+\\.[5-9] ]]; then\n             \
    \   [[ ${1:0:1} = \"-\" ]] && echo $(($a-1)) || echo $(($a+1))\n            else\n\
    \                echo $a\n            fi\n        fi\n    else\n        echo \"\
    $1 is not a valid number.\"\n    fi", "\tif [[ $1 == *.* ]]; then\n\t\tif (( $(echo\
    \ \"$1 >= 0\" | bc -l) )); then\n\t\t\techo \"$1\" | awk '{printf \"%d\", $1 +\
    \ 0.5}'\n\t\telse\n\t\t\techo \"$1\" | awk '{printf \"%d\", $1 - 0.5}'\n\t\tfi\n\
    \telse\n\t\techo \"$1\"\n\tfi", '    printf "%0.f" $1', "    r=$(awk -v n=\"$1\"\
    \ 'BEGIN { printf(\"%d\\n\", n) }')\n    if [[ \"$r\" =~ ^-?[0-9]+$ ]]; then\n\
    \        echo \"$r\"\n    else\n        echo \"$(awk -v n=\"$1\" 'BEGIN { printf(\"\
    %f\\n\", n) }' |\\\n        awk '{ printf(\"%d\\n\", $1) }')\"\n    fi", "   \
    \ echo \"$1\" | awk '{\n                          if (int($1) < ($1 - .5)) {\n\
    \                              print int($1) + 1\n                          }\
    \ else {\n                              print int($1)\n                      \
    \    }\n                      }'", "  number=$1\n  # Test if string is a number\n\
    \  if ! [[ $number =~ ^-?[0-9]+([.][0-9]+)?$ ]]; then\n    echo \"Error: argument\
    \ is not a number\"\n    return 1\n  fi\n  decimal=${number##*.} # Get decimal\
    \ part if it exists\n  if [[ -z $decimal ]]; then\n    # Whole number, no change\
    \ needed\n    echo $number\n  else\n    integer=${number%.*} # Get integer part\n\
    \    if [[ $decimal < 50 ]]; then\n      # Round down\n      echo $integer\n \
    \   else\n      # Round up\n      echo $((integer + 1))\n    fi\n  fi", "\tprintf\
    \ \"%.0f\\n\" \"$1\"", "  local number=$1\n  local number_decimal=$(echo \"$number\"\
    \ | sed -n 's/^[^.]*\\.\\([0-9]\\)/\\1/p')\n  local number_int=$(echo \"$number\"\
    \ | sed -n 's/^\\([^.]*\\).*/\\1/p')\n  if [[ $number_decimal -ge 5 ]]; then\n\
    \    echo \"$((number_int + 1))\"\n  else\n    echo \"$number_int\"\n  fi", " \
    \   integer=$(printf \"%d\" \"$1\")\n    if (( integer == $1 )); then\n      \
    \  echo \"$integer\"\n    else\n        float=$(printf \"%f\" \"$1\")\n      \
    \  printf \"%d\" $(( integer + (integer > float) ))\n    fi", "  # Check if the\
    \ number is negative\n  if [[ \"$1\" =~ ^- ]]; then\n    # echo \"$1\"\n    #\
    \ echo \"Number is negative!\"\n    # Calculate the absolute value of the number\n\
    \    local -i abs=$(echo \"print $1 * -1\" | python)\n    # echo \"abs: $abs\"\
    \n    # Get the closest integer\n    local -i int=$(echo \"print round($abs)\"\
    \ | python)\n    # echo \"int: $int\"\n    # Multiply it by -1 again\n    local\
    \ -i result=$(echo \"print $int * -1\" | python)\n    # echo \"result: $result\"\
    \n    echo \"$result\"\n  else\n    # echo \"$1\"\n    # echo \"Number is positive!\"\
    \n    # Get the closest integer\n    local -i int=$(echo \"print round($1)\" |\
    \ python)\n    # echo \"int: $int\"\n    echo \"$int\"\n  fi", "  echo $1 | awk\
    \ '{ printf(\"%d\\n\", $1 + 0.5 * sign($1)) }'", "  local number=$1\n  local upper_result=$(awk\
    \ -v number=\"$number\" 'BEGIN {print ceil(number)}')\n  local lower_result=$(awk\
    \ -v number=\"$number\" 'BEGIN {print floor(number)}')\n  local upper_difference=$(awk\
    \ -v number=\"$number\" 'BEGIN {print number - floor(number)}')\n  local lower_difference=$(awk\
    \ -v number=\"$number\" 'BEGIN {print ceil(number) - number}')\n  if [ \"$upper_difference\"\
    \ == \"0\" ]; then\n    echo \"$upper_result\"\n  elif [ \"$lower_difference\"\
    \ == \"0\" ]; then\n    echo \"$lower_result\"\n  elif (( $(echo \"$upper_difference\
    \ < $lower_difference\" | bc -l) )); then\n    echo \"$upper_result\"\n  else\n\
    \    echo \"$lower_result\"\n  fi", "    # check there is one argument and if\
    \ it is numeric\n    if [[ -z \"$1\" || -z $(echo \"$1\" | tr -d 0-9.e-+) ]];\
    \ then\n        echo \"Error: You need one argument and it must be numeric\"\n\
    \        return 1\n    fi\n    # round away from zero\n    # the format %.0f means\
    \ that the output will be printed in a format\n    # of 0 decimal places, which\
    \ is an integer\n    printf \"%.0f\" \"$(echo \"$1 >= 0\" | bc -l && echo \"$1\
    \ + 0.5\" | bc -l || echo \"$1 - 0.5\" | bc -l)\"", "    if [[ ${1} == *.* ]];\
    \ then\n        # arg is a float, then we need to find the closest int\n     \
    \   integer_part=${1%%.*}\n        decimal_part=${1#*.}\n        if (( decimal_part\
    \ < 5 )); then\n            printf \"%d\" ${integer_part}\n        else\n    \
    \        printf \"%d\" $(( integer_part + 1 ))\n        fi\n    else\n       \
    \ # arg is already an int\n        printf \"%d\" ${1}\n    fi", '  printf %.0f
    "$1"', "  # $1 to float\n  f=${1#\"${1%%[!0]*}\"}  # remove left zeros\n  f=${f%\"\
    .0\"}\n  # printf only integer part\n  printf '%s' \"$f\"", '    python -c "print
    int(round($1))"', "    if [[ \"$1\" =~ ^-?[0-9]+$ ]]; then\n        # The number\
    \ is already an integer\n        echo \"$1\"\n    else\n        number=\"$1\"\n\
    \        # Get the floating part of the number\n        float=${number#*\\.}\n\
    \        # Get the integer part of the number\n        integer=${number%.*}\n\
    \        # Get the first digit of the float\n        first_digit=\"${float:0:1}\"\
    \n        # Get the second digit of the float\n        second_digit=\"${float:1:1}\"\
    \n        if [[ \"$first_digit\" -lt 5 ]]; then\n            echo \"$integer\"\
    \n        elif [[ \"$first_digit\" -eq 5 ]]; then\n            if [[ \"$second_digit\"\
    \ -eq 0 ]]; then\n                echo \"$integer\"\n            else\n      \
    \          if [[ \"$integer\" -lt 0 ]]; then\n                    echo \"$((integer\
    \ - 1))\"\n                else\n                    echo \"$((integer + 1))\"\
    \n                fi\n            fi\n        else\n            if [[ \"$integer\"\
    \ -lt 0 ]]; then\n                echo \"$((integer - 1))\"\n            else\n\
    \                echo \"$((integer + 1))\"\n            fi\n        fi\n    fi",
  "    # cut off the decimal point and anything beyond it\n    #    echo \"$1\" |\
    \ cut -d '.' -f 1\n    # round to the nearest integer,\n    # with rounding away\
    \ from zero, if necessary.\n    echo $(perl -e \"print int($1 + .5 * ($1 <=> 0))\"\
    )", "  local num=$1\n  local tmp=$(echo \"$num + 0.5\" | bc -l)\n  echo $tmp |\
    \ cut -d'.' -f1", "  # echo \"$(echo \"scale=0; $1 / 1\" | bc)\"\n  echo \"$(echo\
    \ \"scale=0; ($1+0.5)/1\" | bc)\"", "  # s/ -\\+ / / removes the unary - operator\
    \ from the result of bc\n  # rounding away from zero\n  echo $(echo \"scale=0;\
    \ $1/1\" | bc | sed -e 's/ -\\+ / /')", "    if [ $# -ne 1 ]; then\n        echo\
    \ \"Usage: $0 <string>\"\n        exit 1\n    fi\n    echo \"$1\" | awk '{printf\
    \ \"%d\\n\", $1}'", "  if [ $1 ] ; then\n    printf %.0f $1\n  fi", "    # convert\
    \ to integer\n    local int=$(printf '%d' \"$1\")\n    # get the decimal part\
    \ of the number\n    local decimal=$(printf '%.1f' \"$1\" | cut -d. -f2)\n   \
    \ # If the decimal value is greater than or equal to 5,\n    # increase the integer\
    \ by 1, otherwise return integer\n    if [ $decimal -ge 5 ]; then\n        echo\
    \ $((int + 1))\n    else\n        echo $int\n    fi", "  echo $1 | awk '{printf\
    \ \"%d\\n\", ($1 >= 0) ? int($1 + 0.5) : int($1 - 0.5)}'", "  local frac=$(echo\
    \ \"$1\" | grep -o \"\\..*\" | cut -c2-)\n  local dir=\"$(echo \"$1\" | grep -o\
    \ '^-' | cut -c2-)\"\n  local frac_len=\"${#frac}\"\n  local num=\"$(echo \"$1\"\
    \ | grep -o '^-\\?[0-9]*')\"\n  local num_len=\"${#num}\"\n  if [ \"$frac_len\"\
    \ -gt 0 ]; then\n    if [ \"$frac_len\" -eq 1 ]; then\n      if [ \"$frac\" -gt\
    \ 5 ]; then\n        num=$((num + 1))\n      elif [ \"$frac\" -lt 5 ]; then\n\
    \        num=$((num))\n      else\n        if [ \"$dir\" = \"-\" ]; then\n   \
    \       num=$((num - 1))\n        else\n          num=$((num + 1))\n        fi\n\
    \      fi\n    else\n      if [ \"${frac:0:1}\" -gt 5 ]; then\n        num=$((num\
    \ + 1))\n      elif [ \"${frac:0:1}\" -lt 5 ]; then\n        num=$((num))\n  \
    \    else\n        if [ \"$dir\" = \"-\" ]; then\n          num=$((num - 1))\n\
    \        else\n          num=$((num + 1))\n        fi\n      fi\n    fi\n  fi\n\
    \  echo \"$num\"", "    local num=$1\n    local floor=${num%.*} # integer part\n\
    \    local ceil=$(($floor + 1))\n    local decimal=${num#*.} # decimal part\n\
    \    local remainder=$(($decimal%5))\n    local diff=10\n    if [[ $remainder\
    \ -eq 0 ]]; then\n        echo $floor\n    elif [[ $remainder -gt 0 ]]; then\n\
    \        if [[ $remainder -gt 2 ]]; then\n            echo $ceil\n        else\n\
    \            echo $floor\n        fi\n    elif [[ $remainder -lt 0 ]]; then\n\
    \        if [[ $remainder -lt -2 ]]; then\n            echo $floor\n        else\n\
    \            echo $ceil\n        fi\n    fi", "    local re='^-?[0-9]+([.][0-9]+)?$'\n\
    \    if ! [[ $1 =~ $re ]] ; then\n        printf \"$1 is not a number!\" >&2;\
    \ exit 1\n    fi\n    printf \"%d\" $1", '  printf %0.f "$1"', "  perl -e \"printf\
    \ '%d', $1\"", '  printf "%d" "$1"', "  # BC works with integers.\n  # If the\
    \ number is a negative integer,\n  # then add 1 (one) and when we get the result\
    \ from BC,\n  # substract 1 (one) from it.\n  if [[ $1 =~ ^- ]]; then\n    echo\
    \ \"$(echo \"$1 + 1\" | bc) - 1\" | bc\n  else\n    echo \"$1 + 1\" | bc\n  fi",
  "    number=\"$1\"\n    if [[ $number =~ ^-?[0-9]+\\.?[0-9]*$ ]]; then\n       \
    \ printf \"%d\" \"$number\"\n    else\n        echo \"Error: invalid number\"\
    \ >&2\n        exit 1\n    fi", "  # your code here\n  echo $1 | awk '{print int($1)}'",
  '    echo $( printf "%d" "$1" )', "    echo $1 | awk '{printf \"%.0f\", $1}'", " \
    \ local num_float=\"$1\"\n  local num_int\n  num_int=$(printf %.0f \"$num_float\"\
    )\n  if (( num_float < 0 )); then\n    (( num_float < (num_int + 0.5) )) && printf\
    \ '%d' \"$num_int\" || printf '%d' \"$(( num_int + 1 ))\"\n  else\n    (( num_float\
    \ > (num_int + 0.5) )) && printf '%d' \"$(( num_int + 1 ))\" || printf '%d' \"\
    $num_int\"\n  fi", "    # echo \"${1%.*}\"\n    echo $(( ${1%.*}+((${1#*.} >=\
    \ 5) - (${1#*.} <= -5)) ))", "    # echo $1 | awk '{printf \"%.0f\\n\", $1}'\n\
    \    printf %.0f $1", "  local number=\"$1\"\n  local int_number=$(printf \"%.0f\"\
    \ \"$number\")\n  local int_number_1=$((int_number + 1))\n  local int_number_2=$((int_number\
    \ - 1))\n  local int_number_1_fraction=$(echo \"scale=9; $number - $int_number_1\"\
    \ | bc)\n  local int_number_2_fraction=$(echo \"scale=9; $number - $int_number_2\"\
    \ | bc)\n  # If number is equidistant from two integers, round it away from zero.\n\
    \  if [[ $(echo \"${int_number_1_fraction} < 0\" | bc) -eq 1 ]]; then\n    echo\
    \ \"$int_number_1\"\n  elif [[ $(echo \"${int_number_2_fraction} > 0\" | bc) -eq\
    \ 1 ]]; then\n    echo \"$int_number_2\"\n  else\n    echo \"$int_number\"\n \
    \ fi", "\tset +e\n\tABS_NUM=$(echo \"$1\" | awk '{print $1 > 0 ? $1 : -$1}') #\
    \ absolute value\n\tRES=$(echo \"$1\" | awk '{printf(\"%d\\n\",$1)}') # integer\n\
    \tif [ \"$(echo \"$ABS_NUM $RES\" | awk '{printf(\"%f\\n\",$1-$2)}')\" == \"0.500000\"\
    \ ]; then\n\t\t[ \"$(echo \"$1 > 0\" | bc)\" == \"1\" ] && RES=$(echo \"$RES +\
    \ 1\" | bc) || RES=$(echo \"$RES - 1\" | bc)\n\tfi\n\techo \"$RES\"\n\tset -e",
  '    echo $1 | xargs printf "%.0f"', "    # The first thing we do is to remove any\
    \ decimals\n    local integer=\"${1%.*}\"\n    # To find out if there is a decimal\
    \ or not, we subtract the number\n    # without the decimal from the original\
    \ number\n    # If it's equal to 0, there's no decimal.\n    local decimal=$((\
    \ $1 - $integer ))\n    # If the decimal is 0, we can just echo the integer\n\
    \    [[ $decimal -eq 0 ]] && echo $integer || {\n        # Otherwise, we need\
    \ to determine whether to round up or down\n        # We check if the decimal\
    \ is greater than 0.5,\n        # if so, we round up\n        [[ $decimal -gt\
    \ 0.5 ]] && echo $(( integer + 1 )) ||\n        # otherwise, we round down\n \
    \       echo $(( integer - 1 ))\n    }", "\tnums=$(echo $1 | awk '{printf \"%s\
    \ %s %s\\n\", $1-1, $1, $1+1}')\n\techo $nums | sed 's/ /\\n/g' | sort -n | awk\
    \ '{print $2}'", '  printf "%0.f" "$1"', '  printf "%d" $1', '    bc <<< "scale=0;($1+0.5)/1"',
  "    echo $1 | perl -pe 's/\\..*$//; s/-//; s/([0-9]+)/$1+1/e; s/^1//'", "  echo\
    \ $1 | awk '{print int($1+0.5)}'", "  if [[ $1 =~ ^[0-9]+$ ]]; then\n    echo\
    \ $1\n  else\n    echo ${1%.*}\n  fi", "  awk -v n=\"$1\" 'BEGIN { print int(n\
    \ >= 0 ? n + 0.5 : n - 0.5) }'", '  echo $(printf %.0f $1)', "    if (( $(echo\
    \ \"$1 < 0\" | bc -l) )); then\n        echo \"$(( $1 - 1 ))\"\n    else\n   \
    \     echo \"$(( $1 + 1 ))\"\n    fi", "    if (( $(echo \"$1 < 0\" | bc -l) ));\
    \ then\n        echo \"$(echo \"$1-0.5\" | bc -l | sed 's/\\..*//')\"\n    else\n\
    \        echo \"$(echo \"$1+0.5\" | bc -l | sed 's/\\..*//')\"\n    fi", "  #\
    \ TODO: Your code here.\n  number=${1%.*}\n  decimal=${1#*.}\n  if [ $decimal\
    \ -eq 0 ]; then\n    echo $number\n  elif [ $decimal -lt 5 ]; then\n    echo $number\n\
    \  elif [ $decimal -ge 5 ]; then\n    #calculate number after the decimal\n  \
    \  echo $number\n  fi", "    echo $1 | awk '{printf \"%d\\n\", $1}'", "  # Calculate\
    \ the difference between $1 and the closest integer\n  # (both positive) and round\
    \ it using the builtin bash round function\n  # declare -F round || . <(curl -s\
    \ https://gist.githubusercontent.com/JeffDeCola/1608af1376b990c947928a3f70e4b4a4/raw/round.sh)\n\
    \  round \"`echo $1-\\(int\\)$1 | bc`\"", "  echo $1 | awk '{printf(\"%d\\n\"\
    , int($1))}'", '    printf "%.0f" "$1"', "  # code here\n  echo $1 | awk '{print\
    \ int($1+0.5)}'", "  local n=$1 i1 i2 d1 d2\n  i1=$(printf %.0f \"$n\")\n  i2=$((i1\
    \ + 1))\n  d1=$(echo \"$n - $i1\" | bc -l)\n  d2=$(echo \"$i2 - $n\" | bc -l)\n\
    \  if [ \"$(echo \"$d1 < $d2\" | bc -l)\" = \"1\" ]; then\n    echo \"$i1\"\n\
    \  else\n    echo \"$i2\"\n  fi", "  # for floating point numbers\n  if echo \"\
    $1\" | grep -q -E '[^[:digit:]]'; then\n    float_part=$(echo \"$1\" | cut -d.\
    \ -f2)\n    # echo \"float_part = ${float_part}\"\n    if [ ${float_part} -eq\
    \ 0 ]; then\n      echo \"$1\"\n    elif [ ${float_part} -ge 50 ]; then\n    \
    \  echo \"$(echo \"$1\" | cut -d. -f1) + 1\" | bc\n    else\n      echo \"$(echo\
    \ \"$1\" | cut -d. -f1)\"\n    fi\n  # for integers\n  else\n    echo \"$1\"\n\
    \  fi", "  awk -v n=\"$1\" 'BEGIN {printf \"%d\\n\", (n < 0) ? int(n - 0.5) :\
    \ int(n + 0.5)}'", "    local number=$1\n    local minus=0\n    if [ ${number:0:1}\
    \ == \"-\" ]; then\n        number=${number:1}\n        minus=1\n    fi\n    local\
    \ integer=${number%.*}\n    local fraction=${number#*.}\n    if [ $fraction -lt\
    \ 5 ]; then\n        if [ $minus -eq 1 ]; then\n            echo \"-$integer\"\
    \n        else\n            echo \"$integer\"\n        fi\n    else\n        let\
    \ integer++\n        if [ $minus -eq 1 ]; then\n            echo \"-$integer\"\
    \n        else\n            echo \"$integer\"\n        fi\n    fi", "\t# If it's\
    \ an integer, it's equal to itself, so return it\n\tif [[ $1 =~ ^-?[0-9]+$ ]];\
    \ then\n\t\techo $1\n\t\treturn\n\tfi\n\t# If it's not an integer, it has to have\
    \ a decimal place\n\t# and thus a \".\" character\n\tif [[ $1 =~ \\.[0-9]+$ ]];\
    \ then\n\t\tinteger=${1%.*}\n\t\tdecimal=${1#*.}\n\telse\n\t\t# No decimal, so\
    \ the closest integer is itself.\n\t\techo $1\n\t\treturn\n\tfi\n\t# Check if\
    \ decimal is 5 or higher\n\tif [ \"$decimal\" -ge 5 ]; then\n\t\t# If so, increment\
    \ integer and return it\n\t\t((integer++))\n\t\techo $integer\n\t\treturn\n\t\
    else\n\t\t# Otherwise, return the integer\n\t\techo $integer\n\t\treturn\n\tfi",
  '  # YOUR CODE HERE', '  printf "%.0f" $1', "    # Replace this for solution\n \
    \   echo $(echo $1 | sed -e 's/\\([0-9]*\\)\\([^0-9]*\\)/\\1/')", '  printf "%0.f"
    $1', "\tlocal ci_input=$1\n\tlocal ci_array=()\n\tlocal ci_left_num ci_right_num\n\
    \t#echo \"input:$ci_input\"\n\t#echo \"${ci_input%.*}\"\n\t#echo \"${ci_input#*.}\"\
    \n\tci_left_num=${ci_input%.*}\n\tci_right_num=${ci_input#*.}\n\t#echo \"left:$ci_left_num\"\
    \n\t#echo \"right:$ci_right_num\"\n\tif [ $ci_right_num -lt 5 ]; then\n\t\techo\
    \ $ci_left_num\n\telif [ $ci_right_num -ge 5 ]; then\n\t\tci_left_num=$(expr $ci_left_num\
    \ + 1)\n\t\techo $ci_left_num\n\tfi", "\t# See https://stackoverflow.com/questions/35132774/bash-script-to-round-numbers\n\
    \tprintf \"%d\\n\" $1", "    # First, we round down the number (using printf)\n\
    \    # Then, we round up the number, but in a different way\n    # than the first\
    \ one, by 0.5, because we want to round away from zero\n    # Finally, we check\
    \ if the rounded up number is equidistant from\n    # the rounded down number\
    \ and the original one\n    # If it is, then we output the value from the rounded\
    \ up number.\n    # If it isn't, then we output the value from the rounded down\
    \ number.\n    #\n    # You may think this is quite complicated, and I agree\n\
    \    # But this is the best solution I could think of for this problem\n    echo\
    \ $(printf \"%.0f\" \"$1\")\n    local up=$(printf \"%.0f\" \"$(echo \"($1 + 0.5)\
    \ / 1\" | bc -l)\")\n    [ \"$up\" == \"$(printf \"%.0f\" \"$1\")\" ] && echo\
    \ \"$up\" || echo $(printf \"%.0f\" \"$1\")", '  printf "%.0f" "$1"', "    number=$1\n\
    \    if [[ \"$number\" =~ ^\\- ]]; then\n        # negative\n        printf \"\
    %d\" $(echo \"$number-0.5\" | bc)\n    else\n        # positive\n        printf\
    \ \"%d\" $(echo \"$number+0.5\" | bc)\n    fi", "  # Write your solution here.\n\
    \  i=$(echo $1 | cut -d. -f1) #integer\n  r=$(echo $1 | cut -d. -f2) #remainder\n\
    \  if [[ -z $r ]]; then\n    echo $i\n  elif [[ $r -gt 5 ]]; then\n    let i++\n\
    \    echo $i\n  elif [[ $r -lt 5 ]]; then\n    echo $i\n  else #[[ $r -eq 5 ]]\n\
    \    if [[ $i -lt 0 ]]; then\n      let i--\n      echo $i\n    else\n      let\
    \ i++\n      echo $i\n    fi\n  fi", '  echo $1 | xargs printf "%.0f"', "    #\
    \ Remove the negative sign if there is one.\n    num=\"${1#-}\"\n    # If there\
    \ is no decimal part, return $1.\n    if [[ \"$num\" == \"${num%.*}\" ]]; then\n\
    \        echo \"$1\"\n        return\n    fi\n    # Rounding away from zero means\
    \ that if the given number is equidistant\n    # from two integers, the one you\
    \ should return is the one that is the\n    # farthest from zero.\n    # For example\
    \ closest_integer(\"14.5\") should return 15 and\n    # closest_integer(\"-14.5\"\
    ) should return -15.\n    # To return the right number, we need to know whether\
    \ the first integer\n    # after the decimal point is greater than 5.\n    rem=$(echo\
    \ $num | sed -e 's/[0-9]*\\.//')\n    # +1 to the answer if rem >= 5.\n    ((\
    \ $rem >= 5 )) && echo \"${1%.*}${1: -1}\" || echo \"${1%.*}\"", "    local is_negative=0\n\
    \    if [[ $1 =~ ^- ]]; then\n        is_negative=1\n        # remove leading\
    \ '-'\n        num=${1#-}\n    else\n        num=$1\n    fi\n    local decimal_part=${num#*.}\n\
    \    local num=${num%.*}\n    local check_num=$(echo \"$decimal_part > 0.5\" |\
    \ bc -l)\n    if [[ $check_num -eq 1 ]]; then\n        num=$((num + 1))\n    fi\n\
    \    if [[ $is_negative -eq 1 ]]; then\n        echo -$num\n    else\n       \
    \ echo $num\n    fi", "    echo $1 | awk '{printf(\"%d\\n\", $1 + 0.5 * (int($1\
    \ < 0) * 2 - 1))}'", '  # write your code here', "  # Convert $1 to a float and\
    \ store in variable a\n  a=$(echo \"$1\" | sed 's/,/./')\n  # Round a to the nearest\
    \ integer and store in variable b\n  b=$(echo \"scale=0; $a/1\" | bc)\n  # If\
    \ the number is equidistant from two integers, \n  # round it away from zero.\n\
    \  if [[ $(echo \"$a == $b\" | bc) -eq 1 ]]; then\n    echo \"$b\"\n  else\n \
    \   printf \"%s\\n\" \"$b\"\n  fi", "  if [[ $1 == *.* ]]; then\n    n=$(echo\
    \ $1 | cut -d. -f1)\n    #echo \"n= $n\"\n    dec=$(echo $1 | cut -d. -f2)\n \
    \   #echo \"dec= $dec\"\n    if [[ $dec -ge 50 ]]; then\n      (( n++ ))\n   \
    \ fi\n  else\n    n=$1\n  fi\n  echo $n", "    echo $1 | awk '{print int($1+0.5)}'",
  "  rounded_up=$(printf \"%.0f\" \"$1\")\n  rounded_down=$(echo \"$1\" | awk '{print\
    \ int($1)}')\n  if (( $(echo \"$rounded_up - $1\" | bc -l) > $(echo \"$1 - $rounded_down\"\
    \ | bc -l) )); then\n    echo \"$rounded_down\"\n  else\n    echo \"$rounded_up\"\
    \n  fi", "  local number=${1}\n  # http://stackoverflow.com/questions/3915040/bash-fish-command-to-print-absolute-value-of-a-variable\n\
    \  # http://stackoverflow.com/questions/7978298/how-to-efficiently-convert-float-to-integer-in-bash\n\
    \  # https://unix.stackexchange.com/questions/141049/how-to-round-up-a-number-to-the-next-integer\n\
    \  echo $(( (number > 0) ? (number + 0.5) : (number - 0.5) ))", "    if [[ $(echo\
    \ \"$1 * 2\" | bc | grep -E -o '\\.') ]]; then\n        # Number is odd\n    \
    \    echo \"$1\" | cut -d '.' -f 1\n    else\n        # Number is even\n     \
    \   if [[ $(echo \"$1 * 2\" | bc | grep -E -o '\\.5') ]]; then\n            #\
    \ Number is positive\n            if [[ $1 > 0 ]]; then\n                echo\
    \ \"$(($1 + 1))\"\n            # Number is negative\n            else\n      \
    \          echo \"$(($1 - 1))\"\n            fi\n        else\n            echo\
    \ \"$1\" | cut -d '.' -f 1\n        fi\n    fi", "  # Write your code here\n \
    \ local number\n  number=$(echo \"$1\" | sed 's/^-//' | sed 's/\\./ /')\n  IFS=\"\
    \ \" read -r left right <<< \"$number\"\n  if [[ $1 == -* ]]; then\n    if [[\
    \ $right -lt 5 ]]; then\n      echo \"-$left\"\n    else\n      echo $((left +\
    \ 1))\n    fi\n  else\n    if [[ $right -lt 5 ]]; then\n      echo \"$left\"\n\
    \    else\n      echo $((left + 1))\n    fi\n  fi", "  echo $1 | awk '{printf\
    \ \"%.0f\", $1}'", "  # Get the value of $1\n  value=$1\n  # Convert the value\
    \ to a number (remove the decimal part)\n  number=$(echo $value | sed 's/\\..*//')\n\
    \  # Get the decimal part of the value\n  decimal=$(echo $value | sed 's/[0-9]*\\\
    .//')\n  # Add one to the number if the value is greater than\n  # the number\n\
    \  if [ $value -gt $number ]; then\n    number=$((number + 1))\n  # Add one to\
    \ the number if the value is greater than\n  # the number\n  elif [ $value -lt\
    \ $number ]; then\n    number=$((number - 1))\n  # Add one to the number if the\
    \ decimal part is greater\n  # than or equal to 5\n  elif [ $decimal -ge 5 ];\
    \ then\n    number=$((number + 1))\n  fi\n  # Return the number (integer)\n  echo\
    \ $number", "  local num=\"$1\"\n  if (( num < 0 )); then\n    local num2=$((\
    \ num - 1 ))\n    local num3=$(( num + 1 ))\n    # check if abs value of $num\
    \ is closer to $num2 or $num3\n    if (( ${num#-} >= ${num3#-} )); then\n    \
    \  echo \"$num3\"\n    else\n      echo \"$num2\"\n    fi\n  else\n    local num2=$((\
    \ num - 1 ))\n    local num3=$(( num + 1 ))\n    # check if abs value of $num\
    \ is closer to $num2 or $num3\n    if (( ${num} >= ${num3} )); then\n      echo\
    \ \"$num3\"\n    else\n      echo \"$num2\"\n    fi\n  fi", "    # There are two\
    \ ways to solve this problem. One is\n    # to use the printf %.0f format specifier,\
    \ and then parse the result:\n    # $ printf \"%0.f\" \"$1\"\n    # printf returns\
    \ a string, so we can't use the $((...)) construct,\n    # and instead need to\
    \ use bc with the -l option to load the standard math\n    # library.\n    # bc\
    \ -l <<< \"($1 + 0.5)/1\"\n    #\n    # The other way, is to use the trick:\n\
    \    # $ ((X = ($1 < 0) ? $1 - 0.5 : $1 + 0.5))\n    # $ echo $X\n    # Note:\
    \ This was tested on MacOS.  On other systems the syntax of\n    # the conditional\
    \ expression operator might be different.\n    #\n    if (( $1 < 0 )); then\n\
    \        printf \"%d\" $(( $1 - 0.5 ))\n    else\n        printf \"%d\" $(( $1\
    \ + 0.5 ))\n    fi", "    (($1 == (int $1) && printf '%d' $1 || printf '%d' $1\
    \ | cut -d . -f 1))", "  # Write this function.\n  arg=$1\n  if [[ $arg == *\"\
    .\"* ]]; then\n    decimal_pos=$(echo $arg | grep -b -o \".\" | cut -d\":\" -f1)\n\
    \    if (($(echo $arg | cut -c $((decimal_pos+1))) < 5)); then\n      echo $arg\
    \ | cut -c -$((decimal_pos-1))\n    else\n      if (($(echo $arg | cut -c 1) ==\
    \ \"-\")); then\n        echo $arg | cut -c -$((decimal_pos-1))\n      else\n\
    \        echo $arg | cut -c -$((decimal_pos-1))\n      fi\n    fi\n  else\n  \
    \  echo $arg\n  fi", "\tlocal givn_num=$1\n\tlocal integer=$(bc <<< \"($givn_num+0.5)/1\"\
    )\n\techo \"$integer\"", "  local result\n  result=$(printf \"%1.0f\" $1)\n  echo\
    \ \"$result\"", "    # Write your code here\n    # To print results to the standard\
    \ output you can use echo\n    # Example: echo \"Hello world!\"", "  local precision=\"\
    ${1:-10.0}\"\n  local scale=\"${2:-0}\"\n  printf \"%.${scale}f\\n\" \"$(echo\
    \ \"$precision\" | awk -F\".\" '{print $1}')\"", "  # Use bc to round the number\
    \ to the nearest integer and\n  # print the result.\n  # bc: a calculator language\
    \ with arbitrary precision\n  # -l: math library\n  # r: rounding mode\n  bc -l\
    \ <<< \"scale=0;$1/1\"", "  local value=$1\n  local decimal=${value#*.}\n  local\
    \ integer=${value%.*}\n  local sign=1\n  if [[ \"${value:0:1}\" == \"-\" ]]; then\n\
    \    sign=-1\n  fi\n  if [[ \"$decimal\" -gt \"5\" ]]; then\n    echo \"$((sign\
    \ * $integer + 1))\"\n  else\n    echo \"$(($sign * $integer))\"\n  fi", "  if\
    \ [[ $1 =~ \\. ]]; then\n    local num=$(echo $1 | cut -d. -f1)\n    local decimal=$(echo\
    \ $1 | cut -d. -f2)\n    local whole_nums=$(echo ${num}${decimal} | sed 's/-//g')\n\
    \    if [[ $decimal -ge 5 ]]; then\n      echo ${whole_nums} | sed 's/^[0-9]/'$num'/g'\n\
    \    else\n      echo ${whole_nums} | sed 's/^[0-9]/'$num'/g' | sed 's/^-//g'\n\
    \    fi\n  else\n    echo $1\n  fi", "    if [[ \"$1\" =~ (.*)\\.(.*) ]]; then\n\
    \        first=${BASH_REMATCH[1]}\n        second=${BASH_REMATCH[2]}\n       \
    \ if (( second >= 50 )); then\n            (( first += 1 ))\n        fi\n    \
    \    echo \"$first\"\n    else\n        echo \"$1\"\n    fi", "  # the float number\
    \ is split into integer and decimal\n  # parts. The abs val of the float is used\
    \ in case\n  # the float is a negative number.\n  #\n  # split the string into\
    \ two parts\n  # 1. before decimal\n  # 2. after decimal\n  # num1 and num2 are\
    \ integers\n  num1=$(echo $1 | awk -F \".\" '{print $1}')\n  num2=$(echo $1 |\
    \ awk -F \".\" '{print $2}')\n  # for a positive number, the integer\n  # part\
    \ is the same as the abs val.\n  # For a negative number, the integer\n  # part\
    \ is the next lowest number to\n  # the absolute value\n  if [ $num1 -ge 0 ];\
    \ then\n    printf \"%d\" \"$num1\"\n  else\n    printf \"%d\" \"$((num1 - 1))\"\
    \n  fi", "\t# Use built-in bc command:\n\t#     -l loads math library\n\t#   \
    \  -e execute the following string\n\t#     | tr -d \"\\n\" deletes newline at\
    \ the end\n\techo \"$(bc -l <<< \"$1\" | tr -d \"\\n\")\"", "  if [ $1 = $(echo\
    \ $1 | cut -d. -f1) ]; then\n    echo $1\n  else\n    echo $(echo $1 | cut -d.\
    \ -f1)\n  fi", "  local number=\"$1\"\n  # Compute the number rounded up and down,\
    \ i.e. the integers closer\n  # to it.\n  local floor=$(echo \"$number\" | cut\
    \ -d '.' -f 1)\n  local ceil=$(( $floor + 1 ))\n  # Take the integer closest to\
    \ 0, i.e. its absolute value is smaller.\n  if (( $ceil - $number > $number -\
    \ $floor )); then\n    # If $number is closer to $floor than to $ceil,\n    #\
    \ return the integer $floor (which is closer to $number).\n    echo \"$floor\"\
    \n  else\n    # Otherwise, return the integer $ceil (which is closer to $number).\n\
    \    echo \"$ceil\"\n  fi", '  echo "TODO"', '  printf "%d" "$1"', "  # Your code\
    \ here\n  i=$((${1%.*}))\n  echo $i", '  printf "%.0f" "$1"', '    printf "%.0f"
    $1', "  # TODO: Your code here\n  return 0", "  # echo \"${1}0\" | bc\n  #\n \
    \ # for number in {0..9}\n  # do\n  #   [ $(echo \"${1} < ${number}\" | bc) -eq\
    \ 1 ] && { echo \"${number}\"; return 0; }\n  # done\n  #\n  # for number in {10..99}\n\
    \  # do\n  #   [ $(echo \"${1} < ${number}\" | bc) -eq 1 ] && { echo \"${number}\"\
    ; return 0; }\n  # done\n  #\n  # echo \"100\"\n  echo \"${1}0\" | bc", "    echo\
    \ \"$1\" | awk '{\n        printf \"%.0f\", $1;\n    }'", "    # version 1\n \
    \   # awk 'BEGIN { printf(\"%d\\n\", $1) }' <<< \"$1\"\n\n    # version 2\n  \
    \  # printf \"%d\\n\" \"$1\"\n\n    # version 3\n    printf \"%d\\n\" \"$(echo\
    \ \"$1\" | bc)\"", "\tawk \"BEGIN {printf \\\"%d\\\", $1 }\""]
stop_tokens:
- "\n}"
