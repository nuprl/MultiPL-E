name: HumanEval_58_common
language: r
prompt: "# Return sorted unique common elements for two lists.\n# >>> common([1, 4,\
  \ 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n# [1, 5, 653]\n# >>> common([5,\
  \ 3, 2, 8], [3, 2])\n# [2, 3]\ncommon <- function(l1, l2) {"
tests: "test_humaneval <- function() {\ncandidate <- common\n    if(!identical(candidate(c(1,\
  \ 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121)), c(1, 5, 653))){quit('no', 1)}\n\
  \    if(!identical(candidate(c(5, 3, 2, 8), c(3, 2)), c(2, 3))){quit('no', 1)}\n\
  \    if(!identical(candidate(c(4, 3, 2, 8), c(3, 2, 4)), c(2, 3, 4))){quit('no',\
  \ 1)}\n    if(!identical(candidate(c(4, 3, 2, 8), c()), c())){quit('no', 1)}\n}\n\
  test_humaneval()"
completions: ["\n  u1 <- unique(l1)\n  u2 <- unique(l2)\n  u1[u2 %in% u1]\n}\n", "\n\
    \  u1 <- unique(l1)\n  u2 <- unique(l2)\n  u1[u2 %in% u1]\n}\n</code>\n<|/ a tags=r,list,unique\
    \ |>\n<| c |>\nThis doesn't work if there are duplicates in either of the lists.\n\
    <|/ c |>\n<| c |>\nYes, it does. I added a second example to show that.\n<|/ c\
    \ |>\n<| c |>\nI see what you mean. Yes, it does work. Sorry I missed that in\
    \ the question. Thanks for pointing it out.\n<|/ c |>\n<| c |>\nI added a third\
    \ example to show that `common` works with duplicates.\n<|/ c |>\n<| a tags=r,list,unique\
    \ |>\nHere's a solution using base R:\n<code>", "\n  u1 <- unique(l1)\n  u2 <-\
    \ unique(l2)\n  u1[u1 == u2]\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThanks for\
    \ your answer! I tested your function and it works, but it takes too long to run.\
    \ Do you know any faster way?\n<|/ c |>\n<| c |>\nI added a faster version to\
    \ my answer. Hope it helps.\n<|/ c |>\n<| c |>\nThanks for your answer! I tested\
    \ your function and it works, but it takes too long to run. Do you know any faster\
    \ way?\n<|/ c |>\n<| c |>\nI added a faster version to my answer. Hope it helps.\n\
    <|/ c |>\n<| a |>\nA solution using data.table:\n<code>\nlibrary(data.table)\n\
    setDT(df)\ndf[, x := .I]\ndf[, y := .I]\ndf[, z := .I]\ndf[, i := .I]\ndf[, j\
    \ := .I]\ndf[, k := .I]\ndf[, l := .I]\ndf[, m := .I]\ndf[, n := .I]\ndf[, o :=\
    \ .I]\ndf[, p := .I]\ndf[, q := .I]\ndf[, r := .I]\ndf[, s := .I]\ndf[, t := .I]\n\
    df[, u := .I]\ndf[, v := .I]\ndf[, w := .I]\ndf[, x := NULL]\ndf[, y := NULL]\n\
    df[, z := NULL]\ndf[, i := NULL]\ndf[, j := NULL]\ndf[, k := NULL]\ndf[, l :=\
    \ NULL]\ndf[, m := NULL]\ndf[, n := NULL]\ndf[, o := NULL]\ndf[, p := NULL]\n\
    df[, q := NULL]\ndf[, r := NULL]\ndf[, s := NULL]\ndf[, t := NULL]\ndf[, u :=\
    \ NULL]\ndf[, v := NULL]\ndf[, w := NULL]\ndf[, x := NULL]\ndf[, y := NULL]\n\
    df[, z := NULL]\ndf[, i := NULL]\ndf[, j := NULL]\ndf[, k := NULL]\ndf[, l :=\
    \ NULL]\ndf[, m := NULL]\ndf[, n := NULL", "\n  l1 <- sort(l1)\n  l2 <- sort(l2)\n\
    \  common1 <- intersect(l1, l2)\n  common2 <- intersect(l2, l1)\n  common1 <-\
    \ c(common1, l1[length(common1)])\n  common2 <- c(common2, l2[length(common2)])\n\
    \  common1 <- unique(common1)\n  common2 <- unique(common2)\n  common\n}\n</code>\n\
    <|/ a dscore=3 |>\n<| c |>\nI like this solution, because it doesn't require any\
    \ packages. However, it does require a little more memory than my solution. My\
    \ solution requires O(n^2) memory, while this solution requires O(n) memory. I'm\
    \ going to run some tests to see which one is better for my application. Thanks!\n\
    <|/ c |>\n<| c |>\nI ran some tests, and this solution is better for my application.\
    \ Thanks!\n<|/ c |>\n<| a tags=r,sorting,algorithm |>\nHere's a solution using\
    \ data.table:\n<code>\nlibrary(data.table)\ndt <- data.table(\n  x = c(1:10, 1:10,\
    \ 1:10, 1:10),\n  y = c(1:10, 1:10, 1:10, 1:10)\n)\ndt[, x := factor(x, levels\
    \ = unique(x)), by = y]\ndt[, y := factor(y, levels = unique(y)), by = x]\ndt[,\
    \ x := NULL]\ndt[, y := NULL]\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThis solution\
    \ works well for my application. Thanks!\n<|/ c |>\n<| a dscore=3 |>\nHere's a\
    \ solution using data.table:\n<code>\nlibrary(data.table)\ndt <- data.table(\n\
    \  x = c(1:10, 1:10, 1:10, 1:10),\n  y = c(1:10, 1:10, 1:10, 1:10)\n)\ndt[, x\
    \ := factor(x, levels = unique(x)), by = y]\ndt[, y := factor(y, levels = unique(y)),\
    \ by = x]\ndt[, x := NULL]\ndt[, y := NULL]\n</code>\n<|/ a tags=r,sorting,algorithm\
    \ |>\n<| a tags=r,sorting,algorithm |>\nHere's a solution using data.table:\n\
    <code>\nlibrary(data.table)\ndt <- data.table(\n  x = c(1:10, 1:10, 1:10, 1:10),\n\
    \  y = c(1:10, 1:10, 1:10, 1:10)\n)\ndt[, x := factor(x, levels = unique(x)),\
    \ by = y]", "\n  l1 <- sort(l1)\n  l2 <- sort(l2)\n  u <- unique(c(l1, l2))\n\
    \  u[!duplicated(u)]\n}\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis should be the\
    \ accepted answer. Much more efficient than `intersect` as it doesn't require\
    \ sorting.\n<|/ c |>\n<| c |>\nThis should be the accepted answer. Much more efficient\
    \ than `intersect` as it doesn't require sorting.\n<|/ c |>\n<| c |>\nThis should\
    \ be the accepted answer. Much more efficient than `intersect` as it doesn't require\
    \ sorting.\n<|/ c |>\n<| c |>\nThis should be the accepted answer. Much more efficient\
    \ than `intersect` as it doesn't require sorting.\n<|/ c |>\n<| c |>\nThis should\
    \ be the accepted answer. Much more efficient than `intersect` as it doesn't require\
    \ sorting.\n<|/ c |>\n<| a dscore=5 tags=r,intersection,list |>\n<code>\n> intersect(a,\
    \ b)\n[1] 1 2 3 4\n</code>\n<|/ a |>\n<| c |>\nThis should be the accepted answer.\
    \ Much more efficient than `intersect` as it doesn't require sorting.\n<|/ c |>\n\
    <| c |>\nThis should be the accepted answer. Much more efficient than `intersect`\
    \ as it doesn't require sorting.\n<|/ c |>\n<| c |>\nThis should be the accepted\
    \ answer. Much more efficient than `intersect` as it doesn't require sorting.\n\
    <|/ c |>\n<| c |>\nThis should be the accepted answer. Much more efficient than\
    \ `intersect` as it doesn't require sorting.\n<|/ c |>\n<| c |>\nThis should be\
    \ the accepted answer. Much more efficient than `intersect` as it doesn't require\
    \ sorting.\n<|/ c |>\n<| a tags=r,intersection,list |>\n<code>\n> intersect(a,\
    \ b)\n[1] 1 2 3 4\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis should be the accepted\
    \ answer. Much more efficient than `intersect` as it doesn't require sorting.\n\
    <|/ c |>\n<| c |>\nThis should be the accepted answer. Much more efficient than\
    \ `intersect` as it doesn't require sorting.\n<|/ c |>\n<| c |>\nThis should be\
    \ the accepted answer. Much more efficient than `intersect` as it doesn't require\
    \ sorting.\n<|/", "\n  u1 <- unique(l1)\n  u2 <- unique(l2)\n  u1[u2 %in% u1]\n\
    }\n</code>\n<|/ a tags=r,unique,list |>\n<| c |>\nThis doesn't work if you have\
    \ duplicate elements in your lists.\n<|/ c |>\n<| c |>\nYes, it does. I added\
    \ a test case to my answer.\n<|/ c |>\n<| c |>\nI added a test case to my answer.\
    \ Thanks for pointing that out.\n<|/ c |>\n<| c |>\nI added a test case to my\
    \ answer. Thanks for pointing that out.\n<|/ c |>\n<| c |>\nI added a test case\
    \ to my answer. Thanks for pointing that out.\n<|/ c |>\n<| a tags=r,unique,list\
    \ |>\nHere's a solution using base R:\n<code>", "\n  u1 <- unique(l1)\n  u2 <-\
    \ unique(l2)\n  u1[u1 == u2]\n}\n</code>\n<|/ a tags=r,list,unique |>\n<| a tags=r,list,unique\
    \ |>\n<code>", "\n  u1 <- unique(l1)\n  u2 <- unique(l2)\n  u1[u2 %in% u1]\n}\n\
    </code>\n<|/ a tags=r,dataframe,list |>\n<| c |>\nThank you so much! This was\
    \ very helpful!\n<|/ c |>\n<| a tags=r,dataframe,list |>\nHere's a solution using\
    \ data.table:\n<code>\nlibrary(data.table)\n", "\n  u1 <- unique(l1)\n  u2 <-\
    \ unique(l2)\n  u1[u2 %in% u1]\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis doesn't\
    \ work if there are duplicates in either of the lists.\n<|/ c |>\n<| c |>\nYes,\
    \ it does. I tested it before posting.\n<|/ c |>\n<| c |>\nIt doesn't work if\
    \ there are duplicates in either of the lists.\n<|/ c |>\n<| c |>\nIt doesn't\
    \ work if there are duplicates in either of the lists.\n<|/ c |>\n<| c |>\nIt\
    \ doesn't work if there are duplicates in either of the lists.\n<|/ c |>\n<| a\
    \ dscore=2 |>\n<code>\nlibrary(dplyr)\nlibrary(purrr)\nlibrary(stringr)\n\ncommon_elements\
    \ <- function(list1, list2) {\n  list1 <- list1 %>% \n    map(str_to_lower) %>%\
    \ \n    map(~str_split(.x, \"\\\\s+\"))\n  list2 <- list2 %>% \n    map(str_to_lower)\
    \ %>% \n    map(~str_split(.x, \"\\\\s+\"))\n  \n  list1 %>% \n    map(~map_chr(list2,\
    \ ~intersect(.x, .y)))\n}\n\ncommon_elements(list1, list2)\n</code>\n<|/ a tags=r\
    \ |>\n<| c |>\nThis doesn't work if there are duplicates in either of the lists.\n\
    <|/ c |>\n<| c |>\nIt doesn't work if there are duplicates in either of the lists.\n\
    <|/ c |>\n<| c |>\nIt doesn't work if there are duplicates in either of the lists.\n\
    <|/ c |>\n<| a tags=r |>\nHere is a base R solution:\n<code>\nlist1 <- list(c(\"\
    a\", \"b\", \"c\"), c(\"a\", \"b\", \"d\"), c(\"a\", \"b\", \"e\"), c(\"a\", \"\
    b\", \"f\"))\nlist2 <- list(c(\"a\", \"b\", \"c\"), c(\"a\", \"b\", \"d\"), c(\"\
    a\", \"b\", \"e\"), c(\"a\", \"b\", \"f\"))\n\nlist1 <- lapply(list1, function(x)\
    \ unlist(strsplit(x, \" \")))\nlist2 <- lapply(list2, function(x) unlist(strsplit(x,\
    \ \" \")))\n\nlist1 <- lapply(list1, function(x) x[!x %in% list2])\nlist2 <- lapply(list2,\
    \ function(x) x[!x %in% list1])\n\nlist1 <- lapply(list1, function(x) x[!x %in",
  "\n  u1 <- unique(l1)\n  u2 <- unique(l2)\n  u1[u2 %in% u1]\n}\n</code>\n<|/ a dscore=5\
    \ |>\n<| c |>\nThis should be the accepted answer. `intersect` doesn't preserve\
    \ order, and `setdiff` doesn't preserve duplicates.\n<|/ c |>\n<| c |>\nI agree\
    \ with you, `setdiff` doesn't preserve duplicates. But `intersect` does. So I\
    \ guess `setdiff` should be the accepted answer. :)\n<|/ c |>\n<| c |>\n`setdiff`\
    \ doesn't preserve duplicates, but `intersect` does. `setdiff` preserves order,\
    \ but `intersect` doesn't.\n<|/ c |>\n<| c |>\n`setdiff` preserves duplicates,\
    \ but `intersect` doesn't. `setdiff` preserves order, but `intersect` doesn't.\n\
    <|/ c |>\n<| c |>\n`setdiff` preserves duplicates, but `intersect` doesn't. `setdiff`\
    \ preserves order, but `intersect` doesn't.\n<|/ c |>\n<| a dscore=5 |>\nThe R\
    \ base function intersect does exactly what you want.\n<code>\n> intersect(c(1,2,3),\
    \ c(4,5,6))\n[1] 1 2 3\n</code>\n<|/ a tags=r |>\n<| c |>\nThis doesn't preserve\
    \ order. `intersect` doesn't preserve duplicates.\n<|/ c |>\n<| c |>\n`intersect`\
    \ preserves duplicates, but `setdiff` doesn't.\n<|/ c |>\n<| c |>\n`intersect`\
    \ preserves duplicates, but `setdiff` doesn't.\n<|/ c |>\n<| c |>\n`setdiff` preserves\
    \ duplicates, but `intersect` doesn't.\n<|/ c |>\n<| c |>\n`setdiff` preserves\
    \ duplicates, but `intersect` doesn't.\n<|/ c |>\n<| a dscore=5 |>\nThe R base\
    \ function setdiff does exactly what you want.\n<code>\n> setdiff(c(1,2,3), c(4,5,6))\n\
    [1] 1 3\n</code>\n<|/ a tags=r |>\n<| c |>\n`setdiff` preserves duplicates, but\
    \ `intersect` doesn't.\n<|/ c |>\n<| c |>\n`setdiff` preserves duplicates, but\
    \ `intersect` doesn't.\n<|/ c |>\n<| a tags=r |>\nThe ", "\n  u1 <- unique(l1)\n\
    \  u2 <- unique(l2)\n  u1[u2 %in% u1]\n}\n</code>\n<|/ a tags=r,list,unique |>\n\
    <| c |>\nThis doesn't seem to work if you have a list with multiple repeated elements.\
    \ For example, `common(c(\"a\", \"a\", \"b\"), c(\"a\", \"b\", \"c\"))` returns\
    \ `c(\"a\", \"b\", \"c\")`, whereas it should return `c(\"a\", \"b\", \"c\")`.\n\
    <|/ c |>\n<| c |>\nI fixed it by adding `u1[u2 %in% u1]` to the end of the function.\n\
    <|/ c |>\n<| c |>\nThis doesn't work if you have a list with multiple repeated\
    \ elements. For example, `common(c(\"a\", \"a\", \"b\"), c(\"a\", \"b\", \"c\"\
    ))` returns `c(\"a\", \"b\", \"c\")`, whereas it should return `c(\"a\", \"b\"\
    , \"c\")`.\n<|/ c |>\n<| c |>\nI fixed it by adding `u1[u2 %in% u1]` to the end\
    \ of the function.\n<|/ c |>\n<| a tags=r,list,unique |>\n<code>", "\n  u1 <-\
    \ unique(l1)\n  u2 <- unique(l2)\n  u1[u1 == u2]\n}\n</code>\n<|/ a dscore=2 |>\n\
    <| c |>\nThis doesn't seem to work if there are repeated elements in the lists.\
    \ For example, `common(list(c(1,2,3), c(1,2,3)), list(c(1,2,3), c(1,2,3)))` returns\
    \ `[1] 1 2 3` instead of `[1] 1 2 3`.\n<|/ c |>\n<| c |>\nI added a version that\
    \ works with repeated elements. Thanks for pointing that out.\n<|/ c |>\n<| a\
    \ tags=r,list |>\n<code>\ncommon<-function(l1,l2){\n  u1<-unique(l1)\n  u2<-unique(l2)\n\
    \  u1[u1==u2]\n}\n</code>\n<|/ a dscore=2 |>\n<| a tags=r,list |>\n<code>\ncommon<-function(l1,l2){\n\
    \  u1<-unique(l1)\n  u2<-unique(l2)\n  u1[u1==u2]\n}\n</code>\n<|/ a dscore=2\
    \ |>\n<| a dscore=1 |>\n<code>\ncommon<-function(l1,l2){\n  u1<-unique(l1)\n \
    \ u2<-unique(l2)\n  u1[u1==u2]\n}\n</code>\n<|/ a tags=r,list |>\n<| a tags=r,list\
    \ |>\n<code>\ncommon<-function(l1,l2){\n  u1<-unique(l1)\n  u2<-unique(l2)\n \
    \ u1[u1==u2]\n}\n</code>\n<|/ a dscore=1 |>\n<| a tags=r,list |>\n<code>\ncommon<-function(l1,l2){\n\
    \  u1<-unique(l1)\n  u2<-unique(l2)\n  u1[u1==u2]\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| a dscore=1 |>\n<code>\ncommon<-function(l1,l2){\n  u1<-unique(l1)\n \
    \ u2<-unique(l2)\n  u1[u1==u2]\n}\n</code>\n<|/ a tags=r,list |>\n<| a |>\n<code>\n\
    common<-function(l1,l2){\n  u1<-unique(l1)\n  u2<-unique(l2)\n  u1[", "\n  u1\
    \ <- unique(l1)\n  u2 <- unique(l2)\n  u1[u2 %in% u1]\n}\n</code>\n<|/ a tags=r\
    \ |>\n<| c |>\nI like this solution, but I wonder if there is a way to do this\
    \ without having to create a temporary data frame. I'm thinking there might be\
    \ a way to do this with some kind of apply function, but I'm not sure.\n<|/ c\
    \ |>\n<| c |>\nI added a solution without creating a temporary data frame.\n<|/\
    \ c |>\n<| c |>\nThanks, this is great! I didn't know about `intersect` before.\
    \ I'm still trying to wrap my head around `apply` so I appreciate your help!\n\
    <|/ c |>\n<| c |>\nI added a solution without creating a temporary data frame.\n\
    <|/ c |>\n<| c |>\nThanks again! I really appreciate your help!\n<|/ c |>\n<|\
    \ a dscore=3 |>\nHere is a solution without creating a temporary data frame:\n\
    <code>\ncommon <- function(l1, l2) {\n  u1 <- unique(l1)\n  u2 <- unique(l2)\n\
    \  u1[u2 %in% u1]\n}\n\ncommon(c(1,2,3), c(1,2,3))", "\n  u1 <- sort(unique(l1))\n\
    \  u2 <- sort(unique(l2))\n  u1[u1 == u2]\n}\n</code>\n<|/ a dscore=5 |>\n<| c\
    \ |>\nThis doesn't work if there are duplicate elements in the lists. For example,\
    \ `common(list(\"a\", \"a\", \"b\", \"c\"), list(\"a\", \"b\", \"c\"))` returns\
    \ `[1] \"a\" \"b\"` instead of `[1] \"a\" \"b\" \"c\"`.\n<|/ c |>\n<| c |>\nThis\
    \ doesn't work if there are duplicate elements in the lists. For example, `common(list(\"\
    a\", \"a\", \"b\", \"c\"), list(\"a\", \"b\", \"c\"))` returns `[1] \"a\" \"b\"\
    ` instead of `[1] \"a\" \"b\" \"c\"`.\n<|/ c |>\n<| c |>\nThis doesn't work if\
    \ there are duplicate elements in the lists. For example, `common(list(\"a\",\
    \ \"a\", \"b\", \"c\"), list(\"a\", \"b\", \"c\"))` returns `[1] \"a\" \"b\"`\
    \ instead of `[1] \"a\" \"b\" \"c\"`.\n<|/ c |>\n<| c |>\nThis doesn't work if\
    \ there are duplicate elements in the lists. For example, `common(list(\"a\",\
    \ \"a\", \"b\", \"c\"), list(\"a\", \"b\", \"c\"))` returns `[1] \"a\" \"b\"`\
    \ instead of `[1] \"a\" \"b\" \"c\"`.\n<|/ c |>\n<| c |>\nThis doesn't work if\
    \ there are duplicate elements in the lists. For example, `common(list(\"a\",\
    \ \"a\", \"b\", \"c\"), list(\"a\", \"b\", \"c\"))` returns `[1] \"a\" \"b\"`\
    \ instead of `[1] \"a\" \"b\" \"c\"`.\n<|/ c |>\n<| a tags=r,list |>\n<code>\n\
    > x <- list(\"a\", \"b\", \"c\")\n> y <- list(\"a\", \"b\", \"c\")\n> common(x,\
    \ y)\n[1] \"a\" \"b\"\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis doesn't work\
    \ if there are duplicate elements in the lists. For example, `common(list(\"a\"\
    , \"a\", \"b\", \"c\"), list(\"a\", \"b\", \"c\"))` returns `[1] \"a\" \"b\"`\
    \ instead of `[1] \"a\" \"b\" \"c\"`.\n<|/ c |>\n<| c |>\nThis doesn't work if\
    \ there are duplicate elements in the lists. For example, `common(list(\"a\",\
    \ \"a\", \"b\", \"c\"), list(\"a\", \"b\", \"c\"))` returns `[1] \"a\" \"b\"`\
    \ instead of `[1] \"a\" \"b\" \"c\"`.\n<|/ c |>\n<| c |>\nThis doesn't work if\
    \ there are duplicate elements in the lists. For example, `common(", "\n  u1 <-\
    \ unique(l1)\n  u2 <- unique(l2)\n  u1[u2 %in% u1]\n}\n</code>\n<|/ a dscore=2\
    \ |>\n<| a tags=r |>\n<code>", "\n  l1 <- sort(l1)\n  l2 <- sort(l2)\n  common1\
    \ <- intersect(l1, l2)\n  common2 <- intersect(l2, l1)\n  common1 <- sort(common1)\n\
    \  common2 <- sort(common2)\n  common1 <- unique(c(common1, common2))\n  common2\
    \ <- unique(c(common2, common1))\n  common1 <- common1[!is.na(common1)]\n  common2\
    \ <- common2[!is.na(common2)]\n  common1 <- common1[!is.na(common1)]\n  common2\
    \ <- common2[!is.na(common2)]\n  common1 <- common1[!is.na(common1)]\n  common2\
    \ <- common2[!is.na(common2)]\n  common1 <- common1[!is.na(common1)]\n  common2\
    \ <- common2[!is.na(common2)]\n  common1 <- common1[!is.na(common1)]\n  common2\
    \ <- common2[!is.na(common2)]\n  common1 <- common1[!is.na(common1)]\n  common2\
    \ <- common2[!is.na(common2)]\n  common1 <- common1[!is.na(common1)]\n  common2\
    \ <- common2[!is.na(common2)]\n  common1 <- common1[!is.na(common1)]\n  common2\
    \ <- common2[!is.na(common2)]\n  common1 <- common1[!is.na(common1)]\n  common2\
    \ <- common2[!is.na(common2)]\n  common1 <- common1[!is.na(common1)]\n  common2\
    \ <- common2[!is.na(common2)]\n  common1 <- common1[!is.na(common1)]\n  common2\
    \ <- common2[!is.na(common2)]\n  common1 <- common1[!is.na(common1)]\n  common2\
    \ <- common2[!is.na(common2)]\n  common1 <- common1[!is.na(common1)]\n  common2\
    \ <- common2[!is.na(common2)]\n  common1 <- common1[!is.na(common1)]\n  common2\
    \ <- common2[!is.na(common2)]\n  common1 <- common1[!is.na(common1)]\n  common2\
    \ <- common2[!is.na(common2)]\n  common1 <- common1[!is.na(common1)]\n  common2\
    \ <- common2[!is.na(common2)]\n  common1 <- common1[!is.na(common1)]\n  common",
  "\n  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n  u1[u1 == u2] # remove duplicates\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis doesn't work for me. `common(list(c(1,2,3),\
    \ c(1,2,3)), list(c(1,2,3), c(1,2,4)))` returns `[1] 1 2 3` instead of `[1] 1\
    \ 2 3`.\n<|/ c |>\n<| c |>\nI tested it on R 3.2.2 and it works. I guess you have\
    \ a different version of R. Try `common(list(c(1,2,3), c(1,2,3)), list(c(1,2,3),\
    \ c(1,2,4)))`\n<|/ c |>\n<| c |>\nYes, I tested it on R 3.2.2 and it works. I\
    \ guess you have a different version of R. Try `common(list(c(1,2,3), c(1,2,3)),\
    \ list(c(1,2,3), c(1,2,4)))`\n<|/ c |>\n<| c |>\nYes, I tested it on R 3.2.2 and\
    \ it works. I guess you have a different version of R. Try `common(list(c(1,2,3),\
    \ c(1,2,3)), list(c(1,2,3), c(1,2,4)))`\n<|/ c |>\n<| c |>\nI tested it on R 3.2.2\
    \ and it works. I guess you have a different version of R. Try `common(list(c(1,2,3),\
    \ c(1,2,3)), list(c(1,2,3), c(1,2,4)))`\n<|/ c |>\n<| a dscore=2 |>\nThis should\
    \ work:\n<code>\ncommon = function(l1, l2) {\n  u1 <- sort(unique(l1))\n  u2 <-\
    \ sort(unique(l2))\n  u1[u1 == u2]\n}\n</code>\n<|/ a tags=r |>\n<| c |>\nThis\
    \ doesn't work for me. `common(list(c(1,2,3), c(1,2,3)), list(c(1,2,3), c(1,2,4)))`\
    \ returns `[1] 1 2 3` instead of `[1] 1 2 3`.\n<|/ c |>\n<| c |>\nI tested it\
    \ on R 3.2.2 and it works. I guess you have a different version of R. Try `common(list(c(1,2,3),\
    \ c(1,2,3)), list(c(1,2,3), c(1,2,4)))`\n<|/ c |>\n<| a tags=r |>\n<code>\ncommon\
    \ <- function(l1, l2) {\n  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n\
    \  u", "\n  u1 <- unique(l1)\n  u2 <- unique(l2)\n  u1[u2 %in% u1]\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nThanks for your answer. Your solution works well for\
    \ small lists, but for large lists (>10000 elements) it takes too long to compute.\
    \ I'm looking for a solution that is more efficient for large lists.\n<|/ c |>\n\
    <| c |>\nI added a solution based on your answer. Thanks again!\n<|/ c |>\n<|\
    \ a dscore=1 |>\nI finally found a solution that is efficient for large lists:\n\
    <code>", "\n  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n  u1[u1 == u2]\n\
    }\n</code>\n<|/ a tags=r,sorting |>\n<| c |>\nThis doesn't seem to work if there\
    \ are repeated elements in the lists. For example, `common(c(1,2,2,3,4), c(1,2))`\
    \ returns `[1] 1 2 3` instead of `[1] 1 2`.\n<|/ c |>\n<| c |>\nI added a fix\
    \ for that case.\n<|/ c |>\n<| c |>\nThis doesn't seem to work if there are repeated\
    \ elements in the lists. For example, `common(c(1,2,2,3,4), c(1,2))` returns `[1]\
    \ 1 2 3` instead of `[1] 1 2`.\n<|/ c |>\n<| c |>\nI added a fix for that case.\n\
    <|/ c |>\n<| a tags=r,sorting |>\n<code>\ncommon <- function(l1, l2) {\n  u1 <-\
    \ sort(unique(l1))\n  u2 <- sort(unique(l2))\n  u1[u1 == u2]\n}\n</code>\n<|/\
    \ a dscore=5 |>\n<| c |>\nThis doesn't seem to work if there are repeated elements\
    \ in the lists. For example, `common(c(1,2,2,3,4), c(1,2))` returns `[1] 1 2 3`\
    \ instead of `[1] 1 2`.\n<|/ c |>\n<| c |>\nThis doesn't seem to work if there\
    \ are repeated elements in the lists. For example, `common(c(1,2,2,3,4), c(1,2))`\
    \ returns `[1] 1 2 3` instead of `[1] 1 2`.\n<|/ c |>\n<| c |>\nThis doesn't seem\
    \ to work if there are repeated elements in the lists. For example, `common(c(1,2,2,3,4),\
    \ c(1,2))` returns `[1] 1 2 3` instead of `[1] 1 2`.\n<|/ c |>\n<| a tags=r,sorting\
    \ |>\n<code>\ncommon <- function(l1, l2) {\n  u1 <- sort(unique(l1))\n  u2 <-\
    \ sort(unique(l2))\n  u1[u1 == u2]\n}\n</code>\n<|/ a dscore=4 |>\n<| c |>\nThis\
    \ doesn't seem to work if there are repeated elements in the lists. For example,\
    \ `common(c(1,2,2,3,4), c(1,2))` returns `[1] 1 2 3` instead of `[1] 1 2`.\n<|/\
    \ c |>\n<| c |>\nThis doesn't seem to work if there are repeated elements in the\
    \ lists. For example, `common(c(1,2,2,3,4), c(1,2))` returns `[1] 1 2 3` instead\
    \ of ", "\n  u1 <- unique(l1)\n  u2 <- unique(l2)\n  u1[u2 %in% u1]\n}\n</code>\n\
    <|/ a dscore=2 |>\n<| a tags=r,unique,list |>\n<code>"]
stop_tokens:
- "\n#"
- "\n```"
