name: HumanEval_60_sum_to_n
language: r
prompt: "# sum_to_n is a function that sums numbers from 1 to n.\n# >>> sum_to_n(30)\n\
  # 465\n# >>> sum_to_n(100)\n# 5050\n# >>> sum_to_n(5)\n# 15\n# >>> sum_to_n(10)\n\
  # 55\n# >>> sum_to_n(1)\n# 1\nsum_to_n <- function(n) {"
tests: "test_humaneval <- function() {\ncandidate <- sum_to_n\n    if(!identical(candidate(1),\
  \ 1)){quit('no', 1)}\n    if(!identical(candidate(6), 21)){quit('no', 1)}\n    if(!identical(candidate(11),\
  \ 66)){quit('no', 1)}\n    if(!identical(candidate(30), 465)){quit('no', 1)}\n \
  \   if(!identical(candidate(100), 5050)){quit('no', 1)}\n}\ntest_humaneval()"
completions: ["\n  n <- n + 1\n  n <- n * 3 + 1\n  n <- n / 2 + 1\n  n\n}\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nI like your solution, but I wonder if there is a way\
    \ to do it without using any packages. I guess it would be a recursive function,\
    \ but I haven't been able to figure it out.\n<|/ c |>\n<| c |>\nI added a recursive\
    \ solution to my answer. Hope it helps.\n<|/ c |>\n<| c |>\nThanks, this is very\
    \ helpful.\n<|/ c |>\n<| a dscore=1 |>\nHere's a recursive solution:\n<code>\n\
    sum_to_n <- function(n) {\n  n <- n + 1\n  n <- n * 3 + 1\n  n <- n / 2 + 1\n\
    \  n\n}\n\nsum_to_n(10)", "\n  n <- n + 1\n  n <- n * n\n  n <- n / 2\n  n\n}\n\
    </code>\n<|/ a |>\n<| c |>\nThank you for your answer. I'm sorry I didn't make\
    \ it clear enough in my question. I'm looking for a way to do this without using\
    \ any packages. I edited my question to make it clearer.\n<|/ c |>\n<| c |>\n\
    I edited my answer to include a solution that does not use any packages.\n<|/\
    \ c |>\n<| c |>\nThank you for your answer. I'm sorry I didn't make it clear enough\
    \ in my question. I'm looking for a way to do this without using any packages.\
    \ I edited my question to make it clearer.\n<|/ c |>\n<| c |>\nI edited my answer\
    \ to include a solution that does not use any packages.\n<|/ c |>\n<| a tags=r,sum,function\
    \ |>\n<code>\nsum_to_n <- function(n) {\n  n <- n + 1\n  n <- n * n\n  n <- n\
    \ / 2\n  n\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThank you for your answer.\
    \ I'm sorry I didn't make it clear enough in my question. I'm looking for a way\
    \ to do this without using any packages. I edited my question to make it clearer.\n\
    <|/ c |>\n<| a dscore=0 |>\n<code>\nsum_to_n <- function(n) {\n  n <- n + 1\n\
    \  n <- n * n\n  n <- n / 2\n  n\n}\n</code>\n<|/ a tags=r,sum,function |>\n<|\
    \ c |>\nThank you for your answer. I'm sorry I didn't make it clear enough in\
    \ my question. I'm looking for a way to do this without using any packages. I\
    \ edited my question to make it clearer.\n<|/ c |>\n<| a tags=r,sum,function |>\n\
    <code>\nsum_to_n <- function(n) {\n  n <- n + 1\n  n <- n * n\n  n <- n / 2\n\
    \  n\n}\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>\nsum_to_n <- function(n)\
    \ {\n  n <- n + 1\n  n <- n * n\n  n <- n / 2\n  n\n}\n</code>\n<|/ a tags=r,sum,function\
    \ |>\n<| c |>\nThank you for your answer. I'm sorry I didn't make it clear enough\
    \ in my question. I'm looking for a way to do this without using any packages.\
    \ I edi", "\n  n <- n + 1\n  if(n == 1) 1\n  else n * sum_to_n(n-1)\n}\n</cell>\n\
    <cell>\nsum_to_n(10)\n</cell>\n<cell>", "\n  n <- n + 1\n  return(sum(1:n))\n\
    }\n</cell>\n<cell>", "\n  n <- n\n  if(n < 1) return(0)\n  if(n %% 2 == 0) return(sum_to_n(n/2)\
    \ + n)\n  return(sum_to_n(n/2) + n)\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\n\
    I like your solution, but I wonder if there is a way to avoid recursion. Maybe\
    \ with some kind of iterative solution?\n<|/ c |>\n<| c |>\nI added a recursive\
    \ solution, but I wonder if there is a way to avoid recursion.\n<|/ c |>\n<| c\
    \ |>\nI added a recursive solution, but I wonder if there is a way to avoid recursion.\n\
    <|/ c |>\n<| c |>\nI added a recursive solution, but I wonder if there is a way\
    \ to avoid recursion.\n<|/ c |>\n<| c |>\nI added a recursive solution, but I\
    \ wonder if there is a way to avoid recursion.\n<|/ c |>\n<| a tags=recursion,r\
    \ |>\nHere's a recursive solution:\n<code>\nsum_to_n <- function(n) {\n  if(n\
    \ < 1) return(0)\n  if(n %% 2 == 0) return(sum_to_n(n/2) + n)\n  return(sum_to_n(n/2)\
    \ + n)\n}\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2 |>\nHere's a recursive solution:\n\
    <code>\nsum_to_n <- function(n) {\n  if(n < 1) return(0)\n  if(n %% 2 == 0) return(sum_to_n(n/2)\
    \ + n)\n  return(sum_to_n(n/2) + n)\n}\n</code>\n<|/ a tags=recursion,r |>\n<|\
    \ a dscore=2 |>\nHere's a recursive solution:\n<code>\nsum_to_n <- function(n)\
    \ {\n  if(n < 1) return(0)\n  if(n %% 2 == 0) return(sum_to_n(n/2) + n)\n  return(sum_to_n(n/2)\
    \ + n)\n}\n</code>\n<|/ a tags=recursion,r |>\n<| a dscore=1 |>\nHere's a recursive\
    \ solution:\n<code>\nsum_to_n <- function(n) {\n  if(n < 1) return(0)\n  if(n\
    \ %% 2 == 0) return(sum_to_n(n/2) + n)\n  return(sum_to_n(n/2) + n)\n}\n</code>\n\
    <|/ a tags=recursion,r |>\n<| a tags=recursion,r |>\nHere's a recursive solution:\n\
    <code>\nsum_to_n <- function(n) {\n  if(n < 1) return(0)\n  if(n %% 2 == 0) return(sum_to_n(n",
  "\n  n <- as.integer(n)\n  if(n < 1) return(0)\n  if(n > 1) return(sum(1:n))\n}\n\
    </code>\n<|/ a dscore=2 |>\n<| c |>\nI like your solution. However it seems that\
    \ it only works for positive integers. I tried to make it work for negative integers\
    \ by replacing `1:n` with `seq(1,n)` but that didn't work. Do you know why that\
    \ is?\n<|/ c |>\n<| c |>\nI added a version that works for negative numbers. I\
    \ didn't test it for negative numbers, but it seems to work.\n<|/ c |>\n<| c |>\n\
    I tested it and it works. I guess I missed something when I tried it earlier.\
    \ Thanks!\n<|/ c |>\n<| a tags=r,sum,integer |>\n<code>\nsum_to_n <- function(n){\n\
    \  n <- as.integer(n)\n  if(n < 1) return(0)\n  if(n > 1) return(sum(1:n))\n}\n\
    </code>\n<|/ a dscore=2 |>\n<| a dscore=1 |>\n<code>\nsum_to_n <- function(n){\n\
    \  n <- as.integer(n)\n  if(n < 1) return(0)\n  if(n > 1) return(sum(1:n))\n}\n\
    </code>\n<|/ a tags=r,sum,integer |>\n<| a dscore=1 |>\n<code>\nsum_to_n <- function(n){\n\
    \  n <- as.integer(n)\n  if(n < 1) return(0)\n  if(n > 1) return(sum(1:n))\n}\n\
    </code>\n<|/ a tags=r,sum,integer |>\n<| a tags=r,sum,integer |>\n<code>\nsum_to_n\
    \ <- function(n){\n  n <- as.integer(n)\n  if(n < 1) return(0)\n  if(n > 1) return(sum(1:n))\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| a |>\n<code>\nsum_to_n <- function(n){\n  n\
    \ <- as.integer(n)\n  if(n < 1) return(0)\n  if(n > 1) return(sum(1:n))\n}\n</code>\n\
    <|/ a tags=r,sum,integer dscore=1 |>\n<| a dscore=1 |>\n<code>\nsum_to_n <- function(n){\n\
    \  n <- as.integer(n)\n  if(n < 1) return(0)\n  if(n > 1) return(sum(1:n))\n}\n\
    </code>\n<|/ a tags=r,sum,integer |>\n<| a tags=r,sum,integer |>\n<code>\nsum_to_",
  "\n  n <- n + 1\n  n <- n * n\n  return(n)\n}\n", "\n  return(sum(1:n))\n}\n", "\n\
    \  n <- n\n  n <- n + 1\n  n <- n * 3\n  n <- n - 1\n  n\n}\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nThanks for your answer. Your solution is very elegant and I like\
    \ it, but I cannot accept it because I cannot use it in my real code. My real\
    \ code is a bit more complicated and I cannot use your solution in my real code.\
    \ Sorry for not mentioning it in my question.\n<|/ c |>\n<| c |>\nNo problem.\
    \ Your question was very interesting to me. I'm glad you found a solution that\
    \ works for you. Good luck!\n<|/ c |>\n<| a |>\nI believe that your problem can\
    \ be solved using recursion. \n<code>\nsum_to_n <- function(n) {\n  n <- n\n \
    \ n <- n + 1\n  n <- n * 3\n  n <- n - 1\n  n\n}\n</code>\nThe function above\
    \ is equivalent to:\n<code>\nsum_to_n <- function(n) {\n  if (n == 1) 1\n  else\
    \ if (n == 2) 3\n  else if (n == 3) 9\n  else sum_to_n(n - 1)\n}\n</code>\n<|/\
    \ a dscore=1 tags=r,recursion,function,sum |>\n<| c |>\nThanks for your answer.\
    \ Your solution is very elegant and I like it, but I cannot accept it because\
    \ I cannot use it in my real code. My real code is a bit more complicated and\
    \ I cannot use your solution in my real code. Sorry for not mentioning it in my\
    \ question.\n<|/ c |>\n<| a tags=r,recursion,function,sum |>\n<code>\nsum_to_n\
    \ <- function(n) {\n  n <- n\n  n <- n + 1\n  n <- n * 3\n  n <- n - 1\n  n\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThanks for your answer. Your solution\
    \ is very elegant and I like it, but I cannot accept it because I cannot use it\
    \ in my real code. My real code is a bit more complicated and I cannot use your\
    \ solution in my real code. Sorry for not mentioning it in my question.\n<|/ c\
    \ |>\n<| a tags=r,recursion,function,sum |>\n<code>\nsum_to_n <- function(n) {\n\
    \  n <- n\n  n <- n + 1\n  n <- n * 3\n  n <- n - 1\n  n\n}\n</code>\n<|/ a dscore",
  "\n  n <- n + 1\n  n <- n * n\n  n <- n / 2\n  return(n)\n}\n</cell>\n<cell>\nsum_to_n(10)\n\
    </cell>\n<cell>\nsum_to_n(100)\n</cell>\n<cell>\nsum_to_n(1000)\n</cell>\n<cell>\n\
    sum_to_n(10000)\n</cell>\n<cell>\nsum_to_n(100000)\n</cell>\n<cell>\nsum_to_n(1000000)\n\
    </cell>\n<cell>\nsum_to_n(10000000)\n</cell>\n<cell>\nsum_to_n(100000000)\n</cell>\n\
    <cell>\nsum_to_n(1000000000)\n</cell>\n<cell>\nsum_to_n(10000000000)\n</cell>\n\
    <cell>\nsum_to_n(100000000000)\n</cell>\n<cell>\nsum_to_n(1000000000000)\n</cell>\n\
    <cell>\nsum_to_n(10000000000000)\n</cell>\n<cell>\nsum_to_n(100000000000000)\n\
    </cell>\n<cell>\nsum_to_n(1000000000000000)\n</cell>\n<cell>\nsum_to_n(10000000000000000)\n\
    </cell>\n<cell>\nsum_to_n(100000000000000000)\n</cell>\n<cell>\nsum_to_n(1000000000000000000)\n\
    </cell>\n<cell>\nsum_to_n(10000000000000000000)\n</cell>\n<cell>\nsum_to_n(100000000000000000000)\n\
    </cell>\n<cell>\nsum_to_n(1000000000000000000000)\n</cell>\n<cell>\nsum_to_n(10000000000000000000000)\n\
    </cell>\n<cell>\nsum_to_n(100000000000000000000000)\n</cell>\n<cell>\nsum_to_n(1000000000000000000000000)\n\
    </cell>\n<cell>\nsum_to_n(10000000000000000000000000)\n</cell>\n<cell>\nsum_to_n(100000000000000000000000000)\n\
    </cell>\n<cell>\nsum_to_n(1000000000000000000000000000)\n</cell>\n<cell>\nsum_to_n(10000000000000000000000000000)\n\
    </cell>\n<cell>\nsum_to_n(100000000000000000000000000000)\n</cell>\n<cell>\nsum_to_n(1000000000000000000000000000000)\n\
    </cell>\n<cell>\nsum_to_n(10000000000000000000000000000000)\n</cell>\n<cell>\n\
    sum_to_n(100000000000000000000000000000000", "\n  return(sum(1:n))\n}\n</cell>\n\
    <cell>", "\n  n <- as.integer(n)\n  sum <- 0\n  for(i in 1:n) {\n    sum <- sum\
    \ + i\n  }\n  return(sum)\n}\n", "\n  n <- n + 1\n  return(n %/% 10 * 10 + n %%\
    \ 10)\n}\n</cell>\n<cell>\nsum_to_n(30)\n</cell>\n<cell>\nsum_to_n(100)\n</cell>\n\
    <cell>\nsum_to_n(5)\n</cell>\n<cell>\nsum_to_n(10)\n</cell>\n<cell>\nsum_to_n(1)\n\
    </cell>\n<text>\nThe sum_to_n function above is called a generator function. It\
    \ generates numbers from 1 to n and stores them in a variable. Let's see how it\
    \ works:\n\n\n</text>\n<cell>\nsum_to_n_generator <- function(n) {\n  n <- n +\
    \ 1\n  return(n %/% 10 * 10 + n %% 10)\n}\n</cell>\n<cell>\nsum_to_n_generator(30)\n\
    </cell>\n<cell>\nsum_to_n_generator(100)\n</cell>\n<cell>\nsum_to_n_generator(5)\n\
    </cell>\n<cell>\nsum_to_n_generator(10)\n</cell>\n<cell>\nsum_to_n_generator(1)\n\
    </cell>\n<text>\nThe sum_to_n_generator function above is called a generator expression.\
    \ It generates numbers from 1 to n and stores them in a variable. Let's see how\
    \ it works:\n\n\n</text>\n<cell>\nsum_to_n_generator_exp <- function(n) {\n  n\
    \ <- n + 1\n  return(n %/% 10 * 10 + n %% 10)\n}\n</cell>\n<cell>\nsum_to_n_generator_exp(30)\n\
    </cell>\n<cell>\nsum_to_n_generator_exp(100)\n</cell>\n<cell>\nsum_to_n_generator_exp(5)\n\
    </cell>\n<cell>\nsum_to_n_generator_exp(10)\n</cell>\n<cell>\nsum_to_n_generator_exp(1)\n\
    </cell>\n<text>\nThe sum_to_n_generator_exp function above is called a list comprehension.\
    \ It generates numbers from 1 to n and stores them in a variable. Let's see how\
    \ it works:\n\n\n</text>\n<cell>\nsum_to_n_generator_exp_list <- function(n) {\n\
    \  n <- n + 1\n  return(n %/% 10 * 10 + n %% 10)\n}\n</cell>\n<cell>\nsum_to_n_generator_exp_list(30)\n\
    </cell>\n<cell>\nsum_to_n_generator_exp_list(100)\n</cell>\n<cell>\nsum_to_n_generator_exp_list(",
  "\n  n <- n + 1\n  if(n == 1) 1\n  else n * sum_to_n(n-1)\n}\n", "\n  n <- n + 1\n\
    \  return(n %/% sum_to_n(n - 1))\n}\n</cell>\n<text>\nThe function sum_to_n takes\
    \ an integer argument and returns the sum of the integers from 1 to that number.\
    \ For example, sum_to_n(10) returns 55.\n\nThe function sum_to_n has two base\
    \ cases. If the argument n is 1, the function returns 1. Otherwise, the function\
    \ returns the sum of the integers from 1 to n by adding n to itself and subtracting\
    \ 1 from n.\n\n\n</text>\n<cell>\nsum_to_n(1)\n</cell>\n<cell>\nsum_to_n(10)\n\
    </cell>\n<cell>\nsum_to_n(100)\n</cell>\n<cell>\nsum_to_n(1000)\n</cell>\n<cell>\n\
    sum_to_n(10000)\n</cell>\n<cell>\nsum_to_n(100000)\n</cell>\n<cell>\nsum_to_n(1000000)\n\
    </cell>\n<cell>\nsum_to_n(10000000)\n</cell>\n<text>\nExercise\nWrite a function\
    \ that returns the sum of the integers from 1 to n by adding n to itself and subtracting\
    \ 1 from n.\n\n\n</text>\n<cell>", "\n  n <- as.integer(n)\n  if(n <= 0) stop(\"\
    n must be positive\")\n  if(n > 100) stop(\"n must be less than 100\")\n  n <-\
    \ n + 1\n  n <- n * n\n  n <- n / 2\n  return(n)\n}\n</cell>\n<text>\nExercise\
    \ 3\nWrite a function that takes a vector of numbers and returns the sum of the\
    \ squares of the numbers.\n\nThe function should raise an error if the vector\
    \ is empty.\n\nThe function should raise an error if the vector has more than\
    \ one element.\n\nThe function should raise an error if the vector has negative\
    \ numbers.\n\nThe function should raise an error if the vector has more than 100\
    \ elements.\n\nThe function should raise an error if the vector has more than\
    \ 100 elements.\n\nThe function should raise an error if the vector has more than\
    \ 100 elements.\n\nThe function should raise an error if the vector has more than\
    \ 100 elements.\n\nThe function should raise an error if the vector has more than\
    \ 100 elements.\n\nThe function should raise an error if the vector has more than\
    \ 100 elements.\n\nThe function should raise an error if the vector has more than\
    \ 100 elements.\n\nThe function should raise an error if the vector has more than\
    \ 100 elements.\n\nThe function should raise an error if the vector has more than\
    \ 100 elements.\n\nThe function should raise an error if the vector has more than\
    \ 100 elements.\n\nThe function should raise an error if the vector has more than\
    \ 100 elements.\n\nThe function should raise an error if the vector has more than\
    \ 100 elements.\n\nThe function should raise an error if the vector has more than\
    \ 100 elements.\n\nThe function should raise an error if the vector has more than\
    \ 100 elements.\n\nThe function should raise an error if the vector has more than\
    \ 100 elements.\n\nThe function should raise an error if the vector has more than\
    \ 100 elements.\n\nThe function should raise an error if the vector has more than\
    \ 100 elements.\n\nThe function should raise an error if the vector has more than\
    \ 100 elements.\n\nThe function should raise an error if the vector has more than\
    \ 100 elements.\n\nThe function should raise an error if the vector has more than\
    \ 100 elements.\n\nThe function should raise an error if the vector has more than\
    \ 100 elements.\n\nThe function should raise an error if the vector has more than\
    \ 100 elements.\n\nThe function should raise an error if the vector has more than\
    \ 100 elements.\n\nThe function should raise an error if the vector has more than\
    \ 100 elements.\n\nThe function should raise an error if the vector has more than\
    \ 100 elements.\n\nThe function should raise an error if the vector has more than\
    \ 100 elements.\n\nThe function should raise an error if the vector has more than\
    \ 100 elements.\n\nThe function should raise an error if the vector has more than\
    \ 100 elements.\n\nThe function should raise an error if the vector has more than\
    \ 100 elements.\n\nThe function should raise an error if the vector has more than\
    \ 100 elements.\n\nThe function should raise an error if the vector has more than\
    \ 100 elements.\n\nThe function should raise an error if the vector has more than\
    \ 100 elements.\n\nThe function should raise an error if the vector has more than\
    \ 100 elements.\n\nThe ", "\n  n <- n + 1\n  n <- n * 3 + 1\n  n <- n / 2\n  n\n\
    }\n</cell>\n<text>\nLet's test our function by summing up from 1 to 100. We'll\
    \ start by defining a function called sum_to_n. We'll then call our function sum_to_n\
    \ to see what it returns.\n\n\n</text>\n<cell>\nsum_to_n(100)\n</cell>\n<text>\n\
    It returns 55! That's not what we expected. Let's see what happens when we call\
    \ our function with different inputs.\n\n\n</text>\n<cell>\nsum_to_n(10)\n</cell>\n\
    <cell>\nsum_to_n(5)\n</cell>\n<cell>\nsum_to_n(1)\n</cell>\n<text>\nIt looks like\
    \ our function isn't working properly. Let's fix it.\n\n\n</text>\n<cell>\nsum_to_n\
    \ <- function(n) {\n  n <- n + 1\n  n <- n * 3 + 1\n  n <- n / 2\n  n\n}\n</cell>\n\
    <cell>\nsum_to_n(100)\n</cell>\n<cell>\nsum_to_n(10)\n</cell>\n<cell>\nsum_to_n(5)\n\
    </cell>\n<cell>\nsum_to_n(1)\n</cell>\n<text>\nIt looks like our function works\
    \ now. Let's test it out by summing up from 1 to 100.\n\n\n</text>\n<cell>\nsum_to_n(100)\n\
    </cell>\n<text>\nIt returns 55! That's not what we expected. Let's see what happens\
    \ when we call our function with different inputs.\n\n\n</text>\n<cell>\nsum_to_n(10)\n\
    </cell>\n<cell>\nsum_to_n(5)\n</cell>\n<cell>\nsum_to_n(1)\n</cell>\n<text>\n\
    It looks like our function isn't working properly. Let's fix it.\n\n\n</text>\n\
    <cell>\nsum_to_n <- function(n) {\n  n <- n + 1\n  n <- n * 3 + 1\n  n <- n /\
    \ 2\n  n\n}\n</cell>\n<cell>\nsum_to_n(100)\n</cell>\n<cell>\nsum_to_n(10)\n</cell>\n\
    <cell>\nsum_to_n(5)\n</cell>\n<cell>\nsum_to_n(1)\n</cell>\n<text>\nIt looks like\
    \ our function works now. Let's test it out by summing up from 1 to 100.\n\n\n\
    </text>\n<cell>\nsum_to_n(100)\n</cell>\n<text>\nIt returns 55", "\n  n <- n\n\
    \  n <- ifelse(n < 1, n, 1)\n  n <- ifelse(n < 2, n * 2, n * 3)\n  n <- ifelse(n\
    \ < 3, n * 5, n * 7)\n  n <- ifelse(n < 5, n * 10, n * 13)\n  n <- ifelse(n <\
    \ 7, n * 15, n * 18)\n  n <- ifelse(n < 10, n * 20, n * 25)\n  n <- ifelse(n <\
    \ 15, n * 30, n * 35)\n  n <- ifelse(n < 20, n * 40, n * 45)\n  n <- ifelse(n\
    \ < 30, n * 50, n * 55)\n  n <- ifelse(n < 40, n * 60, n * 65)\n  n <- ifelse(n\
    \ < 50, n * 70, n * 75)\n  n <- ifelse(n < 60, n * 80, n * 85)\n  n <- ifelse(n\
    \ < 70, n * 90, n * 95)\n  n <- ifelse(n < 80, n * 100, n * 100)\n  n <- ifelse(n\
    \ < 90, n * 110, n * 115)\n  n <- ifelse(n < 100, n * 120, n / 10)\n  n\n}\n</cell>\n\
    <cell>\nsum_to_n(30)\n</cell>\n<cell>\nsum_to_n(100)\n</cell>\n<cell>\nsum_to_n(5)\n\
    </cell>\n<cell>\nsum_to_n(10)\n</cell>\n<cell>\nsum_to_n(1)\n</cell>\n<text>\n\
    Exercise: Write a function that returns the sum of the first n numbers of a Fibonacci\
    \ sequence. Test it by printing out the result of the function and comparing it\
    \ to the sum of the first n numbers of the Fibonacci sequence starting from 1.\n\
    \n\n</text>\n<cell>", "\n  n <- n + 1\n  if(n == 1) return(1)\n  return(sum_to_n(n-1))\n\
    }\n</cell>\n<cell>", "\n  n <- n + 1\n  n <- n * n\n  n <- n / 2\n  return(n)\n\
    }\n</cell>\n<cell>\nsum_to_n(10)\n</cell>\n<cell>\nsum_to_n(100)\n</cell>\n<cell>\n\
    sum_to_n(1000)\n</cell>\n<cell>\nsum_to_n(10000)\n</cell>\n<cell>\nsum_to_n(100000)\n\
    </cell>\n<cell>\nsum_to_n(1000000)\n</cell>\n<cell>\nsum_to_n(10000000)\n</cell>\n\
    <cell>\nsum_to_n(100000000)\n</cell>\n<cell>\nsum_to_n(1000000000)\n</cell>\n\
    <cell>\nsum_to_n(10000000000)\n</cell>\n<cell>\nsum_to_n(100000000000)\n</cell>\n\
    <cell>\nsum_to_n(1000000000000)\n</cell>\n<cell>\nsum_to_n(10000000000000)\n</cell>\n\
    <cell>\nsum_to_n(100000000000000)\n</cell>\n<cell>\nsum_to_n(1000000000000000)\n\
    </cell>\n<cell>\nsum_to_n(10000000000000000)\n</cell>\n<cell>\nsum_to_n(100000000000000000)\n\
    </cell>\n<cell>\nsum_to_n(1000000000000000000)\n</cell>\n<cell>\nsum_to_n(10000000000000000000)\n\
    </cell>\n<cell>\nsum_to_n(100000000000000000000)\n</cell>\n<cell>\nsum_to_n(1000000000000000000000)\n\
    </cell>\n<cell>\nsum_to_n(10000000000000000000000)\n</cell>\n<cell>\nsum_to_n(100000000000000000000000)\n\
    </cell>\n<cell>\nsum_to_n(1000000000000000000000000)\n</cell>\n<cell>\nsum_to_n(10000000000000000000000000)\n\
    </cell>\n<cell>\nsum_to_n(100000000000000000000000000)\n</cell>\n<cell>\nsum_to_n(1000000000000000000000000000)\n\
    </cell>\n<cell>\nsum_to_n(10000000000000000000000000000)\n</cell>\n<cell>\nsum_to_n(100000000000000000000000000000)\n\
    </cell>\n<cell>\nsum_to_n(1000000000000000000000000000000)\n</cell>\n<cell>\n\
    sum_to_n(10000000000000000000000000000000)\n</cell>\n<cell>\nsum_to_n(100000000000000000000000000000000"]
stop_tokens:
- "\n#"
- "\n```"
