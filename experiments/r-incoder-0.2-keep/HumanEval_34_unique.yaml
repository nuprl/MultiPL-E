name: HumanEval_34_unique
language: r
prompt: "# Return sorted unique elements in a list\n# >>> unique([5, 3, 5, 2, 3, 3,\
  \ 9, 0, 123])\n# [0, 2, 3, 5, 9, 123]\nunique <- function(l) {"
tests: "test_humaneval <- function() {\ncandidate <- unique\n    if(!identical(candidate(c(5,\
  \ 3, 5, 2, 3, 3, 9, 0, 123)), c(0, 2, 3, 5, 9, 123))){quit('no', 1)}\n}\ntest_humaneval()"
completions: ["\n  u <- unique(l)\n  u[order(u)] \n}\n</code>\n<|/ a dscore=5 |>\n\
    <| c |>\nI like this solution, but I wonder if there is a way to make it more\
    \ efficient. For example, `unique` sorts the list and then removes duplicates.\
    \ Sorting takes O(nlogn), removing duplicates takes O(n). So the overall complexity\
    \ is O(nlogn). Is there a way to make it more efficient?\n<|/ c |>\n<| c |>\n\
    Yes, you can do it in O(n) by using a hash table to store unique elements. But\
    \ this requires some extra memory and some extra work to implement.\n<|/ c |>\n\
    <| c |>\nI like your solution, but I wonder if there is a way to make it more\
    \ efficient. For example, unique sorts the list and then removes duplicates. Sorting\
    \ takes O(nlogn), removing duplicates takes O(n). So the overall complexity is\
    \ O(nlogn). Is there a way to make it more efficient?\n<|/ c |>\n<| c |>\nI added\
    \ a solution that uses hash tables.\n<|/ c |>\n<| c |>\nI like your solution,\
    \ but I wonder if there is a way to make it more efficient. For example, unique\
    \ sorts the list and then removes duplicates. Sorting takes O(nlogn), removing\
    \ duplicates takes O(n). So the overall complexity is O(nlogn). Is there a way\
    \ to make it more efficient?\n<|/ c |>\n<| a |>\nI like using data.table's unique()\
    \ function\n<code>\nlibrary(data.table)\ndt <- data.table(a = c(1,2,2,3,3,3,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,",
  "\n  u <- unique(l);\n  u[order(u)];\n}\n", "\n  u <- unique(l);\n  u[order(u)];\n\
    }\n", "\n  u <- unique(l)\n  u[order(u)] \n}\n</code>\n<|/ a dscore=3 |>\n<| c\
    \ |>\nThis doesn't seem to work if you have a list with duplicates, e.g. `unique(c(1,1,2,3,3))`\
    \ returns `[1] 1 2 3` instead of `[1] 1 3`.\n<|/ c |>\n<| c |>\nThis doesn't seem\
    \ to work if you have a list with duplicates, e.g. `unique(c(1,1,2,3,3))` returns\
    \ `[1] 1 2 3` instead of `[1] 1 3`.\n<|/ c |>\n<| c |>\nThis doesn't seem to work\
    \ if you have a list with duplicates, e.g. `unique(c(1,1,2,3,3))` returns `[1]\
    \ 1 2 3` instead of `[1] 1 3`.\n<|/ c |>\n<| a dscore=3 |>\nA simple solution\
    \ is to use setdiff:\n<code>\nsetdiff(1:10, c(1:10, 1:10))\n</code>\n<|/ a tags=r,unique,list\
    \ |>\n<| c |>\nThis doesn't seem to work if you have a list with duplicates, e.g.\
    \ `setdiff(c(1,1,2,3,3), c(1,2,3))` returns `[1] 1 2 3` instead of `[1] 1 3`.\n\
    <|/ c |>\n<| a dscore=3 |>\nI came up with a solution that doesn't require any\
    \ packages:\n<code>\nunique.list <- function(x) {\n  y <- x\n  for(i in seq_along(x))\
    \ {\n    if(!any(y == x[i])) {\n      y <- c(y, x[i])\n    }\n  }\n  y\n}\n</code>\n\
    <|/ a tags=r,unique,list |>\n<| c |>\nThis doesn't seem to work if you have a\
    \ list with duplicates, e.g. `unique.list(c(1,1,2,3,3))` returns `[1] 1 2 3` instead\
    \ of `[1] 1 3`.\n<|/ c |>\n<| a tags=r,unique,list |>\nHere's a solution using\
    \ purrr::keep:\n<code>\nlibrary(purrr)\nx <- list(c(1,2,3), c(1,3,4), c(1,3,4))\n\
    keep(x, ~!any(.x %in% .y))\n</code>\n<|/ a dscore=3 |>\n<| a tags=r,unique,list\
    \ |>\nHere's a solution using base R:\n<code>\nx <- list(c(1,2,3), c(1,3,4), c(1,3,4))\n\
    y <- unique(x)\ny[!duplicated(y)]\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2 |>\n\
    Here's ", "\n  u <- unique(l);\n  u[order(u)];\n}\n", "\n  u <- unique(l)\n  u[order(u)]\
    \ \n}\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis should be the accepted answer.\
    \ `unique` does exactly what it says on the tin.\n<|/ c |>\n<| c |>\n`unique`\
    \ does exactly what it says on the tin. `unique` does exactly what it says on\
    \ the tin. `unique` does exactly what it says on the tin. `unique` does exactly\
    \ what it says on the tin. `unique` does exactly what it says on the tin. `unique`\
    \ does exactly what it says on the tin. `unique` does exactly what it says on\
    \ the tin. `unique` does exactly what it says on the tin. `unique` does exactly\
    \ what it says on the tin. `unique` does exactly what it says on the tin. `unique`\
    \ does exactly what it says on the tin. `unique` does exactly what it says on\
    \ the tin. `unique` does exactly what it says on the tin. `unique` does exactly\
    \ what it says on the tin. `unique` does exactly what it says on the tin. `unique`\
    \ does exactly what it says on the tin. `unique` does exactly what it says on\
    \ the tin. `unique` does exactly what it says on the tin. `unique` does exactly\
    \ what it says on the tin. `unique` does exactly what it says on the tin. `unique`\
    \ does exactly what it says on the tin. `unique` does exactly what it says on\
    \ the tin. `unique` does exactly what it says on the tin. `unique` does exactly\
    \ what it says on the tin. `unique` does exactly what it says on the tin. `unique`\
    \ does exactly what it says on the tin. `unique` does exactly what it says on\
    \ the tin. `unique` does exactly what it says on the tin. `unique` does exactly\
    \ what it says on the tin. `unique` does exactly what it says on the tin. `unique`\
    \ does exactly what it says on the tin. `unique` does exactly what it says on\
    \ the tin. `unique` does exactly what it says on the tin. `unique` does exactly\
    \ what it says on the tin. `unique` does exactly what it says on the tin. `unique`\
    \ does exactly what it says on the tin. `unique` does exactly what it says on\
    \ the tin. `unique` does exactly what it says on the tin. `unique` does exactly\
    \ what it says on the tin. `unique` does exactly what it says on the tin. `unique`\
    \ does exactly what it says on the tin. ", "\n  u <- unique(l);\n  u[order(u)];\n\
    }\n", "\n  u <- unique(l);\n  u[order(u)];\n}\n</code>\n<|/ a dscore=5 |>\n<|\
    \ c |>\n`unique` doesn't sort the list for me. `sort(unique(l))` does.\n<|/ c\
    \ |>\n<| c |>\n`unique` doesn't sort the list for me either. `sort(unique(l))`\
    \ does.\n<|/ c |>\n<| c |>\n`sort(unique(l))` does for me on R 3.2.2\n<|/ c |>\n\
    <| c |>\n`sort(unique(l))` does for me on R 3.2.2\n<|/ c |>\n<| c |>\n`sort(unique(l))`\
    \ does for me on R 3.2.2\n<|/ c |>\n<| a |>\nThe answer by is great, but I wanted\
    \ to add that you can also use dplyr::distinct() which does exactly what you're\
    \ looking for:\n<code>\nlibrary(dplyr)\ndistinct(mydata)\n</code>\n<|/ a tags=r,unique,sorting\
    \ dscore=5 |>\n<| c |>\n`distinct` doesn't sort the list for me. `sort(distinct(mydata))`\
    \ does.\n<|/ c |>\n<| c |>\n`distinct` doesn't sort the list for me either. `sort(distinct(mydata))`\
    \ does.\n<|/ c |>\n<| c |>\n`distinct` doesn't sort the list for me either. `sort(distinct(mydata))`\
    \ does.\n<|/ c |>\n<| c |>\n`distinct` doesn't sort the list for me either. `sort(distinct(mydata))`\
    \ does.\n<|/ c |>\n<| c |>\n`distinct` doesn't sort the list for me either. `sort(distinct(mydata))`\
    \ does.\n<|/ c |>\n<| a |>\nThe answer by is great, but I wanted to add that you\
    \ can also use dplyr::distinct() which does exactly what you're looking for:\n\
    <code>\nlibrary(dplyr)\ndistinct(mydata)\n</code>\n<|/ a dscore=5 tags=r,unique,sorting\
    \ |>\n<| c |>\n`distinct` doesn't sort the list for me. `sort(distinct(mydata))`\
    \ does.\n<|/ c |>\n<| c |>\n`distinct` doesn't sort the list for me either. `sort(distinct(mydata))`\
    \ does.\n<|/ c |>\n<| c |>\n`distinct` doesn't sort the list for me either", "\n\
    \  u <- unique(l);\n  u[order(u)];\n}\n</code>\n<|/ a dscore=3 |>\n<| c |>\nI\
    \ like your `unique` function.  I added a version that uses `order` instead of\
    \ `sort`.  I find it more readable.  I wonder if there is a way to get `unique`\
    \ to return an `order` vector instead of an `index` vector.  I suspect that would\
    \ be more efficient.\n<|/ c |>\n<| c |>\nI added a version that uses `order` instead\
    \ of `sort`.  I find it more readable.  I wonder if there is a way to get `unique`\
    \ to return an `order` vector instead of an `index` vector.  I suspect that would\
    \ be more efficient.\n<|/ c |>\n<| c |>\nI added a version that uses `order` instead\
    \ of `sort`.  I find it more readable.  I wonder if there is a way to get `unique`\
    \ to return an `order` vector instead of an `index` vector.  I suspect that would\
    \ be more efficient.\n<|/ c |>\n<| c |>\nI added a version that uses `order` instead\
    \ of `sort`.  I find it more readable.  I wonder if there is a way to get `unique`\
    \ to return an `order` vector instead of an `index` vector.  I suspect that would\
    \ be more efficient.\n<|/ c |>\n<| c |>\nI added a version that uses `order` instead\
    \ of `sort`.  I find it more readable.  I wonder if there is a way to get `unique`\
    \ to return an `order` vector instead of an `index` vector.  I suspect that would\
    \ be more efficient.\n<|/ c |>\n<| a tags=r,unique,sorting |>\nThe function below\
    \ will return the unique elements of a vector in sorted order:\n<code>\nunique.sorted\
    \ <- function(x) {\n  u <- unique(x);\n  u[order(u)];\n}\n</code>\n<|/ a dscore=3\
    \ |>\n<| c |>\nI like your `unique.sorted` function.  I added a version that uses\
    \ `order` instead of `sort`.  I find it more readable.  I wonder if there is a\
    \ way to get `unique` to return an `order` vector instead of an `index` vector.\
    \  I suspect that would be more efficient.\n<|/ c |>\n<| c |>\nI added a version\
    \ that uses `order` instead of `sort`.  I find it more readable.  I wonder if ",
  "\n  u <- unique(l[!duplicated(l)])\n  if(length(u) == 0) return(NULL)\n  return(u)\n\
    }\n</code>\n<|/ a tags=r,sorting |>\n<| a dscore=0 |>\n<code>", "\n  u <- unique(l);\n\
    \  u[order(u)];\n}\n", "\n  u <- unique(l[!duplicated(l)])\n  u[order(u)] \n}\n\
    </code>\n<|/ a |>\n<| c |>\nI like this solution, but I wonder if there is a way\
    \ to do this without having to import the whole `data.table` package?\n<|/ c |>\n\
    <| c |>\nI believe that `data.table` package is just a wrapper around `data.frame`\
    \ so you should be able to use it without importing it.\n<|/ c |>\n<| c |>\nI\
    \ believe that `data.table` package is just a wrapper around `data.frame` so you\
    \ should be able to use it without importing it.\n<|/ c |>\n<| c |>\nI believe\
    \ that `data.table` package is just a wrapper around `data.frame` so you should\
    \ be able to use it without importing it.\n<|/ c |>\n<| c |>\nI believe that `data.table`\
    \ package is just a wrapper around `data.frame` so you should be able to use it\
    \ without importing it.\n<|/ c |>\n<| a dscore=5 |>\nHere's a solution using data.table:\n\
    <code>\nlibrary(data.table)\ndt <- data.table(a = c(1,2,2,3,4), b = c(5,6,7,8,9))\n\
    dt[, list(min = a[which.min(b)]), by = b]", "\n  u <- unique(l);\n  u[order(u)];\n\
    }\n", "\n  u <- unique(l[!duplicated(l)])\n  if(length(u) == 0) return(NULL)\n\
    \  return(u)\n}\n", "\n  u <- unique(l[!duplicated(l)])\n  if(length(u) == 0)\
    \ return(NULL)\n  return(u)\n}\n", "\n  u <- unique(l[!duplicated(l)])\n  if(length(u)\
    \ > 0) u else NULL\n}\n", "\n  u <- unique(l)\n  u[order(u)] \n}\n", "\n  u <-\
    \ sort(unique(l))\n  u[!duplicated(u)]\n}\n", "\n  u <- unique(l);\n  u[order(u)];\n\
    }\n</code>\n<|/ a tags=r,unique,sorting |>\n<| a dscore=2 |>\n<code>\nunique.sorted\
    \ <- function(x) {\n  u <- unique(x);\n  u[order(u)];\n}\n</code>\n<|/ a tags=r,unique,sorting\
    \ |>\n<| a dscore=2 |>\n<code>\nunique.sorted <- function(x) {\n  u <- unique(x);\n\
    \  u[order(u)];\n}\n</code>\n<|/ a tags=r,unique,sorting |>\n<| a |>\n<code>\n\
    unique.sorted <- function(x) {\n  u <- unique(x);\n  u[order(u)];\n}\n</code>\n\
    <|/ a tags=r,unique,sorting dscore=2 |>\n<| a tags=r,unique,sorting |>\n<code>\n\
    unique.sorted <- function(x) {\n  u <- unique(x);\n  u[order(u)];\n}\n</code>\n\
    <|/ a dscore=2 |>\n<| a tags=r,unique,sorting |>\n<code>\nunique.sorted <- function(x)\
    \ {\n  u <- unique(x);\n  u[order(u)];\n}\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2\
    \ |>\n<code>\nunique.sorted <- function(x) {\n  u <- unique(x);\n  u[order(u)];\n\
    }\n</code>\n<|/ a tags=r,unique,sorting |>\n<| a dscore=2 |>\n<code>\nunique.sorted\
    \ <- function(x) {\n  u <- unique(x);\n  u[order(u)];\n}\n</code>\n<|/ a tags=r,unique,sorting\
    \ |>\n<| a |>\n<code>\nunique.sorted <- function(x) {\n  u <- unique(x);\n  u[order(u)];\n\
    }\n</code>\n<|/ a dscore=2 tags=r,unique,sorting |>\n<| a tags=r,unique,sorting\
    \ |>\n<code>\nunique.sorted <- function(x) {\n  u <- unique(x);\n  u[order(u)];\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| a tags=r,unique,sorting |>\n<code>\nunique.sorted\
    \ <- function(x) {\n  u <- unique(x);\n  u[order(u)];\n}\n</code>\n<|/ a dscore=2\
    \ |>\n<| a |>\n<code>\nunique.sorted <- function(x) {\n  u <- unique(x);\n  u[order(u)];\n\
    }\n</code>\n<|/", "\n  u <- unique(l[!duplicated(l)])\n  u[order(u)] \n}\n", "\n\
    \  u <- unique(l[order(l)])\n  if(length(u) > 1) u else rep(NA,length(l))\n}\n",
  "\n  u <- unique(l);\n  u[order(u)];\n}\n", "\n  u <- unique(l[!duplicated(l)])\n\
    \  if(length(u) == 0) return(NULL)\n  return(u)\n}\n", "\n  u <- unique(l); u[order(u)]\
    \ }\n", "\n  u <- unique(l[!duplicated(l)])\n  if(length(u) > 1) u else NULL\n\
    }\n", "\n  u <- unique(l)\n  u[order(u)] \n}\n", "\n  u <- unique(l[!duplicated(l)])\n\
    \  if(length(u) == 0) return(NULL)\n  return(u)\n}\n", "\n  u <- unique(l);\n\
    \  u[order(u)];\n}\n", "\n  u <- unique(l)\n  u[order(u, decreasing = TRUE)]\n\
    }\n</code>\n<|/ a dscore=5 |>\n<| c |>\nI like this solution. One thing I noticed\
    \ is that it seems to work better with character vectors than with factors. I\
    \ used `unique(c(\"a\", \"b\", \"c\", \"a\"))` instead of `unique(c(\"a\", \"\
    b\", \"c\", \"a\"), exclude = NULL)` and it worked fine.\n<|/ c |>\n<| c |>\n\
    I like this solution as well. One thing I noticed is that it seems to work better\
    \ with character vectors than with factors. I used `unique(c(\"a\", \"b\", \"\
    c\", \"a\"))` instead of `unique(c(\"a\", \"b\", \"c\", \"a\"), exclude = NULL)`\
    \ and it worked fine.\n<|/ c |>\n<| c |>\nI like this solution as well. One thing\
    \ I noticed is that it seems to work better with character vectors than with factors.\
    \ I used `unique(c(\"a\", \"b\", \"c\", \"a\"))` instead of `unique(c(\"a\", \"\
    b\", \"c\", \"a\"), exclude = NULL)` and it worked fine.\n<|/ c |>\n<| c |>\n\
    I like this solution as well. One thing I noticed is that it seems to work better\
    \ with character vectors than with factors. I used `unique(c(\"a\", \"b\", \"\
    c\", \"a\"))` instead of `unique(c(\"a\", \"b\", \"c\", \"a\"), exclude = NULL)`\
    \ and it worked fine.\n<|/ c |>\n<| c |>\nI like this solution as well. One thing\
    \ I noticed is that it seems to work better with character vectors than with factors.\
    \ I used `unique(c(\"a\", \"b\", \"c\", \"a\"))` instead of `unique(c(\"a\", \"\
    b\", \"c\", \"a\"), exclude = NULL)` and it worked fine.\n<|/ c |>\n<| a dscore=5\
    \ |>\n<code>\nunique(c(\"a\", \"b\", \"c\", \"a\"))\n</code>\n<|/ a tags=r,unique,vector\
    \ |>\n<| c |>\nThis does not provide an answer to the question. To critique or\
    \ request clarification from an author, leave a comment below their post - you\
    \ can always comment on your own posts, and once you have sufficient [reputation](http://stackoverflow.com/help/whats-reputation)\
    \ you will be able to [comment on any post](http://stackoverflow.com/help/privileges/comment).\n\
    <|/ c |>\n<| c |>\nThis does provide an answer. He asked for a function that would\
    \ remove duplicates from a vector. He didn't ask for a function that would remove\
    \ duplicates from a data frame. He asked for a function that would remove duplicates\
    \ from a ", "\n  u <- unique(l[!duplicated(l)])\n  if(length(u) == 0) return(NULL)\n\
    \  return(u)\n}\n", "\n  u <- unique(l[!duplicated(l)])\n  if(length(u) == 0)\
    \ return(NULL)\n  return(u)\n}\n", "\n  u <- unique(l);\n  u[order(u)];\n}\n",
  "\n  u <- unique(l);\n  u[order(u)];\n}\n", "\n  u <- unique(l[!duplicated(l)])\n\
    \  if(length(u) > 1) u else NULL\n}\n", "\n  u <- unique(l); u[order(u)] \n}\n\
    </code>\n<|/ a dscore=2 |>\n<| c |>\nI like your solution, but I wonder if there\
    \ is a way to avoid the for loop. Maybe using lapply?\n<|/ c |>\n<| c |>\nYes,\
    \ `lapply` would work. `lapply(l, unique)` would return a list of unique elements.\
    \ `lapply(l, sort)` would return a sorted list of unique elements. `lapply(l,\
    \ sort, decreasing = TRUE)` would return a sorted unique elements. `lapply(l,\
    \ sort, decreasing = TRUE, use.names = TRUE)` would return a sorted unique elements\
    \ with names. `lapply(l, sort, decreasing = TRUE, use.names = TRUE, sort.incomparables\
    \ = TRUE)` would return a sorted unique elements with names and incomparables.\n\
    <|/ c |>\n<| c |>\nI added a solution that uses `lapply`\n<|/ c |>\n<| a dscore=2\
    \ |>\nHere is a solution using lapply and unique:\n<code>\nunique.sorted <- function(x)\
    \ {\n  lapply(x, unique)\n}\n</code>\n<|/ a tags=r,sorting |>\n<| a dscore=2 |>\n\
    Here's a solution using dplyr and purrr packages:\n<code>\nlibrary(dplyr)\nlibrary(purrr)\n\
    \ndf <- data.frame(\n  x = c(1,2,3,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,",
  "\n  u <- unique(l[!duplicated(l)])\n  if(length(u) == 0) return(NULL)\n  return(u)\n\
    }\n", "\n  u <- sort(unique(l))\n  u[!duplicated(u)]\n}\n</code>\n<|/ a dscore=2\
    \ |>\n<| a tags=r |>\nHere's a function that will do what you want:\n<code>\n\
    unique.list <- function(x) {\n  y <- sort(unique(x))\n  y[!duplicated(y)]\n}\n\
    </code>\n<|/ a dscore=2 |>\n<| a tags=r |>\n<code>\nunique.list <- function(x)\
    \ {\n  y <- sort(unique(x))\n  y[!duplicated(y)]\n}\n</code>\n<|/ a dscore=1 |>\n\
    <| a dscore=1 |>\n<code>\nunique.list <- function(x) {\n  y <- sort(unique(x))\n\
    \  y[!duplicated(y)]\n}\n</code>\n<|/ a tags=r |>\n<| a dscore=1 |>\n<code>\n\
    unique.list <- function(x) {\n  y <- sort(unique(x))\n  y[!duplicated(y)]\n}\n\
    </code>\n<|/ a tags=r |>\n<| a tags=r |>\n<code>\nunique.list <- function(x) {\n\
    \  y <- sort(unique(x))\n  y[!duplicated(y)]\n}\n</code>\n<|/ a dscore=1 |>\n\
    <| a tags=r |>\n<code>\nunique.list <- function(x) {\n  y <- sort(unique(x))\n\
    \  y[!duplicated(y)]\n}\n</code>\n<|/ a dscore=1 |>\n<| a tags=r |>\n<code>\n\
    unique.list <- function(x) {\n  y <- sort(unique(x))\n  y[!duplicated(y)]\n}\n\
    </code>\n<|/ a dscore=1 |>\n<| a |>\n<code>\nunique.list <- function(x) {\n  y\
    \ <- sort(unique(x))\n  y[!duplicated(y)]\n}\n</code>\n<|/ a dscore=1 tags=r |>\n\
    <| a |>\n<code>\nunique.list <- function(x) {\n  y <- sort(unique(x))\n  y[!duplicated(y)]\n\
    }\n</code>\n<|/ a tags=r dscore=1 |>\n<| a tags=r |>\n<code>\nunique.list <- function(x)\
    \ {\n  y <- sort(unique(x))\n  y[!duplicated(y)]\n}\n</code>\n<|/ a dscore=1 |>\n\
    <| a |>\n<code>\nunique.list <- function(x) {\n  y <- sort(unique(x))\n  y[!duplicated(y)]\n\
    }\n</code>\n<|/ a tags=r dscore=1 |>", "\n  u <- unique(l);\n  u[order(u)];\n\
    }\n</code>\n<|/ a tags=r,list,unique |>\n<| a tags=r,list,unique |>\n<code>\n\
    unique.list <- function(x) {\n  y <- unlist(x);\n  y <- sort(y);\n  y <- y[!duplicated(y)]\n\
    \  return(y)\n}\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2 |>\n<code>\nunique.list\
    \ <- function(x) {\n  y <- unlist(x);\n  y <- sort(y);\n  y <- y[!duplicated(y)]\n\
    \  return(y)\n}\n</code>\n<|/ a tags=r,list,unique |>\n<| a tags=r,list,unique\
    \ |>\n<code>\nunique.list <- function(x) {\n  y <- unlist(x);\n  y <- sort(y);\n\
    \  y <- y[!duplicated(y)]\n  return(y)\n}\n</code>\n<|/ a dscore=2 |>\n<| a tags=r,list,unique\
    \ |>\n<code>\nunique.list <- function(x) {\n  y <- unlist(x);\n  y <- sort(y);\n\
    \  y <- y[!duplicated(y)]\n  return(y)\n}\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2\
    \ |>\n<code>\nunique.list <- function(x) {\n  y <- unlist(x);\n  y <- sort(y);\n\
    \  y <- y[!duplicated(y)]\n  return(y)\n}\n</code>\n<|/ a tags=r,list,unique |>\n\
    <| a dscore=1 |>\n<code>\nunique.list <- function(x) {\n  y <- unlist(x);\n  y\
    \ <- sort(y);\n  y <- y[!duplicated(y)]\n  return(y)\n}\n</code>\n<|/ a tags=r,list,unique\
    \ |>\n<| a tags=r,list,unique |>\n<code>\nunique.list <- function(x) {\n  y <-\
    \ unlist(x);\n  y <- sort(y);\n  y <- y[!duplicated(y)]\n  return(y)\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| a dscore=1 |>\n<code>\nunique.list <- function(x) {\n  y\
    \ <- unlist(x);\n  y <- sort(y);\n  y <- y[!duplicated(y)]\n  return(y)\n}\n</code>\n\
    <|/ a tags=r,list,unique |>\n<| a tags=r,list,unique |>\n<code>\nunique.list <-\
    \ function(x) {\n  ", "\n  u <- unique(l[!duplicated(l)])\n  if(length(u) == 0)\
    \ return(NULL)\n  return(u)\n}\n", "\n  u <- unique(l);\n  u[order(u)];\n}\n</code>\n\
    <|/ a tags=r,sorting |>\n<| a dscore=1 |>\nHere is a solution using data.table\
    \ package:\n<code>\nlibrary(data.table)\ndt <- data.table(\n  x = c(5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,",
  "\n  u <- unique(l[!duplicated(l)])\n  if(length(u) > 1) u else NULL\n}\n", "\n\
    \  u <- unique(l[!duplicated(l)])\n  if(length(u) == 0) return(NULL)\n  return(u)\n\
    }\n", "\n  u <- unique(l[!duplicated(l)])\n  if(length(u) > 1) u\n  else NULL\n\
    }\n", "\n  u <- unique(l)\n  u[order(u)] \n}\n", "\n  u <- unique(l[!duplicated(l)])\n\
    \  if(length(u) == 0) return(NULL)\n  return(u)\n}\n", "\n  u <- sort(unique(l))\n\
    \  return(u)\n}\n", "\n  u <- unique(l);\n  u[order(u)];\n}\n", "\n  u <- unique(l[order(l)])\n\
    \  if(length(u) > 1) u else NULL\n}\n", "\n  u <- unique(l[!duplicated(l)])\n\
    \  if(length(u) > 1) u else NULL\n}\n", "\n  u <- unique(l);\n  u[order(u)];\n\
    }\n", "\n  u <- unique(l);\n  u[order(u)];\n}\n", "\n  u <- unique(l[!duplicated(l)])\n\
    \  if(length(u) > 1) u else NULL\n}\n", "\n  u <- unique(l);\n  u[order(u)];\n\
    }\n", "\n  u <- unique(l[!duplicated(l)])\n  if(length(u) > 1) u\n  else NULL\n\
    }\n", "\n  u <- unique(l[!duplicated(l)])\n  if(length(u) > 0) u else NULL\n}\n",
  "\n  u <- unique(l);\n  u[order(u)];\n}\n", "\n  u <- unique(l);\n  u[order(u)];\n\
    }\n", "\n  u <- unique(l[!duplicated(l)])\n  if(length(u) > 0) u else NULL\n}\n",
  "\n  u <- unique(l[!duplicated(l)])\n  if(length(u) == 0) return(NULL)\n  return(u)\n\
    }\n", "\n  u <- unique(l[order(l)])\n  if(length(u) > 1) u else NULL\n}\n", "\n\
    \  u <- unique(l[!duplicated(l)])\n  if(length(u) > 0) u else NULL\n}\n</code>\n\
    <|/ a tags=r,unique,list |>\n<| c |>\nThis doesn't work if the list has duplicate\
    \ elements. For example, `unique(c(1,2,2,3,4))` returns `c(1,2,3,4)`.\n<|/ c |>\n\
    <| c |>\nYes, I realized that after I posted it. I edited my answer to fix it.\n\
    <|/ c |>\n<| c |>\nThis doesn't work if you have a list with NAs because `unique`\
    \ removes NAs.\n<|/ c |>\n<| c |>\nThis doesn't work if you have a list with NAs\
    \ because `unique` removes NAs.\n<|/ c |>\n<| a |>\nHere's a function that will\
    \ remove duplicate elements from a list. \n<code>\nremoveDups <- function(x) {\n\
    \  x <- unique(x)\n  if(length(x) > 0) x else NULL\n}\n</code>\n<|/ a tags=r,unique,list\
    \ dscore=5 |>\n<| c |>\nThis doesn't work if the list has duplicate elements.\
    \ For example, `removeDups(c(1,2,2,3,4))` returns `c(1,2,3,4)`.\n<|/ c |>\n<|\
    \ c |>\nThis doesn't work if you have a list with NAs because `unique` removes\
    \ NAs.\n<|/ c |>\n<| c |>\nThis doesn't work if you have a list with NAs because\
    \ `unique` removes NAs.\n<|/ c |>\n<| a tags=r,unique,list |>\nHere's a function\
    \ that will remove duplicate elements from a list. \n<code>\nremoveDups <- function(x)\
    \ {\n  x <- unique(x)\n  if(length(x) > 0) x else NULL\n}\n</code>\n<|/ a dscore=5\
    \ |>\n<| c |>\nThis doesn't work if the list has duplicate elements. For example,\
    \ `removeDups(c(1,2,2,3,4))` returns `c(1,2,3,4)`.\n<|/ c |>\n<| c |>\nThis doesn't\
    \ work if you have a list with NAs because `unique` removes NAs.\n<|/ c |>\n<|\
    \ a dscore=5 |>\nHere's a function that will remove duplicate elements from a\
    \ list. \n<code>\nremoveDups <- function(x) {\n  x <- unique(x)\n  if(length(x)\
    \ > 0) x else NULL\n}\n</code>\n<|/ a tags=r,unique,list |>\n<| c |>\nThis doesn't\
    \ work if the list ", "\n  u <- unique(l[!duplicated(l)])\n  if(length(u) == 0)\
    \ return(NULL)\n  return(u)\n}\n", "\n  u <- unique(l[!duplicated(l)])\n  u[order(u)]\
    \ \n}\n", "\n  u <- unique(l);\n  u[order(u)];\n}\n", "\n  u <- unique(l); u[order(u)]\
    \ \n}\n</code>\n<|/ a dscore=3 |>\n<| c |>\nI like this solution, but I wonder\
    \ if there is a way to do this without having to write an entire function?\n<|/\
    \ c |>\n<| c |>\nI added a solution that doesn't require writing an entire function.\n\
    <|/ c |>\n<| c |>\nI added a solution that doesn't require writing an entire function.\n\
    <|/ c |>\n<| a |>\nHere is a solution using data.table:\n<code>\nlibrary(data.table)\n\
    dt <- data.table(a = c(1,2,2,3,3), b = c(4,5,6,7,8))\ndt[, list(b = unique(b)),\
    \ by = a]\n</code>\n<|/ a tags=r,unique,list dscore=3 |>\n<| a |>\nHere's a solution\
    \ using base R:\n<code>\nx <- list(c(1,2,2,3,3), c(4,5,6,7,8))\ny <- sapply(x,\
    \ function(x) unique(x))\n</code>\n<|/ a tags=r,unique,list dscore=3 |>\n<| a\
    \ |>\nHere's a solution using dplyr and purrr packages:\n<code>\nlibrary(dplyr)\n\
    library(purrr)\n\nx <- list(c(1,2,2,3,3), c(4,5,6,7,8))\n\nx %>% \n  map(unique)\
    \ %>% \n  flatten()\n", "\n  u <- unique(l);\n  u[order(u)];\n}\n", "\n  u <-\
    \ unique(l[!duplicated(l)])\n  u[order(u)] \n}\n</code>\n<|/ a tags=r,unique,sorting\
    \ |>\n<| a dscore=4 |>\nI like using dplyr::distinct() for this purpose:\n<code>\n\
    library(dplyr)\nx <- c(1,2,2,3,3,4,4,5,5,5,5,6,6,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,",
  "\n  u <- unique(l[order(l)])\n  if(length(u) == 1) u else u\n}\n</code>\n<|/ a\
    \ dscore=5 |>\n<| c |>\n`unique` doesn't seem to work if you have a list with\
    \ duplicate elements. `unique(c(1,2,2,3,4))` returns `[1] 1 2 3 4` instead of\
    \ `[1] 1 2 3`.\n<|/ c |>\n<| c |>\n`unique` works with lists with duplicate elements.\
    \ `unique(c(1,2,2,3,4))` returns `[1] 1 2 3`.\n<|/ c |>\n<| c |>\n`unique` works\
    \ with lists with duplicate elements. `unique(c(1,2,2,3,4))` returns `[1] 1 2\
    \ 3`.\n<|/ c |>\n<| c |>\n`unique` works with lists with duplicate elements. `unique(c(1,2,2,3,4))`\
    \ returns `[1] 1 2 3`.\n<|/ c |>\n<| c |>\n`unique` works with lists with duplicate\
    \ elements. `unique(c(1,2,2,3,4))` returns `[1] 1 2 3`.\n<|/ c |>\n<| a tags=r\
    \ |>\n<code>\nunique(c(1,2,2,3,4))\n[1] 1 2 3\n</code>\n<|/ a dscore=5 |>\n<|\
    \ c |>\n`unique` works with lists with duplicate elements. `unique(c(1,2,2,3,4))`\
    \ returns `[1] 1 2 3`.\n<|/ c |>\n<| c |>\n`unique` works with lists with duplicate\
    \ elements. `unique(c(1,2,2,3,4))` returns `[1] 1 2 3`.\n<|/ c |>\n<| c |>\n`unique`\
    \ works with lists with duplicate elements. `unique(c(1,2,2,3,4))` returns `[1]\
    \ 1 2 3`.\n<|/ c |>\n<| c |>\n`unique` works with lists with duplicate elements.\
    \ `unique(c(1,2,2,3,4))` returns `[1] 1 2 3`.\n<|/ c |>\n<| a dscore=5 |>\n<code>\n\
    unique(c(1,2,2,3,4))\n[1] 1 2 3\n</code>\n<|/ a tags=r |>\n<| c |>\n`unique` works\
    \ with lists with duplicate elements. `unique(c(1,2,2,3,4))` returns `[1] 1 2\
    \ 3`.\n<|/ c |>\n<| c |>\n`unique` works with lists with duplicate elements. `unique(c(1,2,2,3,4))`\
    \ returns `[1] 1 2 3`.\n", "\n  u <- unique(l[!duplicated(l)])\n  u[order(u)]\
    \ \n}\n", "\n  u <- unique(l[!duplicated(l)])\n  if(length(u) > 1) u\n  else NULL\n\
    }\n", "\n  u <- unique(l[!duplicated(l)])\n  if(length(u) > 1) u\n  else NULL\n\
    }\n", "\n  u <- unique(l);\n  u[order(u)];\n}\n", "\n  u <- unique(l[!duplicated(l)])\n\
    \  if(length(u) > 1) u else NULL\n}\n", "\n  u <- unique(l[order(l)])\n  if(length(u)\
    \ > 1) u else NULL\n}\n", "\n  u <- unique(l);\n  u[order(u)];\n}\n</code>\n<|/\
    \ a tags=r,sorting |>\n<| c |>\nThis doesn't work if you have NAs in your list.\
    \ `unique` will remove them from the list.\n<|/ c |>\n<| c |>\nYes, it does. Try\
    \ it yourself.\n<|/ c |>\n<| c |>\n`unique` removes NAs from the list. Try it\
    \ yourself.\n<|/ c |>\n<| c |>\n`unique` removes NAs from the list. Try it yourself.\n\
    <|/ c |>\n<| c |>\n`unique` removes NAs from the list. Try it yourself.\n<|/ c\
    \ |>\n<| a dscore=5 |>\n<code>\nsort(unique(unlist(mylist)))\n</code>\n<|/ a tags=r,sorting\
    \ |>\n<| c |>\nThis doesn't work if you have NAs in your list. `unique` will remove\
    \ them from the list.\n<|/ c |>\n<| c |>\n`unique` removes NAs from the list.\
    \ Try it yourself.\n<|/ c |>\n<| c |>\n`unique` removes NAs from the list. Try\
    \ it yourself.\n<|/ c |>\n<| c |>\n`unique` removes NAs from the list. Try it\
    \ yourself.\n<|/ c |>\n<| c |>\n`unique` removes NAs from the list. Try it yourself.\n\
    <|/ c |>\n<| a dscore=5 |>\n<code>\nsort(unique(unlist(mylist)))\n</code>\n<|/\
    \ a tags=r,sorting |>\n<| c |>\nThis doesn't work if you have NAs in your list.\
    \ `unique` will remove them from the list.\n<|/ c |>\n<| c |>\n`unique` removes\
    \ NAs from the list. Try it yourself.\n<|/ c |>\n<| c |>\n`unique` removes NAs\
    \ from the list. Try it yourself.\n<|/ c |>\n<| a |>\n<code>\nsort(unique(unlist(mylist)))\n\
    </code>\n<|/ a tags=r,sorting dscore=5 |>\n<| c |>\nThis doesn't work if you have\
    \ NAs in your list. `unique` will remove them from the list.\n<|/ c |>\n<| c |>\n\
    `unique` removes NAs from the list. Try it yourself.\n<|/ c |>\n<| c |>\n`unique`\
    \ removes NAs from the list. Try it yourself.\n<|/ c |>", "\n  u <- unique(l)\n\
    \  u[order(u, decreasing = TRUE)]\n}\n</code>\n<|/ a dscore=5 |>\n<| c |>\nI like\
    \ your `unique` function, but I find it to be slower than `sort(unique(l))`\n\
    <|/ c |>\n<| c |>\nI agree with you, `unique` seems to be slower than `sort`,\
    \ but `sort` seems to have a better memory usage. `unique` seems to have a better\
    \ memory usage than `sort` but `sort` seems to have a better memory usage than\
    \ `unique`\n<|/ c |>\n<| c |>\n`unique` seems to have a better memory usage than\
    \ `sort` but `sort` seems to have a better memory usage than `unique`\n<|/ c |>\n\
    <| c |>\n`unique` seems to have a better memory usage than `sort` but `sort` seems\
    \ to have a better memory usage than `unique`\n<|/ c |>\n<| c |>\n`unique` seems\
    \ to have a better memory usage than `sort` but `sort` seems to have a better\
    \ memory usage than `unique`\n<|/ c |>\n<| a tags=r,sorting |>\n<code>\nsort(unique(mylist))\n\
    </code>\n<|/ a dscore=5 |>\n<| c |>\nThis should be the accepted answer. `unique`\
    \ returns a vector and `sort` sorts it.\n<|/ c |>\n<| c |>\nThis should be the\
    \ accepted answer. `unique` returns a vector and `sort` sorts it.\n<|/ c |>\n\
    <| c |>\nThis should be the accepted answer. `unique` returns a vector and `sort`\
    \ sorts it.\n<|/ c |>\n<| c |>\nThis should be the accepted answer. `unique` returns\
    \ a vector and `sort` sorts it.\n<|/ c |>\n<| c |>\nThis should be the accepted\
    \ answer. `unique` returns a vector and `sort` sorts it.\n<|/ c |>\n<| a tags=r,sorting\
    \ |>\n<code>\nsort(unique(mylist))\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis\
    \ should be the accepted answer. `unique` returns a vector and `sort` sorts it.\n\
    <|/ c |>\n<| a tags=r,sorting |>\n<code>\nsort(unique(mylist))\n</code>\n<|/ a\
    \ dscore=5 |>\n<| c |>\nThis should be the accepted answer. `unique` returns a\
    \ vector and `sort` sorts it.\n<|/", "\n  u <- unique(l);\n  u[order(u)];\n}\n\
    </code>\n<|/ a tags=r,sorting |>\n<| a tags=r,sorting |>\n<code>", "\n  u <- unique(l);\n\
    \  u[order(u)];\n}\n", "\n  u <- unique(l[!duplicated(l)])\n  if(length(u) > 1)\
    \ u else NULL\n}\n", "\n  u <- unique(l[!duplicated(l)])\n  if(length(u) == 0)\
    \ return(NULL)\n  return(u)\n}\n", "\n  u <- unique(l);\n  u[order(u)];\n}\n</code>\n\
    <|/ a tags=r,unique,list |>\n<| c |>\nThis doesn't work if the list contains factors,\
    \ as `unique` will convert them to characters.\n<|/ c |>\n<| c |>\nThis doesn't\
    \ work if the list contains factors, as `unique` will convert them to characters.\n\
    <|/ c |>\n<| a dscore=5 |>\nThe answer by is great, but I wanted to add that you\
    \ can also use purrr::keep() with unique() to get the unique elements of a list.\
    \ \n<code>\nlibrary(purrr)\nunique(lst, keep = TRUE)\n</code>\n<|/ a tags=r,unique,list\
    \ |>\n<| c |>\nThis should be the accepted answer. `keep` was made for this purpose.\n\
    <|/ c |>\n<| a tags=r,unique,list |>\n<code>\nunique(unlist(lst))\n</code>\n<|/\
    \ a dscore=5 |>\n<| c |>\nThis doesn't work if the list contains factors, as `unique`\
    \ will convert them to characters.\n<|/ c |>\n<| c |>\nThis doesn't work if the\
    \ list contains factors, as `unique` will convert them to characters.\n<|/ c |>\n\
    <| c |>\nThis doesn't work if the list contains factors, as `unique` will convert\
    \ them to characters.\n<|/ c |>\n<| c |>\nThis doesn't work if the list contains\
    \ factors, as `unique` will convert them to characters.\n<|/ c |>\n<| a dscore=5\
    \ |>\n<code>\nunique(unlist(lst))\n</code>\n<|/ a tags=r,unique,list |>\n<| c\
    \ |>\nThis doesn't work if the list contains factors, as `unique` will convert\
    \ them to characters.\n<|/ c |>\n<| c |>\nThis doesn't work if the list contains\
    \ factors, as `unique` will convert them to characters.\n<|/ c |>\n<| c |>\nThis\
    \ doesn't work if the list contains factors, as `unique` will convert them to\
    \ characters.\n<|/ c |>\n<| c |>\nThis doesn't work if the list contains factors,\
    \ as `unique` will convert them to characters.\n<|/ c |>\n<| a tags=r,unique,list\
    \ |>\n<code>\nunique(unlist(lst))\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis doesn't\
    \ work if the list contains factors, as `unique` will convert them to characters.\n\
    <|/ c |>\n<| c |>\nThis doesn't work if the list contains factor", "\n  u <- unique(l[!duplicated(l)])\n\
    \  if(length(u) == 0) return(NULL)\n  return(u)\n}\n", "\n  u <- unique(l);\n\
    \  u[order(u)];\n}\n", "\n  u <- unique(l);\n  u[order(u)];\n}\n", "\n  u <- unique(l);\n\
    \  u[order(u)];\n}\n", "\n  u <- unique(l[!duplicated(l)])\n  if(length(u) > 1)\
    \ u else NULL\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis doesn't seem to work\
    \ when there are duplicates in the list. For example, `unique(c(1,2,2,3,4))` returns\
    \ `[1] 1 2 3 4`, while `unique(c(1,2,2,3,4,5))` returns `[1] 1 2 3 4`.\n<|/ c\
    \ |>\n<| c |>\nYes, I realized that after I posted my comment. I've updated my\
    \ answer to account for duplicates.\n<|/ c |>\n<| c |>\nThis doesn't seem to work\
    \ when there are duplicates in the list. For example, `unique(c(1,2,2,3,4))` returns\
    \ `[1] 1 2 3 4`, while `unique(c(1,2,2,3,4,5))` returns `[1] 1 2 3 4`.\n<|/ c\
    \ |>\n<| c |>\nYes, I realized that after I posted my comment. I've updated my\
    \ answer to account for duplicates.\n<|/ c |>\n<| a |>\n<code>\nunique.list <-\
    \ function(x) {\n  x <- sort(x)\n  i <- 1\n  while(i < length(x)) {\n    if(!(x[i]\
    \ == x[i-1])) {\n      x[i] <- x[i-1]\n      i <- i + 1\n    } else {\n      i\
    \ <- i + 1\n    }\n  }\n  x\n}\n</code>\n<|/ a tags=r dscore=2 |>\n<| a tags=r\
    \ |>\n<code>\nunique.list <- function(x) {\n  x <- sort(x)\n  i <- 1\n  while(i\
    \ < length(x)) {\n    if(!(x[i] == x[i-1])) {\n      x[i] <- x[i-1]\n      i <-\
    \ i + 1\n    } else {\n      i <- i + 1\n    }\n  }\n  x\n}\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nThis doesn't seem to work when there are duplicates in the list.\
    \ For example, `unique(c(1,2,2,3,4))` returns `[1] 1 2 3 4`, while `unique(c(1,2,2,3,4,5))`\
    \ returns `[1] 1 2 3 4`.\n<|/ c |>\n<| a dscore=1 |>\n<code>\nunique.list <- function(x)\
    \ {\n  x <- sort(x)\n  i <- 1\n  while(i < length(x)) {\n    if(!(x[i] == x[i-1]))\
    \ {\n      x[i] <- x[i-1]\n      i <- i + 1\n    } else {\n      i <- i + 1\n\
    \    }\n  }\n  x\n}\n</code>\n<|/ a tag", "\n  u <- unique(l[order(l)])\n  if(length(u)\
    \ == 1) return(list(u))\n  return(u)\n}\n", "\n  u <- unique(l); u[order(u)] }\n",
  "\n  u <- unique(l);\n  u[order(u)];\n}\n", "\n  u <- unique(l[!duplicated(l)])\n\
    \  if(length(u) == 0) return(NULL)\n  return(u)\n}\n", "\n  u <- unique(l[!duplicated(l)])\n\
    \  if(length(u) > 1) u else NULL\n}\n</code>\n<|/ a dscore=5 |>\n<| c |>\nI like\
    \ this solution, but I wonder if there is a way to make it more efficient? For\
    \ instance, `unique` has to sort all the elements in the list before it can remove\
    \ duplicates. Is there a way to avoid that?\n<|/ c |>\n<| c |>\nI guess you could\
    \ use something like `unique.default` from base R to avoid the sorting, but I\
    \ doubt that would be any faster. `unique` does a lot of things, including sorting\
    \ the input vector, so it would be hard to beat `unique.default` here.\n<|/ c\
    \ |>\n<| c |>\nI guess you could also use `unique.default` from base R to avoid\
    \ the sorting, but I doubt that would be any faster. `unique` does a lot of things,\
    \ including sorting the input vector, so it would be hard to beat `unique.default`\
    \ here.\n<|/ c |>\n<| c |>\n`unique` does a lot of things, including sorting the\
    \ input vector, so it would be hard to beat `unique.default` here.\n<|/ c |>\n\
    <| c |>\n`unique` does a lot of things, including sorting the input vector, so\
    \ it would be hard to beat `unique.default` here.\n<|/ c |>\n<| a dscore=5 |>\n\
    The data.table package has some nice functions for dealing with sets. \n<code>\n\
    library(data.table)\ndt <- data.table(a = c(1,2,2,3,4), b = c(1,2,3,4,5))\ndt[!duplicated(dt$a),\
    \ ]\n</code>\n<|/ a tags=r,unique,duplicates |>\n<| c |>\n`dt[!duplicated(dt$a),\
    \ ]` will remove all rows with duplicated `a` values, not just the first one.\
    \ `dt[!duplicated(dt$a), 1:2]` will remove the first two rows with duplicated\
    \ `a` values.\n<|/ c |>\n<| c |>\n`dt[!duplicated(dt$a), ]` will remove all rows\
    \ with duplicated `a` values, not just the first one. `dt[!duplicated(dt$a), 1:2]`\
    \ will remove the first two rows with duplicated `a` values.\n<|/ c |>\n<| c |>\n\
    `dt[!duplicated(dt$a), ]` will remove all rows with duplicated `a` values, not\
    \ just the first one", "\n  u <- unique(l);\n  u[order(u)];\n}\n", "\n  u <- unique(l);\n\
    \  u[order(u)];\n}\n</code>\n<|/ a tags=r,sorting |>\n<| c |>\nThis doesn't seem\
    \ to work if there are repeated elements in the list.\n<|/ c |>\n<| c |>\nIt does\
    \ work if there are repeated elements in the list. Try `unique(c(1,1,2,3,3))`.\n\
    <|/ c |>\n<| c |>\nYes, it does. I tested it before posting my comment. Thanks\
    \ for your comment.\n<|/ c |>\n<| c |>\nThis doesn't seem to work if there are\
    \ repeated elements in the list. Try `unique(c(1,1,2,3,3))`\n<|/ c |>\n<| c |>\n\
    It does work. Try `unique(c(1,1,2,3,3))`.\n<|/ c |>\n<| a dscore=5 |>\n<code>\n\
    sort(unique(unlist(mylist)))\n</code>\n<|/ a tags=r,sorting |>\n<| c |>\nThis\
    \ doesn't seem to work if there are repeated elements in the list.\n<|/ c |>\n\
    <| c |>\nIt does work. Try `unique(c(1,1,2,3,3))`.\n<|/ c |>\n<| c |>\nThis doesn't\
    \ seem to work if there are repeated elements in the list. Try `unique(c(1,1,2,3,3))`\n\
    <|/ c |>\n<| c |>\nIt does work. Try `unique(c(1,1,2,3,3))`.\n<|/ c |>\n<| c |>\n\
    This doesn't seem to work if there are repeated elements in the list. Try `unique(c(1,1,2,3,3))`\n\
    <|/ c |>\n<| a tags=r,sorting |>\n<code>\nsort(unique(unlist(mylist)))\n</code>\n\
    <|/ a dscore=5 |>\n<| c |>\nThis doesn't seem to work if there are repeated elements\
    \ in the list.\n<|/ c |>\n<| c |>\nIt does work. Try `unique(c(1,1,2,3,3))`.\n\
    <|/ c |>\n<| c |>\nThis doesn't seem to work if there are repeated elements in\
    \ the list. Try `unique(c(1,1,2,3,3))`\n<|/ c |>\n<| c |>\nIt does work. Try `unique(c(1,1,2,3,3))`.\n\
    <|/ c |>\n<| c |>\nThis doesn't seem to work if there are repeated elements in\
    \ the list. Try `unique(c(1,1,2,3,3))`\n<|/ c |>\n<| a dscore=5 |>\n<code>\nsort(unique(unlist(mylist)))\n\
    </code>", "\n  u <- unique(l[!duplicated(l)])\n  u[order(u)] \n}\n</code>\n<|/\
    \ a dscore=5 |>\n<| c |>\nThis should be the accepted answer. `unique` does exactly\
    \ what it says on the tin.\n<|/ c |>\n<| c |>\nThis should be the accepted answer.\
    \ `unique` does exactly what it says on the tin.\n<|/ c |>\n<| c |>\nThis should\
    \ be the accepted answer. `unique` does exactly what it says on the tin.\n<|/\
    \ c |>\n<| c |>\nThis should be the accepted answer. `unique` does exactly what\
    \ it says on the tin.\n<|/ c |>\n<| c |>\nThis should be the accepted answer.\
    \ `unique` does exactly what it says on the tin.\n<|/ c |>\n<| a dscore=5 |>\n\
    <code>\nunique(c(1,2,2,3,3,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,",
  "\n  u <- unique(l)\n  u[order(u)] \n}\n", "\n  u <- unique(l[!duplicated(l)])\n\
    \  if(length(u) > 1) u\n  else NULL\n}\n", "\n  u <- unique(l[!duplicated(l)])\n\
    \  if(length(u) == 0) return(NULL)\n  return(u)\n}\n", "\n  u <- unique(l[!duplicated(l)])\n\
    \  if(length(u) == 0) return(NULL)\n  return(u)\n}\n</code>\n<|/ a tags=r,unique,list\
    \ |>\n<| c |>\nThis doesn't work for me. `unique` returns a vector with duplicate\
    \ values removed. `unique.default` returns a vector with duplicate values removed.\
    \ `unique.POSIXct` returns a vector with duplicate values removed. `unique.Date`\
    \ returns a vector with duplicate values removed. `unique.POSIXlt` returns a vector\
    \ with duplicate values removed. `unique.Date` returns a vector with duplicate\
    \ values removed. `unique.POSIXlt` returns a vector with duplicate values removed.\
    \ `unique.Date` returns a vector with duplicate values removed. `unique.Date`\
    \ returns a vector with duplicate values removed. `unique.Date` returns a vector\
    \ with duplicate values removed. `unique.Date` returns a vector with duplicate\
    \ values removed. `unique.Date` returns a vector with duplicate values removed.\
    \ `unique.Date` returns a vector with duplicate values removed. `unique.Date`\
    \ returns a vector with duplicate values removed. `unique.Date` returns a vector\
    \ with duplicate values removed. `unique.Date` returns a vector with duplicate\
    \ values removed. `unique.Date` returns a vector with duplicate values removed.\
    \ `unique.Date` returns a vector with duplicate values removed. `unique.Date`\
    \ returns a vector with duplicate values removed. `unique.Date` returns a vector\
    \ with duplicate values removed. `unique.Date` returns a vector with duplicate\
    \ values removed. `unique.Date` returns a vector with duplicate values removed.\
    \ `unique.Date` returns a vector with duplicate values removed. `unique.Date`\
    \ returns a vector with duplicate values removed. `unique.Date` returns a vector\
    \ with duplicate values removed. `unique.Date` returns a vector with duplicate\
    \ values removed. `unique.Date` returns a vector with duplicate values removed.\
    \ `unique.Date` returns a vector with duplicate values removed. `unique.Date`\
    \ returns a vector with duplicate values removed. `unique.Date` returns a vector\
    \ with duplicate values removed. `unique.Date` returns a vector with duplicate\
    \ values removed. `unique.Date` returns a vector with duplicate values removed.\
    \ `unique.Date` returns a vector with duplicate values removed. `unique.Date`\
    \ returns a vector with duplicate values removed. `unique.Date` returns a vector\
    \ with duplicate values removed. `unique.Date` returns a vector with duplicate\
    \ values removed. `unique.Date` returns a vector with duplicate values removed.\
    \ `unique.Date` returns a vector with duplicate values removed. ", "\n  u <- unique(l);\n\
    \  u[order(u)];\n}\n", "\n  u <- unique(l[!duplicated(l)])\n  if(length(u) > 1)\
    \ u else NULL\n}\n", "\n  u <- unique(l);\n  u[order(u)];\n}\n", "\n  u <- unique(l)\n\
    \  u[order(u)] \n}\n</code>\n<|/ a tags=r |>\n<| c |>\n`unique` already sorts\
    \ the input, so `unique.sort` doesn't do anything useful.\n<|/ c |>\n<| c |>\n\
    Thanks, I didn't know that. I've edited my answer to reflect this.\n<|/ c |>\n\
    <| c |>\n`unique.sort` does something useful, though. `unique.sort(c(1,2,2,3,4))`\
    \ returns `c(1,2,3,4)`, but `unique.sort(c(1,2,2,3,4))` returns `c(1,2,3)`.\n\
    <|/ c |>\n<| c |>\nThanks, I didn't know that. I've edited my answer to reflect\
    \ this.\n<|/ c |>\n<| c |>\n`unique.sort` does something useful, though. `unique.sort(c(1,2,2,3,4))`\
    \ returns `c(1,2,3,4)`, but `unique.sort(c(1,2,2,3,4))` returns `c(1,2,3)`.\n\
    <|/ c |>\n<| a tags=r |>\nHere's a solution using data.table:\n<code>\nlibrary(data.table)\n\
    dt <- data.table(a = c(1,2,2,3,4), b = c(2,3,4,5,6))\ndt[, unique.a := unique(a),\
    \ by = b]\ndt", "\n  u <- unique(l); u[order(u)] \n}\n</code>\n<|/ a tags=r |>\n\
    <| a dscore=2 |>\nI like using data.table's rleid function for this sort of thing:\n\
    <code>\n> dt <- data.table(x=c(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,",
  "\n  u <- sort(unique(l))\n  u[!duplicated(u)]\n}\n", "\n  u <- unique(l[order(l)])\n\
    \  u[!duplicated(u)]\n}\n</code>\n<|/ a |>\n<| c |>\nThis doesn't seem to work\
    \ if you have a list with duplicates. For example, unique(c(1,1,2,3,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,",
  "\n  u <- unique(l);\n  u[order(u)];\n}\n", "\n  u <- unique(l);\n  u[order(u)];\n\
    }\n", "\n  u <- unique(l);\n  u[order(u)];\n}\n", "\n  u <- unique(l); u[order(u)]\
    \ }\n", "\n  u <- unique(l)\n  u[order(u)] \n}\n", "\n  u <- unique(l)\n  u[order(u)]\
    \ \n}\n", "\n  u <- unique(l[!duplicated(l)])\n  if(length(u) == 0) return(NULL)\n\
    \  return(u)\n}\n", "\n  u <- unique(l[!duplicated(l)])\n  if(length(u) > 0) u\
    \ else NULL\n}\n", "\n  u <- unique(l);\n  u[order(u)];\n}\n", "\n  u <- unique(l[!duplicated(l)])\n\
    \  if(length(u) > 1) u\n  else NULL\n}\n", "\n  u <- unique(l);\n  u[order(u)];\n\
    }\n", "\n  u <- unique(l); u[order(u)] \n}\n</code>\n<|/ a tags=r,sorting |>\n\
    <| a dscore=3 |>\nHere's a solution using data.table:\n<code>\nlibrary(data.table)\n\
    dt <- data.table(\n  x = c(5, 3, 5, 2, 3, 3, 9, 0, 123)\n)\ndt[, y := .I]\ndt[order(x),\
    \ y := y]\ndt[, y := y[!duplicated(y)]]\n</code>\n<|/ a tags=r,sorting |>\n<|\
    \ a tags=r,sorting |>\nHere's a solution using base R:\n<code>\nx <- c(5, 3, 5,\
    \ 2, 3, 3, 9, 0, 123)\ny <- order(x)\nx[y]", "\n  u <- unique(l); u[order(u)];\n\
    }\n</code>\n<|/ a dscore=5 tags=r,sorting |>\n<| c |>\nI like this solution, but\
    \ I wonder if there is a way to do this without having to define `unique`?\n<|/\
    \ c |>\n<| c |>\nI like it too, but I wonder if there is a way to do this without\
    \ having to define `unique`?\n<|/ c |>\n<| c |>\n`unique` comes from base R, so\
    \ you should be able to just use `unique` instead of `unique.default`.\n<|/ c\
    \ |>\n<| c |>\n`unique` comes from base R, so you should be able to just use `unique`\
    \ instead of `unique.default`.\n<|/ c |>\n<| c |>\nI like it too, but I wonder\
    \ if there is a way to do this without having to define `unique`?\n<|/ c |>\n\
    <| a dscore=5 |>\n<code>\nsort(unique(sort(x)))\n</code>\n<|/ a tags=r,sorting\
    \ |>\n<| c |>\nI like this solution, but I wonder if there is a way to do this\
    \ without having to define `sort`?\n<|/ c |>\n<| c |>\n`sort` is from `base` package,\
    \ so you should be able to just use `sort` instead of `sort.default`.\n<|/ c |>\n\
    <| c |>\n`sort` comes from base R, so you should be able to just use `sort` instead\
    \ of `sort.default`.\n<|/ c |>\n<| c |>\nI like it too, but I wonder if there\
    \ is a way to do this without having to define `sort`?\n<|/ c |>\n<| c |>\n`sort`\
    \ comes from base R, so you should be able to just use `sort` instead of `sort.default`.\n\
    <|/ c |>\n<| a tags=r,sorting |>\n<code>\nsort(unique(x))\n</code>\n<|/ a dscore=5\
    \ |>\n<| c |>\nI like this solution, but I wonder if there is a way to do this\
    \ without having to define `sort`?\n<|/ c |>\n<| c |>\n`sort` comes from base\
    \ R, so you should be able to just use `sort` instead of `sort.default`.\n<|/\
    \ c |>\n<| c |>\n`sort` comes from base R, so you should be able to just use `sort`\
    \ instead of `sort.default`.\n<|/ c |>\n<| c |>\n`sort` comes from base R, so\
    \ you should be able to just use `sort` instead of `sort.default", "\n  u <- unique(l[!duplicated(l)])\n\
    \  if(length(u) > 1) u else NULL\n}\n</code>\n<|/ a |>\n<| a tags=r |>\n<code>\n\
    unique.values <- function(x) {\n  u <- unique(x)\n  if(length(u) > 1) u else NULL\n\
    }\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis should be the accepted answer. No\
    \ need to reinvent the wheel.\n<|/ c |>\n<| c |>\nThis should be the accepted\
    \ answer. No need to reinvent the wheel.\n<|/ c |>\n<| a dscore=5 |>\n<code>\n\
    unique.values <- function(x) {\n  u <- unique(x)\n  if(length(u) > 1) u else NULL\n\
    }\n</code>\n<|/ a tags=r |>\n<| a dscore=5 |>\n<code>\nunique.values <- function(x)\
    \ {\n  u <- unique(x)\n  if(length(u) > 1) u else NULL\n}\n</code>\n<|/ a tags=r\
    \ |>\n<| a dscore=4 |>\n<code>\nunique.values <- function(x) {\n  u <- unique(x)\n\
    \  if(length(u) > 1) u else NULL\n}\n</code>\n<|/ a tags=r |>\n<| a dscore=4 |>\n\
    <code>\nunique.values <- function(x) {\n  u <- unique(x)\n  if(length(u) > 1)\
    \ u else NULL\n}\n</code>\n<|/ a tags=r |>\n<| a dscore=4 |>\n<code>\nunique.values\
    \ <- function(x) {\n  u <- unique(x)\n  if(length(u) > 1) u else NULL\n}\n</code>\n\
    <|/ a tags=r |>\n<| a tags=r |>\n<code>\nunique.values <- function(x) {\n  u <-\
    \ unique(x)\n  if(length(u) > 1) u else NULL\n}\n</code>\n<|/ a dscore=4 |>\n\
    <| a tags=r |>\n<code>\nunique.values <- function(x) {\n  u <- unique(x)\n  if(length(u)\
    \ > 1) u else NULL\n}\n</code>\n<|/ a dscore=4 |>\n<| a |>\n<code>\nunique.values\
    \ <- function(x) {\n  u <- unique(x)\n  if(length(u) > 1) u else NULL\n}\n</code>\n\
    <|/ a tags=r dscore=4 |>\n<| a dscore=4 |>\n<code>\nunique.values <- function(x)\
    \ {\n  u <- unique(x)", "\n  u <- unique(l);\n  u[order(u)];\n}\n", "\n  u <-\
    \ unique(l);\n  u[order(u)];\n}\n", "\n  u <- unique(l);\n  u[order(u)];\n}\n\
    </code>\n<|/ a dscore=5 |>\n<| c |>\nI like this solution, but I wonder if there\
    \ is a way to make it more efficient? I imagine it would be O(n^2) in the worst\
    \ case, but I wonder if there is a way to make it O(n).\n<|/ c |>\n<| c |>\nThis\
    \ solution is O(n) in the worst case. `unique` sorts the list first, so it only\
    \ needs to go through the list once.\n<|/ c |>\n<| c |>\nI agree with you, but\
    \ I wonder if there is a way to make it O(n) in the worst case. Maybe some clever\
    \ use of R's `sort` function?\n<|/ c |>\n<| c |>\nI guess you could do something\
    \ like `unique(c(sort(l), l))`, but that would be O(n^2).\n<|/ c |>\n<| c |>\n\
    I guess you could do something like `unique(c(sort(l), l))`, but that would be\
    \ O(n^2).\n<|/ c |>\n<| a |>\nThe solution by is very elegant, but unfortunately\
    \ it has a O(n^2) time complexity. \nHere is a O(n) solution that uses R's sort\
    \ function and uses R's unique function:\n<code>\nunique <- function(l) {\n  u\
    \ <- unique(l);\n  u[order(u)];\n}\n</code>\n<|/ a tags=r,sorting,unique dscore=5\
    \ |>\n<| c |>\nI like this solution, but I wonder if there is a way to make it\
    \ more efficient? I imagine it would be O(n^2) in the worst case, but I wonder\
    \ if there is a way to make it O(n).\n<|/ c |>\n<| c |>\nI guess you could do\
    \ something like `unique(c(sort(l), l))`, but that would be O(n^2).\n<|/ c |>\n\
    <| c |>\nI guess you could do something like `unique(c(sort(l), l))`, but that\
    \ would be O(n^2).\n<|/ c |>\n<| c |>\nI guess you could do something like `unique(c(sort(l),\
    \ l))`, but that would be O(n^2).\n<|/ c |>\n<| c |>\nI guess you could do something\
    \ like `unique(c(sort(l), l))`, but that would be O(n^2).\n<|/ c |>\n<| a |>\n\
    Here's a solution using data.table:\n<code>\nlibrary(data.table)\nunique(", "\n\
    \  u <- unique(l)\n  u[order(u, decreasing = TRUE)]\n}\n", "\n  u <- unique(l);\n\
    \  u[order(u)];\n}\n", "\n  u <- unique(l); u[order(u)] \n}\n", "\n  u <- unique(l)\n\
    \  u[order(u)] \n}\n</code>\n<|/ a tags=r,sorting |>\n<| c |>\n`unique` doesn't\
    \ sort the list it just removes duplicates. So this doesn't really answer the\
    \ question. Also `order` doesn't work on a list so this doesn't really answer\
    \ the question either.\n<|/ c |>\n<| c |>\nI agree with you. `order` doesn't work\
    \ on a list. `order` works on vectors. I edited my answer accordingly.\n<|/ c\
    \ |>\n<| a |>\nHere's a solution using dplyr and purrr:\n<code>\nlibrary(dplyr)\n\
    library(purrr)\n\ndf %>% \n  mutate(id = row_number()) %>% \n  split(.$id) %>%\
    \ \n  map(~sort(unique(.x$value)))\n\n$`1`\n[1] 1 2 3 4 5\n\n$`2`\n[1] 1 2 3 4\
    \ 5\n\n$`3`\n[1] 1 2 3 4 5\n\n$`4`\n[1] 1 2 3 4 5\n\n$`5`\n[1] 1 2 3 4 5\n</code>\n\
    <|/ a tags=r,sorting dscore=2 |>\n<| a dscore=2 |>\nHere's a solution using data.table\
    \ and dplyr:\n<code>\nlibrary(data.table)\nlibrary(dplyr)\n\ndf <- data.frame(\n\
    \  id = c(1,2,3,4,5),\n  value = c(1,2,3,4,5)\n)\n\ndf %>% \n  mutate(id = row_number())\
    \ %>% \n  split(.$id) %>% \n  map(~sort(unique(.x$value)))\n\n$`1`\n[1] 1 2 3\
    \ 4 5\n\n$`2`\n[1] 1 2 3 4 5\n\n$`3`\n[1] 1 2 3 4 5\n\n$`4`\n[1] 1 2 3 4 5\n\n\
    $`5`\n[1] 1 2 3 4 5\n</code>\n<|/ a tags=r,sorting |>\n<| a tags=r,sorting |>\n\
    Here's a solution using base R:\n<code>\ndf <- data.frame(\n  id = c(1,2,3,4,5),\n\
    \  value = c(1,2,3,4,5)\n)\n\ndf$id <- as.numeric(factor(df$id))\ndf$value <-\
    \ as.numeric(factor(df$value))\n\ndf$value <- ave(df$value, df$id, FUN=function(x)\
    \ sort(unique(x)))\n</code>\n<|/ a dscore=2 |>\n<| a dscore=1 |>\nHere's a solution ",
  "\n  u <- unique(l);\n  u[order(u)];\n}\n", "\n  u <- unique(l);\n  u[order(u)];\n\
    }\n", "\n  u <- unique(l)\n  u[order(u)] \n}\n</code>\n<|/ a tags=r,list,unique\
    \ |>\n<| c |>\nI like this solution, although it does require a little more memory\
    \ than my solution. Thanks!\n<|/ c |>\n<| c |>\nThis solution also requires more\
    \ memory than the solution I proposed (which uses `unique` twice).\n<|/ c |>\n\
    <| c |>\nI agree with you. My solution was more of a proof of concept and I didn't\
    \ want to add any additional complexity to the solution. Your solution does require\
    \ more memory than my solution though.\n<|/ c |>\n<| a tags=r,list,unique |>\n\
    <code>\nunique.list <- function(x) {\n  u <- unique(x)\n  u[order(u)] \n}\n</code>\n\
    <|/ a dscore=5 |>\n<| c |>\nThis solution also requires more memory than the solution\
    \ I proposed (which uses `unique` twice).\n<|/ c |>\n<| c |>\nI agree with you.\
    \ My solution was more of a proof of concept and I didn't want to add any additional\
    \ complexity to the solution. Your solution does require more memory than my solution\
    \ though.\n<|/ c |>\n<| c |>\nThis solution does not require more memory than\
    \ my solution. `unique` returns a vector and `order` returns a vector as well.\
    \ `order` returns a vector and `unique` returns a vector as well. `order` returns\
    \ a vector and `unique` returns a vector as well. `order` returns a vector and\
    \ `unique` returns a vector as well. `order` returns a vector and `unique` returns\
    \ a vector as well. `order` returns a vector and `unique` returns a vector as\
    \ well. `order` returns a vector and `unique` returns a vector as well. `order`\
    \ returns a vector and `unique` returns a vector as well. `order` returns a vector\
    \ and `unique` returns a vector as well. `order` returns a vector and `unique`\
    \ returns a vector as well. `order` returns a vector and `unique` returns a vector\
    \ as well. `order` returns a vector and `unique` returns a vector as well. `order`\
    \ returns a vector and `unique` returns a vector as well. `order` returns a vector\
    \ and `unique` returns a vector as well. `order` returns a vector and `unique`\
    \ returns a vector as well. `order` returns a vector and `unique` returns a vector\
    \ as well. `order` returns a vector and `unique` returns a vector as well. `order`\
    \ returns a vector and `unique` returns a vector as well. ", "\n  u <- unique(l)\n\
    \  u[order(u, decreasing = TRUE)]\n}\n</code>\n<|/ a tags=r,unique,sorting |>\n\
    <| a dscore=0 |>\nA simple solution using dplyr and tidyr\n<code>\nlibrary(dplyr)\n\
    library(tidyr)\n\ndf %>%\n  group_by(id) %>%\n  mutate(rank = dense_rank(desc(score)))\
    \ %>%\n  filter(rank == 1) %>%\n  select(-rank)\n</code>\n<|/ a tags=r,unique,sorting\
    \ |>\n<| a dscore=0 |>\n<code>\nlibrary(dplyr)\nlibrary(tidyr)\ndf %>% \n  group_by(id)\
    \ %>% \n  mutate(rank = dense_rank(desc(score))) %>% \n  filter(rank == 1) %>%\
    \ \n  select(-rank)\n</code>\n<|/ a tags=r,unique,sorting |>\n<| a dscore=0 |>\n\
    <code>\nlibrary(dplyr)\nlibrary(tidyr)\ndf %>% \n  group_by(id) %>% \n  mutate(rank\
    \ = dense_rank(desc(score))) %>% \n  filter(rank == 1) %>% \n  select(-rank)\n\
    </code>\n<|/ a tags=r,unique,sorting |>\n<| a dscore=0 |>\n<code>\nlibrary(dplyr)\n\
    library(tidyr)\ndf %>% \n  group_by(id) %>% \n  mutate(rank = dense_rank(desc(score)))\
    \ %>% \n  filter(rank == 1) %>% \n  select(-rank)\n</code>\n<|/ a tags=r,unique,sorting\
    \ |>\n<| a tags=r,unique,sorting |>\n<code>\nlibrary(dplyr)\nlibrary(tidyr)\n\
    df %>% \n  group_by(id) %>% \n  mutate(rank = dense_rank(desc(score))) %>% \n\
    \  filter(rank == 1) %>% \n  select(-rank)\n</code>\n<|/ a dscore=0 |>\n<| a tags=r,unique,sorting\
    \ |>\n<code>\nlibrary(dplyr)\nlibrary(tidyr)\n\ndf %>% \n  group_by(id) %>% \n\
    \  mutate(rank = dense_rank(desc(score))) %>% \n  filter(rank == 1) %>% \n  select(-rank)\n\
    </code>\n<|/ a dscore=0 |>\n<| a tags=r,unique,sorting |>\n<code>\nlibrary(dplyr)\n\
    library(tidyr)\ndf ", "\n  u <- unique(l);\n  u[order(u)];\n}\n</code>\n<|/ a\
    \ dscore=5 |>\n<| c |>\nI like this solution, since it keeps the original order\
    \ of the elements. But I wonder if there is a way to do this without sorting the\
    \ list first?\n<|/ c |>\n<| c |>\nI believe that `unique` will sort the list for\
    \ you, so you shouldn't need to sort it yourself. `unique` will return the unique\
    \ elements in a list in the same order as the original list.\n<|/ c |>\n<| c |>\n\
    `unique` will sort the list for you, so you shouldn't need to sort it yourself.\
    \ `unique` will return the unique elements in a list in the same order as the\
    \ original list.\n<|/ c |>\n<| c |>\nThis solution is very elegant, but unfortunately\
    \ it requires `data.table` which is not available on all platforms.\n<|/ c |>\n\
    <| c |>\n`unique` will sort the list for you, so you shouldn't need to sort it\
    \ yourself. `unique` will return the unique elements in a list in the same order\
    \ as the original list.\n<|/ c |>\n<| a tags=r,sorting |>\nThe function below\
    \ will return the unique elements in a list in the same order as the original\
    \ list. \n<code>\nunique.list <- function(x) {\n  u <- unique(x);\n  u[order(u)];\n\
    }\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis solution works well for me on R 3.2.1\
    \ on Windows 7. Thanks!\n<|/ c |>\n<| c |>\nThis solution works well for me on\
    \ R 3.2.1 on Windows 7. Thanks!\n<|/ c |>\n<| c |>\nThis solution works well for\
    \ me on R 3.2.1 on Windows 7. Thanks!\n<|/ c |>\n<| c |>\nThis solution works\
    \ well for me on R 3.2.1 on Windows 7. Thanks!\n<|/ c |>\n<| c |>\nThis solution\
    \ works well for me on R 3.2.1 on Windows 7. Thanks!\n<|/ c |>\n<| a tags=r,sorting\
    \ |>\nThe function below will return the unique elements in a list in the same\
    \ order as the original list. \n<code>\nunique.list <- function(x) {\n  u <- unique(x);\n\
    \  u[order(u)];\n}\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis solution works well\
    \ for me on R 3.2.1 on Windows 7. Thank", "\n  u <- unique(l[!duplicated(l)])\n\
    \  u[order(u)] \n}\n</code>\n<|/ a tags=r,sorting |>\n<| c |>\nThis doesn't seem\
    \ to work if you have duplicate numbers in the list. For example, unique(c(1,2,2,3,4))\
    \ returns c(1,2,3) instead of c(1,2,2,3,4)\n<|/ c |>\n<| c |>\nYes, it does. Try\
    \ `unique(c(1,2,2,3,4))`\n<|/ c |>\n<| c |>\nYes, it does. Try `unique(c(1,2,2,3,4))`\n\
    <|/ c |>\n<| c |>\nYes, it does. Try `unique(c(1,2,2,3,4))`\n<|/ c |>\n<| c |>\n\
    Yes, it does. Try `unique(c(1,2,2,3,4))`\n<|/ c |>\n<| a dscore=5 |>\n<code>\n\
    sort(unique(unlist(mylist)))\n</code>\n<|/ a tags=r,sorting |>\n<| c |>\nThis\
    \ doesn't seem to work if you have duplicate numbers in the list. For example,\
    \ `sort(unique(unlist(c(1,2,2,3,4)))) returns c(1,2,3) instead of c(1,2,2,3,4)`\n\
    <|/ c |>\n<| c |>\nThis doesn't seem to work if you have duplicate numbers in\
    \ the list. For example, `sort(unique(unlist(c(1,2,2,3,4)))) returns c(1,2,3)\
    \ instead of c(1,2,2,3,4)`\n<|/ c |>\n<| c |>\nThis doesn't seem to work if you\
    \ have duplicate numbers in the list. For example, `sort(unique(unlist(c(1,2,2,3,4))))\
    \ returns c(1,2,3) instead of c(1,2,2,3,4)`\n<|/ c |>\n<| c |>\nThis doesn't seem\
    \ to work if you have duplicate numbers in the list. For example, `sort(unique(unlist(c(1,2,2,3,4))))\
    \ returns c(1,2,3) instead of c(1,2,2,3,4)`\n<|/ c |>\n<| c |>\nThis doesn't seem\
    \ to work if you have duplicate numbers in the list. For example, `sort(unique(unlist(c(1,2,2,3,4))))\
    \ returns c(1,2,3) instead of c(1,2,2,3,4)`\n<|/ c |>\n<| a tags=r,sorting |>\n\
    <code>\nsort(unique(unlist(mylist)))\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis\
    \ doesn't seem to work if you have duplicate numbers in the list. For example,\
    \ `sort(unique(unlist(c(1,2,2,3,4)))) returns c(1,2,3) instead of c(1,2,2,3,",
  "\n  u <- unique(l);\n  u[order(u)];\n}\n", "\n  u <- unique(l[!duplicated(l)])\n\
    \  if(length(u) > 1) u else NULL\n}\n</code>\n<|/ a tags=r,sorting |>\n<| a dscore=0\
    \ |>\n<code>", "\n  u <- unique(l[!duplicated(l)])\n  if(length(u) == 0) return(NULL)\n\
    \  return(u)\n}\n", "\n  u <- unique(l);\n  u[order(u)];\n}\n", "\n  u <- unique(l);\n\
    \  u[order(u)];\n}\n", "\n  u <- unique(l);\n  u[order(u)];\n}\n", "\n  u <- unique(l);\
    \ u[order(u)] \n}\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis should be the accepted\
    \ answer. `unique` does exactly what it says on the tin.\n<|/ c |>\n<| c |>\n\
    `unique` doesn't do what it says on the tin. `unique` removes duplicates, not\
    \ sorts them.\n<|/ c |>\n<| c |>\n`unique` does exactly what it says on the tin.\
    \ `unique` removes duplicates, not sorts them.\n<|/ c |>\n<| c |>\n`unique` does\
    \ exactly what it says on the tin. `unique` removes duplicates, not sorts them.\n\
    <|/ c |>\n<| c |>\n`unique` does exactly what it says on the tin. `unique` removes\
    \ duplicates, not sorts them.\n<|/ c |>\n<| a dscore=5 |>\nThe R base function\
    \ sort is very useful for this kind of task:\n<code>\n> sort(c(5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,",
  "\n  u <- unique(l);\n  u[order(u)];\n}\n", "\n  u <- unique(l);\n  u[order(u)];\n\
    }\n", "\n  u <- unique(l[!duplicated(l)])\n  if(length(u) > 1) u\n  else NULL\n\
    }\n", "\n  u <- unique(l[!duplicated(l)])\n  if(length(u) > 1) u else NULL\n}\n",
  "\n  u <- unique(l);\n  u[order(u)];\n}\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis\
    \ should be the accepted answer. `unique` does exactly what it says on the tin.\n\
    <|/ c |>\n<| c |>\nThis should be the accepted answer. `unique` does exactly what\
    \ it says on the tin.\n<|/ c |>\n<| c |>\nThis should be the accepted answer.\
    \ `unique` does exactly what it says on the tin.\n<|/ c |>\n<| c |>\nThis should\
    \ be the accepted answer. `unique` does exactly what it says on the tin.\n<|/\
    \ c |>\n<| c |>\nThis should be the accepted answer. `unique` does exactly what\
    \ it says on the tin.\n<|/ c |>\n<| a dscore=5 |>\n<code>\nunique(c(1,2,2,3,4))\n\
    </code>\n<|/ a tags=r,unique,vector |>\n<| c |>\nThis should be the accepted answer.\
    \ `unique` does exactly what it says on the tin.\n<|/ c |>\n<| c |>\nThis should\
    \ be the accepted answer. `unique` does exactly what it says on the tin.\n<|/\
    \ c |>\n<| c |>\nThis should be the accepted answer. `unique` does exactly what\
    \ it says on the tin.\n<|/ c |>\n<| c |>\nThis should be the accepted answer.\
    \ `unique` does exactly what it says on the tin.\n<|/ c |>\n<| c |>\nThis should\
    \ be the accepted answer. `unique` does exactly what it says on the tin.\n<|/\
    \ c |>\n<| a tags=r,unique,vector |>\n<code>\nunique(c(1,2,2,3,4))\n</code>\n\
    <|/ a dscore=5 |>\n<| c |>\nThis should be the accepted answer. `unique` does\
    \ exactly what it says on the tin.\n<|/ c |>\n<| c |>\nThis should be the accepted\
    \ answer. `unique` does exactly what it says on the tin.\n<|/ c |>\n<| a dscore=5\
    \ |>\n<code>\nunique(c(1,2,2,3,4))\n</code>\n<|/ a tags=r,unique,vector |>\n<|\
    \ c |>\nThis should be the accepted answer. `unique` does exactly what it says\
    \ on the tin.\n<|/ c |>\n<| c |>\nThis should be the accepted answer. `unique`\
    \ does exactly ", "\n  u <- unique(l);\n  u[order(u)];\n}\n</code>\n<|/ a tags=r,sorting\
    \ |>\n<| c |>\nThis doesn't seem to work. `unique` seems to sort the list before\
    \ returning it, which means it won't be in order when `sort` is applied to the\
    \ result.\n<|/ c |>\n<| c |>\nYes, you're right. I missed that `sort` was applied\
    \ to the result of `unique`. I've updated my answer.\n<|/ c |>\n<| c |>\nThanks\
    \ for your answer! I really appreciate it! I ended up using `sort(unique(l))`\
    \ because I didn't want to have to install `data.table` just for this one function.\n\
    <|/ c |>\n<| c |>\n`sort` doesn't sort the list before returning it. It sorts\
    \ the list before returning the unique elements. `unique` returns a sorted unique\
    \ list.\n<|/ c |>\n<| c |>\nI see. I was thinking of `sort` as `sort` the list\
    \ before returning the unique elements. I guess I misunderstood what `sort` did.\n\
    <|/ c |>\n<| a tags=r,sorting |>\n<code>\nunique.sorted <- function(x) {\n  u\
    \ <- unique(x);\n  u[order(u)];\n}\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis\
    \ doesn't seem to work. `unique` seems to sort the list before returning it, which\
    \ means it won't be in order when `order` is applied to the result.\n<|/ c |>\n\
    <| c |>\n`order` sorts the list before returning the unique elements. `unique`\
    \ returns a sorted unique list.\n<|/ c |>\n<| c |>\nThis doesn't seem to work.\
    \ `unique` seems to sort the list before returning it, which means it won't be\
    \ in order when `order` is applied to the result.\n<|/ c |>\n<| c |>\n`order`\
    \ sorts the list before returning the unique elements. `unique` returns a sorted\
    \ unique list.\n<|/ c |>\n<| c |>\nThis doesn't seem to work. `unique` seems to\
    \ sort the list before returning it, which means it won't be in order when `order`\
    \ is applied to the result.\n<|/ c |>\n<| a tags=r,sorting |>\n<code>\nunique.sorted\
    \ <- function(x) {\n  u <- unique(x);\n  u[order(u)];\n}\n</code>\n<|/ a dscore=5\
    \ |>\n<| c |>\nThis doesn't seem to work. `unique` seems to sort the list ", "\n\
    \  u <- unique(l[!duplicated(l)])\n  if(length(u) > 1) u else NULL\n}\n", "\n\
    \  u <- unique(l)\n  u[order(u)] \n}\n", "\n  u <- unique(l);\n  u[order(u)];\n\
    }\n</code>\n<|/ a tags=r |>\n<| a dscore=1 |>\nI like using data.table's rleid\
    \ to group consecutive runs of numbers. Then you can just use unique.\n<code>\n\
    library(data.table)\ndt <- data.table(\n  x = c(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,",
  "\n  u <- unique(l[order(l)])\n  if(length(u) > 1) u else NULL\n}\n", "\n  u <-\
    \ unique(l[!duplicated(l)])\n  if(length(u) == 0) return(NULL)\n  return(u)\n\
    }\n</code>\n<|/ a dscore=4 |>\n<| c |>\nThis doesn't work if you have a list with\
    \ duplicates.\n<|/ c |>\n<| c |>\nIt does work if you have a list with duplicates.\
    \ Try it yourself.\n<|/ c |>\n<| c |>\nIt doesn't work if you have a list with\
    \ duplicates. Try it yourself. `unique(c(1,2,2,3,4))` returns `[1] 1 2 3 4`\n\
    <|/ c |>\n<| c |>\nIt does work if you have a list with duplicates. Try it yourself.\
    \ `unique(c(1,2,2,3,4))` returns `[1] 1 2 3 4`\n<|/ c |>\n<| c |>\nIt does work\
    \ if you have a list with duplicates. Try it yourself. `unique(c(1,2,2,3,4))`\
    \ returns `[1] 1 2 3 4`\n<|/ c |>\n<| a dscore=4 |>\nHere is a function that will\
    \ remove duplicates from a list while preserving the order:\n<code>\nremoveDups\
    \ <- function(x) {\n  y <- unique(x)\n  i <- 1\n  while(i <= length(y)) {\n  \
    \  i <- i + 1\n    x <- x[-which(x == y[i])]\n  }\n  return(x)\n}\n</code>\n<|/\
    \ a tags=r,unique,list |>\n<| c |>\nThis doesn't work if you have a list with\
    \ duplicates.\n<|/ c |>\n<| c |>\nIt does work if you have a list with duplicates.\
    \ Try it yourself. `removeDups(c(1,2,2,3,4))` returns `[1] 1 2 3 4`\n<|/ c |>\n\
    <| c |>\nIt does work if you have a list with duplicates. Try it yourself. `removeDups(c(1,2,2,3,4))`\
    \ returns `[1] 1 2 3 4`\n<|/ c |>\n<| c |>\nIt does work if you have a list with\
    \ duplicates. Try it yourself. `removeDups(c(1,2,2,3,4))` returns `[1] 1 2 3 4`\n\
    <|/ c |>\n<| c |>\nIt does work if you have a list with duplicates. Try it yourself.\
    \ `removeDups(c(1,2,2,3,4))` returns `[1] 1 2 3 4`\n<|/ c |>\n<| a dscore=4 |>\n",
  "\n  u <- unique(l);\n  u[order(u)];\n}\n", "\n  u <- unique(l[!duplicated(l)])\n\
    \  if(length(u) == 0) return(NULL)\n  return(u)\n}\n</code>\n<|/ a dscore=2 |>\n\
    <| c |>\nThis doesn't work if you have duplicate elements in the list. For example,\
    \ unique(c(1,1,2,3,3)) returns c(1,2,3) instead of c(1,3)\n<|/ c |>\n<| c |>\n\
    I fixed the bug in the code by adding `unique` at the end. Thanks for pointing\
    \ it out.\n<|/ c |>\n<| a tags=r,unique,list |>\n<code>\nunique(unlist(your_list))\n\
    </code>\n<|/ a dscore=2 |>\n<| c |>\nThis doesn't work if you have duplicate elements\
    \ in the list. For example, `unique(unlist(c(1,1,2,3,3)))` returns `c(1,2,3)`\
    \ instead of `c(1,3)`\n<|/ c |>\n<| a dscore=2 |>\n<code>\nunique(unlist(your_list))\n\
    </code>\n<|/ a tags=r,unique,list |>\n<| a dscore=2 |>\n<code>\nunique(unlist(your_list))\n\
    </code>\n<|/ a tags=r,unique,list |>\n<| a dscore=1 |>\n<code>\nunique(unlist(your_list))\n\
    </code>\n<|/ a tags=r,unique,list |>\n<| a dscore=1 |>\n<code>\nunique(unlist(your_list))\n\
    </code>\n<|/ a tags=r,unique,list |>\n<| a dscore=1 |>\n<code>\nunique(unlist(your_list))\n\
    </code>\n<|/ a tags=r,unique,list |>\n<| a tags=r,unique,list |>\n<code>\nunique(unlist(your_list))\n\
    </code>\n<|/ a dscore=1 |>\n<| a tags=r,unique,list |>\n<code>\nunique(unlist(your_list))\n\
    </code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\n<code>\nunique(unlist(your_list))\n\
    </code>\n<|/ a tags=r,unique,list |>\n<| a tags=r,unique,list |>\n<code>\nunique(unlist(your_list))\n\
    </code>\n<|/ a dscore=1 |>\n<| a tags=r,unique,list |>\n<code>\nunique(unlist(your_list))\n\
    </code>\n<|/ a dscore=1 |>\n<| a tags=r,unique,list |>\n<code>\nunique(unlist(your_list))\n\
    </code>\n<|/ a dscore=1 |>\n<| a tags=r,unique,list |>\n<code>", "\n  u <- unique(l);\n\
    \  u[order(u)];\n}\n", "\n  u <- unique(l);\n  u[order(u)];\n}\n", "\n  u <- unique(l);\n\
    \  u[order(u)];\n}\n", "\n  u <- unique(l[!duplicated(l)])\n  if(length(u) > 1)\
    \ u else NULL\n}\n", "\n  u <- unique(l);\n  u[order(u)];\n}\n", "\n  u <- unique(l[!duplicated(l)])\n\
    \  u[order(u)] \n}\n", "\n  u <- unique(l);\n  u[order(u)];\n}\n", "\n  u <- unique(l[!duplicated(l)])\n\
    \  u[order(u)] \n}\n", "\n  u <- unique(l);\n  u[order(u)];\n}\n", "\n  u <- unique(l[!duplicated(l)])\n\
    \  if(length(u) == 0) return(NULL)\n  return(u)\n}\n", "\n  u <- unique(l[!duplicated(l)])\n\
    \  if(length(u) == 0) return(NULL)\n  return(u)\n}\n", "\n  u <- unique(l); u[order(u)]\
    \ \n}\n</code>\n<|/ a tags=r,sorting |>\n<| a |>\nI like to use dplyr for this\
    \ kind of thing:\n<code>\nlibrary(dplyr)\ndf <- data.frame(\n  x = c(1,2,2,3,3,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,",
  "\n  u <- unique(l[!duplicated(l)])\n  if(length(u) == 0) return(NULL)\n  return(u)\n\
    }\n", "\n  u <- unique(l[!duplicated(l)])\n  if(length(u) == 0) return(NULL)\n\
    \  return(u)\n}\n", "\n  u <- sort(unique(l))\n  u[!duplicated(u)]\n}\n", "\n\
    \  u <- unique(l[!duplicated(l)])\n  u[order(u)] \n}\n</code>\n<|/ a |>\n<| c\
    \ |>\nThis doesn't seem to work if you have a list with duplicates. For example,\
    \ `unique(c(1,2,2,3,4))` returns `[1] 1 2 3 4` instead of `[1] 1 2 3`.\n<|/ c\
    \ |>\n<| c |>\nYes, it does work. Try it yourself. `unique(c(1,2,2,3,4))` returns\
    \ `[1] 1 2 3`.\n<|/ c |>\n<| c |>\nAh, I see what you mean. Yes, it does work.\
    \ Try it yourself. `unique(c(1,2,2,3,4))` returns `[1] 1 2 3`.\n<|/ c |>\n<| c\
    \ |>\nYes, it does work. Try it yourself. `unique(c(1,2,2,3,4))` returns `[1]\
    \ 1 2 3`.\n<|/ c |>\n<| c |>\nYes, it does work. Try it yourself. `unique(c(1,2,2,3,4))`\
    \ returns `[1] 1 2 3`.\n<|/ c |>\n<| a dscore=5 |>\n<code>\nunique(c(1,2,2,3,4))\n\
    [1] 1 2 3\n</code>\n<|/ a tags=r,unique,list |>\n<| c |>\nThis doesn't seem to\
    \ work if you have a list with duplicates. For example, `unique(c(1,2,2,3,4))`\
    \ returns `[1] 1 2 3 4` instead of `[1] 1 2 3`.\n<|/ c |>\n<| c |>\nYes, it does\
    \ work. Try it yourself. `unique(c(1,2,2,3,4))` returns `[1] 1 2 3`.\n<|/ c |>\n\
    <| c |>\nYes, it does work. Try it yourself. `unique(c(1,2,2,3,4))` returns `[1]\
    \ 1 2 3`.\n<|/ c |>\n<| c |>\nYes, it does work. Try it yourself. `unique(c(1,2,2,3,4))`\
    \ returns `[1] 1 2 3`.\n<|/ c |>\n<| c |>\nYes, it does work. Try it yourself.\
    \ `unique(c(1,2,2,3,4))` returns `[1] 1 2 3`.\n<|/ c |>\n<| a |>\n<code>\nunique(c(1,2,2,3,4))\n\
    [1] 1 2 3\n</code>\n<|/ a tags=r,unique,list dscore=5 |>\n<| c |>\nThis doesn't\
    \ seem to ", "\n  u <- unique(l); u[order(u)];\n}\n", "\n  u <- unique(l[!duplicated(l)])\n\
    \  if(length(u) > 1) u\n  else NULL\n}\n", "\n  u <- unique(l); u[order(u)] \n\
    }\n", "\n  u <- unique(l);\n  u[order(u)];\n}\n", "\n  u <- unique(l);\n  u[order(u)];\n\
    }\n</code>\n<|/ a dscore=5 |>\n<| c |>\nI like this solution, but I wonder if\
    \ there is a way to avoid the sorting step by using the `order` function from\
    \ `dplyr` package?\n<|/ c |>\n<| c |>\nI believe `order` does a sort anyway. `unique`\
    \ just removes duplicates.\n<|/ c |>\n<| c |>\n`order` does a sort anyway, but\
    \ `unique` does not. `unique` removes duplicates, `order` does not.\n<|/ c |>\n\
    <| c |>\n`order` does a sort anyway, but `unique` does not. `unique` removes duplicates,\
    \ `order` does not.\n<|/ c |>\n<| c |>\n`order` does a sort anyway, but `unique`\
    \ does not. `unique` removes duplicates, `order` does not.\n<|/ c |>\n<| a tags=r,sorting\
    \ |>\n<code>\nsort(unique(unlist(mylist)))\n</code>\n<|/ a dscore=5 |>\n<| c |>\n\
    This doesn't work if you have multiple levels of nesting.\n<|/ c |>\n<| c |>\n\
    This doesn't work if you have multiple levels of nesting.\n<|/ c |>\n<| c |>\n\
    This doesn't work if you have multiple levels of nesting.\n<|/ c |>\n<| c |>\n\
    This doesn't work if you have multiple levels of nesting.\n<|/ c |>\n<| c |>\n\
    This doesn't work if you have multiple levels of nesting.\n<|/ c |>\n<| a tags=r,sorting\
    \ |>\n<code>\nsort(unique(unlist(mylist)))\n</code>\n<|/ a dscore=5 |>\n<| c |>\n\
    This doesn't work if you have multiple levels of nesting.\n<|/ c |>\n<| c |>\n\
    This doesn't work if you have multiple levels of nesting.\n<|/ c |>\n<| c |>\n\
    This doesn't work if you have multiple levels of nesting.\n<|/ c |>\n<| c |>\n\
    This doesn't work if you have multiple levels of nesting.\n<|/ c |>\n<| c |>\n\
    This doesn't work if you have multiple levels of nesting.\n<|/ c |>\n<| a dscore=5\
    \ |>\n<code>\nsort(unique(unlist(mylist)))\n</code>\n<|/ a tags=r,sorting |>\n\
    <| c |>\nThis doesn't work", "\n  u <- unique(l[!duplicated(l)])\n  if(length(u)\
    \ > 0) u\n  else NULL\n}\n", "\n  u <- unique(l); u[order(u)] \n}\n", "\n  u <-\
    \ unique(l);\n  u[order(u)];\n}\n", "\n  u <- unique(l)\n  u[order(u)] \n}\n</code>\n\
    <|/ a tags=r,sorting |>\n<| c |>\nI like this solution, since it works with `data.frame`s\
    \ and `data.table`s. However, it seems to me that `unique` should be able to handle\
    \ `list`s just fine, since `unique` works on `list`s just fine.\n<|/ c |>\n<|\
    \ c |>\nI agree with you, `unique` should handle `list`s just fine. But the `data.table`\
    \ package doesn't seem to handle `list`s very well. `data.table` also doesn't\
    \ seem to handle `data.frame`s very well. `data.table` also doesn't seem to handle\
    \ `data.frame`s very well. `data.table` also doesn't seem to handle `data.frame`s\
    \ very well. `data.table` also doesn't seem to handle `data.frame`s very well.\
    \ `data.table` also doesn't seem to handle `data.frame`s very well. `data.table`\
    \ also doesn't seem to handle `data.frame`s very well. `data.table` also doesn't\
    \ seem to handle `data.frame`s very well. `data.table` also doesn't seem to handle\
    \ `data.frame`s very well. `data.table` also doesn't seem to handle `data.frame`s\
    \ very well. `data.table` also doesn't seem to handle `data.frame`s very well.\
    \ `data.table` also doesn't seem to handle `data.frame`s very well. `data.table`\
    \ also doesn't seem to handle `data.frame`s very well. `data.table` also doesn't\
    \ seem to handle `data.frame`s very well. `data.table` also doesn't seem to handle\
    \ `data.frame`s very well. `data.table` also doesn't seem to handle `data.frame`s\
    \ very well. `data.table` also doesn't seem to handle `data.frame`s very well.\
    \ `data.table` also doesn't seem to handle `data.frame`s very well. `data.table`\
    \ also doesn't seem to handle `data.frame`s very well. `data.table` also doesn't\
    \ seem to handle `data.frame`s very well. `data.table` also doesn't seem to handle\
    \ `data.frame`s very well. `data.table` also doesn't seem to handle `data.frame`s\
    \ very well. `data.table` also doesn't seem to handle `data.frame`s very well.\
    \ `data.table` also doesn't seem to handle `data.frame`s very well. `data.table`\
    \ also doesn't seem to handle `data.frame`s very well. `", "\n  u <- unique(l)\n\
    \  u[order(u)] \n}\n", "\n  u <- unique(l);\n  u[order(u)];\n}\n", "\n  u <- unique(l)\n\
    \  u[order(u)] \n}\n", "\n  u <- unique(l)\n  u[order(u, decreasing = TRUE)]\n\
    }\n</code>\n<|/ a |>\n<| c |>\nThis doesn't seem to work if the vector is of length\
    \ 1. `unique` returns `NULL`.\n<|/ c |>\n<| c |>\nYes, it returns `NULL` if the\
    \ vector is of length 1. I added a fix for that case.\n<|/ c |>\n<| c |>\nI added\
    \ a fix for that case as well. Thanks.\n<|/ c |>\n<| c |>\nI added a fix for that\
    \ case as well. Thanks.\n<|/ c |>\n<| a dscore=5 |>\nI like using data.table's\
    \ unique.\n<code>\nlibrary(data.table)\nunique(c(1,2,2,3,4))\n[1] 1 2 3 4\n</code>\n\
    <|/ a tags=r |>\n<| c |>\nThis should be the accepted answer. `unique` from `dplyr`\
    \ package is very slow and `data.table` has much better performance.\n<|/ c |>\n\
    <| c |>\nI agree with you, `dplyr::unique` is very slow and `data.table::unique`\
    \ is much faster.\n<|/ c |>\n<| c |>\nI agree with you, `dplyr::unique` is very\
    \ slow and `data.table::unique` is much faster.\n<|/ c |>\n<| c |>\nI agree with\
    \ you, `dplyr::unique` is very slow and `data.table::unique` is much faster.\n\
    <|/ c |>\n<| a dscore=5 |>\nA simple solution using base R:\n<code>\nunique(unlist(your_list))\n\
    </code>\n<|/ a tags=r |>\n<| c |>\nThis doesn't seem to work if the vector is\
    \ of length 1. `unique` returns `NULL`.\n<|/ c |>\n<| c |>\nThis doesn't seem\
    \ to work if the vector is of length 1. `unique` returns `NULL`.\n<|/ c |>\n<|\
    \ c |>\nThis doesn't seem to work if the vector is of length 1. `unique` returns\
    \ `NULL`.\n<|/ c |>\n<| c |>\nThis doesn't seem to work if the vector is of length\
    \ 1. `unique` returns `NULL`.\n<|/ c |>\n<| c |>\nThis doesn't seem to work if\
    \ the vector is of length 1. `unique` returns `NULL`.\n<|/ c |>\n<| a tags=r |>\n\
    A simple solution using dplyr", "\n  u <- unique(l);\n  u[order(u)];\n}\n", "\n\
    \  u <- unique(l)\n  u[order(u)] \n}\n", "\n  u <- unique(l);\n  u[order(u)];\n\
    }\n", "\n  u <- unique(l[!duplicated(l)])\n  if(length(u) == 0) return(NULL)\n\
    \  return(u)\n}\n", "\n  u <- unique(l);\n  u[order(u)];\n}\n", "\n  u <- unique(l)\n\
    \  u[order(u)] \n}\n</code>\n<|/ a dscore=5 |>\n<| c |>\nI like this solution,\
    \ but I wonder if there is a way to do this without having to write an entire\
    \ new function.  I suppose you could write your own `unique` function that calls\
    \ `unique.default` but that seems like a lot of work.\n<|/ c |>\n<| c |>\nI agree\
    \ with you. I'm just trying to show that you can do it in one line. `unique` isn't\
    \ a base R function.\n<|/ c |>\n<| c |>\nI agree with you, but I wonder if there\
    \ is a way to do this without having to write an entire new function. I suppose\
    \ you could write your own `unique` function that calls `unique.default` but that\
    \ seems like a lot of work.\n<|/ c |>\n<| c |>\nI agree with you, but I wonder\
    \ if there is a way to do this without having to write an entire new function.\
    \ I suppose you could write your own `unique` function that calls `unique.default`\
    \ but that seems like a lot of work.\n<|/ c |>\n<| c |>\nI agree with you, but\
    \ I wonder if there is a way to do this without having to write an entire new\
    \ function. I suppose you could write your own `unique` function that calls `unique.default`\
    \ but that seems like a lot of work.\n<|/ c |>\n<| a tags=r,unique,sorting |>\n\
    <code>\nunique.default <- function(x, ...) unique(x[!duplicated(x)], ...)\n</code>\n\
    <|/ a dscore=5 |>\n<| c |>\nThis doesn't work if you have NAs in the vector. `unique.default(c(NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,",
  "\n  u <- unique(l[!duplicated(l)])\n  if(length(u) == 0) return(NULL)\n  return(u)\n\
    }\n", "\n  u <- unique(l)\n  u[order(u)] \n}\n", "\n  u <- unique(l);\n  u[order(u)];\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThanks for your answer. I'm aware of the\
    \ `unique` function but I was hoping to find a solution that doesn't require me\
    \ to install additional packages.\n<|/ c |>\n<| c |>\nI added a solution that\
    \ doesn't require additional packages.\n<|/ c |>\n<| c |>\nThanks for your answer.\
    \ I'm aware of the `unique` function but I was hoping to find a solution that\
    \ doesn't require me to install additional packages.\n<|/ c |>\n<| c |>\nI added\
    \ a solution that doesn't require additional packages.\n<|/ c |>\n<| a dscore=2\
    \ |>\nHere's a solution using data.table:\n<code>\nlibrary(data.table)\ndt <-\
    \ data.table(\n  x = c(1,2,2,3,3,4,4,5,5,5,5,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,",
  "\n  u <- unique(l);\n  u[order(u)];\n}\n", "\n  u <- unique(l);\n  u[order(u)];\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis doesn't seem to work. `unique` returns\
    \ a vector and `order` returns a vector. `unique` doesn't seem to work with vectors.\n\
    <|/ c |>\n<| c |>\nI fixed the typo in the function and added a link to the source\
    \ code. Thanks for pointing it out.\n<|/ c |>\n<| a dscore=2 |>\nI believe this\
    \ should work:\n<code>\nunique.list <- function(x) {\n  x <- sort(x)\n  i <- 1\n\
    \  while(i <= length(x)) {\n    if(!(x[i] == x[i-1])) {\n      x[i] <- x[i-1]\n\
    \      i <- i + 1\n    }\n  }\n  x\n}\n</code>\n<|/ a tags=r,sorting |>\n<| c\
    \ |>\nThis doesn't seem to work. `unique` returns a vector and `order` returns\
    \ a vector. `unique` doesn't seem to work with vectors.\n<|/ c |>\n<| c |>\nI\
    \ fixed the typo in the function and added a link to the source code. Thanks for\
    \ pointing it out.\n<|/ c |>\n<| a tags=r,sorting |>\n<code>\nunique.list <- function(x)\
    \ {\n  x <- sort(x)\n  i <- 1\n  while(i <= length(x)) {\n    if(!(x[i] == x[i-1]))\
    \ {\n      x[i] <- x[i-1]\n      i <- i + 1\n    }\n  }\n  x\n}\n</code>\n<|/\
    \ a dscore=2 |>\n<| a dscore=2 |>\nI believe this should work:\n<code>\nunique.list\
    \ <- function(x) {\n  x <- sort(x)\n  i <- 1\n  while(i <= length(x)) {\n    if(!(x[i]\
    \ == x[i-1])) {\n      x[i] <- x[i-1]\n      i <- i + 1\n    }\n  }\n  x\n}\n\
    </code>\n<|/ a tags=r,sorting |>\n<| a dscore=1 |>\nI believe this should work:\n\
    <code>\nunique.list <- function(x) {\n  x <- sort(x)\n  i <- 1\n  while(i <= length(x))\
    \ {\n    if(!(x[i] == x[i-1])) {\n      x[i] <- x[i-1]\n      i <- i + 1\n   \
    \ }\n  }\n  x\n}\n</code>\n<|/ a tags=r,sorting |>\n<| a tags=r,sorting |>\n<code>\n\
    unique.list <- function(x) {\n  x <- sort(x)\n  i <- 1\n  while(i <= length(x",
  "\n  u <- unique(l[!duplicated(l)])\n  if(length(u) == 0) return(NULL)\n  return(u)\n\
    }\n", "\n  u <- unique(l[!duplicated(l)])\n  if(length(u) == 0) return(NULL)\n\
    \  return(u)\n}\n", "\n  u <- unique(l);\n  u[order(u)];\n}\n", "\n  u <- unique(l);\n\
    \  u[order(u)];\n}\n", "\n  u <- unique(l); u[order(u)] \n}\n", "\n  u <- unique(l);\n\
    \  u[order(u)];\n}\n", "\n  u <- unique(l);\n  u[order(u)];\n}\n</code>\n<|/ a\
    \ tags=r,sorting |>\n<| c |>\nThis doesn't work if you have NAs in your data.\n\
    <|/ c |>\n<| c |>\nThis doesn't work if you have NAs in your data.\n<|/ c |>\n\
    <| c |>\nThis doesn't work if you have NAs in your data.\n<|/ c |>\n<| a dscore=5\
    \ |>\nI like using dplyr::arrange for this:\n<code>\nlibrary(dplyr)\ndf <- data.frame(a\
    \ = c(1,2,2,3,NA,NA,NA,NA,NA), b = c(2,NA,NA,NA,NA,NA,NA,NA,NA))\ndf %>% arrange(!is.na(a))\n\
    </code>\n<|/ a tags=r,sorting |>\n<| c |>\nThis doesn't work if you have NAs in\
    \ your data.\n<|/ c |>\n<| c |>\nThis doesn't work if you have NAs in your data.\n\
    <|/ c |>\n<| c |>\nThis doesn't work if you have NAs in your data.\n<|/ c |>\n\
    <| c |>\nThis doesn't work if you have NAs in your data.\n<|/ c |>\n<| a tags=r,sorting\
    \ |>\n<code>\ndf <- data.frame(a = c(1,2,2,3,NA,NA,NA,NA,NA), b = c(2,NA,NA,NA,NA,NA,NA,NA,NA))\n\
    </code>\nThe solution using dplyr package:\n<code>\ndf %>% arrange(!is.na(a))\n\
    </code>\n<|/ a dscore=5 |>\n<| c |>\nThis doesn't work if you have NAs in your\
    \ data.\n<|/ c |>\n<| c |>\nThis doesn't work if you have NAs in your data.\n\
    <|/ c |>\n<| c |>\nThis doesn't work if you have NAs in your data.\n<|/ c |>\n\
    <| a dscore=5 |>\n<code>\ndf <- data.frame(a = c(1,2,2,3,NA,NA,NA,NA,NA), b =\
    \ c(2,NA,NA,NA,NA,NA,NA,NA,NA))\n\ndf[order(!is.na(df$a)),]\n</code>\n<|/ a tags=r,sorting\
    \ |>\n<| c |>\nThis doesn't work if you have NAs in your data.\n<|/ c |>\n<| c\
    \ |>\nThis doesn't work if you have NAs in your data.\n<|/ c |>\n", "\n  u <-\
    \ unique(l[!duplicated(l)])\n  if(length(u) == 0) return(NULL)\n  return(u)\n\
    }\n"]
stop_tokens:
- "\n#"
- "\n```"
