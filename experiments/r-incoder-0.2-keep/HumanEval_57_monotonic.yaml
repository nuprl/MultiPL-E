name: HumanEval_57_monotonic
language: r
prompt: "# Return True is list elements are monotonically increasing or decreasing.\n\
  # >>> monotonic([1, 2, 4, 20])\n# True\n# >>> monotonic([1, 20, 4, 10])\n# False\n\
  # >>> monotonic([4, 1, 0, -10])\n# True\nmonotonic <- function(l) {"
tests: "test_humaneval <- function() {\ncandidate <- monotonic\n    if(!identical(candidate(c(1,\
  \ 2, 4, 10)), TRUE)){quit('no', 1)}\n    if(!identical(candidate(c(1, 2, 4, 20)),\
  \ TRUE)){quit('no', 1)}\n    if(!identical(candidate(c(1, 20, 4, 10)), FALSE)){quit('no',\
  \ 1)}\n    if(!identical(candidate(c(4, 1, 0, -10)), TRUE)){quit('no', 1)}\n   \
  \ if(!identical(candidate(c(4, 1, 1, 0)), TRUE)){quit('no', 1)}\n    if(!identical(candidate(c(1,\
  \ 2, 3, 2, 5, 60)), FALSE)){quit('no', 1)}\n    if(!identical(candidate(c(1, 2,\
  \ 3, 4, 5, 60)), TRUE)){quit('no', 1)}\n    if(!identical(candidate(c(9, 9, 9, 9)),\
  \ TRUE)){quit('no', 1)}\n}\ntest_humaneval()"
completions: ["\n  l <- sort(l)\n  i <- 1\n  while(i < length(l)) {\n    if(l[i] <\
    \ l[i-1]) {\n      i <- i + 1\n    } else {\n      i <- i + 1\n      if(l[i] >\
    \ l[i-1]) {\n        i <- i + 1\n      }\n    }\n  }\n  return(TRUE)\n}\n</code>\n\
    <|/ a tags=r,sorting |>\n<| c |>\nI like this solution, but I wonder if there\
    \ is a way to make it more efficient by avoiding sorting and just checking if\
    \ each element in the list is greater than the previous one. I'm thinking about\
    \ a function that would return TRUE if the list was monotonically increasing or\
    \ FALSE if it was decreasing.\n<|/ c |>\n<| c |>\nYes, that would be a good idea.\
    \ I'll try to write it up and post it here.\n<|/ c |>\n<| c |>\nI added a function\
    \ that does just that. Let me know if that works for you.\n<|/ c |>\n<| c |>\n\
    Thanks, that looks great. I'll give it a try.\n<|/ c |>\n<| c |>\nI added a function\
    \ that does just that. Let me know if that works for you.\n<|/ c |>\n<| a |>\n\
    Here's a solution using data.table:\n<code>\nlibrary(data.table)\ndt <- data.table(x\
    \ = c(1,2,4,20))\ndt[, y := c(NA, diff(x)), by = 1:nrow(dt)]\ndt[, y := ifelse(y\
    \ == 0, NA, y)]\ndt[, y := cumsum(y), by = 1:nrow(dt)]\ndt[, y := ifelse(is.na(y),\
    \ 0, y)]\ndt[, y := ifelse(y == 0, NA, y)]\ndt[, y := cumsum(y), by = 1:nrow(dt)]\n\
    dt[, y := ifelse(is.na(y), 0, y)]\ndt[, y := cumsum(y), by = 1:nrow(dt)]\ndt[,\
    \ y := ifelse(is.na(y), 0, y)]\ndt[, y := cumsum(y), by = 1:nrow(dt)]\ndt[, y\
    \ := ifelse(is.na(y), 0, y)]\ndt[, y := cumsum(y), by = 1:nrow(dt)]\ndt[, y :=\
    \ ifelse(is.na(y), 0, y)]\ndt[, y := cumsum(y), by = 1:nrow(dt)]\ndt[, y := ifelse(is.na(y),\
    \ 0, y", "\n  l <- sort(l)\n  i <- 1\n  while(i < length(l)) {\n    if(l[i] <\
    \ l[i-1]) {\n      i <- i + 1\n    } else {\n      i <- i + 1\n      if(l[i] >\
    \ l[i-1]) {\n        i <- i + 1\n      }\n    }\n  }\n  return(TRUE)\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nThanks, this works great. I'm still trying to understand\
    \ how it works. I understand that `monotonic` returns TRUE if the list is monotonically\
    \ increasing or decreasing, but how does it know when to stop? I see that `i`\
    \ is incremented every time `l[i]` is greater than `l[i-1]`, but how does it know\
    \ when to stop? Does it just keep going until it reaches the end of the list?\n\
    <|/ c |>\n<| c |>\nYes, it just keeps going until it reaches the end of the list.\
    \ `i` starts at 1 and increments by 1 every time `l[i]` is greater than `l[i-1]`.\
    \ When it reaches the end of the list, `i` increments by 1 again and `l[i]` is\
    \ greater than `l[i-1]` again, etc.\n<|/ c |>\n<| c |>\nAh, I see. So it just\
    \ keeps going until it reaches the end of the list and then it stops because `i`\
    \ increments by 1 again and `l[i]` is greater than `l[i-1]` again, etc.\n<|/ c\
    \ |>\n<| c |>\nYes, that's right. `i` starts at 1 and increments by 1 every time\
    \ `l[i]` is greater than `l[i-1]`. When it reaches the end of the list, `i` increments\
    \ by 1 again and `l[i]` is greater than `l[i-1]` again, etc.\n<|/ c |>\n<| c |>\n\
    Thanks, this was very helpful.\n<|/ c |>\n<| a tags=r,list,monotonicity |>\n<code>\n\
    monotonic = function(x) {\n  for(i in seq_along(x)) {\n    if(diff(x[(i+1):length(x)])<0)\
    \ {\n      return(FALSE)\n    }\n  }\n  return(TRUE)\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| a tags=r,list,monotonicity |>\n<code>\nmonotonic = function(x) {\n  for(i\
    \ in seq_along(x)) {\n    if(diff(x[(i+1):length(x)])<0) {\n      return(FALSE)\n\
    \    }\n  }\n  return(TRUE)\n}\n</code>\n<|/ a dscore=1 |>\n<| a tags=", "\n \
    \ l <- sort(l)\n  diffs <- c(l[1] - l[2], l[2] - l[1], l[3] - l[2], l[4] - l[3])\n\
    \  all(diffs >= 0)\n}\n", "\n  l <- sort(l)\n  diffs <- diff(l) > 0\n  all(diffs)\
    \ || all(diffs[c(TRUE, FALSE)])\n}\n", "\n  l <- sort(l)\n  i <- 1\n  while(i\
    \ < length(l)) {\n    if(l[i] < l[i-1]) {\n      break\n    }\n    i <- i + 1\n\
    \  }\n  return(i <= length(l))\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThanks\
    \ for your answer. Your code works perfectly for monotonic lists, but not for\
    \ non-monotonic lists. For example: `monotonic(c(1,2,4,20))` returns `FALSE`,\
    \ but `monotonic(c(1,2,4,20,10))` returns `TRUE`.\n<|/ c |>\n<| c |>\nI added\
    \ a version that works for non-monotonic lists.\n<|/ c |>\n<| c |>\nThanks for\
    \ your answer. Your code works perfectly for monotonic lists, but not for non-monotonic\
    \ lists. For example: `monotonic(c(1,2,4,20))` returns `FALSE`, but `monotonic(c(1,2,4,20,10))`\
    \ returns `TRUE`.\n<|/ c |>\n<| c |>\nI added a version that works for non-monotonic\
    \ lists.\n<|/ c |>\n<| a |>\nHere is a simple solution that works for both monotonic\
    \ lists and non-monotonic lists:\n<code>\nmonotonic <- function(l) {\n  l <- sort(l)\n\
    \  i <- 1\n  while(i < length(l)) {\n    if(l[i] < l[i-1]) {\n      break\n  \
    \  }\n    i <- i + 1\n  }\n  return(i <= length(l))\n}\n</code>\n<|/ a tags=list,r\
    \ dscore=2 |>\n<| c |>\nThanks for your answer. Your code works perfectly for\
    \ monotonic lists, but not for non-monotonic lists. For example: `monotonic(c(1,2,4,20))`\
    \ returns `FALSE`, but `monotonic(c(1,2,4,20,10))` returns `TRUE`.\n<|/ c |>\n\
    <| c |>\nI added a version that works for non-monotonic lists.\n<|/ c |>\n<| a\
    \ dscore=2 |>\nHere's a solution using purrr:\n<code>\nlibrary(purrr)\nmonotonic2\
    \ <- function(x) {\n  x %>% \n    map(sort) %>% \n    map(function(x) all(diff(x)\
    \ > 0)) %>% \n    reduce(`&`)\n}\n</code>\n<|/ a tags=list,r |>\n<| c |>\nThanks\
    \ for your answer. Your code works perfectly for monotonic lists, but not for\
    \ non-monoton", "\n  l <- sort(l)\n  diffs <- c(l[1], diff(l))\n  return(all(diffs\
    \ >= 0))\n}\n</code>\n<|/ a dscore=2 |>\n<| a tags=r,sorting |>\nHere's a solution\
    \ using data.table:\n<code>\nlibrary(data.table)\ndt <- data.table(x = c(1,2,4,20))\n\
    dt[, y := c(NA, diff(x)), by = .(x < shift(x, fill = NA))]\ndt[, y := ifelse(is.na(y),\
    \ x, y), by = .(x < shift(x, fill = NA))]\ndt[, y := ifelse(is.na(y), x, y), by\
    \ = .(x > shift(x, fill = NA))]\ndt[, y := ifelse(is.na(y), x, y), by = .(x >\
    \ shift(x, fill = NA))]\ndt[, y := ifelse(is.na(y), x, y), by = .(x < shift(x,\
    \ fill = NA)), .SDcols = c(\"x\", \"y\")]\ndt[, y := ifelse(is.na(y), x, y), by\
    \ = .(x > shift(x, fill = NA)), .SDcols = c(\"x\", \"y\")]\ndt[, y := ifelse(is.na(y),\
    \ x, y), by = .(x < shift(x, fill = NA)), .SDcols = c(\"x\", \"y\")]\ndt[, y :=\
    \ ifelse(is.na(y), x, y), by = .(x > shift(x, fill = NA)), .SDcols = c(\"x\",\
    \ \"y\")]\ndt[, y := ifelse(is.na(y), x, y), by = .(x < shift(x, fill = NA)),\
    \ .SDcols = c(\"x\", \"y\")]\ndt[, y := ifelse(is.na(y), x, y), by = .(x > shift(x,\
    \ fill = NA)), .SDcols = c(\"x\", \"y\")]\ndt[, y := ifelse(is.na(y), x, y), by\
    \ = .(x < shift(x, fill = NA)), .SDcols = c(\"x\", \"y\")]\ndt[, y := ifelse(is.na(y),\
    \ x, y), by = .(x > shift(x, fill = NA)), .SDcols = c(\"x\", \"y\")]\ndt[, y :=\
    \ ifelse(is.na(y), x, y), by = .(x < shift(x, fill = NA)), .SDcols = c(\"x\",\
    \ \"y\")]\ndt[, y := ifelse(is.na(y), x, y), by = .(x > shift(x, fill = NA)),\
    \ .SDcols = c(\"x\", \"y\")]\ndt", "\n  l <- sort(l)\n  diffs <- c(l[-1], NA)\
    \ - l\n  all(diffs >= 0)\n}\n</code>\n<|/ a tags=r,sorting |>\n<| c |>\nThis doesn't\
    \ work if the list is `c(1,2,4,20)`\n<|/ c |>\n<| c |>\nIt does work, try it yourself.\
    \ It returns `TRUE` for the example you gave.\n<|/ c |>\n<| c |>\nI tested it\
    \ and it doesn't work. Try `monotonic(c(1,2,4,20))`\n<|/ c |>\n<| c |>\nYes, I\
    \ tested it and it doesn't work. Try `monotonic(c(1,2,4,20))`\n<|/ c |>\n<| c\
    \ |>\nYes, I tested it and it doesn't work. Try `monotonic(c(1,2,4,20))`\n<|/\
    \ c |>\n<| a dscore=5 |>\nThe answer by is great, but I thought I'd add my own\
    \ answer because I wanted to compare it to the other answers here.\n<code>\nis.monotonic",
  "\n  l <- sort(l)\n  l[1] < l[2] & l[1] < l[3] & l[2] < l[3] & l[1] < l[4]\n}\n\
    </code>\n<|/ a dscore=2 |>\n<| a tags=r,sorting |>\n<code>\nmonotonic = function(a)\
    \ {\n  a = sort(a)\n  a[1] < a[2] & a[1] < a[3] & a[2] < a[3] & a[1] < a[4]\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| a tags=r,sorting |>\n<code>\nmonotonic = function(a)\
    \ {\n  a = sort(a)\n  a[1] < a[2] & a[1] < a[3] & a[2] < a[3] & a[1] < a[4]\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2 |>\n<code>\nmonotonic = function(a)\
    \ {\n  a = sort(a)\n  a[1] < a[2] & a[1] < a[3] & a[2] < a[3] & a[1] < a[4]\n\
    }\n</code>\n<|/ a tags=r,sorting |>\n<| a dscore=2 |>\n<code>\nmonotonic = function(a)\
    \ {\n  a = sort(a)\n  a[1] < a[2] & a[1] < a[3] & a[2] < a[3] & a[1] < a[4]\n\
    }\n</code>\n<|/ a tags=r,sorting |>\n<| a tags=r,sorting |>\n<code>\nmonotonic\
    \ = function(a) {\n  a = sort(a)\n  a[1] < a[2] & a[1] < a[3] & a[2] < a[3] &\
    \ a[1] < a[4]\n}\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\n<code>\nmonotonic\
    \ = function(a) {\n  a = sort(a)\n  a[1] < a[2] & a[1] < a[3] & a[2] < a[3] &\
    \ a[1] < a[4]\n}\n</code>\n<|/ a tags=r,sorting |>\n<| a tags=r,sorting |>\n<code>\n\
    monotonic = function(a) {\n  a = sort(a)\n  a[1] < a[2] & a[1] < a[3] & a[2] <\
    \ a[3] & a[1] < a[4]\n}\n</code>\n<|/ a dscore=1 |>\n<| a tags=r,sorting |>\n\
    <code>\nmonotonic = function(a) {\n  a = sort(a)\n  a[1] < a[2] & a[1] < a[3]\
    \ & a[2] < a[3] & a[1] < a[4]\n}\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\n\
    <code>\nmonotonic = function(a) {\n  a = sort(", "\n  l <- sort(l)\n  l[1] < l[2]\
    \ & l[1] < l[3] & l[2] < l[3] & l[1] < l[4]\n}\n", "\n  l <- sort(l)\n  l[c(TRUE,\
    \ diff(l) > 0)]\n}\n</code>\n<|/ a tags=r,sorting |>\n<| a dscore=2 |>\nA simple\
    \ solution would be to sort the vector and compare the previous and current elements:\n\
    <code>\nx <- c(4,2,1,-10)\nsort(x) == c(sort(x)[1], sort(x)[-1])", "\n  l <- sort(l)\n\
    \  diffs <- c(l[1], diff(l))\n  return(all(diffs > 0))\n}\n</code>\n<|/ a dscore=5\
    \ |>\n<| c |>\nI like this solution, but I wonder if it will work well with large\
    \ lists. I ran a test with 1e6 elements and it took about 1.5 seconds to run on\
    \ my machine.\n<|/ c |>\n<| c |>\nI ran a test with 1e6 elements and it took about\
    \ 1.5 seconds to run on my machine.\n<|/ c |>\n<| c |>\nI ran a test with 1e6\
    \ elements and it took about 1.5 seconds to run on my machine.\n<|/ c |>\n<| c\
    \ |>\nI ran a test with 1e6 elements and it took about 1.5 seconds to run on my\
    \ machine.\n<|/ c |>\n<| c |>\nI ran a test with 1e6 elements and it took about\
    \ 1.5 seconds to run on my machine.\n<|/ c |>\n<| a dscore=5 |>\nThe R package\
    \ data.table has a function called is.increasing which does exactly what you want.\n\
    <code>\nlibrary(data.table)\nis.increasing(1:10)\n[1] FALSE FALSE FALSE FALSE\
    \ FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\
    \ FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\
    \ FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\
    \ FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\
    \ FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\
    \ FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\
    \ FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\
    \ FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\
    \ FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\
    \ FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FAL", "\n  l <- sort(l)\n  diffs\
    \ <- c(NA_integer_, head(diff(l), -1))\n  all(diffs == 0)\n}\n</code>\n<|/ a tags=r,sorting\
    \ |>\n<| c |>\nI like your solution, although I wonder how it compares to `sort`\
    \ on large vectors. `sort` seems to be much faster for small vectors.\n<|/ c |>\n\
    <| c |>\nI tested it on vectors of length 100 and it took about 1.5 seconds on\
    \ my machine. `sort` was about 5 times faster.\n<|/ c |>\n<| c |>\nI tested it\
    \ on vectors of length 10000 and it took about 1.5 seconds on my machine. `sort`\
    \ was about 5 times faster.\n<|/ c |>\n<| c |>\nI tested it on vectors of length\
    \ 100000 and it took about 1.5 seconds on my machine. `sort` was about 5 times\
    \ faster.\n<|/ c |>\n<| c |>\nI tested it on vectors of length 1000000 and it\
    \ took about 1.5 seconds on my machine. `sort` was about 5 times faster.\n<|/\
    \ c |>\n<| a dscore=4 |>\n<code>\n> x <- c(1,4,2,5,3,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20)\n\
    > x\n [1]  1  4  2  5  3  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20\n> sort(x)\n\
    \ [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20\n> x[order(x)]\n\
    \ [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20\n</code>\n<|/\
    \ a tags=r,sorting |>\n<| c |>\nThis doesn't work if `x` is already sorted.\n\
    <|/ c |>\n<| c |>\nIt doesn't work if `x` is already sorted.\n<|/ c |>\n<| c |>\n\
    This doesn't work if `x` is already sorted.\n<|/ c |>\n<| a dscore=4 |>\n<code>\n\
    x <- c(1,4,2,5,3,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20)\nx", "\n  n <- length(l)\
    \ - 1\n  m <- 0\n  i <- 1\n  while (i <= n) {\n    m <- max(m, l[i])\n    i <-\
    \ i + 1\n  }\n  m > l[n]\n}\n</code>\n<|/ a dscore=4 |>\n<| c |>\nThis is great,\
    \ thank you! I added a small modification to allow for negative numbers in the\
    \ list. `m <- max(m, -l[i])`\n<|/ c |>\n<| c |>\nI added a version that doesn't\
    \ require the list to be sorted.\n<|/ c |>\n<| a tags=r |>\nHere's a solution\
    \ using data.table:\n<code>\nlibrary(data.table)\ndt <- data.table(\n  x = c(1,2,4,20),\n\
    \  y = c(2,4,1,-10),\n  z = c(4,1,0,10)\n)\n\ndt[, \n  list(\n    increasing =\
    \ all(x > y),\n    decreasing = all(x < y)\n  )\n]\n</code>\n<|/ a dscore=4 |>\n\
    <| c |>\nThis doesn't seem to work if the list elements are of different lengths.\
    \ For example, `dt <- data.table(x = c(1,2,4,20), y = c(2,4,1,-10), z = c(4,1,0,10))`\
    \ gives `Error in Ops.data.table(dt$x, dt$y) : \n  binary operator \">\" is not\
    \ defined for \"list\" operands`\n<|/ c |>\n<| c |>\nI added a version that doesn't\
    \ require the list to be sorted.\n<|/ c |>\n<| a dscore=4 |>\nHere's a solution\
    \ using dplyr and purrr:\n<code>\nlibrary(dplyr)\nlibrary(purrr)\n\nx <- c(1,2,4,20)\n\
    y <- c(2,4,1,-10)\nz <- c(4,1,0,10)\n\ndf <- data.frame(x, y, z)\n\ndf %>%\n \
    \ mutate(\n    increasing = map_lgl(df, ~all(.x > .y)),\n    decreasing = map_lgl(df,\
    \ ~all(.x < .y))\n  )\n</code>\n<|/ a tags=r |>\n<| a tags=r |>\nHere's a solution\
    \ using base R:\n<code>\nx <- c(1,2,4,20)\ny <- c(2,4,1,-10)\nz <- c(4,1,0,10)\n\
    \ndf <- data.frame(x, y, z)\n\ndf$increasing <- sapply(1:nrow(df), function(i)\
    \ all(df[i,]$x > df[i,]$y))\ndf$decreasing <- sapply(1:nrow(df", "\n  l <- sort(l)\n\
    \  diffs <- c(l[-1], NA) - l\n  all(diffs >= 0) && all(diffs <= 0)\n}\n</code>\n\
    <|/ a tags=r |>\n<| c |>\nI like this solution, but I wonder if there is a way\
    \ to make it more efficient by avoiding sorting the entire list twice. Maybe by\
    \ using a binary search to find the first element that is out of order?\n<|/ c\
    \ |>\n<| c |>\nI added a binary search solution to my answer.\n<|/ c |>\n<| a\
    \ dscore=2 |>\nHere's a solution using data.table:\n<code>\nlibrary(data.table)\n\
    dt <- data.table(a = c(1,2,4,20), b = c(1,20,4,10))\ndt[, diff := b - shift(a,\
    \ fill = first(a)), by = a]\ndt[diff < 0, diff := diff]\ndt[diff > 0, diff :=\
    \ diff]\ndt[diff == 0, diff := NA]\n</code>\n<|/ a tags=r |>\n<| a tags=r |>\n\
    Here's a solution using dplyr and purrr packages:\n<code>\nlibrary(dplyr)\nlibrary(purrr)\n\
    \ndf <- data.frame(a = c(1,2,4,20), b = c(1,20,4,10))\n\ndf %>% \n  mutate(diff\
    \ = map(b, ~ifelse(a < .x, .x - a, NA)) %>% \n           reduce(`+`)) %>% \n \
    \ mutate(diff = ifelse(diff < 0, diff, NA)) %>% \n  mutate(diff = ifelse(diff\
    \ > 0, diff, NA))\n</code>\n<|/ a dscore=2 |>\n<| a tags=r |>\nHere's a solution\
    \ using dplyr and purrr packages:\n<code>\nlibrary(dplyr)\nlibrary(purrr)\n\n\
    df <- data.frame(a = c(1,2,4,20), b = c(1,20,4,10))\n\ndf %>% \n  mutate(diff\
    \ = map(b, ~ifelse(a < .x, .x - a, NA)) %>% \n           reduce(`+`)) %>% \n \
    \ mutate(diff = ifelse(diff < 0, diff, NA)) %>% \n  mutate(diff = ifelse(diff\
    \ > 0, diff, NA))\n</code>\n<|/ a dscore=2 |>\n<| a tags=r |>\nHere's a solution\
    \ using dplyr and purrr packages:\n<code>\nlibrary(dplyr)\nlibrary(purrr)\n\n\
    df <- data.frame(a = c(1,2,4,20), b = c(1,20,4,10))\n\ndf ", "\n  l <- sort(l)\n\
    \  diffs <- diff(l) > 0\n  all(diffs) || (all(diffs[c(TRUE, FALSE)]))\n}\n</code>\n\
    <|/ a |>\n<| c |>\nI like your solution, though I wonder if there is a way to\
    \ avoid the explicit `c(TRUE, FALSE)` construction.\n<|/ c |>\n<| c |>\nI guess\
    \ you could do `all(diffs[c(TRUE, FALSE)])` but that doesn't seem very elegant.\n\
    <|/ c |>\n<| c |>\nI like your solution, though I wonder if there is a way to\
    \ avoid the explicit `c(TRUE, FALSE)` construction.\n<|/ c |>\n<| c |>\nI guess\
    \ you could do `all(diffs[c(TRUE, FALSE)])` but that doesn't seem very elegant.\n\
    <|/ c |>\n<| c |>\nI like your solution, though I wonder if there is a way to\
    \ avoid the explicit `c(TRUE, FALSE)` construction.\n<|/ c |>\n<| a tags=r,sorting\
    \ |>\nHere's a solution using data.table:\n<code>\nlibrary(data.table)\ndt <-\
    \ data.table(\n  x = c(1,2,4,20),\n  y = c(2,4,1,-10),\n  z = c(4,1,0,-10),\n\
    \  w = c(20,10,10,10)\n)\n\ndt[, \n  is_increasing := \n    c(FALSE, diff(x) >\
    \ 0) &\n    c(FALSE, diff(y) > 0) &\n    c(FALSE, diff(z) > 0) &\n    c(FALSE,\
    \ diff(w) > 0)\n]\n", "\n  l <- sort(l)\n  diffs <- c(l[-1]-l[-length(l)]) # Get\
    \ differences between adjacent elements\n  all(diffs >= 0) # Return True if all\
    \ differences are positive\n}\n", "\n  l <- sort(l)\n  diffs <- diff(l) < 0\n\
    \  all(diffs) || all(diffs[c(TRUE, FALSE)])\n}\n</code>\n<|/ a dscore=3 |>\n<|\
    \ c |>\nI like your answer but I'm having trouble understanding how it works.\
    \ Can you explain how it works?\n<|/ c |>\n<| c |>\nSure. `diff` gives you the\
    \ difference between consecutive elements. `diff` returns `NA` when there is an\
    \ NA between two consecutive elements. `diff` returns `0` when there is an NA\
    \ between two consecutive elements. `diff` returns `1` when there is an NA between\
    \ two consecutive elements. `all` returns `TRUE` when all elements are `1` or\
    \ `0`.\n<|/ c |>\n<| c |>\nI added a little explanation.\n<|/ c |>\n<| c |>\n\
    I like your answer but I'm having trouble understanding how it works. Can you\
    \ explain how it works?\n<|/ c |>\n<| c |>\nI added a little explanation.\n<|/\
    \ c |>\n<| a |>\nHere's a solution using data.table:\n<code>\nlibrary(data.table)\n\
    dt <- data.table(\n  x = c(1,2,4,20,1,4,1,0,-10,4,1,0,-10,4,1,0,-10,4,1,0,-10,4,1,0,-10,4,1,0,-10,4,1,0,-10,4,1,0,-10,4,1,0,-10,4,1,0,-10,4,1,0,-10,4,1,0,-10,4,1,0,-10,4,1,0,-10,4,1,0,-10,4,1,0,-10,4,1,0,-10,4,1,0,-10,4,1,0,-10,4,1,0,-10,4,1,0,-10,4,1,0,-10,4,1,0,-10,4,1,0,-10,4,1,0,-10,4,1,0,-10,4,1,0,-10,4,1,0,-10,4,1,0,-10,4,1,0,-10,4,1,0,-10,4,1,0,-10,4,1,0,-10,4,1,0,-10,4,1,0,-10,4,1,0,-10,4,1,0,-10,4,1,0,-10,4,1,0,-10,4,1,0,-10,4,1,0,-10,4,1,0,-10,4,1,0,-10,4,1,0,-10,4,1,0,-10,4,1,0,-10,4,1,0,-10,4,1,0,-10,4,1,0,-",
  "\n  l <- sort(l)\n  diffs <- c(l[-1], NA)\n  diffs[is.na(diffs)] <- 0\n  all(diffs[1:(length(l)-1)]\
    \ < 0)\n}\n</code>\n<|/ a dscore=5 |>\n<| c |>\nI like this answer because it\
    \ doesn't require a package. Thanks!\n<|/ c |>\n<| c |>\nThis is great! I added\
    \ a version that returns TRUE or FALSE to make it more useful.\n<|/ c |>\n<| c\
    \ |>\nI added a version that returns TRUE or FALSE to make it more useful.\n<|/\
    \ c |>\n<| c |>\nI added a version that returns TRUE or FALSE to make it more\
    \ useful.\n<|/ c |>\n<| c |>\nI added a version that returns TRUE or FALSE to\
    \ make it more useful.\n<|/ c |>\n<| a tags=r,sorting |>\n<code>\n> x <- c(1,2,4,20)\n\
    > x[1] < x[2] & x[1] < x[3] & x[1] < x[4]\n[1] TRUE\n> x[1] > x[2] & x[1] > x[3]\
    \ & x[1] > x[4]\n[1] FALSE\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis doesn't\
    \ work if you have NAs in your vector. `x[1] < x[2] & x[1] < x[3] & x[1] < x[4]`\
    \ returns `[1] TRUE` but `x[1] > x[2] & x[1] > x[3] & x[1] > x[4]` returns `[1]\
    \ FALSE`\n<|/ c |>\n<| c |>\nThis doesn't work if you have NAs in your vector.\
    \ `x[1] < x[2] & x[1] < x[3] & x[1] < x[4]` returns `[1] TRUE` but `x[1] > x[2]\
    \ & x[1] > x[3] & x[1] > x[4]` returns `[1] FALSE`\n<|/ c |>\n<| c |>\nThis doesn't\
    \ work if you have NAs in your vector. `x[1] < x[2] & x[1] < x[3] & x[1] < x[4]`\
    \ returns `[1] TRUE` but `x[1] > x[2] & x[1] > x[3] & x[1] > x[4]` returns `[1]\
    \ FALSE`\n<|/ c |>\n<| c |>\nThis doesn't work if you have NAs in your vector.\
    \ `x[1] < x[2] & x[1] < x[3] & x[1] < x[4]` returns `[1] TRUE` but `x[1] > x[2]\
    \ & x[1] > x[3] & x[1] > x[4]` returns `[1] FALSE`\n<|/ c |>\n<| c |>\n", "\n\
    \  l <- sort(l)\n  diffs <- c(l[1], diff(l), l[length(l)])\n  all(diffs > 0)\n\
    }\n</code>\n<|/ a tags=r,sorting |>\n<| a dscore=2 |>\nHere's a solution using\
    \ data.table:\n<code>\nlibrary(data.table)\ndt <- data.table(a = c(1,2,4,20),\
    \ b = c(1,20,4,10))\ndt[, c := c(NA, diff(a), NA), by = b][, c := ifelse(is.na(c),\
    \ a, c)]\ndt", "\n  l <- sort(l)\n  diffs <- c(l[-1], NA)\n  diffs[is.na(diffs)]\
    \ <- 0\n  all(diffs[1:(length(l)-1)] == diffs[2:length(l)])\n}\n</code>\n<|/ a\
    \ dscore=2 |>\n<| a tags=r,sorting |>\n<code>\nmonotonic = function(a){\n  a =\
    \ sort(a)\n  b = a[-1] - a[-length(a)]\n  return(all(diff(b) == 0))\n}\n</code>\n\
    <|/ a dscore=2 |>\n<| a tags=r,sorting |>\n<code>\nmonotonic = function(a){\n\
    \  a = sort(a)\n  b = a[-1] - a[-length(a)]\n  return(all(diff(b) == 0))\n}\n\
    </code>\n<|/ a dscore=2 |>\n<| a tags=r,sorting |>\n<code>\nmonotonic = function(a){\n\
    \  a = sort(a)\n  b = a[-1] - a[-length(a)]\n  return(all(diff(b) == 0))\n}\n\
    </code>\n<|/ a dscore=2 |>\n<| a dscore=1 |>\n<code>\nmonotonic = function(a){\n\
    \  a = sort(a)\n  b = a[-1] - a[-length(a)]\n  return(all(diff(b) == 0))\n}\n\
    </code>\n<|/ a tags=r,sorting |>\n<| a dscore=1 |>\n<code>\nmonotonic = function(a){\n\
    \  a = sort(a)\n  b = a[-1] - a[-length(a)]\n  return(all(diff(b) == 0))\n}\n\
    </code>\n<|/ a tags=r,sorting |>\n<| a tags=r,sorting |>\n<code>\nmonotonic =\
    \ function(a){\n  a = sort(a)\n  b = a[-1] - a[-length(a)]\n  return(all(diff(b)\
    \ == 0))\n}\n</code>\n<|/ a dscore=1 |>\n<| a tags=r,sorting |>\n<code>\nmonotonic\
    \ = function(a){\n  a = sort(a)\n  b = a[-1] - a[-length(a)]\n  return(all(diff(b)\
    \ == 0))\n}\n</code>\n<|/ a dscore=1 |>\n<| a tags=r,sorting |>\n<code>\nmonotonic\
    \ = function(a){\n  a = sort(a)\n  b = a[-1] - a[-length(a)]\n  return(all(diff(b)\
    \ == 0))\n}\n</code>\n<|/ a dscore=1 |>\n<| a tags=r,sorting |>\n<code>\nmonotonic\
    \ = function(a){\n  a = sort(a)\n  b = a[-1] - a[-length(a)]", "\n  n <- length(l)\
    \ - 1\n  i <- 1\n  while(i <= n) {\n    if(l[i] < l[i-1]) {\n      break\n   \
    \ }\n    i <- i + 1\n  }\n  return(i <= n)\n}\n", "\n  n <- length(l) - 1\n  i\
    \ <- 1\n  while (i <= n) {\n    if (l[i] < l[i - 1]) {\n      i <- i + 1\n   \
    \ } else if (l[i] > l[i - 1]) {\n      i <- i + 1\n    } else {\n      i <- i\
    \ + 1\n    }\n  }\n  return(TRUE)\n}\n</code>\n<|/ a dscore=1 |>\n<| a |>\nI wrote\
    \ a function that checks if a vector is monotonic:\n<code>\nis_monotonic <- function(x)\
    \ {\n  n <- length(x)\n  i <- 1\n  while (i <= n) {\n    if (x[i] < x[i-1]) {\n\
    \      i <- i + 1\n    } else if (x[i] > x[i-1]) {\n      i <- i + 1\n    } else\
    \ {\n      i <- i + 1\n    }\n  }\n  return(TRUE)\n}\n</code>\n<|/ a tags=r,sorting\
    \ dscore=1 |>\n<| a dscore=0 |>\n<code>\nis_monotonic <- function(x) {\n  n <-\
    \ length(x)\n  i <- 1\n  while (i <= n) {\n    if (x[i] < x[i-1]) {\n      i <-\
    \ i + 1\n    } else if (x[i] > x[i-1]) {\n      i <- i + 1\n    } else {\n   \
    \   i <- i + 1\n    }\n  }\n  return(TRUE)\n}\n</code>\n<|/ a tags=r,sorting |>\n\
    <| c |>\nWhile this code may answer the question, providing additional context\
    \ regarding why and/or how this code answers the question improves its long-term\
    \ value.\n<|/ c |>\n<| a dscore=0 |>\n<code>\nis_monotonic <- function(x) {\n\
    \  n <- length(x)\n  i <- 1\n  while (i <= n) {\n    if (x[i] < x[i-1]) {\n  \
    \    i <- i + 1\n    } else if (x[i] > x[i-1]) {\n      i <- i + 1\n    } else\
    \ {\n      i <- i + 1\n    }\n  }\n  return(TRUE)\n}\n</code>\n<|/ a tags=r,sorting\
    \ |>\n<| a dscore=0 |>\n<code>\nis_monotonic <- function(x) {\n  n <- length(x)\n\
    \  i <- 1\n  while (i <= n) {\n    if (x[i] < x[i-1]) {\n      i <- i + 1\n  \
    \  } else if (x[i] > x[i-1]) {\n      i <- i + 1\n    } else {\n      i <- i +\
    \ 1\n    }\n  }\n  return(TRUE)\n}\n</code>\n<|/ a tags=r,sorting |>\n<| c |>\n\
    While this code may answer the question, providing additional context regarding\
    \ why and/or how this code answers the question improves its long-term value.\n\
    <|/ c |>", "\n  n <- length(l) - 1\n  i <- 1\n  while (i <= n) {\n    if (l[i]\
    \ < l[i - 1]) {\n      i <- i + 1\n    } else {\n      i <- i + 1\n      break\n\
    \    }\n  }\n  return(TRUE)\n}\n</code>\n<|/ a tags=r |>\n<| c |>\nThanks for\
    \ your answer! I didn't know about `rle` before. Unfortunately, it seems that\
    \ `rle` doesn't work on vectors of length greater than 2. Any ideas on how to\
    \ make it work?\n<|/ c |>\n<| c |>\nI added a function that should work for vectors\
    \ of length greater than 2.\n<|/ c |>\n<| c |>\nThanks for your answer! Unfortunately,\
    \ it seems that `rle` doesn't work on vectors of length greater than 2. Any ideas\
    \ on how to make it work?\n<|/ c |>\n<| c |>\nI added a function that should work\
    \ for vectors of length greater than 2.\n<|/ c |>\n<| c |>\nThanks for your answer!\
    \ Unfortunately, it seems that `rle` doesn't work on vectors of length greater\
    \ than 2. Any ideas on how to make it work?\n<|/ c |>\n<| a tags=r |>\nHere is\
    \ a solution using rle:\n<code>\nrle <- function(x){\n  r <- rle(x)\n  r$values\
    \ <- r$values*r$lengths\n  r$values <- r$values[order(r$values)]\n  r$values <-\
    \ r$values[!duplicated(r$values)]\n  r$values <- r$values[!is.na(r$values)]\n\
    \  return(r)\n}\n\nx <- c(1,2,4,20)\nrle(x)\n</code>\n<|/ a dscore=2 |>\n<| c\
    \ |>\nThanks for your answer! Unfortunately, it seems that `rle` doesn't work\
    \ on vectors of length greater than 2. Any ideas on how to make it work?\n<|/\
    \ c |>\n<| c |>\nI added a function that should work for vectors of length greater\
    \ than 2.\n<|/ c |>\n<| a tags=r |>\nHere's a solution using rle:\n<code>\nrle\
    \ <- function(x){\n  r <- rle(x)\n  r$values <- r$values*r$lengths\n  r$values\
    \ <- r$values[order(r$values)]\n  r$values <- r$values[!duplicated(r$values)]\n\
    \  r$values <- r$values[!is.na(r$values)]\n  return(r)\n}\n\nx <- c(1,2,4,", "\n\
    \  l <- sort(l)\n  diffs <- c(l[1], diff(l))\n  all(diffs >= 0)\n}\n", "\n  l\
    \ <- sort(l)\n  diffs <- c(l[-1] - l[-length(l)], 0)\n  all(diffs >= 0)\n}\n</code>\n\
    <|/ a tags=r |>\n<| c |>\nI like your answer, but I think it would be better to\
    \ give an explanation of what it does and why it works.\n<|/ c |>\n<| c |>\nI\
    \ added some explanation.\n<|/ c |>\n<| c |>\nI like your answer, but I think\
    \ it would be better to give an explanation of what it does and why it works.\n\
    <|/ c |>\n<| c |>\nI added some explanation.\n<|/ c |>\n<| a dscore=3 |>\nI like\
    \ using dplyr::lag to compare the previous value to the current one:\n<code>\n\
    library(dplyr)\ndf %>% mutate(is_increasing = lag(val) == val)\n</code>\n<|/ a\
    \ tags=r |>\n<| a |>\nHere is a base R solution using diff:\n<code>\nx <- c(1,2,4,20)\n\
    x[-1] - x[-length(x)]", "\n  l <- sort(l)\n  diffs <- diff(l) < 0\n  all(diffs)\
    \ || all(diffs[c(TRUE, FALSE)])\n}\n", "\n  l <- sort(l)\n  all(diff(l)>0)\n}\n\
    </code>\n<|/ a dscore=5 |>\n<| c |>\nI like this solution, but I wonder if there\
    \ is a way to make it more efficient. For example, `monotonic(1:10)` returns `TRUE`\
    \ but `monotonic(1:100)` returns `FALSE`. Is there a way to make it more efficient?\n\
    <|/ c |>\n<| c |>\nI guess you could do something like `all(diff(sort(x))>0)`\
    \ but that seems pretty inefficient.\n<|/ c |>\n<| c |>\n`all(diff(sort(x))>0)`\
    \ works but is inefficient. `all(diff(sort(x))>0)` takes about a second on my\
    \ computer.\n<|/ c |>\n<| c |>\nI guess `all(diff(sort(x))>0)` would be the most\
    \ efficient solution. `all(diff(sort(x))>0)` takes about a second on my computer.\n\
    <|/ c |>\n<| c |>\nI guess `all(diff(sort(x))>0)` would be the most efficient\
    \ solution. `all(diff(sort(x))>0)` takes about a second on my computer.\n<|/ c\
    \ |>\n<| a dscore=5 tags=r,sorting |>\nThe package data.table has a function called\
    \ is.increasing which does exactly what you want.\n<code>\nlibrary(data.table)\n\
    is.increasing(1:10)\n[1] TRUE\nis.increasing(1:100)\n[1] FALSE\n</code>\n<|/ a\
    \ |>\n<| c |>\n`data.table` also has a `is.decreasing` function\n<|/ c |>\n<|\
    \ c |>\n`is.decreasing` also exists in `data.table`\n<|/ c |>\n<| c |>\n`is.increasing`\
    \ also exists in `data.table`\n<|/ c |>\n<| a tags=r,sorting |>\nA simple solution\
    \ that works well for me:\n<code>\nis.increasing <- function(x) {\n  x <- sort(x)\n\
    \  all(diff(x) > 0)\n}\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis should be the\
    \ accepted answer. `is.increasing` returns `TRUE` when `x <- c(1,2,3,4,5,6,7,8,9,10)`\
    \ and `x <- c(1,2,3,4,5,6,7,8,9,10,11)` but returns `FALSE` when `x <- c(1,2,3,4,5,6,7,8,9,10,11,12)`.\n\
    <|/ c |>\n<| a dscore=5 |>\nA simple solution using diff:\n", "\n  l <- sort(l)\n\
    \  diffs <- diff(l) > 0\n  all(diffs) || (all(diffs[1:(length(diffs)-1)]) & all(diffs[2:length(diffs)]))\n\
    }\n", "\n  l <- sort(l)\n  diffs <- c(l[1], diff(l))\n  all(diffs > 0)\n}\n",
  "\n  l <- sort(l)\n  diffs <- c(l[-1] - l[-length(l)], 0)\n  all(diffs >= 0)\n}\n\
    </code>\n<|/ a tags=r,sorting |>\n<| c |>\nThis doesn't seem to work if you have\
    \ a list with only two elements. `monotonic(c(4,1))` returns `FALSE` but `monotonic(c(4,1,2))`\
    \ returns `TRUE`.\n<|/ c |>\n<| c |>\nI added a fix for that case\n<|/ c |>\n\
    <| c |>\nI added a fix for that case\n<|/ c |>\n<| a dscore=5 |>\nThe R package\
    \ monotone does this for you:\n<code>\nlibrary(monotone)\nmonotone(c(4,1,2))\n\
    [1] TRUE\n</code>\n<|/ a tags=r,sorting |>\n<| c |>\nThis package is no longer\
    \ maintained.\n<|/ c |>\n<| c |>\nThe package is still maintained and works as\
    \ of 2019.\n<|/ c |>\n<| c |>\nThe package is still maintained and works as of\
    \ 2019.\n<|/ c |>\n<| a |>\n<code>\nmonotone <- function(x){\n  x <- sort(x)\n\
    \  diffs <- c(tail(x, -1) - head(x, -1), 0)\n  all(diffs >= 0)\n}\n</code>\n<|/\
    \ a tags=r,sorting dscore=4 |>\n<| a tags=r,sorting |>\n<code>\nmonotone <- function(x){\n\
    \  x <- sort(x)\n  diffs <- c(tail(x, -1) - head(x, -1), 0)\n  all(diffs >= 0)\n\
    }\n</code>\n<|/ a dscore=4 |>\n<| c |>\nThis doesn't seem to work if you have\
    \ a list with only two elements. `monotone(c(4,1))` returns `FALSE` but `monotone(c(4,1,2))`\
    \ returns `TRUE`.\n<|/ c |>\n<| c |>\nI added a fix for that case\n<|/ c |>\n\
    <| a tags=r,sorting |>\n<code>\nmonotone <- function(x){\n  x <- sort(x)\n  diffs\
    \ <- c(tail(x, -1) - head(x, -1), 0)\n  all(diffs >= 0)\n}\n</code>\n<|/ a dscore=3\
    \ |>\n<| a dscore=3 |>\n<code>\nmonotone <- function(x){\n  x <- sort(x)\n  diffs\
    \ <- c(tail(x, -1) - head(x, -1), 0)\n  all(diffs >= 0)", "\n  l <- sort(l)\n\
    \  diffs <- diff(l) > 0\n  all(diffs) || all(diffs[c(TRUE, FALSE)])\n}\n</code>\n\
    <|/ a dscore=4 |>\n<| c |>\nI like your solution, but I wonder if it would be\
    \ possible to make it more efficient by not sorting the list twice. Sorting twice\
    \ is O(n log n), but sorting once is O(n).\n<|/ c |>\n<| c |>\nI agree that sorting\
    \ twice is O(n log n), but sorting once is O(n). Sorting twice is O(n log n) because\
    \ of the `sort` function, but sorting once is O(n) because of the `diff` function.\
    \ I think sorting twice is O(n log n) because of the `sort` function, but sorting\
    \ once is O(n) because of the `diff` function.\n<|/ c |>\n<| c |>\nI agree that\
    \ sorting twice is O(n log n), but sorting once is O(n). Sorting twice is O(n\
    \ log n) because of the `sort` function, but sorting once is O(n) because of the\
    \ `diff` function. I think sorting twice is O(n log n) because of the `sort` function,\
    \ but sorting once is O(n) because of the `diff` function.\n<|/ c |>\n<| c |>\n\
    I agree that sorting twice is O(n log n), but sorting once is O(n). Sorting twice\
    \ is O(n log n) because of the `sort` function, but sorting once is O(n) because\
    \ of the `diff` function. I think sorting twice is O(n log n) because of the `sort`\
    \ function, but sorting once is O(n) because of the `diff` function.\n<|/ c |>\n\
    <| c |>\nI agree that sorting twice is O(n log n), but sorting once is O(n). Sorting\
    \ twice is O(n log n) because of the `sort` function, but sorting once is O(n)\
    \ because of the `diff` function. I think sorting twice is O(n log n) because\
    \ of the `sort` function, but sorting once is O(n) because of the `diff` function.\n\
    <|/ c |>\n<| a tags=r,sorting |>\nHere's a solution using data.table:\n<code>\n\
    library(data.table)\ndt <- data.table(\n  x = c(1,2,4,20),\n  y = c(1,20,4,10)\n\
    )\n\ndt[", "\n  l <- sort(l)\n  diffs <- c(l[-1] - l[-length(l)], 0)\n  all(diffs\
    \ >= 0) & all(diffs <= 1)\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nI like this\
    \ solution. I'm going to try it out and see how it performs.\n<|/ c |>\n<| c |>\n\
    I added a benchmark test to the answer. `monotonic` was the winner by far.\n<|/\
    \ c |>\n<| a tags=r,sorting |>\nHere's a solution using data.table:\n<code>\n\
    library(data.table)\ndt <- data.table(\n  x = c(1,2,4,5,7,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216",
  "\n  l <- sort(l)\n  l[c(TRUE, diff(l) > 0)]\n}\n</code>\n<|/ a tags=r,list,sorting\
    \ |>\n<| c |>\nThanks so much for this. I really appreciate it. I was able to\
    \ get it to work by changing the last line to `l[c(TRUE, diff(l) > 0)]`\n<|/ c\
    \ |>\n<| c |>\nYes, I forgot to add `TRUE` at the end. Thanks for pointing that\
    \ out.\n<|/ c |>\n<| a |>\nI came up with a solution using sapply and diff:\n\
    <code>\nsapply(l, function(x) all(diff(x) > 0))\n</code>\n<|/ a dscore=2 tags=r,list,sorting\
    \ |>\n<| a dscore=2 |>\nHere's a solution using purrr::map\n<code>\nlibrary(purrr)\n\
    \nl <- list(c(1,2,4,10), c(1,20,4,10), c(4,1,0,-10))\n\nmap(l, function(x) all(diff(x)\
    \ > 0))\n</code>\n<|/ a tags=r,list,sorting |>\n<| a tags=r,list,sorting |>\n\
    Here's a solution using purrr::reduce\n<code>\nlibrary(purrr)\n\nl <- list(c(1,2,4,10),\
    \ c(1,20,4,10), c(4,1,0,-10))\n\nreduce(l, function(x, y) {\n  all(diff(x) > 0)\n\
    })\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2 |>\nHere is a solution using purrr::reduce:\n\
    <code>\nlibrary(purrr)\n\nl <- list(c(1,2,4,10), c(1,20,4,10), c(4,1,0,-10))\n\
    \nreduce(l, function(x, y) {\n  all(diff(x) > 0)\n})\n</code>\n<|/ a tags=r,list,sorting\
    \ |>\n<| a tags=r,list,sorting |>\nHere is a solution using purrr::reduce\n<code>\n\
    library(purrr)\n\nl <- list(c(1,2,4,10), c(1,20,4,10), c(4,1,0,-10))\n\nreduce(l,\
    \ function(x, y) {\n  all(diff(x) > 0)\n})\n</code>\n<|/ a dscore=1 |>\n<| a tags=r,list,sorting\
    \ |>\nHere is a solution using purrr::reduce\n<code>\nlibrary(purrr)\n\nl <- list(c(1,2,4,10),\
    \ c(1,20,4,10), c(4,1,0,-10))\n\nreduce(l, function(x, y) {\n  all(diff(x) > 0)\n\
    })\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\nHere is a solution using purrr",
  "\n  l <- sort(l)\n  diffs <- c(l[1], diff(l), l[length(l)])\n  all(diffs >= 0)\n\
    }\n</code>\n<|/ a dscore=4 |>\n<| c |>\nI like this solution, but I wonder if\
    \ there is a way to make it more efficient? I mean it does a lot of unnecessary\
    \ comparisons.\n<|/ c |>\n<| c |>\nI added a version that does less comparisons.\n\
    <|/ c |>\n<| c |>\nI added a version that does less comparisons.\n<|/ c |>\n<|\
    \ a tags=r,sorting |>\n<code>\nmonotonic<-function(x){\n  x<-sort(x)\n  y<-c(0,diff(x),0)\n\
    \  y<-c(y,y[1],y[2])\n  y<-c(y,y[1],y[2])\n  y<-c(y,y[1],y[2])\n  y<-c(y,y[1],y[2])\n\
    \  y<-c(y,y[1],y[2])\n  y<-c(y,y[1],y[2])\n  y<-c(y,y[1],y[2])\n  y<-c(y,y[1],y[2])\n\
    \  y<-c(y,y[1],y[2])\n  y<-c(y,y[1],y[2])\n  y<-c(y,y[1],y[2])\n  y<-c(y,y[1],y[2])\n\
    \  y<-c(y,y[1],y[2])\n  y<-c(y,y[1],y[2])\n  y<-c(y,y[1],y[2])\n  y<-c(y,y[1],y[2])\n\
    \  y<-c(y,y[1],y[2])\n  y<-c(y,y[1],y[2])\n  y<-c(y,y[1],y[2])\n  y<-c(y,y[1],y[2])\n\
    \  y<-c(y,y[1],y[2])\n  y<-c(y,y[1],y[2])\n  y<-c(y,y[1],y[2])\n  y<-c(y,y[1],y[2])\n\
    \  y<-c(y,y[1],y[2])\n  y<-c(y,y[1],y[2])\n  y<-c(y,y[1],y[2])\n  y<-c(y,y[1],y[2])\n\
    \  y<-c(y,y[1],y[2])\n  y<-c(y,y[1],y[2])\n  y<-c(y,y[1],y[2])\n  y<-c(y,y[1],y[2])\n\
    \  y<-c(y,y[1],", "\n  l <- sort(l)\n  all(diff(l)>0) || all(diff(l)<0)\n}\n</code>\n\
    <|/ a tags=r,sorting |>\n<| c |>\nThis doesn't seem to work. `monotonic(c(1,2,4,20))`\
    \ returns `FALSE`, but `monotonic(c(1,2,4,10,20))` returns `TRUE`\n<|/ c |>\n\
    <| c |>\nIt works for me on R 3.2.2 on Windows. What version are you using?\n\
    <|/ c |>\n<| c |>\nI'm using R 3.2.2 on Ubuntu 14.04.\n<|/ c |>\n<| c |>\nI guess\
    \ I should have been more clear. I'm running R 3.2.2 on Windows 7. I'll update\
    \ my question to reflect that.\n<|/ c |>\n<| c |>\nI updated my answer to include\
    \ a solution that works on Windows as well.\n<|/ c |>\n<| a dscore=3 |>\nThe R\
    \ package monotone does exactly what you want.\n<code>\nlibrary(monotone)\nmonotone(c(1,2,4,20))",
  "\n  l <- sort(l)\n  l[1] < l[2] & l[2] < l[3] & l[3] < l[4]\n}\n", "\n  l <- sort(l)\n\
    \  l[c(TRUE, diff(l) != 0)]\n}\n</code>\n<|/ a |>\n<| c |>\nThanks for your answer!\
    \ I added a little more explanation to my question. Your answer works great for\
    \ monotonically increasing lists, but not for monotonically decreasing lists.\n\
    <|/ c |>\n<| c |>\nI added a solution for monotonically decreasing lists.\n<|/\
    \ c |>\n<| c |>\nThanks for your answer! I added a little more explanation to\
    \ my question. Your answer works great for monotonically increasing lists, but\
    \ not for monotonically decreasing lists.\n<|/ c |>\n<| c |>\nI added a solution\
    \ for monotonically decreasing lists.\n<|/ c |>\n<| a |>\nHere's a solution using\
    \ data.table:\n<code>\nlibrary(data.table)\ndt <- data.table(x = c(1,2,4,20))\n\
    dt[, y := cummax(x), by = .(x)]\ndt[, y := ifelse(y == max(x), 0, y)]\ndt[, y\
    \ := cumsum(y), by = .(x)]\ndt[, y := ifelse(y == 1, 0, y)]\ndt[, y := cumsum(y),\
    \ by = .(x)]\ndt[, y := ifelse(y == 1, 0, y)]\ndt[, y := cumsum(y), by = .(x)]\n\
    dt[, y := ifelse(y == 1, 0, y)]\ndt[, y := cumsum(y), by = .(x)]\ndt[, y := ifelse(y\
    \ == 1, 0, y)]\ndt[, y := cumsum(y), by = .(x)]\ndt[, y := ifelse(y == 1, 0, y)]\n\
    dt[, y := cumsum(y), by = .(x)]\ndt[, y := ifelse(y == 1, 0, y)]\ndt[, y := cumsum(y),\
    \ by = .(x)]\ndt[, y := ifelse(y == 1, 0, y)]\ndt[, y := cumsum(y), by = .(x)]\n\
    dt[, y := ifelse(y == 1, 0, y)]\ndt[, y := cumsum(y), by = .(x)]\ndt[, y := ifelse(y\
    \ == 1, 0, y)]\ndt[, y := cumsum(y), by = .(x)]\ndt[, y := ifelse(y == 1, 0, y)]\n\
    dt[, y := cumsum(y), by = .(x)]\ndt[", "\n  l <- sort(l)\n  diffs <- c(l[-1],\
    \ NA) - l\n  all(diffs >= 0) & all(diffs <= 0)\n}\n", "\n  l <- sort(l)\n  diffs\
    \ <- c(l[1], diff(l))\n  all(diffs >= 0) & all(diffs <= 0)\n}\n", "\n  l <- sort(l)\n\
    \  l[1] < l[2] || l[1] > l[3]\n}\n</code>\n<|/ a dscore=4 |>\n<| c |>\nThis doesn't\
    \ seem to work for lists with more than 3 elements. `monotonic(list(c(1,2,4,20),\
    \ c(1,20,4,10), c(4,1,0,-10)))` returns `FALSE`.\n<|/ c |>\n<| c |>\nThis doesn't\
    \ seem to work for lists with more than 3 elements. `monotonic(list(c(1,2,4,20),\
    \ c(1,20,4,10), c(4,1,0,-10)))` returns `FALSE`.\n<|/ c |>\n<| c |>\nThis doesn't\
    \ seem to work for lists with more than 3 elements. `monotonic(list(c(1,2,4,20),\
    \ c(1,20,4,10), c(4,1,0,-10)))` returns `FALSE`.\n<|/ c |>\n<| c |>\nThis doesn't\
    \ seem to work for lists with more than 3 elements. `monotonic(list(c(1,2,4,20),\
    \ c(1,20,4,10), c(4,1,0,-10)))` returns `FALSE`.\n<|/ c |>\n<| c |>\nThis doesn't\
    \ seem to work for lists with more than 3 elements. `monotonic(list(c(1,2,4,20),\
    \ c(1,20,4,10), c(4,1,0,-10)))` returns `FALSE`.\n<|/ c |>\n<| a dscore=4 |>\n\
    I wrote a package called monotonic for exactly this purpose. \n<code>\nlibrary(monotonic)\n\
    monotonic(list(c(1,2,4,20), c(1,20,4,10), c(4,1,0,-10)))", "\n  n <- length(l)\
    \ - 1\n  i <- 1\n  while (i <= n) {\n    i <- i + 1\n    if (l[i] < l[i - 1])\
    \ {\n      return(TRUE)\n    }\n    if (l[i] > l[i - 1]) {\n      return(FALSE)\n\
    \    }\n  }\n  return(TRUE)\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis doesn't\
    \ seem to work. `monotonic(c(1,2,4,20))` returns `FALSE`, but `monotonic(c(1,2,4,20,30))`\
    \ returns `TRUE`\n<|/ c |>\n<| c |>\nIt doesn't seem to work if you have a list\
    \ with negative numbers. `monotonic(c(1,2,4,20,-30))` returns `FALSE`, but `monotonic(c(1,2,4,20,-30))`\
    \ returns `TRUE`\n<|/ c |>\n<| c |>\nI added a fix for negative numbers. I tested\
    \ it on `monotonic(c(1,2,4,20,-30))` and it returns `TRUE`.\n<|/ c |>\n<| c |>\n\
    I added a fix for negative numbers. I tested it on `monotonic(c(1,2,4,20,-30))`\
    \ and it returns `TRUE`.\n<|/ c |>\n<| c |>\nI added a fix for negative numbers.\
    \ I tested it on `monotonic(c(1,2,4,20,-30))` and it returns `TRUE`.\n<|/ c |>\n\
    <| a dscore=2 |>\nA simple solution that works on all vectors:\n<code>\nis.monotonic\
    \ <- function(x) all(diff(x) > 0)\n</code>\n<|/ a tags=r,vector |>\n<| c |>\n\
    This doesn't seem to work. `is.monotonic(c(1,2,4,20))` returns `FALSE`, but `is.monotonic(c(1,2,4,20,30))`\
    \ returns `TRUE`\n<|/ c |>\n<| c |>\nIt doesn't seem to work if you have a list\
    \ with negative numbers. `is.monotonic(c(1,2,4,20,-30))` returns `FALSE`, but\
    \ `is.monotonic(c(1,2,4,20,-30))` returns `TRUE`\n<|/ c |>\n<| c |>\nI added a\
    \ fix for negative numbers. I tested it on `is.monotonic(c(1,2,4,20,-30))` and\
    \ it returns `TRUE`.\n<|/ c |>\n<| a dscore=2 |>\nA simple solution that works\
    \ on all vectors:\n<code>\nis.monotonic <- function(x) all(diff(x) > 0)\n</code>",
  "\n  l <- sort(l)\n  diffs <- c(l[-1], NA) - l\n  all(diffs > 0) || all(diffs <\
    \ 0)\n}\n</code>\n<|/ a tags=r,sorting |>\n<| c |>\nThis doesn't seem to work\
    \ when there are two or more consecutive elements that are equal, e.g. `monotonic(c(1,1,2,2))`\
    \ returns `FALSE`.\n<|/ c |>\n<| c |>\nYes, it does. I tested it with `c(1,1,2,2)`\
    \ and it returns `TRUE`.\n<|/ c |>\n<| c |>\nI tested it with `c(1,1,2,2)` and\
    \ it returns `TRUE`. What version of R are you using?\n<|/ c |>\n<| c |>\nI'm\
    \ using R 3.2.3 on Windows 7. Maybe it's different on other platforms.\n<|/ c\
    \ |>\n<| c |>\nI tested it on R 3.2.3 on Windows 7 and it returns `TRUE`. What\
    \ OS are you using?\n<|/ c |>\n<| a dscore=3 |>\nThe answer by is correct, but\
    \ I thought I'd add my own answer since I needed a solution that worked for me\
    \ in R and I thought it might be helpful to others.\nThe answer by is correct,\
    \ but I thought I'd add my own answer since I needed a solution that worked for\
    \ me in R and I thought it might be helpful to others.\n<code>", "\n  l <- sort(l)\n\
    \  diffs <- c(l[1], diff(l), l[length(l)])\n  all(diffs > 0)\n}\n</code>\n<|/\
    \ a tags=r,list,sorting |>\n<| a tags=r,list,sorting |>\nI like using purrr::map()\
    \ for this kind of thing:\n<code>\nlibrary(purrr)\n\nx <- list(a = c(1,2), b =\
    \ c(3,4), c = c(5,6))\nmap(x, function(x) sort(x))\n</code>\n<|/ a dscore=2 |>\n\
    <| a tags=r,list,sorting |>\nHere's a base R option:\n<code>\nx <- list(a = c(1,2),\
    \ b = c(3,4), c = c(5,6))\nsapply(x, sort)\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2\
    \ |>\nHere's a solution using purrr::map and purrr::reduce:\n<code>\nlibrary(purrr)\n\
    \nx <- list(a = c(1,2), b = c(3,4), c = c(5,6))\n\nmap(sort(x), reduce)\n</code>\n\
    <|/ a tags=r,list,sorting |>\n<| a tags=r,list,sorting |>\nHere's a base R option:\n\
    <code>\nx <- list(a = c(1,2), b = c(3,4), c = c(5,6))\nsapply(x, sort)\n</code>\n\
    <|/ a dscore=2 |>\n<| a dscore=2 |>\nWe can use lapply to loop through the list\
    \ elements and sort each of them\n<code>\nlapply(x, sort)\n</code>\n<|/ a tags=r,list,sorting\
    \ |>\n<| a dscore=1 |>\nA base R option\n<code>\nlapply(x, sort)\n</code>\n<|/\
    \ a tags=r,list,sorting |>\n<| a dscore=1 |>\nWe can use lapply with sort\n<code>\n\
    lapply(x, sort)\n</code>\n<|/ a tags=r,list,sorting |>\n<| a dscore=1 |>\nWe can\
    \ use lapply with sort\n<code>\nlapply(x, sort)\n</code>\n<|/ a tags=r,list,sorting\
    \ |>\n<| a dscore=1 |>\nWe can use lapply with sort\n<code>\nlapply(x, sort)\n\
    </code>\n<|/ a tags=r,list,sorting |>\n<| a dscore=1 |>\nWe can use lapply with\
    \ sort\n<code>\nlapply(x, sort)\n</code>\n<|/ a tags=r,list,sorting |>\n<| a tags=r,list,sorting\
    \ |>\nWe can use lapply with sort\n<code>\nlapply(x, sort)\n</code>\n<|/ a dscore=",
  "\n  l <- sort(l)\n  diffs <- c(l[1], diff(l))\n  all(diffs >= 0)\n}\n</code>\n\
    <|/ a dscore=5 |>\n<| c |>\nThis doesn't seem to work for lists with negative\
    \ numbers. `monotonic(list(-2,-1,0,1))` returns `TRUE` but `monotonic(list(-2,-1,0,2))`\
    \ returns `FALSE`\n<|/ c |>\n<| c |>\nIt works for me. `monotonic(list(-2,-1,0,2))`\
    \ returns `FALSE`\n<|/ c |>\n<| c |>\nIt works for me too. `monotonic(list(-2,-1,0,2))`\
    \ returns `FALSE`\n<|/ c |>\n<| c |>\nIt works for me too. `monotonic(list(-2,-1,0,2))`\
    \ returns `FALSE`\n<|/ c |>\n<| c |>\nIt works for me too. `monotonic(list(-2,-1,0,2))`\
    \ returns `FALSE`\n<|/ c |>\n<| a dscore=5 |>\nA simple and fast solution:\n<code>\n\
    is.monotonic <- function(x) all(diff(x) >= 0)\n</code>\n<|/ a tags=r,list,monotonicity\
    \ |>\n<| c |>\nThis doesn't seem to work for lists with negative numbers. `is.monotonic(list(-2,-1,0,1))`\
    \ returns `TRUE` but `is.monotonic(list(-2,-1,0,2))` returns `FALSE`\n<|/ c |>\n\
    <| c |>\nIt works for me. `is.monotonic(list(-2,-1,0,2))` returns `FALSE`\n<|/\
    \ c |>\n<| c |>\nIt works for me too. `is.monotonic(list(-2,-1,0,2))` returns\
    \ `FALSE`\n<|/ c |>\n<| c |>\nIt works for me too. `is.monotonic(list(-2,-1,0,2))`\
    \ returns `FALSE`\n<|/ c |>\n<| c |>\nIt works for me too. `is.monotonic(list(-2,-1,0,2))`\
    \ returns `FALSE`\n<|/ c |>\n<| a dscore=5 |>\n<code>\nis.monotonic = function(x)\
    \ all(diff(x) >= 0)\n</code>\n<|/ a tags=r,list,monotonicity |>\n<| c |>\nThis\
    \ doesn't seem to work for lists with negative numbers. `is.monotonic(list(-2,-1,0,1))`\
    \ returns `TRUE` but `is.monotonic(list(-2,-1,0,2))` returns `", "\n  l <- sort(l)\n\
    \  diffs <- c(l[-1] - l[-length(l)]) # difference between last and second-to-last\
    \ elements\n  all(diffs >= 0) # all differences must be positive\n}\n</code>\n\
    <|/ a tags=r,sorting |>\n<| c |>\nI like your solution, but I wonder if there\
    \ is a way to do this without having to sort the entire vector. I'm thinking along\
    \ the lines of `diff(sort(x))` but that doesn't work.\n<|/ c |>\n<| c |>\nYes,\
    \ I thought of that, but I didn't want to rewrite `sort` so I used `sort` only\
    \ to find the differences. I guess it's just not worth it.\n<|/ c |>\n<| c |>\n\
    I like your solution, but I wonder if there is a way to do this without having\
    \ to sort the entire vector. I'm thinking along the lines of `diff(sort(x))` but\
    \ that doesn't work.\n<|/ c |>\n<| c |>\nI added a solution that doesn't require\
    \ sorting.\n<|/ c |>\n<| c |>\nI like your solution, but I wonder if there is\
    \ a way to do this without having to sort the entire vector. I'm thinking along\
    \ the lines of `diff(sort(x))` but that doesn't work.\n<|/ c |>\n<| a tags=r,sorting\
    \ |>\nHere's a solution using data.table:\n<code>\nlibrary(data.table)\nx <- c(1,2,4,20)\n\
    setDT(as.data.table(x))\nx[, diff := c(tail(x, -1) - head(x, -1)), by = seq_len(.N)]\n\
    x[diff > 0]", "\n  l <- sort(l)\n  diffs <- c(l[-1]-l[-length(l)]) \n  all(diffs\
    \ >= 0) || all(diffs <= 0)\n}\n</code>\n<|/ a tags=r |>\n<| c |>\nI like this\
    \ solution. Very elegant and simple.\n<|/ c |>\n<| c |>\nThis solution doesn't\
    \ work if your vector is `c(NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,",
  "\n  l <- sort(l)\n  diffs <- c(l[-1] - l[-length(l)], 0)\n  all(diffs > 0)\n}\n\
    </code>\n<|/ a tags=r,sorting |>\n<| a dscore=2 |>\n<code>\nmonotonic = function(x)\
    \ {\n  y = c(x[length(x)], x[1])\n  return(all(diff(y) > 0))\n}\n</code>\n<|/\
    \ a tags=r,sorting |>\n<| a tags=r,sorting |>\n<code>\nmonotonic = function(x)\
    \ {\n  y = c(x[length(x)], x[1])\n  return(all(diff(y) > 0))\n}\n</code>\n<|/\
    \ a dscore=2 |>\n<| a dscore=2 |>\n<code>\nmonotonic = function(x) {\n  y = c(x[length(x)],\
    \ x[1])\n  return(all(diff(y) > 0))\n}\n</code>\n<|/ a tags=r,sorting |>\n<| a\
    \ dscore=1 |>\n<code>\nmonotonic = function(x) {\n  y = c(x[length(x)], x[1])\n\
    \  return(all(diff(y) > 0))\n}\n</code>\n<|/ a tags=r,sorting |>\n<| a dscore=1\
    \ |>\n<code>\nmonotonic = function(x) {\n  y = c(x[length(x)], x[1])\n  return(all(diff(y)\
    \ > 0))\n}\n</code>\n<|/ a tags=r,sorting |>\n<| a tags=r,sorting |>\n<code>\n\
    monotonic = function(x) {\n  y = c(x[length(x)], x[1])\n  return(all(diff(y) >\
    \ 0))\n}\n</code>\n<|/ a dscore=1 |>\n<| a tags=r,sorting |>\n<code>\nmonotonic\
    \ = function(x) {\n  y = c(x[length(x)], x[1])\n  return(all(diff(y) > 0))\n}\n\
    </code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\n<code>\nmonotonic = function(x)\
    \ {\n  y = c(x[length(x)], x[1])\n  return(all(diff(y) > 0))\n}\n</code>\n<|/\
    \ a tags=r,sorting |>\n<| a dscore=1 |>\n<code>\nmonotonic = function(x) {\n \
    \ y = c(x[length(x)], x[1])\n  return(all(diff(y) > 0))\n}\n</code>\n<|/ a tags=r,sorting\
    \ |>\n<| a tags=r,sorting |>\n<code>\nmonotonic = function(x) {\n  y = c(x[length(x)],\
    \ x[1])\n  return(all(diff(y) > 0))\n}\n</code>\n<|/ a dscore=1 |>\n<| a ", "\n\
    \  l <- sort(l)\n  diffs <- c(l[-1], NA)\n  diffs[is.na(diffs)] <- 0\n  all(diffs[1:(length(diffs)\
    \ - 1)] < 0)\n}\n</code>\n<|/ a tags=r |>\n<| c |>\nThanks for your answer. Your\
    \ solution works perfectly for monotonic lists, but not for non-monotonic lists.\
    \ For example, `monotonic(c(1,2,4,20))` returns `FALSE`, while `monotonic(c(1,2,4,10,20))`\
    \ returns `TRUE`.\n<|/ c |>\n<| c |>\nI added a solution for non-monotonic lists.\n\
    <|/ c |>\n<| c |>\nThanks for your answer. Your solution works perfectly for monotonic\
    \ lists, but not for non-monotonic lists. For example, `monotonic(c(1,2,4,20))`\
    \ returns `FALSE`, while `monotonic(c(1,2,4,10,20))` returns `TRUE`.\n<|/ c |>\n\
    <| c |>\nI added a solution for non-monotonic lists.\n<|/ c |>\n<| a dscore=1\
    \ |>\nHere's a solution using dplyr and purrr packages:\n<code>\nlibrary(dplyr)\n\
    library(purrr)\n", "\n  l <- sort(l)\n  l[1] < l[2] & l[1] < l[3] & l[2] < l[3]\
    \ & l[1] < l[4]\n}\n</code>\n<|/ a tags=r,sorting |>\n<| c |>\nI like this solution,\
    \ but I wonder if there is a way to make it more efficient by avoiding sorting\
    \ and just checking if each element in the list is in order.\n<|/ c |>\n<| c |>\n\
    I added a function that does just that. Not sure how efficient it is, but it's\
    \ pretty concise.\n<|/ c |>\n<| c |>\nI added a function that does just that.\
    \ Not sure how efficient it is, but it's pretty concise.\n<|/ c |>\n<| a dscore=2\
    \ |>\n<code>\nmonotonic = function(a){\n  a = sort(a)\n  return(all(diff(a) <\
    \ 0))\n}\n</code>\n<|/ a tags=r,sorting |>\n<| a tags=r,sorting |>\n<code>\nmonotonic\
    \ = function(a){\n  a = sort(a)\n  return(all(diff(a) < 0))\n}\n</code>\n<|/ a\
    \ dscore=2 |>\n<| c |>\nThis doesn't seem to work when `a` is `c(1,10,2,3,4)`\n\
    <|/ c |>\n<| a dscore=2 |>\n<code>\nmonotonic = function(a){\n  a = sort(a)\n\
    \  return(all(diff(a) < 0))\n}\n</code>\n<|/ a tags=r,sorting |>\n<| a tags=r,sorting\
    \ |>\n<code>\nmonotonic = function(a){\n  a = sort(a)\n  return(all(diff(a) <\
    \ 0))\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis doesn't seem to work when\
    \ `a` is `c(1,10,2,3,4)`\n<|/ c |>\n<| a tags=r,sorting |>\n<code>\nmonotonic\
    \ = function(a){\n  a = sort(a)\n  return(all(diff(a) < 0))\n}\n</code>\n<|/ a\
    \ dscore=2 |>\n<| a tags=r,sorting |>\n<code>\nmonotonic = function(a){\n  a =\
    \ sort(a)\n  return(all(diff(a) < 0))\n}\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1\
    \ |>\n<code>\nmonotonic = function(a){\n  a = sort(a)\n  return(all(diff(a) <\
    \ 0))\n}\n</code>\n<|/ a tags=r,sorting |>\n<| a tags=r,sorting |>\n<code>\nmonotonic\
    \ = ", "\n  l <- sort(l)\n  l[1] < l[2] || l[1] > l[3]\n}\n", "\n  l <- sort(l)\n\
    \  l[c(TRUE, diff(l) > 0)]\n}\n</code>\n<|/ a tags=r |>\n<| c |>\nI like your\
    \ solution, but I wonder if there is a way to do it without having to sort first.\
    \ Maybe some kind of binary search or something?\n<|/ c |>\n<| c |>\nI added a\
    \ binary search solution to my answer.\n<|/ c |>\n<| c |>\nThanks again! I really\
    \ appreciate it!\n<|/ c |>\n<| a tags=r |>\nHere's a solution using data.table:\n\
    <code>\nlibrary(data.table)\ndt <- data.table(\n  x = c(1,2,4,20),\n  y = c(2,4,1,-10)\n\
    )\n\ndt[, \n  list(\n    increasing = all(x > y),\n    decreasing = all(x < y)\n\
    \  ), \n  by = x\n]\n</code>\n<|/ a dscore=2 |>\n<| a dscore=1 |>\nHere's a solution\
    \ using dplyr and purrr packages:\n<code>\nlibrary(dplyr)\nlibrary(purrr)\n\n\
    df <- data.frame(\n  x = c(1,2,4,20),\n  y = c(2,4,1,-10)\n)\n\ndf %>% \n  mutate(\n\
    \    increasing = map_lgl(x, ~x > y),\n    decreasing = map_lgl(x, ~x < y)\n \
    \ )\n</code>\n<|/ a tags=r |>\n<| a tags=r |>\nHere's a solution using dplyr and\
    \ purrr packages:\n<code>\nlibrary(dplyr)\nlibrary(purrr)\n\ndf <- data.frame(\n\
    \  x = c(1,2,4,20),\n  y = c(2,4,1,-10)\n)\n\ndf %>% \n  mutate(\n    increasing\
    \ = map_lgl(x, ~x > y),\n    decreasing = map_lgl(x, ~x < y)\n  )\n</code>\n<|/\
    \ a dscore=1 |>\n<| a tags=r |>\nHere's a solution using dplyr and purrr packages:\n\
    <code>\nlibrary(dplyr)\nlibrary(purrr)\n\ndf <- data.frame(\n  x = c(1,2,4,20),\n\
    \  y = c(2,4,1,-10)\n)\n\ndf %>% \n  mutate(\n    increasing = map_lgl(x, ~x >\
    \ y),\n    decreasing = map_lgl(x, ~x < y)\n  )\n</code>\n<|/ a dscore=1 |>\n\
    <| a |>\nHere's a solution using dplyr and pur", "\n  l <- sort(l)\n  diffs <-\
    \ c(l[-1]-l[-length(l)]) \n  return(all(diffs < 0))\n}\n</code>\n<|/ a tags=r,list\
    \ |>\n<| a tags=r,list |>\nHere's a solution using purrr::map2\n<code>\nlibrary(purrr)\n",
  "\n  l <- sort(l)\n  diffs <- c(l[-1], NA) - l\n  all(diffs >= 0) & all(diffs <=\
    \ 0)\n}\n</code>\n<|/ a |>\n<| c |>\nThis doesn't seem to work for negative numbers.\
    \ `monotonic(c(-2, -1, 0, 1, 2))` returns `TRUE`, but `monotonic(c(-2, -1, 0,\
    \ 1, -2))` returns `FALSE`.\n<|/ c |>\n<| c |>\nI added a fix for negative numbers.\
    \ Thanks for pointing that out.\n<|/ c |>\n<| c |>\nI added a fix for negative\
    \ numbers. Thanks for pointing that out.\n<|/ c |>\n<| a dscore=5 tags=r |>\n\
    A simple and efficient solution is to use diff:\n<code>\n> x <- c(1,2,4,20)\n\
    > diff(x)\n[1] 1 2 4 0\n> diff(x)>0\n[1] FALSE FALSE FALSE TRUE\n</code>\n<|/\
    \ a |>\n<| c |>\nThis doesn't seem to work for negative numbers. `diff(c(-2, -1,\
    \ 0, 1, 2))` returns `c(-2, -1, 0, 1, 2)`, but `diff(c(-2, -1, 0, 1, -2))` returns\
    \ `c(-2, -1, 0, 1, -2)`.\n<|/ c |>\n<| c |>\nThis doesn't seem to work for negative\
    \ numbers. `diff(c(-2, -1, 0, 1, 2))` returns `c(-2, -1, 0, 1, 2)`, but `diff(c(-2,\
    \ -1, 0, 1, -2))` returns `c(-2, -1, 0, 1, -2)`.\n<|/ c |>\n<| c |>\nThis doesn't\
    \ seem to work for negative numbers. `diff(c(-2, -1, 0, 1, 2))` returns `c(-2,\
    \ -1, 0, 1, 2)`, but `diff(c(-2, -1, 0, 1, -2))` returns `c(-2, -1, 0, 1, -2)`.\n\
    <|/ c |>\n<| c |>\nThis doesn't seem to work for negative numbers. `diff(c(-2,\
    \ -1, 0, 1, 2))` returns `c(-2, -1, 0, 1, 2)`, but `diff(c(-2, -1, 0, 1, -2))`\
    \ returns `c(-2, -1, 0, 1, -2)`.\n<|/ c |>\n<| c |>\nThis doesn't seem to work\
    \ for negative numbers. `diff(c(-2, -1, 0, 1, 2))` returns `c(-2, -1, 0, 1, 2)`,\
    \ but `diff(c(-2, -1, 0, 1, -2))` returns `c(-2, -1, 0, 1, -2)`.\n<|/ c |>\n<|\
    \ a tags=r |>\n<code>\nx <- c(1,2,4,20)\ndiff(x)>0\n</code>\n<|/ a dscore=5 |>\n",
  "\n  n <- length(l);\n  m <- numeric(n);\n  for(i in seq_len(n)) {\n    m[i] <-\
    \ l[i - 1] < l[i] & l[i - 1] > l[i + 1];\n  }\n  return(all(m));\n}\n</code>\n\
    <|/ a tags=r,sorting |>\n<| c |>\nThis doesn't seem to work when `l` is `c(4,\
    \ 1, -10, 2)`\n<|/ c |>\n<| c |>\nIt works fine for me. `monotonic(c(4, 1, -10,\
    \ 2))` returns `TRUE`.\n<|/ c |>\n<| c |>\nI guess I misunderstood your question.\
    \ My apologies. I thought you were asking about a function that returns `TRUE`\
    \ if the list elements are monotonically increasing or decreasing.\n<|/ c |>\n\
    <| c |>\nI edited my answer to include a function that returns `TRUE` if the list\
    \ elements are monotonically increasing or decreasing.\n<|/ c |>\n<| c |>\nThanks\
    \ for your answer. Your function works fine for monotonically increasing lists,\
    \ but not for monotonically decreasing lists. For example: `monotonic(c(4, 1,\
    \ -10, 2))` returns `FALSE` instead of `TRUE`.\n<|/ c |>\n<| a dscore=2 |>\nA\
    \ simple solution would be to sort your list and then compare the sorted list\
    \ with the original list to see if the elements are in order. \n<code>\nx <- c(4,\
    \ 1, -10, 2)\nsort(x)\n[1]  4  1 -10  2\n</code>\n<|/ a tags=r,sorting |>\n<|\
    \ c |>\nThis doesn't seem to work when `l` is `c(4, 1, -10, 2)`\n<|/ c |>\n<|\
    \ c |>\nIt works fine for me. `sort(c(4, 1, -10, 2))` returns `[1]  4  1 -10 \
    \ 2`.\n<|/ c |>\n<| c |>\nI guess I misunderstood your question. My apologies.\
    \ I thought you were asking about a function that returns `TRUE` if the list elements\
    \ are monotonically increasing or decreasing.\n<|/ c |>\n<| a dscore=2 |>\nHere's\
    \ a solution using data.table:\n<code>\nlibrary(data.table)\nx <- c(4, 1, -10,\
    \ 2)\ndt <- data.table(x)\ndt[, `:=`(x = sort(x)), by = seq_along(x)]\ndt[, `:=`(x",
  "\n  l <- sort(l)\n  diffs <- c(l[1], diff(l), l[length(l)])\n  all(diffs > 0)\n\
    }\n</code>\n<|/ a tags=r,sorting |>\n<| c |>\nI like this solution, but I wonder\
    \ if there is a way to do this without having to sort the list twice.  It seems\
    \ like there should be a way to do this with just one pass.\n<|/ c |>\n<| c |>\n\
    I guess I misunderstood the question.  I thought you wanted a function that returned\
    \ TRUE if all elements of the list were monotonically increasing or decreasing.\
    \  I thought you wanted a function that returned TRUE if all elements of the list\
    \ were monotonically increasing or decreasing.  I thought you wanted a function\
    \ that returned TRUE if all elements of the list were monotonically increasing\
    \ or decreasing.  I thought you wanted a function that returned TRUE if all elements\
    \ of the list were monotonically increasing or decreasing.  I thought you wanted\
    \ a function that returned TRUE if all elements of the list were monotonically\
    \ increasing or decreasing.  I thought you wanted a function that returned TRUE\
    \ if all elements of the list were monotonically increasing or decreasing.  I\
    \ thought you wanted a function that returned TRUE if all elements of the list\
    \ were monotonically increasing or decreasing.  I thought you wanted a function\
    \ that returned TRUE if all elements of the list were monotonically increasing\
    \ or decreasing.  I thought you wanted a function that returned TRUE if all elements\
    \ of the list were monotonically increasing or decreasing.  I thought you wanted\
    \ a function that returned TRUE if all elements of the list were monotonically\
    \ increasing or decreasing.  I thought you wanted a function that returned TRUE\
    \ if all elements of the list were monotonically increasing or decreasing.  I\
    \ thought you wanted a function that returned TRUE if all elements of the list\
    \ were monotonically increasing or decreasing.  I thought you wanted a function\
    \ that returned TRUE if all elements of the list were monotonically increasing\
    \ or decreasing.  I thought you wanted a function that returned TRUE if all elements\
    \ of the list were monotonically increasing or decreasing.  I thought you wanted\
    \ a function that returned TRUE if all elements of the list were monotonically\
    \ increasing or decreasing.  I thought you wanted a function that returned TRUE\
    \ if all elements of the list were monotonically increasing or decreas", "\n \
    \ l <- sort(l)\n  diffs <- c(l[-1]-l[-length(l)]) # difference between last and\
    \ first elements\n  all(diffs >= 0) # True if all elements are non-negative\n\
    }\n</code>\n<|/ a |>\n<| c |>\nI like the idea of using diff, but I believe this\
    \ fails for `monotonic([1, 20, 4, 10])` because `diff` returns `c(NA, 2, -2)`\
    \ which is not monotonic (`all(diffs >= 0)` returns `FALSE`). But I guess you\
    \ could use `all(diffs >= 0) + 1` to get it to work.\n<|/ c |>\n<| c |>\nThanks\
    \ for the comment, I've updated my answer accordingly.\n<|/ c |>\n<| a dscore=3\
    \ |>\nA simple and fast solution is to use data.table::rleid to create a grouping\
    \ variable and use that to identify the groups that need to be sorted:\n<code>\n\
    library(data.table)\ndt <- data.table(x = c(1,2,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20))\n\
    dt[, grp := rleid(x)]\ndt[, grp := order(grp)]\ndt[, grp := cumsum(!is.na(grp)),\
    \ by = grp]\n</code>\n<|/ a tags=r,sorting |>\n<| a dscore=2 |>\nA simple solution\
    \ is to use rle to identify the groups and then sort each group:\n<code>\nx <-\
    \ c(1,2,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20)\ngroups <- rle(x)\ngroups\
    \ <- groups[groups[[1]] != groups[[2]]]\ngroups <- sort(groups)\n</code>\n<|/\
    \ a tags=r,sorting |>\n<| a dscore=2 |>\nA simple and fast solution is to use\
    \ data.table::rleid to create a grouping variable and use that to identify the\
    \ groups that need to be sorted:\n<code>\nlibrary(data.table)\ndt <- data.table(x\
    \ = c(1,2,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20))\ndt[, grp := rleid(x)]\n\
    dt[, grp := order(grp)]\ndt[, grp := cumsum(!is.na(grp)), by = grp]\n</code>\n\
    <|/ a tags=r,sorting |>\n<| a dscore=2 |>\nA simple and fast solution is to use\
    \ rle to identify the groups and then sort each group:\n<code>\nx <- c(1,2,4,5,6,7,8,9,10,11,12,13,14,15,16,17,",
  "\n  l <- sort(l)\n  l[1] < l[2] & l[1] < l[3] & l[2] < l[3]\n}\n</code>\n<|/ a\
    \ dscore=4 |>\n<| c |>\nThis doesn't seem to work for `monotonic([1, 20, 4, 10])`\n\
    <|/ c |>\n<| c |>\nYes, it does. I tested it before posting it. I will add some\
    \ more explanation.\n<|/ c |>\n<| c |>\nI tested it again and it doesn't work.\
    \ `monotonic([1, 20, 4, 10])` returns `FALSE`\n<|/ c |>\n<| c |>\nYes, it does.\
    \ I tested it before posting it. I will add some more explanation.\n<|/ c |>\n\
    <| c |>\nI tested it again and it doesn't work. `monotonic([1, 20, 4, 10])` returns\
    \ `FALSE`\n<|/ c |>\n<| a dscore=3 |>\n<code>\nmonotonic(sort(x))\n</code>\n<|/\
    \ a tags=r |>\n<| c |>\nThis doesn't seem to work for `monotonic([1, 20, 4, 10])`\n\
    <|/ c |>\n<| c |>\nIt does for me. `monotonic(sort(x))` returns `TRUE`\n<|/ c\
    \ |>\n<| c |>\nI tested it again and it doesn't work. `monotonic([1, 20, 4, 10])`\
    \ returns `FALSE`\n<|/ c |>\n<| c |>\nI tested it again and it doesn't work. `monotonic([1,\
    \ 20, 4, 10])` returns `FALSE`\n<|/ c |>\n<| c |>\nI tested it again and it doesn't\
    \ work. `monotonic([1, 20, 4, 10])` returns `FALSE`\n<|/ c |>\n<| a tags=r |>\n\
    <code>\nmonotonic(sort(x))\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThis doesn't\
    \ seem to work for `monotonic([1, 20, 4, 10])`\n<|/ c |>\n<| c |>\nIt does for\
    \ me. `monotonic(sort(x))` returns `TRUE`\n<|/ c |>\n<| c |>\nI tested it again\
    \ and it doesn't work. `monotonic([1, 20, 4, 10])` returns `FALSE`\n<|/ c |>\n\
    <| c |>\nI tested it again and it doesn't work. `monotonic([1, 20, 4, 10])` returns\
    \ `FALSE`\n<|/ c |>\n<| a tags=r |>\n<code>\nmonotonic(sort(x))\n</code>\n<|/\
    \ a dscore=", "\n  l <- sort(l)\n  l[c(TRUE, diff(l) != 0)]\n}\n</code>\n<|/ a\
    \ dscore=2 |>\n<| c |>\nThis doesn't seem to work if you have a list with negative\
    \ numbers. `monotonic(c(-2, -1, 0, 1, 2))` returns `[1] -1 0 1 2` instead of `[1]\
    \ -1 0 1 2`.\n<|/ c |>\n<| c |>\nYes, I realized that after I posted my comment.\
    \ I've updated my answer to fix the problem.\n<|/ c |>\n<| a tags=r,list,sorting\
    \ |>\nI like using data.table::rleid for this kind of problem:\n<code>\nx <- list(c(1,2,4,20),\
    \ c(1,20,4,10), c(4,1,0,-10))\ndata.table::rleid(x)", "\n  l <- sort(l)\n  diffs\
    \ <- diff(l) > 0\n  all(diffs) || all(diffs[c(TRUE, FALSE)])\n}\n", "\n  l <-\
    \ sort(l)\n  l[1] < l[2] || (l[1] == l[2] && l[3] < l[4])\n}\n", "\n  l <- sort(l)\n\
    \  diffs <- c(l[1], diff(l))\n  all(diffs > 0)\n}\n</code>\n<|/ a tags=r,sorting\
    \ |>\n<| c |>\nI like your solution, although it only works for monotonic increasing\
    \ lists. I added a solution that works for both increasing and decreasing lists.\n\
    <|/ c |>\n<| c |>\nI added a solution that works for both increasing and decreasing\
    \ lists.\n<|/ c |>\n<| a dscore=3 |>\nHere's a solution using data.table:\n<code>\n\
    library(data.table)\ndt <- data.table(\n  x = c(1,2,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,",
  "\n  l <- sort(l)\n  i <- 1\n  while(i < length(l)) {\n    if(l[i] < l[i-1]) {\n\
    \      i <- i + 1\n    } else {\n      i <- 1\n    }\n  }\n  return(TRUE)\n}\n",
  "\n  l <- sort(l)\n  diffs <- c(l[1], diff(l))\n  all(diffs >= 0)\n}\n", "\n  l\
    \ <- sort(l)\n  diffs <- c(l[-1], NA) - l\n  all(diffs >= 0) & all(diffs <= 0)\n\
    }\n</code>\n<|/ a tags=r,list,sorting |>\n<| c |>\nI like this solution, but I\
    \ wonder if there is a way to avoid the for loop. Maybe `Reduce` could help?\n\
    <|/ c |>\n<| c |>\nYes, `Reduce` could work. `Reduce` will apply a function to\
    \ a list of elements and then return the result of the function applied to the\
    \ last element of the list. `Reduce` will also apply a function to the first element\
    \ of the list and then apply the function to the rest of the list. `Reduce` will\
    \ also apply a function to the first two elements of the list and then apply the\
    \ function to the rest of the list. `Reduce` will also apply a function to the\
    \ first three elements of the list and then apply the function to the rest of\
    \ the list. `Reduce` will also apply a function to the first four elements of\
    \ the list and then apply the function to the rest of the list. `Reduce` will\
    \ also apply a function to the first five elements of the list and then apply\
    \ the function to the rest of the list. `Reduce` will also apply a function to\
    \ the first six elements of the list and then apply the function to the rest of\
    \ the list. `Reduce` will also apply a function to the first seven elements of\
    \ the list and then apply the function to the rest of the list. `Reduce` will\
    \ also apply a function to the first eight elements of the list and then apply\
    \ the function to the rest of the list. `Reduce` will also apply a function to\
    \ the first nine elements of the list and then apply the function to the rest\
    \ of the list. `Reduce` will also apply a function to the first ten elements of\
    \ the list and then apply the function to the rest of the list. `Reduce` will\
    \ also apply a function to the first eleven elements of the list and then apply\
    \ the function to the rest of the list. `Reduce` will also apply a function to\
    \ the first twelve elements of the list and then apply the function to the rest\
    \ of the list. `Reduce` will also apply a function to the first thirteen elements\
    \ of the list and then apply the function to the rest of the list. `Reduce` will\
    \ also apply a function to the first fourteen elements of the list and then apply\
    \ the function to the rest of the list. `Reduce` will also apply a function to\
    \ the first fifteen elements of the list and then apply the function to the rest\
    \ of the list. `Reduce` will also apply a function to the first sixteen elements\
    \ of the list and then apply the function to the rest of the list. `Reduce` will\
    \ also apply a function to the first seventeen elements of the list and then apply\
    \ the function to the rest of the list. `Reduce` will also apply a function to\
    \ the first eighteen elements of the list and then apply the function to the rest\
    \ of the list. `", "\n  l <- sort(l)\n  all(diff(sort(l)) < 0)\n}\n</code>\n<|/\
    \ a dscore=5 |>\n<| c |>\nI like your solution. Just a small comment: if you have\
    \ `NA`s in your vector and want to remove them you can do `is.na(l)` instead of\
    \ `is.na(sort(l))`\n<|/ c |>\n<| c |>\nThis doesn't work for `NA`s because `is.na(sort(l))`\
    \ returns `FALSE` when `l` is `NA`.\n<|/ c |>\n<| c |>\nThis doesn't work for\
    \ `NA`s because `is.na(sort(l))` returns `FALSE` when `l` is `NA`.\n<|/ c |>\n\
    <| c |>\nThis doesn't work for `NA`s because `is.na(sort(l))` returns `FALSE`\
    \ when `l` is `NA`.\n<|/ c |>\n<| c |>\nThis doesn't work for `NA`s because `is.na(sort(l))`\
    \ returns `FALSE` when `l` is `NA`.\n<|/ c |>\n<| a dscore=5 |>\nA simple and\
    \ efficient solution is to use diff:\n<code>\n> x <- c(1,2,4,5,6,7,8,9,10)\n>\
    \ x\n [1]  1  2  4  5  6  7  8  9 10\n> diff(x)\n [1]  1  2  1  1  1  1  1  1\
    \  1\n> diff(x)>0\n [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\
    \ FALSE\n</code>\n<|/ a tags=r,sorting |>\n<| c |>\nThis doesn't work for `NA`s\
    \ because `is.na(diff(x))` returns `FALSE` when `x` is `NA`.\n<|/ c |>\n<| c |>\n\
    This doesn't work for `NA`s because `is.na(diff(x))` returns `FALSE` when `x`\
    \ is `NA`.\n<|/ c |>\n<| c |>\nThis doesn't work for `NA`s because `is.na(diff(x))`\
    \ returns `FALSE` when `x` is `NA`.\n<|/ c |>\n<| c |>\nThis doesn't work for\
    \ `NA`s because `is.na(diff(x))` returns `FALSE` when `x` is `NA`.\n<|/ c |>\n\
    <| c |>\nThis doesn't work for `NA`s because `is.na(diff(x))` returns `FALSE`\
    \ when ", "\n  l <- sort(l)\n  diffs <- c(l[1], diff(l), l[length(l)])\n  all(diffs\
    \ > 0)\n}\n", "\n  l <- sort(l)\n  diffs <- c(l[1], diff(l), l[length(l)])\n \
    \ all(diffs >= 0)\n}\n</code>\n<|/ a tags=r |>\n<| c |>\nThis doesn't seem to\
    \ work when there are NAs in the list. `monotonic(c(NA,1,2,NA,NA,NA))` returns\
    \ `FALSE` instead of `TRUE`.\n<|/ c |>\n<| c |>\nI added a fix for NAs.\n<|/ c\
    \ |>\n<| a dscore=3 |>\nA simple and efficient solution using data.table:\n<code>\n\
    library(data.table)\ndt <- data.table(x = c(1,2,3,4,5,6,7,8,9,10))\ndt[, y :=\
    \ c(NA, diff(x)), by = cumsum(c(1, diff(x) != 0))]\n</code>\n<|/ a tags=r |>\n\
    <| a tags=r |>\nA simple and efficient solution using data.table:\n<code>\nlibrary(data.table)\n\
    dt <- data.table(x = c(1,2,3,4,5,6,7,8,9,10))\ndt[, y := c(NA, diff(x)), by =\
    \ cumsum(c(1, diff(x) != 0))]\n</code>\n<|/ a dscore=3 |>\n<| a |>\nHere is a\
    \ solution using dplyr and purrr packages:\n<code>\nlibrary(dplyr)\nlibrary(purrr)\n\
    \nx <- c(1,2,3,4,5,6,7,8,9,10)\nx <- c(x, NA)\n\nx %>% \n  map_int(~.x - lag(.x,\
    \ default = first(.x)) > 0) %>% \n  reduce(`&`) %>% \n  any() \n</code>\n<|/ a\
    \ dscore=2 tags=r |>\n<| a dscore=2 |>\nHere's a solution using base R:\n<code>\n\
    x <- c(1,2,3,4,5,6,7,8,9,10)\nx <- c(x, NA)\n\nx <- c(x[-1], NA)\nx <- c(x[-length(x)],\
    \ NA)\nx <- c(x[-length(x)], NA)\nx <- c(x[-length(x)], NA)\nx <- c(x[-length(x)],\
    \ NA)\nx <- c(x[-length(x)], NA)\nx <- c(x[-length(x)], NA)\nx <- c(x[-length(x)],\
    \ NA)\nx <- c(x[-length(x)], NA)\nx <- c(x[-length(x)], NA)\nx <- c(x[-length(x)],\
    \ NA)\nx <- c(x[-length(x)], NA)\nx <- c(x[-", "\n  l <- sort(l)\n  l[c(TRUE,\
    \ diff(l) != 0)]\n}\n</code>\n<|/ a |>\n<| a tags=r,sorting |>\nHere is a solution\
    \ that is more efficient than sorting the entire vector and only then finding\
    \ the first and last elements:\n<code>\nmonotonic_inc <- function(x) {\n  x <-\
    \ sort(x)\n  i <- which(x == x[1])\n  j <- which(x == x[nrow(x)])\n  i <- min(i,\
    \ j)\n  i <- max(i, j)\n  i <- i + 1\n  i <- i - 1\n  x[i]\n}\n</code>\n<|/ a\
    \ dscore=2 |>\n<| a tags=r,sorting |>\nI came up with a solution which does not\
    \ require sorting the entire vector:\n<code>\nmonotonic_inc <- function(x) {\n\
    \  i <- which(x == x[1])\n  j <- which(x == x[nrow(x)])\n  i <- min(i, j)\n  i\
    \ <- max(i, j)\n  i <- i + 1\n  i <- i - 1\n  x[i]\n}\n</code>\n<|/ a dscore=2\
    \ |>\n<| a tags=r,sorting |>\nHere is a solution that is more efficient than sorting\
    \ the entire vector and only then finding the first and last elements:\n<code>\n\
    monotonic_inc <- function(x) {\n  x <- sort(x)\n  i <- which(x == x[1])\n  j <-\
    \ which(x == x[nrow(x)])\n  i <- min(i, j)\n  i <- max(i, j)\n  i <- i + 1\n \
    \ i <- i - 1\n  x[i]\n}\n</code>\n<|/ a dscore=2 |>\n<| a tags=r,sorting |>\n\
    I came up with a solution which does not require sorting the entire vector:\n\
    <code>\nmonotonic_inc <- function(x) {\n  i <- which(x == x[1])\n  j <- which(x\
    \ == x[nrow(x)])\n  i <- min(i, j)\n  i <- max(i, j)\n  i <- i + 1\n  i <- i -\
    \ 1\n  x[i]\n}\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\nI came up with a\
    \ solution that does not require sorting the entire vector:\n<code>\nmonotonic_inc\
    \ <- function(x) {\n  i <- which(x == x[1])\n  j <- which(x == x[nrow(x)])\n \
    \ i <- min(i, j)\n  i <- max(i, j)\n  i <- i + 1\n  ", "\n  l <- sort(l)\n  diffs\
    \ <- c(l[-1], NA)\n  c(FALSE, diffs[1] < diffs[2], diffs[1] > diffs[2])\n}\n</code>\n\
    <|/ a dscore=4 |>\n<| c |>\nI like this solution, but I wonder if there is a way\
    \ to make it work for vectors of different lengths.\n<|/ c |>\n<| c |>\n: I added\
    \ a version that works for vectors of different lengths.\n<|/ c |>\n<| c |>\n\
    I like your solution, but I wonder if there is a way to make it work for vectors\
    \ of different lengths.\n<|/ c |>\n<| c |>\n: I added a version that works for\
    \ vectors of different lengths.\n<|/ c |>\n<| c |>\nI like your solution, but\
    \ I wonder if there is a way to make it work for vectors of different lengths.\n\
    <|/ c |>\n<| a dscore=4 |>\nHere's a solution using data.table:\n<code>\nlibrary(data.table)\n\
    dt <- data.table(a = c(1,2,4,20), b = c(4,5,6,10))\ndt[, c := c(NA, diff(a), NA),\
    \ by = b]\ndt[, d := c(NA, diff(b), NA), by = a]\ndt[, e := c(NA, diff(c), NA),\
    \ by = a]\ndt[, f := c(NA, diff(d), NA), by = a]\ndt[, g := c(NA, diff(e), NA),\
    \ by = a]\ndt[, h := c(NA, diff(f), NA), by = a]\ndt[, i := c(NA, diff(g), NA),\
    \ by = a]\ndt[, j := c(NA, diff(h), NA), by = a]\ndt[, k := c(NA, diff(i), NA),\
    \ by = a]\ndt[, l := c(NA, diff(k), NA), by = a]\ndt[, m := c(NA, diff(l), NA),\
    \ by = a]\ndt[, n := c(NA, diff(m), NA), by = a]\ndt[, o := c(NA, diff(n), NA),\
    \ by = a]\ndt[, p := c(NA, diff(o), NA), by = a]\ndt[, q := c(NA, diff(p), NA),\
    \ by = a]\ndt[, r := c(NA, diff(q), NA), by = a]\ndt[, s := c(NA, diff(r), NA),\
    \ by = a]\ndt[, t := c(NA, diff(s) + 1, NA), by = a]\ndt[, u := c(", "\n  l <-\
    \ sort(l)\n  l[seq_along(l) == 1]\n}\n</code>\n<|/ a dscore=3 |>\n<| c |>\nI like\
    \ your solution, but I wonder if there is a way to avoid the loop. Maybe some\
    \ `apply` magic?\n<|/ c |>\n<| c |>\nI guess you could do something like `apply(l,\
    \ 1, function(x) all(x[1:2] > x[2:1]))`\n<|/ c |>\n<| c |>\nI guess you could\
    \ do something like `apply(l, 1, function(x) all(x[1:2] > x[2:1]))`\n<|/ c |>\n\
    <| c |>\nI guess you could do something like `apply(l, 1, function(x) all(x[1:2]\
    \ > x[2:1]))`\n<|/ c |>\n<| c |>\nI guess you could do something like `apply(l,\
    \ 1, function(x) all(x[1:2] > x[2:1]))`\n<|/ c |>\n<| a dscore=2 |>\nHere's a\
    \ solution using data.table:\n<code>\nlibrary(data.table)\ndt <- data.table(\n\
    \  x = c(1,2,4,20),\n  y = c(2,4,1,-10),\n  z = c(4,1,0,10)\n)\n\ndt[, \n  all(x\
    \ > y), \n  by = .EACHI\n][\n  all(x < y), \n  by = .EACHI\n]\n", "\n  l <- sort(l)\n\
    \  l[1] < l[2] & l[1] > l[3]\n}\n</code>\n<|/ a tags=r |>\n<| c |>\nThanks for\
    \ your answer! I didn't know about `sort`, but your solution is very elegant,\
    \ and I learned something new. Thanks!\n<|/ c |>\n<| c |>\nI added a solution\
    \ that doesn't require `sort`, but is still O(n).\n<|/ c |>\n<| c |>\nThanks for\
    \ your answer! I didn't know about `sort`, but your solution is very elegant,\
    \ and I learned something new. Thanks!\n<|/ c |>\n<| a tags=r |>\nHere's a solution\
    \ using data.table:\n<code>\nlibrary(data.table)\ndt <- data.table(\n  x = c(1,2,4,10),\n\
    \  y = c(2,4,1,-10)\n)\n\ndt[, \n  is_increasing := x < shift(x, type = \"lead\"\
    ), \n  by = .EACHI\n]\n</code>\nThis gives:\n<code>\n   x y is_increasing\n1:\
    \ 1 2         TRUE\n2: 2 4        FALSE\n3: 4 1        FALSE\n4: 10 0        FALSE\n\
    </code>\n<|/ a dscore=2 |>\n<| c |>\nThanks for your answer! I didn't know about\
    \ `data.table`, but your solution is very elegant, and I learned something new.\
    \ Thanks!\n<|/ c |>\n<| a tags=r |>\nHere's a solution using dplyr and purrr:\n\
    <code>\nlibrary(dplyr)\nlibrary(purrr)\n\ndf <- data.frame(x = c(1,2,4,10), y\
    \ = c(2,4,1,-10))\n\ndf %>%\n  mutate(is_increasing = map2_lgl(x, lag(x, default\
    \ = first(x)), \n                                ~.x < .y))\n\n  x y is_increasing\n\
    1 1 2         TRUE\n2 2 4        FALSE\n3 4 1        FALSE\n4 10 0        FALSE\n\
    </code>\n<|/ a dscore=2 |>\n<| c |>\nThanks for your answer! I didn't know about\
    \ `purrr`, but your solution is very elegant, and I learned something new. Thanks!\n\
    <|/ c |>\n<| a |>\nHere's a solution using dplyr and purrr:\n<code>\nlibrary(dplyr)\n\
    library(purrr)\n\ndf <- data.frame(x = c(1,2,4,10), y = c(2,4,1,-10))\n\ndf %>%\n\
    \  ", "\n  l <- sort(l)\n  diffs <- c(l[1], diff(l))\n  all(diffs > 0)\n}\n</code>\n\
    <|/ a |>\n<| c |>\nThis doesn't work for `monotonic([1, 20, 4, 10])` which should\
    \ return `TRUE` but returns `FALSE`.\n<|/ c |>\n<| c |>\n: I fixed the bug, thanks\
    \ for pointing it out. Now it works.\n<|/ c |>\n<| c |>\nThis doesn't work for\
    \ `monotonic([1, 20, 4, 10])` which should return `TRUE` but returns `FALSE`.\n\
    <|/ c |>\n<| c |>\n: I fixed the bug, thanks for pointing it out. Now it works.\n\
    <|/ c |>\n<| a dscore=4 |>\nA simple and efficient solution using data.table:\n\
    <code>\nlibrary(data.table)\ndt <- data.table(x = c(1,2,4,20))\ndt[, y := c(0,diff(x)),\
    \ by = .(x)]\ndt[, y := ifelse(y == 0, NA, y)]\ndt[, y := ifelse(is.na(y), x,\
    \ y)]\n</code>\n<|/ a tags=r,algorithm,vector |>\n<| c |>\nThis doesn't work for\
    \ `monotonic([1, 20, 4, 10])` which should return `TRUE` but returns `FALSE`.\n\
    <|/ c |>\n<| c |>\n: I fixed the bug, thanks for pointing it out. Now it works.\n\
    <|/ c |>\n<| a tags=r,algorithm,vector |>\nHere's a solution using base R:\n<code>\n\
    x <- c(1,2,4,20)\ny <- c(0,diff(x))\nz <- c(0,diff(y))\nz[is.na(z)] <- x\nz[is.na(z)]\
    \ <- y\nz[is.na(z)] <- x\nz[is.na(z)] <- y\nz", "\n  l <- sort(l)\n  diffs <-\
    \ c(l[1], diff(l), l[length(l)])\n  all(diffs > 0)\n}\n", "\n  l <- sort(l)\n\
    \  diffs <- c(l[1], diff(l))\n  all(diffs >= 0) & all(diffs <= 0)\n}\n</code>\n\
    <|/ a tags=r,sorting |>\n<| c |>\nThis doesn't seem to work. `monotonic(c(1,2,4,20))`\
    \ returns `FALSE` but `monotonic(c(1,2,4,20,20))` returns `TRUE`.\n<|/ c |>\n\
    <| c |>\n, you are right. I was thinking about a vector with only one element.\
    \ Fixed now.\n<|/ c |>\n<| c |>\nThis doesn't seem to work. `monotonic(c(1,2,4,20))`\
    \ returns `FALSE` but `monotonic(c(1,2,4,20,20))` returns `TRUE`.\n<|/ c |>\n\
    <| c |>\n, you are right. I was thinking about a vector with only one element.\
    \ Fixed now.\n<|/ c |>\n<| a dscore=5 |>\nThe answer by is great, but I thought\
    \ I'd add an alternative that doesn't require sorting the entire vector. \n<code>\n\
    monotonic2 <- function(x) {\n  i <- 1\n  while(i < length(x)) {\n    if(diff(x[(i+1):length(x)])\
    \ < 0) {\n      i <- i + 1\n    } else {\n      i <- i + 1\n      break\n    }\n\
    \  }\n  return(TRUE)\n}\n</code>\n<|/ a tags=r,sorting |>\n<| c |>\nThis doesn't\
    \ seem to work. `monotonic2(c(1,2,4,20))` returns `FALSE` but `monotonic2(c(1,2,4,20,20))`\
    \ returns `TRUE`.\n<|/ c |>\n<| c |>\n, you are right. I was thinking about a\
    \ vector with only one element. Fixed now.\n<|/ c |>\n<| c |>\nThis doesn't seem\
    \ to work. `monotonic2(c(1,2,4,20))` returns `FALSE` but `monotonic2(c(1,2,4,20,20))`\
    \ returns `TRUE`.\n<|/ c |>\n<| c |>\n, you are right. I was thinking about a\
    \ vector with only one element. Fixed now.\n<|/ c |>\n<| c |>\nThis doesn't seem\
    \ to work. `monotonic2(c(1,2,4,20))` returns `FALSE` but `monotonic2(c(1,2,4,20,20))`\
    \ returns `TRUE`.\n<|/ c |>\n<| a tags=r,sorting |>\nHere's a function that will\
    \ do what you want:\n<code>\nmonotonic <- function(x) {\n  i <- 1\n  while(",
  "\n  l <- sort(l)\n  l[c(TRUE, diff(l) != 0)]\n}\n", "\n  l <- sort(l)\n  l[c(TRUE,\
    \ diff(l)>0)]\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nI like this solution, but\
    \ I wonder if there is a way to make it more efficient by avoiding sorting.\n\
    <|/ c |>\n<| c |>\nI added a solution that avoids sorting.\n<|/ c |>\n<| a tags=r,sorting\
    \ |>\nHere's a solution that avoids sorting.\n<code>\nmonotonic2 <- function(x)\
    \ {\n  y <- x\n  y[1] <- NA\n  y[-1] <- NA\n  y <- na.omit(y)\n  y[1] <- y[1]\
    \ > y[2]\n  y[-1] <- y[-1] > y[-length(y)]\n  y\n}\n</code>\n<|/ a dscore=2 |>\n\
    <| c |>\nI like this solution, but I wonder if there is a way to make it more\
    \ efficient by avoiding sorting.\n<|/ c |>\n<| c |>\nI added a solution that avoids\
    \ sorting.\n<|/ c |>\n<| a tags=r,sorting |>\nHere's a solution using dplyr and\
    \ purrr packages:\n<code>\nlibrary(dplyr)\nlibrary(purrr)\n\nmonotonic2 <- function(x)\
    \ {\n  x %>% \n    map_dbl(function(x) ifelse(is.na(x), NA, x)) %>% \n    map_dbl(function(x)\
    \ ifelse(is.na(x), NA, sort(x)))\n}\n\nmonotonic2(c(NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,",
  "\n  l <- sort(l)\n  l[c(TRUE, diff(l) > 0)]\n}\n</code>\n<|/ a dscore=3 |>\n<|\
    \ c |>\nThis doesn't seem to work. `monotonic(1:10)` returns `[1]  1  2  3  4\
    \  5  6  7  8  9 10` but `monotonic(1:10)[c(TRUE, diff(1:10) > 0)]` returns `[1]\
    \  1  2  3  4  5  6  7  8  9 10`\n<|/ c |>\n<| c |>\n: You're right. I was thinking\
    \ about a vector rather than a list. I've updated my answer.\n<|/ c |>\n<| c |>\n\
    Thanks for your answer. I've updated my question to include a more general case\
    \ for lists.\n<|/ c |>\n<| c |>\n: I've updated my answer to include a more general\
    \ case for lists.\n<|/ c |>\n<| c |>\nThanks for your answer. I've updated my\
    \ question to include a more general case for lists.\n<|/ c |>\n<| a tags=r |>\n\
    Here's a solution using base R:\n<code>\nmonotonic <- function(x) {\n  y <- x\n\
    \  y[1] <- NA\n  y[-1] <- c(y[-1], NA)\n  y <- na.omit(y)\n  y <- y[order(y)]\n\
    \  y[1] <- NA\n  y[-1] <- c(y[-1], NA)\n  y <- na.omit(y)\n  y <- y[order(y)]\n\
    \  y[1] <- NA\n  y[-1] <- c(y[-1], NA)\n  y <- na.omit(y)\n  y <- y[order(y)]\n\
    \  y[1] <- NA\n  y[-1] <- c(y[-1], NA)\n  y <- na.omit(y)\n  y <- y[order(y)]\n\
    \  y[1] <- NA\n  y[-1] <- c(y[-1], NA)\n  y <- na.omit(y)\n  y <- y[order(y)]\n\
    \  y[1] <- NA\n  y[-1] <- c(y[-1], NA)\n  y <- na.omit(y)\n  y <- y[order(y)]\n\
    \  y[1] <- NA\n  y[-1] <- c(y[-1], NA)\n  y <- na.omit(y)\n  y <- y[order(y)]\n\
    \  y[1] <- NA\n  y[-1] <- ", "\n  l <- sort(l)\n  diffs <- diff(l) > 0\n  all(diffs)\n\
    }\n", "\n  l <- sort(l)\n  i <- 1\n  while(i < length(l)) {\n    if(l[i] < l[i\
    \ - 1]) {\n      i <- i + 1\n    } else {\n      i <- i + 1\n      if(l[i] > l[i\
    \ - 1]) {\n        i <- i + 1\n      }\n    }\n  }\n  return(TRUE)\n}\n</code>\n\
    <|/ a tags=r,sorting |>\n<| c |>\nThis doesn't seem to work. `monotonic(c(1,2,4,20))`\
    \ returns `FALSE` instead of `TRUE`.\n<|/ c |>\n<| c |>\n, thanks for pointing\
    \ that out. I've corrected the code. Now it works.\n<|/ c |>\n<| c |>\n, thanks\
    \ for pointing that out. I've corrected the code. Now it works.\n<|/ c |>\n<|\
    \ a dscore=2 |>\nHere's a solution using data.table:\n<code>\nlibrary(data.table)\n\
    dt <- data.table(a = c(1,2,4,20))\ndt[order(a), .I]", "\n  l <- sort(l)\n  l[c(TRUE,\
    \ diff(l)) == 1]\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis is great, thank\
    \ you! I added a small modification to allow for negative numbers and to allow\
    \ for non-numeric inputs. I added the code to the original post.\n<|/ c |>\n<|\
    \ a dscore=1 |>\nHere's a function that will do what you want:\n<code>\nmonotonic_inc\
    \ <- function(x) {\n  x <- sort(x)\n  x[x == x[1]] <- NA\n  x[x == x[-length(x)]]\
    \ <- NA\n  x\n}\n</code>\n<|/ a tags=r,sorting |>\n<| c |>\nThis doesn't work\
    \ if `x` is `c(1,3,5,2,4)`\n<|/ c |>\n<| c |>\nIt does work if `x` is `c(1,3,5,2,4)`\n\
    <|/ c |>\n<| c |>\nIt does work if `x` is `c(1,3,5,2,4)`\n<|/ c |>\n<| c |>\n\
    It does work if `x` is `c(1,3,5,2,4)`\n<|/ c |>\n<| c |>\nIt does work if `x`\
    \ is `c(1,3,5,2,4)`\n<|/ c |>\n<| a dscore=1 |>\nHere's a function that will do\
    \ what you want:\n<code>\nmonotonic_inc <- function(x) {\n  x <- sort(x)\n  x[x\
    \ == x[1]] <- NA\n  x[x == x[-length(x)]] <- NA\n  x\n}\n</code>\n<|/ a tags=r,sorting\
    \ |>\n<| a tags=r,sorting |>\nHere's a function that will do what you want:\n\
    <code>\nmonotonic_inc <- function(x) {\n  x <- sort(x)\n  x[x == x[1]] <- NA\n\
    \  x[x == x[-length(x)]] <- NA\n  x\n}\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0\
    \ |>\nHere's a function that will do what you want:\n<code>\nmonotonic_inc <-\
    \ function(x) {\n  x <- sort(x)\n  x[x == x[1]] <- NA\n  x[x == x[-length(x)]]\
    \ <- NA\n  x\n}\n</code>\n<|/ a tags=r,sorting |>\n<| a tags=r,sorting |>\nHere's\
    \ a function that will do what you want:\n<code>\nmonotonic_inc <- function(x)\
    \ {\n  x <- sort(x)\n", "\n  l <- sort(l)\n  diffs <- c(l[-1], NA)\n  diffs[which(diffs\
    \ < 0)] <- 0\n  all(diffs == diffs[1])\n}\n</code>\n<|/ a dscore=3 |>\n<| c |>\n\
    This doesn't seem to work when `l` is `c(NA, 1, NA)`\n<|/ c |>\n<| c |>\nI added\
    \ a fix for that case.\n<|/ c |>\n<| c |>\nThis doesn't seem to work when `l`\
    \ is `c(NA, 1, NA)`\n<|/ c |>\n<| c |>\nI added a fix for that case.\n<|/ c |>\n\
    <| a tags=r,sorting |>\nHere's a solution using data.table:\n<code>\nlibrary(data.table)\n\
    dt <- data.table(x = c(NA, 1, NA))\ndt[, y := c(NA, diff(x)), by = 1:nrow(dt)]\n\
    dt[, y := ifelse(is.na(y), 0, y), by = 1:nrow(dt)]\ndt[, y := cumsum(y), by =\
    \ 1:nrow(dt)]\ndt[, y := ifelse(is.na(y), 0, y), by = 1:nrow(dt)]\ndt[, y := cumsum(y),\
    \ by = 1:nrow(dt)]\ndt[, y := ifelse(is.na(y), 0, y), by = 1:nrow(dt)]\ndt[, y\
    \ := cumsum(y), by = 1:nrow(dt)]\ndt[, y := ifelse(is.na(y), 0, y), by = 1:nrow(dt)]\n\
    dt[, y := cumsum(y), by = 1:nrow(dt)]\ndt[, y := ifelse(is.na(y), 0, y), by =\
    \ 1:nrow(dt)]\ndt[, y := cumsum(y), by = 1:nrow(dt)]\ndt[, y := ifelse(is.na(y),\
    \ 0, y), by = 1:nrow(dt)]\ndt[, y := cumsum(y), by = 1:nrow(dt)]\ndt[, y := ifelse(is.na(y),\
    \ 0, y), by = 1:nrow(dt)]\ndt[, y := cumsum(y), by = 1:nrow(dt)]\ndt[, y := ifelse(is.na(y),\
    \ 0, y), by = 1:nrow(dt)]\ndt[, y := cumsum(y), by = 1:nrow(dt)]\ndt[, y := ifelse(is.na(y),\
    \ 0, y), by = 1:nrow(dt", "\n  l <- sort(l)\n  i <- 1\n  while(i < length(l))\
    \ {\n    if(l[i] < l[i-1]) {\n      break\n    }\n    i <- i + 1\n  }\n  return(TRUE)\n\
    }\n</code>\n<|/ a |>\n<| c |>\nI like the `while` loop, but I wonder if there\
    \ is a faster way. `rle` seems like it would be very slow for large lists.\n<|/\
    \ c |>\n<| c |>\nI added a faster `rle` solution. Not sure how fast it would be\
    \ for large lists.\n<|/ c |>\n<| c |>\nI added a faster `rle` solution. Not sure\
    \ how fast it would be for large lists.\n<|/ c |>\n<| a dscore=2 |>\nHere's a\
    \ solution using rle:\n<code>\nrle <- rle(sort(x))\nrle$values[rle$lengths > 1]\
    \ <- NA\n</code>\n<|/ a tags=r,list,sorting |>\n<| c |>\nNice solution, although\
    \ it seems that `rle` doesn't have a `lengths` attribute. `rle$lengths` returns\
    \ `integer(0)`.\n<|/ c |>\n<| c |>\nThanks, I fixed the answer.\n<|/ c |>\n<|\
    \ a tags=r,list,sorting |>\nHere's a solution using data.table:\n<code>\nlibrary(data.table)\n\
    dt <- data.table(sort(x))\ndt[, `:=`(value = ifelse(is.na(value), NA, value))]\n\
    </code>\n<|/ a dscore=2 |>\n<| c |>\nNice solution, although it seems that `data.table`\
    \ doesn't have a `lengths` attribute. `dt$lengths` returns `integer(0)`.\n<|/\
    \ c |>\n<| c |>\nThanks, I fixed the answer.\n<|/ c |>\n<| a dscore=2 |>\nHere's\
    \ a solution using base R:\n<code>\nx <- c(1,2,4,20)\nx[order(x)] <- NA\n</code>\n\
    <|/ a tags=r,list,sorting |>\n<| c |>\nNice solution, although it seems that `base`\
    \ doesn't have a `lengths` attribute. `x$lengths` returns `integer(0)`.\n<|/ c\
    \ |>\n<| a tags=r,list,sorting |>\nHere's a solution using dplyr and purrr:\n\
    <code>\nlibrary(dplyr)\nlibrary(purrr)\n\nx <- c(1,2,4,20)\nx %>% \n  sort() %>%\
    \ \n  map_if(is.numeric, ", "\n  l <- sort(l)\n  diffs <- c(l[1], diff(l))\n \
    \ all(diffs > 0)\n}\n</code>\n<|/ a tags=r,sorting |>\n<| c |>\nI like this solution,\
    \ but I wonder if there is a way to make it more efficient by avoiding sorting\
    \ the whole list twice. For example, `monotonic(sort(c(1,4,2,5)))` returns `TRUE`,\
    \ but `monotonic(sort(c(1,4,2,5,3)))` returns `FALSE`.\n<|/ c |>\n<| c |>\nI added\
    \ a more efficient version. Thanks for the suggestion!\n<|/ c |>\n<| c |>\nThanks\
    \ for your answer! I tested it on some random vectors and it seems to work well.\
    \ I'm going to test it on some more complex vectors and see how it goes.\n<|/\
    \ c |>\n<| c |>\nI tested it on some more complex vectors and it seems to work\
    \ well. I'm going to test it on some more complex vectors and see how it goes.\n\
    <|/ c |>\n<| c |>\nI tested it on some more complex vectors and it seems to work\
    \ well. I'm going to test it on some more complex vectors and see how it goes.\n\
    <|/ c |>\n<| a dscore=3 |>\nHere's a solution using data.table:\n<code>\nlibrary(data.table)\n\
    dt <- data.table(x = c(1,4,2,5))\ndt[, y := c(NA, diff(x)), by = .(x < shift(x,\
    \ type = \"lag\"))]\ndt[, y := ifelse(is.na(y), 0, y)]\ndt[, y := cumsum(y), by\
    \ = x]\ndt[, y := ifelse(is.na(y), 0, y)]\ndt[, y := cumsum(y), by = x]\ndt[,\
    \ y := ifelse(is.na(y), 0, y)]\ndt[, y := cumsum(y), by = x]\ndt[, y := ifelse(is.na(y),\
    \ 0, y)]\ndt[, y := cumsum(y), by = x]\ndt[, y := ifelse(is.na(y), 0, y)]\ndt[,\
    \ y := cumsum(y), by = x]\ndt[, y := ifelse(is.na(y), 0, y)]\ndt[, y := cumsum(y),\
    \ by = x]\ndt[, y := ifelse(is.na(y), 0, y)]\ndt[, y := cumsum(y), by = x]\ndt[,\
    \ y := ifelse(is.na(y", "\n  l <- sort(l)\n  l[1] < l[2] & l[1] < l[3] & l[2]\
    \ < l[3] & l[1] < l[4]\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis doesn't seem\
    \ to work. `monotonic(c(1,2,4,20))` returns `FALSE`\n<|/ c |>\n<| c |>\nI tested\
    \ it on R and it works. I guess it depends on how you define \"monotonic\"\n<|/\
    \ c |>\n<| c |>\nI added a definition of monotonic to my answer.\n<|/ c |>\n<|\
    \ c |>\nI added a definition of monotonic to my answer.\n<|/ c |>\n<| c |>\nI\
    \ added a definition of monotonic to my answer.\n<|/ c |>\n<| a dscore=2 |>\n\
    Here's a function that returns TRUE if all elements of a vector are strictly increasing:\n\
    <code>\nall_increasing <- function(x) {\n  all(diff(x) < 0)\n}\n</code>\n<|/ a\
    \ tags=r,vector |>\n<| c |>\nThis doesn't seem to work. `all_increasing(c(1,2,4,20))`\
    \ returns `FALSE`\n<|/ c |>\n<| c |>\nI tested it on R and it works. I guess it\
    \ depends on how you define \"monotonic\"\n<|/ c |>\n<| c |>\nI added a definition\
    \ of monotonic to my answer.\n<|/ c |>\n<| a tags=r,vector |>\nA simple solution\
    \ using base R:\n<code>\nall_increasing <- function(x) {\n  all(diff(x) < 0)\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2 |>\n<code>\nall_increasing <- function(x)\
    \ {\n  all(diff(x) < 0)\n}\n</code>\n<|/ a tags=r,vector |>\n<| c |>\nThis doesn't\
    \ seem to work. `all_increasing(c(1,2,4,20))` returns `FALSE`\n<|/ c |>\n<| c\
    \ |>\nI tested it on R and it works. I guess it depends on how you define \"monotonic\"\
    \n<|/ c |>\n<| c |>\nI added a definition of monotonic to my answer.\n<|/ c |>\n\
    <| a tags=r,vector |>\n<code>\nall_increasing <- function(x) {\n  all(diff(x)\
    \ < 0)\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis doesn't seem to ", "\n  l\
    \ <- sort(l)\n  l[c(TRUE, diff(l) > 0)]\n}\n</code>\n<|/ a |>\n<| c |>\nThis doesn't\
    \ seem to work. `monotonic(1:10)` returns `[1]  1  2  3  4  5  6  7  8  9 10`,\
    \ but `monotonic(1:10)[c(TRUE, diff(1:10) > 0)]` returns `[1]  1  2  3  4  5 \
    \ 6  7  8  9 10`\n<|/ c |>\n<| c |>\nI see what you mean. `diff` returns `c(NA,\
    \ NA, NA, NA, NA, NA, NA, NA, NA, NA, NA)` which is not what we want. `diff` should\
    \ be used on `l[c(TRUE, diff(l) > 0)]` instead. I've updated my answer.\n<|/ c\
    \ |>\n<| c |>\nThanks. I see what you mean. `diff` returns `c(NA, NA, NA, NA,\
    \ NA, NA, NA, NA, NA, NA, NA)` which is not what we want. `diff` should be used\
    \ on `l[c(TRUE, diff(l) > 0)]` instead. I've updated my answer.\n<|/ c |>\n<|\
    \ c |>\nThanks again. I've updated my answer with a new function `monotonic` that\
    \ does what you want.\n<|/ c |>\n<| c |>\nThanks again. I've updated my answer\
    \ with a new function `monotonic` that does what you want.\n<|/ c |>\n<| a tags=r\
    \ |>\nHere's a solution using dplyr and purrr packages:\n<code>\nlibrary(dplyr)\n\
    library(purrr)\n", "\n  n <- length(l) - 1\n  i <- 1\n  while (i <= n) {\n   \
    \ if (l[i] < l[i - 1]) {\n      i <- i + 1\n    } else if (l[i] > l[i - 1]) {\n\
    \      i <- i + 1\n    } else {\n      i <- i + 1\n    }\n  }\n  return(TRUE)\n\
    }\n</code>\n<|/ a tags=r,sorting |>\n<| c |>\nThis doesn't work if you have NA's\
    \ in the vector. Try `monotonic(c(NA,1,2))`\n<|/ c |>\n<| c |>\nI didn't think\
    \ of that. Thanks for pointing it out. I've edited my answer to account for NA's\
    \ in the vector.\n<|/ c |>\n<| c |>\nI like the idea of using an index to keep\
    \ track of the current position. Very clever. Thanks!\n<|/ c |>\n<| c |>\nI like\
    \ your solution, but I wonder if there is a way to avoid the while loop? I mean,\
    \ is there a way to avoid the while loop and still get the correct result?\n<|/\
    \ c |>\n<| c |>\nI guess you could use `Reduce` but that would require a lot of\
    \ extra code. I'm not sure if there is a way to do it without a `while` loop.\
    \ Maybe someone else can come up with a clever solution.\n<|/ c |>\n<| a tags=r,sorting\
    \ |>\nHere's a solution using Reduce:\n<code>\nmonotonic = function(x) {\n  Reduce(function(x,\
    \ y) if (x < y) y else x, x, init = x)\n}\n\nmonotonic(c(NA,1,2))", "\n  l <-\
    \ sort(l)\n  l[c(TRUE, diff(l) != 0)]\n}\n</code>\n<|/ a tags=r,sorting |>\n<|\
    \ a dscore=1 |>\n<code>\nmonotonic = function(x){\n  y = sort(x)\n  return(all(y[1:(length(y)\
    \ - 1)] == y[2:length(y)]) & all(y[2:length(y)] == y[1:(length(y) - 2)]))\n}\n\
    </code>\n<|/ a tags=r,sorting |>\n<| a tags=r,sorting |>\n<code>\nmonotonic =\
    \ function(x){\n  y = sort(x)\n  return(all(y[1:(length(y) - 1)] == y[2:length(y)])\
    \ & all(y[2:length(y)] == y[1:(length(y) - 2)]))\n}\n</code>\n<|/ a dscore=1 |>\n\
    <| a tags=r,sorting |>\n<code>\nmonotonic = function(x){\n  y = sort(x)\n  return(all(y[1:(length(y)\
    \ - 1)] == y[2:length(y)]) & all(y[2:length(y)] == y[1:(length(y) - 2)]))\n}\n\
    </code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\n<code>\nmonotonic = function(x){\n\
    \  y = sort(x)\n  return(all(y[1:(length(y) - 1)] == y[2:length(y)]) & all(y[2:length(y)]\
    \ == y[1:(length(y) - 2)]))\n}\n</code>\n<|/ a tags=r,sorting |>\n<| a dscore=1\
    \ |>\n<code>\nmonotonic = function(x){\n  y = sort(x)\n  return(all(y[1:(length(y)\
    \ - 1)] == y[2:length(y)]) & all(y[2:length(y)] == y[1:(length(y) - 2)]))\n}\n\
    </code>\n<|/ a tags=r,sorting |>\n<| a dscore=0 |>\n<code>\nmonotonic = function(x){\n\
    \  y = sort(x)\n  return(all(y[1:(length(y) - 1)] == y[2:length(y)]) & all(y[2:length(y)]\
    \ == y[1:(length(y) - 2)]))\n}\n</code>\n<|/ a tags=r,sorting |>\n<| c |>\nPlease\
    \ add some explanation to your answer such that others can learn from it\n<|/\
    \ c |>\n<| c |>\nThis answer was flagged as low-quality because of its length\
    \ and content. Could you please add some explanation to your answer?\n<|/ c |>\n\
    <| a tags=r,sorting |>\n<code>\nmonotonic = function(x){\n  y = sort(x)\n  return(",
  "\n  l <- sort(l)\n  diffs <- c(l[-1]-l[-length(l)]) # diff of last and first elements\n\
    \  all(diffs > 0) || all(diffs < 0)\n}\n</code>\n<|/ a tags=r,list |>\n<| c |>\n\
    This doesn't seem to work. `monotonic(list(c(1,2,4,20), c(1,20,4,10), c(4,1,0,-10)))`\
    \ returns `TRUE` but `monotonic(list(c(1,2,4,20), c(1,20,4,10), c(4,1,0,-10),\
    \ c(4,1,0,-10)))` returns `FALSE`.\n<|/ c |>\n<| c |>\n: I see what you mean.\
    \ I've updated the answer to account for that.\n<|/ c |>\n<| c |>\n: I added a\
    \ more general solution that should work for any list with any number of elements.\n\
    <|/ c |>\n<| c |>\n: I added a more general solution that should work for any\
    \ list with any number of elements.\n<|/ c |>\n<| a dscore=3 |>\nHere's a solution\
    \ that uses purrr::map and purrr::keep:\n<code>\nlibrary(purrr)\n\nmonotonic2\
    \ <- function(l) {\n  map(l, keep, ~ all(diff(sort(.)) < 0))\n}\n\nmonotonic2(list(c(1,2,4,20),\
    \ c(1,20,4,10), c(4,1,0,-10)))", "\n  l <- sort(l)\n  diffs <- diff(l) > 0\n \
    \ all(diffs)\n}\n</code>\n<|/ a dscore=2 |>\n<| a tags=r,sorting |>\nI came up\
    \ with a solution that uses R's built-in sort function, but also uses R's built-in\
    \ diff function to determine if two elements are \"out of order\".  \n<code>",
  "\n  l <- sort(l)\n  l[c(TRUE, diff(l) != 0)]\n}\n", "\n  l <- sort(l)\n  diffs\
    \ <- c(l[1], diff(l), l[length(l)])\n  all(diffs >= 0)\n}\n</code>\n<|/ a tags=r,sorting\
    \ |>\n<| c |>\nThis doesn't work if you have NA's in the vector. `monotonic(c(NA,1,NA,2))`\
    \ returns `FALSE` instead of `TRUE`.\n<|/ c |>\n<| c |>\nI added a fix for NA's.\n\
    <|/ c |>\n<| a tags=r,sorting |>\nI came up with a solution that uses R's internal\
    \ sorting algorithms. \n<code>", "\n  l <- sort(l)\n  l[c(TRUE, diff(l)>0)]\n\
    }\n</code>\n<|/ a |>\n<| c |>\nI like the idea of using diff to identify the monotonic\
    \ elements, but the function doesn't seem to work as intended on lists with negative\
    \ numbers. For example, `monotonic(c(-2, -1, 0, 1, 2))` returns `[1] -1 -1 -1\
    \ -1 -1`, which is not the correct result.\n<|/ c |>\n<| c |>\nThanks for pointing\
    \ that out. I fixed the function and added a test to show that it works.\n<|/\
    \ c |>\n<| c |>\nThanks for your answer! I tested it on some lists and it seems\
    \ to work fine. One thing I noticed is that it seems to return `TRUE` if the list\
    \ contains only positive numbers. For example: `monotonic(c(-2, -1, 0, 1, 2))`\
    \ returns `[1] -1 -1 -1 -1 -1`, which is not the correct result.\n<|/ c |>\n<|\
    \ c |>\nI fixed the function and added a test to show that it works.\n<|/ c |>\n\
    <| c |>\nThanks for your answer! I tested it on some lists and it seems to work\
    \ fine. One thing I noticed is that it seems to return `TRUE` if the list contains\
    \ only positive numbers. For example: `monotonic(c(-2, -1, 0, 1, 2))` returns\
    \ `[1] -1 -1 -1 -1 -1`, which is not the correct result.\n<|/ c |>\n<| a tags=r,sorting\
    \ |>\nHere's a solution using data.table:\n<code>\nlibrary(data.table)\ndt <-\
    \ data.table(a = c(1,2,4,20), b = c(1,20,4,10))\ndt[order(a), .I[seq_len(.N) ==\
    \ min(a)]]\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThanks for your answer! I tested\
    \ it on some lists and it seems to work fine. One thing I noticed is that it seems\
    \ to return `TRUE` if the list contains only positive numbers. For example: `monotonic(c(-2,\
    \ -1, 0, 1, 2))` returns `[1] -1 -1 -1 -1 -1`, which is not the correct result.\n\
    <|/ c |>\n<| c |>\nThanks for your answer! I tested it on some lists and it seems\
    \ to work fine. One thing I noticed is that it seems to return `TRUE` if the list\
    \ contains only positive numbers. For example: `monotonic(c(-2, -1, 0, 1, 2))`\
    \ returns `[1] -1 -1 -1 -1 -1`, which is not the correct result.\n<|/ c |>\n<|\
    \ c |>\nThank", "\n  l <- sort(l)\n  diffs <- c(l[1], diff(l))\n  all(diffs >\
    \ 0)\n}\n", "\n  n <- length(l) - 1\n  i <- 1\n  while (i <= n) {\n    if (l[i]\
    \ < l[i - 1]) {\n      i <- i + 1\n    } else if (l[i] > l[i - 1]) {\n      i\
    \ <- i + 1\n    } else {\n      i <- i + 1\n      break\n    }\n  }\n  return(i\
    \ <= n)\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis doesn't seem to work. `monotonic(list(c(1,2,4,20),\
    \ c(1,20,4,10), c(4,1,0,-10)))` returns `TRUE` but `monotonic(list(c(1,2,4,20),\
    \ c(1,20,4,10), c(4,1,0,-10), c(4,1,0,-10)))` returns `FALSE`.\n<|/ c |>\n<| c\
    \ |>\nI didn't realize that `monotonic` was a base R function. I thought it was\
    \ a custom function I wrote. I'll update my answer.\n<|/ c |>\n<| c |>\nThanks\
    \ for your answer. I've updated my question to make it more clear that I'm looking\
    \ for a function that returns TRUE if all elements are monotonically increasing\
    \ or decreasing, otherwise FALSE.\n<|/ c |>\n<| c |>\nI updated my answer to include\
    \ a function that returns TRUE if all elements are monotonically increasing or\
    \ decreasing.\n<|/ c |>\n<| c |>\nThanks for your answer. I've updated my question\
    \ to make it more clear that I'm looking for a function that returns TRUE if all\
    \ elements are monotonically increasing or decreasing, otherwise FALSE.\n<|/ c\
    \ |>\n<| a tags=r |>\nHere's a solution using data.table:\n<code>\nlibrary(data.table)\n\
    library(magrittr)\n", "\n  l <- sort(l)\n  i <- 1\n  while(i < length(l)) {\n\
    \    if(l[i] < l[i-1]) {\n      i <- i + 1\n    } else {\n      i <- i + 1\n \
    \     if(l[i] > l[i-1]) {\n        i <- i + 1\n      }\n    }\n  }\n  return(TRUE)\n\
    }\n", "\n  l <- sort(l)\n  diffs <- diff(l) > 0\n  all(diffs) || all(diffs[c(TRUE,\
    \ FALSE)])\n}\n</code>\n<|/ a tags=r,sorting |>\n<| c |>\nThis doesn't seem to\
    \ work. `monotonic(c(1,2,4,20))` returns `FALSE`\n<|/ c |>\n<| c |>\nIt does work.\
    \ `monotonic(c(1,2,4,20))` returns `TRUE`\n<|/ c |>\n<| c |>\nIt does work. `monotonic(c(1,2,4,20))`\
    \ returns `TRUE`\n<|/ c |>\n<| c |>\nIt does work. `monotonic(c(1,2,4,20))` returns\
    \ `TRUE`\n<|/ c |>\n<| c |>\nIt does work. `monotonic(c(1,2,4,20))` returns `TRUE`\n\
    <|/ c |>\n<| a dscore=5 |>\nThe function below is based on a previous answer by\
    \ and works with vectors of any length.\n<code>\nmonotonic_inc <- function(x)\
    \ {\n  x <- sort(x)\n  diffs <- diff(x) > 0\n  all(diffs) || all(diffs[c(TRUE,\
    \ FALSE)])\n}\n</code>\n<|/ a tags=r,sorting |>\n<| c |>\nThis doesn't seem to\
    \ work. `monotonic_inc(c(1,2,4,20))` returns `FALSE`\n<|/ c |>\n<| c |>\nIt does\
    \ work. `monotonic_inc(c(1,2,4,20))` returns `TRUE`\n<|/ c |>\n<| c |>\nIt does\
    \ work. `monotonic_inc(c(1,2,4,20))` returns `TRUE`\n<|/ c |>\n<| c |>\nIt does\
    \ work. `monotonic_inc(c(1,2,4,20))` returns `TRUE`\n<|/ c |>\n<| c |>\nIt does\
    \ work. `monotonic_inc(c(1,2,4,20))` returns `TRUE`\n<|/ c |>\n<| a dscore=5 |>\n\
    Here's a function that works with vectors of any length (including zero):\n<code>\n\
    monotonic_inc <- function(x) {\n  x <- sort(x)\n  diffs <- diff(x) > 0\n  all(diffs)\
    \ || all(diffs[c(TRUE, FALSE)])\n}\n</code>\n<|/ a tags=r,sorting |>\n<| c |>\n\
    This doesn't seem to work. `monotonic_inc(c(1,2,4,20))` returns `FALSE`\n", "\n\
    \  l <- sort(l)\n  diffs <- c(l[1], diff(l))\n  all(diffs > 0)\n}\n</code>\n<|/\
    \ a tags=r |>\n<| c |>\nI like this solution, but I wonder if there is a way to\
    \ make it work for vectors of different lengths?\n<|/ c |>\n<| c |>\nI added a\
    \ version that works for vectors of different lengths.\n<|/ c |>\n<| c |>\nThanks,\
    \ I like it!\n<|/ c |>\n<| a dscore=3 |>\nHere's a solution using data.table:\n\
    <code>\nlibrary(data.table)\ndt <- data.table(a = c(1,2,3,4,5), b = c(2,4,6,8,10))\n\
    dt[, diff := c(NA, diff(a)), by = b]\ndt[diff > 0, diff := NA]\n</code>\n<|/ a\
    \ tags=r |>\n<| c |>\nI like this solution, but I wonder if there is a way to\
    \ make it work for vectors of different lengths?\n<|/ c |>\n<| c |>\nI added a\
    \ version that works for vectors of different lengths.\n<|/ c |>\n<| a dscore=3\
    \ |>\nHere's a solution using dplyr and purrr packages:\n<code>\nlibrary(dplyr)\n\
    library(purrr)\n\ndf <- data.frame(a = c(1,2,3,4,5), b = c(2,4,6,8,10))\n\ndf\
    \ %>% \n  group_by(b) %>% \n  mutate(diff = c(NA, diff(a))) %>% \n  mutate(diff\
    \ = replace(diff, diff > 0, NA))\n</code>\n<|/ a tags=r |>\n<| a dscore=2 |>\n\
    Here's a solution using data.table:\n<code>\nlibrary(data.table)\ndt <- data.table(a\
    \ = c(1,2,3,4,5), b = c(2,4,6,8,10))\ndt[, diff := c(NA, diff(a)), by = b]\ndt[diff\
    \ > 0, diff := NA]\n</code>\n<|/ a tags=r |>\n<| a dscore=2 |>\nHere's a solution\
    \ using dplyr and purrr packages:\n<code>\nlibrary(dplyr)\nlibrary(purrr)\n\n\
    df <- data.frame(a = c(1,2,3,4,5), b = c(2,4,6,8,10))\n\ndf %>% \n  group_by(b)\
    \ %>% \n  mutate(diff = c(NA, diff(a))) %>% \n  mutate(diff = replace(diff, diff\
    \ > 0, NA))\n</code>\n<|/ a tags=r |>\n<| a dscore=2 |>\nHere's a solution using\
    \ dplyr and ", "\n  l <- sort(l)\n  l[1] < l[2] || l[1] > l[3]\n}\n", "\n  l <-\
    \ sort(l)\n  l[c(TRUE, diff(l) > 0)]\n}\n</code>\n<|/ a tags=r,sorting |>\n<|\
    \ c |>\nThis doesn't seem to work. `monotonic(c(1,2,4,20))` returns `[1]  1  2\
    \  4 20` instead of `[1]  1  2  4 20`\n<|/ c |>\n<| c |>\n, you're right. I've\
    \ fixed the code in the answer. Thanks.\n<|/ c |>\n<| a dscore=5 |>\nI like using\
    \ dplyr::lag to get the previous element and dplyr::lead to get the next element.\
    \ \n<code>\nlibrary(dplyr)\nx <- c(1,2,4,20)\nlag(x, 1) < x < lead(x, 1)", "\n\
    \  l <- sort(l)\n  diffs <- c(l[-1], NA)\n  diffs[c(TRUE, diffs < 0)] <- NA\n\
    \  all(diffs == 0)\n}\n</code>\n<|/ a tags=r |>\n<| c |>\nI like your `monotonic`\
    \ function, but I believe it fails on `monotonic(list(c(NA,NA,NA)))` which should\
    \ return `TRUE` but returns `FALSE`.\n<|/ c |>\n<| c |>\nI believe it fails on\
    \ `monotonic(list(c(NA,NA,NA)))` because `diffs` has length 3 but `all(diffs ==\
    \ 0)` only checks for length 2.\n<|/ c |>\n<| c |>\nYes, I see that now. Thanks\
    \ for pointing that out.\n<|/ c |>\n<| a dscore=2 |>\nHere is a solution using\
    \ dplyr and purrr packages:\n<code>\nlibrary(dplyr)\nlibrary(purrr)\n\ndf <- data.frame(x\
    \ = c(1,2,3,4,5,6,7,8,9,10))\ndf %>% \n  mutate(\n    increasing = pmap_lgl(df,\
    \ ~ (.x > lag(.x, default = first(.x)))),\n    decreasing = pmap_lgl(df, ~ (.x\
    \ < lag(.x, default = first(.x)))),\n    same = pmap_lgl(df, ~ (.x == lag(.x,\
    \ default = first(.x)))),\n    same = map2(.x, .y, ~ (.x == lag(.x, default =\
    \ first(.x)))),\n    same = map2(.x, .y, ~ (.x == lag(.x, default = first(.x)))),\n\
    \    same = map2(.x, .y, ~ (.x == lag(.x, default = first(.x)))),\n    same =\
    \ map2(.x, .y, ~ (.x == lag(.x, default = first(.x)))),\n    same = map2(.x, .y,\
    \ ~ (.x == lag(.x, default = first(.x)))),\n    same = map2(.x, .y, ~ (.x == lag(.x,\
    \ default = first(.x)))),\n    same = map2(.x, .y, ~ (.x == lag(.x, default =\
    \ first(.x)))),\n    same = map2(.x, .y, ~ (.x == lag(.x, default = first(.x)))),\n\
    \    same = map2(.x, .y, ~ (.x == lag(.x, default = first(.x)))),\n    same =\
    \ map2(.x, .y, ~ (.x == lag(.x, default = first(.", "\n  l <- sort(l)\n  diffs\
    \ <- c(l[1] - l[-1], NA)\n  all(diffs > 0)\n}\n</code>\n<|/ a tags=r |>\n<| c\
    \ |>\nThis doesn't seem to work. `monotonic(1:10)` returns `TRUE` but `monotonic(1:11)`\
    \ returns `FALSE`.\n<|/ c |>\n<| c |>\nI tested it on R-3.2.3 and it works. I\
    \ guess you have a different version of R. Try `monotonic(1:10)` on R-3.2.3\n\
    <|/ c |>\n<| c |>\nI tested it on R-3.2.3 too. `monotonic(1:10)` returns `TRUE`\
    \ but `monotonic(1:11)` returns `FALSE`.\n<|/ c |>\n<| c |>\nI tested it on R-3.2.3\
    \ too. `monotonic(1:10)` returns `TRUE` but `monotonic(1:11)` returns `FALSE`.\n\
    <|/ c |>\n<| c |>\nI tested it on R-3.2.3 too. `monotonic(1:10)` returns `TRUE`\
    \ but `monotonic(1:11)` returns `FALSE`.\n<|/ c |>\n<| a |>\n<code>\nmonotonic<-function(x){\n\
    \  x<-sort(x)\n  diffs<-c(tail(x,1)-head(x,1),NA)\n  all(diffs>0)\n}\n</code>\n\
    <|/ a dscore=2 tags=r |>\n<| c |>\nThis doesn't seem to work. `monotonic(1:10)`\
    \ returns `TRUE` but `monotonic(1:11)` returns `FALSE`.\n<|/ c |>\n<| c |>\nI\
    \ tested it on R-3.2.3 and it works. I guess you have a different version of R.\
    \ Try `monotonic(1:10)` on R-3.2.3\n<|/ c |>\n<| c |>\nI tested it on R-3.2.3\
    \ too. `monotonic(1:10)` returns `TRUE` but `monotonic(1:11)` returns `FALSE`.\n\
    <|/ c |>\n<| c |>\nI tested it on R-3.2.3 too. `monotonic(1:10)` returns `TRUE`\
    \ but `monotonic(1:11)` returns `FALSE`.\n<|/ c |>\n<| c |>\nI tested it on R-3.2.3\
    \ too. `monotonic(1:10)` returns `TRUE` but `monotonic(1:11)` ", "\n  l <- sort(l)\n\
    \  l[c(TRUE, diff(l) > 0)]\n}\n</code>\n<|/ a tags=r,list,sorting |>\n<| c |>\n\
    This doesn't seem to work if the list contains NAs. For example, `monotonic(c(NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA",
  "\n  n <- length(l) - 1\n  i <- 1\n  while (i <= n) {\n    if (l[i] < l[i - 1])\
    \ {\n      i <- i + 1\n    } else if (l[i] > l[i - 1]) {\n      i <- i + 1\n \
    \   } else {\n      i <- i + 1\n      break\n    }\n  }\n  return(i <= n)\n}\n\
    </code>\n<|/ a dscore=1 |>\n<| c |>\nI like your solution, but I wonder if there\
    \ is a way to do it without looping through the entire list. Maybe some kind of\
    \ vectorized operation?\n<|/ c |>\n<| c |>\nI added a vectorized solution. Hope\
    \ it helps.\n<|/ c |>\n<| a tags=r |>\nHere's a vectorized solution:\n<code>",
  "\n  l <- sort(l)\n  diffs <- diff(l) > 0\n  all(diffs) || (all(diffs[c(TRUE, FALSE)]))\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThanks for your answer. Your code works\
    \ well for monotonic lists, but fails for non-monotonic lists. For example, `monotonic(c(1,2,4,20))`\
    \ returns `FALSE`, but `monotonic(c(1,2,4,20,30))` returns `TRUE`.\n<|/ c |>\n\
    <| c |>\nThanks for your comment. I've added a version that works for non-monotonic\
    \ lists.\n<|/ c |>\n<| c |>\nThanks for your answer. Your code works well for\
    \ monotonic lists, but fails for non-monotonic lists. For example, `monotonic(c(1,2,4,20))`\
    \ returns `FALSE`, but `monotonic(c(1,2,4,20,30))` returns `TRUE`.\n<|/ c |>\n\
    <| c |>\nThanks for your comment. I've added a version that works for non-monotonic\
    \ lists.\n<|/ c |>\n<| a dscore=2 |>\nHere's a solution using data.table:\n<code>\n\
    library(data.table)\ndt <- data.table(a = c(1,2,4,20))\ndt[, `:=`(b = c(tail(a,\
    \ -1), head(a, -1)), c = c(head(a, -1), tail(a, -1)), d = c(tail(a, -1), head(a,\
    \ -1)), e = c(head(a, -1), tail(a, -1)), f = c(tail(a, -1), head(a, -1)), g =\
    \ c(head(a, -1), tail(a, -1)), h = c(tail(a, -1), head(a, -1)), i = c(head(a,\
    \ -1), tail(a, -1)), j = c(tail(a, -1), head(a, -1)), k = c(head(a, -1), tail(a,\
    \ -1)), l = c(tail(a, -1), head(a, -1)), m = c(head(a, -1), tail(a, -1)), n =\
    \ c(tail(a, -1), head(a, -1)), o = c(head(a, -1), tail(a, -1)), p = c(tail(a,\
    \ -1), head(a, -1)), q = c(head(a, -1), tail(a, -1)), r = c(tail(a, -1), head(a,\
    \ -1)), s = c(head(a, -1), tail(a, -1)), t = c(tail(a, -1), head(a, -1)), u =\
    \ c(head(a, -1), tail(a, -1)), v = c(tail(a, -1), head(a, -1)), w = c(head(a,\
    \ -1), tail(a, -1)), x = c(tail(a, -1), head(a, -1)), y = c(head(a, -1), tail(a,\
    \ -1)), z = c(tail(a, -1), head(a, -1)), w = c(head(a, -1), tail(a, -1)), x =\
    \ c(tail(a, -1), head(a, -1)), ", "\n  l <- sort(l)\n  diffs <- c(l[1], diff(l))\n\
    \  all(diffs > 0)\n}\n</code>\n<|/ a dscore=3 |>\n<| c |>\nI like this solution,\
    \ but I wonder if there is a way to do this without sorting.\n<|/ c |>\n<| c |>\n\
    I added a solution without sorting.\n<|/ c |>\n<| c |>\nI like the second solution,\
    \ but I wonder if there is a way to do this without sorting.\n<|/ c |>\n<| c |>\n\
    I added a solution without sorting.\n<|/ c |>\n<| c |>\nI like the second solution,\
    \ but I wonder if there is a way to do this without sorting.\n<|/ c |>\n<| a dscore=2\
    \ |>\nHere's a solution without sorting:\n<code>\nmonotonic = function(x) {\n\
    \  n = length(x)\n  y = 0\n  for(i in 1:n) {\n    if(y<x[i] && x[i]<y) y = x[i]\n\
    \    if(y<x[i+1]) return(FALSE)\n  }\n  return(TRUE)\n}\n</code>\n<|/ a tags=r,sorting\
    \ |>\n<| a tags=r,sorting |>\nHere's a solution without sorting:\n<code>\nmonotonic\
    \ = function(x) {\n  n = length(x)\n  y = 0\n  for(i in 1:n) {\n    if(y<x[i]\
    \ && x[i]<y) y = x[i]\n    if(y<x[i+1]) return(FALSE)\n  }\n  return(TRUE)\n}\n\
    </code>\n<|/ a dscore=2 |>\n<| a dscore=2 |>\nHere's a solution without sorting:\n\
    <code>\nmonotonic = function(x) {\n  n = length(x)\n  y = 0\n  for(i in 1:n) {\n\
    \    if(y<x[i] && x[i]<y) y = x[i]\n    if(y<x[i+1]) return(FALSE)\n  }\n  return(TRUE)\n\
    }\n</code>\n<|/ a tags=r,sorting |>\n<| a dscore=2 |>\nHere's a solution without\
    \ sorting:\n<code>\nmonotonic = function(x) {\n  n = length(x)\n  y = 0\n  for(i\
    \ in 1:n) {\n    if(y<x[i] && x[i]<y) y = x[i]\n    if(y<x[i+1]) return(FALSE)\n\
    \  }\n  return(TRUE)\n}\n</code>\n<|/ a tags=r,sorting |>\n<| a tags=r,sorting\
    \ |>\nHere's a solution without sorting:\n<code>\nmonotonic = function(x) {\n\
    \  n = length(x)", "\n  l <- sort(l)\n  diffs <- c(l[-1]-l[-length(l)]) # difference\
    \ between each consecutive element\n  all(diffs >= 0) # all differences are positive\
    \ or zero\n}\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis doesn't work for negative\
    \ numbers. Try `monotonic(c(-2, -1, 0, 1, 2))`\n<|/ c |>\n<| c |>\nI added a version\
    \ that works for negative numbers. Thanks for pointing that out.\n<|/ c |>\n<|\
    \ c |>\nI added a version that works for negative numbers. Thanks for pointing\
    \ that out.\n<|/ c |>\n<| c |>\nI added a version that works for negative numbers.\
    \ Thanks for pointing that out.\n<|/ c |>\n<| c |>\nI added a version that works\
    \ for negative numbers. Thanks for pointing that out.\n<|/ c |>\n<| a dscore=5\
    \ |>\n<code>\nlibrary(data.table)\nlibrary(zoo)\nlibrary(magrittr)\n\nis.monotonic_increasing\
    \ <- function(x) \n  all(diff(sort(x)) > 0)\n\nis.monotonic_decreasing <- function(x)\
    \ \n  all(diff(sort(x)) < 0)\n\nis.monotonic_strictly_increasing <- function(x)\
    \ \n  all(diff(sort(x)) > 0)\n\nis.monotonic_strictly_decreasing <- function(x)\
    \ \n  all(diff(sort(x)) < 0)\n\nis.monotonic <- function(x) \n  is.monotonic_increasing(x)\
    \ | is.monotonic_decreasing(x) | is.monotonic_strictly_increasing(x) | is.monotonic_strictly_decreasing(x)\n\
    \nis.monotonic(c(1,2,4,20))", "\n  n <- length(l) - 1\n  i <- 1\n  while (i <=\
    \ n) {\n    if (l[i] < l[i - 1]) {\n      i <- i + 1\n    } else {\n      i <-\
    \ i + 1\n      n <- n - 1\n    }\n  }\n  return(TRUE)\n}\n</code>\n<|/ a tags=r,sorting\
    \ |>\n<| c |>\nThis doesn't seem to work. `monotonic(c(1,2,4,20))` returns `FALSE`,\
    \ but `monotonic(c(1,2,4,20,10))` returns `TRUE`.\n<|/ c |>\n<| c |>\nYes, I see\
    \ that now. Thanks for pointing that out. I've fixed it now.\n<|/ c |>\n<| c |>\n\
    Thanks for your answer! It works perfectly for my purposes. I wonder why it isn't\
    \ accepted as an answer though.\n<|/ c |>\n<| c |>\nI guess because it's not a\
    \ very good answer. `monotonic` doesn't do what OP wants. It's not an answer to\
    \ his question. He wants to know if one vector is monotonically increasing or\
    \ decreasing. `monotonic` doesn't do that. He wants to know if one vector is monotonically\
    \ increasing or decreasing, but he doesn't care about the direction of the increasing\
    \ or decreasing sequence. He wants to know if one vector is monotonically increasing\
    \ or decreasing, but he doesn't care about the direction of the increasing or\
    \ decreasing sequence. He wants to know if one vector is monotonically increasing\
    \ or decreasing, but he doesn't care about the direction of the increasing or\
    \ decreasing sequence. He wants to know if one vector is monotonically increasing\
    \ or decreasing, but he doesn't care about the direction of the increasing or\
    \ decreasing sequence.\n<|/ c |>\n<| c |>\nI guess I misunderstood your comment.\
    \ My comment was directed at the OP who posted this answer, not you. Sorry for\
    \ the confusion.\n<|/ c |>\n<| a tags=r,sorting |>\n<code>\nmonotonic = function(x){\n\
    \  if(length(x) == 1){\n    return(TRUE)\n  }\n  if(length(x) == 2){\n    return(TRUE)\n\
    \  }\n  if(length(x) == 3){\n    return(TRUE)\n  }\n  if(length(x) == 4){\n  \
    \  return(TRUE)\n  }\n  if(length(x) == 5){\n    return(TRUE)\n  }\n  if(length(x)\
    \ == 6){\n    return(TRUE)\n", "\n  l <- sort(l)\n  l[c(TRUE, diff(l) != 0)]\n\
    }\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis is great. Thank you!\n<|/ c |>\n\
    <| c |>\nThis works great for me but I'm wondering if there is a way to make it\
    \ work for vectors of different lengths. For example, `monotonic(c(1,2,4,20))`\
    \ returns `c(TRUE, FALSE, FALSE, FALSE)` but `monotonic(c(1,2,4,20,30))` returns\
    \ `c(TRUE, TRUE, FALSE, FALSE, FALSE)`\n<|/ c |>\n<| c |>\nI added a version that\
    \ works for vectors of different lengths.\n<|/ c |>\n<| c |>\nThis is great. Thank\
    \ you!\n<|/ c |>\n<| c |>\nThis works great for me but I'm wondering if there\
    \ is a way to make it work for vectors of different lengths. For example, `monotonic(c(1,2,4,20))`\
    \ returns `c(TRUE, FALSE, FALSE, FALSE)` but `monotonic(c(1,2,4,20,30))` returns\
    \ `c(TRUE, TRUE, FALSE, FALSE, FALSE)`\n<|/ c |>\n<| a tags=r,sorting |>\nI like\
    \ to use dplyr::lag to get the previous value of a variable in a data frame. \n\
    <code>\nlibrary(dplyr)\n\ndf <- data.frame(\n  x = c(1,2,4,20),\n  y = c(2,4,6,8)\n\
    )\n\ndf %>% \n  mutate(\n    previous_x = lag(x, default = 0),\n    previous_y\
    \ = lag(y, default = 0)\n  )\n\n  x y previous_x previous_y\n1 1 2         1 \
    \        2\n2 2 4         2         4\n3 4 6         4         6\n4 20 8     \
    \   20         8\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis works great for vectors\
    \ of different lengths. Thank you!\n<|/ c |>\n<| c |>\nThis works great for vectors\
    \ of different lengths. Thank you!\n<|/ c |>\n<| c |>\nThis works great for vectors\
    \ of different lengths. Thank you!\n<|/ c |>\n<| a tags=r,sorting |>\nA base R\
    \ option with ave + diff\n<code>\ndf$previous_x <- with(df, ave(x, x, FUN = function(x)\
    \ c(x, NA)[-length(x)]))\ndf$previous_y <- with(df, ave(y, y, FUN = function(x)\
    \ c(x, NA)", "\n  l <- sort(l)\n  diffs <- c(l[-1]-l[-length(l)]) # All but last\
    \ element\n  all(diffs >= 0) # All elements are increasing\n}\n</code>\n<|/ a\
    \ tags=r,sorting |>\n<| c |>\nI like your answer, but I think it would be more\
    \ efficient to just sort once, rather than sorting each time you call `monotonic`.\
    \ Also, `diffs` should be `diff(l[-1:-length(l)]`\n<|/ c |>\n<| c |>\nYes, you\
    \ are right. I was thinking about a more efficient solution, but I didn't want\
    \ to change too much the OP's code. Thanks for your comment!\n<|/ c |>\n<| c |>\n\
    I like your answer, but I think it would be more efficient to just sort once,\
    \ rather than sorting each time you call `monotonic`. Also, `diffs` should be\
    \ `diff(l[-1:-length(l)]`\n<|/ c |>\n<| c |>\nI agree with you. I just wanted\
    \ to show that `diff` could be used instead of `sort`. I also wanted to show that\
    \ `diff` could be used instead of `sort`. I will edit my answer to include your\
    \ suggestions.\n<|/ c |>\n<| c |>\nI like your answer, but I think it would be\
    \ more efficient to just sort once, rather than sorting each time you call `monotonic`.\
    \ Also, `diffs` should be `diff(l[-1:-length(l)]`\n<|/ c |>\n<| a dscore=2 |>\n\
    Here's a solution using data.table:\n<code>\nlibrary(data.table)\ndt <- data.table(\n\
    \  x = c(1,4,2,5,3,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,11",
  "\n  l <- sort(l)\n  diffs <- diff(l) > 0\n  all(diffs) || all(diffs[c(TRUE, FALSE)])\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| c |>\nI like the `diff` solution, but I wonder\
    \ if there is a way to do this without `diff`? I mean, `diff` will give me the\
    \ difference between adjacent elements, but I want the difference between each\
    \ element and the previous one. Is there a way to do this without `diff`?\n<|/\
    \ c |>\n<| c |>\nI added a solution without `diff`.\n<|/ c |>\n<| c |>\nThanks,\
    \ I like your solution, although I wonder if there is a way to do this without\
    \ `diff`? I mean, `diff` will give me the difference between adjacent elements,\
    \ but I want the difference between each element and the previous one. Is there\
    \ a way to do this without `diff`?\n<|/ c |>\n<| c |>\nI added a solution without\
    \ `diff`.\n<|/ c |>\n<| a tags=r,sorting |>\nHere's a solution without diff:\n\
    <code>\nmonotonic2 <- function(x) {\n  y <- x\n  y[1] <- NA\n  y[-1] <- NA\n \
    \ y[-1] <- y[-length(y)]\n  y[1] <- y[1]\n  y <- y[order(y)]\n  y <- y[!is.na(y)]\n\
    \  return(all(is.na(y)))\n}\n</code>\n<|/ a dscore=2 |>\n<| a tags=r,sorting |>\n\
    Here's a solution without diff:\n<code>\nmonotonic3 <- function(x) {\n  y <- x\n\
    \  y[1] <- NA\n  y[-1] <- NA\n  y[-1] <- y[-length(y)]\n  y[1] <- y[1]\n  y <-\
    \ y[order(y)]\n  y <- y[!is.na(y)]\n  return(all(is.na(y)))\n}\n</code>\n<|/ a\
    \ dscore=2 |>\n<| a tags=r,sorting |>\nHere's a solution without diff:\n<code>\n\
    monotonic4 <- function(x) {\n  y <- x\n  y[1] <- NA\n  y[-1] <- NA\n  y[-1] <-\
    \ y[-length(y)]\n  y[1] <- y[1]\n  y <- y[order(y)]\n  y <- y[!is.na(y)]\n  return(all(is.na(y)))\n\
    }\n</code>\n<|/ a dscore=1 |>\n<|", "\n  l <- sort(l)\n  diffs <- c(l[1], diff(l),\
    \ l[length(l)])\n  all(diffs > 0)\n}\n</code>\n<|/ a tags=r,sorting |>\n<| c |>\n\
    I like your solution, but I wonder if there is a way to do it without having to\
    \ sort the list twice. I'm thinking about a function that can tell me whether\
    \ a list is monotonically increasing or decreasing.\n<|/ c |>\n<| c |>\nI added\
    \ a function that tells you whether a list is monotonically increasing or decreasing.\n\
    <|/ c |>\n<| c |>\nI like your solution, but I wonder if there is a way to do\
    \ it without having to sort the list twice. I'm thinking about a function that\
    \ can tell me whether a list is monotonically increasing or decreasing.\n<|/ c\
    \ |>\n<| c |>\nI added a function that tells you whether a list is monotonically\
    \ increasing or decreasing.\n<|/ c |>\n<| c |>\nI like your solution, but I wonder\
    \ if there is a way to do it without having to sort the list twice. I'm thinking\
    \ about a function that can tell me whether a list is monotonically increasing\
    \ or decreasing.\n<|/ c |>\n<| a dscore=5 |>\n<code>\nis.monotonic <- function(x)\
    \ \n{\n  x <- sort(x)\n  diffs <- c(head(x, -1), diff(x), tail(x, -1))\n  all(diffs\
    \ > 0)\n}\n</code>\n<|/ a tags=r,sorting |>\n<| c |>\nI like your solution, but\
    \ I wonder if there is a way to do it without having to sort the list twice. I'm\
    \ thinking about a function that can tell me whether a list is monotonically increasing\
    \ or decreasing.\n<|/ c |>\n<| c |>\nI added a function that tells you whether\
    \ a list is monotonically increasing or decreasing.\n<|/ c |>\n<| c |>\nI like\
    \ your solution, but I wonder if there is a way to do it without having to sort\
    \ the list twice. I'm thinking about a function that can tell me whether a list\
    \ is monotonically increasing or decreasing.\n<|/ c |>\n<| c |>\nI added a function\
    \ that tells you whether a list is monotonically increasing or decreasing.\n<|/\
    \ c |>\n<| c |>\nI like your solution, but I wonder if there is a way to do it\
    \ without having to sort the list twice. I'm thinking about a function that can\
    \ tell me whether a list is ", "\n  l <- sort(l)\n  diffs <- c(l[1], diff(l))\n\
    \  all(diffs < 0)\n}\n</code>\n<|/ a dscore=4 |>\n<| c |>\nThis doesn't work if\
    \ your list has negative numbers. Try `monotonic(c(-2, -1, 0, 1, 2))`\n<|/ c |>\n\
    <| c |>\nI believe this answer should be updated to `all(diffs < 0)` instead of\
    \ `all(diffs > 0)`\n<|/ c |>\n<| a |>\nI wrote a function that does this in R:\n\
    <code>\nmonotonic_inc <- function(x) {\n  x <- sort(x)\n  diffs <- c(head(x, -1),\
    \ diff(x))\n  all(diffs < 0)\n}\n</code>\n<|/ a tags=r,list dscore=4 |>\n<| c\
    \ |>\nThis doesn't work if your list has negative numbers. Try `monotonic_inc(c(-2,\
    \ -1, 0, 1, 2))`\n<|/ c |>\n<| a dscore=4 |>\nI wrote a function that does this\
    \ in R:\n<code>\nmonotonic_inc <- function(x) {\n  x <- sort(x)\n  diffs <- c(head(x,\
    \ -1), diff(x))\n  all(diffs < 0)\n}\n</code>\n<|/ a tags=r,list |>\n<| a tags=r,list\
    \ |>\n<code>\nmonotonic_inc <- function(x) {\n  x <- sort(x)\n  diffs <- c(head(x,\
    \ -1), diff(x))\n  all(diffs < 0)\n}\n</code>\n<|/ a dscore=3 |>\n<| a tags=r,list\
    \ |>\nI wrote a function that does this in R:\n<code>\nmonotonic_inc <- function(x)\
    \ {\n  x <- sort(x)\n  diffs <- c(head(x, -1), diff(x))\n  all(diffs < 0)\n}\n\
    </code>\n<|/ a dscore=3 |>\n<| a tags=r,list |>\n<code>\nmonotonic_inc <- function(x)\
    \ {\n  x <- sort(x)\n  diffs <- c(head(x, -1), diff(x))\n  all(diffs < 0)\n}\n\
    </code>\n<|/ a dscore=3 |>\n<| a dscore=3 |>\n<code>\nmonotonic_inc <- function(x)\
    \ {\n  x <- sort(x)\n  diffs <- c(head(x, -1), diff(x))\n  all(diffs < 0)\n}\n\
    </code>\n<|/ a tags=r,list |>\n<| a dscore=3 |>\n<code>\nmonotonic_inc <- function(x)\
    \ {\n  x <- sort(x)\n  diffs <- c(head(x, ", "\n  l <- sort(l)\n  l[c(TRUE, diff(l)\
    \ > 0)]\n}\n</code>\n<|/ a dscore=4 |>\n<| c |>\nThis doesn't seem to work for\
    \ negative numbers. `monotonic(c(-2, -1, 0, 1))` returns `[1] -1 -1  0  1` instead\
    \ of `[1] -1 -1  1  0`\n<|/ c |>\n<| c |>\nThe function doesn't work for negative\
    \ numbers. Try `monotonic(c(-2, -1, 0, 1))`\n<|/ c |>\n<| c |>\nI see what you\
    \ mean. Thanks for pointing that out. I've updated the answer to account for negative\
    \ numbers.\n<|/ c |>\n<| a dscore=4 |>\nI came up with a solution using data.table:\n\
    <code>\nlibrary(data.table)\ndt <- data.table(a = c(1,2,4,5), b = c(2,4,6,8))\n\
    dt[, c := ifelse(a > b, 1, ifelse(a < b, -1, 0)), by = a]\n</code>\n<|/ a tags=r,sorting\
    \ |>\n<| a tags=r,sorting |>\nHere's a solution using dplyr and tidyr:\n<code>\n\
    library(dplyr)\nlibrary(tidyr)\n\ndf <- data.frame(a = c(1,2,4,5), b = c(2,4,6,8))\n\
    \ndf %>% \n  mutate(c = ifelse(a > b, 1, ifelse(a < b, -1, 0)))\n\n  a b c\n1\
    \ 1 2 1\n2 2 4 1\n3 4 6 -1\n4 5 8 -1\n</code>\n<|/ a dscore=4 |>\n<| a tags=r,sorting\
    \ |>\nHere's a solution using data.table:\n<code>\nlibrary(data.table)\ndt <-\
    \ data.table(a = c(1,2,4,5), b = c(2,4,6,8))\ndt[, c := ifelse(a > b, 1, ifelse(a\
    \ < b, -1, 0)), by = a]\n</code>\n<|/ a dscore=3 |>\n<| a |>\nHere's a solution\
    \ using data.table:\n<code>\nlibrary(data.table)\ndt <- data.table(a = c(1,2,4,5),\
    \ b = c(2,4,6,8))\ndt[, c := ifelse(a > b, 1, ifelse(a < b, -1, 0)), by = a]\n\
    </code>\n<|/ a tags=r,sorting dscore=3 |>\n<| a tags=r,sorting |>\nHere's a solution\
    \ using dplyr and tidyr:\n<code>\nlibrary(dplyr)\nlibrary(tidyr)\n\ndf <- data.frame(a\
    \ = c(1,2,4,", "\n  l <- sort(l)\n  diffs <- c(l[-1]-l[-length(l)]) # diff of\
    \ last to first\n  all(diffs >= 0) # all diff are positive\n}\n</code>\n<|/ a\
    \ dscore=1 |>\n<| a dscore=0 |>\nHere's a solution using data.table:\n<code>\n\
    library(data.table)\n", "\n  l <- sort(l)\n  diffs <- c(l[-1] - l[-length(l)])\
    \ \n  return(all(diffs >= 0))\n}\n", "\n  l <- sort(l)\n  diffs <- c(l[1], diff(l))\n\
    \  all(diffs >= 0) & all(diffs <= 0)\n}\n</code>\n<|/ a dscore=5 |>\n<| c |>\n\
    I like this solution, but I wonder if it will work well with large lists. I ran\
    \ a test with 1e6 elements and it took about 20 seconds to run on my laptop. I\
    \ wonder if there's a faster way to do this in R?\n<|/ c |>\n<| c |>\nI ran a\
    \ test with 1e7 elements and it took about 5 seconds to run on my laptop. I wonder\
    \ if there's a faster way to do this in R?\n<|/ c |>\n<| c |>\nI ran a test with\
    \ 1e8 elements and it took about 2 seconds to run on my laptop. I wonder if there's\
    \ a faster way to do this in R?\n<|/ c |>\n<| c |>\nI ran a test with 1e9 elements\
    \ and it took about 1 second to run on my laptop. I wonder if there's a faster\
    \ way to do this in R?\n<|/ c |>\n<| c |>\nI ran a test with 1e10 elements and\
    \ it took about 0.1 second to run on my laptop. I wonder if there's a faster way\
    \ to do this in R?\n<|/ c |>\n<| a dscore=5 |>\nHere's a solution that doesn't\
    \ require sorting the list first:\n<code>\nis_increasing <- function(x) {\n  y\
    \ <- x[1]\n  for(i in 2:length(x)) {\n    if(y<x[i]) return(FALSE)\n    y <- x[i]\n\
    \  }\n  return(TRUE)\n}\n</code>\n<|/ a tags=list,r,sorting |>\n<| c |>\nThis\
    \ doesn't work if you have a list with negative numbers. For example, `is_increasing(c(-2,-1,0,1))`\
    \ returns `TRUE` instead of `FALSE`.\n<|/ c |>\n<| c |>\nI guess you could add\
    \ `if(y<0) return(FALSE)` before `y <- x[i]`\n<|/ c |>\n<| c |>\nThis doesn't\
    \ work if you have a list with negative numbers. For example, `is_increasing(c(-2,-1,0,1))`\
    \ returns `TRUE` instead of `FALSE`.\n<|/ c |>\n<| c |>\nI guess you could add\
    \ `if(y<0) return(FALSE)` before `y <- x[i]`\n<|/ c |>\n<| c |>\nThis doesn't\
    \ work", "\n  l <- sort(l)\n  i <- 1\n  while(i < length(l)) {\n    if(l[i] <\
    \ l[i-1]) {\n      i <- i + 1\n    } else {\n      i <- i + 1\n      break\n \
    \   }\n  }\n  return(TRUE)\n}\n</code>\n<|/ a dscore=3 |>\n<| c |>\nI like the\
    \ idea of using sort to find the first element that is out of order, but this\
    \ doesn't seem to work if the list is sorted in reverse order. For example, `monotonic(c(10,9,8,7,6,5,4,3,2,1))`\
    \ returns `TRUE`, but `monotonic(c(10,9,8,7,6,5,4,3,2,1,-1))` returns `FALSE`.\n\
    <|/ c |>\n<| c |>\nYes, I agree. That's why I added the comment \"# Return True\
    \ is list elements are monotonically increasing or decreasing.\"\n<|/ c |>\n<|\
    \ c |>\nI added a solution that works in both directions.\n<|/ c |>\n<| a tags=r,sorting\
    \ |>\nHere's a solution using data.table:\n<code>\nlibrary(data.table)\ndt <-\
    \ data.table(a = c(1,2,3,4,5,6,7,8,9,10), b = c(10,9,8,7,6,5,4,3,2,1))\ndt[order(-b),\
    \ .I[seq_len(.N) == 1], by = a]\n</code>\n<|/ a dscore=3 |>\n<| c |>\nNice solution!\
    \ I didn't know about `data.table`.\n<|/ c |>\n<| a dscore=3 |>\nHere's a solution\
    \ using base R:\n<code>\nx <- c(1,2,3,4,5,6,7,8,9,10)\ny <- c(10,9,8,7,6,5,4,3,2,1)\n\
    which(diff(x) < 0)", "\n  l <- sort(l)\n  diffs <- c(l[-1] - l[-length(l)], 0)\n\
    \  all(diffs >= 0)\n}\n", "\n  l <- sort(l)\n  diffs <- c(l[-1], NA)\n  diffs[c(TRUE,\
    \ diffs < 0)]\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThanks so much for the\
    \ answer! I really appreciate it! I ran your function on my data set and got this\
    \ error: `Error in if (diffs[c(TRUE, diffs < 0)] == 0) stop(\"increasing or decreasing\
    \ not allowed\") : \n  missing value where TRUE/FALSE needed`\n<|/ c |>\n<| c\
    \ |>\nI ran it again and got this error: `Error in if (diffs[c(TRUE, diffs < 0)]\
    \ == 0) stop(\"increasing or decreasing not allowed\") : \n  missing value where\
    \ TRUE/FALSE needed`\n<|/ c |>\n<| c |>\nI ran it again and got this error: `Error\
    \ in if (diffs[c(TRUE, diffs < 0)] == 0) stop(\"increasing or decreasing not allowed\"\
    ) : \n  missing value where TRUE/FALSE needed`\n<|/ c |>\n<| c |>\nI ran it again\
    \ and got this error: `Error in if (diffs[c(TRUE, diffs < 0)] == 0) stop(\"increasing\
    \ or decreasing not allowed\") : \n  missing value where TRUE/FALSE needed`\n\
    <|/ c |>\n<| c |>\nI ran it again and got this error: `Error in if (diffs[c(TRUE,\
    \ diffs < 0)] == 0) stop(\"increasing or decreasing not allowed\") : \n  missing\
    \ value where TRUE/FALSE needed`\n<|/ c |>\n<| a tags=r |>\nHere's a solution\
    \ using dplyr and purrr. \n<code>\nlibrary(dplyr)\nlibrary(purrr)\n\ndf %>%\n\
    \  mutate(\n    across(everything(), ~if_else(\n      lag(.x) == .x,\n      NA,\n\
    \      if_else(\n        is.na(lag(.x)) | is.na(.x),\n        NA,\n        if_else(\n\
    \          is.na(lag(.x)) & is.na(.x),\n          NA,\n          if_else(\n  \
    \          is.na(lag(.x)) | is.na(.x),\n            NA,\n            if_else(\n\
    \              is.na(lag(.x)) & is.na(.x),\n              NA,\n              if_else(\n\
    \                is.na(lag(.x)) | is.na(.x),\n                NA", "\n  l <- sort(l)\n\
    \  l[seq_along(l) == 1]\n}\n", "\n  l <- sort(l)\n  i <- 1\n  while(i < length(l))\
    \ {\n    if(l[i] < l[i-1]) {\n      i <- i + 1\n    } else {\n      i <- i + 1\n\
    \      if(l[i] > l[i-1]) {\n        i <- i + 1\n      }\n    }\n  }\n  return(TRUE)\n\
    }\n", "\n  l <- sort(l)\n  i <- 1\n  while(i < length(l)) {\n    if(l[i] < l[i-1])\
    \ {\n      i <- i + 1\n    } else {\n      i <- 1\n    }\n  }\n  return(TRUE)\n\
    }\n</code>\n<|/ a tags=r,sorting |>\n<| c |>\nThis doesn't work if you have negative\
    \ numbers in the list.\n<|/ c |>\n<| c |>\nIt does work if you have negative numbers\
    \ in the list. Try it yourself.\n<|/ c |>\n<| c |>\nI tested it and it doesn't\
    \ work. Try it yourself.\n<|/ c |>\n<| c |>\nI tested it and it does work. Try\
    \ it yourself.\n<|/ c |>\n<| c |>\nI tested it and it does work. Try it yourself.\n\
    <|/ c |>\n<| a tags=r,sorting |>\n<code>\nmonotonic = function(a){\n  a = sort(a)\n\
    \  i = 2\n  while(i < length(a)){\n    if(a[i] < a[i-1]){\n      i = i + 1\n \
    \   } else {\n      i = 2\n    }\n  }\n  return(TRUE)\n}\n</code>\n<|/ a dscore=3\
    \ |>\n<| c |>\nThis doesn't work if you have negative numbers in the list.\n<|/\
    \ c |>\n<| c |>\nIt does work if you have negative numbers in the list. Try it\
    \ yourself.\n<|/ c |>\n<| c |>\nI tested it and it doesn't work. Try it yourself.\n\
    <|/ c |>\n<| c |>\nI tested it and it does work. Try it yourself.\n<|/ c |>\n\
    <| c |>\nI tested it and it does work. Try it yourself.\n<|/ c |>\n<| a tags=r,sorting\
    \ |>\n<code>\nmonotonic = function(a){\n  a = sort(a)\n  i = 2\n  while(i < length(a)){\n\
    \    if(a[i] < a[i-1]){\n      i = i + 1\n    } else {\n      i = 2\n    }\n \
    \ }\n  return(TRUE)\n}\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThis doesn't work\
    \ if you have negative numbers in the list.\n<|/ c |>\n<| c |>\nIt does work if\
    \ you have negative numbers in the list. Try it yourself.\n<|/ c |>\n<| c |>\n\
    I tested it and it doesn't work. Try it yourself.\n<|/ c |>\n<| a tags=r,sorting\
    \ |>\n<code>\nmonotonic = function(a){", "\n  n <- length(l);\n  i <- 1;\n  while\
    \ (i <= n) {\n    if (l[i] < l[i - 1]) {\n      i <- i + 1;\n    } else {\n  \
    \    i <- i + 2;\n    }\n  }\n  return(i <= n);\n}\n</code>\n<|/ a dscore=1 |>\n\
    <| c |>\nThis doesn't work if the first element in the vector is greater than\
    \ the last.\n<|/ c |>\n<| c |>\nThanks for the comment. I fixed the code so that\
    \ it works with vectors of length greater than 1.\n<|/ c |>\n<| c |>\nThis doesn't\
    \ work if the first element in the vector is greater than the last.\n<|/ c |>\n\
    <| c |>\nThanks for the comment. I fixed the code so that it works with vectors\
    \ of length greater than 1.\n<|/ c |>\n<| a dscore=1 |>\n<code>\nlibrary(dplyr)\n\
    library(purrr)\n\nx <- c(1,2,4,20)\ny <- c(1,20,4,10)\n", "\n  l <- sort(l)\n\
    \  diffs <- c(l[1], diff(l))\n  all(diffs > 0)\n}\n</code>\n<|/ a tags=r |>\n\
    <| a tags=r |>\nI came up with this solution:\n<code>\nmonotonic = function(x){\n\
    \  if(length(x) == 1){\n    return(TRUE)\n  }\n  if(length(x) == 2){\n    return(TRUE)\n\
    \  }\n  if(length(x) == 3){\n    return(TRUE)\n  }\n  if(length(x) == 4){\n  \
    \  return(TRUE)\n  }\n  if(length(x) == 5){\n    return(TRUE)\n  }\n  if(length(x)\
    \ == 6){\n    return(TRUE)\n  }\n  if(length(x) == 7){\n    return(TRUE)\n  }\n\
    \  if(length(x) == 8){\n    return(TRUE)\n  }\n  if(length(x) == 9){\n    return(TRUE)\n\
    \  }\n  if(length(x) == 10){\n    return(TRUE)\n  }\n  if(length(x) == 11){\n\
    \    return(TRUE)\n  }\n  if(length(x) == 12){\n    return(TRUE)\n  }\n  if(length(x)\
    \ == 13){\n    return(TRUE)\n  }\n  if(length(x) == 14){\n    return(TRUE)\n \
    \ }\n  if(length(x) == 15){\n    return(TRUE)\n  }\n  if(length(x) == 16){\n \
    \   return(TRUE)\n  }\n  if(length(x) == 17){\n    return(TRUE)\n  }\n  if(length(x)\
    \ == 18){\n    return(TRUE)\n  }\n  if(length(x) == 19){\n    return(TRUE)\n \
    \ }\n  if(length(x) == 20){\n    return(TRUE)\n  }\n  if(length(x) == 21){\n \
    \   return(TRUE)\n  }\n  if(length(x) == 22){\n    return(TRUE)\n  }\n  if(length(x)\
    \ == 23){\n    return(TRUE)\n  }\n  if(length(x) == 24){\n    return(TRUE)\n \
    \ }\n  if(length(x) == 25){\n    return(TRUE)\n  }\n  if(length(x) == 26){\n \
    \   return(TRUE)\n  }\n  if(length(x) == 27){\n    return(TRUE)\n  }\n  if(length(x)\
    \ == 28){\n    return(TRUE)\n  }\n  if(length(x) == 29){\n    return(TRUE)\n \
    \ }\n  if(length(x) == 30){\n    return(TRUE)\n  }\n  if(length(x) == ", "\n \
    \ l <- sort(l)\n  diffs <- c(l[-1], NA)\n  diffs[which(diffs < 0)] <- 0\n  all(diffs[1:(length(l)-1)]\
    \ == diffs[2:length(l)])\n}\n</code>\n<|/ a tags=r,list,sorting |>\n<| c |>\n\
    I like your solution, but I wonder if there is a way to do it without having to\
    \ sort the list first. Maybe something like `all(diff(l)==0)`?\n<|/ c |>\n<| c\
    \ |>\nYes, that would work. `all(diff(l)==0)` would return `TRUE` if the list\
    \ was monotonically increasing or decreasing.\n<|/ c |>\n<| c |>\nI added a solution\
    \ that doesn't require sorting.\n<|/ c |>\n<| c |>\nI added a solution that doesn't\
    \ require sorting.\n<|/ c |>\n<| a dscore=2 |>\nHere's a solution using base R:\n\
    <code>", "\n  l <- sort(l)\n  diffs <- diff(l) > 0\n  all(diffs)\n}\n", "\n  l\
    \ <- sort(l)\n  diffs <- c(l[1], diff(l), l[length(l)])\n  all(diffs >= 0)\n}\n\
    </code>\n<|/ a dscore=4 |>\n<| c |>\nThis doesn't seem to work for `monotonic([1,\
    \ 20, 4, 10])`\n<|/ c |>\n<| c |>\nIt does work for me. `monotonic([1, 20, 4,\
    \ 10])` returns `TRUE`.\n<|/ c |>\n<| c |>\nI guess I misunderstood your question.\
    \ My apologies. I thought you were asking for a function that returns `TRUE` if\
    \ all elements are strictly increasing or decreasing. I've updated my answer to\
    \ reflect that.\n<|/ c |>\n<| c |>\nI like your solution, however it fails for\
    \ `monotonic([1, 20, 4, 10])` which returns `FALSE`\n<|/ c |>\n<| c |>\nI guess\
    \ I misunderstood your question. My apologies. I thought you were asking for a\
    \ function that returns `TRUE` if all elements are strictly increasing or decreasing.\
    \ I've updated my answer to reflect that.\n<|/ c |>\n<| a tags=r,sorting |>\n\
    A simple and fast solution is to use rle to find the runs of increasing or decreasing\
    \ elements and then check whether all runs are of length 1 or not:\n<code>\nmonotonic\
    \ <- function(x) {\n  y <- rle(x)\n  all(y$lengths == 1 | y$lengths == 0)\n}\n\
    </code>\n<|/ a dscore=4 |>\n<| c |>\nThis doesn't seem to work for `monotonic([1,\
    \ 20, 4, 10])`\n<|/ c |>\n<| c |>\nI guess I misunderstood your question. My apologies.\
    \ I thought you were asking for a function that returns `TRUE` if all elements\
    \ are strictly increasing or decreasing. I've updated my answer to reflect that.\n\
    <|/ c |>\n<| c |>\nI like your solution, however it fails for `monotonic([1, 20,\
    \ 4, 10])` which returns `FALSE`\n<|/ c |>\n<| c |>\nI guess I misunderstood your\
    \ question. My apologies. I thought you were asking for a function that returns\
    \ `TRUE` if all elements are strictly increasing or decreasing. I've updated my\
    \ answer to reflect that.\n<|/ c |>\n<| c |>\nI like your solution, however it\
    \ fails for `monotonic([1, 20, 4, 10])` which ", "\n  l <- sort(l)\n  diffs <-\
    \ c(l[-1], NA) - l\n  all(diffs >= 0) & all(diffs <= 0)\n}\n", "\n  l <- sort(l)\n\
    \  diffs <- c(l[1], diff(l))\n  all(diffs > 0)\n}\n</code>\n<|/ a dscore=5 |>\n\
    <| c |>\nThis doesn't work for `monotonic([1, 20, 4, 10])` which should return\
    \ `TRUE` but returns `FALSE`\n<|/ c |>\n<| c |>\nI believe this should return\
    \ `TRUE` because `diff` returns `1` for `[1,2,4,20]` and `[1,2,4,10]` but `diffs`\
    \ returns `-1` for `[1,2,4,10]` and `[1,2,4,20]`\n<|/ c |>\n<| c |>\nI believe\
    \ this should return `TRUE` because `diff` returns `1` for `[1,2,4,20]` and `[1,2,4,10]`\
    \ but `diffs` returns `-1` for `[1,2,4,10]` and `[1,2,4,20]`\n<|/ c |>\n<| c |>\n\
    I believe this should return `TRUE` because `diff` returns `1` for `[1,2,4,20]`\
    \ and `[1,2,4,10]` but `diffs` returns `-1` for `[1,2,4,10]` and `[1,2,4,20]`\n\
    <|/ c |>\n<| c |>\nI believe this should return `TRUE` because `diff` returns\
    \ `1` for `[1,2,4,20]` and `[1,2,4,10]` but `diffs` returns `-1` for `[1,2,4,10]`\
    \ and `[1,2,4,20]`\n<|/ c |>\n<| a dscore=5 |>\n<code>\nmonotonic = function(x){\n\
    \  x = sort(x)\n  diffs = c(x[1], diff(x))\n  all(diffs > 0)\n}\n</code>\n<|/\
    \ a tags=r,sorting |>\n<| c |>\nThis doesn't work for `monotonic([1, 20, 4, 10])`\
    \ which should return `TRUE` but returns `FALSE`\n<|/ c |>\n<| c |>\nThis doesn't\
    \ work for `monotonic([1, 20, 4, 10])` which should return `TRUE` but returns\
    \ `FALSE`\n<|/ c |>\n<| c |>\nThis doesn't work for `monotonic([1, 20, 4, 10])`\
    \ which should return `TRUE` but returns `FALSE`\n<|/ c |>\n<| a tags=r,sorting\
    \ |>\n<code>\nmonotonic = function(x){\n  x = sort(x)\n  diffs = c(x[1], diff(x))\n\
    \  all(diffs > 0)\n}\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis doesn't work for\
    \ `monotonic([1, ", "\n  l <- sort(l)\n  l[1] < l[2] & l[1] < l[3] & l[2] < l[3]\
    \ & l[1] < l[4]\n}\n", "\n  l <- sort(l)\n  diffs <- c(l[1], diff(l), l[length(l)])\n\
    \  all(diffs > 0)\n}\n</code>\n<|/ a dscore=2 |>\n<| a dscore=1 |>\nHere is a\
    \ solution using data.table:\n<code>\nlibrary(data.table)\ndt <- data.table(\n\
    \  x = c(1, 3, 5),\n  y = c(1, 3, 5)\n)\n\ndt[, `:=`(x = ifelse(x < y, y, x)),\
    \ by = y]\n</code>\n<|/ a tags=r,sorting |>\n<| a tags=r,sorting |>\n<code>\n\
    library(dplyr)\ndf <- data.frame(x = c(1,3,5), y = c(1,3,5))\ndf %>% group_by(y)\
    \ %>% mutate(x = ifelse(x < y, y, x))\n</code>\n<|/ a dscore=1 |>\n<| a |>\n<code>\n\
    df <- data.frame(x = c(1,3,5), y = c(1,3,5))\ndf$x <- ifelse(df$x < df$y, df$y,\
    \ df$x)\n</code>\n<|/ a dscore=1 tags=r,sorting |>\n<| a dscore=1 |>\n<code>\n\
    df <- data.frame(x = c(1,3,5), y = c(1,3,5))\ndf$x <- ifelse(df$x < df$y, df$y,\
    \ df$x)\n</code>\n<|/ a tags=r,sorting |>\n<| a |>\n<code>\ndf <- data.frame(x\
    \ = c(1,3,5), y = c(1,3,5))\ndf$x <- ifelse(df$x < df$y, df$y, df$x)\n</code>\n\
    <|/ a tags=r,sorting dscore=1 |>\n<| a tags=r,sorting |>\n<code>\ndf <- data.frame(x\
    \ = c(1,3,5), y = c(1,3,5))\ndf$x <- ifelse(df$x < df$y, df$y, df$x)\n</code>\n\
    <|/ a dscore=1 |>\n<| a tags=r,sorting |>\n<code>\ndf <- data.frame(x = c(1,3,5),\
    \ y = c(1,3,5))\ndf$x <- ifelse(df$x < df$y, df$y, df$x)\n</code>\n<|/ a dscore=1\
    \ |>\n<| a dscore=1 |>\n<code>\ndf <- data.frame(x = c(1,3,5), y = c(1,3,5))\n\
    df$x <- ifelse(df$x < df$y, df$y, df$x)\n</code>\n<|/ a tags=r,sorting |>\n",
  "\n  l <- sort(l)\n  diffs <- diff(l) > 0\n  all(diffs)\n}\n", "\n  l <- sort(l)\n\
    \  l[c(TRUE, diff(l)>0)]\n}\n", "\n  l <- sort(l)\n  l[seq_along(l) == 1]\n}\n",
  "\n  l <- sort(l)\n  diffs <- c(l[-1] - l[-length(l)]) # difference between each\
    \ consecutive element\n  all(diffs >= 0) # all differences are positive or zero\n\
    }\n</code>\n<|/ a dscore=4 |>\n<| c |>\nI like this solution, but I wonder if\
    \ there is a way to make it more efficient by avoiding sorting.\n<|/ c |>\n<|\
    \ c |>\nI added a solution that avoids sorting.\n<|/ c |>\n<| c |>\nI added a\
    \ solution that avoids sorting.\n<|/ c |>\n<| c |>\nI added a solution that avoids\
    \ sorting.\n<|/ c |>\n<| a dscore=3 |>\nHere's a solution using data.table:\n\
    <code>\nlibrary(data.table)\ndt <- data.table(x = c(1,2,4,20))\ndt[, diff := c(tail(x,\
    \ -1), head(x, -1) - x)]\ndt[, diff := c(diff, diff[length(diff)]), by = 1:nrow(dt)]\n\
    dt[, diff := diff[diff < 0]]\ndt[, diff := diff[diff > 0]]\ndt[, diff := diff[order(diff)]]\n\
    dt[, diff := diff[!duplicated(diff)]]\ndt[, diff := diff[!is.na(diff)]]\ndt[,\
    \ diff := diff[!is.na(diff)]]\ndt[, diff := diff[!is.na(diff)]]\ndt[, diff :=\
    \ diff[!is.na(diff)]]\ndt[, diff := diff[!is.na(diff)]]\ndt[, diff := diff[!is.na(diff)]]\n\
    dt[, diff := diff[!is.na(diff)]]\ndt[, diff := diff[!is.na(diff)]]\ndt[, diff\
    \ := diff[!is.na(diff)]]\ndt[, diff := diff[!is.na(diff)]]\ndt[, diff := diff[!is.na(diff)]]\n\
    dt[, diff := diff[!is.na(diff)]]\ndt[, diff := diff[!is.na(diff)]]\ndt[, diff\
    \ := diff[!is.na(diff)]]\ndt[, diff := diff[!is.na(diff)]]\ndt[, diff := diff[!is.na(diff)]]\n\
    dt[, diff := diff[!is.na", "\n  l <- sort(l)\n  diffs <- c(l[-1], NA)\n  diffs[is.na(diffs)]\
    \ <- 0\n  all(diffs[1:(length(l)-1)] < 0)\n}\n</code>\n<|/ a tags=r,sorting |>\n\
    <| c |>\nI like your solution, but I wonder if there is a way to make it more\
    \ efficient (less memory and time). Maybe using some kind of binary search or\
    \ something?\n<|/ c |>\n<| c |>\nI added a more efficient version. Hope it helps.\n\
    <|/ c |>\n<| c |>\nI added a more efficient version. Hope it helps.\n<|/ c |>\n\
    <| a tags=r,sorting |>\nHere's a solution using data.table:\n<code>\nlibrary(data.table)\n\
    dt <- data.table(a = c(1,2,4,20), b = c(1,20,4,10))\ndt[, c := c(NA, diff(a)),\
    \ by = b][c > 0, ]\n</code>\n<|/ a dscore=2 |>\n<| c |>\nI like your solution,\
    \ but I wonder if there is a way to make it more efficient (less memory and time).\
    \ Maybe using some kind of binary search or something?\n<|/ c |>\n<| c |>\nI added\
    \ a more efficient version. Hope it helps.\n<|/ c |>\n<| a dscore=2 |>\nHere's\
    \ a solution using dplyr and purrr packages:\n<code>\nlibrary(dplyr)\nlibrary(purrr)\n\
    \ndf <- data.frame(a = c(1,2,4,20), b = c(1,20,4,10))\n\ndf %>% \n  mutate(\n\
    \    diff = map(b, ~c(NA, diff(a))),\n    flag = map_lgl(diff, ~all(.x < 0)),\n\
    \    flag = ifelse(flag, TRUE, FALSE)\n  )\n\n  a  b  diff  flag\n1 1  1 <NA>\
    \  TRUE\n2 2 20   -1  TRUE\n3 4 10   -1  TRUE\n4 5 NA   NA  TRUE\n</code>\n<|/\
    \ a tags=r,sorting |>\n<| a dscore=2 |>\nHere's a solution using base R:\n<code>\n\
    df <- data.frame(a = c(1,2,4,20), b = c(1,20,4,10))\ndf$diff <- c(NA, diff(df$a))\n\
    df$flag <- with(df, ifelse(diff(df$a) < 0, TRUE, FALSE))\n</code>\n<|/ a tags=r,sorting\
    \ |>\n<| c |>\nI like your solution, but I wonder ", "\n  l <- sort(l)\n  diffs\
    \ <- diff(l) > 0\n  all(diffs) || (all(diffs[2:1]) & all(diffs[1:2]))\n}\n</code>\n\
    <|/ a tags=r,sorting |>\n<| c |>\nThis doesn't seem to work when `l` is `c(1,3,5,7,9,10,11,13,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,",
  "\n  l <- sort(l)\n  i <- 1\n  while(i < length(l)) {\n    if(l[i] < l[i-1]) {\n\
    \      i <- i + 1\n    } else {\n      i <- i + 1\n      if(l[i] > l[i-1]) {\n\
    \        i <- i + 1\n      }\n    }\n  }\n  return(TRUE)\n}\n</code>\n<|/ a tags=r,sorting\
    \ |>\n<| c |>\nI like this solution, but I wonder if there is a way to make it\
    \ more efficient (faster). I tried `system.time` on `monotonic(1:1e6)` and it\
    \ took about 2 seconds. I wonder if there is a way to make it faster?\n<|/ c |>\n\
    <| c |>\nI added a faster version that should be faster than the one I posted.\n\
    <|/ c |>\n<| c |>\nI added a faster version that should be faster than the one\
    \ I posted.\n<|/ c |>\n<| c |>\nI added a faster version that should be faster\
    \ than the one I posted.\n<|/ c |>\n<| c |>\nI added a faster version that should\
    \ be faster than the one I posted.\n<|/ c |>\n<| a dscore=3 |>\nHere's a solution\
    \ using data.table:\n<code>\nlibrary(data.table)\ndt <- data.table(x = 1:10)\n\
    dt[, y := c(NA, diff(x)), by = 1:nrow(dt)]\ndt[, y := ifelse(is.na(y), 0, y)]\n\
    dt[, y := cumsum(y), by = 1:nrow(dt)]\ndt[, y := ifelse(y == 1, 0, y)]\ndt[, y\
    \ := ifelse(y == 0, 0, y)]\ndt[, y := ifelse(y == 1, 1, y)]\ndt[, y := ifelse(y\
    \ == 0, 0, y)]\ndt[, y := ifelse(y == 1, 1, y)]\ndt[, y := ifelse(y == 0, 0, y)]\n\
    dt[, y := ifelse(y == 1, 1, y)]\ndt[, y := ifelse(y == 0, 0, y)]\ndt[, y := ifelse(y\
    \ == 1, 1, y)]\ndt[, y := ifelse(y == 0, 0, y)]\ndt[, y := ifelse(y == 1, 1, y)]\n\
    dt[, y := ifelse(y == 0, 0, y)]\ndt[, y := ifelse(y == 1, 1, y)]\ndt[, y := ifelse(y\
    \ == 0, 0, y)]\ndt[, y := ifelse(y == 1, 1, y)]\ndt", "\n  l <- sort(l)\n  diffs\
    \ <- c(l[-1] - l[-length(l)], 0)\n  all(diffs >= 0)\n}\n</code>\n<|/ a tags=r,sorting\
    \ |>\n<| c |>\nThis doesn't work for me. `monotonic(c(1,2,4,20))` returns `FALSE`,\
    \ but `monotonic(c(1,2,4,20,10))` returns `TRUE`.\n<|/ c |>\n<| c |>\nI added\
    \ a fix for that case.\n<|/ c |>\n<| c |>\nThis doesn't work for me. `monotonic(c(1,2,4,20))`\
    \ returns `FALSE`, but `monotonic(c(1,2,4,20,10))` returns `FALSE`.\n<|/ c |>\n\
    <| c |>\nI added a fix for that case.\n<|/ c |>\n<| a tags=r,sorting |>\n<code>\n\
    monotonic = function(x) {\n  x = sort(x)\n  diffs = c(tail(x, -1) - head(x, -1),\
    \ 0)\n  all(diffs >= 0)\n}\n</code>\n<|/ a dscore=4 |>\n<| c |>\nThis doesn't\
    \ work for me. `monotonic(c(1,2,4,20))` returns `FALSE`, but `monotonic(c(1,2,4,20,10))`\
    \ returns `TRUE`.\n<|/ c |>\n<| c |>\nI added a fix for that case.\n<|/ c |>\n\
    <| a tags=r,sorting |>\n<code>\nmonotonic = function(x) {\n  x = sort(x)\n  diffs\
    \ = c(tail(x, -1) - head(x, -1), 0)\n  all(diffs >= 0)\n}\n</code>\n<|/ a dscore=3\
    \ |>\n<| c |>\nThis doesn't work for me. `monotonic(c(1,2,4,20))` returns `FALSE`,\
    \ but `monotonic(c(1,2,4,20,10))` returns `TRUE`.\n<|/ c |>\n<| a tags=r,sorting\
    \ |>\n<code>\nmonotonic = function(x) {\n  x = sort(x)\n  diffs = c(tail(x, -1)\
    \ - head(x, -1), 0)\n  all(diffs >= 0)\n}\n</code>\n<|/ a dscore=3 |>\n<| a tags=r,sorting\
    \ |>\n<code>\nmonotonic = function(x) {\n  x = sort(x)\n  diffs = c(tail(x, -1)\
    \ - head(x, -1), 0)\n  all(diffs >= 0)\n}\n</code>\n<|/ a dscore=3 |>\n<| c |>\n\
    This doesn't work for me. `monotonic(c(1,2,4,20))` returns `FALSE`, but `monotonic(c(1,2,4,20,10))`\
    \ returns `TRUE`.", "\n  l <- sort(l)\n  diffs <- c(l[1], diff(l))\n  return(all(diffs\
    \ >= 0) == all(diffs <= 0))\n}\n</code>\n<|/ a tags=r,sorting |>\n<| c |>\nThis\
    \ doesn't work for me. `monotonic(1:10)` returns `FALSE`\n<|/ c |>\n<| c |>\n\
    I tested it on `1:10` and it returns `TRUE`\n<|/ c |>\n<| c |>\nI tested it on\
    \ `1:10` and it returns `TRUE`\n<|/ c |>\n<| c |>\nI tested it on `1:10` and it\
    \ returns `TRUE`\n<|/ c |>\n<| c |>\nI tested it on `1:10` and it returns `TRUE`\n\
    <|/ c |>\n<| a tags=r,sorting |>\n<code>\nmonotonic = function(x){\n  if(length(x)\
    \ == 1){\n    return(TRUE)\n  }\n  if(length(x) == 2){\n    return(FALSE)\n  }\n\
    \  if(length(x) == 3){\n    return(FALSE)\n  }\n  if(length(x) == 4){\n    return(FALSE)\n\
    \  }\n  if(length(x) == 5){\n    return(FALSE)\n  }\n  if(length(x) == 6){\n \
    \   return(FALSE)\n  }\n  if(length(x) == 7){\n    return(FALSE)\n  }\n  if(length(x)\
    \ == 8){\n    return(FALSE)\n  }\n  if(length(x) == 9){\n    return(FALSE)\n \
    \ }\n  if(length(x) == 10){\n    return(FALSE)\n  }\n  if(length(x) == 11){\n\
    \    return(FALSE)\n  }\n  if(length(x) == 12){\n    return(FALSE)\n  }\n  if(length(x)\
    \ == 13){\n    return(FALSE)\n  }\n  if(length(x) == 14){\n    return(FALSE)\n\
    \  }\n  if(length(x) == 15){\n    return(FALSE)\n  }\n  if(length(x) == 16){\n\
    \    return(FALSE)\n  }\n  if(length(x) == 17){\n    return(FALSE)\n  }\n  if(length(x)\
    \ == 18){\n    return(FALSE)\n  }\n  if(length(x) == 19){\n    return(FALSE)\n\
    \  }\n  if(length(x) == 20){\n    return(FALSE)\n  }\n  if(length(x) == 21){\n\
    \    return(FALSE)\n  }\n  if(length(x) == 22){\n    return(FALSE)\n  }", "\n\
    \  l <- sort(l)\n  diffs <- c(l[-length(l)]-l[length(l)]) \n  all(diffs > 0)\n\
    }\n</code>\n<|/ a tags=r,sorting |>\n<| c |>\nThis doesn't work if you have a\
    \ list with two or more equal elements. For example, `monotonic(c(1,1,2,2))` returns\
    \ `FALSE`, but `monotonic(c(1,1,2,2))` returns `TRUE`.\n<|/ c |>\n<| c |>\nThanks\
    \ for pointing that out. I've fixed the code accordingly.\n<|/ c |>\n<| a dscore=4\
    \ |>\nHere's a function that will do what you want:\n<code>\nmonotonic_inc <-\
    \ function(x) {\n  x <- sort(x)\n  diffs <- c(x[-length(x)]-x[length(x)])\n  all(diffs\
    \ > 0)\n}\n</code>\n<|/ a tags=r,sorting |>\n<| c |>\nThis doesn't work if you\
    \ have a list with two or more equal elements. For example, `monotonic_inc(c(1,1,2,2))`\
    \ returns `FALSE`, but `monotonic_inc(c(1,1,2,2))` returns `TRUE`.\n<|/ c |>\n\
    <| a dscore=4 |>\nHere's a function that will do what you want:\n<code>\nmonotonic_inc\
    \ <- function(x) {\n  x <- sort(x)\n  diffs <- c(x[-length(x)]-x[length(x)])\n\
    \  all(diffs > 0)\n}\n</code>\n<|/ a tags=r,sorting |>\n<| c |>\nThis doesn't\
    \ work if you have a list with two or more equal elements. For example, `monotonic_inc(c(1,1,2,2))`\
    \ returns `FALSE`, but `monotonic_inc(c(1,1,2,2))` returns `TRUE`.\n<|/ c |>\n\
    <| a dscore=3 |>\nHere's a function that will do what you want:\n<code>\nmonotonic_inc\
    \ <- function(x) {\n  x <- sort(x)\n  diffs <- c(x[-length(x)]-x[length(x)])\n\
    \  all(diffs > 0)\n}\n</code>\n<|/ a tags=r,sorting |>\n<| a tags=r,sorting |>\n\
    Here's a function that will do what you want:\n<code>\nmonotonic_inc <- function(x)\
    \ {\n  x <- sort(x)\n  diffs <- c(x[-length(x)]-x[length(x)])\n  all(diffs > 0)\n\
    }\n</code>\n<|/ a dscore=3 |>\n<| a dscore=3 |>\nHere's a function that will do\
    \ what you wan", "\n  l <- sort(l)\n  all(diff(l) < 0)\n}\n", "\n  l <- sort(l)\n\
    \  l[c(TRUE, diff(l) > 0)]\n}\n</code>\n<|/ a dscore=4 |>\n<| c |>\nI like the\
    \ idea of using diff. Thanks!\n<|/ c |>\n<| a dscore=3 |>\n<code>\nlibrary(data.table)\n\
    library(zoo)\n", "\n  l <- sort(l)\n  diffs <- c(l[1], diff(l))\n  all(diffs >=\
    \ 0)\n}\n", "\n  l <- sort(l)\n  diffs <- c(l[1], diff(l), l[length(l)])\n  all(diffs\
    \ > 0)\n}\n</code>\n<|/ a tags=r,sorting |>\n<| a tags=r,sorting |>\nA simple\
    \ and efficient solution is to use rank:\n<code>\nrank(myvector, ties.method =\
    \ \"min\")\n</code>\n<|/ a dscore=4 |>\n<| c |>\nThis doesn't work if your vector\
    \ has negative values.\n<|/ c |>\n<| c |>\nIt doesn't work if your vector has\
    \ negative values, but you can fix that by adding `-Inf` at the beginning.\n<|/\
    \ c |>\n<| c |>\nThis doesn't work if your vector has negative values, but you\
    \ can fix that by adding `-Inf` at the beginning.\n<|/ c |>\n<| c |>\nThis doesn't\
    \ work if your vector has negative values, but you can fix that by adding `-Inf`\
    \ at the beginning.\n<|/ c |>\n<| c |>\nThis doesn't work if your vector has negative\
    \ values, but you can fix that by adding `-Inf` at the beginning.\n<|/ c |>\n\
    <| a tags=r,sorting |>\nHere's a solution using rank:\n<code>\nrank(myvector,\
    \ ties.method = \"min\")\n</code>\n<|/ a dscore=4 |>\n<| c |>\nThis doesn't work\
    \ if your vector has negative values.\n<|/ c |>\n<| c |>\nThis doesn't work if\
    \ your vector has negative values, but you can fix that by adding `-Inf` at the\
    \ beginning.\n<|/ c |>\n<| a |>\nHere's a solution using rank:\n<code>\nrank(myvector,\
    \ ties.method = \"min\")\n</code>\n<|/ a dscore=4 tags=r,sorting |>\n<| c |>\n\
    This doesn't work if your vector has negative values.\n<|/ c |>\n<| c |>\nThis\
    \ doesn't work if your vector has negative values, but you can fix that by adding\
    \ `-Inf` at the beginning.\n<|/ c |>\n<| a dscore=4 |>\n<code>\nrank(myvector,\
    \ ties.method = \"min\")\n</code>\n<|/ a tags=r,sorting |>\n<| a dscore=3 |>\n\
    <code>\nrank(myvector, ties.method = \"min\")\n</code>\n<|/ a tags=r,sorting |>\n\
    <| a |>\n<code>\nrank(myvector, ties.method = \"min\")\n</code>\n<|/ a tags=r,sorting\
    \ dscore=", "\n  n <- length(l) - 1\n  i <- 1\n  while (i <= n) {\n    if (l[i]\
    \ < l[i - 1]) {\n      i <- i + 1\n    } else {\n      i <- i + 1\n      n <-\
    \ n - 1\n    }\n  }\n  return(TRUE)\n}\n</code>\n<|/ a dscore=5 |>\n<| c |>\n\
    I like this solution, but I wonder if there is a way to make it more efficient.\
    \ I'm thinking about a while loop that checks whether the current element in the\
    \ list is the next element in the list, and if so, stops iterating through the\
    \ list. Would that be more efficient?\n<|/ c |>\n<| c |>\nI added a while loop\
    \ that checks whether the current element is the next element in the list, and\
    \ if so, stops iterating through the list. Would that be more efficient?\n<|/\
    \ c |>\n<| c |>\nI added a while loop that checks whether the current element\
    \ is the next element in the list, and if so, stops iterating through the list.\
    \ Would that be more efficient?\n<|/ c |>\n<| c |>\nI added a while loop that\
    \ checks whether the current element is the next element in the list, and if so,\
    \ stops iterating through the list. Would that be more efficient?\n<|/ c |>\n\
    <| c |>\nI added a while loop that checks whether the current element is the next\
    \ element in the list, and if so, stops iterating through the list. Would that\
    \ be more efficient?\n<|/ c |>\n<| a tags=r,list,sorting |>\n<code>\n> x <- list(c(1,2,3),\
    \ c(4,5,6), c(7,8,9))\n> x\n[[1]]\n[1] 1 2 3\n\n[[2]]\n[1] 4 5 6\n\n[[3]]\n[1]\
    \ 7 8 9\n</code>\nYou can use the function sort.list from the package gtools to\
    \ sort your list by each element of the list. \n<code>\n> library(gtools)\n> sort.list(x)\n\
    [[1]]\n[1] 1 2 3\n\n[[2]]\n[1] 4 5 6\n\n[[3]]\n[1] 7 8 9\n</code>\n<|/ a dscore=5\
    \ |>\n<| c |>\nThis doesn't work if the list contains vectors of different lengths.\n\
    <|/ c |>\n<| c |>\nThis doesn't work if the list contains vectors of different\
    \ lengths.\n<|/ c |>\n<| c |>\nThis doesn't work if the list contains vectors\
    \ of different lengths.\n<|/ c |>\n<| a tags=r,list,sorting |>\n<code>\nx <- list(c(",
  "\n  l <- sort(l)\n  diffs <- c(l[1] - l[-1], NA)\n  all(diffs >= 0)\n}\n</code>\n\
    <|/ a dscore=2 |>\n<| a tags=r,list,sorting |>\n<code>\n> x <- list(c(1,2,4,20),\
    \ c(1,20,4,10), c(4,1,0,-10))\n> x\n[[1]]\n[1] 1 2 4 20\n\n[[2]]\n[1] 1 20 4 10\n\
    \n[[3]]\n[1] 4 1 0 -10\n> \n> y <- sort(x)\n> y\n[[1]]\n[1] 1 2 4 20\n\n[[2]]\n\
    [1] 1 20 4 10\n\n[[3]]\n[1] 4 1 0 -10\n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n\
    > \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n", "\n  l <- sort(l)\n  diffs <- c(l[1], diff(l), l[length(l)])\n\
    \  all(diffs >= 0)\n}\n", "\n  l <- sort(l)\n  diffs <- diff(l) > 0\n  all(diffs)\
    \ || all(diffs[c(TRUE, diffs[length(diffs)])])\n}\n</code>\n<|/ a dscore=5 |>\n\
    <| c |>\nI like your solution, but I wonder if there is a way to make it more\
    \ efficient (maybe by avoiding `sort`?). For instance, `monotonic` could be implemented\
    \ using `diff` only once and `all` could be replaced by `any`.\n<|/ c |>\n<| c\
    \ |>\nI added a version that avoids `sort` but still uses `diff`.\n<|/ c |>\n\
    <| c |>\nI added a version that avoids `sort` but still uses `diff`.\n<|/ c |>\n\
    <| c |>\nI added a version that avoids `sort` but still uses `diff`.\n<|/ c |>\n\
    <| c |>\nI added a version that avoids `sort` but still uses `diff`.\n<|/ c |>\n\
    <| a tags=r,sorting |>\nThe R package monotone does exactly what you want.\n<code>\n\
    library(monotone)\nmonotone(c(1,2,4,20))\n[1] TRUE\nmonotone(c(1,20,4,10))\n[1]\
    \ FALSE\nmonotone(c(4,1,0,-10))\n[1] TRUE\n</code>\n<|/ a dscore=5 |>\n<| c |>\n\
    `monotone` does not appear to work on `data.frame`s.\n<|/ c |>\n<| c |>\n`monotone`\
    \ does work on `data.frame`s. `monotone(c(1,2,4,20))` returns `TRUE`.\n<|/ c |>\n\
    <| c |>\n`monotone` does not appear to work on `data.frame`s.\n<|/ c |>\n<| c\
    \ |>\n`monotone` does work on `data.frame`s. `monotone(c(1,2,4,20))` returns `TRUE`.\n\
    <|/ c |>\n<| c |>\n`monotone` does not appear to work on `data.frame`s.\n<|/ c\
    \ |>\n<| a dscore=5 |>\nHere's a solution using data.table:\n<code>\nlibrary(data.table)\n\
    dt <- data.table(a = c(1,2,4,20))\ndt[, `:=`(b = c(diff(a), NA)), by = a][is.na(b),\
    \ b := 0]\ndt[, `:=`(b = ifelse(is.na(b), 0, b)), by = a]\ndt[, `:=`(b", "\n \
    \ l <- sort(l)\n  diffs <- c(l[1], diff(l))\n  all(diffs > 0)\n}\n</code>\n<|/\
    \ a tags=r,sorting |>\n<| c |>\nThis doesn't seem to work. `monotonic(c(1,2,4,20))`\
    \ returns `FALSE` but `monotonic(c(4,1,0,-10))` returns `TRUE`.\n<|/ c |>\n<|\
    \ c |>\nI added a test case that demonstrates it working. `monotonic` returns\
    \ `TRUE` if the list elements are monotonically increasing or decreasing.\n<|/\
    \ c |>\n<| c |>\nI see what you mean. My bad. I was thinking about it backwards.\
    \ Thanks for clarifying.\n<|/ c |>\n<| a tags=r,sorting |>\n<code>\nmonotonic\
    \ = function(x){\n  if(length(x) == 1){\n    return(TRUE)\n  }\n  if(length(x)\
    \ == 2){\n    return(TRUE)\n  }\n  if(length(x) == 3){\n    return(TRUE)\n  }\n\
    \  if(length(x) == 4){\n    return(TRUE)\n  }\n  if(length(x) == 5){\n    return(TRUE)\n\
    \  }\n  if(length(x) == 6){\n    return(TRUE)\n  }\n  if(length(x) == 7){\n  \
    \  return(TRUE)\n  }\n  if(length(x) == 8){\n    return(TRUE)\n  }\n  if(length(x)\
    \ == 9){\n    return(TRUE)\n  }\n  if(length(x) == 10){\n    return(TRUE)\n  }\n\
    \  if(length(x) == 11){\n    return(TRUE)\n  }\n  if(length(x) == 12){\n    return(TRUE)\n\
    \  }\n  if(length(x) == 13){\n    return(TRUE)\n  }\n  if(length(x) == 14){\n\
    \    return(TRUE)\n  }\n  if(length(x) == 15){\n    return(TRUE)\n  }\n  if(length(x)\
    \ == 16){\n    return(TRUE)\n  }\n  if(length(x) == 17){\n    return(TRUE)\n \
    \ }\n  if(length(x) == 18){\n    return(TRUE)\n  }\n  if(length(x) == 19){\n \
    \   return(TRUE)\n  }\n  if(length(x) == 20){\n    return(TRUE)\n  }\n  if(length(x)\
    \ == 21){\n    return(TRUE)\n  }\n  if(length(x) == 22){\n    return(TRUE)\n \
    \ }\n  if(length(x) == 23){\n    return(TRUE", "\n  l <- sort(l)\n  diffs <- c(l[-1],\
    \ NA)\n  diffs[which(diffs < 0)] <- 0\n  all(diffs[1:(length(l)-1)] < 0)\n}\n\
    </code>\n<|/ a tags=r |>\n<| c |>\nThis doesn't work if you have a list with only\
    \ two elements and one element that is increasing.\n<|/ c |>\n<| c |>\n: I added\
    \ a version that works with that case.\n<|/ c |>\n<| c |>\nI added a version that\
    \ works with that case.\n<|/ c |>\n<| c |>\n: I added a version that works with\
    \ that case.\n<|/ c |>\n<| a tags=r |>\nHere's a solution using data.table:\n\
    <code>\nlibrary(data.table)\nx <- c(1,2,4,20)\ndata.table(x = x)[order(x), .I[seq_len(.N)\
    \ == .N], by = seq_len(.N)]$V1", "\n  l <- sort(l)\n  l[c(TRUE, diff(l)>0)]\n\
    }\n</code>\n<|/ a tags=r,sorting |>\n<| c |>\nThanks for your answer. Your solution\
    \ is very elegant and works well. However I prefer `monotonic` as it is more intuitive\
    \ and easier to understand.\n<|/ c |>\n<| c |>\nI agree, `monotonic` is more intuitive.\
    \ `sort` will sort `NA` values too.\n<|/ c |>\n<| a dscore=2 |>\nThis can be done\
    \ with base R's order:\n<code>\norder(x)", "\n  l <- sort(l)\n  diffs <- c(NA,diff(l))\n\
    \  return(all(diffs==-diffs[1]))\n}\n</code>\n<|/ a tags=r,sorting |>\n<| a dscore=2\
    \ |>\nHere's a solution using data.table:\n<code>\nlibrary(data.table)\ndt <-\
    \ data.table(a = c(1,2,4,20), b = c(2,4,1,-10))\ndt[, c := c(NA, diff(a)), by\
    \ = b][, c := ifelse(is.na(c), a, c)]\n</code>\n<|/ a tags=r,sorting |>\n<| a\
    \ dscore=2 |>\nHere's a solution using dplyr and tidyr:\n<code>\nlibrary(dplyr)\n\
    library(tidyr)\n\ndf <- data.frame(a = c(1,2,4,20), b = c(2,4,1,-10))\n\ndf %>%\
    \ \n  group_by(b) %>% \n  mutate(c = c(NA, diff(a))) %>% \n  ungroup() %>% \n\
    \  mutate(c = ifelse(is.na(c), a, c)) %>% \n  select(-a)\n</code>\n<|/ a tags=r,sorting\
    \ |>\n<| a tags=r,sorting |>\nHere's a base R solution:\n<code>\ndf <- data.frame(a\
    \ = c(1,2,4,20), b = c(2,4,1,-10))\ndf$c <- c(NA, diff(df$a))\ndf$c[is.na(df$c)]\
    \ <- df$a\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\nHere's a solution using\
    \ dplyr and tidyr:\n<code>\nlibrary(dplyr)\nlibrary(tidyr)\n\ndf <- data.frame(a\
    \ = c(1,2,4,20), b = c(2,4,1,-10))\n\ndf %>% \n  group_by(b) %>% \n  mutate(c\
    \ = c(NA, diff(a))) %>% \n  ungroup() %>% \n  mutate(c = ifelse(is.na(c), a, c))\
    \ %>% \n  select(-a)\n</code>\n<|/ a tags=r,sorting |>\n<| a tags=r,sorting |>\n\
    Here's a solution using data.table:\n<code>\nlibrary(data.table)\ndt <- data.table(a\
    \ = c(1,2,4,20), b = c(2,4,1,-10))\ndt[, c := c(NA, diff(a)), by = b][, c := ifelse(is.na(c),\
    \ a, c)]\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0 |>\n", "\n  l <- sort(l)\n\
    \  diffs <- c(l[1], diff(l))\n  all(diffs >= 0)\n}\n</code>\n<|/ a tags=r |>\n\
    <| c |>\nThis does not provide an answer to the question. To critique or request\
    \ clarification from an author, leave a comment below their post.\n<|/ c |>\n\
    <| c |>\nThis does provide an answer to the question. He wants to know if all\
    \ elements in a list are monotonically increasing or decreasing. He also states\
    \ that he wants to know if all elements are unique.\n<|/ c |>\n<| c |>\nThis does\
    \ not provide an answer to the question. To critique or request clarification\
    \ from an author, leave a comment below their post.\n<|/ c |>\n<| c |>\nThis does\
    \ not provide an answer to the question. To critique or request clarification\
    \ from an author, leave a comment below their post.\n<|/ c |>\n<| c |>\nThis does\
    \ not provide an answer to the question. To critique or request clarification\
    \ from an author, leave a comment below their post.\n<|/ c |>\n<| a dscore=3 |>\n\
    <code>\nall(sapply(x, function(x) all(diff(x) > 0))) \n</code>\n<|/ a tags=r |>\n\
    <| c |>\nThis does not provide an answer to the question. To critique or request\
    \ clarification from an author, leave a comment below their post.\n<|/ c |>\n\
    <| c |>\nThis does not provide an answer to the question. To critique or request\
    \ clarification from an author, leave a comment below their post.\n<|/ c |>\n\
    <| c |>\nThis does not provide an answer to the question. To critique or request\
    \ clarification from an author, leave a comment below their post.\n<|/ c |>\n\
    <| a tags=r |>\n<code>\nall(sapply(x, function(x) all(diff(x) > 0))) \n</code>\n\
    <|/ a dscore=3 |>\n<| c |>\nThis does not provide an answer to the question. To\
    \ critique or request clarification from an author, leave a comment below their\
    \ post.\n<|/ c |>\n<| a tags=r |>\n<code>\nall(x[c(TRUE, diff(x) != 0)])\n</code>\n\
    <|/ a dscore=3 |>\n<| c |>\nThis does not provide an answer to the question. To\
    \ critique or request clarification from an author, leave a comment below their\
    \ post.", "\n  n <- length(l) - 1\n  i <- 1\n  while (i <= n) {\n    if (l[i]\
    \ < l[i - 1]) {\n      i <- i + 1\n    } else if (l[i] > l[i - 1]) {\n      i\
    \ <- i + 1\n    } else {\n      i <- i + 1\n    }\n  }\n  return(TRUE)\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| a dscore=1 |>\nA simple and fast solution is to use data.table's\
    \ rleid function which assigns a unique id to each run of equal values in a vector:\n\
    <code>\nlibrary(data.table)\nx <- c(1,1,1,2,2,3,3,3,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,",
  "\n  l <- sort(l)\n  i <- 1\n  while(i < length(l)) {\n    if(l[i] < l[i-1]) {\n\
    \      i <- i + 1\n    } else {\n      i <- i + 1\n      if(l[i] > l[i-1]) {\n\
    \        i <- i + 1\n      }\n    }\n  }\n  return(TRUE)\n}\n", "\n  n <- length(l);\n\
    \  i <- 1;\n  while (i <= n) {\n    if (l[i] < l[i - 1]) {\n      i <- i + 1;\n\
    \    } else {\n      i <- i + 2;\n    }\n  }\n  return(i <= n);\n}\n</code>\n\
    <|/ a tags=r |>\n<| c |>\nThanks for your answer. Your code works perfectly for\
    \ monotonic increasing lists, but not for monotonic decreasing lists. I edited\
    \ my question to make it clearer.\n<|/ c |>\n<| c |>\nI edited my answer to include\
    \ a solution for monotonic decreasing lists.\n<|/ c |>\n<| a tags=r |>\nA simple\
    \ and efficient solution is to use diff:\n<code>\nmonotonic_decreasing <- function(x)\
    \ {\n  diff(x) < 0\n}\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThis doesn't work\
    \ for `monotonic_decreasing(c(1,2,4,20))` which returns `FALSE`\n<|/ c |>\n<|\
    \ c |>\nIt does work for monotonic decreasing lists. Try `monotonic_decreasing(c(1,2,4,20))`\n\
    <|/ c |>\n<| c |>\nI edited my question to make it clearer. Sorry for the confusion.\n\
    <|/ c |>\n<| c |>\nI edited my answer to include a solution for monotonic decreasing\
    \ lists.\n<|/ c |>\n<| a dscore=2 |>\nA simple and efficient solution is to use\
    \ diff:\n<code>\nmonotonic_decreasing <- function(x) {\n  diff(x) < 0\n}\n</code>\n\
    <|/ a tags=r |>\n<| a tags=r |>\n<code>\nmonotonic_decreasing <- function(x) {\n\
    \  diff(x) < 0\n}\n</code>\n<|/ a dscore=2 |>\n<| a tags=r |>\n<code>\nmonotonic_decreasing\
    \ <- function(x) {\n  return(all(diff(x) < 0))\n}\n</code>\n<|/ a dscore=2 |>\n\
    <| a dscore=1 |>\n<code>\nmonotonic_decreasing <- function(x) {\n  return(all(diff(x)\
    \ < 0))\n}\n</code>\n<|/ a tags=r |>\n<| a dscore=1 |>\n<code>\nmonotonic_decreasing\
    \ <- function(x) {\n  return(all(diff(x) < 0))\n}\n</code>\n<|/ a tags=r |>\n\
    <| a tags=r |>\n<code>\nmonot", "\n  l <- sort(l)\n  l[c(TRUE, diff(l)>0)]\n}\n\
    </code>\n<|/ a tags=r |>\n<| a |>\nHere's a solution using dplyr and purrr packages:\n\
    <code>\nlibrary(dplyr)\nlibrary(purrr)\n\ndf <- data.frame(\n  x = c(1, 4, 2,\
    \ 5, 3, 6, 8, 9),\n  y = c(1, 4, 2, 5, 3, 6, 8, 9),\n  z = c(1, 4, 2, 5, 3, 6,\
    \ 8, 9)\n)\n\ndf %>%\n  mutate(\n    z = map2(z, y, ~ifelse(is.na(.x), .y, .x)),\n\
    \    z = map2(z, y, ~ifelse(is.na(.x), .y, .x))\n  )\n\n  x y z\n1 1 1 1\n2 4\
    \ 4 4\n3 2 2 2\n4 5 5 5\n5 3 3 3\n6 6 6 6\n7 8 8 8\n8 9 9 9\n</code>\n<|/ a tags=r\
    \ dscore=1 |>\n<| a tags=r |>\nHere's a solution using dplyr and purrr packages:\n\
    <code>\nlibrary(dplyr)\nlibrary(purrr)\n\ndf <- data.frame(\n  x = c(1, 4, 2,\
    \ 5, 3, 6, 8, 9),\n  y = c(1, 4, 2, 5, 3, 6, 8, 9),\n  z = c(1, 4, 2, 5, 3, 6,\
    \ 8, 9)\n)\n\ndf %>%\n  mutate(\n    z = map2(z, y, ~ifelse(is.na(.x), .y, .x)),\n\
    \    z = map2(z, y, ~ifelse(is.na(.x), .y, .x))\n  )\n\n  x y z\n1 1 1 1\n2 4\
    \ 4 4\n3 2 2 2\n4 5 5 5\n5 3 3 3\n6 6 6 6\n7 8 8 8\n8 9 9 9\n</code>\n<|/ a dscore=1\
    \ |>\n<| a dscore=0 |>\nHere's a solution using base R:\n<code>\ndf <- data.frame(\n\
    \  x = c(1, 4, 2, 5, 3, 6, 8, 9),\n  y = c(1, 4, 2, 5, 3, 6, 8, 9),\n  z = c(1,\
    \ 4, 2, 5, 3, 6, 8, 9)\n)\n\ndf$z <- ifelse(is.na(df$x), df$y, df$x)\ndf$z <-\
    \ ifelse(is.na(df$x), df$y, df$x)\n</code>\n<|/ a tags=r |>\n<| a tags=r |>\n\
    Here's a ", "\n  l <- sort(l)\n  diffs <- c(NA,diff(l))\n  return(all(diffs <\
    \ 0))\n}\n", "\n  l <- sort(l)\n  l[c(TRUE, diff(l) < 0)]\n}\n</code>\n<|/ a dscore=4\
    \ |>\n<| c |>\nI like your solution, but I wonder if there is a way to avoid the\
    \ sort and just use an index to find the next element in the vector. Something\
    \ like `findNext` from Rcpp or RcppArmadillo.\n<|/ c |>\n<| c |>\nI guess you\
    \ could do something like `findNext <- function(x, i) { i <- min(i, length(x)\
    \ - 1); x[i + 1] }`\n<|/ c |>\n<| c |>\nI added a version that doesn't sort the\
    \ vector and uses `findNext` from Rcpp or RcppArmadillo.\n<|/ c |>\n<| a dscore=3\
    \ |>\nHere's a solution using RcppArmadillo:\n<code>", "\n  l <- sort(l)\n  diffs\
    \ <- c(l[1], diff(l), l[length(l)])\n  all(diffs > 0)\n}\n</code>\n<|/ a dscore=5\
    \ |>\n<| c |>\nThis doesn't work for `monotonic([1, 20, 4, 10])` because `diff`\
    \ returns `c(1,0,-1)` instead of `c(1,0,1)`.\n<|/ c |>\n<| c |>\nThanks, I fixed\
    \ it.\n<|/ c |>\n<| c |>\nThis doesn't work for `monotonic([1, 20, 4, 10])` because\
    \ `diff` returns `c(1,0,-1)` instead of `c(1,0,1)`.\n<|/ c |>\n<| c |>\nThanks\
    \ for pointing that out. I fixed it now.\n<|/ c |>\n<| c |>\nThis doesn't work\
    \ for `monotonic([1, 20, 4, 10])` because `diff` returns `c(1,0,-1)` instead of\
    \ `c(1,0,1)`.\n<|/ c |>\n<| a tags=r,sorting |>\nThe solution by is great, but\
    \ I thought I'd add an alternative that doesn't require sorting.\n<code>\nmonotonic\
    \ <- function(x) {\n  y <- x\n  y[1] <- TRUE\n  y[-1] <- FALSE\n  y\n}\n</code>\n\
    <|/ a dscore=5 |>\n<| c |>\nThis doesn't work for `monotonic([1, 20, 4, 10])`\
    \ because `diff` returns `c(1,0,-1)` instead of `c(1,0,1)`.\n<|/ c |>\n<| c |>\n\
    This doesn't work for `monotonic([1, 20, 4, 10])` because `diff` returns `c(1,0,-1)`\
    \ instead of `c(1,0,1)`.\n<|/ c |>\n<| a dscore=4 |>\nHere's a solution using\
    \ data.table:\n<code>\nlibrary(data.table)\ndt <- data.table(x = c(1,4,2,5,3,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20))\n\
    dt[, y := c(TRUE, diff(sort(x)) > 0)]\n</code>\n<|/ a tags=r,sorting |>\n<| c\
    \ |>\nThis doesn't work for `monotonic([1, 20, 4, 10])` because `diff` returns\
    \ `c(1,0,-1)` instead of `c(1,0,1)`.\n<|/ c |>\n<| c |>\nThis doesn't work for\
    \ `monotonic([1, 20, 4, 10])` because `diff` returns `c(1,0,-1)` instead of `c(1,0,1)`.\n\
    <|/ c |>\n<| a tags=r,sorting |>\n<code>", "\n  l <- sort(l)\n  all(diff(l) <\
    \ 0)\n}\n</code>\n<|/ a tags=r,sorting |>\n<| a tags=r,sorting |>\nHere is a solution\
    \ using data.table:\n<code>\nlibrary(data.table)\nsetDT(df)\ndf[, x := c(NA, sort(x))]\n\
    df[, x := c(NA, head(x, -1))]\ndf[, x := c(NA, tail(x, -1))]\n</code>\n<|/ a dscore=2\
    \ |>\n<| a dscore=2 |>\nHere is a solution using dplyr and tidyr:\n<code>\nlibrary(dplyr)\n\
    library(tidyr)\n\ndf %>% \n  mutate(id = row_number()) %>% \n  arrange(id, x)\
    \ %>% \n  group_by(id) %>% \n  mutate(x_new = c(NA, sort(x))) %>% \n  mutate(x_new\
    \ = c(NA, head(x_new, -1))) %>% \n  mutate(x_new = c(NA, tail(x_new, -1))) %>%\
    \ \n  select(-id)\n</code>\n<|/ a tags=r,sorting |>\n<| a dscore=2 |>\nHere is\
    \ a solution using data.table:\n<code>\nlibrary(data.table)\nsetDT(df)\ndf[, x\
    \ := c(NA, sort(x))]\ndf[, x := c(NA, head(x, -1))]\ndf[, x := c(NA, tail(x, -1))]\n\
    </code>\n<|/ a tags=r,sorting |>\n<| a |>\nHere is a solution using dplyr and\
    \ tidyr:\n<code>\nlibrary(dplyr)\nlibrary(tidyr)\n\ndf %>% \n  mutate(id = row_number())\
    \ %>% \n  arrange(id, x) %>% \n  group_by(id) %>% \n  mutate(x_new = c(NA, sort(x)))\
    \ %>% \n  mutate(x_new = c(NA, head(x_new, -1))) %>% \n  mutate(x_new = c(NA,\
    \ tail(x_new, -1))) %>% \n  select(-id)\n</code>\n<|/ a dscore=2 tags=r,sorting\
    \ |>\n<| a dscore=1 |>\nHere is a solution using dplyr and tidyr:\n<code>\nlibrary(dplyr)\n\
    library(tidyr)\n\ndf %>% \n  mutate(id = row_number()) %>% \n  arrange(id, x)\
    \ %>% \n  group_by(id) %>% \n  mutate(x_new = c(NA, sort(x))) %>% \n  mutate(x_new\
    \ = c(NA, head(x_new, -1))) %>% \n  mutate(x_new = c(NA, tail(x_new, -1))) %>%\
    \ \n", "\n  l <- sort(l)\n  diffs <- diff(l) > 0\n  all(diffs) || (all(diffs[c(TRUE,\
    \ FALSE)]) & all(diffs[c(FALSE, TRUE)]))\n}\n</code>\n<|/ a tags=r,sorting |>\n\
    <| c |>\nThis doesn't seem to work when `l` is `c(4, 1, -10, 2)`.\n<|/ c |>\n\
    <| c |>\nIt does work. `monotonic(c(4, 1, -10, 2))` returns `TRUE`.\n<|/ c |>\n\
    <| c |>\nIt does work, but I believe it shouldn't. `c(4, 1, -10, 2)` should be\
    \ sorted before `monotonic` is applied, so `c(4, 1, -10, 2)` should be sorted\
    \ before `c(4, 1, -10, 2)` is sorted, which should return `TRUE`. `c(4, 1, -10,\
    \ 2)` should be sorted before `c(4, 1, -10, 2)` is sorted, which should return\
    \ `FALSE`. `c(4, 1, -10, 2)` should be sorted before `c(4, 1, -10, 2)` is sorted,\
    \ which should return `TRUE`. `c(4, 1, -10, 2)` should be sorted before `c(4,\
    \ 1, -10, 2)` is sorted, which should return `FALSE`. `c(4, 1, -10, 2)` should\
    \ be sorted before `c(4, 1, -10, 2)` is sorted, which should return `TRUE`. `c(4,\
    \ 1, -10, 2)` should be sorted before `c(4, 1, -10, 2)` is sorted, which should\
    \ return `FALSE`. `c(4, 1, -10, 2)` should be sorted before `c(4, 1, -10, 2)`\
    \ is sorted, which should return `TRUE`. `c(4, 1, -10, 2)` should be sorted before\
    \ `c(4, 1, -10, 2)` is sorted, which should return `FALSE`. `c(4, 1, -10, 2)`\
    \ should be sorted before `c(4, 1, -10, 2)` is sorted, which should return `TRUE`.\
    \ `c(4, 1, -10, 2)` should be sorted before `c(4, 1, -10, 2)` is sorted, which\
    \ should return `FALSE`. `c(4, 1, -10, 2)` should be sorted before `c(4, 1, -10,\
    \ 2)` is sorted, which should return `TRUE`. `c(4, 1, -10, 2)` should be sorted\
    \ before `c(4, 1, -10, 2)` is sorted, which should return `FALSE`. `c(4, 1, -10,\
    \ 2)` should be sorted before `c(4, 1, -10, 2)` is sorted, which should return\
    \ `TRUE`. `c(4, 1, -10, 2)` should be sorted before `c(4, 1, -10, 2)", "\n  l\
    \ <- sort(l)\n  i <- 1\n  while(i < length(l)) {\n    if(l[i] < l[i - 1]) {\n\
    \      i <- i + 1\n    } else {\n      i <- i + 1\n      if(l[i] > l[i - 1]) {\n\
    \        i <- i + 1\n      }\n    }\n  }\n  return(TRUE)\n}\n</code>\n<|/ a tags=r,sorting\
    \ |>\n<| c |>\nThis doesn't work if you have a list with duplicates. For example,\
    \ `monotonic(c(1,2,2,3,4))` returns `FALSE`, but `monotonic(c(1,2,2,3,4))` returns\
    \ `TRUE`.\n<|/ c |>\n<| c |>\n: I added a fix for duplicates.\n<|/ c |>\n<| c\
    \ |>\nThis doesn't work for `monotonic(c(1,2,2,3,4))` returns `FALSE`, but `monotonic(c(1,2,2,3,4))`\
    \ returns `TRUE`.\n<|/ c |>\n<| c |>\n: I added a fix for duplicates.\n<|/ c |>\n\
    <| c |>\nThis doesn't work for `monotonic(c(1,2,2,3,4))` returns `FALSE`, but\
    \ `monotonic(c(1,2,2,3,4))` returns `TRUE`.\n<|/ c |>\n<| a |>\nA simple and efficient\
    \ solution using data.table:\n<code>\nlibrary(data.table)\ndt <- data.table(a\
    \ = c(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20), \n                \
    \ b = c(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20))\ndt[order(a), .I]\n\
    </code>\n<|/ a tags=r,sorting dscore=5 |>\n<| c |>\nThis doesn't work for `dt[order(a),\
    \ .I]` returns `FALSE`, but `dt[order(a), .I]` returns `TRUE`.\n<|/ c |>\n<| c\
    \ |>\nThis doesn't work for `dt[order(a), .I]` returns `FALSE`, but `dt[order(a),\
    \ .I]` returns `TRUE`.\n<|/ c |>\n<| c |>\nThis doesn't work for `dt[order(a),\
    \ .I]` returns `FALSE`, but `dt[order(a), .I]` returns `TRUE`.\n<|/ c |>\n<| c\
    \ |>\nThis doesn't work for `dt[order(a), .I]` returns `FALSE`, but `dt[order(a),\
    \ .I]` returns `TRUE`.", "\n  l <- sort(l)\n  diffs <- c(NA,diff(l))\n  return(all(diffs\
    \ >= 0))\n}\n</code>\n<|/ a |>\n<| c |>\nThanks for your answer. Your solution\
    \ is very elegant and works perfectly for my problem. I'm still wondering if there\
    \ is a way to do this without using an external package. I'm still learning R\
    \ and I find it difficult to find solutions to problems like this without using\
    \ external packages.\n<|/ c |>\n<| c |>\nI added a solution without an external\
    \ package. Hope it helps.\n<|/ c |>\n<| c |>\nThanks for your answer. I was able\
    \ to adapt your solution to my problem. I'm still learning R and I find it difficult\
    \ to find solutions to problems like this without using external packages. I appreciate\
    \ your help.\n<|/ c |>\n<| a dscore=0 |>\n<code>", "\n  l <- sort(l)\n  diffs\
    \ <- c(l[1], diff(l), l[length(l)])\n  all(diffs >= 0)\n}\n</code>\n<|/ a |>\n\
    <| c |>\nThanks, this works great! I added a little bit of code to make it work\
    \ for vectors of different lengths.\n<|/ c |>\n<| c |>\nThanks for your comment.\
    \ I've added a version that works for vectors of different lengths.\n<|/ c |>\n\
    <| a dscore=2 |>\nHere's a solution using data.table:\n<code>\nlibrary(data.table)\n\
    dt <- data.table(a = c(1,2,4,10), b = c(2,4,1,-10))\ndt[, diff := c(NA, diff(a),\
    \ NA), by = a][diff > 0, .SD[which.max(diff)], by = a]\n</code>\n<|/ a tags=r,sorting\
    \ |>\n<| c |>\nThanks, this works great! I added a little bit of code to make\
    \ it work for vectors of different lengths.\n<|/ c |>\n<| a dscore=2 |>\nHere's\
    \ a solution using dplyr and purrr packages:\n<code>\nlibrary(dplyr)\nlibrary(purrr)\n\
    \ndf <- data.frame(a = c(1,2,4,10), b = c(2,4,1,-10))\n\ndf %>% \n  mutate(diff\
    \ = map2_dbl(a, a, ~c(NA, .x - .y)) %>% \n           reduce(`+`)) %>% \n  filter(diff\
    \ > 0) %>% \n  group_by(a) %>% \n  slice(which.max(diff)) %>% \n  ungroup()\n",
  "\n  l <- sort(l)\n  l[c(TRUE, diff(l) > 0)]\n}\n</code>\n<|/ a dscore=2 |>\n<|\
    \ c |>\nI like the idea of using diff to identify the changes. I didn't know about\
    \ that function. Thanks!\n<|/ c |>\n<| a dscore=1 |>\nHere's a solution using\
    \ data.table:\n<code>\nlibrary(data.table)\ndt <- data.table(x = c(1,2,4,20))\n\
    dt[, y := c(NA, diff(x)), by = seq_len(.N)]\ndt[, y := ifelse(is.na(y), x, y)]\n\
    </code>\n<|/ a tags=r,time-series,dplyr |>\n<| c |>\nThanks for your answer. I'm\
    \ going to try this out and see how it compares to other solutions.\n<|/ c |>\n\
    <| a dscore=1 |>\nHere's a solution using dplyr and zoo:\n<code>\nlibrary(dplyr)\n\
    library(zoo)\n\ndf <- data.frame(x = c(1,2,4,20))\ndf %>% \n  mutate(y = lag(x,\
    \ default = 0) + lead(x, default = 0))\n</code>\n<|/ a tags=r,time-series,dplyr\
    \ |>\n<| a tags=r,time-series,dplyr |>\nHere's a solution using dplyr and zoo:\n\
    <code>\nlibrary(dplyr)\nlibrary(zoo)\n\ndf <- data.frame(x = c(1,2,4,20))\ndf\
    \ %>% \n  mutate(y = lag(x, default = 0) + lead(x, default = 0))\n</code>\n<|/\
    \ a dscore=1 |>\n<| a tags=r,time-series,dplyr |>\nHere's a solution using dplyr\
    \ and zoo:\n<code>\nlibrary(dplyr)\nlibrary(zoo)\n\ndf <- data.frame(x = c(1,2,4,20))\n\
    df %>% \n  mutate(y = lag(x, default = 0) + lead(x, default = 0))\n</code>\n<|/\
    \ a dscore=1 |>\n<| a tags=r,time-series,dplyr |>\nHere's a solution using dplyr\
    \ and zoo:\n<code>\nlibrary(dplyr)\nlibrary(zoo)\n\ndf <- data.frame(x = c(1,2,4,20))\n\
    df %>% \n  mutate(y = lag(x, default = 0) + lead(x, default = 0))\n</code>\n<|/\
    \ a dscore=1 |>\n<| a tags=r,time-series,dplyr |>\nHere's a solution using dplyr\
    \ and zoo:\n<code>\nlibrary(dplyr)\nlibrary(zoo)\n\ndf <- data.", "\n  l <- sort(l)\n\
    \  i <- 1\n  while(i < length(l)) {\n    if(l[i] < l[i-1]) {\n      i <- i + 1\n\
    \    } else {\n      i <- i + 1\n      if(l[i] > l[i-1]) {\n        i <- i + 1\n\
    \      }\n    }\n  }\n  return(TRUE)\n}\n</code>\n<|/ a tags=r,sorting |>\n<|\
    \ c |>\nThis doesn't work if you have a list with two or more equal elements.\
    \ For example, `monotonic(c(1,2,4,20))` returns `FALSE`, but `monotonic(c(1,2,4,20,20))`\
    \ returns `TRUE`.\n<|/ c |>\n<| c |>\n: I added a version that works with lists\
    \ with two or more equal elements.\n<|/ c |>\n<| c |>\nThis doesn't work if you\
    \ have a list with two or more equal elements. For example, `monotonic(c(1,2,4,20))`\
    \ returns `FALSE`, but `monotonic(c(1,2,4,20,20))` returns `TRUE`.\n<|/ c |>\n\
    <| c |>\n: I added a version that works with lists with two or more equal elements.\n\
    <|/ c |>\n<| c |>\nThis doesn't work if you have a list with two or more equal\
    \ elements. For example, `monotonic(c(1,2,4,20))` returns `FALSE`, but `monotonic(c(1,2,4,20,20))`\
    \ returns `TRUE`.\n<|/ c |>\n<| a dscore=4 |>\nI like using rle:\n<code>\nrle(sort(x))$values\n\
    </code>\n<|/ a tags=r,sorting |>\n<| c |>\nThis doesn't work if you have a list\
    \ with two or more equal elements. For example, `rle(sort(c(1,2,4,20)))` returns\
    \ `FALSE`, but `rle(sort(c(1,2,4,20,20)))` returns `TRUE`.\n<|/ c |>\n<| c |>\n\
    This doesn't work if you have a list with two or more equal elements. For example,\
    \ `rle(sort(c(1,2,4,20)))` returns `FALSE`, but `rle(sort(c(1,2,4,20,20)))` returns\
    \ `TRUE`.\n<|/ c |>\n<| c |>\nThis doesn't work if you have a list with two or\
    \ more equal elements. For example, `rle(sort(c(1,2,4,20)))` returns `FALSE`,\
    \ but `rle(sort(c(1,2,4,20,20)))` returns `TRUE`.\n<|/ c |>\n<| a tags=r,sorting\
    \ |>\n<code>\nx <- c(1,2,4,20)\nx", "\n  l <- sort(l)\n  i <- 1\n  while (i <\
    \ length(l)-1 && l[i] == l[i+1]) {\n    i <- i + 1\n  }\n  return(i < length(l)-1)\n\
    }\n", "\n  l <- sort(l)\n  l[c(TRUE, diff(l) > 0)]\n}\n</code>\n<|/ a tags=r,sorting\
    \ |>\n<| a tags=r,sorting |>\n<code>", "\n  l <- sort(l)\n  diffs <- c(l[-1] -\
    \ l[-length(l)], 0)\n  all(diffs >= 0) & all(diffs <= 1)\n}\n</code>\n<|/ a dscore=4\
    \ |>\n<| c |>\nI like your answer, but I don't think it works. Try it with `monotonic(c(1,2,4,20))`.\
    \ It returns `FALSE`, but `c(1,2,4,20)` does indeed have a monotonic increasing\
    \ sequence.\n<|/ c |>\n<| c |>\nI see what you mean. I've edited my answer to\
    \ fix the problem.\n<|/ c |>\n<| c |>\nI like your answer, but I don't think it\
    \ works. Try it with `monotonic(c(1,2,4,20))`. It returns `FALSE`, but `c(1,2,4,20)`\
    \ does indeed have a monotonic increasing sequence.\n<|/ c |>\n<| c |>\nI see\
    \ what you mean. I've edited my answer to fix the problem.\n<|/ c |>\n<| c |>\n\
    I like your answer, but I don't think it works. Try it with `monotonic(c(1,2,4,20))`.\
    \ It returns `FALSE`, but `c(1,2,4,20)` does indeed have a monotonic increasing\
    \ sequence.\n<|/ c |>\n<| a tags=r,sorting |>\nI like your answer, but I don't\
    \ think it works. Try it with monotonic(c(1,2,4,20)).\nIt returns FALSE, but c(1,2,4,20)\
    \ does indeed have a monotonic increasing sequence.\n\nTry this instead:\n<code>\n\
    monotonic_inc <- function(x) {\n  x <- sort(x)\n  diffs <- c(tail(x, -1) - head(x,\
    \ -1), 0)\n  all(diffs >= 0) & all(diffs <= 1)\n}\n</code>\n<|/ a dscore=4 |>\n\
    <| c |>\nI like your answer, but I don't think it works. Try it with `monotonic_inc(c(1,2,4,20))`.\
    \ It returns `FALSE`, but `c(1,2,4,20)` does indeed have a monotonic increasing\
    \ sequence.\n<|/ c |>\n<| c |>\nI like your answer, but I don't think it works.\
    \ Try it with `monotonic_inc(c(1,2,4,20))`. It returns `FALSE`, but `c(1,2,4,20)`\
    \ does indeed have a monotonic increasing sequence.\n<|/ c |>\n<| c |>\nI like\
    \ your answer, but I don't think it works. Try it with `monotonic_inc(c(1,2,4,20))",
  "\n  l <- sort(l)\n  i <- 1\n  while(i < length(l)) {\n    if(l[i] < l[i - 1]) {\n\
    \      i <- i + 1\n    } else {\n      i <- i + 1\n      if(l[i] > l[i - 1]) {\n\
    \        i <- i + 1\n      }\n    }\n  }\n  return(TRUE)\n}\n</code>\n<|/ a dscore=2\
    \ |>\n<| a dscore=2 |>\n<code>\nmonotonic = function(a) {\n  a = sort(a)\n  for(i\
    \ in 1:length(a)) {\n    if(a[i] < a[i - 1]) {\n      return(FALSE)\n    }\n \
    \ }\n  return(TRUE)\n}\n</code>\n<|/ a tags=r |>\n<| c |>\nThis doesn't work if\
    \ `a` is `c(NA,NA,NA,NA)`\n<|/ c |>\n<| a |>\n<code>\nmonotonic = function(a)\
    \ {\n  a = sort(a)\n  for(i in 1:length(a)) {\n    if(a[i] < a[i - 1]) {\n   \
    \   return(FALSE)\n    }\n  }\n  return(TRUE)\n}\n</code>\n<|/ a tags=r dscore=2\
    \ |>\n<| a tags=r |>\n<code>\nmonotonic = function(a) {\n  a = sort(a)\n  for(i\
    \ in 1:length(a)) {\n    if(a[i] < a[i - 1]) {\n      return(FALSE)\n    }\n \
    \ }\n  return(TRUE)\n}\n</code>\n<|/ a dscore=1 |>\n<| a tags=r |>\n<code>\nmonotonic\
    \ = function(a) {\n  a = sort(a)\n  for(i in 1:length(a)) {\n    if(a[i] < a[i\
    \ - 1]) {\n      return(FALSE)\n    }\n  }\n  return(TRUE)\n}\n</code>\n<|/ a\
    \ dscore=1 |>\n<| a tags=r |>\n<code>\nmonotonic = function(a) {\n  a = sort(a)\n\
    \  for(i in 1:length(a)) {\n    if(a[i] < a[i - 1]) {\n      return(FALSE)\n \
    \   }\n  }\n  return(TRUE)\n}\n</code>\n<|/ a dscore=1 |>\n<| a tags=r |>\n<code>\n\
    monotonic = function(a) {\n  a = sort(a)\n  for(i in 1:length(a)) {\n    if(a[i]\
    \ < a[i - 1]) {\n      return(FALSE)\n    }\n  }\n  return(TRUE)\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| a tags=r |>\n<code>", "\n  l <- sort(l)\n  diffs <- c(l[1],\
    \ diff(l), l[length(l)])\n  all(diffs > 0)\n}\n</code>\n<|/ a tags=r,list,sorting\
    \ |>\n<| c |>\nI like the idea of using diff, but this doesn't seem to work when\
    \ there are two consecutive negative numbers in the list. For example: `monotonic(c(-2,\
    \ -1, -1, 1, 2))` returns `FALSE`, but `monotonic(c(-2, -1, -1, 1, -2, 2))` returns\
    \ `TRUE`. Any ideas on how to fix this?\n<|/ c |>\n<| c |>\nI added a fix for\
    \ that case to the answer.\n<|/ c |>\n<| c |>\nThanks, this works great! I added\
    \ a fix to my question to include a case where there are two consecutive negative\
    \ numbers in the list.\n<|/ c |>\n<| a dscore=1 |>\nHere's a solution using data.table:\n\
    <code>\nlibrary(data.table)\nlibrary(magrittr)\n", "\n  l <- sort(l)\n  diffs\
    \ <- c(NA,diff(l))\n  return(all(diffs < 0))\n}\n", "\n  l <- sort(l)\n  diffs\
    \ <- c(l[-1]-l[-length(l)]) # diff of consecutive elements\n  all(diffs >= 0)\
    \ # all diff are positive\n}\n</code>\n<|/ a dscore=4 |>\n<| c |>\nThis doesn't\
    \ work for negative numbers. Try `monotonic(c(-2, -1, 0, 1))`\n<|/ c |>\n<| c\
    \ |>\n: I added a check for negative numbers. Thanks!\n<|/ c |>\n<| c |>\nThis\
    \ doesn't work for negative numbers. Try `monotonic(c(-2, -1, 0, 1))`\n<|/ c |>\n\
    <| c |>\n: I added a check for negative numbers. Thanks!\n<|/ c |>\n<| c |>\n\
    This doesn't work for negative numbers. Try `monotonic(c(-2, -1, 0, 1))`\n<|/\
    \ c |>\n<| a tags=r |>\nA simple and fast solution:\n<code>\nmonotonic = function(a)\
    \ {\n  a = sort(a)\n  diffs = c(a[-1] - a[-length(a)])\n  all(diffs >= 0)\n}\n\
    </code>\n<|/ a dscore=4 |>\n<| c |>\nThis doesn't work for negative numbers. Try\
    \ `monotonic(c(-2, -1, 0, 1))`\n<|/ c |>\n<| c |>\nThis doesn't work for negative\
    \ numbers. Try `monotonic(c(-2, -1, 0, 1))`\n<|/ c |>\n<| a dscore=3 |>\nA simple\
    \ and fast solution:\n<code>\nmonotonic = function(a) {\n  a = sort(a)\n  diffs\
    \ = c(a[-1] - a[-length(a)])\n  all(diffs >= 0)\n}\n</code>\n<|/ a tags=r |>\n\
    <| c |>\nThis doesn't work for negative numbers. Try `monotonic(c(-2, -1, 0, 1))`\n\
    <|/ c |>\n<| a tags=r |>\nA simple and fast solution:\n<code>\nmonotonic = function(a)\
    \ {\n  a = sort(a)\n  diffs = c(a[-1] - a[-length(a)])\n  all(diffs >= 0)\n}\n\
    </code>\n<|/ a dscore=3 |>\n<| a dscore=3 |>\nA simple and fast solution:\n<code>\n\
    monotonic = function(a) {\n  a = sort(a)\n  diffs = c(a[-1] - a[-length(a)])\n\
    \  all(diffs >= 0)\n}\n</code>\n<|/ a tags=r |>\n<| a dscore=3 |>\nA simple and\
    \ fast solution:\n<code>\nmonotonic = function", "\n  l <- sort(l)\n  l[c(TRUE,\
    \ diff(l)>0)]\n}\n", "\n  l <- sort(l)\n  l[1] < l[2] & l[1] < l[3] & l[2] < l[3]\
    \ & l[1] < l[4]\n}\n</code>\n<|/ a |>\n<| c |>\nI like your solution, however\
    \ it fails for `monotonic(list(c(NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA",
  "\n  l <- sort(l)\n  diffs <- c(l[-1], NA) - l\n  all(diffs >= 0) & all(diffs <=\
    \ 0)\n}\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis doesn't work for `monotonic([1,\
    \ 20, 4, 10])` because `diffs` will be `c(NA, NA, NA, NA)` which is not `c(NA,\
    \ NA)`.\n<|/ c |>\n<| c |>\nYes, you're right. I've updated the answer accordingly.\n\
    <|/ c |>\n<| c |>\nI like your solution, but I wonder if there is a way to do\
    \ this without looping through the list. Something like `sapply(l, function(x)\
    \ all(diff(x) >= 0) & all(diff(x) <= 0))`\n<|/ c |>\n<| c |>\nYes, that's possible,\
    \ but I wouldn't recommend it because it will be slower than the vectorized solution.\n\
    <|/ c |>\n<| c |>\nI wonder if there is a way to do this without looping through\
    \ the list. Something like `sapply(l, function(x) all(diff(x) >= 0) & all(diff(x)\
    \ <= 0))`\n<|/ c |>\n<| a tags=r |>\n<code>\nlibrary(data.table)\nlibrary(zoo)\n\
    \nx <- c(1,2,4,20)\ny <- c(1,20,4,10)\n\nz <- data.table(x,y)\nz[,.(diff=c(NA,diff(y)-c(NA,y[1])),\n\
    \      diff2=c(NA,diff(y)-c(NA,y[1])),\n      diff3=c(NA,diff(y)-c(NA,y[1])),\n\
    \      diff4=c(NA,diff(y)-c(NA,y[1])),\n      diff5=c(NA,diff(y)-c(NA,y[1])),\n\
    \      diff6=c(NA,diff(y)-c(NA,y[1])),\n      diff7=c(NA,diff(y)-c(NA,y[1])),\n\
    \      diff8=c(NA,diff(y)-c(NA,y[1])),\n      diff9=c(NA,diff(y)-c(NA,y[1])),\n\
    \      diff10=c(NA,diff(y)-c(NA,y[1])),\n      diff11=c(NA,diff(y)-c(NA,y[1])),\n\
    \      diff12=c(NA,diff(y)-c(NA,y[1])),\n      diff13=c(NA,diff(y)-c(NA,y[1])),\n\
    \      diff14=c(NA,diff(y)-c(NA,y[1])),\n      diff15=c(", "\n  l <- sort(l)\n\
    \  diffs <- c(l[1], diff(l))\n  all(diffs < 0)\n}\n</code>\n<|/ a tags=r,sorting\
    \ |>\n<| c |>\nI like this solution, but I wonder if there is a way to do it without\
    \ sorting the whole list. Maybe by using a binary search to find the first element\
    \ that is out of order?\n<|/ c |>\n<| c |>\n: Yes, that's a good idea. I'll add\
    \ an answer with that approach.\n<|/ c |>\n<| a dscore=3 |>\nHere's a solution\
    \ using binary search to find the first element that is out of order:\n<code>\n\
    monotonic2 <- function(x) {\n  i <- 0\n  while(TRUE) {\n    i <- i + 1 \n    x\
    \ <- sort(x)\n    if(diff(x) < 0) break\n  }\n  return(x[i])\n}\n</code>\n<|/\
    \ a tags=r,sorting |>\n<| c |>\nI like this solution, but I wonder if there is\
    \ a way to do it without sorting the whole list. Maybe by using a binary search\
    \ to find the first element that is out of order?\n<|/ c |>\n<| c |>\n: Yes, that's\
    \ a good idea. I'll add an answer with that approach.\n<|/ c |>\n<| a dscore=3\
    \ |>\nHere's a solution using binary search to find the first element that is\
    \ out of order:\n<code>\nmonotonic3 <- function(x) {\n  i <- 0\n  while(TRUE)\
    \ {\n    i <- i + 1 \n    x <- sort(x)\n    if(diff(x) < 0) break\n  }\n  return(x[i])\n\
    }\n</code>\n<|/ a tags=r,sorting |>\n<| c |>\nI like this solution, but I wonder\
    \ if there is a way to do it without sorting the whole list. Maybe by using a\
    \ binary search to find the first element that is out of order?\n<|/ c |>\n<|\
    \ c |>\n: Yes, that's a good idea. I'll add an answer with that approach.\n<|/\
    \ c |>\n<| a tags=r,sorting |>\nHere's a solution using binary search to find\
    \ the first element that is out of order:\n<code>\nmonotonic4 <- function(x) {\n\
    \  i <- 0\n  while(TRUE) {\n    i <- i + 1 \n    x <- sort(x)\n    if(diff(x)\
    \ < 0) break\n  }\n  return(x[i])\n}\n</code>\n<|/ a dscore=3 |>\n<| a dscore=3\
    \ |>\nHere's a solution using binary search to find the first element that is\
    \ out of order:\n<code>\nmonotonic5 <- ", "\n  l <- sort(l)\n  diffs <- c(l[1],\
    \ diff(l))\n  all(diffs >= 0) & all(diffs <= 1)\n}\n</code>\n<|/ a dscore=4 |>\n\
    <| c |>\nI like your solution, but I wonder if there is a way to make it more\
    \ efficient. My dataset is very large and I wonder if there is a way to make it\
    \ more efficient.\n<|/ c |>\n<| c |>\nI added a more efficient version that uses\
    \ `diff` instead of `diffs`.\n<|/ c |>\n<| c |>\nThanks for the update. I will\
    \ try it out and let you know if it works.\n<|/ c |>\n<| c |>\nI added a more\
    \ efficient version that uses `diff` instead of `diffs`.\n<|/ c |>\n<| c |>\n\
    Thanks for the update. I will try it out and let you know if it works.\n<|/ c\
    \ |>\n<| a tags=r,sorting |>\n<code>\nmonotonic = function(x){\n  x = sort(x)\n\
    \  diffs = c(head(x, -1), diff(x))\n  all(diffs >= 0) & all(diffs <= 1)\n}\n</code>\n\
    <|/ a dscore=3 |>\n<| c |>\nThanks for the update. I will try it out and let you\
    \ know if it works.\n<|/ c |>\n<| a |>\n<code>\nmonotonic = function(x){\n  x\
    \ = sort(x)\n  diffs = c(head(x, -1), diff(x))\n  all(diffs >= 0) & all(diffs\
    \ <= 1)\n}\n</code>\n<|/ a dscore=3 tags=r,sorting |>\n<| c |>\nThanks for the\
    \ update. I will try it out and let you know if it works.\n<|/ c |>\n<| a tags=r,sorting\
    \ |>\n<code>\nmonotonic = function(x){\n  x = sort(x)\n  diffs = c(head(x, -1),\
    \ diff(x))\n  all(diffs >= 0) & all(diffs <= 1)\n}\n</code>\n<|/ a dscore=3 |>\n\
    <| c |>\nThanks for the update. I will try it out and let you know if it works.\n\
    <|/ c |>\n<| a dscore=2 |>\n<code>\nmonotonic = function(x){\n  x = sort(x)\n\
    \  diffs = c(head(x, -1), diff(x))\n  all(diffs >= 0) & all(diffs <= 1)\n}\n</code>\n\
    <|/ a tags=r,sorting |>\n<| a tags=r,sorting |>\n<code>\nmonotonic = function(x){\n\
    \  x = sort(x)\n  diffs = ", "\n  l <- sort(l)\n  diffs <- c(l[1], diff(l))\n\
    \  all(diffs > 0)\n}\n</code>\n<|/ a tags=r,sorting |>\n<| c |>\nThis doesn't\
    \ seem to work if you have a list with two or more consecutive identical elements.\
    \ For example, `monotonic(c(1,2,2,3,4))` returns `FALSE`, but `monotonic(c(1,2,2,3,4))`\
    \ returns `TRUE`.\n<|/ c |>\n<| c |>\n: I see what you mean. I've updated the\
    \ answer to account for that case.\n<|/ c |>\n<| c |>\nThis doesn't seem to work\
    \ if you have a list with two or more consecutive identical elements. For example,\
    \ `monotonic(c(1,2,2,3,4))` returns `FALSE`, but `monotonic(c(1,2,2,3,4))` returns\
    \ `TRUE`.\n<|/ c |>\n<| c |>\n: I see what you mean. I've updated the answer to\
    \ account for that case.\n<|/ c |>\n<| a dscore=3 |>\n<code>\nmonotonic<-function(x){\n\
    \  x<-sort(x)\n  y<-x[1]\n  for(i in 2:length(x)){\n    if(y>x[i]){\n      y<-x[i]\n\
    \    }\n  }\n  y<-ifelse(y>x[1],y,x[1])\n  y<-ifelse(y>x[2],y,x[2])\n  y<-ifelse(y>x[3],y,x[3])\n\
    \  y<-ifelse(y>x[4],y,x[4])\n  y<-ifelse(y>x[5],y,x[5])\n  y<-ifelse(y>x[6],y,x[6])\n\
    \  y<-ifelse(y>x[7],y,x[7])\n  y<-ifelse(y>x[8],y,x[8])\n  y<-ifelse(y>x[9],y,x[9])\n\
    \  y<-ifelse(y>x[10],y,x[10])\n  y<-ifelse(y>x[11],y,x[11])\n  y<-ifelse(y>x[12],y,x[12])\n\
    \  y<-ifelse(y>x[13],y,x[13])\n  y<-ifelse(y>x[14],y,x[14])\n  y<-ifelse(y>x[15],y,x[15])\n\
    \  y<-ifelse(y>x[16],y,x[16])\n  y<-ifelse", "\n  l <- sort(l)\n  diffs <- c(l[1],\
    \ diff(l))\n  all(diffs > 0)\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThanks for\
    \ your answer. I'm still not clear on how this would work. Could you please elaborate?\n\
    <|/ c |>\n<| c |>\nI added an explanation to the answer. Hope it helps.\n<|/ c\
    \ |>\n<| c |>\nThanks for your answer. I'm still not clear on how this would work.\
    \ Could you please elaborate?\n<|/ c |>\n<| c |>\nI added an explanation to the\
    \ answer. Hope it helps.\n<|/ c |>\n<| c |>\nThanks for your answer. I'm still\
    \ not clear on how this would work. Could you please elaborate?\n<|/ c |>\n<|\
    \ a dscore=2 |>\n<code>\nlibrary(dplyr)\nlibrary(purrr)\n\ndf %>%\n  mutate(across(everything(),\
    \ ~if_else(\n    is.na(.), NA_real_, \n    case_when(\n      is.na(lag(.)) ~ lag(.),\n\
    \      is.na(lead(.)) ~ lead(.),\n      TRUE ~ lag(.) - lead(.)\n    )\n  )))\
    \ %>%\n  mutate(across(everything(), ~if_else(\n    is.na(.), NA_real_, \n   \
    \ case_when(\n      is.na(lag(.)) ~ lag(.),\n      is.na(lead(.)) ~ lead(.),\n\
    \      TRUE ~ lag(.) - lead(.)\n    )\n  ))) %>%\n  mutate(across(everything(),\
    \ ~if_else(\n    is.na(.), NA_real_, \n    case_when(\n      is.na(lag(.)) ~ lag(.),\n\
    \      is.na(lead(.)) ~ lead(.),\n      TRUE ~ lag(.) - lead(.)\n    )\n  )))\
    \ %>%\n  mutate(across(everything(), ~if_else(\n    is.na(.), NA_real_, \n   \
    \ case_when(\n      is.na(lag(.)) ~ lag(.),\n      is.na(lead(.)) ~ lead(.),\n\
    \      TRUE ~ lag(.) - lead(.)\n    )\n  ))) %>%\n  mutate(across(everything(),\
    \ ~if_else(\n    is.na(.), NA_real_, \n    ", "\n  l <- sort(l)\n  i <- 1\n  while(i\
    \ < length(l)) {\n    if(l[i] < l[i - 1]) {\n      i <- i + 1\n    } else {\n\
    \      i <- i + 1\n      if(l[i] > l[i - 1]) {\n        i <- i + 1\n      }\n\
    \    }\n  }\n  return(TRUE)\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThanks for\
    \ your answer. Your code works well for monotonic lists, but not for non-monotonic\
    \ lists. For example, `monotonic(c(1,2,4,20))` returns `FALSE`, but `monotonic(c(1,2,4,20,20))`\
    \ returns `TRUE`. Any idea how to fix this?\n<|/ c |>\n<| c |>\nI added a fix\
    \ for non-monotonic lists.\n<|/ c |>\n<| c |>\nThanks for your answer. Your code\
    \ works well for monotonic lists, but not for non-monotonic lists. For example,\
    \ `monotonic(c(1,2,4,20))` returns `FALSE`, but `monotonic(c(1,2,4,20,20))` returns\
    \ `TRUE`. Any idea how to fix this?\n<|/ c |>\n<| c |>\nI added a fix for non-monotonic\
    \ lists.\n<|/ c |>\n<| a |>\n<code>\nmonotonic = function(x) {\n  x = sort(x)\n\
    \  return(all(diff(x) < 0))\n}\n</code>\n<|/ a tags=list,r,sorting dscore=2 |>\n\
    <| a dscore=2 |>\nHere's a function that will work for any type of list:\n<code>\n\
    isMonotonic = function(x) {\n  x = sort(x)\n  return(all(diff(x) < 0))\n}\n</code>\n\
    <|/ a tags=list,r,sorting |>\n<| a tags=list,r,sorting |>\n<code>\nisMonotonic\
    \ = function(x) {\n  x = sort(x)\n  return(all(diff(x) < 0))\n}\n</code>\n<|/\
    \ a dscore=1 |>\n<| a |>\n<code>\nisMonotonic = function(x) {\n  x = sort(x)\n\
    \  return(all(diff(x) < 0))\n}\n</code>\n<|/ a tags=list,r,sorting dscore=1 |>\n\
    <| a dscore=1 |>\n<code>\nisMonotonic = function(x) {\n  x = sort(x)\n  return(all(diff(x)\
    \ < 0))\n}\n</code>\n<|/ a tags=list,r,sorting |>\n<| a tags=list,r,sorting |>\n\
    <code>\nisMonotonic = function(x) {\n  x = sort(x)\n  return(", "\n  l <- sort(l)\n\
    \  diffs <- diff(l) > 0\n  all(diffs)\n}\n</code>\n<|/ a dscore=5 |>\n<| c |>\n\
    I like this solution, but I wonder if there is a way to make it work with a vector\
    \ of dates? I tried `lubridate::is_increasing` but that doesn't seem to work.\
    \ Thanks!\n<|/ c |>\n<| c |>\nThis doesn't seem to work for `lubridate::is_increasing`\
    \ on `lubridate::date` vectors. `is_increasing(as.Date(c(\"2018-01-01\", \"2018-01-02\"\
    , \"2018-01-03\", \"2018-01-04\")))` returns `FALSE` even though `lubridate::date`\
    \ vectors are increasing.\n<|/ c |>\n<| c |>\n`is_increasing(as.Date(c(\"2018-01-01\"\
    , \"2018-01-02\", \"2018-01-03\", \"2018-01-04\")))` returns `FALSE` because `lubridate::date`\
    \ vectors are increasing. The `lubridate::is_increasing` function only works on\
    \ `lubridate::Date` vectors.\n<|/ c |>\n<| c |>\nI see. Thanks for clarifying!\n\
    <|/ c |>\n<| a |>\nI wrote a function that does this for me:\n<code>\nis_increasing\
    \ <- function(x) {\n  y <- x\n  y[1] < y[2] & y[2] < y[3] & y[3] < y[4]\n}\n</code>\n\
    <|/ a dscore=5 tags=r,sorting |>\n<| c |>\nThis doesn't seem to work for `lubridate::is_increasing`\
    \ on `lubridate::date` vectors. `is_increasing(as.Date(c(\"2018-01-01\", \"2018-01-02\"\
    , \"2018-01-03\", \"2018-01-04\")))` returns `FALSE` even though `lubridate::date`\
    \ vectors are increasing.\n<|/ c |>\n<| c |>\nI believe this answer is correct,\
    \ since it uses `<` instead of `<=`. `is_increasing(as.Date(c(\"2018-01-01\",\
    \ \"2018-01-02\", \"2018-01-03\", \"2018-01-04\")))` returns `TRUE` because `lubridate::date`\
    \ vectors are increasing.\n<|/ c |>\n<| c |>\nThis doesn't seem to work for `lubridate::is_increasing`\
    \ on `lubridate::date` vectors. `is_increasing(", "\n  l <- sort(l)\n  diffs <-\
    \ c(l[1], diff(l))\n  all(diffs >= 0)\n}\n</code>\n<|/ a tags=r |>\n<| c |>\n\
    I like your answer, but I'm afraid that `monotonic` doesn't work as expected for\
    \ lists with negative numbers. Try `monotonic(c(-2, -1, 0, 1, 2))`.\n<|/ c |>\n\
    <| c |>\nThanks, I didn't know that `diff` would return negative numbers. I updated\
    \ my answer to account for that.\n<|/ c |>\n<| a dscore=2 |>\nHere's a function\
    \ that will do what you want:\n<code>\nisMonotonicIncreasing <- function(x) {\n\
    \  y <- x\n  y[1] <- y[1] - 1\n  y[-1] <- y[-1] + 1\n  all(y[-1] < y[-length(y)])\
    \ & all(y[1] > y[1])\n}\n</code>\n<|/ a tags=r |>\n<| c |>\nThis doesn't work\
    \ for `isMonotonicIncreasing(c(-2, -1, 0, 1, 2))`\n<|/ c |>\n<| c |>\nThanks,\
    \ I didn't know that `diff` would return negative numbers. I updated my answer\
    \ to account for that.\n<|/ c |>\n<| a tags=r |>\nHere's a function that will\
    \ do what you want:\n<code>\nisMonotonicIncreasing <- function(x) {\n  y <- x\n\
    \  y[1] <- y[1] - 1\n  y[-1] <- y[-1] + 1\n  all(y[-1] < y[-length(y)]) & all(y[1]\
    \ > y[1])\n}\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2 |>\nHere is a function\
    \ that will do what you want:\n<code>\nisMonotonicIncreasing <- function(x) {\n\
    \  y <- x\n  y[1] <- y[1] - 1\n  y[-1] <- y[-1] + 1\n  all(y[-1] < y[-length(y)])\
    \ & all(y[1] > y[1])\n}\n</code>\n<|/ a tags=r |>\n<| a tags=r |>\nHere's a function\
    \ that will do what you want:\n<code>\nisMonotonicIncreasing <- function(x) {\n\
    \  y <- x\n  y[1] <- y[1] - 1\n  y[-1] <- y[-1] + 1\n  all(y[-1] < y[-length(y)])\
    \ & all(y[1] > y[1])\n}\n</code>\n<|/ a dscore=1 |>\n<| a tags=r |>\n<code>\n\
    isMon", "\n  l <- sort(l)\n  diffs <- c(l[-1] - l[-length(l)], 0)\n  all(diffs\
    \ >= 0)\n}\n</code>\n<|/ a tags=r,list |>\n<| c |>\nThis doesn't seem to work\
    \ when `l` is a list of lists.\n<|/ c |>\n<| c |>\nIt works fine for me. `l` is\
    \ a list of lists. `l[[4]]` is `[[1]]` which is `[1] \"a\"`\n<|/ c |>\n<| c |>\n\
    I guess I should have mentioned that my list has nested lists in it. I tried it\
    \ on a list with nested lists and it didn't work. Sorry about that. I'll edit\
    \ my original post to reflect that.\n<|/ c |>\n<| c |>\nI added a solution that\
    \ works for nested lists.\n<|/ c |>\n<| a tags=r,list |>\nHere's a solution using\
    \ purrr::map2\n<code>\nlibrary(purrr)\n\nl <- list(list(\"a\", \"b\"), list(\"\
    c\", \"d\"))\n\nmap2(l, l, function(x, y) {\n  all(y > x)\n})\n</code>\n<|/ a\
    \ dscore=2 |>\n<| a dscore=2 |>\nHere's a solution using purrr::map2\n<code>\n\
    library(purrr)\n\nl <- list(list(\"a\", \"b\"), list(\"c\", \"d\"))\n\nmap2(l,\
    \ l, function(x, y) {\n  all(y > x)\n})\n</code>\n<|/ a tags=r,list |>\n<| a tags=r,list\
    \ |>\nHere's a solution using purrr::map2\n<code>\nlibrary(purrr)\n\nl <- list(list(\"\
    a\", \"b\"), list(\"c\", \"d\"))\n\nmap2(l, l, function(x, y) {\n  all(y > x)\n\
    })\n</code>\n<|/ a dscore=2 |>\n<| a tags=r,list |>\nHere's a solution using purrr::map2\n\
    <code>\nlibrary(purrr)\n\nl <- list(list(\"a\", \"b\"), list(\"c\", \"d\"))\n\n\
    map2(l, l, function(x, y) {\n  all(y > x)\n})\n</code>\n<|/ a dscore=1 |>\n<|\
    \ a dscore=1 |>\nHere's a solution using purrr::map2\n<code>\nlibrary(purrr)\n\
    \nl <- list(list(\"a\", \"b\"), list(\"c\", \"d\"))\n\nmap2(l, l, function(x,\
    \ y) {\n  all(y > x)\n})\n</code>\n<|/ a tags=r,list |>\n<| a dscore=1 |>\nHere's\
    \ a solution using purrr::", "\n  l <- sort(l)\n  diffs <- c(l[-1] - l[-length(l)],\
    \ 0)\n  all(diffs > 0)\n}\n</code>\n<|/ a tags=r |>\n<| a tags=r |>\nHere's a\
    \ solution using dplyr and purrr packages:\n<code>\nlibrary(dplyr)\nlibrary(purrr)\n\
    \ndf %>%\n  mutate(\n    diff = map_int(\n      lag(diff, default = first(diff)),\n\
    \      ~ if_else(\n        is.na(lag(diff, default = first(diff))),\n        0,\n\
    \        lag(diff, default = first(diff))\n      )\n    )\n  ) %>%\n  mutate(\n\
    \    diff = if_else(\n      is.na(diff),\n      0,\n      diff\n    )\n  ) %>%\n\
    \  mutate(\n    diff = if_else(\n      diff > 0,\n      1,\n      0\n    )\n \
    \ ) %>%\n  mutate(\n    diff = if_else(\n      diff < 0,\n      -1,\n      diff\n\
    \    )\n  ) %>%\n  mutate(\n    diff = if_else(\n      diff == 0,\n      0,\n\
    \      diff\n    )\n  ) %>%\n  mutate(\n    diff = if_else(\n      diff == 1,\n\
    \      1,\n      diff\n    )\n  ) %>%\n  mutate(\n    diff = if_else(\n      diff\
    \ == -1,\n      -1,\n      diff\n    )\n  ) %>%\n  mutate(\n    diff = if_else(\n\
    \      diff == 0,\n      0,\n      diff\n    )\n  ) %>%\n  mutate(\n    diff =\
    \ if_else(\n      diff == 1,\n      1,\n      diff\n    )\n  ) %>%\n  mutate(\n\
    \    diff = if_else(\n      diff == -1,\n      -1,\n      diff\n    )\n  ) %>%\n\
    \  mutate(\n    diff = if_else(\n      diff == 2,\n      2,\n      diff\n    )\n\
    \  ) %>%\n  mutate(\n    diff = if_else(\n      diff == 3,\n      3,\n      diff\n\
    \    )\n  ) %>%\n  mutate(\n    diff = if_else(\n      diff == 4,\n      4,\n\
    \      diff\n    )\n  ) %>%\n  mutate(\n    diff = if_else(\n      diff == 5,\n\
    \      5,\n      diff\n    )\n  ) %>%\n  mutate(\n    diff = ", "\n  n <- length(l)\
    \ - 1\n  i <- 1\n  while(i <= n) {\n    if(l[i] < l[i + 1]) {\n      i <- i +\
    \ 1\n    } else {\n      i <- 1\n    }\n  }\n  return(TRUE)\n}\n</code>\n<|/ a\
    \ tags=r,sorting |>\n<| c |>\nI like your solution. I'm going to try it out and\
    \ see if it works. Thanks!\n<|/ c |>\n<| c |>\nI tested it out and it works great!\
    \ Thanks so much!\n<|/ c |>\n<| a tags=r,sorting |>\nHere's a solution using data.table:\n\
    <code>\nlibrary(data.table)\ndt <- data.table(\n  x = c(1,4,2,3,5,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,",
  "\n  n <- length(l) - 1\n  i <- 1\n  while (i <= n) {\n    if (l[i] < l[i - 1])\
    \ {\n      i <- i + 1\n    } else if (l[i] > l[i - 1]) {\n      i <- i + 1\n \
    \   } else {\n      i <- i + 1\n    }\n  }\n  return(TRUE)\n}\n", "\n  l <- sort(l)\n\
    \  diffs <- c(l[-1] - l[-length(l)], 0)\n  all(diffs >= 0) & all(diffs <= 1)\n\
    }\n</code>\n<|/ a tags=r,list,sorting |>\n<| c |>\nNice solution. One thing I\
    \ noticed is that `monotonic` returns `TRUE` when `l` is `NULL`. To fix this,\
    \ I added `if(is.null(l)) return(FALSE)` as the first line of the function.\n\
    <|/ c |>\n<| a tags=r,list,sorting |>\nHere's a solution using purrr that uses\
    \ purrr::map2 to iterate over each element of the list and then purrr::keep()\
    \ to keep only the elements that are monotonically increasing or decreasing:\n\
    <code>\nlibrary(purrr)\n\nmonotonic2 <- function(l){\n  map2(l, l, ~keep(.x, ~monotonic(.y)))\n\
    }\n\nmonotonic2(l)", "\n  l <- sort(l)\n  l[c(TRUE, diff(l)>0)]\n}\n", "\n  l\
    \ <- sort(l)\n  l[c(TRUE, diff(l) > 0)]\n}\n</code>\n<|/ a |>\n<| c |>\nThanks\
    \ for your answer! I tested your function and it works perfectly. However I still\
    \ don't understand why my function doesn't work. Could you explain me why my function\
    \ doesn't work?\n<|/ c |>\n<| c |>\nI added a comment to my answer. Hope it helps.\n\
    <|/ c |>\n<| c |>\nThanks for your answer! I tested your function and it works\
    \ perfectly. However I still don't understand why my function doesn't work. Could\
    \ you explain me why my function doesn't work?\n<|/ c |>\n<| c |>\nI added a comment\
    \ to my answer. Hope it helps.\n<|/ c |>\n<| c |>\nThanks for your answer! I tested\
    \ your function and it works perfectly. However I still don't understand why my\
    \ function doesn't work. Could you explain me why my function doesn't work?\n\
    <|/ c |>\n<| a tags=r |>\nThe function below will return a logical vector indicating\
    \ whether each element in the vector is monotonically increasing or decreasing.\n\
    <code>\nmonotonic_inc <- function(x) {\n  x <- sort(x)\n  c(TRUE, diff(x) > 0)\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThanks for your answer! I tested your\
    \ function and it works perfectly. However I still don't understand why my function\
    \ doesn't work. Could you explain me why my function doesn't work?\n<|/ c |>\n\
    <| c |>\nI added a comment to my answer. Hope it helps.\n<|/ c |>\n<| a tags=r\
    \ |>\nHere is a function that returns TRUE if all elements are increasing, FALSE\
    \ otherwise:\n<code>\nincreasing <- function(x) {\n  all(diff(x) > 0)\n}\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nThanks for your answer! I tested your function and\
    \ it works perfectly. However I still don't understand why my function doesn't\
    \ work. Could you explain me why my function doesn't work?\n<|/ c |>\n<| c |>\n\
    I added a comment to my answer. Hope it helps.\n<|/ c |>\n<| a tags=r |>\n<code>\n\
    monotonic_inc <- function(x) {\n  x <- sort(x)\n  c(TRUE, diff(x) > 0)\n}\n",
  "\n  l <- sort(l)\n  diffs <- c(l[1] - l[2], l[2] - l[1], l[3] - l[2])\n  all(diffs\
    \ >= 0) & all(diffs <= 1)\n}\n", "\n  l <- sort(l)\n  diffs <- c(l[-1] - l[-length(l)]\
    \ + 1, 0)\n  all(diffs >= 0)\n}\n</code>\n<|/ a dscore=5 |>\n<| c |>\nI like this\
    \ solution, but I wonder if there is a way to make it more efficient by not sorting\
    \ the list twice. Sorting twice is O(nlogn), while sorting once is O(n).\n<|/\
    \ c |>\n<| c |>\nI wonder if there is a way to make it more efficient by not sorting\
    \ the list twice. Sorting twice is O(nlogn), while sorting once is O(n). Is there\
    \ a way to make it O(n)?\n<|/ c |>\n<| c |>\n: I added a solution below that avoids\
    \ sorting the list twice.\n<|/ c |>\n<| c |>\nI wonder if there is a way to make\
    \ it more efficient by not sorting the list twice. Sorting twice is O(nlogn),\
    \ while sorting once is O(n). Is there a way to make it O(n)?\n<|/ c |>\n<| c\
    \ |>\n: I added a solution below that avoids sorting the list twice.\n<|/ c |>\n\
    <| a tags=r,sorting,algorithm |>\nHere's a solution using data.table:\n<code>\n\
    library(data.table)\ndt <- data.table(x = c(1,4,2,5,3,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20))\n\
    dt[, y := c(NA,diff(sort(x)), NA)]\ndt[, y := ifelse(is.na(y), x, y)]\ndt[, y\
    \ := y[!is.na(y)]]\n</code>\n<|/ a dscore=4 |>\n<| c |>\nThis solution works well\
    \ for me. Thanks!\n<|/ c |>\n<| c |>\nThis solution works well for me. Thanks!\n\
    <|/ c |>\n<| a tags=r,sorting,algorithm |>\nHere's a solution using dplyr and\
    \ purrr:\n<code>\nlibrary(dplyr)\nlibrary(purrr)\n\ndf <- data.frame(x = c(1,4,2,5,3,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20))\n\
    \ndf %>% \n  mutate(y = c(NA, diff(x)), \n         y = map(y, ~ifelse(is.na(.x),\
    \ x, .x))) %>% \n  mutate(y = map(y, ~.[!is.na(.x)]), \n         y = map(y, ~.[!is.na(.x)]",
  "\n  l <- sort(l)\n  l[c(TRUE, diff(l) != 0)]\n}\n</code>\n<|/ a tags=r,sorting\
    \ |>\n<| c |>\nThis doesn't seem to work. `monotonic(1:10)` returns `[1]  1  2\
    \  3  4  5  6  7  8  9 10`, but `monotonic(1:10)[c(TRUE, diff(1:10) != 0)]` returns\
    \ `[1]  1  2  3  4  5  6  7  8  9 10`.\n<|/ c |>\n<| c |>\nYes, I missed the fact\
    \ that `diff` returns a vector with length 1 less than the input. Fixed now.\n\
    <|/ c |>\n<| c |>\nThanks, I fixed it now. Your solution is much more elegant\
    \ than mine.\n<|/ c |>\n<| a dscore=2 |>\nHere's a solution using data.table:\n\
    <code>\nlibrary(data.table)\ndt <- data.table(a = 1:10)\ndt[, `:=`(b = c(NA, diff(a)),\
    \ c = c(NA, cumsum(b != 0)), d = c(NA, cumsum(b == 0)), e = c(NA, cumsum(b ==\
    \ 0))), by = a]\ndt[, `:=`(b = c(NA, diff(b)), c = c(NA, cumsum(b != 0)), d =\
    \ c(NA, cumsum(b == 0)), e = c(NA, cumsum(b == 0))), by = c]\ndt[, `:=`(b = c(NA,\
    \ diff(b)), c = c(NA, cumsum(b != 0)), d = c(NA, cumsum(b == 0)), e = c(NA, cumsum(b\
    \ == 0))), by = d]\ndt[, `:=`(b = c(NA, diff(b)), c = c(NA, cumsum(b != 0)), d\
    \ = c(NA, cumsum(b == 0)), e = c(NA, cumsum(b == 0))), by = e]\ndt[, `:=`(b =\
    \ c(NA, diff(b)), c = c(NA, cumsum(b != 0)), d = c(NA, cumsum(b == 0)), e = c(NA,\
    \ cumsum(b == 0))), by = c(d, e, c, b)]\ndt[, `:=`(b = c(NA, diff(b)), c = c(NA,\
    \ cumsum(b != 0)), d = c(NA, cumsum(b == 0)), e = c(NA, cumsum(b == 0))), by =\
    \ c(d, e, c)]\ndt[, `:=`(b = c(NA, diff(b)), c = c(NA, cumsum(b != 0)), d = c(NA,\
    \ cumsum(b == 0", "\n  l <- sort(l)\n  l[c(TRUE, diff(l) != 0)]\n}\n", "\n  l\
    \ <- sort(l)\n  diffs <- c(l[1], diff(l))\n  all(diffs > 0)\n}\n</code>\n<|/ a\
    \ dscore=4 |>\n<| c |>\nI like your solution. Very elegant. Thanks!\n<|/ c |>\n\
    <| c |>\nI like this solution as well. Very elegant. Thanks!\n<|/ c |>\n<| a tags=r,sorting\
    \ |>\nI like using rle for this:\n<code>\nx <- c(1,2,4,20,1,4,1,0,-10)\ny <- rle(x)\n\
    y$values[y$lengths > 1]", "\n  l <- sort(l)\n  diffs <- c(l[-1]-l[-length(l)])\
    \ # diff of last and first elements\n  all(diffs > 0) & all(diffs < 0)\n}\n</code>\n\
    <|/ a tags=r |>\n<| c |>\nI like your answer, but I think it can be simplified\
    \ a bit. `diffs` can be calculated as `diff(l[c(1,length(l))])`. Then `all(diffs\
    \ > 0) & all(diffs < 0)` can be simplified to `all(diffs > 0)`.\n<|/ c |>\n<|\
    \ c |>\nThanks, I didn't know about `diff` being vectorized. I'll update my answer.\n\
    <|/ c |>\n<| c |>\nI like your answer, but I think it can be simplified a bit.\
    \ `diffs` can be calculated as `diff(l[c(1,length(l))])`. Then `all(diffs > 0)\
    \ & all(diffs < 0)` can be simplified to `all(diffs > 0)`.\n<|/ c |>\n<| c |>\n\
    Thanks, I didn't know about `diff` being vectorized. I'll update my answer.\n\
    <|/ c |>\n<| a dscore=3 |>\nHere's a vectorized solution:\n<code>\nx <- c(1,2,4,20)\n\
    y <- c(1,2,4,10)\nz <- c(1,2,4,20)\nw <- c(1,2,4,10)\n\nall(diff(x) == 0)\n[1]\
    \ FALSE\n\nall(diff(y) == 0)\n[1] TRUE\n\nall(diff(z) == 0)\n[1] FALSE\n\nall(diff(w)\
    \ == 0)\n[1] TRUE\n</code>\n<|/ a tags=r |>\n<| a dscore=2 |>\nHere's a vectorized\
    \ solution:\n<code>\nx <- c(1,2,4,20)\ny <- c(1,2,4,10)\nz <- c(1,2,4,20)\nw <-\
    \ c(1,2,4,10)\n\nall(diff(x) == 0)\n[1] FALSE\n\nall(diff(y) == 0)\n[1] TRUE\n\
    \nall(diff(z) == 0)\n[1] FALSE\n\nall(diff(w) == 0)\n[1] TRUE\n</code>\n<|/ a\
    \ tags=r |>\n<| a dscore=2 |>\nHere is a simple and fast solution:\n<code>\nx\
    \ <- c(1,2,4,20)\ny <- c(1,2,4,10)\nz <- c(1,2,4,20)\nw <- c(1,2,4,10)\n\nall(diff(x)\
    \ == 0)\n[1] FALSE\n\nall(diff(y) == 0)\n[1] TRUE\n\nall(diff(z) == 0)\n[1] FALSE\n\
    \nall(diff(w) == 0)\n[1] TRUE\n</code>\n<|/ a tags=r |>\n<| a dscore=", "\n  l\
    \ <- sort(l)\n  diffs <- diff(l) > 0\n  all(diffs) || all(diffs[c(TRUE, FALSE)])\n\
    }\n</code>\n<|/ a tags=r,sorting |>\n<| c |>\nThis doesn't seem to work when there\
    \ are duplicates in the list. For example, `monotonic(c(1,2,2,3,4))` returns `FALSE`.\n\
    <|/ c |>\n<| c |>\nIt does work. Try `monotonic(c(1,2,2,3,4))`\n<|/ c |>\n<| c\
    \ |>\nYes, it does work. Try `monotonic(c(1,2,2,3,4))`\n<|/ c |>\n<| c |>\nIt\
    \ does work. Try `monotonic(c(1,2,2,3,4))`\n<|/ c |>\n<| c |>\nIt does work. Try\
    \ `monotonic(c(1,2,2,3,4))`\n<|/ c |>\n<| a dscore=5 |>\nI like using dplyr::lag\
    \ to compare adjacent elements:\n<code>\nlibrary(dplyr)\nx <- c(1,2,3,4,5,6,7,8,9,10)\n\
    lag(x, 1) < lag(x, 2)", "\n  l <- sort(l)\n  l[1] < l[2] & l[1] < l[3] & l[2]\
    \ < l[3] & l[1] < l[4]\n}\n</code>\n<|/ a tags=r |>\n<| c |>\nI like your answer,\
    \ but I think it would be better to have `l[1] < l[2] & l[1] < l[3] & l[2] < l[3]\
    \ & l[1] < l[4]` as `l[1] < l[2] & l[2] < l[3] & l[1] < l[4]`\n<|/ c |>\n<| c\
    \ |>\nI agree, thanks for pointing that out. I edited my answer to reflect your\
    \ suggestion.\n<|/ c |>\n<| a dscore=2 |>\nHere's a solution using data.table:\n\
    <code>\nlibrary(data.table)\ndt <- data.table(\n  x = c(1, 4, 2, 5, 3, 6, 8, 7,\
    \ 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20),\n  y = c(2, 5, 3, 6, 8, 7, 9,\
    \ 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21)\n)\n\ndt[, \n  c(\n    min(y),\
    \ \n    max(y), \n    min(y), \n    max(y), \n    min(y), \n    max(y), \n   \
    \ min(y), \n    max(y), \n    min(y), \n    max(y), \n    min(y), \n    max(y),\
    \ \n    min(y), \n    max(y), \n    min(y), \n    max(y), \n    min(y), \n   \
    \ max(y), \n    min(y), \n    max(y), \n    min(y), \n    max(y), \n    min(y),\
    \ \n    max(y), \n    min(y), \n    max(y), \n    min(y), \n    max(y), \n   \
    \ min(y), \n    max(y), \n    min(y), \n    max(y), \n    min(y), \n    max(y),\
    \ \n    min(y), \n    max(y), \n    min(y), \n    max(y), \n    min(y), \n   \
    \ max(y), \n    min(y), \n    max(y), \n    min(y), \n    max(y), \n    min(y),\
    \ \n    max(y), \n    min(y), \n    max(y), \n    min(y), \n    max(y), \n   \
    \ min(y), \n    max(y), \n    min(y), \n    max(y), \n    min(y), \n    max(y),\
    \ \n    min(y), \n    max(y), \n    min(y), \n    max(y), \n    min(y), \n   \
    \ max(y), \n    min(y), \n    max(y), \n    min(y), \n    max(y), \n    min(y),\
    \ \n    max(y), \n    min(y), \n    max(y), \n    min(y), \n    max(y), "]
stop_tokens:
- "\n#"
- "\n```"
