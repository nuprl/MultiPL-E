name: HumanEval_41_car_race_collision
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Imagine a road that's a perfectly straight infinitely long line.\n    //\
  \ n cars are driving left to right;  simultaneously, a different set of n cars\n\
  \    // are driving right to left.   The two sets of cars start out being very far\
  \ from\n    // each other.  All cars move in the same speed.  Two cars are said\
  \ to collide\n    // when a car that's moving left to right hits a car that's moving\
  \ right to left.\n    // However, the cars are infinitely sturdy and strong; as\
  \ a result, they continue moving\n    // in their trajectory as if they did not\
  \ collide.\n    // This function outputs the number of such collisions.\n    def\
  \ carRaceCollision(n : Long) : Long = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
  \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
  \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
  \ == (100l));\n    }\n\n}\n"
completions: ["        // The idea is to sort the cars by their starting positions.\n\
    \        // Then, we can count the number of collisions by counting the number\
    \ of\n        // cars that start at the same position.\n        // The number\
    \ of collisions is the number of cars that start at the same position\n      \
    \  // times the number of cars that start at the same position minus 1.\n    \
    \    // The reason is that each car that starts at the same position can collide\
    \ with\n        // every other car that starts at the same position.\n       \
    \ // For example, if there are 3 cars that start at the same position, then there\
    \ are\n        // 3 * 2 = 6 collisions.\n        // The number of cars that start\
    \ at the same position is the number of cars that start\n        // at the same\
    \ position minus 1.\n        // For example, if there are 3 cars that start at\
    \ the same position, then there are\n        // 3 - 1 = 2 cars that start at the\
    \ same position.\n        // The reason is that the first car that starts at the\
    \ same position cannot collide with\n        // itself.\n        val cars = Array.fill(2\
    \ * n.toInt)(0)\n        for (i <- 0 until n.toInt) {\n            cars(i) = i\n\
    \            cars(i + n.toInt) = i\n        }\n        scala.util.Sorting.quickSort(cars)\n\
    \        var collisions = 0L\n        var i = 0\n        while (i < 2 * n) {\n\
    \            var j = i + 1\n            while (j < 2 * n && cars(i) == cars(j))\
    \ j += 1\n            collisions += (j - i) * (j - i - 1) / 2\n            i =\
    \ j\n        }\n        collisions", "        // Assume that the left-to-right\
    \ cars are indexed from 1 to n, and the right-to-left cars\n        // are indexed\
    \ from n+1 to 2n.  The left-to-right car with index i starts at position i,\n\
    \        // and the right-to-left car with index i starts at position 2n+1-i.\n\
    \        // The left-to-right car with index i will collide with the right-to-left\
    \ car with index\n        // 2n+1-i.  The left-to-right car with index i will\
    \ collide with the right-to-left car with\n        // index 2n+1-i if and only\
    \ if i > n+1-i.  The left-to-right car with index i will collide\n        // with\
    \ the right-to-left car with index 2n+1-i if and only if i > n/2.\n        //\
    \ The left-to-right car with index i will collide with the right-to-left car with\
    \ index\n        // 2n+1-i if and only if i > n/2.  The left-to-right car with\
    \ index i will collide with the\n        // right-to-left car with index 2n+1-i\
    \ if and only if i > n/2.  The left-to-right car with\n        // index i will\
    \ collide with the right-to-left car with index 2n+1-i if and only if i > n/2.\n\
    \        // The left-to-right car with index i will collide with the right-to-left\
    \ car with index\n        // 2n+1-i if and only if i > n/2.  The left-to-right\
    \ car with index i will collide with the\n        // right-to-left car with index\
    \ 2n+1-i if and only if i > n/2.  The left-to-right car with\n        // index\
    \ i will collide with the right-to-left car with index 2n+1-i if and only if i\
    \ > n/2.\n        // The left-to-right car with index i will collide with the\
    \ right-to-left car with index\n        // 2n+1-i if and only if i > n/2.  The\
    \ left-to-right car with index", "        // We can think of the cars as points\
    \ on a number line.\n        // The left-to-right cars are at positions 0, 1,\
    \ 2, ..., n-1.\n        // The right-to-left cars are at positions 0, -1, -2,\
    \ ..., -(n-1).\n        // The number of collisions is the number of pairs of\
    \ points that are the same.\n        // This is the same as the number of pairs\
    \ of points that are the same distance from 0.\n        // This is the same as\
    \ the number of pairs of points that are the same distance from 0.\n        //\
    \ This is the same as the number of pairs of points that are the same distance\
    \ from 0.\n        // This is the same as the number of pairs of points that are\
    \ the same distance from 0.\n        // This is the same as the number of pairs\
    \ of points that are the same distance from 0.\n        // This is the same as\
    \ the number of pairs of points that are the same distance from 0.\n        //\
    \ This is the same as the number of pairs of points that are the same distance\
    \ from 0.\n        // This is the same as the number of pairs of points that are\
    \ the same distance from 0.\n        // This is the same as the number of pairs\
    \ of points that are the same distance from 0.\n        // This is the same as\
    \ the number of pairs of points that are the same distance from 0.\n        //\
    \ This is the same as the number of pairs of points that are the same distance\
    \ from 0.\n        // This is the same as the number of pairs of points that are\
    \ the same distance from 0.\n        // This is the same as the number of pairs\
    \ of points that are the same distance from 0.\n        // This is the same as\
    \ the number of pairs of points that are the same distance from 0.\n        //\
    \ This is the same as the number of pairs of points that are the same distance\
    \ from 0.\n        // This is the same as the number of pairs of points that are\
    \ the same distance from 0.\n        // This is the same as the number of pairs\
    \ of points that are the same distance from 0.\n        // This is the same as\
    \ the number of pairs of points that are the same distance from 0.\n        //\
    \ This is the same as the number of pairs of points that are the same distance\
    \ from 0.\n        // This is", "        // The idea is to sort the left-to-right\
    \ cars by their position, and the right-to-left cars\n        // by their position.\
    \  Then, we can just iterate through the sorted lists and count the number\n \
    \       // of collisions.\n        // The time complexity is O(n log n).\n   \
    \     val leftToRight = new Array[Long](n.toInt)\n        val rightToLeft = new\
    \ Array[Long](n.toInt)\n        for (i <- 0 until n.toInt) {\n            leftToRight(i)\
    \ = i\n            rightToLeft(i) = n - i - 1\n        }\n        scala.util.Sorting.quickSort(leftToRight)\n\
    \        scala.util.Sorting.quickSort(rightToLeft)\n        var count = 0\n  \
    \      var i = 0\n        var j = 0\n        while (i < n.toInt && j < n.toInt)\
    \ {\n            if (leftToRight(i) < rightToLeft(j)) {\n                i +=\
    \ 1\n            } else {\n                count += 1\n                j += 1\n\
    \            }\n        }\n        count", "        // The idea is to sort the\
    \ cars by their starting position.\n        // Then we can easily count the number\
    \ of collisions.\n        // The number of collisions is the number of cars that\
    \ start on the right side\n        // of the road minus the number of cars that\
    \ start on the left side of the road.\n        // This is because the cars that\
    \ start on the right side of the road will collide\n        // with the cars that\
    \ start on the left side of the road.\n        // The cars that start on the right\
    \ side of the road will collide with the cars\n        // that start on the right\
    \ side of the road, but the cars that start on the right\n        // side of the\
    \ road will also collide with the cars that start on the left side of\n      \
    \  // the road.\n        // The cars that start on the left side of the road will\
    \ collide with the cars\n        // that start on the left side of the road, but\
    \ the cars that start on the left\n        // side of the road will also collide\
    \ with the cars that start on the right side of\n        // the road.\n      \
    \  // So the cars that start on the right side of the road will collide with the\
    \ cars\n        // that start on the left side of the road, but the cars that\
    \ start on the left side\n        // of the road will also collide with the cars\
    \ that start on the right side of the road.\n        // So the cars that start\
    \ on the right side of the road will collide with the cars\n        // that start\
    \ on the left side of the road, but the cars that start on the left side\n   \
    \     // of the road will also collide with the cars that start on the right side\
    \ of the road.\n        // So the cars that start on the right side of the road\
    \ will collide with the cars\n        // that start on the left side of the road,\
    \ but the cars that start on the left side\n        // of the road will also collide\
    \ with the cars that start on the right side of the road.\n        // So the cars\
    \ that start on the right side of the road will collide with the cars\n      \
    \  // that start on the left side of the road, but the cars that start on the\
    \ left side\n        // of the road will also collide with the cars that start\
    \ on the right side of the road.\n        // So the cars that start on the right\
    \ side of the road will collide with the cars\n       ", "        // The idea\
    \ is to sort the cars by their starting position.  Then, we can\n        // use\
    \ a sweep line algorithm to count the number of collisions.\n        // The sweep\
    \ line algorithm is as follows:\n        // We start at the leftmost car.  We\
    \ move the sweep line to the right,\n        // and we count the number of cars\
    \ that are moving left to right that\n        // are currently to the left of\
    \ the sweep line.  We also count the number\n        // of cars that are moving\
    \ right to left that are currently to the right\n        // of the sweep line.\
    \  The number of collisions is the product of these\n        // two numbers. \
    \ We repeat this process until we reach the rightmost car.\n        // The time\
    \ complexity is O(n log n).\n        // The space complexity is O(n).\n      \
    \  val cars = Array.ofDim[(Long, Boolean)](n.toInt)\n        for (i <- 0 until\
    \ n.toInt) {\n            val Array(x, v) = readLine.split(\" \").map(_.toLong)\n\
    \            cars(i) = (x, v == 1)\n        }\n        val sortedCars = cars.sortWith((a,\
    \ b) => a._1 < b._1)\n        var leftToRight = 0\n        var rightToLeft = 0\n\
    \        var collisions = 0L\n        for (i <- 0 until n.toInt) {\n         \
    \   val (x, v) = sortedCars(i)\n            if (v) leftToRight += 1\n        \
    \    else rightToLeft += 1\n            collisions += leftToRight * rightToLeft\n\
    \        }\n        collisions", "        // The idea is to use a binary search.\
    \  We will use the fact that\n        // the number of collisions is a monotonically\
    \ increasing function of time.\n        // We will use the fact that the number\
    \ of collisions is a monotonically increasing function of time.\n        // We\
    \ will use the fact that the number of collisions is a monotonically increasing\
    \ function of time.\n        // We will use the fact that the number of collisions\
    \ is a monotonically increasing function of time.\n        // We will use the\
    \ fact that the number of collisions is a monotonically increasing function of\
    \ time.\n        // We will use the fact that the number of collisions is a monotonically\
    \ increasing function of time.\n        // We will use the fact that the number\
    \ of collisions is a monotonically increasing function of time.\n        // We\
    \ will use the fact that the number of collisions is a monotonically increasing\
    \ function of time.\n        // We will use the fact that the number of collisions\
    \ is a monotonically increasing function of time.\n        // We will use the\
    \ fact that the number of collisions is a monotonically increasing function of\
    \ time.\n        // We will use the fact that the number of collisions is a monotonically\
    \ increasing function of time.\n        // We will use the fact that the number\
    \ of collisions is a monotonically increasing function of time.\n        // We\
    \ will use the fact that the number of collisions is a monotonically increasing\
    \ function of time.\n        // We will use the fact that the number of collisions\
    \ is a monotonically increasing function of time.\n        // We will use the\
    \ fact that the number of collisions is a monotonically increasing function of\
    \ time.\n        // We will use the fact that the number of collisions is a monotonically\
    \ increasing function of time.\n        // We will use the fact that the number\
    \ of collisions is a monotonically increasing function of time.\n        // We\
    \ will use the fact that the number of collisions is a monotonically increasing\
    \ function of time.\n        // We will use the fact that the number of collisions\
    \ is a monotonically increasing function of time.\n        // We will use the\
    \ fact that the number of collisions is a monotonically increasing function of\
    \ time.\n        // We will use the fact that the number of collisions is a monotonically\
    \ increasing function of time.\n        // We will use the fact that the number\
    \ of collisions is a mon", "        // This is a very simple problem.  The cars\
    \ are moving in the same speed.\n        // Therefore, the cars that are closest\
    \ to each other will collide first.\n        // The cars that are closest to each\
    \ other are the ones that are at the same\n        // position.  Therefore, the\
    \ number of collisions is the number of pairs of cars\n        // that are at\
    \ the same position.\n        // The number of pairs of cars that are at the same\
    \ position is the number of\n        // pairs of cars that are at the same position.\n\
    \        // The number of pairs of cars that are at the same position is the number\
    \ of\n        // pairs of cars that are at the same position.\n        // The\
    \ number of pairs of cars that are at the same position is the number of\n   \
    \     // pairs of cars that are at the same position.\n        // The number of\
    \ pairs of cars that are at the same position is the number of\n        // pairs\
    \ of cars that are at the same position.\n        // The number of pairs of cars\
    \ that are at the same position is the number of\n        // pairs of cars that\
    \ are at the same position.\n        // The number of pairs of cars that are at\
    \ the same position is the number of\n        // pairs of cars that are at the\
    \ same position.\n        // The number of pairs of cars that are at the same\
    \ position is the number of\n        // pairs of cars that are at the same position.\n\
    \        // The number of pairs of cars that are at the same position is the number\
    \ of\n        // pairs of cars that are at the same position.\n        // The\
    \ number of pairs of cars that are at the same position is the number of\n   \
    \     // pairs of cars that are at the same position.\n        // The number of\
    \ pairs of cars that are at the same position is the number of\n        // pairs\
    \ of cars that are at the same position.\n        // The number of pairs of cars\
    \ that are at the same position is the number of\n        // pairs of cars that\
    \ are at the same position.\n        // The number of pairs of cars that are at\
    \ the same position is the number of\n        // pairs of cars that are at the\
    \ same position.\n        // The number of pairs of cars that are at the same\
    \ position is the number of\n        // pairs of cars that are at the same position.\n\
    \        // The number of pairs of cars that are", "        // The idea is to\
    \ use a sweep line algorithm.  We will sweep the line from left to right.\n  \
    \      // At each point, we will keep track of the number of cars that are moving\
    \ left to right\n        // and the number of cars that are moving right to left.\
    \  The number of collisions at that\n        // point is the product of the number\
    \ of cars moving left to right and the number of cars\n        // moving right\
    \ to left.  We will sum up the number of collisions at each point.\n        //\
    \ The number of cars moving left to right and the number of cars moving right\
    \ to left\n        // can be represented as a pair of integers.  We will use a\
    \ map to keep track of the\n        // number of cars at each point.  The key\
    \ is the point, and the value is the pair of\n        // integers.\n        val\
    \ map = new HashMap[Long, (Long, Long)]\n        // We will use a set to keep\
    \ track of the points that we have already visited.\n        val set = new HashSet[Long]\n\
    \        // We will use a queue to keep track of the points that we need to visit.\n\
    \        val queue = new Queue[Long]\n        // We will use a map to keep track\
    \ of the number of cars moving left to right and the\n        // number of cars\
    \ moving right to left at each point.\n        val carCount = new HashMap[Long,\
    \ (Long, Long)]\n        // We will use a map to keep track of the number of collisions\
    \ at each point.\n        val collisionCount = new HashMap[Long, Long]\n     \
    \   // We will use a map to keep track of the number of collisions at each point.\n\
    \        val collisionCount2 = new HashMap[Long, Long]\n        // We will use\
    \ a map to keep track of the number of collisions at each point.\n        val\
    \ collisionCount3 = new HashMap[Long, Long]\n        // We will use a map to keep\
    \ track of the number of collisions at each point.\n        val collisionCount4\
    \ = new HashMap[Long, Long]\n        // We will use a map to keep track of the\
    \ number of collisions at each point.\n        val collisionCount5 = new HashMap[Long,\
    \ Long]\n        // We will use a map to keep track of the number of collisions\
    \ at each point.\n        val collisionCount", "        // This is a very simple\
    \ problem.  We can solve it by brute force.\n        // We can place the left-to-right\
    \ cars at positions 0, 1, 2, ..., n - 1.\n        // We can place the right-to-left\
    \ cars at positions -1, -2, -3, ..., -n.\n        // Then, we can iterate through\
    \ the left-to-right cars, and for each one,\n        // we can iterate through\
    \ the right-to-left cars, and count the number of\n        // collisions.\n  \
    \      var collisions = 0L\n        for (i <- 0L until n) {\n            for (j\
    \ <- 0L until n) {\n                if (i - j == 1) collisions += 1\n        \
    \    }\n        }\n        collisions", "        // The cars are numbered from\
    \ 1 to n.  The left-to-right cars are numbered from 1 to n.\n        // The right-to-left\
    \ cars are numbered from n to 1.\n        // The left-to-right cars are at positions\
    \ 1, 2, 3, ..., n.\n        // The right-to-left cars are at positions n, n -\
    \ 1, n - 2, ..., 1.\n        // The left-to-right cars move at speed 1.\n    \
    \    // The right-to-left cars move at speed 1.\n        // The left-to-right\
    \ cars move from left to right.\n        // The right-to-left cars move from right\
    \ to left.\n        // The left-to-right cars start at positions 1, 2, 3, ...,\
    \ n.\n        // The right-to-left cars start at positions n, n - 1, n - 2, ...,\
    \ 1.\n        // The left-to-right cars end at positions n, n - 1, n - 2, ...,\
    \ 1.\n        // The right-to-left cars end at positions 1, 2, 3, ..., n.\n  \
    \      // The left-to-right cars move from 1 to n.\n        // The right-to-left\
    \ cars move from n to 1.\n        // The left-to-right cars move from 1 to n.\n\
    \        // The right-to-left cars move from n to 1.\n        // The left-to-right\
    \ cars move from 1 to n.\n        // The right-to-left cars move from n to 1.\n\
    \        // The left-to-right cars move from 1 to n.\n        // The right-to-left\
    \ cars move from n to 1.\n        // The left-to-right cars move from 1 to n.\n\
    \        // The right-to-left cars move from n to 1.\n        // The left-to-right\
    \ cars move from 1 to n.\n        // The right-to-left cars move from n to 1.\n\
    \        // The left-to-right cars move from 1 to n.\n        // The right-to-left\
    \ cars move from n to 1.\n        // The left-to-right cars move from 1 to n.\n\
    \        // The right-to-left cars move from n to 1.", "        // We can think\
    \ of the cars as points on a number line.\n        // The cars moving left to\
    \ right are at positions 1, 2, ..., n.\n        // The cars moving right to left\
    \ are at positions -1, -2, ..., -n.\n        // The cars moving left to right\
    \ are at positions 1, 2, ..., n.\n        // The cars moving right to left are\
    \ at positions -1, -2, ..., -n.\n        // We can think of the cars as points\
    \ on a number line.\n        // The cars moving left to right are at positions\
    \ 1, 2, ..., n.\n        // The cars moving right to left are at positions -1,\
    \ -2, ..., -n.\n        // The cars moving left to right are at positions 1, 2,\
    \ ..., n.\n        // The cars moving right to left are at positions -1, -2, ...,\
    \ -n.\n        // We can think of the cars as points on a number line.\n     \
    \   // The cars moving left to right are at positions 1, 2, ..., n.\n        //\
    \ The cars moving right to left are at positions -1, -2, ..., -n.\n        //\
    \ The cars moving left to right are at positions 1, 2, ..., n.\n        // The\
    \ cars moving right to left are at positions -1, -2, ..., -n.\n        // We can\
    \ think of the cars as points on a number line.\n        // The cars moving left\
    \ to right are at positions 1, 2, ..., n.\n        // The cars moving right to\
    \ left are at positions -1, -2, ..., -n.\n        // The cars moving left to right\
    \ are at positions 1, 2, ..., n.\n        // The cars moving right to left are\
    \ at positions -1, -2, ..., -n.\n        // We can think of the cars as points\
    \ on a number line.\n        // The cars moving left to right are at positions\
    \ 1, 2, ..., n.\n        // The cars moving right to left are at positions -1,\
    \ -2, ..., -n.\n        // The cars moving left to right are at positions 1, 2,\
    \ ..., n.\n        // The cars moving right to left are at positions -1, -2, ...,\
    \ -n.\n       ", "        // This function returns the number of collisions between\
    \ cars that are moving\n        // left to right and cars that are moving right\
    \ to left.\n        // The cars are numbered from 1 to n.\n        // The cars\
    \ that are moving left to right are numbered from 1 to n.\n        // The cars\
    \ that are moving right to left are numbered from n to 1.\n        // The cars\
    \ that are moving left to right are at positions from 1 to n.\n        // The\
    \ cars that are moving right to left are at positions from n to 1.\n        //\
    \ The cars that are moving left to right have speeds from 1 to n.\n        //\
    \ The cars that are moving right to left have speeds from n to 1.\n        //\
    \ The cars that are moving left to right have speeds from 1 to n.\n        //\
    \ The cars that are moving right to left have speeds from n to 1.\n        //\
    \ The cars that are moving left to right have speeds from 1 to n.\n        //\
    \ The cars that are moving right to left have speeds from n to 1.\n        //\
    \ The cars that are moving left to right have speeds from 1 to n.\n        //\
    \ The cars that are moving right to left have speeds from n to 1.\n        //\
    \ The cars that are moving left to right have speeds from 1 to n.\n        //\
    \ The cars that are moving right to left have speeds from n to 1.\n        //\
    \ The cars that are moving left to right have speeds from 1 to n.\n        //\
    \ The cars that are moving right to left have speeds from n to 1.\n        //\
    \ The cars that are moving left to right have speeds from 1 to n.\n        //\
    \ The cars that are moving right to left have speeds from n to 1.\n        //\
    \ The cars that are moving left to right have speeds from 1 to n.\n        //\
    \ The cars that are moving right to left have speeds from n to 1.\n        //\
    \ The cars that are moving left to right have speeds from 1 to n.\n        //\
    \ The cars that are moving right to left have speeds from n to 1.\n        //\
    \ The cars that are moving left to right have speeds from 1 to n.\n        //\
    \ The cars that are moving right to left have speeds from n to 1.\n        //\
    \ The cars that are moving left to right have speeds from 1 to n.\n        //\
    \ The cars that are moving right to left have speeds from n to 1.", "        //\
    \ The idea is to sort the cars by their starting positions.\n        // Then,\
    \ for each car that's moving left to right, we find the first car\n        //\
    \ that's moving right to left that's to the right of it.  If there is such a car,\n\
    \        // then we know that the two cars will collide.  We can do this in O(n\
    \ log n) time\n        // using a binary search.\n        // The total number\
    \ of collisions is the sum of the number of collisions for each car\n        //\
    \ that's moving left to right.\n        // The total number of collisions is also\
    \ the number of cars that are moving right to left\n        // that are to the\
    \ left of the car that's moving left to right.\n        // This is because the\
    \ cars that are moving right to left are sorted by their starting positions\n\
    \        // and the cars that are moving left to right are sorted by their starting\
    \ positions.\n        // Therefore, the number of cars that are moving right to\
    \ left that are to the left of the car\n        // that's moving left to right\
    \ is the number of cars that are moving right to left that are to the left\n \
    \       // of the car that's moving left to right.\n        // This is because\
    \ the cars that are moving right to left are sorted by their starting positions\n\
    \        // and the cars that are moving left to right are sorted by their starting\
    \ positions.\n        // Therefore, the number of cars that are moving right to\
    \ left that are to the left of the car\n        // that's moving left to right\
    \ is the number of cars that are moving right to left that are to the left\n \
    \       // of the car that's moving left to right.\n        // This is because\
    \ the cars that are moving right to left are sorted by their starting positions\n\
    \        // and the cars that are moving left to right are sorted by their starting\
    \ positions.\n        // Therefore, the number of cars that are moving right to\
    \ left that are to the left of the car\n        // that's moving left to right\
    \ is the number of cars that are moving right to left that are to the left\n \
    \       // of the car that's moving left to right.\n        // This is because\
    \ the cars that are moving right to left are sorted by their starting positions\n\
    \        // and the cars that are moving left to right are sorted by their starting\
    \ positions.\n        // Therefore, the number of cars that are moving", "   \
    \     // The idea is to use a sweep line algorithm.\n        // We will use a\
    \ priority queue to keep track of the cars.\n        // The priority queue will\
    \ be sorted by the position of the car.\n        // We will have two queues, one\
    \ for the cars moving left to right,\n        // and one for the cars moving right\
    \ to left.\n        // We will also keep track of the current position of the\
    \ sweep line.\n        // We will start the sweep line at position 0.\n      \
    \  // We will then iterate through the cars moving left to right,\n        //\
    \ and for each car, we will check if there are any cars moving right to left\n\
    \        // that are at the same position.  If so, we will increment the number\
    \ of collisions.\n        // We will then move the sweep line to the position\
    \ of the current car.\n        // We will then iterate through the cars moving\
    \ right to left,\n        // and for each car, we will check if there are any\
    \ cars moving left to right\n        // that are at the same position.  If so,\
    \ we will increment the number of collisions.\n        // We will then move the\
    \ sweep line to the position of the current car.\n        // We will repeat this\
    \ process until we have iterated through all the cars.\n        // The time complexity\
    \ is O(n log n).\n        var leftToRight = new PriorityQueue[Long]()(Ordering.Long.reverse)\n\
    \        var rightToLeft = new PriorityQueue[Long]()(Ordering.Long.reverse)\n\
    \        for (i <- 1 to n.toInt) {\n            leftToRight.enqueue(i)\n     \
    \       rightToLeft.enqueue(n + 1 - i)\n        }\n        var sweepLine = 0L\n\
    \        var collisions = 0L\n        while (!leftToRight.isEmpty) {\n       \
    \     val leftToRightCar = leftToRight.dequeue\n            while (!rightToLeft.isEmpty\
    \ && rightToLeft.head == sweepLine) {\n                rightToLeft.dequeue\n \
    \               collisions += 1\n            }\n            sweepLine = leftToRightCar\n\
    \            while (!leftToRight.isEmpty && leftToRight.head == sweepLine) {\n\
    \                leftToRight.dequeue\n                collisions += 1\n      \
    \      }\n            sweepLine = rightToLeft.dequeue\n", "        // This is\
    \ a brute force solution.  It's not very efficient, but it's easy to understand.\n\
    \        // We'll use a set to keep track of the cars that are moving left to\
    \ right.\n        // We'll use a set to keep track of the cars that are moving\
    \ right to left.\n        // We'll use a variable to keep track of the number\
    \ of collisions.\n        // We'll use a variable to keep track of the current\
    \ time.\n        // We'll use a variable to keep track of the current position\
    \ of the leftmost car moving left to right.\n        // We'll use a variable to\
    \ keep track of the current position of the rightmost car moving right to left.\n\
    \        // We'll use a variable to keep track of the current position of the\
    \ leftmost car moving right to left.\n        // We'll use a variable to keep\
    \ track of the current position of the rightmost car moving left to right.\n \
    \       var leftToRightCars = Set[Long]()\n        var rightToLeftCars = Set[Long]()\n\
    \        var collisions = 0L\n        var time = 0L\n        var leftMostLeftToRightCar\
    \ = 0L\n        var rightMostRightToLeftCar = 0L\n        var leftMostRightToLeftCar\
    \ = 0L\n        var rightMostLeftToRightCar = 0L\n        // We'll now initialize\
    \ the sets of cars.\n        for (i <- 1L to n) {\n            leftToRightCars\
    \ += i\n            rightToLeftCars += i\n        }\n        // We'll now simulate\
    \ the cars moving.\n        while (leftToRightCars.size > 0 && rightToLeftCars.size\
    \ > 0) {\n            // We'll now update the positions of the cars.\n       \
    \     leftMostLeftToRightCar += 1\n            rightMostRightToLeftCar -= 1\n\
    \            leftMostRightToLeftCar -= 1\n            rightMostLeftToRightCar\
    \ += 1\n            // We'll now check for collisions.\n            if (leftMostLeftToRightCar\
    \ == leftMostRightToLeftCar) {\n                // We'll now remove the cars that\
    \ collided.\n                leftToRightCars -= leftMostLeftToRightCar\n     \
    \           rightToLeftCars -= leftMostRightToLeftCar\n                // We'll\
    \ now update the number of collisions.\n                collisions += 1\n    \
    \        }", "        // The idea is to sort the cars by their starting positions.\n\
    \        // Then, we can do a sweep line algorithm.\n        // The sweep line\
    \ starts at the leftmost car, and moves right.\n        // We keep track of the\
    \ number of cars that are moving left to right\n        // and the number of cars\
    \ that are moving right to left.\n        // When the sweep line hits a car that's\
    \ moving left to right,\n        // we increment the number of cars that are moving\
    \ left to right.\n        // When the sweep line hits a car that's moving right\
    \ to left,\n        // we decrement the number of cars that are moving left to\
    \ right.\n        // The number of collisions is the number of cars that are moving\
    \ left to right\n        // times the number of cars that are moving right to\
    \ left.\n        val cars = new Array[(Long, Boolean)](2 * n.toInt)\n        for\
    \ (i <- 0 until n.toInt) {\n            cars(i) = (i, true)\n            cars(i\
    \ + n.toInt) = (i, false)\n        }\n        cars.sortBy(x => x._1)\n       \
    \ var collisions = 0L\n        var leftToRight = 0\n        for (i <- 0 until\
    \ cars.length) {\n            if (cars(i)._2) leftToRight += 1\n            else\
    \ leftToRight -= 1\n            collisions += leftToRight\n        }\n       \
    \ collisions", "        // This is a classic problem in combinatorics.  The answer\
    \ is n * (n - 1) / 2.\n        // The reason is that the number of collisions\
    \ is the same as the number of\n        // pairs of cars.  The number of pairs\
    \ of cars is n * (n - 1) / 2.\n        n * (n - 1) / 2", "        // This is a\
    \ very simple problem.  The cars that are moving left to right\n        // will\
    \ hit the cars that are moving right to left in the order of their\n        //\
    \ speed.  The cars that are moving right to left will hit the cars that\n    \
    \    // are moving left to right in the order of their speed.  So, the total\n\
    \        // number of collisions is the sum of the first n numbers.\n        n\
    \ * (n + 1) / 2", "        // This is a very simple problem.  We can just simulate\
    \ the cars moving.\n        // For each car, we can store its position and direction.\n\
    \        // We can then simulate the cars moving one step at a time.\n       \
    \ // If a car moving left to right hits a car moving right to left, we increment\n\
    \        // the collision count.\n        // We can do this in O(n) time.\n  \
    \      val cars = Array.fill(n.toInt)((0, 0))\n        for (i <- 0 until n.toInt)\
    \ {\n            cars(i) = (i, 1)\n        }\n        for (i <- 0 until n.toInt)\
    \ {\n            cars(i) = (i, -1)\n        }\n        var collisions = 0\n  \
    \      var time = 0\n        while (true) {\n            val newCars = Array.fill(n.toInt)((0,\
    \ 0))\n            for (i <- 0 until n.toInt) {\n                val (position,\
    \ direction) = cars(i)\n                newCars(i) = (position + direction, direction)\n\
    \            }\n            for (i <- 0 until n.toInt) {\n                for\
    \ (j <- 0 until n.toInt) {\n                    if (i != j) {\n              \
    \          val (position1, direction1) = newCars(i)\n                        val\
    \ (position2, direction2) = newCars(j)\n                        if (position1\
    \ == position2 && direction1 != direction2) {\n                            collisions\
    \ += 1\n                        }\n                    }\n                }\n\
    \            }\n            if (collisions > 0) return collisions\n          \
    \  time += 1\n            cars.copyToArray(newCars)\n        }\n        return\
    \ collisions", "        // Let's say the cars moving left to right are indexed\
    \ from 1 to n, and the cars\n        // moving right to left are indexed from\
    \ n+1 to 2n.\n        // The cars moving left to right are at positions 1, 2,\
    \ 3, ..., n.\n        // The cars moving right to left are at positions n+1, n+2,\
    \ n+3, ..., 2n.\n        // The cars moving left to right have speeds 1, 2, 3,\
    \ ..., n.\n        // The cars moving right to left have speeds n, n-1, n-2, ...,\
    \ 1.\n        // The time it takes for the i-th car moving left to right to reach\
    \ the origin is\n        // 1/i.\n        // The time it takes for the i-th car\
    \ moving right to left to reach the origin is\n        // 1/(n+1-i).\n       \
    \ // The time it takes for the i-th car moving left to right to reach the j-th\
    \ car\n        // moving right to left is (n+1-j)/i.\n        // The time it takes\
    \ for the j-th car moving right to left to reach the i-th car\n        // moving\
    \ left to right is (n+1-i)/j.\n        // The i-th car moving left to right will\
    \ collide with the j-th car moving right to left\n        // if and only if (n+1-j)/i\
    \ < (n+1-i)/j.\n        // This is equivalent to (n+1-j)i < (n+1-i)j.\n      \
    \  // This is equivalent to (n+1-j)i - (n+1-i)j < 0.\n        // This is equivalent\
    \ to (n+1-j)i - (n+1-i)j + (n+1-i)i - (n+1-j)j < (n+1-i)i - (n+1-j)j.\n      \
    \  // This is equivalent to (n+1-j)i - (n+1-i)j + (n+1-i)i - (n+1-j)j < n^2 +\
    \ 2n - 2i - 2j + i^2 + j^2.\n        // This is equivalent", "        // The idea\
    \ is to sort the cars by their starting position.\n        // The cars that start\
    \ at the same position are sorted by their speed.\n        // Then, we can use\
    \ a sweep line algorithm to compute the number of collisions.\n        // The\
    \ sweep line algorithm is as follows:\n        // 1.  We start at the leftmost\
    \ car.  We move the sweep line to the right.\n        // 2.  When the sweep line\
    \ encounters a car, we add it to a set of cars.\n        // 3.  When the sweep\
    \ line encounters a car that's moving right to left, we remove it from the set.\n\
    \        // 4.  When the sweep line encounters a car that's moving left to right,\
    \ we check if there's a car\n        //     moving right to left in the set. \
    \ If so, we increment the number of collisions.\n        // 5.  We repeat steps\
    \ 1-4 until we reach the rightmost car.\n        // 6.  We return the number of\
    \ collisions.\n        // The time complexity is O(n log n).\n        val cars\
    \ = new Array[(Long, Boolean)](2 * n.toInt)\n        for (i <- 0 until n.toInt)\
    \ {\n            cars(i) = (i.toLong, true)\n            cars(i + n.toInt) = (i.toLong,\
    \ false)\n        }\n        val sortedCars = cars.sortWith((a, b) => {\n    \
    \        if (a._1 == b._1) a._2 else a._1 < b._1\n        })\n        var collisions\
    \ = 0L\n        val carsInSet = new HashSet[(Long, Boolean)]\n        for (car\
    \ <- sortedCars) {\n            if (car._2) {\n                if (carsInSet.contains((car._1,\
    \ false))) collisions += 1\n                carsInSet.add(car)\n            }\
    \ else {\n                carsInSet.remove(car)\n            }\n        }\n  \
    \      collisions", "        // The idea is to sort the cars by their starting\
    \ positions.\n        // Then, we can just count the number of cars that are moving\n\
    \        // in the same direction.\n        val cars = Array.fill(2 * n.toInt)(0)\n\
    \        for (i <- 0 until n.toInt) {\n            cars(i) = i + 1\n         \
    \   cars(i + n.toInt) = -(i + 1)\n        }\n        cars.sorted\n        var\
    \ collisions = 0\n        for (i <- 0 until cars.length - 1) {\n            if\
    \ (cars(i) > 0 && cars(i + 1) > 0) collisions += 1\n            if (cars(i) <\
    \ 0 && cars(i + 1) < 0) collisions += 1\n        }\n        collisions", "   \
    \     // The idea is to sort the cars by their starting position.\n        //\
    \ Then, we can simulate the race by iterating through the cars\n        // from\
    \ left to right.  If we encounter a car that's moving left to right,\n       \
    \ // then we know that it will collide with the next car that's moving right to\
    \ left.\n        // We can then simulate the collision by swapping the directions\
    \ of the two cars.\n        // We can then continue iterating through the cars.\n\
    \        // We can do this in O(n) time.\n        val cars = new Array[(Long,\
    \ Boolean)](2 * n.toInt)\n        for (i <- 0 until n.toInt) {\n            cars(i)\
    \ = (i, true)\n            cars(i + n.toInt) = (i, false)\n        }\n       \
    \ cars.sortWith((a, b) => a._1 < b._1)\n        var collisions = 0L\n        for\
    \ (i <- 0 until cars.length) {\n            if (cars(i)._2) {\n              \
    \  var j = i + 1\n                while (j < cars.length && cars(j)._2) j += 1\n\
    \                if (j < cars.length) {\n                    collisions += 1\n\
    \                    cars(j) = (cars(j)._1, true)\n                }\n       \
    \     }\n        }\n        collisions", "        // This function outputs the\
    \ number of collisions between the ith car from the left\n        // and the jth\
    \ car from the right.\n        def collision(i : Long, j : Long) : Long = {\n\
    \            if (i == j) 0\n            else if (i < j) collision(i, j - 1) +\
    \ j - 1\n            else collision(i - 1, j) + i - 1\n        }\n        collision(n,\
    \ n)", "        // Let's say the cars moving left to right are labeled 1, 2, 3,\
    \ ..., n.\n        // The cars moving right to left are labeled -1, -2, -3, ...,\
    \ -n.\n        // The cars are initially positioned at x = 1, 2, 3, ..., n, respectively.\n\
    \        // The cars are initially positioned at x = -1, -2, -3, ..., -n, respectively.\n\
    \        // The cars are moving at a speed of 1.\n        // The cars are moving\
    \ at a speed of -1.\n        // The cars are infinitely strong and sturdy.\n \
    \       // The cars are infinitely strong and sturdy.\n        // The cars are\
    \ infinitely strong and sturdy.\n        // The cars are infinitely strong and\
    \ sturdy.\n        // The cars are infinitely strong and sturdy.\n        // The\
    \ cars are infinitely strong and sturdy.\n        // The cars are infinitely strong\
    \ and sturdy.\n        // The cars are infinitely strong and sturdy.\n       \
    \ // The cars are infinitely strong and sturdy.\n        // The cars are infinitely\
    \ strong and sturdy.\n        // The cars are infinitely strong and sturdy.\n\
    \        // The cars are infinitely strong and sturdy.\n        // The cars are\
    \ infinitely strong and sturdy.\n        // The cars are infinitely strong and\
    \ sturdy.\n        // The cars are infinitely strong and sturdy.\n        // The\
    \ cars are infinitely strong and sturdy.\n        // The cars are infinitely strong\
    \ and sturdy.\n        // The cars are infinitely strong and sturdy.\n       \
    \ // The cars are infinitely strong and sturdy.\n        // The cars are infinitely\
    \ strong and sturdy.\n        // The cars are infinitely strong and sturdy.\n\
    \        // The cars are infinitely strong and sturdy.\n        // The cars are\
    \ infinitely strong and sturdy.\n        // The cars are infinitely strong and\
    \ sturdy.\n        // The cars are infinitely strong and sturdy.\n        // The\
    \ cars are infinitely strong and sturdy.\n        // The cars are infinitely strong\
    \ and sturdy.\n        // The cars are infinitely strong and sturdy.\n       \
    \ // The cars are infinitely strong and sturdy.\n        // The cars are infinitely\
    \ strong and sturdy.\n        // The cars are infinitely strong and sturdy.\n\
    \        // The cars are infinitely strong and sturdy.\n        // The cars are\
    \ infinitely strong and sturdy.\n        // The cars are infinitely strong and\
    \ sturdy.\n        // The cars are infinitely strong and sturdy.\n", "       \
    \ // The idea is to sort the cars by their starting position.\n        // Then,\
    \ we can simply count the number of cars that are moving left to right\n     \
    \   // and the number of cars that are moving right to left.  The number of collisions\n\
    \        // is the minimum of these two numbers.\n        // The number of cars\
    \ moving left to right is the number of cars that start at\n        // a position\
    \ that's less than 0.  The number of cars moving right to left is the\n      \
    \  // number of cars that start at a position that's greater than 0.\n       \
    \ // The number of cars that start at a position that's less than 0 is n / 2.\n\
    \        // The number of cars that start at a position that's greater than 0\
    \ is n / 2.\n        // The number of cars that start at a position that's equal\
    \ to 0 is 1.\n        // The number of cars that start at a position that's less\
    \ than 0 is n / 2.\n        // The number of cars that start at a position that's\
    \ greater than 0 is n / 2.\n        // The number of cars that start at a position\
    \ that's equal to 0 is 1.\n        // The number of cars that start at a position\
    \ that's less than 0 is n / 2.\n        // The number of cars that start at a\
    \ position that's greater than 0 is n / 2.\n        // The number of cars that\
    \ start at a position that's equal to 0 is 1.\n        // The number of cars that\
    \ start at a position that's less than 0 is n / 2.\n        // The number of cars\
    \ that start at a position that's greater than 0 is n / 2.\n        // The number\
    \ of cars that start at a position that's equal to 0 is 1.\n        // The number\
    \ of cars that start at a position that's less than 0 is n / 2.\n        // The\
    \ number of cars that start at a position that's greater than 0 is n / 2.\n  \
    \      // The number of cars that start at a position that's equal to 0 is 1.\n\
    \        // The number of cars that start at a position that's less than 0 is\
    \ n / 2.\n        // The number of cars that start at a position that's greater\
    \ than 0 is n / 2.\n        // The number of cars that start at a position that's\
    \ equal to 0 is 1.\n        // The number", "        // The idea is to sort the\
    \ cars by their starting positions.  Then, we can\n        // iterate through\
    \ the cars and count the number of cars that are moving\n        // in the opposite\
    \ direction.  This is a linear time algorithm.\n        val cars = new Array[(Long,\
    \ Boolean)](2 * n.toInt)\n        for (i <- 0 until n.toInt) {\n            cars(i)\
    \ = (i.toLong, true)\n            cars(i + n.toInt) = (i.toLong, false)\n    \
    \    }\n        cars.sortWith((a, b) => a._1 < b._1)\n        var count = 0L\n\
    \        var i = 0\n        while (i < cars.length) {\n            var j = i +\
    \ 1\n            while (j < cars.length && cars(j)._1 == cars(i)._1) j += 1\n\
    \            count += (j - i) * (j - i - 1) / 2\n            i = j\n        }\n\
    \        count", "        // The idea is to sort the cars by their starting position.\n\
    \        // Then, we can just go through the cars in order and count the number\
    \ of collisions.\n        // If we have a car that's moving left to right at position\
    \ x, and a car that's moving\n        // right to left at position y, then they\
    \ collide if and only if x > y.\n        // So, we can just count the number of\
    \ cars that are moving right to left that are\n        // to the left of the current\
    \ car that's moving left to right.\n        // We can do this in O(n log n) time.\n\
    \        val cars = new Array[(Long, Boolean)](2 * n.toInt)\n        for (i <-\
    \ 0 until n.toInt) {\n            cars(i) = (i.toLong, true)\n            cars(i\
    \ + n.toInt) = (i.toLong, false)\n        }\n        cars.sortWith((a, b) => a._1\
    \ < b._1)\n        var count = 0L\n        var leftToRight = 0\n        for (i\
    \ <- 0 until 2 * n.toInt) {\n            if (cars(i)._2) {\n                count\
    \ += leftToRight\n                leftToRight += 1\n            } else {\n   \
    \             leftToRight -= 1\n            }\n        }\n        count", "  \
    \      // The idea is to sort the cars by their starting positions, and then\n\
    \        // iterate through the sorted list.  If a car is moving left to right,\n\
    \        // then it will collide with the next car that's moving right to left.\n\
    \        // The number of collisions is the number of cars moving left to right.\n\
    \        // The number of cars moving left to right is the number of cars that\n\
    \        // have an odd starting position.\n        val cars = (1 to n.toInt).map(x\
    \ => (x, x % 2 == 1)).toList\n        cars.filter(x => x._2).length", "      \
    \  // This function outputs the number of collisions between the cars\n      \
    \  // that are driving left to right and the cars that are driving right to left.\n\
    \        // The cars are numbered from 0 to n - 1.\n        // The cars that are\
    \ driving left to right are numbered from 0 to n - 1.\n        // The cars that\
    \ are driving right to left are numbered from n - 1 to 0.\n        // The car\
    \ that is numbered 0 is the first car that is driving left to right.\n       \
    \ // The car that is numbered n - 1 is the first car that is driving right to\
    \ left.\n        // The car that is numbered 0 is the last car that is driving\
    \ right to left.\n        // The car that is numbered n - 1 is the last car that\
    \ is driving left to right.\n        // The car that is numbered i is driving\
    \ left to right at speed i + 1.\n        // The car that is numbered i is driving\
    \ right to left at speed n - i.\n        // The car that is numbered i is driving\
    \ left to right at position i.\n        // The car that is numbered i is driving\
    \ right to left at position n - i - 1.\n        // The car that is numbered i\
    \ is driving left to right at time i.\n        // The car that is numbered i is\
    \ driving right to left at time n - i - 1.\n        // The car that is numbered\
    \ i is driving left to right at time i + 1.\n        // The car that is numbered\
    \ i is driving right to left at time n - i - 2.\n        // The car that is numbered\
    \ i is driving left to right at time i + 2.\n        // The car that is numbered\
    \ i is driving right to left at time n - i - 3.\n        // The car that is numbered\
    \ i is driving left to right at time i + 3.\n        // The car that is numbered\
    \ i is driving right to left at time n - i - 4.\n        // The car that is numbered\
    \ i is driving left to right at time i + 4.\n        // The car that is numbered\
    \ i is driving right to left at time n - i - 5.\n        // The car that is numbered\
    \ i is driving left to right at time i + 5.\n        // The car that is numbered\
    \ i is driving right to left at time n - i - 6.\n        // The car that is numbered\
    \ i is driving left", "        // The idea is to use a sweep line algorithm.\n\
    \        // We'll use a priority queue to keep track of the cars.\n        //\
    \ The priority queue will be sorted by the x-coordinate of the cars.\n       \
    \ // We'll keep track of the cars moving left to right and the cars moving right\
    \ to left\n        // in two separate priority queues.\n        // We'll keep\
    \ track of the number of collisions in a variable called collisions.\n       \
    \ // Initially, collisions is 0.\n        // We'll keep track of the current x-coordinate\
    \ in a variable called x.\n        // Initially, x is 0.\n        // We'll keep\
    \ track of the current time in a variable called t.\n        // Initially, t is\
    \ 0.\n        // We'll keep track of the current number of cars in a variable\
    \ called numCars.\n        // Initially, numCars is 0.\n        // We'll keep\
    \ track of the current number of cars moving left to right in a variable called\
    \ numCarsLeft.\n        // Initially, numCarsLeft is 0.\n        // We'll keep\
    \ track of the current number of cars moving right to left in a variable called\
    \ numCarsRight.\n        // Initially, numCarsRight is 0.\n        // We'll keep\
    \ track of the current number of cars moving left to right that are at the front\
    \ of the queue in a variable called numCarsLeftFront.\n        // Initially, numCarsLeftFront\
    \ is 0.\n        // We'll keep track of the current number of cars moving right\
    \ to left that are at the front of the queue in a variable called numCarsRightFront.\n\
    \        // Initially, numCarsRightFront is 0.\n        // We'll keep track of\
    \ the current number of cars moving left to right that are at the back of the\
    \ queue in a variable called numCarsLeftBack.\n        // Initially, numCarsLeftBack\
    \ is 0.\n        // We'll keep track of the current number of cars moving right\
    \ to left that are at the back of the queue in a variable called numCarsRightBack.\n\
    \        // Initially, numCarsRightBack is 0.\n        // We'll keep track of\
    \ the current number of cars moving left to right that are at the front of the\
    \ queue and are moving right to left in a variable called numCarsLeftFrontRight.\n\
    \        // Initially, numCarsLeftFront", "        // The idea is to sort the\
    \ cars by their starting positions.\n        // Then, we can easily count the\
    \ number of collisions.\n        // The number of collisions is the number of\
    \ cars that are moving left to right\n        // that are to the left of a car\
    \ that's moving right to left.\n        // This is the same as the number of cars\
    \ that are moving right to left\n        // that are to the right of a car that's\
    \ moving left to right.\n        // So, we can just sort the cars by their starting\
    \ positions, and then\n        // count the number of cars that are moving right\
    \ to left that are to the right\n        // of a car that's moving left to right.\n\
    \        // The number of cars that are moving right to left that are to the right\
    \ of a car\n        // that's moving left to right is the number of cars that\
    \ are moving right to left\n        // that are to the left of a car that's moving\
    \ left to right.\n        // So, we can just sort the cars by their starting positions,\
    \ and then\n        // count the number of cars that are moving left to right\
    \ that are to the left\n        // of a car that's moving right to left.\n   \
    \     // The number of cars that are moving left to right that are to the left\
    \ of a car\n        // that's moving right to left is the number of cars that\
    \ are moving left to right\n        // that are to the right of a car that's moving\
    \ right to left.\n        // So, we can just sort the cars by their starting positions,\
    \ and then\n        // count the number of cars that are moving right to left\
    \ that are to the right\n        // of a car that's moving right to left.\n  \
    \      // The number of cars that are moving right to left that are to the right\
    \ of a car\n        // that's moving right to left is the number of cars that\
    \ are moving right to left\n        // that are to the left of a car that's moving\
    \ right to left.\n        // So, we can just sort the cars by their starting positions,\
    \ and then\n        // count the number of cars that are moving left to right\
    \ that are to the left\n        // of a car that's moving left to right.\n   \
    \     // The number of cars that are moving left to right that are to the left\
    \ of a car\n        // that's moving left to right is the number of", "      \
    \  // This is a very simple problem.  We can solve it in O(n) time.\n        //\
    \ The key observation is that the cars that are moving left to right\n       \
    \ // will never collide with each other.  The same is true for the cars\n    \
    \    // that are moving right to left.  The only collisions that can occur\n \
    \       // are between cars that are moving left to right and cars that are\n\
    \        // moving right to left.\n        // Therefore, we can solve this problem\
    \ by sorting the cars that are\n        // moving left to right and the cars that\
    \ are moving right to left.\n        // Then, we can simply iterate through the\
    \ cars that are moving left to right\n        // and the cars that are moving\
    \ right to left in a single pass.  Every time\n        // we encounter a car that\
    \ is moving left to right and a car that is moving\n        // right to left,\
    \ we know that they will collide.\n        // This algorithm runs in O(n log n)\
    \ time.\n        // We can improve it to O(n) time by using a bucket sort.\n \
    \       // We can also improve it to O(n) time by using a merge sort.\n      \
    \  // We can also improve it to O(n) time by using a counting sort.\n        //\
    \ We can also improve it to O(n) time by using a radix sort.\n        // We can\
    \ also improve it to O(n) time by using a bucket sort.\n        // We can also\
    \ improve it to O(n) time by using a bucket sort.\n        // We can also improve\
    \ it to O(n) time by using a bucket sort.\n        // We can also improve it to\
    \ O(n) time by using a bucket sort.\n        // We can also improve it to O(n)\
    \ time by using a bucket sort.\n        // We can also improve it to O(n) time\
    \ by using a bucket sort.\n        // We can also improve it to O(n) time by using\
    \ a bucket sort.\n        // We can also improve it to O(n) time by using a bucket\
    \ sort.\n        // We can also improve it to O(n) time by using a bucket sort.\n\
    \        // We can also improve it to O(n) time by using a bucket sort.\n    \
    \    // We can also improve it to O(n) time by", "        // Let's say the left\
    \ to right cars are numbered 0 to n-1.\n        // Let's say the right to left\
    \ cars are numbered n to 2n-1.\n        // Let's say the left to right car i starts\
    \ at position xi.\n        // Let's say the right to left car i starts at position\
    \ yi.\n        // Let's say the left to right car i moves at speed vi.\n     \
    \   // Let's say the right to left car i moves at speed wi.\n        // Then,\
    \ the left to right car i will collide with the right to left car j\n        //\
    \ if and only if xi + vi * t = yj - wj * t for some t.\n        // This is equivalent\
    \ to xi - yj = (wj - vi) * t.\n        // This is equivalent to (xi - yj) / (wj\
    \ - vi) = t.\n        // This is equivalent to (xi - yj) / (wj - vi) >= 0.\n \
    \       // This is equivalent to xi - yj >= 0 and wj - vi >= 0.\n        // This\
    \ is equivalent to xi >= yj and wj >= vi.\n        // This is equivalent to xi\
    \ - yj >= 0 and vi - wj >= 0.\n        // This is equivalent to xi - yj >= 0 and\
    \ vi - wj <= 0.\n        // This is equivalent to xi - yj <= 0 and vi - wj >=\
    \ 0.\n        // This is equivalent to xi - yj <= 0 and vi - wj <= 0.\n      \
    \  // This is equivalent to xi - yj <= 0 or vi - wj <= 0.\n        // This is\
    \ equivalent to xi - yj <= 0 or vi <= wj.\n        // This is equivalent to xi\
    \ <= yj or vi <= wj.\n        // This is equivalent to xi <= yj or wj <= vi.\n\
    \        // This is equivalent to xi - yj <= 0 or wj - vi <= 0.\n        // This\
    \ is equivalent to xi - yj <= 0 or wj - vi >= 0.\n        // This is equivalent\
    \ to xi - yj <= 0 or wj >= vi.\n        // This is equivalent to xi <= yj or wj\
    \ >= vi.\n       ", "        // This is a very simple problem.  We can just simulate\
    \ the cars moving.\n        // We'll use a queue to represent the cars moving\
    \ left to right, and a queue\n        // to represent the cars moving right to\
    \ left.  We'll use a priority queue\n        // to represent the events that are\
    \ happening.  An event is either a car\n        // moving left to right, or a\
    \ car moving right to left.  We'll use a priority\n        // queue to represent\
    \ the events that are happening.  An event is either a car\n        // moving\
    \ left to right, or a car moving right to left.  We'll use a priority\n      \
    \  // queue to represent the events that are happening.  An event is either a\
    \ car\n        // moving left to right, or a car moving right to left.  We'll\
    \ use a priority\n        // queue to represent the events that are happening.\
    \  An event is either a car\n        // moving left to right, or a car moving\
    \ right to left.  We'll use a priority\n        // queue to represent the events\
    \ that are happening.  An event is either a car\n        // moving left to right,\
    \ or a car moving right to left.  We'll use a priority\n        // queue to represent\
    \ the events that are happening.  An event is either a car\n        // moving\
    \ left to right, or a car moving right to left.  We'll use a priority\n      \
    \  // queue to represent the events that are happening.  An event is either a\
    \ car\n        // moving left to right, or a car moving right to left.  We'll\
    \ use a priority\n        // queue to represent the events that are happening.\
    \  An event is either a car\n        // moving left to right, or a car moving\
    \ right to left.  We'll use a priority\n        // queue to represent the events\
    \ that are happening.  An event is either a car\n        // moving left to right,\
    \ or a car moving right to left.  We'll use a priority\n        // queue to represent\
    \ the events that are happening.  An event is either a car\n        // moving\
    \ left to right, or a car moving right to left.  We'll use a priority\n      \
    \  // queue to represent the events that are happening.  An event is either a\
    \ car\n        // moving left to right, or a car moving right to left.  We'll\
    \ use a priority\n        // queue", "        // This is a simple problem that\
    \ can be solved by a simple greedy algorithm.\n        // The greedy algorithm\
    \ is as follows:\n        // 1.  Sort the cars by their starting positions.\n\
    \        // 2.  For each car, if it's moving left to right, then it will collide\
    \ with the\n        //     first car that's moving right to left.\n        //\
    \ 3.  The number of collisions is the number of cars moving left to right.\n \
    \       // The running time of this algorithm is O(n log n) because of the sorting.\n\
    \        // The space complexity is O(n) because of the sorting.\n        //\n\
    \        // The following is a more efficient algorithm that runs in O(n) time\
    \ and O(1) space.\n        // The idea is to use a two-pointer approach.\n   \
    \     // 1.  Let the cars moving left to right be indexed by 0, 1, 2, ..., n -\
    \ 1.\n        //     Let the cars moving right to left be indexed by -1, -2, -3,\
    \ ..., -n.\n        // 2.  Let the starting positions of the cars moving left\
    \ to right be\n        //     a0, a1, a2, ..., an - 1.\n        //     Let the\
    \ starting positions of the cars moving right to left be\n        //     b0, b1,\
    \ b2, ..., bn - 1.\n        // 3.  Let the ending positions of the cars moving\
    \ left to right be\n        //     c0, c1, c2, ..., cn - 1.\n        //     Let\
    \ the ending positions of the cars moving right to left be\n        //     d0,\
    \ d1, d2, ..., dn - 1.\n        // 4.  Sort the cars moving left to right by their\
    \ starting positions.\n        //     Sort the cars moving right to left by their\
    \ starting positions.\n        // 5.  Let i be the index of the car moving left\
    \ to right that's currently being considered.\n        //     Let j be the index\
    \ of the car moving right to left that's currently being considered.\n       \
    \ // 6.  If ai < bj, then the car moving left to right will collide with the car\
    \ moving right to left.\n        //     Increment i.\n        // 7.  If ai > bj,",
  "        // Let's say the cars are numbered from 1 to n.\n        // Let's say the\
    \ cars that are moving left to right are numbered from 1 to n.\n        // Let's\
    \ say the cars that are moving right to left are numbered from n to 1.\n     \
    \   // Let's say the cars that are moving left to right are at positions x1, x2,\
    \ ..., xn.\n        // Let's say the cars that are moving right to left are at\
    \ positions y1, y2, ..., yn.\n        // Let's say the cars that are moving left\
    \ to right are moving at speeds s1, s2, ..., sn.\n        // Let's say the cars\
    \ that are moving right to left are moving at speeds t1, t2, ..., tn.\n      \
    \  // Let's say the cars that are moving left to right are at positions x1, x2,\
    \ ..., xn.\n        // Let's say the cars that are moving right to left are at\
    \ positions y1, y2, ..., yn.\n        // Let's say the cars that are moving left\
    \ to right are moving at speeds s1, s2, ..., sn.\n        // Let's say the cars\
    \ that are moving right to left are moving at speeds t1, t2, ..., tn.\n      \
    \  // Let's say the cars that are moving left to right are at positions x1, x2,\
    \ ..., xn.\n        // Let's say the cars that are moving right to left are at\
    \ positions y1, y2, ..., yn.\n        // Let's say the cars that are moving left\
    \ to right are moving at speeds s1, s2, ..., sn.\n        // Let's say the cars\
    \ that are moving right to left are moving at speeds t1, t2, ..., tn.\n      \
    \  // Let's say the cars that are moving left to right are at positions x1, x2,\
    \ ..., xn.\n        // Let's say the cars that are moving right to left are at\
    \ positions y1, y2, ..., yn.\n        // Let's say the cars that are moving left\
    \ to right are moving at speeds s1, s2, ..., sn.\n        // Let's say the cars\
    \ that are moving right to left are moving at speeds t1, t2, ..., tn.\n      \
    \  //", "        // The idea is to sort the cars by their starting positions.\n\
    \        // Then, we can use a greedy algorithm to count the number of collisions.\n\
    \        // We start with the car that's the furthest left.  We then look at the\
    \ car\n        // that's the furthest right.  If the right car is to the left\
    \ of the left car,\n        // then we know that there is a collision.  We then\
    \ move the left car to the right\n        // by one position.  We continue this\
    \ process until we reach the end.\n        // The time complexity is O(n log n)\
    \ because of the sorting.\n        val cars = new Array[Long](2 * n.toInt)\n \
    \       for (i <- 0 until n.toInt) {\n            cars(i) = i\n            cars(i\
    \ + n.toInt) = -i\n        }\n        scala.util.Sorting.quickSort(cars)\n   \
    \     var collisions = 0L\n        var left = 0\n        var right = n.toInt\n\
    \        while (left < n.toInt) {\n            if (cars(left) > cars(right)) {\n\
    \                collisions += n - cars(left)\n                left += 1\n   \
    \         } else {\n                right += 1\n            }\n        }\n   \
    \     collisions", "        // The idea is to sort the cars by their starting\
    \ position and then\n        // iterate through the sorted list.  If the car is\
    \ moving left to right,\n        // then we increment the number of collisions\
    \ by the number of cars that\n        // are moving right to left and are to the\
    \ left of the current car.\n        // If the car is moving right to left, then\
    \ we decrement the number of\n        // collisions by the number of cars that\
    \ are moving left to right and\n        // are to the right of the current car.\n\
    \        // We use a balanced binary search tree to keep track of the cars that\n\
    \        // are moving left to right and are to the left of the current car.\n\
    \        // We use a balanced binary search tree to keep track of the cars that\n\
    \        // are moving right to left and are to the right of the current car.\n\
    \        // The time complexity is O(n log n) and the space complexity is O(n).\n\
    \        val cars = new Array[(Long, Boolean)](2 * n.toInt)\n        for (i <-\
    \ 0 until n.toInt) {\n            cars(i) = (i, true)\n            cars(i + n.toInt)\
    \ = (i, false)\n        }\n        val sortedCars = cars.sortWith((a, b) => a._1\
    \ < b._1)\n        var collisions = 0L\n        val leftToRightCars = new TreeSet[Long]()\n\
    \        val rightToLeftCars = new TreeSet[Long]()\n        for (car <- sortedCars)\
    \ {\n            if (car._2) {\n                collisions += leftToRightCars.size\n\
    \                rightToLeftCars.add(car._1)\n            } else {\n         \
    \       collisions -= rightToLeftCars.size\n                leftToRightCars.add(car._1)\n\
    \            }\n        }\n        collisions", "        // The idea is to sort\
    \ the cars by their starting position.\n        // Then, we can just iterate through\
    \ the cars and count the number of collisions.\n        // The time complexity\
    \ is O(n log n).\n        val cars = Array.fill(n.toInt)(0)\n        for (i <-\
    \ 0 until n.toInt) cars(i) = i\n        val sortedCars = cars.sortWith(_ < _)\n\
    \        var collisions = 0\n        for (i <- 0 until n.toInt) {\n          \
    \  val car = sortedCars(i)\n            val distance = abs(car - i)\n        \
    \    collisions += distance\n        }\n        collisions", "        // We can\
    \ solve this problem by first sorting the cars by their starting positions.\n\
    \        // Then, we can iterate through the cars from left to right, and for\
    \ each car,\n        // we can count the number of cars that are moving right\
    \ to left and are to the left\n        // of the current car.  The total number\
    \ of collisions is the sum of these numbers.\n        // The time complexity is\
    \ O(n log n).\n        val cars = Array.fill(n.toInt)((0, 0))\n        for (i\
    \ <- 0 until n.toInt) {\n            val Array(x, y) = readLine.split(\" \").map(_.toInt)\n\
    \            cars(i) = (x, y)\n        }\n        val sortedCars = cars.sortBy(_._1)\n\
    \        var collisions = 0L\n        for (i <- 0 until n.toInt) {\n         \
    \   val (x, y) = sortedCars(i)\n            if (y == -1) {\n                var\
    \ j = i - 1\n                while (j >= 0 && sortedCars(j)._2 == 1) {\n     \
    \               collisions += 1\n                    j -= 1\n                }\n\
    \            }\n        }\n        collisions", "        // This is a very simple\
    \ problem.  The key is to notice that the cars that are\n        // moving left\
    \ to right are numbered from 1 to n, and the cars that are moving\n        //\
    \ right to left are numbered from n to 1.  So, a collision occurs when the\n \
    \       // car moving left to right has the same number as the car moving right\
    \ to left.\n        // So, the number of collisions is the sum of the numbers\
    \ from 1 to n.\n        // This is a very well-known formula.\n        n * (n\
    \ + 1) / 2", "        // The idea is to sort the cars by their starting positions.\n\
    \        // Then, we can just count the number of cars that are moving in the\
    \ same direction\n        // that are next to each other.\n        // The number\
    \ of collisions is the number of cars that are moving in the same direction\n\
    \        // that are next to each other minus 1.\n        // The reason is that\
    \ the first car in the sorted list of cars moving in the same direction\n    \
    \    // will not collide with any other cars.\n        // The second car in the\
    \ sorted list of cars moving in the same direction\n        // will collide with\
    \ the first car.\n        // The third car in the sorted list of cars moving in\
    \ the same direction\n        // will collide with the first and second cars.\n\
    \        // ...\n        // The nth car in the sorted list of cars moving in the\
    \ same direction\n        // will collide with the first, second, ..., (n - 1)th\
    \ cars.\n        // So, the total number of collisions is (n - 1).\n        //\
    \ However, we have to subtract 1 from this because the first car in the sorted\
    \ list\n        // of cars moving in the same direction will not collide with\
    \ any other cars.\n        // So, the total number of collisions is (n - 1) -\
    \ 1 = n - 2.\n        // This is the same as the number of cars that are moving\
    \ in the same direction\n        // that are next to each other.\n        // So,\
    \ we just need to count the number of cars that are moving in the same direction\n\
    \        // that are next to each other.\n        // The number of cars that are\
    \ moving in the same direction that are next to each other\n        // is the\
    \ number of cars that are moving in the same direction that are next to each other\n\
    \        // minus 1.\n        // The reason is that the first car in the sorted\
    \ list of cars moving in the same direction\n        // will not collide with\
    \ any other cars.\n        // The second car in the sorted list of cars moving\
    \ in the same direction\n        // will collide with the first car.\n       \
    \ // The third car in the sorted list of cars moving in the same direction\n \
    \       // will collide with the first and second cars.\n        // ...\n    \
    \    // The nth car in the sorted list of cars moving in the same direction\n\
    \        // will collide with the first, second,", "        // The idea is to\
    \ sort the cars by their starting position.\n        // Then, we can iterate through\
    \ the cars and count the number of collisions.\n        // The time complexity\
    \ is O(n log n).\n        val cars = Array.fill(n.toInt)(0)\n        for (i <-\
    \ 0 until n.toInt) cars(i) = i\n        val sortedCars = cars.sortWith(_ < _)\n\
    \        var collisions = 0L\n        for (i <- 0 until n.toInt) {\n         \
    \   val car = sortedCars(i)\n            val distance = abs(car - i)\n       \
    \     collisions += distance\n        }\n        collisions", "        // The\
    \ idea is to sort the cars by their starting positions.\n        // Then, we can\
    \ simply count the number of cars that start to the left of a car\n        //\
    \ that starts to the right of it.\n        // This is because if a car starts\
    \ to the left of another car, then it will\n        // collide with it.\n    \
    \    // The number of cars that start to the left of a car that starts to the\
    \ right of it\n        // is the number of cars that start to the right of it.\n\
    \        // This is because the number of cars that start to the left of a car\
    \ that starts to the right of it\n        // is the number of cars that start\
    \ to the right of it.\n        // This is because the number of cars that start\
    \ to the left of a car that starts to the right of it\n        // is the number\
    \ of cars that start to the right of it.\n        // This is because the number\
    \ of cars that start to the left of a car that starts to the right of it\n   \
    \     // is the number of cars that start to the right of it.\n        // This\
    \ is because the number of cars that start to the left of a car that starts to\
    \ the right of it\n        // is the number of cars that start to the right of\
    \ it.\n        // This is because the number of cars that start to the left of\
    \ a car that starts to the right of it\n        // is the number of cars that\
    \ start to the right of it.\n        // This is because the number of cars that\
    \ start to the left of a car that starts to the right of it\n        // is the\
    \ number of cars that start to the right of it.\n        // This is because the\
    \ number of cars that start to the left of a car that starts to the right of it\n\
    \        // is the number of cars that start to the right of it.\n        // This\
    \ is because the number of cars that start to the left of a car that starts to\
    \ the right of it\n        // is the number of cars that start to the right of\
    \ it.\n        // This is because the number of cars that start to the left of\
    \ a car that starts to the right of it\n        // is the number of cars that\
    \ start to the right of it.\n        // This is because the number of cars that\
    \ start to the left of a car that starts to the right of it\n        // is the\
    \ number", "        // The idea is to sort the cars by their starting position.\n\
    \        // Then, we can just iterate through the cars and count the number of\
    \ collisions.\n        // The number of collisions is the number of cars that\
    \ are moving left to right\n        // that are to the left of the current car.\n\
    \        // The time complexity is O(n log n) and the space complexity is O(n).\n\
    \        val cars = Array.fill(2 * n.toInt)(0)\n        for (i <- 0 until n.toInt)\
    \ {\n            cars(i) = i + 1\n            cars(i + n.toInt) = -(i + 1)\n \
    \       }\n        val sortedCars = cars.sorted\n        var collisions = 0L\n\
    \        for (i <- 0 until 2 * n.toInt) {\n            if (sortedCars(i) > 0)\
    \ collisions += i\n        }\n        collisions", "        // This is the number\
    \ of collisions.\n        var collisions = 0L\n        // This is the number of\
    \ cars that are moving left to right.\n        var leftToRight = n\n        //\
    \ This is the number of cars that are moving right to left.\n        var rightToLeft\
    \ = n\n        // This is the number of cars that are moving left to right and\
    \ have collided.\n        var collidedLeftToRight = 0L\n        // This is the\
    \ number of cars that are moving right to left and have collided.\n        var\
    \ collidedRightToLeft = 0L\n        // This is the number of cars that are moving\
    \ left to right and have not collided.\n        var notCollidedLeftToRight = n\n\
    \        // This is the number of cars that are moving right to left and have\
    \ not collided.\n        var notCollidedRightToLeft = n\n        // This is the\
    \ number of cars that are moving left to right and have collided and\n       \
    \ // have not collided.\n        var collidedAndNotCollidedLeftToRight = 0L\n\
    \        // This is the number of cars that are moving right to left and have\
    \ collided and\n        // have not collided.\n        var collidedAndNotCollidedRightToLeft\
    \ = 0L\n        // This is the number of cars that are moving left to right and\
    \ have collided and\n        // have collided.\n        var collidedAndCollidedLeftToRight\
    \ = 0L\n        // This is the number of cars that are moving right to left and\
    \ have collided and\n        // have collided.\n        var collidedAndCollidedRightToLeft\
    \ = 0L\n        // This is the number of cars that are moving left to right and\
    \ have not collided and\n        // have not collided.\n        var notCollidedAndNotCollidedLeftToRight\
    \ = n\n        // This is the number of cars that are moving right to left and\
    \ have not collided and\n        // have not collided.\n        var notCollidedAndNotCollidedRightToLeft\
    \ = n\n        // This is the number of cars that are moving left to right and\
    \ have not collided and\n        // have collided.\n        var notCollidedAndCollidedLeftToRight\
    \ = 0L\n        // This is the number of cars that are moving right to left and\
    \ have not collided and\n        // have collided.\n        var notCollidedAndCollidedRightToLeft\
    \ = 0L\n        // This is", "        // The idea is to use a sweep line algorithm.\n\
    \        // We will sweep from left to right.\n        // We will maintain a set\
    \ of cars that are moving left to right.\n        // We will maintain a set of\
    \ cars that are moving right to left.\n        // We will maintain a set of cars\
    \ that are moving left to right and have collided.\n        // We will maintain\
    \ a set of cars that are moving right to left and have collided.\n        // We\
    \ will maintain a set of cars that are moving left to right and have collided\
    \ and are moving right to left.\n        // We will maintain a set of cars that\
    \ are moving right to left and have collided and are moving left to right.\n \
    \       // We will maintain a set of cars that are moving left to right and have\
    \ collided and are moving right to left and have collided.\n        // We will\
    \ maintain a set of cars that are moving right to left and have collided and are\
    \ moving left to right and have collided.\n        // We will maintain a set of\
    \ cars that are moving left to right and have collided and are moving right to\
    \ left and have collided and are moving left to right.\n        // We will maintain\
    \ a set of cars that are moving right to left and have collided and are moving\
    \ left to right and have collided and are moving right to left.\n        // We\
    \ will maintain a set of cars that are moving left to right and have collided\
    \ and are moving right to left and have collided and are moving left to right\
    \ and have collided.\n        // We will maintain a set of cars that are moving\
    \ right to left and have collided and are moving left to right and have collided\
    \ and are moving right to left and have collided.\n        // We will maintain\
    \ a set of cars that are moving left to right and have collided and are moving\
    \ right to left and have collided and are moving left to right and have collided\
    \ and are moving right to left.\n        // We will maintain a set of cars that\
    \ are moving right to left and have collided and are moving left to right and\
    \ have collided and are moving right to left and have collided and are moving\
    \ left to right.\n        // We will maintain a set of cars that are moving left\
    \ to right and have collided and are moving right to left and have collided and\
    \ are moving left to right and have collided and are moving right to left and\
    \ have collided.\n        // We will maintain a set of cars that are moving right\
    \ to left and have collided and are moving left", "        // The idea is to use\
    \ a sweep line algorithm.  We'll have a line that moves from\n        // left\
    \ to right.  We'll have a set of cars that are moving left to right and a set\n\
    \        // of cars that are moving right to left.  We'll maintain the invariant\
    \ that the\n        // cars in the left to right set are to the left of the sweep\
    \ line, and the cars in\n        // the right to left set are to the right of\
    \ the sweep line.  We'll also maintain\n        // the invariant that the cars\
    \ in the left to right set are ordered by their position\n        // from left\
    \ to right, and the cars in the right to left set are ordered by their\n     \
    \   // position from right to left.\n        // The sweep line will move from\
    \ left to right.  When the sweep line reaches a car\n        // that's moving\
    \ left to right, we'll remove it from the left to right set.  When\n        //\
    \ the sweep line reaches a car that's moving right to left, we'll remove it from\n\
    \        // the right to left set.  When the sweep line reaches a car that's moving\
    \ left to\n        // right, we'll add it to the left to right set.  When the\
    \ sweep line reaches a car\n        // that's moving right to left, we'll add\
    \ it to the right to left set.\n        // When the sweep line reaches a car that's\
    \ moving left to right, we'll add it to\n        // the left to right set.  When\
    \ the sweep line reaches a car that's moving right to\n        // left, we'll\
    \ add it to the right to left set.  When the sweep line reaches a car\n      \
    \  // that's moving left to right, we'll remove it from the left to right set.\
    \  When\n        // the sweep line reaches a car that's moving right to left,\
    \ we'll remove it from\n        // the right to left set.\n        // When the\
    \ sweep line reaches a car that's moving left to right, we'll add it to\n    \
    \    // the left to right set.  When the sweep line reaches a car that's moving\
    \ right to\n        // left, we'll add it to the right to left set.  When the\
    \ sweep line reaches a car\n        // that's moving left to right, we'll remove\
    \ it from the left to right set.  When\n        // the sweep line", "        //\
    \ The idea is to sort the cars by their starting position.\n        // Then, we\
    \ can just go through the sorted list and count the number of cars\n        //\
    \ that are moving in the same direction.\n        // The number of collisions\
    \ is the number of cars moving in the same direction\n        // minus 1.\n  \
    \      // The reason is that if there are k cars moving in the same direction,\n\
    \        // the first car doesn't collide with any other car.\n        // The\
    \ second car collides with the first car.\n        // The third car collides with\
    \ the first and second cars.\n        // ...\n        // The kth car collides\
    \ with the first, second, ..., k-1th cars.\n        // So, the total number of\
    \ collisions is k - 1.\n        // The total number of collisions is the sum of\
    \ the number of collisions\n        // for each group of cars moving in the same\
    \ direction.\n        // We can calculate the number of collisions for each group\
    \ of cars moving\n        // in the same direction by subtracting 1 from the number\
    \ of cars in the group.\n        // So, the total number of collisions is the\
    \ sum of the number of cars in each\n        // group minus the number of groups.\n\
    \        // The number of groups is the number of cars moving in the same direction.\n\
    \        // So, the total number of collisions is the sum of the number of cars\
    \ in each\n        // group minus the number of cars moving in the same direction.\n\
    \        // The number of cars moving in the same direction is the number of groups.\n\
    \        // So, the total number of collisions is the sum of the number of cars\
    \ in each\n        // group minus the number of groups.\n        // The number\
    \ of groups is the number of cars moving in the same direction.\n        // So,\
    \ the total number of collisions is the sum of the number of cars in each\n  \
    \      // group minus the number of cars moving in the same direction.\n     \
    \   // The number of cars moving in the same direction is the number of groups.\n\
    \        // So, the total number of collisions is the sum of the number of cars\
    \ in each\n        // group minus the number of groups.\n        // The number\
    \ of groups is the number of cars moving in the same direction.\n        // So,\
    \ the total number of collisions is the sum of the number of cars in each\n  \
    \      // group minus the", "        // The idea is to sort the cars by their\
    \ starting position.\n        // If the starting position of the ith car is xi,\
    \ then the starting position of the\n        // (n + 1 - i)th car is -xi.  The\
    \ cars are moving at the same speed, so the time\n        // it takes for the\
    \ ith car to reach the origin is xi / 2.  The time it takes for the\n        //\
    \ (n + 1 - i)th car to reach the origin is -xi / 2.  The two cars collide if and\
    \ only if\n        // xi / 2 = -xi / 2, which is equivalent to xi = 0.  Therefore,\
    \ the number of collisions\n        // is the number of cars that start at the\
    \ origin.\n        // We can count the number of cars that start at the origin\
    \ by using the fact that\n        // the sum of the starting positions of the\
    \ cars is 0.  The sum of the starting positions\n        // of the cars that start\
    \ at the origin is 0.  The sum of the starting positions of the\n        // cars\
    \ that start at the origin is 0.  Therefore, the number of cars that start at\
    \ the origin\n        // is 0.\n        0", "        // The idea is to sort the\
    \ cars by their starting position.\n        // Then, we can simply iterate through\
    \ the cars and count the number of collisions.\n        // The time complexity\
    \ is O(n log n).\n        val cars = new Array[(Long, Boolean)](2 * n.toInt)\n\
    \        for (i <- 0 until n.toInt) {\n            cars(i) = (i.toLong, true)\n\
    \            cars(i + n.toInt) = (i.toLong, false)\n        }\n        val sortedCars\
    \ = cars.sortWith((a, b) => if (a._1 == b._1) a._2 else a._1 < b._1)\n       \
    \ var collisions = 0L\n        for (i <- 0 until sortedCars.length - 1) {\n  \
    \          if (sortedCars(i)._2 != sortedCars(i + 1)._2) collisions += 1\n   \
    \     }\n        collisions", "        // The idea is to use a sweep line algorithm.\
    \  We will have a sweep line that moves\n        // from left to right.  The sweep\
    \ line will keep track of the cars that are currently\n        // on the road.\
    \  When the sweep line encounters a car that's moving left to right,\n       \
    \ // it will add the car to the set of cars on the road.  When the sweep line\
    \ encounters\n        // a car that's moving right to left, it will remove the\
    \ car from the set of cars on the road.\n        // The sweep line will also keep\
    \ track of the number of collisions that have occurred.\n        // When the sweep\
    \ line encounters a car that's moving left to right, it will check if\n      \
    \  // the car collides with any of the cars that are currently on the road.  If\
    \ so, it will\n        // increment the number of collisions.\n        // The\
    \ sweep line will keep track of the cars that are currently on the road using\
    \ a\n        // balanced binary search tree.  The key of each node in the tree\
    \ will be the car's\n        // position on the road.  The value of each node\
    \ in the tree will be the car's speed.\n        // The sweep line will keep track\
    \ of the number of collisions using a variable.\n        // The sweep line will\
    \ keep track of the cars that are currently on the road using a\n        // balanced\
    \ binary search tree.  The key of each node in the tree will be the car's\n  \
    \      // position on the road.  The value of each node in the tree will be the\
    \ car's speed.\n        // The sweep line will keep track of the number of collisions\
    \ using a variable.\n        // The sweep line will keep track of the cars that\
    \ are currently on the road using a\n        // balanced binary search tree. \
    \ The key of each node in the tree will be the car's\n        // position on the\
    \ road.  The value of each node in the tree will be the car's speed.\n       \
    \ // The sweep line will keep track of the number of collisions using a variable.\n\
    \        // The sweep line will keep track of the cars that are currently on the\
    \ road using a\n        // balanced binary search tree.  The key of each node\
    \ in the tree will be the car's\n        // position on the road.  The value of\
    \ each node in the tree will be the car's speed.\n        // The sweep line",
  "        // The idea is to sort the cars by their starting position.\n        //\
    \ Then, we can just count the number of cars that are moving\n        // in the\
    \ same direction.\n        // The number of collisions is the number of cars that\
    \ are moving\n        // in the same direction minus 1.\n        val leftToRight\
    \ = ArrayBuffer[Long]()\n        val rightToLeft = ArrayBuffer[Long]()\n     \
    \   for (i <- 1 to n.toInt) {\n            val x = scala.io.StdIn.readLine.toLong\n\
    \            val d = scala.io.StdIn.readLine.toLong\n            if (d == 1) leftToRight\
    \ += x\n            else rightToLeft += x\n        }\n        val sortedLeftToRight\
    \ = leftToRight.sorted\n        val sortedRightToLeft = rightToLeft.sorted\n \
    \       var collisions = 0L\n        var i = 0\n        var j = 0\n        while\
    \ (i < sortedLeftToRight.length && j < sortedRightToLeft.length) {\n         \
    \   if (sortedLeftToRight(i) < sortedRightToLeft(j)) {\n                collisions\
    \ += j\n                i += 1\n            }\n            else {\n          \
    \      collisions += i\n                j += 1\n            }\n        }\n   \
    \     collisions += i * (sortedRightToLeft.length - j)\n        collisions +=\
    \ j * (sortedLeftToRight.length - i)\n        collisions", "        // The idea\
    \ is to use a sweep line algorithm.\n        // We will use a priority queue to\
    \ store the cars.\n        // The priority queue will be sorted by the x-coordinate\
    \ of the car.\n        // We will use a sweep line algorithm to sweep from left\
    \ to right.\n        // We will use a priority queue to store the cars.\n    \
    \    // The priority queue will be sorted by the x-coordinate of the car.\n  \
    \      // We will use a sweep line algorithm to sweep from left to right.\n  \
    \      // We will use a priority queue to store the cars.\n        // The priority\
    \ queue will be sorted by the x-coordinate of the car.\n        // We will use\
    \ a sweep line algorithm to sweep from left to right.\n        // We will use\
    \ a priority queue to store the cars.\n        // The priority queue will be sorted\
    \ by the x-coordinate of the car.\n        // We will use a sweep line algorithm\
    \ to sweep from left to right.\n        // We will use a priority queue to store\
    \ the cars.\n        // The priority queue will be sorted by the x-coordinate\
    \ of the car.\n        // We will use a sweep line algorithm to sweep from left\
    \ to right.\n        // We will use a priority queue to store the cars.\n    \
    \    // The priority queue will be sorted by the x-coordinate of the car.\n  \
    \      // We will use a sweep line algorithm to sweep from left to right.\n  \
    \      // We will use a priority queue to store the cars.\n        // The priority\
    \ queue will be sorted by the x-coordinate of the car.\n        // We will use\
    \ a sweep line algorithm to sweep from left to right.\n        // We will use\
    \ a priority queue to store the cars.\n        // The priority queue will be sorted\
    \ by the x-coordinate of the car.\n        // We will use a sweep line algorithm\
    \ to sweep from left to right.\n        // We will use a priority queue to store\
    \ the cars.\n        // The priority queue will be sorted by the x-coordinate\
    \ of the car.\n        // We will use a sweep line algorithm to sweep from left\
    \ to right.\n        // We will use a priority queue to store the cars.\n    \
    \    // The priority queue will be sorted by the x-coordinate of the car.\n  \
    \      // We will use a sweep line algorithm to sweep from left to right", " \
    \       // This is a simple problem.  We can solve it by simulation.\n       \
    \ // We can simulate the cars by using a list of tuples.  The first element of\
    \ the tuple\n        // is the position of the car.  The second element of the\
    \ tuple is a boolean that\n        // indicates whether the car is moving left\
    \ to right (true) or right to left (false).\n        // We can simulate the cars\
    \ by moving each car one step at a time.  We can check whether\n        // two\
    \ cars collide by checking whether two cars are at the same position and one car\
    \ is\n        // moving left to right and the other car is moving right to left.\n\
    \        // We can simulate the cars by using a list of tuples.  The first element\
    \ of the tuple\n        // is the position of the car.  The second element of\
    \ the tuple is a boolean that\n        // indicates whether the car is moving\
    \ left to right (true) or right to left (false).\n        // We can simulate the\
    \ cars by moving each car one step at a time.  We can check whether\n        //\
    \ two cars collide by checking whether two cars are at the same position and one\
    \ car is\n        // moving left to right and the other car is moving right to\
    \ left.\n        // We can simulate the cars by using a list of tuples.  The first\
    \ element of the tuple\n        // is the position of the car.  The second element\
    \ of the tuple is a boolean that\n        // indicates whether the car is moving\
    \ left to right (true) or right to left (false).\n        // We can simulate the\
    \ cars by moving each car one step at a time.  We can check whether\n        //\
    \ two cars collide by checking whether two cars are at the same position and one\
    \ car is\n        // moving left to right and the other car is moving right to\
    \ left.\n        // We can simulate the cars by using a list of tuples.  The first\
    \ element of the tuple\n        // is the position of the car.  The second element\
    \ of the tuple is a boolean that\n        // indicates whether the car is moving\
    \ left to right (true) or right to left (false).\n        // We can simulate the\
    \ cars by moving each car one step at a time.  We can check whether\n        //\
    \ two cars collide by checking whether two cars are at the same position and one\
    \ car is\n        // moving left to right and", "        // The idea is to sort\
    \ the cars by their starting position.\n        // Then, we can iterate through\
    \ the cars and count the number of cars\n        // that are moving in the opposite\
    \ direction.\n        // The time complexity is O(n log n)\n        val cars =\
    \ Array.fill(n.toInt)(0)\n        for (i <- 0 until n.toInt) cars(i) = i + 1\n\
    \        val sortedCars = cars.sorted\n        var count = 0L\n        for (i\
    \ <- 0 until n.toInt) {\n            val car = sortedCars(i)\n            val\
    \ direction = if (car <= n / 2) 1 else -1\n            val oppositeDirection =\
    \ -direction\n            var j = i + 1\n            while (j < n.toInt && sortedCars(j)\
    \ * direction < car * direction) {\n                if (sortedCars(j) * oppositeDirection\
    \ > car * oppositeDirection) count += 1\n                j += 1\n            }\n\
    \        }\n        count", "        // This is the number of collisions.\n  \
    \      var collisions = 0L\n        // This is the number of cars that have passed\
    \ the origin.\n        var carsPassedOrigin = 0L\n        // This is the number\
    \ of cars that have passed the origin and are moving left to right.\n        var\
    \ carsPassedOriginMovingLeftToRight = 0L\n        // This is the number of cars\
    \ that have passed the origin and are moving right to left.\n        var carsPassedOriginMovingRightToLeft\
    \ = 0L\n        // This is the number of cars that have passed the origin and\
    \ are moving left to right and have collided.\n        var carsPassedOriginMovingLeftToRightCollided\
    \ = 0L\n        // This is the number of cars that have passed the origin and\
    \ are moving right to left and have collided.\n        var carsPassedOriginMovingRightToLeftCollided\
    \ = 0L\n        // This is the number of cars that have passed the origin and\
    \ are moving left to right and have collided and are still moving left to right.\n\
    \        var carsPassedOriginMovingLeftToRightCollidedStillMovingLeftToRight =\
    \ 0L\n        // This is the number of cars that have passed the origin and are\
    \ moving right to left and have collided and are still moving right to left.\n\
    \        var carsPassedOriginMovingRightToLeftCollidedStillMovingRightToLeft =\
    \ 0L\n        // This is the number of cars that have passed the origin and are\
    \ moving left to right and have collided and are still moving left to right and\
    \ have collided again.\n        var carsPassedOriginMovingLeftToRightCollidedStillMovingLeftToRightCollidedAgain\
    \ = 0L\n        // This is the number of cars that have passed the origin and\
    \ are moving right to left and have collided and are still moving right to left\
    \ and have collided again.\n        var carsPassedOriginMovingRightToLeftCollidedStillMovingRightToLeftCollidedAgain\
    \ = 0L\n        // This is the number of cars that have passed the origin and\
    \ are moving left to right and have collided and are still moving left to right\
    \ and have collided again and are still moving left to right.\n        var carsPassedOriginMovingLeftToRightCollidedStillMovingLeftToRightCollidedAgainStillMovingLeftToRight\
    \ = 0L\n        // This is the number of cars that have passed the origin and\
    \ are moving right to left and have collided and are still moving", "        //\
    \ The idea is to use a sweep line algorithm.  We will sweep the line from left\
    \ to right.\n        // We will keep track of the cars that are on the left side\
    \ of the sweep line, and the cars\n        // that are on the right side of the\
    \ sweep line.  We will also keep track of the cars that\n        // are on the\
    \ sweep line.\n        // We will use a priority queue to keep track of the cars\
    \ that are on the left side of the\n        // sweep line.  The priority queue\
    \ will be ordered by the position of the cars.  The cars\n        // that are\
    \ on the right side of the sweep line will be kept in a priority queue that is\n\
    \        // ordered by the position of the cars.  The cars that are on the sweep\
    \ line will be kept\n        // in a priority queue that is ordered by the position\
    \ of the cars.\n        // We will sweep the line from left to right.  When we\
    \ sweep the line, we will move the cars\n        // that are on the sweep line\
    \ to the right side of the sweep line.  We will also move the cars\n        //\
    \ that are on the left side of the sweep line to the sweep line.  We will also\
    \ move the cars\n        // that are on the right side of the sweep line to the\
    \ left side of the sweep line.\n        // We will keep track of the number of\
    \ collisions that have happened so far.  When we move a\n        // car from the\
    \ left side of the sweep line to the sweep line, we will check if there are any\n\
    \        // cars on the right side of the sweep line that are to the left of the\
    \ car that we just moved.\n        // If there are any such cars, we will increment\
    \ the number of collisions.  We will do the same\n        // thing when we move\
    \ a car from the right side of the sweep line to the sweep line.\n        // We\
    \ will also keep track of the number of cars that are on the sweep line.  When\
    \ we move a car\n        // from the left side of the sweep line to the sweep\
    \ line, we will check if there are any cars\n        // on the sweep line that\
    \ are to the left of the car that we just moved.  If there are any such\n    \
    \    // cars, we will increment the number of collisions.  We will do the same\
    \ thing when we move a\n        // car from the right side", "        // The idea\
    \ is to sort the cars by their starting position.\n        // Then, we can use\
    \ a greedy algorithm to count the number of collisions.\n        // The algorithm\
    \ is as follows:\n        // 1.  Sort the cars by their starting position.\n \
    \       // 2.  Start with the first car.  If the car is moving left to right,\
    \ then\n        //     we know that it will collide with the next car that's moving\
    \ right to left.\n        //     So, we count the number of cars moving right\
    \ to left that are to the right of\n        //     the current car.  Then, we\
    \ move on to the next car.\n        // 3.  Repeat step 2 until we've processed\
    \ all cars.\n        //     The total number of collisions is the sum of the number\
    \ of collisions for each car.\n        //\n        // The time complexity of this\
    \ algorithm is O(n log n).\n        // The space complexity of this algorithm\
    \ is O(n).\n        val cars = Array.fill(2 * n.toInt)(0)\n        for (i <- 0\
    \ until n.toInt) {\n            cars(i) = i + 1\n            cars(i + n.toInt)\
    \ = -(i + 1)\n        }\n        scala.util.Sorting.quickSort(cars)\n        var\
    \ collisions = 0L\n        for (i <- 0 until cars.length) {\n            if (cars(i)\
    \ > 0) {\n                var j = i + 1\n                while (j < cars.length\
    \ && cars(j) < 0) {\n                    collisions += 1\n                   \
    \ j += 1\n                }\n            }\n        }\n        collisions", " \
    \       // The idea is to sort the cars by their starting position.\n        //\
    \ Then, we can just iterate through the cars and count the number of collisions.\n\
    \        // The number of collisions is the number of cars that are moving right\
    \ to left\n        // that are to the left of the car that's moving left to right.\n\
    \        // This is the same as the number of cars that are moving left to right\
    \ that are\n        // to the right of the car that's moving right to left.\n\
    \        // We can count this by keeping track of the number of cars that are\
    \ moving left to right\n        // that are to the right of the current car that's\
    \ moving right to left.\n        // We can do this by keeping track of the number\
    \ of cars that are moving left to right\n        // that are to the left of the\
    \ current car that's moving left to right.\n        // We can do this by keeping\
    \ track of the number of cars that are moving right to left\n        // that are\
    \ to the right of the current car that's moving right to left.\n        // We\
    \ can do this by keeping track of the number of cars that are moving right to\
    \ left\n        // that are to the left of the current car that's moving left\
    \ to right.\n        // We can do this by keeping track of the number of cars\
    \ that are moving left to right\n        // that are to the right of the current\
    \ car that's moving right to left.\n        // We can do this by keeping track\
    \ of the number of cars that are moving left to right\n        // that are to\
    \ the left of the current car that's moving left to right.\n        // We can\
    \ do this by keeping track of the number of cars that are moving right to left\n\
    \        // that are to the right of the current car that's moving right to left.\n\
    \        // We can do this by keeping track of the number of cars that are moving\
    \ right to left\n        // that are to the left of the current car that's moving\
    \ left to right.\n        // We can do this by keeping track of the number of\
    \ cars that are moving left to right\n        // that are to the right of the\
    \ current car that's moving right to left.\n        // We can do this by keeping\
    \ track of the number of cars that are moving left to right\n        // that are\
    \ to the left of the current car that's moving left to right.\n        // We can",
  "        // This is a very simple problem.  We just need to find the number of pairs\
    \ of cars\n        // that are moving in opposite directions and have the same\
    \ position.\n        // The number of such pairs is n * (n - 1) / 2.\n       \
    \ n * (n - 1) / 2", "        // This is a very simple problem.  The key observation\
    \ is that the cars\n        // are infinitely strong and sturdy.  As a result,\
    \ the cars will never\n        // collide with each other.  The only way for a\
    \ collision to happen is\n        // for a car to collide with the car that's\
    \ moving in the opposite direction\n        // and has the same speed.  As a result,\
    \ the number of collisions is the\n        // number of cars that are moving in\
    \ the same speed.  Since there are n cars\n        // moving in each direction,\
    \ the number of collisions is n.\n        n", "        // This is a brute force\
    \ solution.  It is not the most efficient solution.\n        // The most efficient\
    \ solution is to use a binary search tree.\n        // However, the brute force\
    \ solution is still fast enough to pass the test cases.\n        var collisions\
    \ = 0L\n        val cars = Array.fill(n.toInt)(0)\n        for (i <- 0 until n.toInt)\
    \ cars(i) = i\n        for (i <- 0 until n.toInt) {\n            for (j <- 0 until\
    \ n.toInt) {\n                if (i != j) {\n                    if (cars(i) >\
    \ cars(j)) collisions += 1\n                }\n            }\n        }\n    \
    \    collisions", "        // This is a very simple problem.  The cars are moving\
    \ in the same speed.\n        // As a result, the cars that are closer to each\
    \ other will collide first.\n        // The cars that are farther away from each\
    \ other will collide later.\n        // The cars that are moving in the same direction\
    \ will never collide.\n        // The cars that are moving in the opposite direction\
    \ will collide.\n        // The number of collisions is the number of cars that\
    \ are moving in the opposite direction.\n        // In other words, the number\
    \ of collisions is n.\n        n", "        // The idea is to use a sweep line\
    \ algorithm.\n        // We'll have a sweep line that's moving right to left.\n\
    \        // We'll have a priority queue that keeps track of the cars that are\
    \ moving\n        // left to right.  The priority queue is sorted by the position\
    \ of the car.\n        // We'll have another priority queue that keeps track of\
    \ the cars that are moving\n        // right to left.  The priority queue is sorted\
    \ by the position of the car.\n        // We'll have a counter that keeps track\
    \ of the number of collisions.\n        // Initially, the sweep line is at the\
    \ rightmost point.\n        // We'll move the sweep line leftward.  As we move\
    \ the sweep line, we'll add\n        // cars to the priority queue.  We'll also\
    \ remove cars from the priority queue.\n        // We'll also update the counter.\n\
    \        // The time complexity is O(n log n).\n        var sweepLine = n * 2\n\
    \        var leftToRightQueue = new PriorityQueue[Long]()(Ordering.Long.reverse)\n\
    \        var rightToLeftQueue = new PriorityQueue[Long]()(Ordering.Long.reverse)\n\
    \        var counter = 0L\n        while (sweepLine > 0) {\n            // Add\
    \ cars to the priority queue.\n            if (sweepLine <= n) {\n           \
    \     leftToRightQueue.enqueue(sweepLine)\n            }\n            if (sweepLine\
    \ <= n) {\n                rightToLeftQueue.enqueue(sweepLine)\n            }\n\
    \            // Remove cars from the priority queue.\n            while (leftToRightQueue.nonEmpty\
    \ && leftToRightQueue.head < sweepLine) {\n                leftToRightQueue.dequeue\n\
    \            }\n            while (rightToLeftQueue.nonEmpty && rightToLeftQueue.head\
    \ < sweepLine) {\n                rightToLeftQueue.dequeue\n            }\n  \
    \          // Update the counter.\n            counter += leftToRightQueue.size\
    \ * rightToLeftQueue.size\n            // Move the sweep line.\n            sweepLine\
    \ -= 1\n        }\n        counter", "        // The idea is to sort the cars\
    \ by their starting positions.\n        // Then, we can simply count the number\
    \ of cars that are moving in the same direction.\n        // The number of collisions\
    \ is the number of cars that are moving in the same direction\n        // minus\
    \ 1.\n        val cars = new Array[(Long, Boolean)](2 * n.toInt)\n        for\
    \ (i <- 0 until n.toInt) {\n            cars(i) = (i, true)\n            cars(i\
    \ + n.toInt) = (i, false)\n        }\n        cars.sortWith((a, b) => a._1 < b._1)\n\
    \        var count = 0\n        var collisions = 0\n        for (i <- 0 until\
    \ 2 * n.toInt) {\n            if (cars(i)._2) {\n                collisions +=\
    \ count\n                count += 1\n            } else {\n                count\
    \ -= 1\n            }\n        }\n        collisions", "        // The idea is\
    \ to sort the cars by their starting position.\n        // Then, we can just count\
    \ the number of cars that are moving left to right\n        // that are to the\
    \ left of a car that's moving right to left.\n        // This is a simple O(n\
    \ log n) algorithm.\n        val cars = Array.fill(2 * n.toInt)(0)\n        for\
    \ (i <- 0 until n.toInt) {\n            cars(i) = i + 1\n            cars(i +\
    \ n.toInt) = -(i + 1)\n        }\n        val sortedCars = cars.sorted\n     \
    \   var count = 0L\n        for (i <- 0 until 2 * n.toInt) {\n            if (sortedCars(i)\
    \ > 0) count += sortedCars.indexWhere(x => x < 0)\n        }\n        count",
  "        // The idea is to use a sweep line algorithm.  We imagine a vertical line\n\
    \        // sweeping from left to right.  The line starts at the leftmost car.\n\
    \        // We keep track of the cars that are to the left of the line.  We keep\n\
    \        // track of the cars that are to the right of the line.  We keep track\
    \ of\n        // the cars that are on the line.  We keep track of the cars that\
    \ are\n        // between the line and the leftmost car.  We keep track of the\
    \ cars that\n        // are between the line and the rightmost car.\n        //\
    \ We keep track of the number of collisions.  We keep track of the number\n  \
    \      // of cars that are on the line.  We keep track of the number of cars that\n\
    \        // are between the line and the leftmost car.  We keep track of the number\n\
    \        // of cars that are between the line and the rightmost car.\n       \
    \ // We keep track of the number of cars that are to the left of the line.\n \
    \       // We keep track of the number of cars that are to the right of the line.\n\
    \        // We keep track of the number of cars that are to the left of the line\n\
    \        // and are moving left to right.  We keep track of the number of cars\
    \ that\n        // are to the left of the line and are moving right to left. \
    \ We keep track\n        // of the number of cars that are to the right of the\
    \ line and are moving\n        // left to right.  We keep track of the number\
    \ of cars that are to the right\n        // of the line and are moving right to\
    \ left.\n        // We keep track of the number of cars that are to the left of\
    \ the line\n        // and are moving left to right and are between the line and\
    \ the leftmost\n        // car.  We keep track of the number of cars that are\
    \ to the left of the line\n        // and are moving right to left and are between\
    \ the line and the leftmost\n        // car.  We keep track of the number of cars\
    \ that are to the right of the line\n        // and are moving left to right and\
    \ are between the line and the rightmost\n        // car.  We keep track of the\
    \ number of cars that are to the right of the line\n        // and are moving\
    \ right to left and are", "        // This is a very simple problem.  The first\
    \ car that's moving left to right\n        // will collide with the first car\
    \ that's moving right to left.  The second car\n        // that's moving left\
    \ to right will collide with the second car that's moving\n        // right to\
    \ left.  And so on.  So the answer is n.\n        n", "        // The idea is\
    \ to sort the cars by their starting positions.\n        // Then, we can simulate\
    \ the race by iterating through the cars.\n        // If a car is moving left\
    \ to right, then it will collide with the next car\n        // that's moving right\
    \ to left.  If a car is moving right to left, then it will\n        // collide\
    \ with the next car that's moving left to right.\n        // The number of collisions\
    \ is the number of cars that are moving left to right\n        // and the number\
    \ of cars that are moving right to left.\n        // The number of cars that are\
    \ moving left to right is the number of cars that\n        // have a starting\
    \ position that's less than the median starting position.\n        // The number\
    \ of cars that are moving right to left is the number of cars that\n        //\
    \ have a starting position that's greater than the median starting position.\n\
    \        // The median starting position is the starting position of the (n +\
    \ 1) / 2th car.\n        val cars = new Array[Long](n.toInt)\n        for (i <-\
    \ 0 until n.toInt) cars(i) = i\n        val median = cars((n - 1) / 2)\n     \
    \   cars.filter(x => x < median).length + cars.filter(x => x > median).length",
  "        // The idea is to sort the cars by their starting positions.\n        //\
    \ Then, we can simulate the race by iterating through the cars\n        // and\
    \ checking if they collide with the cars that are in front of them.\n        //\
    \ The number of collisions is the number of cars that collide with the cars in\
    \ front of them.\n        // The number of cars in front of a car is the number\
    \ of cars that start after it.\n        // The number of cars that start after\
    \ a car is the number of cars that start at a position\n        // that is greater\
    \ than the position of the car.\n        // The number of cars that start at a\
    \ position that is greater than the position of the car\n        // is the number\
    \ of cars that start at a position that is greater than or equal to the position\
    \ of the car.\n        // The number of cars that start at a position that is\
    \ greater than or equal to the position of the car\n        // is the number of\
    \ cars that start at a position that is greater than or equal to the position\
    \ of the car\n        // minus 1.\n        // The number of cars that start at\
    \ a position that is greater than or equal to the position of the car\n      \
    \  // minus 1 is the number of cars that start at a position that is greater than\
    \ or equal to the position of the car\n        // minus 1 plus 1.\n        //\
    \ The number of cars that start at a position that is greater than or equal to\
    \ the position of the car\n        // minus 1 plus 1 is the number of cars that\
    \ start at a position that is greater than or equal to the position of the car.\n\
    \        // The number of cars that start at a position that is greater than or\
    \ equal to the position of the car\n        // is the number of cars that start\
    \ at a position that is greater than or equal to the position of the car\n   \
    \     // plus 1.\n        // The number of cars that start at a position that\
    \ is greater than or equal to the position of the car\n        // plus 1 is the\
    \ number of cars that start at a position that is greater than the position of\
    \ the car.\n        // The number of cars that start at a position that is greater\
    \ than the position of the car\n        // is the number of cars that start after\
    \ the car.\n        // The number of cars that start after the car is the number\
    \ of cars in front of the car.\n        // The number of cars", "        // The\
    \ idea is to sort the cars by their position.  Then, we can use a two pointer\n\
    \        // algorithm to find the number of collisions.\n        // The time complexity\
    \ is O(n log n)\n        val cars = Array.fill(2 * n.toInt)(0)\n        for (i\
    \ <- 0 until n.toInt) {\n            cars(i) = i + 1\n            cars(i + n.toInt)\
    \ = -(i + 1)\n        }\n        val sortedCars = cars.sorted\n        var collisions\
    \ = 0L\n        var i = 0\n        var j = n.toInt\n        while (i < n.toInt\
    \ && j < 2 * n.toInt) {\n            if (sortedCars(i) < 0 && sortedCars(j) >\
    \ 0) {\n                collisions += abs(sortedCars(i))\n                i +=\
    \ 1\n                j += 1\n            } else if (sortedCars(i) < 0) {\n   \
    \             i += 1\n            } else {\n                j += 1\n         \
    \   }\n        }\n        collisions", "        // The idea is to sort the cars\
    \ by their starting positions.\n        // Then, we can simply count the number\
    \ of cars that are moving left to right\n        // and are to the left of a car\
    \ that's moving right to left.\n        // This is because the cars that are moving\
    \ left to right and are to the left of a car\n        // that's moving right to\
    \ left will collide with that car.\n        // The cars that are moving left to\
    \ right and are to the right of a car that's moving\n        // right to left\
    \ will not collide with that car.\n        // The cars that are moving right to\
    \ left and are to the right of a car that's moving\n        // left to right will\
    \ collide with that car.\n        // The cars that are moving right to left and\
    \ are to the left of a car that's moving\n        // left to right will not collide\
    \ with that car.\n        // The cars that are moving left to right and are to\
    \ the right of a car that's moving\n        // left to right will not collide\
    \ with that car.\n        // The cars that are moving right to left and are to\
    \ the left of a car that's moving\n        // right to left will not collide with\
    \ that car.\n        // The cars that are moving left to right and are to the\
    \ left of a car that's moving\n        // left to right will not collide with\
    \ that car.\n        // The cars that are moving right to left and are to the\
    \ right of a car that's moving\n        // right to left will not collide with\
    \ that car.\n        // The cars that are moving left to right and are to the\
    \ right of a car that's moving\n        // right to left will not collide with\
    \ that car.\n        // The cars that are moving right to left and are to the\
    \ left of a car that's moving\n        // left to right will not collide with\
    \ that car.\n        // The cars that are moving left to right and are to the\
    \ left of a car that's moving\n        // right to left will collide with that\
    \ car.\n        // The cars that are moving right to left and are to the right\
    \ of a car that's moving\n        // left to right will collide with that car.\n\
    \        // The cars that are moving left to right and are to the right of a car\
    \ that's moving\n        // left to right will not collide with that car.\n  \
    \      // The cars that", "        // The idea is to sort the cars by their starting\
    \ position.\n        // Then, we can iterate through the cars in order of their\
    \ starting position,\n        // and for each car, we can find the number of cars\
    \ that are to the left of it\n        // and moving right to left.\n        //\
    \ This is a simple O(n log n) algorithm.\n        val cars = Array.fill(2 * n.toInt)(0)\n\
    \        for (i <- 0 until n.toInt) {\n            cars(i) = i + 1\n         \
    \   cars(i + n.toInt) = -(i + 1)\n        }\n        val sortedCars = cars.sorted\n\
    \        var collisions = 0L\n        for (i <- 0 until 2 * n.toInt) {\n     \
    \       if (sortedCars(i) > 0) collisions += i\n        }\n        collisions",
  "        // This is a very simple problem.  The first car that's moving left to\
    \ right\n        // will collide with the nth car that's moving right to left.\
    \  The second car\n        // that's moving left to right will collide with the\
    \ (n-1)th car that's moving\n        // right to left.  And so on.\n        //\
    \ Therefore, the total number of collisions is n + (n-1) + (n-2) + ... + 1 = n\
    \ * (n+1) / 2\n        n * (n + 1) / 2", "        // This is a classic problem\
    \ in discrete math.\n        // The answer is n * (n - 1) / 2.\n        // The\
    \ proof is as follows:\n        // Let's say that the cars moving left to right\
    \ are labeled 1, 2, ..., n.\n        // Let's say that the cars moving right to\
    \ left are labeled n, n - 1, ..., 1.\n        // Then, the number of collisions\
    \ is the number of pairs of cars (i, j) such that\n        // i < j.  This is\
    \ the same as the number of pairs of cars (i, j) such that i < j\n        // and\
    \ i <= n and j <= n.  This is the same as the number of pairs of cars (i, j)\n\
    \        // such that i <= n and j <= n.  This is the same as the number of pairs\
    \ of cars\n        // (i, j) such that i <= n and j <= n and i != j.  This is\
    \ the same as the number\n        // of pairs of cars (i, j) such that i <= n\
    \ and j <= n and i != j and i < j.\n        // This is the same as the number\
    \ of pairs of cars (i, j) such that i <= n and j <= n\n        // and i != j and\
    \ i < j and i <= j.  This is the same as the number of pairs of cars\n       \
    \ // (i, j) such that i <= n and j <= n and i != j and i < j and i <= j and j\
    \ <= i.\n        // This is the same as the number of pairs of cars (i, j) such\
    \ that i <= n and j <= n\n        // and i != j and i < j and i <= j and j <=\
    \ i and i < j.  This is the same as the\n        // number of pairs of cars (i,\
    \ j) such that i <= n and j <= n and i != j and i < j\n        // and i <= j and\
    \ j <= i and i < j and j > i.  This is the same as the number of\n        // pairs\
    \ of cars (i, j) such that i <= n and j <= n and i != j and i < j and i <= j\n\
    \        // and j <= i and i < j and j > i and i < n. ", "        // The key observation\
    \ is that the cars that collide are the ones that are closest to each other.\n\
    \        // So, we can sort the cars by their positions, and then count the number\
    \ of collisions.\n        // The number of collisions is the number of cars that\
    \ are closer than 1 unit to each other.\n        val cars = Array.fill(2 * n.toInt)(0)\n\
    \        for (i <- 0 until n.toInt) {\n            cars(i) = i + 1\n         \
    \   cars(i + n.toInt) = -(i + 1)\n        }\n        val sortedCars = cars.sorted\n\
    \        var collisions = 0\n        for (i <- 1 until 2 * n.toInt) {\n      \
    \      if (sortedCars(i) - sortedCars(i - 1) <= 1) collisions += 1\n        }\n\
    \        collisions", "        // This is a brute force solution.  The idea is\
    \ to simulate the movement of the cars\n        // and count the number of collisions.\n\
    \        // We use a queue to represent the cars moving left to right.  Each element\
    \ in the queue\n        // is a pair (x, y) where x is the position of the car\
    \ and y is the time when the car\n        // reaches position x.\n        // We\
    \ use a stack to represent the cars moving right to left.  Each element in the\
    \ stack\n        // is a pair (x, y) where x is the position of the car and y\
    \ is the time when the car\n        // reaches position x.\n        // We start\
    \ with the queue and stack being empty.  We then add n cars to the queue and\n\
    \        // n cars to the stack.  The cars are added in the order of their positions.\
    \  The position\n        // of the ith car is i.  The time when the ith car reaches\
    \ its position is i.\n        // We then simulate the movement of the cars.  We\
    \ do this by repeatedly removing the\n        // first element from the queue\
    \ and the last element from the stack.  We then check\n        // if the two cars\
    \ collide.  If they do, we increment the number of collisions.\n        // We\
    \ then add the two cars back to the queue and stack.  We add the car from the\
    \ queue\n        // to the back of the queue and the car from the stack to the\
    \ front of the stack.\n        // We continue this process until the queue and\
    \ stack are empty.\n        // The time complexity of this algorithm is O(n^2).\n\
    \        var q = Queue[(Long, Long)]()\n        var s = Stack[(Long, Long)]()\n\
    \        for (i <- 1 to n.toInt) {\n            q += ((i, i))\n            s +=\
    \ ((i, i))\n        }\n        var collisions = 0\n        while (!q.isEmpty &&\
    \ !s.isEmpty) {\n            val (x1, y1) = q.dequeue\n            val (x2, y2)\
    \ = s.pop\n            if (x1 == x2 && y1 == y2) collisions += 1\n           \
    \ q += ((x1, y1 + 1))\n            s.push((x2, y2 + 1))", "        // This function\
    \ returns the number of collisions between the cars that are\n        // moving\
    \ left to right and the cars that are moving right to left.\n        // The cars\
    \ are represented as a list of their starting positions.\n        // The cars\
    \ are assumed to be moving at the same speed.\n        // The cars are assumed\
    \ to be infinitely sturdy and strong.\n        // The cars are assumed to be infinitely\
    \ long.\n        // The cars are assumed to be moving in a straight line.\n  \
    \      // The cars are assumed to be moving in the same direction.\n        //\
    \ The cars are assumed to be moving in a straight line.\n        // The cars are\
    \ assumed to be moving in the same direction.\n        // The cars are assumed\
    \ to be moving in a straight line.\n        // The cars are assumed to be moving\
    \ in the same direction.\n        // The cars are assumed to be moving in a straight\
    \ line.\n        // The cars are assumed to be moving in the same direction.\n\
    \        // The cars are assumed to be moving in a straight line.\n        //\
    \ The cars are assumed to be moving in the same direction.\n        // The cars\
    \ are assumed to be moving in a straight line.\n        // The cars are assumed\
    \ to be moving in the same direction.\n        // The cars are assumed to be moving\
    \ in a straight line.\n        // The cars are assumed to be moving in the same\
    \ direction.\n        // The cars are assumed to be moving in a straight line.\n\
    \        // The cars are assumed to be moving in the same direction.\n       \
    \ // The cars are assumed to be moving in a straight line.\n        // The cars\
    \ are assumed to be moving in the same direction.\n        // The cars are assumed\
    \ to be moving in a straight line.\n        // The cars are assumed to be moving\
    \ in the same direction.\n        // The cars are assumed to be moving in a straight\
    \ line.\n        // The cars are assumed to be moving in the same direction.\n\
    \        // The cars are assumed to be moving in a straight line.\n        //\
    \ The cars are assumed to be moving in the same direction.\n        // The cars\
    \ are assumed to be moving in a straight line.\n        // The cars are assumed\
    \ to be moving in the same direction.\n        // The cars are assumed to be moving\
    \ in a straight line.\n        // The cars are assumed to be moving in the same\
    \ direction.\n        // The", "        // The idea is to sort the cars by their\
    \ starting position.  Then, we can\n        // count the number of collisions\
    \ by counting the number of cars that are\n        // moving in the same direction.\n\
    \        // The cars that are moving in the same direction will collide with each\
    \ other.\n        // The number of collisions is the number of cars that are moving\
    \ in the same\n        // direction minus 1.\n        // The number of cars that\
    \ are moving in the same direction is the number of\n        // cars that are\
    \ moving left to right plus the number of cars that are moving\n        // right\
    \ to left minus 1.\n        // The number of cars that are moving left to right\
    \ is the number of cars\n        // that are moving right to left.\n        //\
    \ The number of cars that are moving right to left is the number of cars\n   \
    \     // that are moving left to right.\n        // The number of cars that are\
    \ moving left to right is the number of cars\n        // that are moving right\
    \ to left.\n        // The number of cars that are moving right to left is the\
    \ number of cars\n        // that are moving left to right.\n        // The number\
    \ of cars that are moving left to right is the number of cars\n        // that\
    \ are moving right to left.\n        // The number of cars that are moving right\
    \ to left is the number of cars\n        // that are moving left to right.\n \
    \       // The number of cars that are moving left to right is the number of cars\n\
    \        // that are moving right to left.\n        // The number of cars that\
    \ are moving right to left is the number of cars\n        // that are moving left\
    \ to right.\n        // The number of cars that are moving left to right is the\
    \ number of cars\n        // that are moving right to left.\n        // The number\
    \ of cars that are moving right to left is the number of cars\n        // that\
    \ are moving left to right.\n        // The number of cars that are moving left\
    \ to right is the number of cars\n        // that are moving right to left.\n\
    \        // The number of cars that are moving right to left is the number of\
    \ cars\n        // that are moving left to right.\n        // The number of cars\
    \ that are moving left to right is the number of cars\n        // that are moving\
    \ right to left.\n        // The number of cars that are moving right to left\
    \ is the", "        // This is a simple problem that can be solved by hand.\n\
    \        // If n = 1, then there are no collisions.\n        // If n = 2, then\
    \ there are 1 collision.\n        // If n = 3, then there are 3 collisions.\n\
    \        // If n = 4, then there are 6 collisions.\n        // If n = 5, then\
    \ there are 10 collisions.\n        // If n = 6, then there are 15 collisions.\n\
    \        // If n = 7, then there are 21 collisions.\n        // If n = 8, then\
    \ there are 28 collisions.\n        // If n = 9, then there are 36 collisions.\n\
    \        // If n = 10, then there are 45 collisions.\n        // If n = 11, then\
    \ there are 55 collisions.\n        // If n = 12, then there are 66 collisions.\n\
    \        // If n = 13, then there are 78 collisions.\n        // If n = 14, then\
    \ there are 91 collisions.\n        // If n = 15, then there are 105 collisions.\n\
    \        // If n = 16, then there are 120 collisions.\n        // If n = 17, then\
    \ there are 136 collisions.\n        // If n = 18, then there are 153 collisions.\n\
    \        // If n = 19, then there are 171 collisions.\n        // If n = 20, then\
    \ there are 190 collisions.\n        // If n = 21, then there are 210 collisions.\n\
    \        // If n = 22, then there are 231 collisions.\n        // If n = 23, then\
    \ there are 253 collisions.\n        // If n = 24, then there are 276 collisions.\n\
    \        // If n = 25, then there are 300 collisions.\n        // If n = 26, then\
    \ there are 325 collisions.\n        // If n = 27, then there are 351 collisions.\n\
    \        // If n = 28, then there are 378 collisions.\n        // If n = 29, then\
    \ there are 406 collisions.\n        // If n = 30, then there are 435 collisions.\n\
    \        // If n = 31, then there are 465 collisions.\n        // If n = 32, then\
    \ there are 496 collisions.\n        // If n = 33, then there are 528 collisions.\n\
    \        // If n = 34, then there are 561 collisions.\n        // If n = 35, then\
    \ there are 595 collisions.\n        //", "        // This function outputs the\
    \ number of collisions between cars that are moving\n        // from left to right\
    \ and cars that are moving from right to left.\n        // The cars are numbered\
    \ from 0 to n - 1.\n        // The cars are moving at the same speed.\n      \
    \  // The cars are moving in a straight line.\n        // The cars are infinitely\
    \ strong and sturdy.\n        // The cars are moving in the same direction.\n\
    \        // The cars are moving in the same direction.\n        // The cars are\
    \ moving in the same direction.\n        // The cars are moving in the same direction.\n\
    \        // The cars are moving in the same direction.\n        // The cars are\
    \ moving in the same direction.\n        // The cars are moving in the same direction.\n\
    \        // The cars are moving in the same direction.\n        // The cars are\
    \ moving in the same direction.\n        // The cars are moving in the same direction.\n\
    \        // The cars are moving in the same direction.\n        // The cars are\
    \ moving in the same direction.\n        // The cars are moving in the same direction.\n\
    \        // The cars are moving in the same direction.\n        // The cars are\
    \ moving in the same direction.\n        // The cars are moving in the same direction.\n\
    \        // The cars are moving in the same direction.\n        // The cars are\
    \ moving in the same direction.\n        // The cars are moving in the same direction.\n\
    \        // The cars are moving in the same direction.\n        // The cars are\
    \ moving in the same direction.\n        // The cars are moving in the same direction.\n\
    \        // The cars are moving in the same direction.\n        // The cars are\
    \ moving in the same direction.\n        // The cars are moving in the same direction.\n\
    \        // The cars are moving in the same direction.\n        // The cars are\
    \ moving in the same direction.\n        // The cars are moving in the same direction.\n\
    \        // The cars are moving in the same direction.\n        // The cars are\
    \ moving in the same direction.\n        // The cars are moving in the same direction.\n\
    \        // The cars are moving in the same direction.\n        // The cars are\
    \ moving in the same direction.\n        // The cars are moving in the same direction.\n\
    \        // The cars are moving in the same direction.\n        // The cars are\
    \ moving in the same direction", "        // This is a very simple problem.  We\
    \ can just simulate the movement of the cars.\n        // We can use a priority\
    \ queue to keep track of the cars.\n        // The priority queue will be sorted\
    \ by the position of the cars.\n        // We can use a tuple to represent the\
    \ cars.  The first element of the tuple\n        // is the position of the car;\
    \ the second element of the tuple is the direction\n        // of the car.  The\
    \ direction is either 1 or -1.  1 means the car is moving right\n        // to\
    \ left; -1 means the car is moving left to right.\n        // We can use a variable\
    \ to keep track of the number of collisions.\n        // We can use a variable\
    \ to keep track of the current time.\n        // We can use a variable to keep\
    \ track of the current position of the car.\n        // We can use a variable\
    \ to keep track of the current direction of the car.\n        // We can use a\
    \ variable to keep track of the current number of cars.\n        // We can use\
    \ a variable to keep track of the current number of collisions.\n        // We\
    \ can use a variable to keep track of the current time.\n        // We can use\
    \ a variable to keep track of the current position of the car.\n        // We\
    \ can use a variable to keep track of the current direction of the car.\n    \
    \    // We can use a variable to keep track of the current number of cars.\n \
    \       // We can use a variable to keep track of the current number of collisions.\n\
    \        // We can use a variable to keep track of the current time.\n       \
    \ // We can use a variable to keep track of the current position of the car.\n\
    \        // We can use a variable to keep track of the current direction of the\
    \ car.\n        // We can use a variable to keep track of the current number of\
    \ cars.\n        // We can use a variable to keep track of the current number\
    \ of collisions.\n        // We can use a variable to keep track of the current\
    \ time.\n        // We can use a variable to keep track of the current position\
    \ of the car.\n        // We can use a variable to keep track of the current direction\
    \ of the car.\n        // We can use a variable to keep track of the current number\
    \ of cars.\n        // We can use a variable to keep track of the current number\
    \ of collisions.\n", "        // We will use a priority queue to keep track of\
    \ the cars.\n        // The priority queue will be sorted by the car's position.\n\
    \        // The priority queue will contain tuples of the form (position, direction).\n\
    \        // The direction is either 1 or -1.  1 means the car is moving left to\
    \ right.\n        // -1 means the car is moving right to left.\n        // The\
    \ priority queue will be sorted by the position.\n        // The priority queue\
    \ will be initialized with the first n cars moving left to right\n        // and\
    \ the last n cars moving right to left.\n        // Then, we will simulate the\
    \ cars moving.  At each step, we will pop the car with\n        // the smallest\
    \ position.  We will then update the position of the car and push it\n       \
    \ // back into the priority queue.  We will keep doing this until the priority\
    \ queue\n        // is empty.\n        // The number of collisions is the number\
    \ of times we pop a car that's moving left to right\n        // and the next car\
    \ in the priority queue is moving right to left.\n        // We will use a variable\
    \ called \"collision\" to keep track of the number of collisions.\n        //\
    \ We will use a variable called \"lastPosition\" to keep track of the last position\
    \ popped\n        // from the priority queue.\n        // We will use a variable\
    \ called \"lastDirection\" to keep track of the last direction popped\n      \
    \  // from the priority queue.\n        // We will use a variable called \"pq\"\
    \ to keep track of the priority queue.\n        var collision = 0L\n        var\
    \ lastPosition = 0L\n        var lastDirection = 0\n        var pq = new PriorityQueue[(Long,\
    \ Int)]()(Ordering.by(x => x._1))\n        // Initialize the priority queue.\n\
    \        for (i <- 1 to n.toInt) {\n            pq.enqueue((i, 1))\n         \
    \   pq.enqueue((-i, -1))\n        }\n        // Simulate the cars moving.\n  \
    \      while (!pq.isEmpty) {\n            val (position, direction) = pq.dequeue\n\
    \            if (direction == 1 && lastDirection == -1) collision += 1\n     \
    \       lastPosition = position\n            lastDirection = direction\n     \
    \       pq.", "        // This function returns the number of collisions between\
    \ the ith car\n        // moving left to right and the jth car moving right to\
    \ left.\n        def collision(i : Long, j : Long) : Long = {\n            //\
    \ The ith car moving left to right starts at position i.\n            // The jth\
    \ car moving right to left starts at position -j.\n            // The ith car\
    \ moving left to right moves at speed 1.\n            // The jth car moving right\
    \ to left moves at speed 1.\n            // The ith car moving left to right will\
    \ collide with the jth car moving right to left\n            // when the ith car\
    \ moving left to right reaches position -j.\n            // The ith car moving\
    \ left to right will reach position -j when it has moved i + j units.\n      \
    \      // The jth car moving right to left will reach position i when it has moved\
    \ i + j units.\n            // Therefore, the ith car moving left to right will\
    \ collide with the jth car moving right to left\n            // when the jth car\
    \ moving right to left reaches position i.\n            // The jth car moving\
    \ right to left will reach position i when it has moved i + j units.\n       \
    \     // Therefore, the ith car moving left to right will collide with the jth\
    \ car moving right to left\n            // when the jth car moving right to left\
    \ has moved i + j units.\n            // The jth car moving right to left moves\
    \ at speed 1.\n            // Therefore, the ith car moving left to right will\
    \ collide with the jth car moving right to left\n            // when the jth car\
    \ moving right to left has moved i + j units.\n            // The jth car moving\
    \ right to left has moved i + j units when the time is i + j.\n            //\
    \ Therefore, the ith car moving left to right will collide with the jth car moving\
    \ right to left\n            // when the time is i + j.\n            i + j\n \
    \       }\n        // The number of collisions is the sum of the number of collisions\
    \ between the ith car\n        // moving left to right and the jth car moving\
    \ right to left for all i and j.\n        (1 to n.toInt).map(i => (1 to n.toInt).map(j\
    \ => collision(i, j))).fl", "        // The idea is to sort the cars by their\
    \ starting position.\n        // Then, we can just iterate through the cars, and\
    \ if the car is moving left to right,\n        // we add it to a set of cars that\
    \ are moving left to right.  If the car is moving right to left,\n        // we\
    \ remove it from the set of cars that are moving left to right.  The number of\
    \ cars that are\n        // moving left to right is the number of collisions.\n\
    \        // This algorithm runs in O(n log n) time.\n        val cars = Array.fill(2\
    \ * n.toInt)(0)\n        for (i <- 0 until n.toInt) {\n            cars(i) = i\
    \ + 1\n            cars(i + n.toInt) = -(i + 1)\n        }\n        scala.util.Sorting.quickSort(cars)\n\
    \        var collisions = 0\n        var carsMovingLeftToRight = Set[Int]()\n\
    \        for (i <- 0 until 2 * n.toInt) {\n            if (cars(i) > 0) {\n  \
    \              carsMovingLeftToRight += cars(i)\n            } else {\n      \
    \          if (carsMovingLeftToRight.contains(-cars(i))) {\n                 \
    \   collisions += 1\n                }\n                carsMovingLeftToRight\
    \ -= -cars(i)\n            }\n        }\n        collisions", "        // We can\
    \ solve this problem by first sorting the cars by their starting position.\n \
    \       // Then we can iterate through the cars in order, and for each car, we\
    \ can find the\n        // number of cars that it collides with by finding the\
    \ number of cars that are\n        // to the left of it and moving right to left.\n\
    \        // This can be done in O(n log n) time.\n        // However, we can do\
    \ better.\n        // We can solve this problem in O(n) time by using a stack.\n\
    \        // We can iterate through the cars in order, and for each car, we can\
    \ push it onto\n        // the stack.  If the car is moving right to left, we\
    \ can pop the stack and count\n        // the number of collisions.  If the car\
    \ is moving left to right, we can push it\n        // onto the stack.\n      \
    \  // This algorithm runs in O(n) time.\n        var stack = new Stack[Long]\n\
    \        var collisions = 0L\n        for (i <- 1 to n.toInt) {\n            val\
    \ car = i\n            if (car % 2 == 0) {\n                // car is moving right\
    \ to left\n                while (!stack.isEmpty) {\n                    collisions\
    \ += 1\n                    stack.pop\n                }\n            } else {\n\
    \                // car is moving left to right\n                stack.push(car)\n\
    \            }\n        }\n        collisions", "        // The idea is to use\
    \ a sweep line algorithm.  We'll use a sweep line that moves\n        // from\
    \ left to right.  We'll keep track of the cars that are moving left to right\n\
    \        // and the cars that are moving right to left.  We'll also keep track\
    \ of the\n        // current position of the sweep line.  When the sweep line\
    \ reaches a car, we'll\n        // remove it from the set of cars that are moving\
    \ left to right or right to left.\n        // We'll also check if the car that's\
    \ being removed is colliding with any cars\n        // that are moving right to\
    \ left.  If so, we'll increment the number of collisions.\n        // We'll continue\
    \ this process until there are no more cars.\n        // We'll use a priority\
    \ queue to keep track of the cars that are moving left to right\n        // and\
    \ the cars that are moving right to left.  The priority queue will be sorted\n\
    \        // by the position of the cars.  The cars that are moving left to right\
    \ will be\n        // sorted in ascending order, and the cars that are moving\
    \ right to left will be\n        // sorted in descending order.\n        // We'll\
    \ use a priority queue to keep track of the cars that are moving left to right\n\
    \        // and the cars that are moving right to left.  The priority queue will\
    \ be sorted\n        // by the position of the cars.  The cars that are moving\
    \ left to right will be\n        // sorted in ascending order, and the cars that\
    \ are moving right to left will be\n        // sorted in descending order.\n \
    \       val leftToRight = new PriorityQueue[Long]()(Ordering.Long.reverse)\n \
    \       val rightToLeft = new PriorityQueue[Long]()(Ordering.Long.reverse)\n \
    \       // We'll use a variable to keep track of the current position of the sweep\
    \ line.\n        var currentPosition = 0L\n        // We'll use a variable to\
    \ keep track of the number of collisions.\n        var collisions = 0L\n     \
    \   // We'll use a variable to keep track of the number of cars that are moving\
    \ left to right.\n        var leftToRightCount = 0L\n        // We'll use a variable\
    \ to keep track of the number of cars that are moving right to left.\n       \
    \ var rightToLeftCount = 0L\n        // We'll use a variable", "        // The\
    \ cars are numbered 1 to n.  The cars moving left to right are numbered 1 to n.\n\
    \        // The cars moving right to left are numbered n+1 to 2n.\n        //\
    \ For each car moving left to right, we'll keep track of the time it takes for\
    \ it to reach\n        // the origin.  For each car moving right to left, we'll\
    \ keep track of the time it takes for it\n        // to reach the origin.  We'll\
    \ sort the times in ascending order.  Then, we'll iterate through\n        //\
    \ the times in ascending order.  If the time is for a car moving left to right,\
    \ we'll increment\n        // the number of collisions by the number of cars moving\
    \ right to left that have already reached\n        // the origin.  If the time\
    \ is for a car moving right to left, we'll decrement the number of collisions\n\
    \        // by the number of cars moving left to right that have already reached\
    \ the origin.\n        // The reason why this works is because the cars are infinitely\
    \ sturdy and strong.  As a result,\n        // the cars moving left to right will\
    \ not be affected by the cars moving right to left, and vice versa.\n        //\
    \ Therefore, the number of collisions is the number of cars moving left to right\
    \ that have already\n        // reached the origin times the number of cars moving\
    \ right to left that have already reached the origin.\n        // This is the\
    \ same as the number of cars moving left to right that have already reached the\
    \ origin\n        // minus the number of cars moving right to left that have already\
    \ reached the origin.\n        var collisions = 0L\n        var leftToRight =\
    \ new Array[Long](n.toInt)\n        var rightToLeft = new Array[Long](n.toInt)\n\
    \        for (i <- 0 until n.toInt) {\n            leftToRight(i) = i + 1\n  \
    \          rightToLeft(i) = n + i + 1\n        }\n        var times = new Array[Long](2\
    \ * n.toInt)\n        for (i <- 0 until n.toInt) {\n            times(i) = leftToRight(i)\n\
    \            times(i + n.toInt) = rightToLeft(i)\n        }\n        times = times.sorted\n\
    \        var leftToRightCount = 0\n        var rightTo", "        // The idea\
    \ is to sort the cars by their starting position.\n        // Then, for each car,\
    \ we can determine how many cars it collides with.\n        // The total number\
    \ of collisions is the sum of the number of collisions\n        // for each car.\n\
    \        // The number of collisions for a car is the number of cars that are\n\
    \        // to the left of it and moving right to left, plus the number of cars\n\
    \        // that are to the right of it and moving left to right.\n        //\
    \ This is equal to the number of cars that are to the left of it and moving\n\
    \        // right to left, plus the number of cars that are to the right of it\
    \ and moving\n        // right to left, minus the number of cars that are to the\
    \ right of it and moving\n        // right to left.\n        // The number of\
    \ cars that are to the left of it and moving right to left is\n        // the\
    \ number of cars that are to the left of it and moving left to right.\n      \
    \  // The number of cars that are to the right of it and moving right to left\
    \ is\n        // the number of cars that are to the right of it and moving left\
    \ to right.\n        // The number of cars that are to the right of it and moving\
    \ right to left is\n        // the number of cars that are to the right of it\
    \ and moving left to right.\n        // So the number of collisions for a car\
    \ is the number of cars that are to the\n        // left of it and moving left\
    \ to right, plus the number of cars that are to the\n        // right of it and\
    \ moving left to right, minus the number of cars that are to the\n        // right\
    \ of it and moving left to right.\n        // This is equal to the number of cars\
    \ that are to the left of it and moving\n        // left to right, plus the number\
    \ of cars that are to the right of it and moving\n        // left to right.\n\
    \        // This is equal to the number of cars that are to the left of it and\
    \ moving\n        // left to right, plus the number of cars that are to the right\
    \ of it and moving\n        // left to right, minus the number of cars that are\
    \ to the right of it and moving\n        // left to right.\n        // This is\
    \ equal to the number of cars that are to the left of it and moving\n       ",
  "        // The idea is to sort the cars by their starting position.  Then, we can\n\
    \        // iterate through the cars and count the number of collisions.\n   \
    \     // The number of collisions is the number of cars that are moving left to\
    \ right\n        // minus the number of cars that are moving right to left.\n\
    \        // We can use a balanced binary search tree to sort the cars.\n     \
    \   val tree = new TreeMap[Long, Long]()\n        for (i <- 1L to n) {\n     \
    \       val x = (i - 1) * 2 + 1\n            tree(x) = tree.getOrElse(x, 0L) +\
    \ 1\n        }\n        var result = 0L\n        var i = 1L\n        for ((x,\
    \ count) <- tree) {\n            val j = (x + 1) / 2\n            if (i < j) {\n\
    \                result += (j - i) * count\n            }\n            i = j +\
    \ count\n        }\n        result", "        // The first car that's moving left\
    \ to right will collide with the last car that's moving right to left.\n     \
    \   // The second car that's moving left to right will collide with the second\
    \ to last car that's moving right to left.\n        // ...\n        // The nth\
    \ car that's moving left to right will collide with the nth car that's moving\
    \ right to left.\n        // Therefore, the answer is n.\n        n", "      \
    \  // The idea is to sort the cars by their starting positions.\n        // Then,\
    \ we can easily count the number of collisions.\n        // The number of collisions\
    \ is the number of cars that are moving left to right\n        // that are to\
    \ the left of a car that's moving right to left.\n        // This is the same\
    \ as the number of cars that are moving right to left\n        // that are to\
    \ the right of a car that's moving left to right.\n        // So, we can just\
    \ sort the cars by their starting positions, and then\n        // count the number\
    \ of cars that are moving left to right that are to the left\n        // of a\
    \ car that's moving right to left.\n        // This is the same as the number\
    \ of cars that are moving right to left that are to the right\n        // of a\
    \ car that's moving left to right.\n        // So, we can just sort the cars by\
    \ their starting positions, and then\n        // count the number of cars that\
    \ are moving left to right that are to the left\n        // of a car that's moving\
    \ right to left.\n        // This is the same as the number of cars that are moving\
    \ right to left that are to the right\n        // of a car that's moving left\
    \ to right.\n        // So, we can just sort the cars by their starting positions,\
    \ and then\n        // count the number of cars that are moving left to right\
    \ that are to the left\n        // of a car that's moving right to left.\n   \
    \     // This is the same as the number of cars that are moving right to left\
    \ that are to the right\n        // of a car that's moving left to right.\n  \
    \      // So, we can just sort the cars by their starting positions, and then\n\
    \        // count the number of cars that are moving left to right that are to\
    \ the left\n        // of a car that's moving right to left.\n        // This\
    \ is the same as the number of cars that are moving right to left that are to\
    \ the right\n        // of a car that's moving left to right.\n        // So,\
    \ we can just sort the cars by their starting positions, and then\n        //\
    \ count the number of cars that are moving left to right that are to the left\n\
    \        // of a car that's moving right to left.\n        // This is the same\
    \ as the number of cars that are moving right to", "        // This is a simple\
    \ problem that can be solved by a simple greedy algorithm.\n        // The greedy\
    \ algorithm is as follows:\n        // 1.  Sort the cars by their starting position.\n\
    \        // 2.  For each car, find the first car that's moving in the opposite\
    \ direction.\n        // 3.  The number of collisions is the number of cars that\
    \ have a car moving in the opposite direction.\n        // This algorithm is correct\
    \ because if a car moving in one direction collides with a car moving in the opposite\
    \ direction,\n        // then the car moving in the opposite direction must be\
    \ the first car moving in the opposite direction.\n        // This algorithm is\
    \ also optimal because if a car moving in one direction collides with a car moving\
    \ in the opposite direction,\n        // then the car moving in the opposite direction\
    \ must be the first car moving in the opposite direction.\n        // This algorithm\
    \ is also fast because it runs in O(n log n) time.\n        // The algorithm is\
    \ implemented below.\n        val cars = new Array[(Long, Boolean)](2 * n.toInt)\n\
    \        for (i <- 0 until n.toInt) {\n            cars(i) = (i.toLong, true)\n\
    \            cars(i + n.toInt) = (i.toLong, false)\n        }\n        val sortedCars\
    \ = cars.sortWith((a, b) => a._1 < b._1)\n        var collisions = 0\n       \
    \ for (i <- 0 until 2 * n.toInt) {\n            if (sortedCars(i)._2) {\n    \
    \            for (j <- i + 1 until 2 * n.toInt) {\n                    if (!sortedCars(j)._2)\
    \ {\n                        collisions += 1\n                        break\n\
    \                    }\n                }\n            }\n        }\n        collisions",
  "        // The idea is to sort the cars by their starting positions.\n        //\
    \ Then, we can simply count the number of cars that are moving left to right\n\
    \        // and the number of cars that are moving right to left.  The number\
    \ of collisions\n        // is the product of these two numbers.\n        // The\
    \ number of cars moving left to right is n.\n        // The number of cars moving\
    \ right to left is n - 1.\n        // Therefore, the number of collisions is n\
    \ * (n - 1).\n        n * (n - 1)", "        // This is the number of cars that\
    \ are moving left to right.\n        // The cars are indexed from 0 to n - 1.\n\
    \        // The car with index i starts at position i.\n        // The car with\
    \ index i moves at speed i.\n        // The car with index i moves left to right.\n\
    \        // The car with index i will collide with the car with index n - 1 -\
    \ i.\n        // The car with index i will collide with the car with index n -\
    \ 1 - i at time (n - 1 - i) / i.\n        // The car with index i will collide\
    \ with the car with index n - 1 - i at position (n - 1 - i) * (n - 1 - i) / i.\n\
    \        // The car with index i will collide with the car with index n - 1 -\
    \ i at position (n - 1 - i) * (n - 1 - i) / i + i.\n        // The car with index\
    \ i will collide with the car with index n - 1 - i at position (n - 1 - i) * (n\
    \ - 1 - i) / i + i + (n - 1 - i).\n        // The car with index i will collide\
    \ with the car with index n - 1 - i at position (n - 1 - i) * (n - 1 - i) / i\
    \ + i + (n - 1 - i) + i.\n        // The car with index i will collide with the\
    \ car with index n - 1 - i at position (n - 1 - i) * (n - 1 - i) / i + i + (n\
    \ - 1 - i) + i + (n - 1 - i).\n        // The car with index i will collide with\
    \ the car with index n - 1 - i at position (n - 1 - i) * (n - 1 - i) / i + i +\
    \ (n - 1 - i) + i + (n - 1 - i) + i.\n        // The car with index i will collide\
    \ with the car with index n - 1 - i at position (n - 1 - i) * (n - 1 - i) / i\
    \ + i + (n - 1 - i) + i + (n - 1 - i) + i + (n - 1 - i).\n        // The car with\
    \ index i will collide with the car with index n -", "        // We can represent\
    \ the cars as a list of pairs (x, y), where x is the position of the car\n   \
    \     // and y is the direction of the car.  A car moving left to right has y\
    \ = 1, and a car\n        // moving right to left has y = -1.  We can sort the\
    \ list by x, and then count the number\n        // of pairs (x, y) where y = 1\
    \ and (x, -y) is also in the list.\n        val cars = (for (i <- 1 to n.toInt)\
    \ yield (i, 1)).toList ++ (for (i <- 1 to n.toInt) yield (i, -1)).toList\n   \
    \     val sortedCars = cars.sortBy(_._1)\n        var collisions = 0\n       \
    \ for (i <- 0 until sortedCars.length) {\n            val (x, y) = sortedCars(i)\n\
    \            if (y == 1) {\n                val (x2, y2) = sortedCars(sortedCars.length\
    \ - 1 - i)\n                if (x2 == x && y2 == -y) collisions += 1\n       \
    \     }\n        }\n        collisions", "        // This is a very simple problem.\
    \  The cars are moving in the same speed, so\n        // the order of the cars\
    \ does not matter.  The only thing that matters is the\n        // distance between\
    \ the cars.  So, we can imagine that all the cars are moving\n        // in the\
    \ same direction.  Then, the problem reduces to finding the number of\n      \
    \  // pairs of cars that are at the same position.  This is a simple combinatorics\n\
    \        // problem.  The answer is n * (n - 1) / 2.\n        n * (n - 1) / 2",
  "        // We can solve this problem by first sorting the cars by their starting\
    \ positions.\n        // Then, we can iterate through the cars from left to right.\
    \  We can keep track of the\n        // number of cars that are moving right to\
    \ left that are to the left of the current car.\n        // This is the number\
    \ of collisions that the current car will have.\n        // This algorithm runs\
    \ in O(n log n) time.\n        val cars = new Array[Long](2 * n.toInt)\n     \
    \   for (i <- 0 until n.toInt) {\n            cars(i) = i + 1\n            cars(i\
    \ + n.toInt) = -(i + 1)\n        }\n        val sortedCars = cars.sorted\n   \
    \     var collisions = 0L\n        var rightToLeftCars = 0\n        for (i <-\
    \ 0 until 2 * n.toInt) {\n            if (sortedCars(i) < 0) rightToLeftCars +=\
    \ 1\n            else collisions += rightToLeftCars\n        }\n        collisions",
  "        // We can solve this problem by considering the cars as points on a number\
    \ line.\n        // The cars moving left to right are at positions 1, 2, ...,\
    \ n.\n        // The cars moving right to left are at positions -1, -2, ..., -n.\n\
    \        // A collision occurs when the absolute value of the difference between\
    \ the positions\n        // of two cars is equal to 1.\n        // For example,\
    \ if n = 3, then the cars moving left to right are at positions 1, 2, 3.\n   \
    \     // The cars moving right to left are at positions -1, -2, -3.\n        //\
    \ The collisions are:\n        // 1 and -1\n        // 2 and -2\n        // 3\
    \ and -3\n        // The total number of collisions is 3.\n        // We can generalize\
    \ this to any value of n.\n        // The total number of collisions is n.\n \
    \       n", "        val cars = new Array[Long](2 * n.toInt)\n        for (i <-\
    \ 0 until n.toInt) {\n            cars(i) = i + 1\n            cars(i + n.toInt)\
    \ = -(i + 1)\n        }\n        cars.sorted.zipWithIndex.filter(x => x._1 < 0\
    \ && x._2 < n.toInt).size", "        // The idea is to use a priority queue to\
    \ store the cars that are moving left to right.\n        // We will store the\
    \ cars in the priority queue in increasing order of their position.\n        //\
    \ Then, we will iterate through the cars that are moving right to left.  For each\
    \ car\n        // that is moving right to left, we will remove all cars from the\
    \ priority queue that\n        // have a position less than the position of the\
    \ car that is moving right to left.\n        // The number of cars removed from\
    \ the priority queue is the number of collisions.\n        // The reason is that\
    \ the cars that are removed from the priority queue are the cars\n        // that\
    \ are moving left to right and have collided with the car that is moving right\
    \ to left.\n        // The cars that are moving left to right are in increasing\
    \ order of their position.\n        // Thus, the cars that are removed from the\
    \ priority queue are in increasing order of their\n        // position.  Thus,\
    \ the cars that are removed from the priority queue are the cars that\n      \
    \  // have collided with the car that is moving right to left.\n        val pq\
    \ = new PriorityQueue[Long]()\n        var collisions = 0L\n        for (i <-\
    \ 1 to n.toInt) {\n            pq.enqueue(i)\n        }\n        for (i <- n.toInt\
    \ to 1 by -1) {\n            collisions += pq.size\n            pq.dequeue\n \
    \       }\n        collisions", "        // This is a simple problem.  The key\
    \ observation is that the cars that are moving\n        // in the same direction\
    \ will never collide.  So, we only need to count the number\n        // of collisions\
    \ between cars that are moving in opposite directions.\n        //\n        //\
    \ The cars that are moving in the same direction are easy to count.  The first\
    \ car\n        // will collide with n - 1 cars.  The second car will collide with\
    \ n - 2 cars.\n        // The third car will collide with n - 3 cars.  The nth\
    \ car will collide with 0 cars.\n        // So, the total number of collisions\
    \ is n + (n - 1) + (n - 2) + ... + 1 = n * (n + 1) / 2.\n        //\n        //\
    \ The cars that are moving in opposite directions are also easy to count.  The\
    \ first car\n        // will collide with n cars.  The second car will collide\
    \ with n - 1 cars.  The third car\n        // will collide with n - 2 cars.  The\
    \ nth car will collide with 1 car.  So, the total number\n        // of collisions\
    \ is n + (n - 1) + (n - 2) + ... + 1 = n * (n + 1) / 2.\n        //\n        //\
    \ So, the total number of collisions is 2 * n * (n + 1) / 2 = n * (n + 1).\n \
    \       n * (n + 1)", "        // This is a very simple problem.  The key is to\
    \ realize that the cars\n        // are moving at the same speed.  As a result,\
    \ the only thing that matters\n        // is the order in which the cars appear\
    \ on the road.  For example, if the\n        // cars are ordered as follows:\n\
    \        //\n        //    1 2 3 4 5 6 7 8 9 10\n        //\n        // Then there\
    \ will be no collisions.  However, if the cars are ordered as follows:\n     \
    \   //\n        //    1 2 3 4 5 6 7 8 9 10\n        //    10 9 8 7 6 5 4 3 2 1\n\
    \        //\n        // Then there will be 9 collisions.  In general, if the cars\
    \ are ordered as follows:\n        //\n        //    1 2 3 4 5 6 7 8 9 10\n  \
    \      //    a b c d e f g h i j\n        //\n        // Then there will be (a\
    \ - 1) + (b - 2) + (c - 3) + ... + (j - 10) collisions.\n        //\n        //\
    \ The problem is to find the number of collisions for a given n.  This is\n  \
    \      // equivalent to finding the number of permutations of the numbers 1 to\
    \ n\n        // such that the sum of the differences between the numbers is negative.\n\
    \        //\n        // For example, if n = 3, then the permutations are:\n  \
    \      //\n        //    1 2 3\n        //    1 3 2\n        //    2 1 3\n   \
    \     //    2 3 1\n        //    3 1 2\n        //    3 2 1\n        //\n    \
    \    // The permutations that have a negative sum of differences are:\n      \
    \  //\n        //    1 3 2\n        //    2 3 1\n        //    3 1 2\n       \
    \ //\n        // The number of such permutations is 3.\n        //\n        //\
    \ The problem is to find the number of such permutations for a given n.\n    \
    \    //\n        // The answer is given by the following formula:\n        //\n\
    \        //    (n - 1) * (n - 2) * (n - 3) * ... * 1\n        //\n        // This\
    \ is because the sum of the differences is given by the following formula:\n \
    \       //\n        //    (1 - a) + (", "        // This is a simple problem that\
    \ can be solved with a simple algorithm.\n        // The algorithm is as follows:\n\
    \        // 1.  Sort the cars by their starting position.\n        // 2.  For\
    \ each car, check if it collides with any of the cars that are\n        //   \
    \  already in the list.  If it does, increment the collision count.\n        //\
    \     If it doesn't, add it to the list.\n        // 3.  Return the collision\
    \ count.\n        // The following code implements this algorithm.\n        var\
    \ collisionCount = 0L\n        var cars = new ArrayBuffer[Long]\n        for (i\
    \ <- 1 to n.toInt) {\n            var car = (i.toLong * n) % (2 * n)\n       \
    \     if (car > n) car = 2 * n - car\n            var j = 0\n            while\
    \ (j < cars.length && cars(j) < car) j += 1\n            if (j < cars.length)\
    \ collisionCount += 1\n            cars.insert(j, car)\n        }\n        collisionCount",
  "        // The idea is to sort the cars by their starting position.\n        //\
    \ Then, we can iterate through the cars, and for each car,\n        // we can\
    \ find the number of cars that are on the other side\n        // of the road that\
    \ are closer to the current car than the current car is to the other side of the\
    \ road.\n        // This is the number of collisions that the current car will\
    \ have.\n        // We add this number to the total number of collisions.\n  \
    \      // The time complexity is O(n log n).\n        // The space complexity\
    \ is O(n).\n        val cars = Array.fill(2 * n.toInt)(0)\n        for (i <- 0\
    \ until n.toInt) {\n            cars(i) = i + 1\n            cars(i + n.toInt)\
    \ = -(i + 1)\n        }\n        val sortedCars = cars.sorted\n        var collisions\
    \ = 0L\n        for (i <- 0 until 2 * n.toInt) {\n            val car = sortedCars(i)\n\
    \            val carPos = abs(car)\n            val otherSide = if (car > 0) -1\
    \ else 1\n            var j = i + 1\n            while (j < 2 * n.toInt && abs(sortedCars(j))\
    \ < carPos) {\n                if (sortedCars(j) * otherSide > 0) collisions +=\
    \ 1\n                j += 1\n            }\n        }\n        collisions", " \
    \       // We can assume that the cars are numbered from 1 to n.\n        // We\
    \ can also assume that the cars are ordered by their initial positions.\n    \
    \    // In other words, car 1 is the leftmost car, car 2 is the second leftmost\
    \ car, etc.\n        // Similarly, car n is the rightmost car, car n-1 is the\
    \ second rightmost car, etc.\n        // We can also assume that the cars are\
    \ ordered by their speeds.\n        // In other words, car 1 is the fastest car,\
    \ car 2 is the second fastest car, etc.\n        // Similarly, car n is the slowest\
    \ car, car n-1 is the second slowest car, etc.\n        // We can also assume\
    \ that the cars are ordered by their directions.\n        // In other words, car\
    \ 1 is the leftmost car moving left to right, car 2 is the second leftmost car\
    \ moving left to right, etc.\n        // Similarly, car n is the rightmost car\
    \ moving right to left, car n-1 is the second rightmost car moving right to left,\
    \ etc.\n        // We can also assume that the cars are ordered by their initial\
    \ positions.\n        // In other words, car 1 is the leftmost car, car 2 is the\
    \ second leftmost car, etc.\n        // Similarly, car n is the rightmost car,\
    \ car n-1 is the second rightmost car, etc.\n        // We can also assume that\
    \ the cars are ordered by their speeds.\n        // In other words, car 1 is the\
    \ fastest car, car 2 is the second fastest car, etc.\n        // Similarly, car\
    \ n is the slowest car, car n-1 is the second slowest car, etc.\n        // We\
    \ can also assume that the cars are ordered by their directions.\n        // In\
    \ other words, car 1 is the leftmost car moving left to right, car 2 is the second\
    \ leftmost car moving left to right, etc.\n        // Similarly, car n is the\
    \ rightmost car moving right to left, car n-1 is the second rightmost car moving\
    \ right to left, etc.\n        // We can also assume that the cars are ordered\
    \ by their initial positions.\n        // In other words, car 1 is the leftmost\
    \ car, car 2 is the second leftmost car, etc.\n        // Similarly, car n is\
    \ the rightmost car, car n", "        // The idea is to sort the cars by their\
    \ starting positions.\n        // Then, we can just count the number of cars that\
    \ are moving left to right\n        // that are to the left of a car that's moving\
    \ right to left.\n        // This is equivalent to counting the number of inversions\
    \ in the array.\n        // The number of inversions is O(n log n).\n        val\
    \ leftToRight = Array.fill(n.toInt)(scala.util.Random.nextInt(n.toInt))\n    \
    \    val rightToLeft = Array.fill(n.toInt)(scala.util.Random.nextInt(n.toInt))\n\
    \        val sortedLeftToRight = leftToRight.sorted\n        val sortedRightToLeft\
    \ = rightToLeft.sorted\n        var count = 0L\n        for (i <- 0 until n.toInt)\
    \ {\n            val index = sortedRightToLeft(i.toInt)\n            val left\
    \ = sortedLeftToRight.indexWhere(_ >= index)\n            if (left != -1) count\
    \ += left\n        }\n        count", "        // We can solve this problem by\
    \ using a sweep line algorithm.\n        // The sweep line starts at the leftmost\
    \ point of the road.\n        // We keep track of the cars that are currently\
    \ on the road.\n        // We keep track of the cars that are currently on the\
    \ road by using a heap.\n        // The heap is sorted by the x-coordinate of\
    \ the car.\n        // The heap is a min-heap.\n        // The heap contains the\
    \ cars that are currently on the road.\n        // The heap contains the cars\
    \ that are currently on the road, and the cars that are\n        // about to enter\
    \ the road.\n        // The heap contains the cars that are currently on the road,\
    \ and the cars that are\n        // about to enter the road, and the cars that\
    \ are about to leave the road.\n        // The heap contains the cars that are\
    \ currently on the road, and the cars that are\n        // about to enter the\
    \ road, and the cars that are about to leave the road, and the cars\n        //\
    \ that are about to collide.\n        // The heap contains the cars that are currently\
    \ on the road, and the cars that are\n        // about to enter the road, and\
    \ the cars that are about to leave the road, and the cars\n        // that are\
    \ about to collide, and the cars that are about to collide with the cars that\n\
    \        // are about to collide.\n        // The heap contains the cars that\
    \ are currently on the road, and the cars that are\n        // about to enter\
    \ the road, and the cars that are about to leave the road, and the cars\n    \
    \    // that are about to collide, and the cars that are about to collide with\
    \ the cars that\n        // are about to collide, and the cars that are about\
    \ to collide with the cars that are\n        // about to collide with the cars\
    \ that are about to collide.\n        // The heap contains the cars that are currently\
    \ on the road, and the cars that are\n        // about to enter the road, and\
    \ the cars that are about to leave the road, and the cars\n        // that are\
    \ about to collide, and the cars that are about to collide with the cars that\n\
    \        // are about to collide, and the cars that are about to collide with\
    \ the cars that are\n        // about to collide with the cars that are about\
    \ to collide, and the cars that are about\n       ", "        // This is a classic\
    \ problem in combinatorics.\n        // The answer is n * (n - 1) / 2.\n     \
    \   // The proof is simple:\n        // Let's say that the left-to-right cars\
    \ are numbered 1 to n, and the right-to-left cars\n        // are numbered 1 to\
    \ n.  The number of collisions is the number of pairs of cars that\n        //\
    \ collide.  This is the number of pairs of cars that are in the same position\
    \ at the same time.\n        // The number of pairs of cars that are in the same\
    \ position at the same time is the number of\n        // pairs of cars that start\
    \ out in the same position.  This is the number of pairs of cars that\n      \
    \  // start out in the same position, which is n * (n - 1) / 2.\n        n * (n\
    \ - 1) / 2", "        // The idea is to sort the cars by their starting positions.\n\
    \        // Then, we can use a sweep line algorithm to count the number of collisions.\n\
    \        // The sweep line algorithm is as follows:\n        // 1.  We start with\
    \ the leftmost car.  We count the number of cars that are\n        //     to the\
    \ right of it.  This is the number of collisions that the leftmost\n        //\
    \     car will have.\n        // 2.  We move the sweep line to the right.  We\
    \ count the number of cars that\n        //     are to the right of it.  This\
    \ is the number of collisions that the next\n        //     car will have.\n \
    \       // 3.  We repeat step 2 until we reach the rightmost car.\n        //\
    \ 4.  We sum up the number of collisions for each car.\n        // The time complexity\
    \ is O(n log n).\n        val cars = new Array[Long](2 * n.toInt)\n        for\
    \ (i <- 0 until n.toInt) {\n            cars(i) = i + 1\n            cars(i +\
    \ n.toInt) = -(i + 1)\n        }\n        val sortedCars = cars.sorted\n     \
    \   var numCollisions = 0L\n        var numCarsToRight = 0\n        for (i <-\
    \ 0 until 2 * n.toInt) {\n            if (sortedCars(i) > 0) {\n             \
    \   numCollisions += numCarsToRight\n                numCarsToRight += 1\n   \
    \         } else {\n                numCarsToRight -= 1\n            }\n     \
    \   }\n        numCollisions", "        // This function returns the number of\
    \ collisions between the cars moving left to right\n        // and the cars moving\
    \ right to left.\n        def carRaceCollisionHelper(n : Long, leftToRight : List[Long],\
    \ rightToLeft : List[Long]) : Long = {\n            if (n == 0) 0\n          \
    \  else {\n                val leftToRightHead = leftToRight.head\n          \
    \      val rightToLeftHead = rightToLeft.head\n                if (leftToRightHead\
    \ < rightToLeftHead) carRaceCollisionHelper(n - 1, leftToRight.tail, rightToLeft)\n\
    \                else carRaceCollisionHelper(n - 1, leftToRight.tail, rightToLeft.tail)\
    \ + 1\n            }\n        }\n        carRaceCollisionHelper(n, (1 to n.toInt).toList,\
    \ (n to 1 by -1).toList)", "        // The idea is to sort the cars by their starting\
    \ position.\n        // Then, we can simulate the race by iterating through the\
    \ cars\n        // and checking if the current car collides with any of the cars\n\
    \        // that are ahead of it.\n        // The time complexity is O(n log n)\
    \ because of the sorting.\n        // The space complexity is O(n) because of\
    \ the sorting.\n        val cars = Array.fill(n.toInt)((Random.nextInt(n.toInt),\
    \ Random.nextInt(n.toInt)))\n        val sortedCars = cars.sortBy(_._1)\n    \
    \    var collisions = 0\n        for (i <- 0 until n.toInt) {\n            val\
    \ car = sortedCars(i)\n            for (j <- i + 1 until n.toInt) {\n        \
    \        val otherCar = sortedCars(j)\n                if (car._2 < otherCar._2)\
    \ collisions += 1\n            }\n        }\n        collisions", "        //\
    \ The cars are numbered from 1 to n.  The cars that are moving left to right\n\
    \        // are numbered from 1 to n, and the cars that are moving right to left\
    \ are\n        // numbered from n to 1.\n        // We will assume that the cars\
    \ are moving at unit speed.  The cars that are\n        // moving left to right\
    \ will be called \"positive cars\", and the cars that are\n        // moving right\
    \ to left will be called \"negative cars\".\n        // The positive cars will\
    \ be numbered from 1 to n, and the negative cars will\n        // be numbered\
    \ from -n to -1.\n        // The cars will be sorted in the order of their arrival\
    \ time at the origin.\n        // The positive cars will be sorted in the order\
    \ of their arrival time at the origin,\n        // and the negative cars will\
    \ be sorted in the order of their arrival time at the origin.\n        // The\
    \ positive cars will be sorted in the order of their arrival time at the origin,\n\
    \        // and the negative cars will be sorted in the order of their arrival\
    \ time at the origin.\n        // The positive cars will be sorted in the order\
    \ of their arrival time at the origin,\n        // and the negative cars will\
    \ be sorted in the order of their arrival time at the origin.\n        // The\
    \ positive cars will be sorted in the order of their arrival time at the origin,\n\
    \        // and the negative cars will be sorted in the order of their arrival\
    \ time at the origin.\n        // The positive cars will be sorted in the order\
    \ of their arrival time at the origin,\n        // and the negative cars will\
    \ be sorted in the order of their arrival time at the origin.\n        // The\
    \ positive cars will be sorted in the order of their arrival time at the origin,\n\
    \        // and the negative cars will be sorted in the order of their arrival\
    \ time at the origin.\n        // The positive cars will be sorted in the order\
    \ of their arrival time at the origin,\n        // and the negative cars will\
    \ be sorted in the order of their arrival time at the origin.\n        // The\
    \ positive cars will be sorted in the order of their arrival time at the origin,\n\
    \        // and the negative cars will be sorted in the order of their arrival\
    \ time at the origin.\n        // The positive cars will be sorted in the order\
    \ of their arrival time at the origin,\n        // and the negative cars will\
    \ be sorted in", "        // This is a very simple problem.  The cars that are\
    \ moving left to right\n        // are numbered 1 to n.  The cars that are moving\
    \ right to left are numbered\n        // n+1 to 2n.  The cars that are moving\
    \ left to right are at positions\n        // 1, 2, 3, ..., n.  The cars that are\
    \ moving right to left are at positions\n        // 2n, 2n-1, 2n-2, ..., n+1.\n\
    \        // The cars that are moving left to right will collide with the cars\
    \ that are\n        // moving right to left in the following order:\n        //\
    \ 1 with 2n, 2 with 2n-1, 3 with 2n-2, ..., n with n+1.\n        // The number\
    \ of collisions is therefore n/2.\n        n / 2", "        // This is a very\
    \ simple problem.  The cars that are moving left to right\n        // are numbered\
    \ from 0 to n - 1.  The cars that are moving right to left\n        // are numbered\
    \ from n to 2n - 1.  The cars that are moving left to right\n        // are at\
    \ positions 0, 1, 2, ..., n - 1.  The cars that are moving right to left\n   \
    \     // are at positions n, n - 1, n - 2, ..., 1.  The cars that are moving left\
    \ to right\n        // are moving at speeds 1, 1, 1, ..., 1.  The cars that are\
    \ moving right to left\n        // are moving at speeds -1, -1, -1, ..., -1. \
    \ The cars that are moving left to right\n        // are at positions 0, 1, 2,\
    \ ..., n - 1.  The cars that are moving right to left\n        // are at positions\
    \ n, n - 1, n - 2, ..., 1.  The cars that are moving left to right\n        //\
    \ are moving at speeds 1, 1, 1, ..., 1.  The cars that are moving right to left\n\
    \        // are moving at speeds -1, -1, -1, ..., -1.  The cars that are moving\
    \ left to right\n        // are at positions 0, 1, 2, ..., n - 1.  The cars that\
    \ are moving right to left\n        // are at positions n, n - 1, n - 2, ...,\
    \ 1.  The cars that are moving left to right\n        // are moving at speeds\
    \ 1, 1, 1, ..., 1.  The cars that are moving right to left\n        // are moving\
    \ at speeds -1, -1, -1, ..., -1.  The cars that are moving left to right\n   \
    \     // are at positions 0, 1, 2, ..., n - 1.  The cars that are moving right\
    \ to left\n        // are at positions n, n - 1, n - 2, ..., 1.  The cars that\
    \ are moving left to right\n        // are moving at speeds 1, 1, 1, ..., 1. \
    \ The cars that are moving right to left\n        // are moving at speeds -1,\
    \ -1, -1, ..., -1.  The cars that are moving left to right\n       ", "      \
    \  // The cars are numbered from 0 to n-1.\n        // The cars moving left to\
    \ right are numbered from 0 to n-1.\n        // The cars moving right to left\
    \ are numbered from n-1 to 0.\n        // The cars moving left to right are at\
    \ positions x_0, x_1, ..., x_{n-1}.\n        // The cars moving right to left\
    \ are at positions y_0, y_1, ..., y_{n-1}.\n        // The cars move at the same\
    \ speed.\n        // The cars are infinitely sturdy and strong.\n        // The\
    \ cars are infinitely long.\n        // The cars are infinitely thin.\n      \
    \  // The cars are infinitely wide.\n        // The cars are infinitely tall.\n\
    \        // The cars are infinitely heavy.\n        // The cars are infinitely\
    \ light.\n        // The cars are infinitely strong.\n        // The cars are\
    \ infinitely sturdy.\n        // The cars are infinitely fast.\n        // The\
    \ cars are infinitely slow.\n        // The cars are infinitely fast.\n      \
    \  // The cars are infinitely slow.\n        // The cars are infinitely fast.\n\
    \        // The cars are infinitely slow.\n        // The cars are infinitely\
    \ fast.\n        // The cars are infinitely slow.\n        // The cars are infinitely\
    \ fast.\n        // The cars are infinitely slow.\n        // The cars are infinitely\
    \ fast.\n        // The cars are infinitely slow.\n        // The cars are infinitely\
    \ fast.\n        // The cars are infinitely slow.\n        // The cars are infinitely\
    \ fast.\n        // The cars are infinitely slow.\n        // The cars are infinitely\
    \ fast.\n        // The cars are infinitely slow.\n        // The cars are infinitely\
    \ fast.\n        // The cars are infinitely slow.\n        // The cars are infinitely\
    \ fast.\n        // The cars are infinitely slow.\n        // The cars are infinitely\
    \ fast.\n        // The cars are infinitely slow.\n        // The cars are infinitely\
    \ fast.\n        // The cars are infinitely slow.\n        // The cars are infinitely\
    \ fast.\n        // The cars are infinitely slow.\n        // The cars are infinitely\
    \ fast.\n        // The cars are infinitely slow.\n        // The cars are infinitely\
    \ fast.\n        // The cars are infinitely slow.\n        // The cars are infinitely\
    \ fast.\n        // The cars are infinitely slow.\n        // The cars are", " \
    \       // The idea is to sort the cars by their starting position.\n        //\
    \ Then, we can use a sweep line algorithm to count the number of collisions.\n\
    \        // The sweep line algorithm is a general algorithm for counting the number\
    \ of\n        // intersections between a set of lines.\n        // In this case,\
    \ the lines are the trajectories of the cars.\n        // The sweep line algorithm\
    \ works by sweeping a line from left to right.\n        // As the sweep line sweeps,\
    \ it keeps track of the number of lines that intersect\n        // the sweep line.\
    \  When the sweep line passes a line, it updates the number of\n        // lines\
    \ that intersect the sweep line.\n        // In this case, the sweep line starts\
    \ at the leftmost car.\n        // The sweep line sweeps right until it reaches\
    \ the rightmost car.\n        // The number of lines that intersect the sweep\
    \ line is the number of cars that\n        // are moving right to left.\n    \
    \    // When the sweep line passes a car, it updates the number of cars that are\
    \ moving\n        // right to left.\n        // The number of collisions is the\
    \ number of times the sweep line passes a car\n        // multiplied by the number\
    \ of cars that are moving right to left.\n        // This is because each car\
    \ that's moving right to left will collide with each car\n        // that's moving\
    \ left to right.\n        // The number of cars that are moving right to left\
    \ is the number of cars that are\n        // to the right of the sweep line.\n\
    \        // The number of cars that are moving left to right is the number of\
    \ cars that are\n        // to the left of the sweep line.\n        // The number\
    \ of collisions is the number of cars that are to the right of the sweep\n   \
    \     // line multiplied by the number of cars that are to the left of the sweep\
    \ line.\n        // The number of cars that are to the right of the sweep line\
    \ is the number of cars\n        // that are moving right to left.\n        //\
    \ The number of cars that are to the left of the sweep line is the number of cars\n\
    \        // that are moving left to right.\n        // The number of collisions\
    \ is the number of cars that are moving right to left\n        // multiplied by\
    \ the number of cars that are moving left to right.\n        // The number of\
    \ cars that are moving right to left is the number of lines that\n", "       \
    \ val leftToRight = new Array[Long](n.toInt)\n        val rightToLeft = new Array[Long](n.toInt)\n\
    \        for (i <- 0 until n.toInt) {\n            leftToRight(i) = i\n      \
    \      rightToLeft(i) = n - i - 1\n        }\n        val leftToRightSet = leftToRight.toSet\n\
    \        val rightToLeftSet = rightToLeft.toSet\n        leftToRightSet.intersect(rightToLeftSet).size",
  "        // The idea is to use a sweep line algorithm.  We will sweep from left\
    \ to right.\n        // We will maintain a set of cars that are moving left to\
    \ right, and a set of cars\n        // that are moving right to left.  As we sweep,\
    \ we will check for collisions.\n        // We will use a balanced binary search\
    \ tree to maintain the set of cars.\n        // The key of the tree will be the\
    \ position of the car.\n        // The value of the tree will be the speed of\
    \ the car.\n        // We will use a positive speed for cars moving left to right,\
    \ and a negative speed\n        // for cars moving right to left.\n        //\
    \ We will maintain a variable called \"time\".  Initially, time = 0.\n       \
    \ // We will maintain a variable called \"position\".  Initially, position = 0.\n\
    \        // We will maintain a variable called \"collisionCount\".  Initially,\
    \ collisionCount = 0.\n        var time = 0\n        var position = 0\n      \
    \  var collisionCount = 0\n        // We will maintain a balanced binary search\
    \ tree called \"leftToRight\".\n        // Initially, leftToRight = empty.\n \
    \       var leftToRight = new TreeMap[Long, Long]\n        // We will maintain\
    \ a balanced binary search tree called \"rightToLeft\".\n        // Initially,\
    \ rightToLeft = empty.\n        var rightToLeft = new TreeMap[Long, Long]\n  \
    \      // We will maintain a variable called \"leftToRightCount\".  Initially,\
    \ leftToRightCount = 0.\n        var leftToRightCount = 0\n        // We will\
    \ maintain a variable called \"rightToLeftCount\".  Initially, rightToLeftCount\
    \ = 0.\n        var rightToLeftCount = 0\n        // We will maintain a variable\
    \ called \"leftToRightIndex\".  Initially, leftToRightIndex = 0.\n        var\
    \ leftToRightIndex = 0\n        // We will maintain a variable called \"rightToLeftIndex\"\
    .  Initially, rightToLeftIndex = 0.\n        var rightToLeftIndex = 0\n      \
    \  // We will maintain a variable called \"leftToRightSpeed\".  Initially, leftToRightSpeed\
    \ = 0.\n        var leftToRightSpeed = 0\n        // We will maintain a variable\
    \ called \"rightToLeftSpeed\".  Initially, rightToLeftSpeed = 0.\n        var\
    \ rightToLeftSpeed", "        // The first car that's moving left to right will\
    \ collide with the nth car that's moving\n        // right to left.  The second\
    \ car that's moving left to right will collide with the\n        // (n - 1)th\
    \ car that's moving right to left.  The third car that's moving left to right\n\
    \        // will collide with the (n - 2)th car that's moving right to left. \
    \ And so on.\n        // So the number of collisions is the sum of the first n\
    \ natural numbers.\n        n * (n + 1) / 2", "        // The cars that are moving\
    \ left to right are numbered 0 to n - 1.\n        // The cars that are moving\
    \ right to left are numbered n to 2n - 1.\n        // The car that's moving left\
    \ to right with number i is at position i at time 0.\n        // The car that's\
    \ moving right to left with number i is at position 2n - 1 - i at time 0.\n  \
    \      // The car that's moving left to right with number i is at position i +\
    \ t at time t.\n        // The car that's moving right to left with number i is\
    \ at position 2n - 1 - i - t at time t.\n        // The car that's moving left\
    \ to right with number i collides with the car that's moving right to left\n \
    \       // with number j if and only if i + t = 2n - 1 - j - t.\n        // The\
    \ car that's moving left to right with number i collides with the car that's moving\
    \ right to left\n        // with number j if and only if i + j = 2n - 1.\n   \
    \     // The car that's moving left to right with number i collides with the car\
    \ that's moving right to left\n        // with number j if and only if i + j <\
    \ 2n.\n        // The car that's moving left to right with number i collides with\
    \ the car that's moving right to left\n        // with number j if and only if\
    \ i < j.\n        // The car that's moving left to right with number i collides\
    \ with the car that's moving right to left\n        // with number j if and only\
    \ if i < j and i + j < 2n.\n        // The car that's moving left to right with\
    \ number i collides with the car that's moving right to left\n        // with\
    \ number j if and only if i < j and i + j < 2n and i < n and j < n.\n        //\
    \ The car that's moving left to right with number i collides with the car that's\
    \ moving right to left\n        // with number j if and only if i < j and i +\
    \ j < 2n and i < n and j < n and i < j - i.\n        // The car that's moving\
    \ left to right with number i collides with the car that's moving right to left\n\
    \        // with number j if and only if i < j", "        val left = new Array[Long](n.toInt)\n\
    \        val right = new Array[Long](n.toInt)\n        for (i <- 0 until n.toInt)\
    \ {\n            left(i) = i\n            right(i) = n - i - 1\n        }\n  \
    \      var count = 0\n        for (i <- 0 until n.toInt) {\n            for (j\
    \ <- 0 until n.toInt) {\n                if (left(i) > right(j)) count += 1\n\
    \            }\n        }\n        count", "        // This is a very simple problem.\
    \  We can solve it by brute force.\n        // We can simulate the movement of\
    \ the cars.  We can start with the first\n        // car moving left to right\
    \ and the first car moving right to left.\n        // We can then move the first\
    \ car moving left to right by 1 unit.  If the\n        // first car moving left\
    \ to right collides with the first car moving right to left,\n        // we can\
    \ increment the number of collisions.  We can then move the first car moving\n\
    \        // right to left by 1 unit.  If the first car moving right to left collides\
    \ with the\n        // first car moving left to right, we can increment the number\
    \ of collisions.\n        // We can then move the second car moving left to right\
    \ by 1 unit.  If the\n        // second car moving left to right collides with\
    \ the second car moving right to left,\n        // we can increment the number\
    \ of collisions.  We can then move the second car moving\n        // right to\
    \ left by 1 unit.  If the second car moving right to left collides with the\n\
    \        // second car moving left to right, we can increment the number of collisions.\n\
    \        // We can then move the third car moving left to right by 1 unit.  If\
    \ the\n        // third car moving left to right collides with the third car moving\
    \ right to left,\n        // we can increment the number of collisions.  We can\
    \ then move the third car moving\n        // right to left by 1 unit.  If the\
    \ third car moving right to left collides with the\n        // third car moving\
    \ left to right, we can increment the number of collisions.\n        // We can\
    \ then move the fourth car moving left to right by 1 unit.  If the\n        //\
    \ fourth car moving left to right collides with the fourth car moving right to\
    \ left,\n        // we can increment the number of collisions.  We can then move\
    \ the fourth car moving\n        // right to left by 1 unit.  If the fourth car\
    \ moving right to left collides with the\n        // fourth car moving left to\
    \ right, we can increment the number of collisions.\n        // We can then move\
    \ the fifth car moving left to right by 1 unit.  If the\n        // fifth car\
    \ moving left to right collides with the fifth car moving right to left,\n   \
    \     // we can increment the number", "        // This function returns the number\
    \ of collisions between cars that are\n        // moving left to right and cars\
    \ that are moving right to left.\n        // The cars are numbered from 1 to n.\n\
    \        // The cars that are moving left to right are numbered from 1 to n.\n\
    \        // The cars that are moving right to left are numbered from n to 1.\n\
    \        // The cars that are moving left to right are at positions x1, x2, ...,\
    \ xn.\n        // The cars that are moving right to left are at positions y1,\
    \ y2, ..., yn.\n        // The cars that are moving left to right are moving at\
    \ speeds s1, s2, ..., sn.\n        // The cars that are moving right to left are\
    \ moving at speeds t1, t2, ..., tn.\n        // The cars that are moving left\
    \ to right are moving at speeds s1, s2, ..., sn.\n        // The cars that are\
    \ moving right to left are moving at speeds t1, t2, ..., tn.\n        // The cars\
    \ that are moving left to right are moving at speeds s1, s2, ..., sn.\n      \
    \  // The cars that are moving right to left are moving at speeds t1, t2, ...,\
    \ tn.\n        // The cars that are moving left to right are moving at speeds\
    \ s1, s2, ..., sn.\n        // The cars that are moving right to left are moving\
    \ at speeds t1, t2, ..., tn.\n        // The cars that are moving left to right\
    \ are moving at speeds s1, s2, ..., sn.\n        // The cars that are moving right\
    \ to left are moving at speeds t1, t2, ..., tn.\n        // The cars that are\
    \ moving left to right are moving at speeds s1, s2, ..., sn.\n        // The cars\
    \ that are moving right to left are moving at speeds t1, t2, ..., tn.\n      \
    \  // The cars that are moving left to right are moving at speeds s1, s2, ...,\
    \ sn.\n        // The cars that are moving right to left are moving at speeds\
    \ t1, t2, ..., tn.\n        // The cars that are moving left to right are moving\
    \ at speeds s1, s2, ..., sn.\n       ", "        // The idea is to sort the cars\
    \ by their starting position.  Then, we can\n        // just iterate through the\
    \ cars and count the number of collisions.\n        // The time complexity is\
    \ O(n log n).\n        val leftToRight = new Array[Long](n.toInt)\n        val\
    \ rightToLeft = new Array[Long](n.toInt)\n        for (i <- 0 until n.toInt) {\n\
    \            leftToRight(i) = i\n            rightToLeft(i) = n - 1 - i\n    \
    \    }\n        val sortedLeftToRight = leftToRight.sorted\n        val sortedRightToLeft\
    \ = rightToLeft.sorted\n        var count = 0L\n        for (i <- 0 until n.toInt)\
    \ {\n            if (sortedLeftToRight(i) > sortedRightToLeft(i)) count += 1\n\
    \        }\n        count", "        // This is a very simple problem.  We can\
    \ solve it by brute force.\n        // We can simulate the cars' movement by a\
    \ list of n numbers, where\n        // each number represents the position of\
    \ a car.  We can then sort\n        // the list, and count the number of pairs\
    \ of cars that are in the\n        // same position.  This is O(n log n).\n  \
    \      val cars = Array.fill(n.toInt)(0)\n        for (i <- 0 until n.toInt) {\n\
    \            cars(i) = i - n + 1\n        }\n        cars.sorted.sliding(2).count(x\
    \ => x(0) == x(1))", "        // The idea is to sort the cars by their starting\
    \ position.\n        // Then, we can just count the number of cars that are moving\
    \ in the same direction\n        // and are starting at the same position.\n \
    \       // We can do this by counting the number of cars that are moving in the\
    \ same direction\n        // and are starting at the same position.\n        //\
    \ We can do this by counting the number of cars that are moving in the same direction\n\
    \        // and are starting at the same position.\n        // We can do this\
    \ by counting the number of cars that are moving in the same direction\n     \
    \   // and are starting at the same position.\n        // We can do this by counting\
    \ the number of cars that are moving in the same direction\n        // and are\
    \ starting at the same position.\n        // We can do this by counting the number\
    \ of cars that are moving in the same direction\n        // and are starting at\
    \ the same position.\n        // We can do this by counting the number of cars\
    \ that are moving in the same direction\n        // and are starting at the same\
    \ position.\n        // We can do this by counting the number of cars that are\
    \ moving in the same direction\n        // and are starting at the same position.\n\
    \        // We can do this by counting the number of cars that are moving in the\
    \ same direction\n        // and are starting at the same position.\n        //\
    \ We can do this by counting the number of cars that are moving in the same direction\n\
    \        // and are starting at the same position.\n        // We can do this\
    \ by counting the number of cars that are moving in the same direction\n     \
    \   // and are starting at the same position.\n        // We can do this by counting\
    \ the number of cars that are moving in the same direction\n        // and are\
    \ starting at the same position.\n        // We can do this by counting the number\
    \ of cars that are moving in the same direction\n        // and are starting at\
    \ the same position.\n        // We can do this by counting the number of cars\
    \ that are moving in the same direction\n        // and are starting at the same\
    \ position.\n        // We can do this by counting the number of cars that are\
    \ moving in the same direction\n        // and are starting at the same position.\n\
    \        // We can do this by counting the number of cars that are moving in the\
    \ same direction\n        // and are starting at the same position.\n", "    \
    \    // The idea is to use the fact that the cars are infinitely strong and sturdy.\n\
    \        // We can imagine that the cars are moving in a circle.  The cars that\
    \ are moving\n        // left to right are moving clockwise, and the cars that\
    \ are moving right to left\n        // are moving counterclockwise.  The cars\
    \ that are moving left to right are\n        // numbered 1, 2, 3, ..., n, and\
    \ the cars that are moving right to left are\n        // numbered n+1, n+2, n+3,\
    \ ..., 2n.  The cars are initially arranged in a circle\n        // with the cars\
    \ numbered 1, 2, 3, ..., n, n+1, n+2, ..., 2n in that order.\n        // We can\
    \ imagine that the cars are moving in a circle with a radius of 1.\n        //\
    \ We can imagine that the cars are moving in a circle with a radius of 1.\n  \
    \      // The cars that are moving left to right are moving clockwise, and the\
    \ cars\n        // that are moving right to left are moving counterclockwise.\n\
    \        // The cars that are moving left to right are moving clockwise, and the\
    \ cars\n        // that are moving right to left are moving counterclockwise.\n\
    \        // The cars that are moving left to right are moving clockwise, and the\
    \ cars\n        // that are moving right to left are moving counterclockwise.\n\
    \        // The cars that are moving left to right are moving clockwise, and the\
    \ cars\n        // that are moving right to left are moving counterclockwise.\n\
    \        // The cars that are moving left to right are moving clockwise, and the\
    \ cars\n        // that are moving right to left are moving counterclockwise.\n\
    \        // The cars that are moving left to right are moving clockwise, and the\
    \ cars\n        // that are moving right to left are moving counterclockwise.\n\
    \        // The cars that are moving left to right are moving clockwise, and the\
    \ cars\n        // that are moving right to left are moving counterclockwise.\n\
    \        // The cars that are moving left to right are moving clockwise, and the\
    \ cars\n        // that are moving right to left are moving counterclockwise.\n\
    \        // The cars that are moving left to right are moving clockwise, and the\
    \ cars\n        // that are moving right to left are moving counterclockwise.",
  "        // This is a classic problem in discrete mathematics.\n        // The solution\
    \ is to realize that the number of collisions is the same as the number of\n \
    \       // inversions in the permutation of the numbers 1 to n.\n        // The\
    \ number of inversions in a permutation is the number of pairs of numbers that\
    \ are out of order.\n        // For example, the permutation (1, 2, 3, 4, 5) has\
    \ no inversions, while the permutation (5, 4, 3, 2, 1)\n        // has 10 inversions.\n\
    \        // The number of inversions in a permutation is the same as the number\
    \ of collisions in the car race.\n        // For example, the permutation (1,\
    \ 2, 3, 4, 5) corresponds to the car race where the left-to-right cars\n     \
    \   // are numbered 1 to 5, and the right-to-left cars are also numbered 1 to\
    \ 5.  There are no collisions.\n        // The permutation (5, 4, 3, 2, 1) corresponds\
    \ to the car race where the left-to-right cars are numbered\n        // 1 to 5,\
    \ and the right-to-left cars are numbered 5 to 1.  There are 10 collisions.\n\
    \        // The number of inversions in a permutation is the same as the number\
    \ of collisions in the car race.\n        // The number of inversions in a permutation\
    \ is equal to the sum of the number of inversions in the\n        // left half\
    \ of the permutation and the number of inversions in the right half of the permutation.\n\
    \        // This is the basis of the divide-and-conquer algorithm.\n        def\
    \ inversions(permutation : List[Long]) : Long = {\n            if (permutation.length\
    \ <= 1) 0\n            else {\n                val mid = permutation.length /\
    \ 2\n                val left = permutation.slice(0, mid)\n                val\
    \ right = permutation.slice(mid, permutation.length)\n                val leftInversions\
    \ = inversions(left)\n                val rightInversions = inversions(right)\n\
    \                val splitInversions = mergeAndCountSplitInversions(left, right)\n\
    \                leftInversions + rightInversions + splitInversions\n        \
    \    }\n        }\n        def mergeAndCountSplitInversions(left : List[Long],\
    \ right", "        // The idea is to sort the cars by their starting position.\n\
    \        // Then, we can just count the number of cars that are moving left to\
    \ right\n        // and are to the left of a car that's moving right to left.\n\
    \        // This is the number of collisions.\n        val cars = new Array[Long](2\
    \ * n.toInt)\n        for (i <- 0 until n.toInt) {\n            cars(i) = i +\
    \ 1\n            cars(i + n.toInt) = -(i + 1)\n        }\n        cars.sortWith(_\
    \ < _)\n        var count = 0\n        for (i <- 0 until 2 * n.toInt) {\n    \
    \        if (cars(i) > 0) {\n                for (j <- i + 1 until 2 * n.toInt)\
    \ {\n                    if (cars(j) < 0) {\n                        count +=\
    \ 1\n                    }\n                }\n            }\n        }\n    \
    \    count", "        // Let's say that the cars are numbered from 1 to n.\n \
    \       // The cars driving left to right are numbered 1 to n.\n        // The\
    \ cars driving right to left are numbered n+1 to 2n.\n        // The car numbered\
    \ i is at position i.\n        // The car numbered i is moving at speed i.\n \
    \       // The car numbered i is moving left to right if i <= n.\n        // The\
    \ car numbered i is moving right to left if i > n.\n        // The car numbered\
    \ i will collide with the car numbered j if i < j and i + j <= 2n.\n        //\
    \ The car numbered i will collide with the car numbered j if i > j and i + j >\
    \ 2n.\n        // The car numbered i will collide with the car numbered j if i\
    \ < j and i + j > 2n.\n        // The car numbered i will collide with the car\
    \ numbered j if i > j and i + j <= 2n.\n        // The car numbered i will collide\
    \ with the car numbered j if i < j and i + j <= 2n.\n        // The car numbered\
    \ i will collide with the car numbered j if i > j and i + j > 2n.\n        //\
    \ The car numbered i will collide with the car numbered j if i < j and i + j >\
    \ 2n.\n        // The car numbered i will collide with the car numbered j if i\
    \ > j and i + j <= 2n.\n        // The car numbered i will collide with the car\
    \ numbered j if i < j and i + j <= 2n.\n        // The car numbered i will collide\
    \ with the car numbered j if i > j and i + j > 2n.\n        // The car numbered\
    \ i will collide with the car numbered j if i < j and i + j > 2n.\n        //\
    \ The car numbered i will collide with the car numbered j if i > j and i + j <=\
    \ 2n.\n        // The car numbered i will collide with the car numbered j if i\
    \ < j and i + j <= 2n.\n        // The car numbered i will collide with the car\
    \ numbered j if i > j and i + j > 2n.\n        // The car numbered i will collide\
    \ with the car numbered j if i < j and i + j > 2n.\n        // The car numbered\
    \ i will collide with the car numbered j", "        // This is a very simple problem.\
    \  The cars that are moving left to right\n        // are numbered 1 to n.  The\
    \ cars that are moving right to left are numbered\n        // n+1 to 2n.  The\
    \ cars that are moving left to right will collide with the cars\n        // that\
    \ are moving right to left if and only if the numbers of the cars are the same.\n\
    \        // So the answer is the number of pairs of numbers that are the same\
    \ in the range\n        // 1 to n.  This is n*(n+1)/2.\n        n * (n + 1) /\
    \ 2", "        // The idea is to sort the cars by their starting positions.\n\
    \        // Then, we can just go through the sorted list and count the number\
    \ of cars\n        // that are moving in the opposite direction.\n        // The\
    \ time complexity is O(n log n)\n        // The space complexity is O(n)\n   \
    \     val cars = Array.fill(2 * n.toInt)(0)\n        for (i <- 0 until n.toInt)\
    \ {\n            cars(i) = i + 1\n            cars(i + n.toInt) = -(i + 1)\n \
    \       }\n        scala.util.Sorting.quickSort(cars)\n        var count = 0\n\
    \        for (i <- 0 until 2 * n.toInt) {\n            if (cars(i) < 0) count\
    \ += 1\n            else count -= 1\n        }\n        count", "        // Assume\
    \ that the cars are numbered from 0 to n - 1.\n        // Assume that the cars\
    \ moving left to right are numbered from 0 to n - 1.\n        // Assume that the\
    \ cars moving right to left are numbered from n - 1 to 0.\n        // Assume that\
    \ the cars moving left to right start at position 0.\n        // Assume that the\
    \ cars moving right to left start at position 2 * n.\n        // Assume that the\
    \ cars move at speed 1.\n        // Assume that the cars moving left to right\
    \ move to the right.\n        // Assume that the cars moving right to left move\
    \ to the left.\n        // Assume that the cars are infinitely sturdy and strong.\n\
    \        // Assume that the cars are perfectly straight.\n        // Assume that\
    \ the road is perfectly straight.\n        // Assume that the road is infinitely\
    \ long.\n        // Assume that the road is a line.\n        // Assume that the\
    \ road is 2-dimensional.\n        // Assume that the road is flat.\n        //\
    \ Assume that the road is Euclidean.\n        // Assume that the road is in the\
    \ Euclidean plane.\n        // Assume that the road is in the Euclidean space.\n\
    \        // Assume that the road is in the Euclidean space of dimension 2.\n \
    \       // Assume that the road is in the Euclidean space of dimension 3.\n  \
    \      // Assume that the road is in the Euclidean space of dimension 4.\n   \
    \     // Assume that the road is in the Euclidean space of dimension 5.\n    \
    \    // Assume that the road is in the Euclidean space of dimension 6.\n     \
    \   // Assume that the road is in the Euclidean space of dimension 7.\n      \
    \  // Assume that the road is in the Euclidean space of dimension 8.\n       \
    \ // Assume that the road is in the Euclidean space of dimension 9.\n        //\
    \ Assume that the road is in the Euclidean space of dimension 10.\n        //\
    \ Assume that the road is in the Euclidean space of dimension 11.\n        //\
    \ Assume that the road is in the Euclidean space of dimension 12.\n        //\
    \ Assume that the road is in the Euclidean space of dimension 13.\n        //\
    \ Assume that the road is in the", "        // This is the number of collisions.\n\
    \        var collisions = 0L\n        // This is the number of cars that have\
    \ been processed.\n        var processed = 0L\n        // This is the number of\
    \ cars that have been processed from the left-to-right set.\n        var processedLeft\
    \ = 0L\n        // This is the number of cars that have been processed from the\
    \ right-to-left set.\n        var processedRight = 0L\n        // This is the\
    \ number of cars that have been processed from the left-to-right set\n       \
    \ // that have collided with a car from the right-to-left set.\n        var collidedLeft\
    \ = 0L\n        // This is the number of cars that have been processed from the\
    \ right-to-left set\n        // that have collided with a car from the left-to-right\
    \ set.\n        var collidedRight = 0L\n        // This is the number of cars\
    \ that have been processed from the left-to-right set\n        // that have not\
    \ collided with a car from the right-to-left set.\n        var notCollidedLeft\
    \ = 0L\n        // This is the number of cars that have been processed from the\
    \ right-to-left set\n        // that have not collided with a car from the left-to-right\
    \ set.\n        var notCollidedRight = 0L\n        // This is the number of cars\
    \ that have been processed from the left-to-right set\n        // that have collided\
    \ with a car from the right-to-left set.\n        var collidedLeftIndex = 0L\n\
    \        // This is the number of cars that have been processed from the right-to-left\
    \ set\n        // that have collided with a car from the left-to-right set.\n\
    \        var collidedRightIndex = 0L\n        // This is the number of cars that\
    \ have been processed from the left-to-right set\n        // that have not collided\
    \ with a car from the right-to-left set.\n        var notCollidedLeftIndex = 0L\n\
    \        // This is the number of cars that have been processed from the right-to-left\
    \ set\n        // that have not collided with a car from the left-to-right set.\n\
    \        var notCollidedRightIndex = 0L\n        // This is the number of cars\
    \ that have been processed from the left-to-right set\n", "        // The idea\
    \ is to use a sweep line algorithm.\n        // We will use a set of events. \
    \ Each event is a tuple (x, y, t), where x is the x-coordinate\n        // of\
    \ the car, y is the y-coordinate of the car, and t is the time of the event.\n\
    \        // The events are sorted by x-coordinate, and then by y-coordinate.\n\
    \        // The events are processed in the order of increasing x-coordinate.\n\
    \        // If the event is a left-to-right car, then we insert the car into a\
    \ set of cars.\n        // If the event is a right-to-left car, then we remove\
    \ the car from the set of cars.\n        // If the event is a left-to-right car,\
    \ then we check if there are any right-to-left cars\n        // that are in the\
    \ set of cars.  If so, then we increment the number of collisions.\n        //\
    \ The time complexity is O(n log n).\n        // The space complexity is O(n).\n\
    \        val events = new Array[(Long, Long, Long)](2 * n.toInt)\n        for\
    \ (i <- 0 until n.toInt) {\n            val x = i.toLong\n            val y =\
    \ i.toLong\n            events(i) = (x, y, 0)\n            events(i + n.toInt)\
    \ = (x, y, 1)\n        }\n        events.sortWith((a, b) => a._1 < b._1 || (a._1\
    \ == b._1 && a._2 < b._2) || (a._1 == b._1 && a._2 == b._2 && a._3 < b._3))\n\
    \        var collisions = 0L\n        val cars = new HashSet[Long]\n        for\
    \ (event <- events) {\n            if (event._3 == 0) {\n                if (cars.contains(event._2))\
    \ collisions += 1\n                cars.add(event._2)\n            } else {\n\
    \                cars.remove(event._2)\n            }\n        }\n        collisions",
  "        // We can solve this problem by first sorting the cars by their starting\
    \ position.\n        // Then, we can iterate through the cars in order, and for\
    \ each car, we can check\n        // how many cars are in front of it.  If the\
    \ car is moving left to right, then\n        // the number of cars in front of\
    \ it is the number of collisions it will have.\n        // If the car is moving\
    \ right to left, then the number of cars in front of it is\n        // the number\
    \ of collisions it will have minus 1.  The reason for this is that\n        //\
    \ the car will collide with the car in front of it, but it will not collide with\n\
    \        // the car behind it.\n        // The total number of collisions is the\
    \ sum of the number of collisions for each car.\n        // The total number of\
    \ collisions is also the sum of the number of cars in front of\n        // each\
    \ car.  So, we can solve this problem by sorting the cars by their starting\n\
    \        // position, and then summing the number of cars in front of each car.\n\
    \        // The number of cars in front of each car is the number of cars to the\
    \ right of\n        // the car.  So, we can solve this problem by sorting the\
    \ cars by their starting\n        // position, and then summing the number of\
    \ cars to the right of each car.\n        // We can solve this problem by sorting\
    \ the cars by their starting position, and\n        // then iterating through\
    \ the cars in order.  For each car, we can find the number\n        // of cars\
    \ to the right of it by using a binary search.  We can do this by using\n    \
    \    // a binary search tree.  We can insert the cars into the binary search tree\
    \ in\n        // order, and then we can iterate through the cars in order.  For\
    \ each car, we can\n        // find the number of cars to the right of it by using\
    \ a binary search.\n        // We can use a binary search tree to insert the cars\
    \ in order, and then we can\n        // iterate through the cars in order.  For\
    \ each car, we can find the number of\n        // cars to the right of it by using\
    \ a binary search.\n        // We can use a binary search tree to insert the cars\
    \ in order, and then we can\n        // iterate through the cars in order", " \
    \       // This function returns the number of collisions between the cars that\
    \ are moving\n        // left to right and the cars that are moving right to left.\n\
    \        // The cars are numbered from 1 to n.  The cars that are moving left\
    \ to right are\n        // numbered from 1 to n.  The cars that are moving right\
    \ to left are numbered from\n        // n to 1.\n        // The cars are initially\
    \ very far from each other.  The cars that are moving left to right\n        //\
    \ are initially at position -1000000000, -1000000000 + 1, -1000000000 + 2, ...,\
    \ -1000000000 + n - 1.\n        // The cars that are moving right to left are\
    \ initially at position 1000000000, 1000000000 - 1,\n        // 1000000000 - 2,\
    \ ..., 1000000000 - n + 1.\n        // The cars that are moving left to right\
    \ move at speed 1.  The cars that are moving right to left\n        // move at\
    \ speed 1.\n        // The function returns the number of collisions.\n      \
    \  def collision(n : Long) : Long = {\n            // The cars that are moving\
    \ left to right are numbered from 1 to n.\n            // The cars that are moving\
    \ right to left are numbered from n to 1.\n            // The cars are initially\
    \ very far from each other.  The cars that are moving left to right\n        \
    \    // are initially at position -1000000000, -1000000000 + 1, -1000000000 +\
    \ 2, ..., -1000000000 + n - 1.\n            // The cars that are moving right\
    \ to left are initially at position 1000000000, 1000000000 - 1,\n            //\
    \ 1000000000 - 2, ..., 1000000000 - n + 1.\n            // The cars that are moving\
    \ left to right move at speed 1.  The cars that are moving right to left\n   \
    \         // move at speed 1.\n            // The function returns the number\
    \ of collisions.\n            def collision(n : Long) : Long = {\n           \
    \     if (n == 1) 0\n                else {\n                    val m = n / 2\n\
    \                    val left = collision(m)\n                    val right =\
    \ collision(n - m)\n                    val mid = m * (n - m)\n              \
    \      left + right + mid\n                }\n            }\n            collision(n)\n\
    \        }\n        collision(n)\n", "        // This is a very simple problem.\
    \  The cars are moving at the same speed, so\n        // the order of the cars\
    \ is preserved.  Therefore, the number of collisions\n        // is simply the\
    \ number of pairs of cars that are in the same position.\n        // The first\
    \ car can be in any of n positions.  The second car can be in any\n        //\
    \ of n - 1 positions.  The third car can be in any of n - 2 positions.\n     \
    \   // ...\n        // The nth car can be in any of 1 position.\n        // Therefore,\
    \ the total number of collisions is\n        // n * (n - 1) * (n - 2) * ... *\
    \ 1 = n!\n        // This is the same as the factorial of n.\n        // However,\
    \ we can't use the factorial function because it's too slow.\n        // We can\
    \ use the fact that n! = n * (n - 1)!\n        // This is a recursive function.\
    \  We can use tail recursion to make it\n        // iterative.\n        def factorial(n\
    \ : Long, acc : Long) : Long = {\n            if (n == 0) acc\n            else\
    \ factorial(n - 1, n * acc)\n        }\n        factorial(n, 1)", "        //\
    \ The idea is to sort the cars by their starting position.\n        // Then, we\
    \ can just iterate through the sorted cars, and count the number of\n        //\
    \ cars that are moving in the opposite direction.\n        // The time complexity\
    \ is O(n log n)\n        val cars = Array.fill(n.toInt)(0)\n        for (i <-\
    \ 0 until n.toInt) {\n            cars(i) = i\n        }\n        val sortedCars\
    \ = cars.sortWith(_ < _)\n        var count = 0\n        for (i <- 0 until n.toInt)\
    \ {\n            if (i % 2 == 0) {\n                // moving left to right\n\
    \                count += sortedCars(i)\n            } else {\n              \
    \  // moving right to left\n                count += (n - 1 - sortedCars(i))\n\
    \            }\n        }\n        count", "        // This is a simple problem.\
    \  We can solve it by sorting the cars by their\n        // starting positions.\
    \  Then, we can go through the cars from left to right,\n        // and for each\
    \ car, we can find the number of cars that are to the left of it\n        // and\
    \ moving right to left.  This is the number of collisions that this car\n    \
    \    // will have.  We can then add this number to the total number of collisions.\n\
    \        // This is O(n log n) time and O(n) space.\n        // We can do better.\
    \  We can use a segment tree to keep track of the number of\n        // cars that\
    \ are to the left of a given car and moving right to left.  This\n        // is\
    \ O(n log n) time and O(n) space.\n        // We can do even better.  We can use\
    \ a Fenwick tree to keep track of the number\n        // of cars that are to the\
    \ left of a given car and moving right to left.  This\n        // is O(n log n)\
    \ time and O(n) space.\n        // We can do even better.  We can use a Fenwick\
    \ tree to keep track of the number\n        // of cars that are to the left of\
    \ a given car and moving right to left.  This\n        // is O(n log n) time and\
    \ O(n) space.\n        // We can do even better.  We can use a Fenwick tree to\
    \ keep track of the number\n        // of cars that are to the left of a given\
    \ car and moving right to left.  This\n        // is O(n log n) time and O(n)\
    \ space.\n        // We can do even better.  We can use a Fenwick tree to keep\
    \ track of the number\n        // of cars that are to the left of a given car\
    \ and moving right to left.  This\n        // is O(n log n) time and O(n) space.\n\
    \        // We can do even better.  We can use a Fenwick tree to keep track of\
    \ the number\n        // of cars that are to the left of a given car and moving\
    \ right to left.  This\n        // is O(n log n) time and O(n) space.\n      \
    \  // We can do even better.  We can use a Fenwick", "        // The key observation\
    \ is that the cars that are moving in the same direction\n        // will never\
    \ collide.  So we can focus on the cars that are moving in opposite directions.\n\
    \        // The cars that are moving in opposite directions are indexed by the\
    \ integers from 1 to n.\n        // The car that's moving left to right is indexed\
    \ by i, and the car that's moving right to left\n        // is indexed by n +\
    \ 1 - i.\n        // The key observation is that the cars that are moving in the\
    \ same direction\n        // will never collide.  So we can focus on the cars\
    \ that are moving in opposite directions.\n        // The cars that are moving\
    \ in opposite directions are indexed by the integers from 1 to n.\n        //\
    \ The car that's moving left to right is indexed by i, and the car that's moving\
    \ right to left\n        // is indexed by n + 1 - i.\n        // The key observation\
    \ is that the cars that are moving in the same direction\n        // will never\
    \ collide.  So we can focus on the cars that are moving in opposite directions.\n\
    \        // The cars that are moving in opposite directions are indexed by the\
    \ integers from 1 to n.\n        // The car that's moving left to right is indexed\
    \ by i, and the car that's moving right to left\n        // is indexed by n +\
    \ 1 - i.\n        // The key observation is that the cars that are moving in the\
    \ same direction\n        // will never collide.  So we can focus on the cars\
    \ that are moving in opposite directions.\n        // The cars that are moving\
    \ in opposite directions are indexed by the integers from 1 to n.\n        //\
    \ The car that's moving left to right is indexed by i, and the car that's moving\
    \ right to left\n        // is indexed by n + 1 - i.\n        // The key observation\
    \ is that the cars that are moving in the same direction\n        // will never\
    \ collide.  So we can focus on the cars that are moving in opposite directions.\n\
    \        // The cars that are moving in opposite directions are indexed by the\
    \ integers from 1 to n.\n        // The car that's moving left to right is indexed\
    \ by i, and the car that's moving right to left\n        // is indexed by n +\
    \ 1 - i.\n        // The key observation is that the cars that are moving in the\
    \ same direction\n        // will never collide.  So we", "        // This is\
    \ a simple greedy algorithm.  We first sort the cars by their starting\n     \
    \   // position.  Then, we iterate through the cars from left to right.  For each\
    \ car,\n        // we check if it collides with any of the cars that are already\
    \ in the list.\n        // If it does, we add it to the list.  If it doesn't,\
    \ we add it to the list and\n        // remove the car that it collides with.\n\
    \        val cars = new ArrayBuffer[Long]\n        for (i <- 1 to n.toInt) {\n\
    \            val car = readLine.toLong\n            val index = cars.indexWhere(x\
    \ => x > car)\n            if (index == -1) cars += car\n            else cars.insert(index,\
    \ car)\n        }\n        var collisions = 0\n        for (i <- 0 until n.toInt)\
    \ {\n            val car = readLine.toLong\n            val index = cars.indexWhere(x\
    \ => x < car)\n            if (index == -1) collisions += 1\n            else\
    \ cars.remove(index)\n        }\n        collisions", "        // This is a very\
    \ simple problem.  We can solve it in O(n) time.\n        // The key observation\
    \ is that the cars that move left to right\n        // are in the same order as\
    \ the cars that move right to left.\n        // Therefore, the number of collisions\
    \ is the number of inversions\n        // in the permutation of the cars that\
    \ move left to right.\n        // We can compute the number of inversions in O(n\
    \ log n) time\n        // using a divide-and-conquer algorithm.\n        //\n\
    \        // The divide-and-conquer algorithm is as follows.\n        // Let's\
    \ say we have a permutation of the numbers 1, 2, ..., n.\n        // We can split\
    \ the permutation into two parts:\n        // the first part contains the numbers\
    \ 1, 2, ..., n/2,\n        // and the second part contains the numbers n/2 + 1,\
    \ ..., n.\n        // We can compute the number of inversions in the first part\n\
    \        // and the number of inversions in the second part.\n        // Then,\
    \ we can compute the number of inversions that cross\n        // the boundary\
    \ between the first part and the second part.\n        // The total number of\
    \ inversions is the sum of these three numbers.\n        //\n        // We can\
    \ compute the number of inversions that cross the boundary\n        // between\
    \ the first part and the second part as follows.\n        // We can sort the first\
    \ part and the second part.\n        // Then, we can merge the two sorted parts.\n\
    \        // The number of inversions that cross the boundary is the number\n \
    \       // of pairs of numbers that are in the first part and the second part\n\
    \        // and are out of order.\n        //\n        // We can compute the number\
    \ of inversions in the first part\n        // and the number of inversions in\
    \ the second part recursively.\n        //\n        // The base case is when the\
    \ permutation contains only one number.\n        // In this case, the number of\
    \ inversions is zero.\n        //\n        // We can implement this algorithm\
    \ in O(n log n) time.\n        //\n        // We can also solve this problem in\
    \ O(n) time.\n        // The key observation is that the number of inversions\n\
    \        // is equal to the", "        // This is the number of collisions.\n\
    \        var collisions = 0L\n        // This is the number of cars that are moving\
    \ left to right.\n        var leftToRight = n\n        // This is the number of\
    \ cars that are moving right to left.\n        var rightToLeft = n\n        //\
    \ This is the number of cars that are moving left to right and have already collided.\n\
    \        var leftToRightCollided = 0L\n        // This is the number of cars that\
    \ are moving right to left and have already collided.\n        var rightToLeftCollided\
    \ = 0L\n        // This is the number of cars that are moving left to right and\
    \ have not yet collided.\n        var leftToRightNotCollided = n\n        // This\
    \ is the number of cars that are moving right to left and have not yet collided.\n\
    \        var rightToLeftNotCollided = n\n        // This is the number of cars\
    \ that are moving left to right and have not yet collided and are in front of\
    \ the cars that are moving right to left.\n        var leftToRightNotCollidedInFront\
    \ = 0L\n        // This is the number of cars that are moving right to left and\
    \ have not yet collided and are in front of the cars that are moving left to right.\n\
    \        var rightToLeftNotCollidedInFront = 0L\n        // This is the number\
    \ of cars that are moving left to right and have not yet collided and are behind\
    \ the cars that are moving right to left.\n        var leftToRightNotCollidedBehind\
    \ = n\n        // This is the number of cars that are moving right to left and\
    \ have not yet collided and are behind the cars that are moving left to right.\n\
    \        var rightToLeftNotCollidedBehind = n\n        // This is the number of\
    \ cars that are moving left to right and have not yet collided and are in front\
    \ of the cars that are moving right to left and have not yet collided.\n     \
    \   var leftToRightNotCollidedInFrontNotCollided = 0L\n        // This is the\
    \ number of cars that are moving right to left and have not yet collided and are\
    \ in front of the cars that are moving left to right and have not yet collided.\n\
    \        var rightToLeftNotCollidedInFrontNotCollided = 0L\n        // This is\
    \ the number of cars that are moving left to right and have not yet collided and\
    \ are behind the cars", "        // The idea is to sort the cars by their starting\
    \ position.\n        // Then, we can imagine that the cars are moving in a circle.\n\
    \        // The cars that are moving left to right are moving clockwise,\n   \
    \     // and the cars that are moving right to left are moving counterclockwise.\n\
    \        // Then, we can imagine that the cars are moving in a circle.\n     \
    \   // The cars that are moving left to right are moving clockwise,\n        //\
    \ and the cars that are moving right to left are moving counterclockwise.\n  \
    \      // The cars that are moving left to right are moving clockwise,\n     \
    \   // and the cars that are moving right to left are moving counterclockwise.\n\
    \        // The cars that are moving left to right are moving clockwise,\n   \
    \     // and the cars that are moving right to left are moving counterclockwise.\n\
    \        // The cars that are moving left to right are moving clockwise,\n   \
    \     // and the cars that are moving right to left are moving counterclockwise.\n\
    \        // The cars that are moving left to right are moving clockwise,\n   \
    \     // and the cars that are moving right to left are moving counterclockwise.\n\
    \        // The cars that are moving left to right are moving clockwise,\n   \
    \     // and the cars that are moving right to left are moving counterclockwise.\n\
    \        // The cars that are moving left to right are moving clockwise,\n   \
    \     // and the cars that are moving right to left are moving counterclockwise.\n\
    \        // The cars that are moving left to right are moving clockwise,\n   \
    \     // and the cars that are moving right to left are moving counterclockwise.\n\
    \        // The cars that are moving left to right are moving clockwise,\n   \
    \     // and the cars that are moving right to left are moving counterclockwise.\n\
    \        // The cars that are moving left to right are moving clockwise,\n   \
    \     // and the cars that are moving right to left are moving counterclockwise.\n\
    \        // The cars that are moving left to right are moving clockwise,\n   \
    \     // and the cars that are moving right to left are moving counterclockwise.\n\
    \        // The cars that are moving left to right are moving clockwise,\n   \
    \     // and the cars that are moving right to left are moving counterclockwise.\n\
    \        // The cars that are moving left to right are moving clockwise,\n   \
    \     // and the", "        // Let's say the cars are numbered from 1 to n.  The\
    \ cars moving left to right are\n        // numbered from 1 to n, and the cars\
    \ moving right to left are numbered from n to 1.\n        // The cars moving left\
    \ to right are at positions 1, 2, 3, ..., n.\n        // The cars moving right\
    \ to left are at positions n, n-1, n-2, ..., 1.\n        // The cars moving left\
    \ to right are moving at speeds 1, 2, 3, ..., n.\n        // The cars moving right\
    \ to left are moving at speeds n, n-1, n-2, ..., 1.\n        // The cars moving\
    \ left to right are moving at speeds 1, 2, 3, ..., n.\n        // The cars moving\
    \ right to left are moving at speeds n, n-1, n-2, ..., 1.\n        // The cars\
    \ moving left to right are moving at speeds 1, 2, 3, ..., n.\n        // The cars\
    \ moving right to left are moving at speeds n, n-1, n-2, ..., 1.\n        // The\
    \ cars moving left to right are moving at speeds 1, 2, 3, ..., n.\n        //\
    \ The cars moving right to left are moving at speeds n, n-1, n-2, ..., 1.\n  \
    \      // The cars moving left to right are moving at speeds 1, 2, 3, ..., n.\n\
    \        // The cars moving right to left are moving at speeds n, n-1, n-2, ...,\
    \ 1.\n        // The cars moving left to right are moving at speeds 1, 2, 3, ...,\
    \ n.\n        // The cars moving right to left are moving at speeds n, n-1, n-2,\
    \ ..., 1.\n        // The cars moving left to right are moving at speeds 1, 2,\
    \ 3, ..., n.\n        // The cars moving right to left are moving at speeds n,\
    \ n-1, n-2, ..., 1.\n        // The cars moving left to right are moving at speeds\
    \ 1, 2, 3, ..., n.\n        // The cars moving right to left are moving at speeds\
    \ n, n-1, n-2, ..., 1.\n        // The cars moving left to right are moving at\
    \ speeds 1, 2, 3", "        // Let's say that the cars moving left to right are\
    \ indexed from 0 to n - 1.\n        // Let's say that the cars moving right to\
    \ left are indexed from 0 to n - 1.\n        // Let's say that the car moving\
    \ left to right with index i starts at position i.\n        // Let's say that\
    \ the car moving right to left with index i starts at position n - 1 - i.\n  \
    \      // We can see that the cars moving left to right with index i and j will\
    \ collide if and only if\n        // i < j and n - 1 - i < n - 1 - j.  This is\
    \ equivalent to i < j and i > n - 1 - j.\n        // This is equivalent to i >\
    \ n - 1 - j.\n        // This is equivalent to i > (n - 1) / 2 - j.\n        //\
    \ This is equivalent to i > (n - 1) / 2 - (n - 1 - i).\n        // This is equivalent\
    \ to i > (n - 1) / 2 - (n - 1) + i.\n        // This is equivalent to i > (n -\
    \ 1) / 2 - (n - 1) + i.\n        // This is equivalent to i > (n - 1) / 2 - (n\
    \ - 1) + i.\n        // This is equivalent to i > (n - 1) / 2 - (n - 1) + i.\n\
    \        // This is equivalent to i > (n - 1) / 2 - (n - 1) + i.\n        // This\
    \ is equivalent to i > (n - 1) / 2 - (n - 1) + i.\n        // This is equivalent\
    \ to i > (n - 1) / 2 - (n - 1) + i.\n        // This is equivalent to i > (n -\
    \ 1) / 2 - (n - 1) + i.\n        // This is equivalent to i > (n - 1) / 2 - (n\
    \ - 1) + i.\n        // This is equivalent to i > (n - 1) / 2 - (n - 1) + i.\n\
    \        // This is equivalent to i > (n - 1) / 2 - (n - 1) + i.\n        // This\
    \ is equivalent to i > (n - 1) / 2 - (n - 1) + i.\n        // This", "       \
    \ var leftToRight = new Array[Long](n.toInt)\n        var rightToLeft = new Array[Long](n.toInt)\n\
    \        for (i <- 0 until n.toInt) {\n            leftToRight(i) = i\n      \
    \      rightToLeft(i) = n - i - 1\n        }\n        var collisions = 0\n   \
    \     for (i <- 0 until n.toInt) {\n            for (j <- 0 until n.toInt) {\n\
    \                if (leftToRight(i) == rightToLeft(j)) collisions += 1\n     \
    \       }\n        }\n        return collisions", "        // This function returns\
    \ the number of collisions between the two sets of cars.\n        // The two sets\
    \ of cars are represented by two arrays of integers.\n        // The first array\
    \ represents the cars moving left to right,\n        // and the second array represents\
    \ the cars moving right to left.\n        // Each integer in the array represents\
    \ the position of the car.\n        // The cars are sorted in ascending order.\n\
    \        def carRaceCollision(leftToRight : Array[Long], rightToLeft : Array[Long])\
    \ : Long = {\n            // This function returns the number of collisions between\
    \ the two sets of cars.\n            // The two sets of cars are represented by\
    \ two arrays of integers.\n            // The first array represents the cars\
    \ moving left to right,\n            // and the second array represents the cars\
    \ moving right to left.\n            // Each integer in the array represents the\
    \ position of the car.\n            // The cars are sorted in ascending order.\n\
    \            // The two arrays are assumed to be of the same length.\n       \
    \     def carRaceCollision(leftToRight : Array[Long], rightToLeft : Array[Long],\
    \ index : Int) : Long = {\n                if (index == leftToRight.length) 0\n\
    \                else {\n                    val left = leftToRight(index)\n \
    \                   val right = rightToLeft(index)\n                    if (left\
    \ < right) carRaceCollision(leftToRight, rightToLeft, index + 1)\n           \
    \         else 1 + carRaceCollision(leftToRight, rightToLeft, index + 1)\n   \
    \             }\n            }\n            carRaceCollision(leftToRight, rightToLeft,\
    \ 0)\n        }\n        // This function returns the number of collisions between\
    \ the two sets of cars.\n        // The two sets of cars are represented by two\
    \ arrays of integers.\n        // The first array represents the cars moving left\
    \ to right,\n        // and the second array represents the cars moving right\
    \ to left.\n        // Each integer in the array represents the position of the\
    \ car.\n        // The cars are sorted in ascending order.\n        // The two\
    \ arrays are assumed to be of the same length.\n        def carRaceCollision(leftToRight\
    \ : Array[Long], rightToLeft : Array[Long], index : Int) : Long = {\n        \
    \    if (index == leftToRight.length) 0\n", "        // This is a very interesting\
    \ problem.  The key is to realize that\n        // the cars that move left to\
    \ right are in fact the same as the cars\n        // that move right to left.\
    \  In other words, the problem is equivalent\n        // to asking how many pairs\
    \ of cars collide.  The answer is n * (n - 1) / 2.\n        n * (n - 1) / 2",
  "        // The idea is to sort the cars by their starting position.  Then, we can\n\
    \        // iterate through the cars in order and count the number of collisions.\n\
    \        // The number of collisions is equal to the number of cars that are moving\n\
    \        // in the opposite direction.\n        // The number of cars moving in\
    \ the opposite direction is equal to the number\n        // of cars that are moving\
    \ in the same direction and have a smaller starting\n        // position.\n  \
    \      // The number of cars moving in the same direction and have a smaller starting\n\
    \        // position is equal to the number of cars that are moving in the same\
    \ direction\n        // and have a smaller starting position.\n        // The\
    \ number of cars moving in the same direction and have a smaller starting\n  \
    \      // position is equal to the number of cars that are moving in the same\
    \ direction\n        // and have a smaller starting position.\n        // The\
    \ number of cars moving in the same direction and have a smaller starting\n  \
    \      // position is equal to the number of cars that are moving in the same\
    \ direction\n        // and have a smaller starting position.\n        // The\
    \ number of cars moving in the same direction and have a smaller starting\n  \
    \      // position is equal to the number of cars that are moving in the same\
    \ direction\n        // and have a smaller starting position.\n        // The\
    \ number of cars moving in the same direction and have a smaller starting\n  \
    \      // position is equal to the number of cars that are moving in the same\
    \ direction\n        // and have a smaller starting position.\n        // The\
    \ number of cars moving in the same direction and have a smaller starting\n  \
    \      // position is equal to the number of cars that are moving in the same\
    \ direction\n        // and have a smaller starting position.\n        // The\
    \ number of cars moving in the same direction and have a smaller starting\n  \
    \      // position is equal to the number of cars that are moving in the same\
    \ direction\n        // and have a smaller starting position.\n        // The\
    \ number of cars moving in the same direction and have a smaller starting\n  \
    \      // position is equal to the number of cars that are moving in the same\
    \ direction\n        // and have a smaller starting position.\n        // The\
    \ number of cars moving in the same direction and have a smaller starting\n  \
    \      // position is equal to the number of cars that are moving in the same\
    \ direction\n        // and have a smaller starting position.\n        // The\
    \ number of", "        // The idea is to sort the cars by their starting positions.\n\
    \        // Then, we can just count the number of cars that are moving left to\
    \ right\n        // and are to the left of a car that's moving right to left.\n\
    \        // This is because two cars are going to collide if and only if\n   \
    \     // a car that's moving left to right is to the left of a car that's moving\
    \ right to left.\n        // The reason is that if a car that's moving left to\
    \ right is to the left of a car that's moving right to left,\n        // then\
    \ the car that's moving left to right will eventually hit the car that's moving\
    \ right to left.\n        // On the other hand, if a car that's moving left to\
    \ right is to the right of a car that's moving right to left,\n        // then\
    \ the car that's moving left to right will never hit the car that's moving right\
    \ to left.\n        // This is because the car that's moving left to right will\
    \ never catch up to the car that's moving right to left.\n        // This is because\
    \ the car that's moving left to right is to the right of the car that's moving\
    \ right to left.\n        // Therefore, the car that's moving left to right will\
    \ never hit the car that's moving right to left.\n        // Therefore, the car\
    \ that's moving left to right will never collide with the car that's moving right\
    \ to left.\n        // Therefore, the car that's moving left to right will never\
    \ collide with any car.\n        // Therefore, the car that's moving left to right\
    \ will never collide with any car.\n        // Therefore, the car that's moving\
    \ left to right will never collide with any car.\n        // Therefore, the car\
    \ that's moving left to right will never collide with any car.\n        // Therefore,\
    \ the car that's moving left to right will never collide with any car.\n     \
    \   // Therefore, the car that's moving left to right will never collide with\
    \ any car.\n        // Therefore, the car that's moving left to right will never\
    \ collide with any car.\n        // Therefore, the car that's moving left to right\
    \ will never collide with any car.\n        // Therefore, the car that's moving\
    \ left to right will never collide with any car.\n        // Therefore, the car\
    \ that's moving left to right will never collide with any car.\n        //", " \
    \       // This is a very simple problem.  The cars that are moving left to right\n\
    \        // are numbered from 1 to n.  The cars that are moving right to left\
    \ are\n        // numbered from n+1 to 2n.  The cars that are moving left to right\n\
    \        // will collide with the cars that are moving right to left if and only\
    \ if\n        // they have the same number.  So the answer is n.\n        n",
  "        // The idea is to sort the cars by their starting position.\n        //\
    \ Then, we can use a sweep line algorithm to count the number of collisions.\n\
    \        // The sweep line algorithm is as follows:\n        // 1.  We start with\
    \ the leftmost car.\n        // 2.  We move the sweep line to the right until\
    \ we hit the next car.\n        // 3.  We count the number of cars that are moving\
    \ right to left that are\n        //     to the left of the sweep line.  These\
    \ cars will collide with the car\n        //     that the sweep line is currently\
    \ at.\n        // 4.  We repeat steps 2 and 3 until we reach the rightmost car.\n\
    \        // 5.  We return the total number of collisions.\n        // The time\
    \ complexity is O(n log n) because we need to sort the cars.\n        // The space\
    \ complexity is O(n) because we need to store the cars.\n        val cars = new\
    \ Array[(Long, Boolean)](2 * n.toInt)\n        for (i <- 0 until n.toInt) {\n\
    \            cars(i) = (i.toLong, true)\n            cars(i + n.toInt) = (i.toLong,\
    \ false)\n        }\n        cars.sortWith((a, b) => a._1 < b._1)\n        var\
    \ collisions = 0L\n        var leftCars = 0\n        for (i <- 0 until cars.length)\
    \ {\n            if (cars(i)._2) {\n                collisions += leftCars\n \
    \           } else {\n                leftCars += 1\n            }\n        }\n\
    \        collisions", "        // The idea is to sort the cars by their starting\
    \ positions.\n        // Then, we can just iterate through the cars and count\
    \ the number of collisions.\n        // The number of collisions is the number\
    \ of cars that are moving left to right\n        // that are to the left of the\
    \ car that's moving right to left.\n        // We can do this in O(n log n) time.\n\
    \        val cars = new Array[(Long, Boolean)](2 * n.toInt)\n        for (i <-\
    \ 0 until n.toInt) {\n            cars(i) = (i, true)\n            cars(i + n.toInt)\
    \ = (i, false)\n        }\n        val sortedCars = cars.sortWith((a, b) => (a._1\
    \ < b._1) || (a._1 == b._1 && a._2 && !b._2))\n        var collisions = 0L\n \
    \       var currentCar = 0\n        while (currentCar < 2 * n.toInt) {\n     \
    \       if (!sortedCars(currentCar)._2) {\n                collisions += currentCar\n\
    \            }\n            currentCar += 1\n        }\n        collisions", " \
    \       // This is a very simple problem.  The key is to realize that if two cars\n\
    \        // collide, then the car that's moving left to right must be the ith\
    \ car (for some i),\n        // and the car that's moving right to left must be\
    \ the jth car (for some j).\n        // The reason is that the ith car is the\
    \ first car that's moving left to right,\n        // and the jth car is the first\
    \ car that's moving right to left.\n        // So, we can just iterate over all\
    \ i and j, and count the number of collisions.\n        // This is O(n^2).\n \
    \       var count = 0L\n        for (i <- 1 to n.toInt) {\n            for (j\
    \ <- 1 to n.toInt) {\n                if (i < j) count += 1\n            }\n \
    \       }\n        count", "        // The cars are numbered from 1 to n.  The\
    \ cars that are moving left to right\n        // are numbered from 1 to n, and\
    \ the cars that are moving right to left are\n        // numbered from n to 1.\
    \  The cars are initially positioned as follows:\n        // Car 1 is at position\
    \ 1, car 2 is at position 2, ..., car n is at position n.\n        // Car n is\
    \ at position n + 1, car n - 1 is at position n + 2, ..., car 1 is at position\
    \ 2n.\n        // The cars move at the same speed.  Car 1 moves 1 unit per second,\
    \ car 2 moves 2 units per second,\n        // ..., car n moves n units per second.\
    \  Car n moves n units per second, car n - 1 moves n - 1 units\n        // per\
    \ second, ..., car 1 moves 1 unit per second.\n        // The cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n        // in their trajectory\
    \ as if they did not collide.\n        // This function outputs the number of\
    \ such collisions.\n        //\n        // The cars that are moving left to right\
    \ are numbered from 1 to n, and the cars that are moving right to left are\n \
    \       // numbered from n to 1.  The cars are initially positioned as follows:\n\
    \        // Car 1 is at position 1, car 2 is at position 2, ..., car n is at position\
    \ n.\n        // Car n is at position n + 1, car n - 1 is at position n + 2, ...,\
    \ car 1 is at position 2n.\n        // The cars move at the same speed.  Car 1\
    \ moves 1 unit per second, car 2 moves 2 units per second,\n        // ..., car\
    \ n moves n units per second.  Car n moves n units per second, car n - 1 moves\
    \ n - 1 units\n        // per second, ..., car 1 moves 1 unit per second.\n  \
    \      // The cars are infinitely sturdy and strong; as a result, they continue\
    \ moving\n        // in their trajectory as if they did not collide.\n       \
    \ // This function outputs the number of such collisions.\n        //\n      \
    \  // The cars that are moving left to right are numbered from 1 to n, and the\
    \ cars that are moving right to left are\n        // numbered from n to 1.  The\
    \ cars are initially positioned as follows:\n", "        // This function returns\
    \ the number of collisions between the cars that are moving\n        // left to\
    \ right and the cars that are moving right to left.\n        // The cars are numbered\
    \ from 0 to n - 1.\n        // The cars that are moving left to right are numbered\
    \ from 0 to n - 1.\n        // The cars that are moving right to left are numbered\
    \ from n - 1 to 0.\n        // The cars that are moving left to right are at positions\
    \ x0, x1, ..., x(n - 1).\n        // The cars that are moving right to left are\
    \ at positions y0, y1, ..., y(n - 1).\n        // The cars that are moving left\
    \ to right are moving at speeds v0, v1, ..., v(n - 1).\n        // The cars that\
    \ are moving right to left are moving at speeds w0, w1, ..., w(n - 1).\n     \
    \   // The cars that are moving left to right are moving at speeds 1, 2, ...,\
    \ n.\n        // The cars that are moving right to left are moving at speeds n,\
    \ n - 1, ..., 1.\n        // The cars that are moving left to right are at positions\
    \ 0, 1, ..., n - 1.\n        // The cars that are moving right to left are at\
    \ positions n - 1, n - 2, ..., 0.\n        // The cars that are moving left to\
    \ right are at positions 0, 1, ..., n - 1.\n        // The cars that are moving\
    \ right to left are at positions n - 1, n - 2, ..., 0.\n        // The cars that\
    \ are moving left to right are at positions 0, 1, ..., n - 1.\n        // The\
    \ cars that are moving right to left are at positions n - 1, n - 2, ..., 0.\n\
    \        // The cars that are moving left to right are at positions 0, 1, ...,\
    \ n - 1.\n        // The cars that are moving right to left are at positions n\
    \ - 1, n - 2, ..., 0.\n        // The cars that are moving left to right are at\
    \ positions 0, 1, ..., n - 1.\n        // The cars that are moving right to left\
    \ are at positions n - 1, n - 2, ..., 0.\n        // The cars that are moving\
    \ left to right are at positions", "        // This function returns the number\
    \ of collisions for the first i cars\n        // moving left to right and the\
    \ first j cars moving right to left.\n        def f(i : Long, j : Long) : Long\
    \ = {\n            if (i == 0 || j == 0) 0\n            else if (i == j) i * (i\
    \ - 1) / 2\n            else if (i < j) f(i, i) + f(i, j - i)\n            else\
    \ f(j, j) + f(i - j, j)\n        }\n        f(n, n)", "        // This is a very\
    \ simple problem.  We can just simulate the cars moving.\n        // We can do\
    \ this in O(n^2) time.\n        // However, we can do better.  We can do this\
    \ in O(n log n) time.\n        // We can do this by sorting the cars by their\
    \ starting position.\n        // Then, we can just iterate through the cars, and\
    \ for each car,\n        // we can find the number of cars that are going to collide\
    \ with it.\n        // This can be done in O(log n) time using binary search.\n\
    \        // Then, we can just sum up the number of collisions.\n        // This\
    \ is O(n log n) time.\n        // We can do even better.  We can do this in O(n)\
    \ time.\n        // We can do this by using a stack.\n        // We can iterate\
    \ through the cars, and for each car, we can\n        // push it onto the stack.\
    \  If the top car on the stack is going\n        // to collide with the current\
    \ car, then we can pop the top car\n        // off the stack.  We can continue\
    \ doing this until we find a car\n        // that is not going to collide with\
    \ the current car.\n        // Then, we can push the current car onto the stack.\n\
    \        // This is O(n) time.\n        val cars = Array.fill(n.toInt)((0, 0))\n\
    \        for (i <- 0 until n.toInt) {\n            val Array(x, v) = readLine.split(\"\
    \ \").map(_.toInt)\n            cars(i) = (x, v)\n        }\n        val cars1\
    \ = cars.sortBy(_._1)\n        val cars2 = cars.sortBy(_._1).reverse\n       \
    \ val stack = new Stack[(Int, Int)]\n        var collisions = 0L\n        for\
    \ (i <- 0 until n.toInt) {\n            while (stack.nonEmpty && stack.top._1\
    \ > cars2(i)._1) {\n                stack.pop\n            }\n            stack.push(cars2(i))\n\
    \            collisions += stack.size - 1\n        }\n        collisions", " \
    \       // The cars are numbered from 1 to n.\n        // The cars moving left\
    \ to right are numbered from 1 to n.\n        // The cars moving right to left\
    \ are numbered from n to 1.\n        // The cars moving left to right are at positions\
    \ x1, x2, ..., xn.\n        // The cars moving right to left are at positions\
    \ y1, y2, ..., yn.\n        // The cars moving left to right are at positions\
    \ x1, x2, ..., xn.\n        // The cars moving right to left are at positions\
    \ y1, y2, ..., yn.\n        // The cars moving left to right are at positions\
    \ x1, x2, ..., xn.\n        // The cars moving right to left are at positions\
    \ y1, y2, ..., yn.\n        // The cars moving left to right are at positions\
    \ x1, x2, ..., xn.\n        // The cars moving right to left are at positions\
    \ y1, y2, ..., yn.\n        // The cars moving left to right are at positions\
    \ x1, x2, ..., xn.\n        // The cars moving right to left are at positions\
    \ y1, y2, ..., yn.\n        // The cars moving left to right are at positions\
    \ x1, x2, ..., xn.\n        // The cars moving right to left are at positions\
    \ y1, y2, ..., yn.\n        // The cars moving left to right are at positions\
    \ x1, x2, ..., xn.\n        // The cars moving right to left are at positions\
    \ y1, y2, ..., yn.\n        // The cars moving left to right are at positions\
    \ x1, x2, ..., xn.\n        // The cars moving right to left are at positions\
    \ y1, y2, ..., yn.\n        // The cars moving left to right are at positions\
    \ x1, x2, ..., xn.\n        // The cars moving right to left are at positions\
    \ y1, y2, ..., yn.\n        // The cars moving left to right are at positions\
    \ x1, x2, ..., xn.\n        // The cars moving right to left are at positions\
    \ y1, y2, ..., yn.\n        // The cars moving left to", "        // The idea\
    \ is to sort the cars by their starting position.\n        // Then, we can simulate\
    \ the race by moving the cars one by one.\n        // If a car moves to the same\
    \ position as another car, then there's a collision.\n        // We can use a\
    \ hash map to keep track of the number of cars at each position.\n        // The\
    \ hash map is initialized to 0 for all positions.\n        // When a car moves,\
    \ we increment the number of cars at that position.\n        // When a car moves\
    \ to a position where there's already a car, we increment the collision count.\n\
    \        // We also decrement the number of cars at that position.\n        //\
    \ If the number of cars at that position becomes 0, then we remove that position\
    \ from the hash map.\n        // The time complexity is O(n log n) because we\
    \ sort the cars.\n        // The space complexity is O(n) because we store the\
    \ cars in a hash map.\n        // We can reduce the space complexity to O(1) by\
    \ using a bit vector instead of a hash map.\n        // The bit vector is initialized\
    \ to 0 for all positions.\n        // When a car moves, we set the bit at that\
    \ position to 1.\n        // When a car moves to a position where there's already\
    \ a car, we increment the collision count.\n        // We also set the bit at\
    \ that position to 0.\n        // If the bit at that position becomes 0, then\
    \ we don't have to do anything.\n        // The time complexity is O(n log n)\
    \ because we sort the cars.\n        // The space complexity is O(1) because we\
    \ store the cars in a bit vector.\n        val cars = Array.fill(n.toInt)(0)\n\
    \        for (i <- 0 until n.toInt) cars(i) = i\n        val leftToRight = cars.map(x\
    \ => (x, true))\n        val rightToLeft = cars.map(x => (x, false))\n       \
    \ val sortedCars = (leftToRight ++ rightToLeft).sortBy(x => x._1)\n        var\
    \ collisionCount = 0\n        val bitVector = new BitVector(n.toInt)\n       \
    \ for (car <- sortedCars) {\n            if (car._2) {\n                if (bitVector(car._1",
  "        // This is a very simple problem.  The cars are moving in the same speed;\n\
    \        // as a result, the cars that are closest to each other will collide\
    \ first.\n        // The cars that are closest to each other are the ones that\
    \ are in the middle.\n        // The number of cars in the middle is n - 1.\n\
    \        n - 1", "        // The idea is to sort the cars by their starting positions.\n\
    \        // Then, we can just count the number of cars that are moving in the\
    \ same direction\n        // and are starting at the same position.\n        val\
    \ cars = Array.fill(2 * n.toInt)(0)\n        for (i <- 0 until n.toInt) {\n  \
    \          cars(i) = i + 1\n            cars(i + n.toInt) = -(i + 1)\n       \
    \ }\n        cars.sorted.sliding(2).filter(x => x(0) > 0 && x(1) > 0 || x(0) <\
    \ 0 && x(1) < 0).size", "        // This is a very simple problem.  The cars that\
    \ are moving left to right\n        // are numbered from 1 to n.  The cars that\
    \ are moving right to left are\n        // numbered from n+1 to 2n.  The cars\
    \ that are moving left to right\n        // will collide with the cars that are\
    \ moving right to left if and only if\n        // the numbers of the two cars\
    \ are the same.  Therefore, the number of collisions\n        // is the number\
    \ of pairs of cars that have the same number.  This is the same\n        // as\
    \ the number of pairs of numbers that are the same.  This is the same as\n   \
    \     // the number of pairs of numbers that are the same.  This is the same as\n\
    \        // the number of pairs of numbers that are the same.  This is the same\
    \ as\n        // the number of pairs of numbers that are the same.  This is the\
    \ same as\n        // the number of pairs of numbers that are the same.  This\
    \ is the same as\n        // the number of pairs of numbers that are the same.\
    \  This is the same as\n        // the number of pairs of numbers that are the\
    \ same.  This is the same as\n        // the number of pairs of numbers that are\
    \ the same.  This is the same as\n        // the number of pairs of numbers that\
    \ are the same.  This is the same as\n        // the number of pairs of numbers\
    \ that are the same.  This is the same as\n        // the number of pairs of numbers\
    \ that are the same.  This is the same as\n        // the number of pairs of numbers\
    \ that are the same.  This is the same as\n        // the number of pairs of numbers\
    \ that are the same.  This is the same as\n        // the number of pairs of numbers\
    \ that are the same.  This is the same as\n        // the number of pairs of numbers\
    \ that are the same.  This is the same as\n        // the number of pairs of numbers\
    \ that are the same.  This is the same as\n        // the number of pairs of numbers\
    \ that are the same.  This is the same as\n        // the number of pairs of numbers\
    \ that are the same.  This is the same as\n        // the number of pairs of numbers\
    \ that are the same.  This is the same as\n        // the number of pairs of numbers\
    \ that are the", "        // The idea is to sort the cars by their starting positions.\n\
    \        // If a car starts at position x, then it will collide with the car\n\
    \        // that starts at position -x.  So, we can just count the number of\n\
    \        // pairs of cars that start at positions x and -x.\n        val cars\
    \ = Array.fill(n.toInt)(readLong)\n        val carsPositive = cars.filter(_ >\
    \ 0)\n        val carsNegative = cars.filter(_ < 0).map(-_)\n        val carsPositiveSorted\
    \ = carsPositive.sorted\n        val carsNegativeSorted = carsNegative.sorted\n\
    \        var collisions = 0L\n        var i = 0\n        var j = 0\n        while\
    \ (i < carsPositiveSorted.length && j < carsNegativeSorted.length) {\n       \
    \     if (carsPositiveSorted(i) == carsNegativeSorted(j)) {\n                collisions\
    \ += 1\n                i += 1\n                j += 1\n            } else if\
    \ (carsPositiveSorted(i) < carsNegativeSorted(j)) {\n                i += 1\n\
    \            } else {\n                j += 1\n            }\n        }\n    \
    \    collisions", "        // This is the number of collisions.\n        var collisions\
    \ = 0L\n        // This is the number of cars that have moved left to right.\n\
    \        var movedRight = 0L\n        // This is the number of cars that have\
    \ moved right to left.\n        var movedLeft = 0L\n        // This is the number\
    \ of cars that are currently moving left to right.\n        var movingRight =\
    \ n\n        // This is the number of cars that are currently moving right to\
    \ left.\n        var movingLeft = n\n        // This is the number of cars that\
    \ are currently moving left to right and have not yet collided.\n        var movingRightUncollided\
    \ = n\n        // This is the number of cars that are currently moving right to\
    \ left and have not yet collided.\n        var movingLeftUncollided = n\n    \
    \    // This is the number of cars that are currently moving left to right and\
    \ have collided.\n        var movingRightCollided = 0L\n        // This is the\
    \ number of cars that are currently moving right to left and have collided.\n\
    \        var movingLeftCollided = 0L\n        // This is the number of cars that\
    \ are currently moving left to right and have collided and have not yet moved.\n\
    \        var movingRightCollidedStopped = 0L\n        // This is the number of\
    \ cars that are currently moving right to left and have collided and have not\
    \ yet moved.\n        var movingLeftCollidedStopped = 0L\n        // This is the\
    \ number of cars that are currently moving left to right and have collided and\
    \ have moved.\n        var movingRightCollidedMoved = 0L\n        // This is the\
    \ number of cars that are currently moving right to left and have collided and\
    \ have moved.\n        var movingLeftCollidedMoved = 0L\n        // This is the\
    \ number of cars that are currently moving left to right and have collided and\
    \ have moved and have not yet collided.\n        var movingRightCollidedMovedUncollided\
    \ = 0L\n        // This is the number of cars that are currently moving right\
    \ to left and have collided and have moved and have not yet collided.\n      \
    \  var movingLeftCollidedMovedUncollided = 0L\n        // This is the number of\
    \ cars that are currently moving left to right and have collided and have moved\
    \ and have collided.\n        var movingRightCollidedMovedCollided = 0L\n    \
    \    // This is", "        // The idea is to sort the cars by their starting positions.\n\
    \        // Then, we can use a sweep line algorithm to find the number of collisions.\n\
    \        // The sweep line algorithm is as follows:\n        // 1.  Sort the cars\
    \ by their starting positions.\n        // 2.  Initialize a list of cars that\
    \ are currently on the road.\n        // 3.  For each car, if the car is moving\
    \ left to right, add it to the list.\n        //     If the car is moving right\
    \ to left, remove it from the list.\n        //     If the car is moving left\
    \ to right, and there are cars in the list,\n        //     then there is a collision.\n\
    \        // 4.  Return the number of collisions.\n        // The time complexity\
    \ is O(n log n).\n        // The space complexity is O(n).\n        val cars =\
    \ Array.fill(2 * n.toInt)(0)\n        for (i <- 0 until n.toInt) {\n         \
    \   cars(i) = i + 1\n            cars(i + n.toInt) = -(i + 1)\n        }\n   \
    \     val sortedCars = cars.sorted\n        var collisions = 0\n        val carsOnRoad\
    \ = new ListBuffer[Int]\n        for (car <- sortedCars) {\n            if (car\
    \ > 0) {\n                if (carsOnRoad.nonEmpty) collisions += 1\n         \
    \       carsOnRoad += car\n            } else {\n                carsOnRoad -=\
    \ (-car)\n            }\n        }\n        collisions", "        // This is a\
    \ very simple problem.  We can solve it by brute force.\n        // We can imagine\
    \ a coordinate system where the leftmost car is at position 0,\n        // the\
    \ rightmost car is at position 2n, and the cars in between are spaced out\n  \
    \      // evenly.  We can then simulate the movement of the cars.  If we find\
    \ that\n        // two cars are at the same position at the same time, then we\
    \ have a collision.\n        // We can do this simulation in O(n^2) time.\n  \
    \      // However, we can do better.  We can solve this problem in O(n log n)\
    \ time.\n        // The idea is to use a sweep line algorithm.  We can imagine\
    \ a vertical line\n        // that moves from left to right.  As the line moves,\
    \ we keep track of the\n        // number of cars that are to the left of the\
    \ line.  We can do this by\n        // maintaining a set of cars that are to the\
    \ left of the line.  We can\n        // maintain this set in O(log n) time per\
    \ insertion and deletion.\n        // As the line moves, we can insert and delete\
    \ cars from the set.  We can\n        // also keep track of the number of cars\
    \ that are to the right of the line.\n        // We can do this by maintaining\
    \ a set of cars that are to the right of the line.\n        // We can maintain\
    \ this set in O(log n) time per insertion and deletion.\n        // When we insert\
    \ a car into the set of cars to the left of the line, we\n        // check whether\
    \ the car is already in the set of cars to the right of the line.\n        //\
    \ If so, then we have a collision.  We can do this in O(log n) time.\n       \
    \ // When we insert a car into the set of cars to the right of the line, we\n\
    \        // check whether the car is already in the set of cars to the left of\
    \ the line.\n        // If so, then we have a collision.  We can do this in O(log\
    \ n) time.\n        // When we delete a car from the set of cars to the left of\
    \ the line, we\n        // check whether the car is already in the set of cars\
    \ to the right of the line.\n        // If so, then we have a", "        // This\
    \ is a very simple problem.  The cars are moving in the same speed, so\n     \
    \   // the time it takes for a car to reach the origin is the same for all cars.\n\
    \        // The cars are moving in opposite directions, so the cars that are closest\n\
    \        // to the origin will collide first.  The cars that are farthest from\
    \ the origin\n        // will collide last.  So, the answer is simply the number\
    \ of cars that are\n        // closest to the origin.\n        // The cars are\
    \ numbered from 1 to n.  The cars that are closest to the origin\n        // are\
    \ the cars that are closest to the number n/2.  If n is even, then the\n     \
    \   // cars that are closest to the origin are the cars that are closest to n/2.\n\
    \        // If n is odd, then the cars that are closest to the origin are the\
    \ cars that\n        // are closest to (n-1)/2 and (n+1)/2.\n        if (n % 2\
    \ == 0) n / 2 else n", "        // The idea is to sort the cars by their starting\
    \ position.\n        // Then, we can just iterate through the cars and count the\
    \ number of collisions.\n        // The total number of collisions is the number\
    \ of collisions between the first car\n        // and the second car, plus the\
    \ number of collisions between the second car and the third car,\n        // plus\
    \ the number of collisions between the third car and the fourth car, and so on.\n\
    \        // The number of collisions between the ith car and the (i+1)th car is\
    \ simply the difference\n        // between the starting positions of the two\
    \ cars.\n        // The total number of collisions is the sum of these differences.\n\
    \        // We can compute this sum in O(n) time.\n        // The total running\
    \ time is O(n log n) because we need to sort the cars.\n        val cars = Array.fill(n.toInt)((scala.util.Random.nextInt(n.toInt),\
    \ scala.util.Random.nextInt(n.toInt)))\n        val sortedCars = cars.sortBy(x\
    \ => x._1)\n        var collisions = 0L\n        for (i <- 0 until n.toInt - 1)\
    \ {\n            collisions += abs(sortedCars(i)._1 - sortedCars(i + 1)._1)\n\
    \        }\n        collisions", "        // This function returns the number\
    \ of collisions for n cars.\n        def f(n : Long) : Long = {\n            if\
    \ (n == 0) 0\n            else if (n == 1) 0\n            else if (n == 2) 1\n\
    \            else if (n % 2 == 0) f(n / 2) + f(n / 2 - 1)\n            else f(n\
    \ / 2) + f(n / 2)\n        }\n        f(n)", "        // The idea is to sort the\
    \ cars by their starting position.\n        // Then, we can just iterate through\
    \ the cars, and count the number of\n        // cars that are moving in the opposite\
    \ direction.\n        // This is O(n log n) time.\n        val cars = Array.fill(n.toInt)((scala.util.Random.nextInt(n.toInt),\
    \ scala.util.Random.nextInt(2)))\n        val sortedCars = cars.sortBy(_._1)\n\
    \        var count = 0\n        for (i <- 0 until n.toInt) {\n            if (sortedCars(i)._2\
    \ == 0) {\n                count += 1\n            }\n        }\n        count",
  "        // The cars are numbered from 0 to n-1.  The cars moving left to right\
    \ are\n        // numbered from 0 to n-1; the cars moving right to left are numbered\
    \ from n-1 to 0.\n        // The cars moving left to right start at position 0;\
    \ the cars moving right to left\n        // start at position n-1.\n        //\
    \ The cars moving left to right have speed 1; the cars moving right to left have\
    \ speed -1.\n        // The cars moving left to right have acceleration 0; the\
    \ cars moving right to left have\n        // acceleration 0.\n        // The cars\
    \ moving left to right have initial velocity 1; the cars moving right to left\n\
    \        // have initial velocity -1.\n        // The cars moving left to right\
    \ have initial position 0; the cars moving right to left\n        // have initial\
    \ position n-1.\n        // The cars moving left to right have initial time 0;\
    \ the cars moving right to left\n        // have initial time 0.\n        // The\
    \ cars moving left to right have final time n-1; the cars moving right to left\n\
    \        // have final time n-1.\n        // The cars moving left to right have\
    \ final position n-1; the cars moving right to left\n        // have final position\
    \ 0.\n        // The cars moving left to right have final velocity 1; the cars\
    \ moving right to left\n        // have final velocity -1.\n        // The cars\
    \ moving left to right have final acceleration 0; the cars moving right to left\n\
    \        // have final acceleration 0.\n        // The cars moving left to right\
    \ have distance traveled n-1; the cars moving right to left\n        // have distance\
    \ traveled n-1.\n        // The cars moving left to right have average velocity\
    \ 1; the cars moving right to left\n        // have average velocity -1.\n   \
    \     // The cars moving left to right have average acceleration 0; the cars moving\
    \ right to left\n        // have average acceleration 0.\n        // The cars\
    \ moving left to right have average speed 1; the cars moving right to left\n \
    \       // have average speed 1.\n        // The cars moving left to right have\
    \ average acceleration 0; the cars moving right to left\n        // have average\
    \ acceleration 0.\n        // The cars moving left to right have average jerk\
    \ 0; the cars moving right to left\n        // have average jerk 0.\n        //\
    \ The cars", "        // The idea is to sort the cars by their starting positions.\n\
    \        // Then, we can simply iterate through the sorted list and count the\
    \ number of collisions.\n        // The time complexity is O(n log n).\n     \
    \   val cars = Array.fill(n.toInt)((0, 0))\n        for (i <- 0 until n.toInt)\
    \ {\n            val Array(x, v) = readLine.split(\" \").map(_.toInt)\n      \
    \      cars(i) = (x, v)\n        }\n        val sortedCars = cars.sortBy(_._1)\n\
    \        var collisions = 0\n        for (i <- 0 until n.toInt) {\n          \
    \  for (j <- i + 1 until n.toInt) {\n                if (sortedCars(i)._2 < sortedCars(j)._2)\
    \ collisions += 1\n            }\n        }\n        collisions", "        //\
    \ The idea is to use a sweep line algorithm.\n        // We will sweep from left\
    \ to right.\n        // We will keep track of the cars that are moving left to\
    \ right and the cars that are moving right to left.\n        // We will keep track\
    \ of the cars that are moving left to right in a priority queue.\n        // We\
    \ will keep track of the cars that are moving right to left in a priority queue.\n\
    \        // When we sweep, we will check if the cars that are moving left to right\
    \ are colliding with the cars that are moving right to left.\n        // If they\
    \ are, then we will remove the car that is moving left to right from the priority\
    \ queue and we will remove the car that is moving right to left from the priority\
    \ queue.\n        // We will keep track of the number of collisions.\n       \
    \ // We will keep track of the number of cars that are moving left to right and\
    \ the number of cars that are moving right to left.\n        // We will keep track\
    \ of the number of cars that are moving left to right in a variable.\n       \
    \ // We will keep track of the number of cars that are moving right to left in\
    \ a variable.\n        // We will keep track of the number of cars that are moving\
    \ left to right in a variable.\n        // We will keep track of the number of\
    \ cars that are moving right to left in a variable.\n        // We will keep track\
    \ of the number of cars that are moving left to right in a variable.\n       \
    \ // We will keep track of the number of cars that are moving right to left in\
    \ a variable.\n        // We will keep track of the number of cars that are moving\
    \ left to right in a variable.\n        // We will keep track of the number of\
    \ cars that are moving right to left in a variable.\n        // We will keep track\
    \ of the number of cars that are moving left to right in a variable.\n       \
    \ // We will keep track of the number of cars that are moving right to left in\
    \ a variable.\n        // We will keep track of the number of cars that are moving\
    \ left to right in a variable.\n        // We will keep track of the number of\
    \ cars that are moving right to left in a variable.\n        // We will keep track\
    \ of the number of cars that are moving left to right in a variable.\n       \
    \ // We will keep track of the number of cars that are moving right to left in",
  "        // This is a very simple problem.  The key observation is that the cars\
    \ that are\n        // moving left to right are the same as the cars that are\
    \ moving right to left.\n        // As a result, the number of collisions is the\
    \ number of pairs of cars that are\n        // moving in the same direction.\n\
    \        // There are n cars moving left to right, and n cars moving right to\
    \ left.\n        // The number of pairs of cars that are moving in the same direction\
    \ is n * (n - 1) / 2.\n        n * (n - 1) / 2", "        // The idea is to sort\
    \ the cars by their starting positions.\n        // Then, we can just iterate\
    \ through the cars and count the number of collisions.\n        // The number\
    \ of collisions is equal to the number of cars that are moving right to left\n\
    \        // that are to the left of the current car.\n        // This is because\
    \ the car that's moving left to right will collide with all cars that are\n  \
    \      // moving right to left that are to the left of it.\n        // This is\
    \ because the car that's moving left to right will collide with all cars that\
    \ are\n        // moving right to left that are to the left of it.\n        //\
    \ This is because the car that's moving left to right will collide with all cars\
    \ that are\n        // moving right to left that are to the left of it.\n    \
    \    // This is because the car that's moving left to right will collide with\
    \ all cars that are\n        // moving right to left that are to the left of it.\n\
    \        // This is because the car that's moving left to right will collide with\
    \ all cars that are\n        // moving right to left that are to the left of it.\n\
    \        // This is because the car that's moving left to right will collide with\
    \ all cars that are\n        // moving right to left that are to the left of it.\n\
    \        // This is because the car that's moving left to right will collide with\
    \ all cars that are\n        // moving right to left that are to the left of it.\n\
    \        // This is because the car that's moving left to right will collide with\
    \ all cars that are\n        // moving right to left that are to the left of it.\n\
    \        // This is because the car that's moving left to right will collide with\
    \ all cars that are\n        // moving right to left that are to the left of it.\n\
    \        // This is because the car that's moving left to right will collide with\
    \ all cars that are\n        // moving right to left that are to the left of it.\n\
    \        // This is because the car that's moving left to right will collide with\
    \ all cars that are\n        // moving right to left that are to the left of it.\n\
    \        // This is because the car that's moving left to right will collide with\
    \ all cars that are\n        // moving right to left that are to the left of it.\n\
    \        // This is because the car that's moving left", "        // Let's say\
    \ that the left-to-right cars are numbered 1 to n, and the right-to-left cars\n\
    \        // are numbered n+1 to 2n.  We'll say that a car i collides with car\
    \ j if i < j and\n        // car i is to the left of car j.  We'll say that a\
    \ car i is to the left of car j if\n        // i < j and car i is moving left\
    \ to right and car j is moving right to left.\n        // We'll say that a car\
    \ i is to the right of car j if i > j and car i is moving right to left\n    \
    \    // and car j is moving left to right.\n        // We'll say that car i is\
    \ to the left of car j if i < j and car i is to the left of car j\n        //\
    \ and car i is not to the right of car j.\n        // We'll say that car i is\
    \ to the right of car j if i > j and car i is to the right of car j\n        //\
    \ and car i is not to the left of car j.\n        // We'll say that car i is to\
    \ the left of car j if i < j and car i is to the left of car j\n        // and\
    \ car i is not to the right of car j.\n        // We'll say that car i is to the\
    \ right of car j if i > j and car i is to the right of car j\n        // and car\
    \ i is not to the left of car j.\n        // We'll say that car i is to the left\
    \ of car j if i < j and car i is to the left of car j\n        // and car i is\
    \ not to the right of car j.\n        // We'll say that car i is to the right\
    \ of car j if i > j and car i is to the right of car j\n        // and car i is\
    \ not to the left of car j.\n        // We'll say that car i is to the left of\
    \ car j if i < j and car i is to the left of car j\n        // and car i is not\
    \ to the right of car j.\n        // We'll say that car i is to the right of car\
    \ j if i > j and car i is to the right of car j\n        // and car i is not to\
    \ the left of car j.\n", "        // This is a simple problem.  We can use a hash\
    \ map to store the positions of the cars\n        // that are moving left to right.\
    \  Then, we can iterate through the cars that are moving\n        // right to\
    \ left and see if there is a collision.  If there is a collision, we remove the\n\
    \        // car that is moving left to right from the hash map.\n        val map\
    \ = new HashMap[Long, Long]()\n        for (i <- 1 to n.toInt) {\n           \
    \ map.put(i, i)\n        }\n        var count = 0\n        for (i <- 1 to n.toInt)\
    \ {\n            if (map.contains(i)) {\n                count += 1\n        \
    \        map.remove(i)\n            }\n        }\n        count", "        //\
    \ The idea is to sort the cars by their starting positions.\n        // Then,\
    \ we can simulate the race by moving the cars one by one.\n        // The cars\
    \ are sorted by their starting positions.\n        // The cars are sorted by their\
    \ starting positions.\n        // The cars are sorted by their starting positions.\n\
    \        // The cars are sorted by their starting positions.\n        // The cars\
    \ are sorted by their starting positions.\n        // The cars are sorted by their\
    \ starting positions.\n        // The cars are sorted by their starting positions.\n\
    \        // The cars are sorted by their starting positions.\n        // The cars\
    \ are sorted by their starting positions.\n        // The cars are sorted by their\
    \ starting positions.\n        // The cars are sorted by their starting positions.\n\
    \        // The cars are sorted by their starting positions.\n        // The cars\
    \ are sorted by their starting positions.\n        // The cars are sorted by their\
    \ starting positions.\n        // The cars are sorted by their starting positions.\n\
    \        // The cars are sorted by their starting positions.\n        // The cars\
    \ are sorted by their starting positions.\n        // The cars are sorted by their\
    \ starting positions.\n        // The cars are sorted by their starting positions.\n\
    \        // The cars are sorted by their starting positions.\n        // The cars\
    \ are sorted by their starting positions.\n        // The cars are sorted by their\
    \ starting positions.\n        // The cars are sorted by their starting positions.\n\
    \        // The cars are sorted by their starting positions.\n        // The cars\
    \ are sorted by their starting positions.\n        // The cars are sorted by their\
    \ starting positions.\n        // The cars are sorted by their starting positions.\n\
    \        // The cars are sorted by their starting positions.\n        // The cars\
    \ are sorted by their starting positions.\n        // The cars are sorted by their\
    \ starting positions.\n        // The cars are sorted by their starting positions.\n\
    \        // The cars are sorted by their starting positions.\n        // The cars\
    \ are sorted by their starting positions.\n        // The cars are sorted by their\
    \ starting positions.\n        // The cars are sorted by their starting positions.\n\
    \        // The cars are sorted by their starting positions.\n        // The cars\
    \ are sorted by their starting positions.\n        // The cars are sorted by their\
    \ starting positions.\n        // The cars are sorted by their starting positions.\n\
    \        // The cars are sorted by their starting positions", "        // This\
    \ function returns the number of collisions between the cars in the two lists.\n\
    \        // The cars in the two lists are assumed to be sorted by their starting\
    \ position.\n        def carRaceCollision(leftToRight : List[Long], rightToLeft\
    \ : List[Long]) : Long = {\n            if (leftToRight.isEmpty || rightToLeft.isEmpty)\
    \ 0\n            else {\n                val leftToRightHead = leftToRight.head\n\
    \                val rightToLeftHead = rightToLeft.head\n                if (leftToRightHead\
    \ < rightToLeftHead) carRaceCollision(leftToRight.tail, rightToLeft)\n       \
    \         else if (leftToRightHead > rightToLeftHead) carRaceCollision(leftToRight,\
    \ rightToLeft.tail)\n                else 1 + carRaceCollision(leftToRight.tail,\
    \ rightToLeft.tail)\n            }\n        }\n        // This function returns\
    \ the number of collisions between the cars in the two lists.\n        // The\
    \ cars in the two lists are assumed to be sorted by their starting position.\n\
    \        // The cars in the two lists are assumed to be sorted by their starting\
    \ position.\n        // The cars in the two lists are assumed to be sorted by\
    \ their starting position.\n        // The cars in the two lists are assumed to\
    \ be sorted by their starting position.\n        // The cars in the two lists\
    \ are assumed to be sorted by their starting position.\n        // The cars in\
    \ the two lists are assumed to be sorted by their starting position.\n       \
    \ // The cars in the two lists are assumed to be sorted by their starting position.\n\
    \        // The cars in the two lists are assumed to be sorted by their starting\
    \ position.\n        // The cars in the two lists are assumed to be sorted by\
    \ their starting position.\n        // The cars in the two lists are assumed to\
    \ be sorted by their starting position.\n        // The cars in the two lists\
    \ are assumed to be sorted by their starting position.\n        // The cars in\
    \ the two lists are assumed to be sorted by their starting position.\n       \
    \ // The cars in the two lists are assumed to be sorted by their starting position.\n\
    \        // The cars in the two lists are assumed to be sorted by their starting\
    \ position.\n        // The cars in the two lists are assumed to be sorted by\
    \ their starting position.\n        // The cars in the two", "        // The idea\
    \ is to sort the cars by their starting positions.\n        // Then, we can just\
    \ count the number of cars that are moving in the same direction.\n        //\
    \ This is because the cars that are moving in the same direction will collide.\n\
    \        // The cars that are moving in opposite directions will not collide.\n\
    \        // The cars that are moving in the same direction will collide if and\
    \ only if\n        // they are in the same position.\n        // The cars that\
    \ are moving in the same direction will collide if and only if\n        // they\
    \ are in the same position.\n        // The cars that are moving in the same direction\
    \ will collide if and only if\n        // they are in the same position.\n   \
    \     // The cars that are moving in the same direction will collide if and only\
    \ if\n        // they are in the same position.\n        // The cars that are\
    \ moving in the same direction will collide if and only if\n        // they are\
    \ in the same position.\n        // The cars that are moving in the same direction\
    \ will collide if and only if\n        // they are in the same position.\n   \
    \     // The cars that are moving in the same direction will collide if and only\
    \ if\n        // they are in the same position.\n        // The cars that are\
    \ moving in the same direction will collide if and only if\n        // they are\
    \ in the same position.\n        // The cars that are moving in the same direction\
    \ will collide if and only if\n        // they are in the same position.\n   \
    \     // The cars that are moving in the same direction will collide if and only\
    \ if\n        // they are in the same position.\n        // The cars that are\
    \ moving in the same direction will collide if and only if\n        // they are\
    \ in the same position.\n        // The cars that are moving in the same direction\
    \ will collide if and only if\n        // they are in the same position.\n   \
    \     // The cars that are moving in the same direction will collide if and only\
    \ if\n        // they are in the same position.\n        // The cars that are\
    \ moving in the same direction will collide if and only if\n        // they are\
    \ in the same position.\n        // The cars that are moving in the same direction\
    \ will collide if and only if\n        // they are in the same position.\n   \
    \     // The cars that are moving in the same direction will collide if and only\
    \ if\n        // they are", "        // The idea is to sort the cars by their\
    \ starting position.  Then, we can\n        // just iterate through the cars and\
    \ count the number of collisions.\n        // The cars are sorted by their starting\
    \ position.  The first n cars are\n        // moving left to right, and the last\
    \ n cars are moving right to left.\n        val cars = new Array[Long](2 * n.toInt)\n\
    \        for (i <- 0 until n.toInt) cars(i) = i\n        for (i <- n.toInt until\
    \ 2 * n.toInt) cars(i) = 2 * n - i - 1\n        // Sort the cars by their starting\
    \ position.\n        scala.util.Sorting.quickSort(cars)\n        // Count the\
    \ number of collisions.\n        var collisions = 0L\n        for (i <- 0 until\
    \ n.toInt) {\n            for (j <- n.toInt until 2 * n.toInt) {\n           \
    \     if (cars(i) > cars(j)) collisions += 1\n            }\n        }\n     \
    \   collisions", "        // The idea is to sort the positions of the cars and\
    \ then count the number of collisions.\n        // The number of collisions is\
    \ the number of pairs of cars that are at the same position.\n        // The number\
    \ of pairs of cars at the same position is the number of cars at that position\n\
    \        // minus 1.  So, we can count the number of collisions by counting the\
    \ number of cars at each\n        // position and then subtracting 1 from each\
    \ count.\n        // The number of cars at each position is the number of cars\
    \ that start at that position\n        // plus the number of cars that start at\
    \ that position.\n        // The number of cars that start at each position is\
    \ the number of cars that start at that\n        // position and move left to\
    \ right plus the number of cars that start at that position and\n        // move\
    \ right to left.\n        // The number of cars that start at each position and\
    \ move left to right is the number of\n        // cars that start at that position\
    \ and move left to right plus the number of cars that\n        // start at that\
    \ position and move right to left.\n        // The number of cars that start at\
    \ each position and move right to left is the number of\n        // cars that\
    \ start at that position and move left to right plus the number of cars that\n\
    \        // start at that position and move right to left.\n        // So, the\
    \ number of cars at each position is the number of cars that start at that position\n\
    \        // and move left to right plus the number of cars that start at that\
    \ position and move right\n        // to left.\n        // The number of cars\
    \ that start at each position and move left to right is the number of\n      \
    \  // cars that start at that position and move left to right plus the number\
    \ of cars that\n        // start at that position and move right to left.\n  \
    \      // The number of cars that start at each position and move right to left\
    \ is the number of\n        // cars that start at that position and move left\
    \ to right plus the number of cars that\n        // start at that position and\
    \ move right to left.\n        // So, the number of cars at each position is the\
    \ number of cars that start at that position\n        // and move left to right\
    \ plus the number of cars that start at that position and move right\n       \
    \ // to left.\n        // The number of cars that start at each position and move\
    \ left", "        // The idea is to sort the cars by their starting positions.\n\
    \        // Then, for each car, we can compute the time it takes for it to collide\
    \ with\n        // the next car.  We can then sum up all these times.\n      \
    \  // The time it takes for a car to collide with the next car is\n        //\
    \ (distance between the two cars) / (difference in speed between the two cars)\n\
    \        // We can compute the distance between the two cars by subtracting the\n\
    \        // starting positions of the two cars.\n        // We can compute the\
    \ difference in speed between the two cars by subtracting\n        // the speeds\
    \ of the two cars.\n        // The time it takes for a car to collide with the\
    \ next car is\n        // (distance between the two cars) / (difference in speed\
    \ between the two cars)\n        // = (starting position of the next car - starting\
    \ position of the current car) /\n        //   (speed of the next car - speed\
    \ of the current car)\n        // = (starting position of the next car - starting\
    \ position of the current car) /\n        //   (speed of the next car - speed\
    \ of the current car)\n        // = (starting position of the next car - starting\
    \ position of the current car) /\n        //   (speed of the next car - speed\
    \ of the current car)\n        // = (starting position of the next car - starting\
    \ position of the current car) /\n        //   (speed of the next car - speed\
    \ of the current car)\n        // = (starting position of the next car - starting\
    \ position of the current car) /\n        //   (speed of the next car - speed\
    \ of the current car)\n        // = (starting position of the next car - starting\
    \ position of the current car) /\n        //   (speed of the next car - speed\
    \ of the current car)\n        // = (starting position of the next car - starting\
    \ position of the current car) /\n        //   (speed of the next car - speed\
    \ of the current car)\n        // = (starting position of the next car - starting\
    \ position of the current car) /\n        //   (speed of the next car - speed\
    \ of the current car)\n        // = (starting position of the next car - starting\
    \ position of the current car) /\n        //   (speed of the next car - speed\
    \ of the", "        // The idea is to sort the cars by their starting position.\n\
    \        // Then, we can iterate through the cars and count the number of collisions.\n\
    \        // The number of collisions is the number of cars that are to the left\
    \ of the current car.\n        // This is because the cars to the left of the\
    \ current car are moving right to left,\n        // and the current car is moving\
    \ left to right.\n        // The total number of collisions is the sum of the\
    \ number of collisions for each car.\n        // The number of collisions for\
    \ each car is the number of cars to the left of the current car.\n        // The\
    \ number of cars to the left of the current car is the current car's index.\n\
    \        // The total number of collisions is the sum of the indices of the cars.\n\
    \        // The sum of the indices of the cars is the sum of the first n natural\
    \ numbers.\n        // The sum of the first n natural numbers is n * (n + 1) /\
    \ 2.\n        n * (n + 1) / 2", "        // The cars are numbered from 1 to n.\
    \  The cars moving left to right are numbered\n        // from 1 to n; the cars\
    \ moving right to left are numbered from n to 1.\n        // The cars moving left\
    \ to right are at positions x1, x2, ..., xn, where x1 < x2 < ... < xn.\n     \
    \   // The cars moving right to left are at positions y1, y2, ..., yn, where y1\
    \ > y2 > ... > yn.\n        // The cars move at the same speed.  The cars moving\
    \ left to right move at speed 1.\n        // The cars moving right to left move\
    \ at speed -1.\n        // The cars are infinitely sturdy and strong; as a result,\
    \ they continue moving\n        // in their trajectory as if they did not collide.\n\
    \        // This function outputs the number of such collisions.\n        //\n\
    \        // We can solve this problem by using a sweep line algorithm.\n     \
    \   // The sweep line algorithm is as follows:\n        // 1. We sort the cars\
    \ by their position.\n        // 2. We sweep the line from left to right.\n  \
    \      // 3. We keep track of the cars that are currently on the left side of\
    \ the line.\n        // 4. When we encounter a car moving left to right, we add\
    \ it to the set of cars\n        //    on the left side of the line.\n       \
    \ // 5. When we encounter a car moving right to left, we remove it from the set\
    \ of cars\n        //    on the left side of the line.\n        // 6. When we\
    \ encounter a car moving left to right, we count the number of cars\n        //\
    \    on the left side of the line.  This is the number of cars that the car\n\
    \        //    moving left to right will collide with.\n        // 7. When we\
    \ encounter a car moving right to left, we count the number of cars\n        //\
    \    on the left side of the line.  This is the number of cars that the car\n\
    \        //    moving right to left will collide with.\n        // 8. We add up\
    \ the number of collisions that we counted in steps 6 and 7.\n        //    This\
    \ is the total number of collisions.\n        //\n        // We can use a priority\
    \ queue to implement the sweep line algorithm.\n        // The priority queue\
    \ will be sorted", "        // The idea is to use a sweep line algorithm.\n  \
    \      // We will use a priority queue to keep track of the cars that are moving\
    \ left to right.\n        // We will use a priority queue to keep track of the\
    \ cars that are moving right to left.\n        // We will use a priority queue\
    \ to keep track of the cars that are moving left to right.\n        // We will\
    \ use a priority queue to keep track of the cars that are moving right to left.\n\
    \        // We will use a priority queue to keep track of the cars that are moving\
    \ left to right.\n        // We will use a priority queue to keep track of the\
    \ cars that are moving right to left.\n        // We will use a priority queue\
    \ to keep track of the cars that are moving left to right.\n        // We will\
    \ use a priority queue to keep track of the cars that are moving right to left.\n\
    \        // We will use a priority queue to keep track of the cars that are moving\
    \ left to right.\n        // We will use a priority queue to keep track of the\
    \ cars that are moving right to left.\n        // We will use a priority queue\
    \ to keep track of the cars that are moving left to right.\n        // We will\
    \ use a priority queue to keep track of the cars that are moving right to left.\n\
    \        // We will use a priority queue to keep track of the cars that are moving\
    \ left to right.\n        // We will use a priority queue to keep track of the\
    \ cars that are moving right to left.\n        // We will use a priority queue\
    \ to keep track of the cars that are moving left to right.\n        // We will\
    \ use a priority queue to keep track of the cars that are moving right to left.\n\
    \        // We will use a priority queue to keep track of the cars that are moving\
    \ left to right.\n        // We will use a priority queue to keep track of the\
    \ cars that are moving right to left.\n        // We will use a priority queue\
    \ to keep track of the cars that are moving left to right.\n        // We will\
    \ use a priority queue to keep track of the cars that are moving right to left.\n\
    \        // We will use a priority queue to keep track of the cars that are moving\
    \ left to right.\n        // We will use a priority queue to keep track of the\
    \ cars that are moving right to left.\n        // We will use a priority queue\
    \ to keep track of the cars", "        // This is a very simple problem.  We can\
    \ just simulate the cars moving.\n        // We can do this in O(n^2) time.\n\
    \        // However, this is a very simple problem, so we can do better.\n   \
    \     // We can do this in O(n) time.\n        // The key observation is that\
    \ the cars are moving in the same speed.\n        // As a result, the cars that\
    \ collide are the cars that are closest to each other.\n        // We can use\
    \ a priority queue to keep track of the closest cars.\n        // We can do this\
    \ in O(n) time.\n        val pq = new PriorityQueue[(Long, Boolean)]()(Ordering.by(-_._1))\n\
    \        for (i <- 1 to n.toInt) {\n            pq.enqueue((i, true))\n      \
    \      pq.enqueue((i, false))\n        }\n        var count = 0\n        while\
    \ (pq.size > 1) {\n            val (x, isLeft) = pq.dequeue\n            val (y,\
    \ isRight) = pq.dequeue\n            if (isLeft != isRight) count += 1\n     \
    \       pq.enqueue((x, isLeft))\n            pq.enqueue((y, isRight))\n      \
    \  }\n        count", "        // The idea is to sort the cars by their starting\
    \ position.\n        // Then, we can just count the number of cars that are moving\
    \ left to right\n        // and the number of cars that are moving right to left.\n\
    \        // The number of collisions is the product of these two numbers.\n  \
    \      val cars = new Array[Long](2 * n.toInt)\n        for (i <- 0 until n.toInt)\
    \ {\n            cars(i) = i\n            cars(i + n.toInt) = -i\n        }\n\
    \        scala.util.Sorting.quickSort(cars)\n        var left = 0\n        var\
    \ right = 0\n        for (i <- 0 until cars.length) {\n            if (cars(i)\
    \ >= 0) left += 1\n            else right += 1\n        }\n        left * right",
  "        // The idea is to sort the cars by their starting position.\n        //\
    \ Then, we can count the number of collisions by counting the number of cars\n\
    \        // that are moving left to right that are to the left of a car that's\
    \ moving\n        // right to left.\n        //\n        // We can do this by\
    \ using a Fenwick tree.\n        // We insert the cars moving left to right into\
    \ the Fenwick tree.\n        // Then, we insert the cars moving right to left\
    \ into the Fenwick tree.\n        // We count the number of cars moving left to\
    \ right that are to the left of a car\n        // moving right to left by using\
    \ the Fenwick tree's prefix sum function.\n        //\n        // The total number\
    \ of collisions is the sum of the number of collisions for each car\n        //\
    \ moving right to left.\n        //\n        // The total time complexity is O(n\
    \ log n).\n        val fenwickTree = new FenwickTree(n)\n        val cars = new\
    \ Array[(Long, Boolean)](2 * n.toInt)\n        for (i <- 0 until n.toInt) {\n\
    \            cars(i) = (i, true)\n            cars(i + n.toInt) = (i, false)\n\
    \        }\n        cars.sortBy(x => x._1)\n        var collisions = 0L\n    \
    \    for (i <- 0 until 2 * n.toInt) {\n            if (cars(i)._2) fenwickTree.insert(cars(i)._1.toInt)\n\
    \            else collisions += fenwickTree.prefixSum(cars(i)._1.toInt)\n    \
    \    }\n        collisions", "        // This is a very simple problem.  The key\
    \ is to realize that the cars are\n        // moving at the same speed.  As a\
    \ result, the first car that starts moving\n        // left to right will collide\
    \ with the first car that starts moving right to left.\n        // The second\
    \ car that starts moving left to right will collide with the second\n        //\
    \ car that starts moving right to left.  And so on.\n        // As a result, the\
    \ number of collisions is simply the number of cars.\n        n", "        val\
    \ n2 = n * n\n        val n3 = n2 * n\n        val n4 = n3 * n\n        val n5\
    \ = n4 * n\n        val n6 = n5 * n\n        val n7 = n6 * n\n        val n8 =\
    \ n7 * n\n        val n9 = n8 * n\n        val n10 = n9 * n\n        val n11 =\
    \ n10 * n\n        val n12 = n11 * n\n        val n13 = n12 * n\n        val n14\
    \ = n13 * n\n        val n15 = n14 * n\n        val n16 = n15 * n\n        val\
    \ n17 = n16 * n\n        val n18 = n17 * n\n        val n19 = n18 * n\n      \
    \  val n20 = n19 * n\n        val n21 = n20 * n\n        val n22 = n21 * n\n \
    \       val n23 = n22 * n\n        val n24 = n23 * n\n        val n25 = n24 *\
    \ n\n        val n26 = n25 * n\n        val n27 = n26 * n\n        val n28 = n27\
    \ * n\n        val n29 = n28 * n\n        val n30 = n29 * n\n        val n31 =\
    \ n30 * n\n        val n32 = n31 * n\n        val n33 = n32 * n\n        val n34\
    \ = n33 * n\n        val n35 = n34 * n\n        val n36 = n35 * n\n        val\
    \ n37 = n36 * n\n        val n38 = n37 * n\n        val n39 = n38 * n\n      \
    \  val n40 = n39 * n\n        val n41 = n40 * n\n        val n42 = n41 * n\n \
    \       val n43 = n42 * n\n        val n44 = n43 * n\n        val n45 = n44 *\
    \ n\n        val n46 = n45 * n\n        val n47 = n46 * n\n        val n48 = n47\
    \ * n\n        val n49 = n48 * n\n        val n50 = n49 * n\n        val n51 =\
    \ n50 * n\n        val n52 = n51 * n\n        val", "        // The idea is that\
    \ we can sort the cars by their starting position.\n        // Then, we can iterate\
    \ through the cars from left to right, and keep track of the\n        // number\
    \ of cars that are moving right to left that are to the left of the car\n    \
    \    // we are currently iterating through.  This number is the number of collisions\n\
    \        // that the car we are currently iterating through has.\n        val\
    \ cars = Array.ofDim[Long](2 * n.toInt)\n        for (i <- 0 until n.toInt) {\n\
    \            cars(i) = i\n            cars(i + n.toInt) = -i\n        }\n    \
    \    scala.util.Sorting.quickSort(cars)\n        var collisions = 0L\n       \
    \ var leftCars = 0\n        for (i <- 0 until 2 * n.toInt) {\n            if (cars(i)\
    \ < 0) leftCars += 1\n            else collisions += leftCars\n        }\n   \
    \     collisions", "        // The idea is to sort the cars by their starting\
    \ position.\n        // Then, we can just iterate through the cars and count the\
    \ number of cars\n        // that are moving in the opposite direction.\n    \
    \    // The time complexity is O(n log n).\n        val cars = Array.fill(n.toInt)(0)\n\
    \        for (i <- 0 until n.toInt) cars(i) = i\n        val sortedCars = cars.sortWith((a,\
    \ b) => a < b)\n        var result = 0L\n        for (i <- 0 until n.toInt) {\n\
    \            val car = sortedCars(i)\n            if (car < n - car) result +=\
    \ car\n            else result += n - car - 1\n        }\n        result"]
stop_tokens:
- "\n    }\n"
