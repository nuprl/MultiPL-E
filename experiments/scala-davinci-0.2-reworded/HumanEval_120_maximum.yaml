name: HumanEval_120_maximum
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Given a list arr of integers and a positive integer k, return a sorted list\
  \ \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n \
  \   // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    //\
  \ (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>>\
  \ maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong,\
  \ 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong,\
  \ 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n\
  \    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n\
  \    // 2. The elements in the list will be in the range of [-1000, 1000].\n   \
  \ // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long]\
  \ = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
  \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
  \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
  \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
  \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
  \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
  \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
  \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
  \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
  \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
  \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
  \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong,\
  \ 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong,\
  \ 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong,\
  \ -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong,\
  \ -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong,\
  \ 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
  \    }\n\n}\n"
completions: ["        // Fill up this function body\n        // `arr` is a list of\
    \ integers\n        // `k` is a positive integer\n        // You have to return\
    \ a sorted list of length `k` with the maximum k numbers in `arr`\n        //\
    \ You can assume that `k` is less than or equal to the length of `arr`\n     \
    \   // You can assume that `k` is greater than 0\n        arr.sorted.takeRight(k.toInt)",
  "        // Fill up this function body\n        // `arr` is a list of integers\n\
    \        // `k` is a positive integer\n        // You have to return a sorted\
    \ list of length `k` with the maximum k numbers in `arr`\n        // You can assume\
    \ that `k` is less than or equal to the length of `arr`\n        // You can assume\
    \ that `k` is greater than 0\n        // You can assume that `arr` is not empty\n\
    \        // You can assume that `arr` is not null\n        // You can assume that\
    \ `arr` does not contain null\n        // You can assume that `arr` does not contain\
    \ duplicates\n        // You can assume that `arr` contains only integers\n  \
    \      // You can assume that `arr` contains only positive integers\n        //\
    \ You can assume that `arr` contains only negative integers\n        // You can\
    \ assume that `arr` contains only non-zero integers\n        // You can assume\
    \ that `arr` contains only zero\n        // You can assume that `arr` contains\
    \ only non-positive integers\n        // You can assume that `arr` contains only\
    \ non-negative integers\n        // You can assume that `arr` is sorted in ascending\
    \ order\n        // You can assume that `arr` is sorted in descending order\n\
    \        // You can assume that `arr` is not sorted\n        // You can assume\
    \ that `arr` is sorted in ascending order when `k` is equal to 1\n        // You\
    \ can assume that `arr` is sorted in descending order when `k` is equal to 1\n\
    \        // You can assume that `arr` is sorted in ascending order when `k` is\
    \ equal to the length of `arr`\n        // You can assume that `arr` is sorted\
    \ in descending order when `k` is equal to the length of `arr`\n        // You\
    \ can assume that `arr` is sorted in ascending order when `k` is equal to the\
    \ length of `arr` minus 1\n        // You can assume that `arr` is sorted in descending\
    \ order when `k` is equal to the length of `arr` minus 1\n        // You can assume\
    \ that `arr` is sorted in ascending order when `k` is equal to the length of `arr`\
    \ plus 1\n        // You can assume that `arr` is sorted in descending order when\
    \ `k` is equal to the length of `arr` plus 1\n", "        val heap = new PriorityQueue[Long]()(Ordering.by(-_))\n\
    \        for (i <- arr) {\n            heap.enqueue(i)\n            if (heap.size\
    \ > k) heap.dequeue\n        }\n        heap.toList.sorted", "        // Fill\
    \ up this function body\n        // `arr` is a list of integers\n        // `k`\
    \ is a positive integer\n        // You have to return a sorted list of length\
    \ `k` with the maximum k numbers in `arr`\n        // You can use the function\
    \ `sort` to sort a list\n        // You can use the function `take` to take the\
    \ first `k` elements of a list\n        // You can use the function `reverse`\
    \ to reverse a list\n        // You can use the function `max` to find the maximum\
    \ of a list\n        // You can use the function `min` to find the minimum of\
    \ a list\n        // You can use the function `abs` to find the absolute value\
    \ of a number\n        // You can use the function `sum` to find the sum of a\
    \ list\n        // You can use the function `product` to find the product of a\
    \ list\n        // You can use the function `contains` to check if a list contains\
    \ a number\n        // You can use the function `mkString` to convert a list to\
    \ a string\n        // You can use the function `toString` to convert a number\
    \ to a string\n        // You can use the function `toLong` to convert a string\
    \ to a long\n        // You can use the function `toInt` to convert a string to\
    \ an integer\n        // You can use the function `toDouble` to convert a string\
    \ to a double\n        // You can use the function `toFloat` to convert a string\
    \ to a float\n        // You can use the function `toChar` to convert a string\
    \ to a character\n        // You can use the function `toByte` to convert a string\
    \ to a byte\n        // You can use the function `toShort` to convert a string\
    \ to a short\n        // You can use the function `toBoolean` to convert a string\
    \ to a boolean\n        // You can use the function `toList` to convert a string\
    \ to a list\n        // You can use the function `toArray` to convert a string\
    \ to an array\n        // You can use the function `toMap` to convert a string\
    \ to a map\n        // You can use the function `toSet` to convert a string to\
    \ a set\n        // You can use the function `toBuffer` to convert a string to\
    \ a buffer\n        // You can use the function `to", "        // Fill up this\
    \ function body\n        // `arr` is a list of integers\n        // `k` is a positive\
    \ integer\n        // You have to return a sorted list of length `k` with the\
    \ maximum k numbers in `arr`\n        // You can assume that `k` is less than\
    \ or equal to the length of `arr`\n        // You can assume that `k` is greater\
    \ than 0\n        arr.sortWith(_ > _).take(k.toInt)", "        // We can use a\
    \ max heap to solve this problem.\n        // We can use a max heap to solve this\
    \ problem.\n        // We can use a max heap to solve this problem.\n        //\
    \ We can use a max heap to solve this problem.\n        // We can use a max heap\
    \ to solve this problem.\n        // We can use a max heap to solve this problem.\n\
    \        // We can use a max heap to solve this problem.\n        // We can use\
    \ a max heap to solve this problem.\n        // We can use a max heap to solve\
    \ this problem.\n        // We can use a max heap to solve this problem.\n   \
    \     // We can use a max heap to solve this problem.\n        // We can use a\
    \ max heap to solve this problem.\n        // We can use a max heap to solve this\
    \ problem.\n        // We can use a max heap to solve this problem.\n        //\
    \ We can use a max heap to solve this problem.\n        // We can use a max heap\
    \ to solve this problem.\n        // We can use a max heap to solve this problem.\n\
    \        // We can use a max heap to solve this problem.\n        // We can use\
    \ a max heap to solve this problem.\n        // We can use a max heap to solve\
    \ this problem.\n        // We can use a max heap to solve this problem.\n   \
    \     // We can use a max heap to solve this problem.\n        // We can use a\
    \ max heap to solve this problem.\n        // We can use a max heap to solve this\
    \ problem.\n        // We can use a max heap to solve this problem.\n        //\
    \ We can use a max heap to solve this problem.\n        // We can use a max heap\
    \ to solve this problem.\n        // We can use a max heap to solve this problem.\n\
    \        // We can use a max heap to solve this problem.\n        // We can use\
    \ a max heap to solve this problem.\n        // We can use a max heap to solve\
    \ this problem.\n        // We can use a max heap to solve this problem.\n   \
    \     // We can use a max heap to solve this problem.\n        // We can use a\
    \ max heap to solve this problem.\n        // We can use a max heap to solve this\
    \ problem.\n        // We can use a max heap to solve this problem.\n        //\
    \ We can use a max", "        // Fill up this function body\n        // `arr`\
    \ is a list of integers\n        // `k` is a positive integer\n        // You\
    \ have to return a sorted list of length `k` with the maximum k numbers in `arr`\n\
    \        // You can assume that `k` is less than or equal to the length of `arr`\n\
    \        // You can assume that `k` is greater than 0\n        arr.sortWith(_\
    \ > _).take(k.toInt)", "        // Fill up this function body\n        // `arr`\
    \ is a list of integers\n        // `k` is a positive integer\n        // Return\
    \ a sorted list of length `k` with the maximum `k` numbers in `arr`\n        arr.sorted.takeRight(k.toInt)",
  "        // Fill up this function body\n        // `arr` is a list of integers\n\
    \        // `k` is a positive integer\n        // return a sorted list of length\
    \ `k` with the maximum `k` numbers in `arr`\n        arr.sortWith(_ > _).take(k.toInt)",
  "        // Fill up this function body\n        // 'arr' is a list of integers\n\
    \        // 'k' is a positive integer\n        // Return a sorted list of length\
    \ 'k' with the maximum 'k' numbers in 'arr'\n        arr.sorted.takeRight(k.toInt)",
  "        // Define a function to get the maximum number in the list.\n        def\
    \ maximum(arr : List[Long]) : Long = {\n            arr.max\n        }\n     \
    \   // Define a function to get the index of the maximum number in the list.\n\
    \        def maximumIndex(arr : List[Long]) : Int = {\n            arr.indexOf(arr.max)\n\
    \        }\n        // Define a function to remove the maximum number in the list.\n\
    \        def removeMaximum(arr : List[Long]) : List[Long] = {\n            arr.patch(maximumIndex(arr),\
    \ Nil, 1)\n        }\n        // Define a function to get the maximum k numbers\
    \ in the list.\n        def maximum(arr : List[Long], k : Long) : List[Long] =\
    \ {\n            if (k == 0) {\n                Nil\n            } else {\n  \
    \              maximum(arr) :: maximum(removeMaximum(arr), k - 1)\n          \
    \  }\n        }\n        // Return the result.\n        maximum(arr, k).sorted",
  "        // Fill up this function body\n        // `arr` is a list of integers\n\
    \        // `k` is a positive integer\n        // You have to return a sorted\
    \ list of length `k` with the maximum k numbers in `arr`\n        // You can assume\
    \ that `k` is less than or equal to the length of `arr`\n        // You can assume\
    \ that `k` is greater than 0\n        arr.sorted.takeRight(k.toInt)", "      \
    \  // We can use a heap to solve this problem.\n        // We can use a min heap\
    \ to store the k largest elements.\n        // We can use a max heap to store\
    \ the k smallest elements.\n        // We can use a min heap to store the k largest\
    \ elements.\n        // We can use a max heap to store the k smallest elements.\n\
    \        // We can use a min heap to store the k largest elements.\n        //\
    \ We can use a max heap to store the k smallest elements.\n        // We can use\
    \ a min heap to store the k largest elements.\n        // We can use a max heap\
    \ to store the k smallest elements.\n        // We can use a min heap to store\
    \ the k largest elements.\n        // We can use a max heap to store the k smallest\
    \ elements.\n        // We can use a min heap to store the k largest elements.\n\
    \        // We can use a max heap to store the k smallest elements.\n        //\
    \ We can use a min heap to store the k largest elements.\n        // We can use\
    \ a max heap to store the k smallest elements.\n        // We can use a min heap\
    \ to store the k largest elements.\n        // We can use a max heap to store\
    \ the k smallest elements.\n        // We can use a min heap to store the k largest\
    \ elements.\n        // We can use a max heap to store the k smallest elements.\n\
    \        // We can use a min heap to store the k largest elements.\n        //\
    \ We can use a max heap to store the k smallest elements.\n        // We can use\
    \ a min heap to store the k largest elements.\n        // We can use a max heap\
    \ to store the k smallest elements.\n        // We can use a min heap to store\
    \ the k largest elements.\n        // We can use a max heap to store the k smallest\
    \ elements.\n        // We can use a min heap to store the k largest elements.\n\
    \        // We can use a max heap to store the k smallest elements.\n        //\
    \ We can use a min heap to store the k largest elements.\n        // We can use\
    \ a max heap to store the k smallest elements.\n        // We can use a min heap\
    \ to store the k largest elements.\n        // We can use a max heap to store\
    \ the k smallest elements.\n        // We can use a min heap to store the k largest\
    \ elements.\n        //", "        // Fill up this function body\n        // 'return\
    \ List[Long]()' in case of timeout or other internal errors\n        return List[Long]()",
  "        // Fill up this function body\n        // `arr` is a list of integers\n\
    \        // `k` is a positive integer\n        // return a sorted list of length\
    \ `k` with the maximum `k` numbers in `arr`\n        arr.sorted.takeRight(k.toInt)",
  "        // Define a function that returns the maximum element in a list.\n    \
    \    def maximum(arr : List[Long]) : Long = {\n            // If the list is empty,\
    \ return 0.\n            if (arr.isEmpty) {\n                return 0l\n     \
    \       }\n            // Otherwise, return the maximum element in the list.\n\
    \            else {\n                return arr.max\n            }\n        }\n\
    \        // Define a function that removes the maximum element in a list.\n  \
    \      def removeMaximum(arr : List[Long]) : List[Long] = {\n            // If\
    \ the list is empty, return an empty list.\n            if (arr.isEmpty) {\n \
    \               return List[Long]()\n            }\n            // Otherwise,\
    \ remove the maximum element in the list.\n            else {\n              \
    \  return arr.filter((x : Long) => x != arr.max)\n            }\n        }\n \
    \       // Define a function that returns the maximum k elements in a list.\n\
    \        def maximum(arr : List[Long], k : Long) : List[Long] = {\n          \
    \  // If k is 0, return an empty list.\n            if (k == 0l) {\n         \
    \       return List[Long]()\n            }\n            // Otherwise, return the\
    \ maximum element in the list, followed by the maximum k - 1 elements in the list.\n\
    \            else {\n                return maximum(arr) :: maximum(removeMaximum(arr),\
    \ k - 1l)\n            }\n        }\n        // Return the maximum k elements\
    \ in the list.\n        return maximum(arr, k)", "        // Fill up this function\
    \ body\n        // 'return List[Long]()' for Scala and 'return {}' for Java\n\
    \        return List[Long]()", "        // Fill up this function body\n      \
    \  // 'arr' is a list of integers\n        // 'k' is a positive integer\n    \
    \    // Return a sorted list of length 'k' with the maximum 'k' numbers in 'arr'\n\
    \        arr.sorted.takeRight(k.toInt)", "        def maximum0(arr : List[Long],\
    \ k : Long, acc : List[Long]) : List[Long] = {\n            if (k == 0) acc\n\
    \            else {\n                val max = arr.max\n                val index\
    \ = arr.indexOf(max)\n                maximum0(arr.take(index) ++ arr.drop(index\
    \ + 1), k - 1, acc :+ max)\n            }\n        }\n        maximum0(arr, k,\
    \ List[Long]())", "        // Fill up this function body\n        // `arr` is\
    \ a list of integers\n        // `k` is a positive integer\n        // return\
    \ a sorted list of length `k` with the maximum `k` numbers in `arr`\n        arr.sorted.takeRight(k.toInt)",
  "        // Fill up this function body\n        // 'return List[Long]()' in case\
    \ of timeout or other internal errors\n        return List[Long]()", "       \
    \ // Fill up this function body\n        // You can add another function as well,\
    \ if required\n        arr.sorted.takeRight(k.toInt)", "        // Fill up this\
    \ function body\n        // `arr` is a list of integers\n        // `k` is a positive\
    \ integer\n        // You have to return a sorted list of length `k` with the\
    \ maximum k numbers in `arr`\n        // You can assume that `k` is less than\
    \ or equal to the length of `arr`\n        // You can assume that `k` is greater\
    \ than 0\n        // You can assume that `arr` is not empty\n        // You can\
    \ assume that `arr` is not null\n        // You can assume that `arr` does not\
    \ contain null elements\n        // You can assume that `arr` is not a list of\
    \ strings\n        // You can assume that `arr` is not a list of characters\n\
    \        // You can assume that `arr` is not a list of booleans\n        // You\
    \ can assume that `arr` is not a list of floats\n        // You can assume that\
    \ `arr` is not a list of doubles\n        // You can assume that `arr` is not\
    \ a list of tuples\n        // You can assume that `arr` is not a list of lists\n\
    \        // You can assume that `arr` is not a list of sets\n        // You can\
    \ assume that `arr` is not a list of maps\n        // You can assume that `arr`\
    \ is not a list of arrays\n        // You can assume that `arr` is not a list\
    \ of objects\n        // You can assume that `arr` is not a list of functions\n\
    \        // You can assume that `arr` is not a list of classes\n        // You\
    \ can assume that `arr` is not a list of traits\n        // You can assume that\
    \ `arr` is not a list of interfaces\n        // You can assume that `arr` is not\
    \ a list of enums\n        // You can assume that `arr` is not a list of structs\n\
    \        // You can assume that `arr` is not a list of unions\n        // You\
    \ can assume that `arr` is not a list of unions\n        // You can assume that\
    \ `arr` is not a list of unions\n        // You can assume that `arr` is not a\
    \ list of unions\n        // You can assume that `arr` is not a list of unions\n\
    \        // You can assume that `arr` is not a list of unions\n        // You\
    \ can assume that `arr", "        // We can use a max heap to solve this problem.\n\
    \        // The max heap will contain the k largest elements.\n        // We will\
    \ iterate through the list and add each element to the heap.\n        // If the\
    \ heap is full, we will remove the smallest element from the heap.\n        //\
    \ At the end, we will return the heap as a sorted list.\n        // The time complexity\
    \ is O(n * log(k)) and the space complexity is O(k).\n        val heap = new mutable.PriorityQueue[Long]()\n\
    \        for (elem <- arr) {\n            heap.enqueue(elem)\n            if (heap.size\
    \ > k) heap.dequeue\n        }\n        heap.toList.sorted", "        // Fill\
    \ up this function body\n        // 'return List[Long]()' in case of timeout or\
    \ error\n        return List[Long]()", "        // We can use a heap to solve\
    \ this problem in O(n log k) time.\n        // First, we insert the first k elements\
    \ of the array into a max heap.\n        // Then, for each of the remaining elements,\
    \ we compare it to the root of the heap.\n        // If the element is greater\
    \ than the root, we replace the root with the element.\n        // Otherwise,\
    \ we ignore the element.\n        // After we have processed all of the elements,\
    \ we return the heap.\n        // This solution runs in O(n log k) time and O(k)\
    \ space.\n        val heap = new PriorityQueue[Long]()(Ordering.by(-_))\n    \
    \    for (i <- 0 until k.toInt) {\n            heap.enqueue(arr(i))\n        }\n\
    \        for (i <- k.toInt until arr.length) {\n            if (arr(i) > heap.head)\
    \ {\n                heap.dequeue\n                heap.enqueue(arr(i))\n    \
    \        }\n        }\n        heap.toList", "        // Fill up this function\
    \ body\n        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // You have to return a sorted list of length `k` with the maximum k\
    \ numbers in `arr`\n        // You can assume that `k` is less than or equal to\
    \ the length of `arr`\n        // You can assume that `k` is greater than 0\n\
    \        // You can assume that `arr` is not empty\n        // You can assume\
    \ that `arr` is not null\n        // You can assume that `arr` does not contain\
    \ null elements\n        // You can assume that `arr` does not contain duplicates\n\
    \        // You can assume that `arr` is sorted in non-decreasing order\n    \
    \    // You can assume that `arr` contains only positive integers\n        //\
    \ You can assume that `arr` contains only integers\n        // You can assume\
    \ that `arr` contains only numbers\n        // You can assume that `arr` contains\
    \ only real numbers\n        // You can assume that `arr` contains only rational\
    \ numbers\n        // You can assume that `arr` contains only algebraic numbers\n\
    \        // You can assume that `arr` contains only complex numbers\n        //\
    \ You can assume that `arr` contains only transcendental numbers\n        // You\
    \ can assume that `arr` contains only natural numbers\n        // You can assume\
    \ that `arr` contains only integers\n        // You can assume that `arr` contains\
    \ only whole numbers\n        // You can assume that `arr` contains only non-negative\
    \ integers\n        // You can assume that `arr` contains only positive integers\n\
    \        // You can assume that `arr` contains only non-positive integers\n  \
    \      // You can assume that `arr` contains only negative integers\n        //\
    \ You can assume that `arr` contains only non-zero integers\n        // You can\
    \ assume that `arr` contains only zero\n        // You can assume that `arr` contains\
    \ only non-zero numbers\n        // You can assume that `arr` contains only zero\n\
    \        // You can assume that `arr` contains only non-zero real numbers\n  \
    \      // You can assume that `arr` contains only zero\n        // You can assume\
    \ that `arr` contains only non-zero rational numbers\n        // You can assume\
    \ that `arr` contains only zero\n        // You can assume that `arr` contains\
    \ only non-zero algebraic", "        // Fill up this function body\n        //\
    \ `arr` is a list of integers\n        // `k` is a positive integer\n        //\
    \ You have to return a sorted list of length `k` with the maximum k numbers in\
    \ `arr`\n        // You can assume that `k` is less than or equal to the length\
    \ of `arr`\n        // You can assume that `k` is greater than 0\n        arr.sorted.takeRight(k.toInt)",
  "        // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n        // of length k with the maximum k numbers in arr.\n        //\
    \ Example 1:\n        // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n        // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n        //\
    \ Example 2:\n        // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)),\
    \ (2l))\n        // (List[Long](4l.toLong, 4l.toLong))\n        // Example 3:\n\
    \        // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n        // (List[Long](2l.toLong))\n\
    \        // Note:\n        // 1. The length of the list will be in the range of\
    \ [1, 1000].\n        // 2. The elements in the list will be in the range of [-1000,\
    \ 1000].\n        // 3. 0 <= k <= len(arr)\n        def maximum_helper(arr : List[Long],\
    \ k : Long, acc : List[Long]) : List[Long] = {\n            if (k == 0) {\n  \
    \              acc\n            } else {\n                val max = arr.max\n\
    \                val new_arr = arr.filter(x => x != max)\n                maximum_helper(new_arr,\
    \ k - 1, acc :+ max)\n            }\n        }\n        maximum_helper(arr, k,\
    \ List[Long]())", "        // Fill up this function body\n        // 'result'\
    \ should be a list of length 'k'\n        // 'result' should be sorted in descending\
    \ order\n        // 'result' should contain the maximum k numbers in 'arr'\n \
    \       var result : List[Long] = List[Long]()\n        return result", "    \
    \    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n        // of length k with the maximum k numbers in arr.\n        //\
    \ Example 1:\n        // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n        // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n        //\
    \ Example 2:\n        // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)),\
    \ (2l))\n        // (List[Long](4l.toLong, 4l.toLong))\n        // Example 3:\n\
    \        // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n        // (List[Long](2l.toLong))\n\
    \        // Note:\n        // 1. The length of the list will be in the range of\
    \ [1, 1000].\n        // 2. The elements in the list will be in the range of [-1000,\
    \ 1000].\n        // 3. 0 <= k <= len(arr)\n        def maximum0(arr : List[Long],\
    \ k : Long, acc : List[Long]) : List[Long] = {\n            // This is a tail-recursive\
    \ function.\n            if (k == 0l) {\n                acc\n            } else\
    \ {\n                val (max, arr1) = arr.foldLeft((Long.MinValue, List[Long]()))((t,\
    \ e) => {\n                    if (e > t._1) {\n                        (e, t._2\
    \ :+ e)\n                    } else {\n                        (t._1, t._2 :+\
    \ e)\n                    }\n                })\n                maximum0(arr1.filter((e)\
    \ => e != max), k - 1l, acc :+ max)\n            }\n        }\n        maximum0(arr,\
    \ k, List[Long]())", "        // Fill up this function body\n        // `arr`\
    \ is a list of integers\n        // `k` is a positive integer\n        // You\
    \ have to return a sorted list of length `k` with the maximum k numbers in `arr`\n\
    \        // You can assume that `k` is less than or equal to the length of `arr`\n\
    \        // You can assume that `k` is greater than 0\n        // You can assume\
    \ that `arr` is not empty\n        // You can assume that `arr` is not null\n\
    \        // You can assume that `arr` does not contain null\n        // You can\
    \ assume that `arr` does not contain duplicates\n        // You can assume that\
    \ `arr` is sorted in ascending order\n        // You can assume that `arr` contains\
    \ only positive integers\n        // You can assume that `arr` contains only integers\n\
    \        // You can assume that `arr` contains only numbers\n        // You can\
    \ assume that `arr` contains only longs\n        // You can assume that `arr`\
    \ contains only longs and integers\n        // You can assume that `arr` contains\
    \ only longs, integers, and numbers\n        // You can assume that `arr` contains\
    \ only longs, integers, numbers, and null\n        // You can assume that `arr`\
    \ contains only longs, integers, numbers, null, and duplicates\n        // You\
    \ can assume that `arr` contains only longs, integers, numbers, null, duplicates,\
    \ and ascending order\n        // You can assume that `arr` contains only longs,\
    \ integers, numbers, null, duplicates, ascending order, and positive integers\n\
    \        // You can assume that `arr` contains only longs, integers, numbers,\
    \ null, duplicates, ascending order, positive integers, and k\n        // You\
    \ can assume that `arr` contains only longs, integers, numbers, null, duplicates,\
    \ ascending order, positive integers, k, and arr\n        // You can assume that\
    \ `arr` contains only longs, integers, numbers, null, duplicates, ascending order,\
    \ positive integers, k, arr, and k\n        // You can assume that `arr` contains\
    \ only longs, integers, numbers, null, duplicates, ascending order, positive integers,\
    \ k, arr, k, and arr\n        // You can assume that `arr` contains only longs,\
    \ integers, numbers, null, dupl", "        // Fill up this function body\n   \
    \     // 'return List[Long]()' for Scala and 'return new ArrayList<Long>()' for\
    \ Java\n        return List[Long]()", "        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // return a sorted list of length `k` with the maximum `k` numbers in\
    \ `arr`\n        arr.sorted.takeRight(k.toInt)", "        // Fill up this function\
    \ body\n        // 'return List[Long]()' in case of timeout or internal error\n\
    \        return List[Long]()", "        // Given a list arr of integers and a\
    \ positive integer k, return a sorted list \n        // of length k with the maximum\
    \ k numbers in arr.\n        // Example 1:\n        // >>> maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l))\n        // (List[Long](-4l.toLong, -3l.toLong,\
    \ 5l.toLong))\n        // Example 2:\n        // >>> maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l))\n        // (List[Long](4l.toLong, 4l.toLong))\n\
    \        // Example 3:\n        // >>> maximum((List[Long](-3l.toLong, 2l.toLong,\
    \ 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n        //\
    \ (List[Long](2l.toLong))\n        // Note:\n        // 1. The length of the list\
    \ will be in the range of [1, 1000].\n        // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n        // 3. 0 <= k <= len(arr)\n      \
    \  def maximum(arr : List[Long], k : Long) : List[Long] = {\n            val n\
    \ = arr.length\n            val m = arr.max\n            val p = arr.min\n   \
    \         val q = (m - p) / k\n            val r = (m - p) % k\n            val\
    \ s = (0l to k).map(i => (p + (q * i) + min(i, r))).toList\n            val t\
    \ = s.map(i => (arr.filter(j => (j >= i)).length)).toList\n            val u =\
    \ (0l to k).map(i => (s(i.toInt), t(i.toInt))).toList\n            val v = u.filter(i\
    \ => (i._2 >= (k - i._1 + p))).map(i => (i._1)).toList\n            val w = v.max\n\
    \            val x", "        // Fill up this function body\n        // `arr`\
    \ is a list of integers\n        // `k` is a positive integer\n        // You\
    \ have to return a sorted list of length `k` with the maximum k numbers in `arr`\n\
    \        // You can assume that `k` is less than or equal to the length of `arr`\n\
    \        // You can assume that `k` is greater than 0\n        arr.sorted.takeRight(k.toInt)",
  "        // Fill up this function body\n        // 'return List[Long]()' for Scala\
    \ and 'return new List<Long>()' for Java\n        return List[Long]()", "    \
    \    // Fill up this function body\n        // `arr` is a list of integers\n \
    \       // `k` is a positive integer\n        // You have to return a sorted list\
    \ of length `k` with the maximum k numbers in `arr`\n        // You can assume\
    \ that `k` is less than or equal to the length of `arr`\n        // You can assume\
    \ that `k` is greater than 0\n        arr.sorted.takeRight(k.toInt)", "      \
    \  val maxHeap = new MaxHeap(arr)\n        val result = new ListBuffer[Long]\n\
    \        for (i <- 0l.toLong until k) result += maxHeap.pop\n        result.toList",
  "        // Fill up this function body\n        // `arr` is a list of integers\n\
    \        // `k` is a positive integer\n        // You have to return a sorted\
    \ list of length `k` with the maximum k numbers in `arr`\n        // If `k` is\
    \ greater than the length of `arr`, return `arr` sorted in descending order\n\
    \        // If `k` is 0, return an empty list\n        // The elements in the\
    \ list will be in the range of [-1000, 1000]\n        // The range of the length\
    \ of the list will be in the range of [1, 1000]\n        arr.sorted.takeRight(k.toInt).reverse",
  "        // Fill up this function body\n        // 'return List[Long]()' in case\
    \ of timeout or other internal errors\n        return List[Long]()", "       \
    \ // Fill up this function body\n        // `arr` is a list of integers\n    \
    \    // `k` is a positive integer\n        // You have to return a sorted list\
    \ of length `k` with the maximum k numbers in `arr`\n        // You can assume\
    \ that `k` is less than or equal to the length of `arr`\n        // You can assume\
    \ that `k` is greater than 0\n        arr.sorted.takeRight(k.toInt)", "      \
    \  // Define the maximum function as a recursive function.\n        def maximum0(arr\
    \ : List[Long], k : Long, acc : List[Long]) : List[Long] = {\n            // If\
    \ the list is empty, return the accumulator.\n            if (arr.isEmpty) acc\n\
    \            // If the accumulator is empty, return the accumulator.\n       \
    \     else if (acc.isEmpty) maximum0(arr.tail, k, acc :+ arr.head)\n         \
    \   // If the accumulator is not empty, return the accumulator.\n            else\
    \ if (acc.length == k) acc\n            // If the accumulator is not empty, return\
    \ the accumulator.\n            else if (acc.head > arr.head) maximum0(arr.tail,\
    \ k, acc)\n            // If the accumulator is not empty, return the accumulator.\n\
    \            else maximum0(arr.tail, k, (acc.tail :+ arr.head).sorted)\n     \
    \   }\n        // Return the maximum function.\n        maximum0(arr, k, List[Long]())",
  "        // Fill up this function body\n        // 'arr' is a list of integers\n\
    \        // 'k' is a positive integer\n        // Return a sorted list of length\
    \ 'k' with the maximum 'k' numbers in 'arr'\n        arr.sortWith(_ > _).take(k.toInt)",
  "        // Fill up this function body\n        // 'return List[Long]()' in case\
    \ of timeout or other internal errors\n        return List[Long]()", "       \
    \ // Fill up this function body\n        // 'passed' variable is just a placeholder\
    \ for compilation\n        val passed : Boolean = true\n        return arr", " \
    \       // Fill up this function body\n        // `arr` is a list of integers\n\
    \        // `k` is a positive integer\n        // You have to return a sorted\
    \ list of length `k` with the maximum k numbers in `arr`\n        // You can assume\
    \ that `k` is less than or equal to the length of `arr`\n        // You can assume\
    \ that `k` is greater than 0\n        // You can assume that `arr` is not empty\n\
    \        val list = arr.sorted\n        list.takeRight(k.toInt)", "        val\
    \ sorted = arr.sorted\n        sorted.takeRight(k.toInt)", "        val arrSorted\
    \ = arr.sorted\n        val arrSortedReversed = arrSorted.reverse\n        arrSortedReversed.take(k.toInt)",
  "        // Fill up this function body\n        // `arr` is a list of integers\n\
    \        // `k` is a positive integer\n        // You have to return a sorted\
    \ list of length `k` with the maximum k numbers in `arr`\n        // You can assume\
    \ that `k` is less than or equal to the length of `arr`\n        // You can assume\
    \ that `k` is greater than 0\n        // You can assume that `arr` is not empty\n\
    \        // You can assume that `arr` is not null\n        // You can assume that\
    \ `arr` does not contain null\n        // You can assume that `arr` does not contain\
    \ duplicates\n        // You can assume that `arr` is sorted in non-decreasing\
    \ order\n        // You can assume that `arr` is sorted in non-increasing order\n\
    \        // You can assume that `arr` is sorted in increasing order\n        //\
    \ You can assume that `arr` is sorted in decreasing order\n        // You can\
    \ assume that `arr` is sorted in non-decreasing order\n        // You can assume\
    \ that `arr` is sorted in non-increasing order\n        // You can assume that\
    \ `arr` is sorted in increasing order\n        // You can assume that `arr` is\
    \ sorted in decreasing order\n        // You can assume that `arr` is sorted in\
    \ non-decreasing order\n        // You can assume that `arr` is sorted in non-increasing\
    \ order\n        // You can assume that `arr` is sorted in increasing order\n\
    \        // You can assume that `arr` is sorted in decreasing order\n        //\
    \ You can assume that `arr` is sorted in non-decreasing order\n        // You\
    \ can assume that `arr` is sorted in non-increasing order\n        // You can\
    \ assume that `arr` is sorted in increasing order\n        // You can assume that\
    \ `arr` is sorted in decreasing order\n        // You can assume that `arr` is\
    \ sorted in non-decreasing order\n        // You can assume that `arr` is sorted\
    \ in non-increasing order\n        // You can assume that `arr` is sorted in increasing\
    \ order\n        // You can assume that `arr` is sorted in decreasing order\n\
    \        // You can assume that `arr` is sorted in non-decreasing order\n    \
    \    // You can assume that `arr` is sorted in non-increasing order\n       ",
  "        val sorted = arr.sorted\n        val result = new ListBuffer[Long]\n  \
    \      for (i <- 0 until k.toInt) {\n            result += sorted(sorted.length\
    \ - i - 1)\n        }\n        result.toList", "        // We can use a max heap\
    \ to solve this problem.\n        // The max heap will have size k.\n        //\
    \ We will iterate through the list and add each element to the heap.\n       \
    \ // If the heap size is greater than k, we will pop the max element from the\
    \ heap.\n        // After iterating through the list, we will have the k largest\
    \ elements in the heap.\n        // We will then pop each element from the heap\
    \ and add it to the result list.\n        // The result list will be in descending\
    \ order.\n        // We will then reverse the result list to get the result in\
    \ ascending order.\n        val heap = new mutable.PriorityQueue[Long]()\n   \
    \     for (i <- arr) {\n            heap.enqueue(i)\n            if (heap.size\
    \ > k) heap.dequeue\n        }\n        val result = new ListBuffer[Long]()\n\
    \        while (heap.nonEmpty) result += heap.dequeue\n        result.toList.reverse",
  "        val heap = new PriorityQueue[Long]()(Ordering.by(-_))\n        for (i <-\
    \ arr) {\n            heap.enqueue(i)\n            if (heap.size > k) heap.dequeue\n\
    \        }\n        heap.toList.sorted", "        // Implement this function\n\
    \        return List[Long]()", "        // Fill up this function body\n      \
    \  // `arr` is a list of integers\n        // `k` is a positive integer\n    \
    \    // You have to return a sorted list of length `k` with the maximum k numbers\
    \ in `arr`\n        // You can assume that `k` is less than or equal to the length\
    \ of `arr`\n        // You can assume that `k` is greater than 0\n        arr.sorted.takeRight(k.toInt)",
  "        // Fill up this function body\n        // 'result' should be the maximum\
    \ k numbers in arr\n        // 'result' should be sorted in descending order\n\
    \        // 'result' should be a list of length k\n        var result : List[Long]\
    \ = List[Long]()\n        return result", "        // Fill up this function body\n\
    \        // 'return List[Long]()' in case of timeout or other failure\n      \
    \  return List[Long]()", "        // Fill up this function body\n        // `arr`\
    \ is a list of integers\n        // `k` is a positive integer\n        // return\
    \ a sorted list of length `k` with the maximum `k` numbers in `arr`\n        arr.sortWith(_\
    \ > _).take(k.toInt)", "        // Fill up this function body\n        // `arr`\
    \ is a list of integers\n        // `k` is a positive integer\n        // You\
    \ have to return a sorted list of length `k` with the maximum k numbers in `arr`\n\
    \        // You can assume that `k` is less than or equal to the length of `arr`\n\
    \        // You can assume that `k` is greater than 0\n        arr.sorted.takeRight(k.toInt)",
  "        // We can use a priority queue to solve this problem.\n        // The idea\
    \ is to keep the queue size at k.\n        // If the queue size is less than k,\
    \ we add the element to the queue.\n        // If the queue size is k, we check\
    \ if the element is greater than the minimum element in the queue.\n        //\
    \ If it is, we remove the minimum element and add the new element.\n        //\
    \ If it is not, we do nothing.\n        // Once we have processed all the elements,\
    \ we return the queue.\n        val queue = new PriorityQueue[Long]()(Ordering.Long.reverse)\n\
    \        for (i <- arr) {\n            if (queue.size < k) queue.enqueue(i)\n\
    \            else if (i > queue.head) {\n                queue.dequeue\n     \
    \           queue.enqueue(i)\n            }\n        }\n        queue.toList",
  "        // Fill up this function body\n        // `k` is the number of elements\
    \ you need to return\n        // `arr` is the list of integers\n        // You\
    \ can create other functions as well, if needed\n        arr.sorted.takeRight(k.toInt)",
  "        val heap = new PriorityQueue[Long]()(Ordering.by(-_))\n        for (i <-\
    \ arr) {\n            heap.enqueue(i)\n            if (heap.size > k) heap.dequeue\n\
    \        }\n        heap.toList.sorted", "        val heap = new PriorityQueue[Long]()(Ordering.by(-_))\n\
    \        for (i <- arr) {\n            heap.enqueue(i)\n            if (heap.size\
    \ > k) heap.dequeue\n        }\n        heap.toList.sorted", "        // Fill\
    \ up this function body\n        // `arr` is a list of integers\n        // `k`\
    \ is a positive integer\n        // You have to return a sorted list of length\
    \ `k` with the maximum k numbers in `arr`\n        // If `k` is greater than the\
    \ length of `arr`, return `arr` sorted in descending order\n        // If `k`\
    \ is 0, return an empty list\n        // The elements in the list will be in the\
    \ range of [-1000, 1000]\n        // The range of the length of list will be [1,\
    \ 1000]\n        // 0 <= k <= len(arr)\n        // return a sorted list of length\
    \ `k` with the maximum k numbers in `arr`\n        if (k == 0) {\n           \
    \ return List[Long]()\n        }\n        if (k >= arr.length) {\n           \
    \ return arr.sortWith(_ > _)\n        }\n        var maxHeap = new MaxHeap[Long](k)\n\
    \        for (i <- 0 until arr.length) {\n            maxHeap.insert(arr(i))\n\
    \        }\n        var result = List[Long]()\n        for (i <- 0 until k) {\n\
    \            result = maxHeap.extractMax() :: result\n        }\n        return\
    \ result.reverse", "        // Fill up this function body\n        // 'arr' is\
    \ a list of integers\n        // 'k' is a positive integer\n        // Return\
    \ a sorted list of length 'k' with the maximum 'k' numbers in 'arr'\n        arr.sorted.takeRight(k.toInt)",
  "        // Fill up this function body\n        // `arr` is a list of integers\n\
    \        // `k` is a positive integer\n        // Return a sorted list of length\
    \ `k` with the maximum `k` numbers in `arr`\n        arr.sorted.takeRight(k.toInt)",
  "        // Fill up this function body\n        // 'return List[Long]()' in case\
    \ of timeout or other internal errors\n        return List[Long]()", "       \
    \ val heap = new Heap[Long]()\n        for (i <- arr) {\n            heap.insert(i)\n\
    \            if (heap.size > k) heap.extractMin()\n        }\n        heap.toList",
  "        val heap = new PriorityQueue[Long]()(Ordering.by(-_))\n        for (i <-\
    \ arr) {\n            heap.enqueue(i)\n            if (heap.size > k) heap.dequeue\n\
    \        }\n        heap.toList.sorted", "        // Fill up this function body\n\
    \        // 'return List[Long]()' in case of timeout or other internal error\n\
    \        return List[Long]()", "        // Fill up this function body\n      \
    \  // `arr` is a list of integers\n        // `k` is a positive integer\n    \
    \    // You have to return a sorted list of length `k` with the maximum k numbers\
    \ in `arr`\n        // You can assume that `k` is less than or equal to the length\
    \ of `arr`\n        // You can assume that `k` is greater than 0\n        arr.sortWith(_\
    \ > _).take(k.toInt)", "        // Fill up this function body\n        // `arr`\
    \ is a list of integers\n        // `k` is a positive integer\n        // You\
    \ have to return a sorted list of length `k` with the maximum k numbers in `arr`\n\
    \        // You can assume that `k` is less than or equal to the length of `arr`\n\
    \        // You can assume that `k` is greater than 0\n        arr.sorted.takeRight(k.toInt)",
  "        // Fill up this function body\n        // 'return List[Long]()' in case\
    \ of timeout or internal error\n        return List[Long]()", "        // Fill\
    \ up this function body\n        // `arr` is a list of integers\n        // `k`\
    \ is a positive integer\n        // You have to return a sorted list of length\
    \ `k` with the maximum k numbers in `arr`\n        arr.sortWith(_ > _).take(k.toInt)",
  "        // We use a heap to store the k largest elements.\n        // We use a\
    \ max heap to store the k largest elements.\n        // We use a min heap to store\
    \ the k smallest elements.\n        // We use a max heap to store the k largest\
    \ elements.\n        // We use a min heap to store the k smallest elements.\n\
    \        // We use a max heap to store the k largest elements.\n        // We\
    \ use a min heap to store the k smallest elements.\n        // We use a max heap\
    \ to store the k largest elements.\n        // We use a min heap to store the\
    \ k smallest elements.\n        // We use a max heap to store the k largest elements.\n\
    \        // We use a min heap to store the k smallest elements.\n        // We\
    \ use a max heap to store the k largest elements.\n        // We use a min heap\
    \ to store the k smallest elements.\n        // We use a max heap to store the\
    \ k largest elements.\n        // We use a min heap to store the k smallest elements.\n\
    \        // We use a max heap to store the k largest elements.\n        // We\
    \ use a min heap to store the k smallest elements.\n        // We use a max heap\
    \ to store the k largest elements.\n        // We use a min heap to store the\
    \ k smallest elements.\n        // We use a max heap to store the k largest elements.\n\
    \        // We use a min heap to store the k smallest elements.\n        // We\
    \ use a max heap to store the k largest elements.\n        // We use a min heap\
    \ to store the k smallest elements.\n        // We use a max heap to store the\
    \ k largest elements.\n        // We use a min heap to store the k smallest elements.\n\
    \        // We use a max heap to store the k largest elements.\n        // We\
    \ use a min heap to store the k smallest elements.\n        // We use a max heap\
    \ to store the k largest elements.\n        // We use a min heap to store the\
    \ k smallest elements.\n        // We use a max heap to store the k largest elements.\n\
    \        // We use a min heap to store the k smallest elements.\n        // We\
    \ use a max heap to store the k largest elements.\n        // We use a min heap\
    \ to store the k smallest elements.\n        // We use a max heap to store the\
    \ k largest elements.\n        //", "        // Fill up this function body\n \
    \       // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // You have to return a sorted list of length `k` with the maximum k\
    \ numbers in `arr`\n        // You can assume that `k` is less than or equal to\
    \ the length of `arr`\n        // You can assume that `k` is greater than 0\n\
    \        arr.sorted.takeRight(k.toInt)", "        // Fill up this function body\n\
    \        // 'return List[Long]()' if the result is an empty list\n        // 'return\
    \ List[Long](1l)' if the result is a list with single element '1'\n        //\
    \ 'return List[Long](1l, 2l, 3l)' if the result is a list with multiple elements\
    \ '1, 2, 3'\n        var result = List[Long]()\n        for (i <- 0 until k.toInt)\
    \ {\n            var max = -1000000000l\n            var index = -1\n        \
    \    for (j <- 0 until arr.length) {\n                if (arr(j) > max) {\n  \
    \                  max = arr(j)\n                    index = j\n             \
    \   }\n            }\n            result = result :+ max\n            arr = arr.take(index)\
    \ ++ arr.drop(index + 1)\n        }\n        return result", "        // Fill\
    \ up this function body\n        // `arr` is a list of integers\n        // `k`\
    \ is a positive integer\n        // You have to return a sorted list of length\
    \ `k` with the maximum k numbers in `arr`\n        arr.sorted.takeRight(k.toInt)",
  "        // Fill up this function body\n        // `arr` is a list of integers\n\
    \        // `k` is a positive integer\n        // You have to return a sorted\
    \ list of length `k` with the maximum k numbers in `arr`\n        // You can assume\
    \ that `k` is less than or equal to the length of `arr`\n        // You can assume\
    \ that `k` is greater than 0\n        var result = List[Long]()\n        var max\
    \ = arr.max\n        var min = arr.min\n        var max_index = arr.indexOf(max)\n\
    \        var min_index = arr.indexOf(min)\n        var max_count = 0\n       \
    \ var min_count = 0\n        var max_arr = arr.filter(x => x == max)\n       \
    \ var min_arr = arr.filter(x => x == min)\n        var max_arr_length = max_arr.length\n\
    \        var min_arr_length = min_arr.length\n        if (k == 1) {\n        \
    \    result = List(max)\n        } else if (k == arr.length) {\n            result\
    \ = arr.sorted\n        } else if (k == max_arr_length) {\n            result\
    \ = max_arr\n        } else if (k == min_arr_length) {\n            result = min_arr\n\
    \        } else if (k > max_arr_length) {\n            result = max_arr\n    \
    \        var temp = arr.filter(x => x != max)\n            var temp_length = temp.length\n\
    \            var temp_max = temp.max\n            var temp_max_index = temp.indexOf(temp_max)\n\
    \            var temp_max_count = 0\n            var temp_max_arr = temp.filter(x\
    \ => x == temp_max)\n            var temp_max_arr_length = temp_max_arr.length\n\
    \            for (i <- 0 until temp_length) {\n                if (temp(i) ==\
    \ temp_max) {\n                    temp_max_count += 1\n                }\n  \
    \          }\n            if (temp_max_count == temp_length) {\n             \
    \   result = result ++ temp\n            } else {\n                result = result\
    \ ++ temp_max_arr\n                var temp2", "        // Fill up this function\
    \ body\n        // 'return List[Long]()' in case of timeout\n        return List[Long]()",
  "        // Fill up this function body\n        // `arr` is a list of integers\n\
    \        // `k` is a positive integer\n        // You have to return a sorted\
    \ list of length `k` with the maximum k numbers in `arr`\n        // You can assume\
    \ that `k` is less than or equal to the length of `arr`\n        // You can assume\
    \ that `k` is greater than 0\n        arr.sortWith(_ > _).take(k.toInt)", "  \
    \      // We can use a max heap to solve this problem.\n        // The max heap\
    \ will keep track of the k largest elements in the list.\n        // The max heap\
    \ will be initialized with the first k elements of the list.\n        // The max\
    \ heap will be updated with the remaining elements of the list.\n        // The\
    \ max heap will be converted to a list and returned.\n        // The time complexity\
    \ is O(n log k) and the space complexity is O(k).\n        val heap = new mutable.PriorityQueue[Long]()(Ordering.by(-_))\n\
    \        for (i <- 0 until k.toInt) {\n            heap.enqueue(arr(i))\n    \
    \    }\n        for (i <- k.toInt until arr.length) {\n            if (arr(i)\
    \ > heap.head) {\n                heap.dequeue\n                heap.enqueue(arr(i))\n\
    \            }\n        }\n        heap.toList", "        val heap = new PriorityQueue[Long]()(Ordering.by(-_))\n\
    \        for (i <- arr) {\n            heap.enqueue(i)\n            if (heap.size\
    \ > k) heap.dequeue\n        }\n        heap.toList.sorted", "        // Fill\
    \ up this function body\n        // `arr` is a list of integers\n        // `k`\
    \ is a positive integer\n        // You have to return a sorted list of length\
    \ `k` with the maximum k numbers in `arr`\n        // You can assume that `k`\
    \ is always valid, i.e. 1 <= k <= len(arr)\n        // You can assume that `arr`\
    \ is always valid, i.e. all the elements in `arr` are positive integers\n    \
    \    // You can assume that `arr` is sorted in non-decreasing order\n        //\
    \ You can assume that `arr` has no duplicates\n        // You can assume that\
    \ `arr` has at least `k` elements\n        // You can assume that `k` is always\
    \ valid, i.e. 1 <= k <= len(arr)\n        // You can assume that `arr` is always\
    \ valid, i.e. all the elements in `arr` are positive integers\n        // You\
    \ can assume that `arr` is sorted in non-decreasing order\n        // You can\
    \ assume that `arr` has no duplicates\n        // You can assume that `arr` has\
    \ at least `k` elements\n        // You can assume that `k` is always valid, i.e.\
    \ 1 <= k <= len(arr)\n        // You can assume that `arr` is always valid, i.e.\
    \ all the elements in `arr` are positive integers\n        // You can assume that\
    \ `arr` is sorted in non-decreasing order\n        // You can assume that `arr`\
    \ has no duplicates\n        // You can assume that `arr` has at least `k` elements\n\
    \        // You can assume that `k` is always valid, i.e. 1 <= k <= len(arr)\n\
    \        // You can assume that `arr` is always valid, i.e. all the elements in\
    \ `arr` are positive integers\n        // You can assume that `arr` is sorted\
    \ in non-decreasing order\n        // You can assume that `arr` has no duplicates\n\
    \        // You can assume that `arr` has at least `k` elements\n        // You\
    \ can assume that `k` is always valid, i.e. 1 <= k <= len(arr)\n        // You\
    \ can assume that `arr` is always valid, i.e", "        // We can use a max heap\
    \ to solve this problem.\n        // The max heap will be of size k.\n       \
    \ // We will iterate through the list and add each element to the heap.\n    \
    \    // If the heap is full, we will remove the largest element from the heap\
    \ and add the new element.\n        // This will ensure that the heap will always\
    \ contain the k largest elements.\n        // After we are done iterating through\
    \ the list, we will return the heap.\n        // The heap will be sorted in descending\
    \ order.\n        // Time complexity: O(n log k)\n        // Space complexity:\
    \ O(k)\n        val heap = new mutable.PriorityQueue[Long]()(Ordering.by(-_))\n\
    \        for (i <- arr) {\n            if (heap.size < k) heap.enqueue(i)\n  \
    \          else {\n                if (i > heap.head) {\n                    heap.dequeue\n\
    \                    heap.enqueue(i)\n                }\n            }\n     \
    \   }\n        heap.toList", "        // We can use a max heap to solve this problem.\n\
    \        // We can also use a min heap to solve this problem.\n        // We can\
    \ also use a sorted array to solve this problem.\n        // We can also use a\
    \ sorted linked list to solve this problem.\n        // We can also use a sorted\
    \ binary search tree to solve this problem.\n        // We can also use a sorted\
    \ hash table to solve this problem.\n        // We can also use a sorted skip\
    \ list to solve this problem.\n        // We can also use a sorted array list\
    \ to solve this problem.\n        // We can also use a sorted linked list to solve\
    \ this problem.\n        // We can also use a sorted binary search tree to solve\
    \ this problem.\n        // We can also use a sorted hash table to solve this\
    \ problem.\n        // We can also use a sorted skip list to solve this problem.\n\
    \        // We can also use a sorted array list to solve this problem.\n     \
    \   // We can also use a sorted linked list to solve this problem.\n        //\
    \ We can also use a sorted binary search tree to solve this problem.\n       \
    \ // We can also use a sorted hash table to solve this problem.\n        // We\
    \ can also use a sorted skip list to solve this problem.\n        // We can also\
    \ use a sorted array list to solve this problem.\n        // We can also use a\
    \ sorted linked list to solve this problem.\n        // We can also use a sorted\
    \ binary search tree to solve this problem.\n        // We can also use a sorted\
    \ hash table to solve this problem.\n        // We can also use a sorted skip\
    \ list to solve this problem.\n        // We can also use a sorted array list\
    \ to solve this problem.\n        // We can also use a sorted linked list to solve\
    \ this problem.\n        // We can also use a sorted binary search tree to solve\
    \ this problem.\n        // We can also use a sorted hash table to solve this\
    \ problem.\n        // We can also use a sorted skip list to solve this problem.\n\
    \        // We can also use a sorted array list to solve this problem.\n     \
    \   // We can also use a sorted linked list to solve this problem.\n        //\
    \ We can also use a sorted binary search tree to solve this problem.\n       \
    \ // We can also use a sorted hash table to solve this problem.\n        // We\
    \ can also use a sorted skip list to solve this", "        // Fill up this function\
    \ body\n        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // You have to return a sorted list of length `k` with the maximum k\
    \ numbers in `arr`\n        // You can assume that `k` is less than or equal to\
    \ the length of `arr`\n        // You can assume that `k` is greater than 0\n\
    \        var res = new ListBuffer[Long]()\n        var max = new ListBuffer[Long]()\n\
    \        for (i <- 0 until arr.length) {\n            if (res.length < k) {\n\
    \                res += arr(i)\n                max += arr(i)\n            } else\
    \ {\n                var min = max.min\n                if (arr(i) > min) {\n\
    \                    res -= min\n                    res += arr(i)\n         \
    \           max -= min\n                    max += arr(i)\n                }\n\
    \            }\n        }\n        res.toList", "        // Fill up this function\
    \ body\n        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // Return a sorted list of length `k` with the maximum `k` numbers in\
    \ `arr`\n        var result = ListBuffer[Long]()\n        var sorted = arr.sorted\n\
    \        var i = 0\n        while (i < k) {\n            result += sorted(sorted.length\
    \ - i - 1)\n            i += 1\n        }\n        result.toList", "        //\
    \ Fill up this function body\n        // `arr` is a list of integers\n       \
    \ // `k` is a positive integer\n        // You have to return a sorted list of\
    \ length `k` with the maximum k numbers in `arr`\n        // You can assume that\
    \ `k` is less than or equal to the length of `arr`\n        // You can assume\
    \ that `k` is greater than 0\n        // You can assume that `arr` is not empty\n\
    \        // You can assume that `arr` does not contain duplicates\n        //\
    \ You can assume that `arr` is sorted in non-decreasing order\n        // You\
    \ can assume that `arr` contains only positive integers\n        // You can assume\
    \ that `arr` contains only integers\n        // You can assume that `arr` contains\
    \ only integers in the range [-1000, 1000]\n        // You can assume that `arr`\
    \ contains only integers in the range [-1000, 1000]\n        // You can assume\
    \ that `arr` contains only integers in the range [-1000, 1000]\n        // You\
    \ can assume that `arr` contains only integers in the range [-1000, 1000]\n  \
    \      // You can assume that `arr` contains only integers in the range [-1000,\
    \ 1000]\n        // You can assume that `arr` contains only integers in the range\
    \ [-1000, 1000]\n        // You can assume that `arr` contains only integers in\
    \ the range [-1000, 1000]\n        // You can assume that `arr` contains only\
    \ integers in the range [-1000, 1000]\n        // You can assume that `arr` contains\
    \ only integers in the range [-1000, 1000]\n        // You can assume that `arr`\
    \ contains only integers in the range [-1000, 1000]\n        // You can assume\
    \ that `arr` contains only integers in the range [-1000, 1000]\n        // You\
    \ can assume that `arr` contains only integers in the range [-1000, 1000]\n  \
    \      // You can assume that `arr` contains only integers in the range [-1000,\
    \ 1000]\n        // You can assume that `arr` contains only integers in the range\
    \ [-1000, 1000]\n        // You can assume that `arr` contains only integers in\
    \ the range [-1000, 1000]\n        // You can assume that `arr` contains only\
    \ integers in the range [-1000, 1000]\n        // You can assume that `arr` contains\
    \ only integers", "        // We can use a min heap to solve this problem.\n \
    \       // The idea is to keep the heap size at k and always\n        // keep\
    \ the minimum element in the heap.\n        // Then, the elements in the heap\
    \ will be the k largest\n        // elements in the array.\n        // Time complexity:\
    \ O(nlogk)\n        // Space complexity: O(k)\n        val heap = new PriorityQueue[Long]()(Ordering.by(-_))\n\
    \        for (i <- arr) {\n            heap.enqueue(i)\n            if (heap.size\
    \ > k) heap.dequeue\n        }\n        heap.toList.sorted", "        // Fill\
    \ up this function body\n        // `k` is the number of elements you need to\
    \ return.\n        // `arr` is the list of integers.\n        // Return a list\
    \ of integers.\n        arr.sorted.takeRight(k.toInt)", "        // Fill up this\
    \ function body\n        // `k` is the length of the output list\n        // `arr`\
    \ is the list of integers\n        // You have to return the maximum k numbers\
    \ in the list\n        arr.sortWith(_ > _).take(k.toInt)", "        // Fill up\
    \ this function body\n        // `arr` is a list of integers\n        // `k` is\
    \ a positive integer\n        // You have to return a sorted list of length `k`\
    \ with the maximum k numbers in `arr`\n        // You can assume that `k` is less\
    \ than or equal to the length of `arr`\n        // You can assume that `k` is\
    \ greater than 0\n        val n = arr.length\n        val m = min(k, n)\n    \
    \    val heap = new PriorityQueue[Long]()(Ordering.by(-_))\n        for (i <-\
    \ 0 until m) heap.enqueue(arr(i))\n        for (i <- m until n) {\n          \
    \  val x = heap.dequeue\n            if (arr(i) > x) heap.enqueue(arr(i))\n  \
    \          else heap.enqueue(x)\n        }\n        heap.dequeueAll.toList.sorted",
  "        // Fill up this function body\n        // 'return List[Long]()' in case\
    \ of timeout or internal error\n        return List[Long]()", "        // Fill\
    \ up this function body\n        // `arr` is a list of integers\n        // `k`\
    \ is a positive integer\n        // You have to return a sorted list of length\
    \ `k` with the maximum k numbers in `arr`\n        // You can assume that `k`\
    \ is less than or equal to the length of `arr`\n        // You can assume that\
    \ `k` is greater than 0\n        arr.sortWith(_ > _).take(k.toInt)", "       \
    \ // Fill up this function body\n        // `arr` is a list of integers\n    \
    \    // `k` is a positive integer\n        // You have to return a sorted list\
    \ of length `k` with the maximum k numbers in `arr`\n        // You can assume\
    \ that `k` is less than or equal to the length of `arr`\n        // You can assume\
    \ that `k` is greater than 0\n        // You can assume that `arr` is not empty\n\
    \        // You can assume that `arr` is not null\n        // You can assume that\
    \ `arr` does not contain null elements\n        // You can assume that `arr` does\
    \ not contain duplicate elements\n        // You can assume that `arr` is sorted\
    \ in non-decreasing order\n        // You can assume that `arr` is sorted in non-increasing\
    \ order\n        // You can assume that `arr` is sorted in increasing order\n\
    \        // You can assume that `arr` is sorted in decreasing order\n        //\
    \ You can assume that `arr` is sorted in ascending order\n        // You can assume\
    \ that `arr` is sorted in descending order\n        // You can assume that `arr`\
    \ is sorted in non-ascending order\n        // You can assume that `arr` is sorted\
    \ in non-descending order\n        // You can assume that `arr` is sorted in non-increasing\
    \ order\n        // You can assume that `arr` is sorted in non-decreasing order\n\
    \        // You can assume that `arr` is sorted in non-decreasing order\n    \
    \    // You can assume that `arr` is sorted in non-decreasing order\n        //\
    \ You can assume that `arr` is sorted in non-decreasing order\n        // You\
    \ can assume that `arr` is sorted in non-decreasing order\n        // You can\
    \ assume that `arr` is sorted in non-decreasing order\n        // You can assume\
    \ that `arr` is sorted in non-decreasing order\n        // You can assume that\
    \ `arr` is sorted in non-decreasing order\n        // You can assume that `arr`\
    \ is sorted in non-decreasing order\n        // You can assume that `arr` is sorted\
    \ in non-decreasing order\n        // You can assume that `arr` is sorted in non-decreasing\
    \ order\n        // You can assume that `arr", "        // Given a list arr of\
    \ integers and a positive integer k, return a sorted list \n        // of length\
    \ k with the maximum k numbers in arr.\n        // Example 1:\n        // >>>\
    \ maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n        // (List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))\n        // Example 2:\n        // >>> maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l))\n        // (List[Long](4l.toLong, 4l.toLong))\n\
    \        // Example 3:\n        // >>> maximum((List[Long](-3l.toLong, 2l.toLong,\
    \ 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n        //\
    \ (List[Long](2l.toLong))\n        // Note:\n        // 1. The length of the list\
    \ will be in the range of [1, 1000].\n        // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n        // 3. 0 <= k <= len(arr)\n      \
    \  val sorted = arr.sorted\n        sorted.takeRight(k.toInt)", "        // Given\
    \ a list arr of integers and a positive integer k, return a sorted list \n   \
    \     // of length k with the maximum k numbers in arr.\n        // Example 1:\n\
    \        // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \        // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n        // Example\
    \ 2:\n        // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \        // (List[Long](4l.toLong, 4l.toLong))\n        // Example 3:\n      \
    \  // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong,\
    \ -2l.toLong, 1l.toLong)), (1l))\n        // (List[Long](2l.toLong))\n       \
    \ // Note:\n        // 1. The length of the list will be in the range of [1, 1000].\n\
    \        // 2. The elements in the list will be in the range of [-1000, 1000].\n\
    \        // 3. 0 <= k <= len(arr)\n        def maximum0(arr : List[Long], k :\
    \ Long, acc : List[Long]) : List[Long] = {\n            if (k == 0l) {\n     \
    \           acc\n            } else {\n                val (max, index) = arr.zipWithIndex.maxBy(_._1)\n\
    \                maximum0(arr.patch(index, Nil, 1), k - 1l, acc :+ max)\n    \
    \        }\n        }\n        maximum0(arr, k, List[Long]())", "        val heap\
    \ = new PriorityQueue[Long]()(Ordering.by(-_))\n        for (i <- arr) {\n   \
    \         heap.enqueue(i)\n            if (heap.size > k) heap.dequeue\n     \
    \   }\n        heap.toList.sorted", "        // Fill up this function body\n \
    \       // 'return List[Long]()' in case of timeout or other failure\n       \
    \ return List[Long]()", "        // Fill up this function body\n        // 'arr'\
    \ is a list of integers\n        // 'k' is a positive integer\n        // Return\
    \ a sorted list of length 'k' with the maximum 'k' numbers in 'arr'\n        arr.sorted.takeRight(k.toInt)",
  "        // We can use a priority queue to solve this problem.\n        // The priority\
    \ queue will be sorted in descending order.\n        // We will add the first\
    \ k elements of the list to the priority queue.\n        // Then we will iterate\
    \ through the rest of the list.\n        // If the element is greater than the\
    \ minimum element in the priority queue,\n        // we will remove the minimum\
    \ element and add the new element.\n        // We will repeat this process until\
    \ we have iterated through the entire list.\n        // Then we will return the\
    \ priority queue.\n        val pq = new PriorityQueue[Long]()(Ordering.Long.reverse)\n\
    \        for (i <- 0l until k) {\n            pq.enqueue(arr(i.toInt))\n     \
    \   }\n        for (i <- k until arr.length) {\n            if (arr(i.toInt) >\
    \ pq.head) {\n                pq.dequeue\n                pq.enqueue(arr(i.toInt))\n\
    \            }\n        }\n        pq.toList", "        // Fill up this function\
    \ body\n        // 'return List[Long]()' for Scala and 'return new ArrayList<Long>()'\
    \ for Java\n        return List[Long]()", "        // Fill up this function body\n\
    \        // `k` is the length of the output list\n        // `arr` is the input\
    \ list\n        // return a sorted list of length `k` with the maximum k numbers\
    \ in `arr`\n        arr.sortWith(_ > _).take(k.toInt)", "        // We can use\
    \ a heap to solve this problem.\n        // The heap will store the k largest\
    \ elements.\n        // If the heap is full and the next element is larger than\
    \ the smallest element in the heap,\n        // then we remove the smallest element\
    \ and add the new element.\n        // If the heap is not full, then we just add\
    \ the new element.\n        // After we have iterated through the list, we return\
    \ the heap.\n        val heap = new PriorityQueue[Long]()(Ordering.by(-_))\n \
    \       for (element <- arr) {\n            if (heap.size < k) heap.enqueue(element)\n\
    \            else if (element > heap.head) {\n                heap.dequeue\n \
    \               heap.enqueue(element)\n            }\n        }\n        heap.toList",
  "        // Fill up this function body\n        // `arr` is a list of integers\n\
    \        // `k` is a positive integer\n        // You have to return a sorted\
    \ list of length `k` with the maximum k numbers in `arr`\n        // You can assume\
    \ that `k` is less than or equal to the length of `arr`\n        // You can assume\
    \ that `k` is greater than 0\n        // You can assume that `arr` is not empty\n\
    \        // You can assume that `arr` is not null\n        // You can assume that\
    \ `arr` does not contain null elements\n        // You can assume that `arr` does\
    \ not contain duplicate elements\n        // You can assume that `arr` is sorted\
    \ in non-decreasing order\n        // You can assume that `arr` is sorted in non-increasing\
    \ order\n        // You can assume that `arr` is sorted in increasing order\n\
    \        // You can assume that `arr` is sorted in decreasing order\n        //\
    \ You can assume that `arr` is sorted in ascending order\n        // You can assume\
    \ that `arr` is sorted in descending order\n        // You can assume that `arr`\
    \ is sorted in non-ascending order\n        // You can assume that `arr` is sorted\
    \ in non-descending order\n        // You can assume that `arr` is sorted in non-increasing\
    \ order\n        // You can assume that `arr` is sorted in non-decreasing order\n\
    \        // You can assume that `arr` is sorted in increasing order\n        //\
    \ You can assume that `arr` is sorted in decreasing order\n        // You can\
    \ assume that `arr` is sorted in ascending order\n        // You can assume that\
    \ `arr` is sorted in descending order\n        // You can assume that `arr` is\
    \ sorted in non-ascending order\n        // You can assume that `arr` is sorted\
    \ in non-descending order\n        // You can assume that `arr` is sorted in non-increasing\
    \ order\n        // You can assume that `arr` is sorted in non-decreasing order\n\
    \        // You can assume that `arr` is sorted in increasing order\n        //\
    \ You can assume that `arr` is sorted in decreasing order\n        // You can\
    \ assume that `arr` is sorted in ascending order\n        // You can assume that\
    \ `arr` is sorted in descending order\n        // You can assume that", "    \
    \    // Fill up this function body\n        // 'return List[Long]()' in case of\
    \ timeout or other abnormal termination during test\n        return List[Long]()",
  "        val heap = new PriorityQueue[Long]()(Ordering.by(-_))\n        for (i <-\
    \ arr) {\n            heap.enqueue(i)\n            if (heap.size > k) heap.dequeue\n\
    \        }\n        heap.toList.sorted", "        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // You have to return a sorted list of length `k` with the maximum k\
    \ numbers in `arr`\n        arr.sorted.takeRight(k.toInt)", "        // Fill up\
    \ this function body\n        // `arr` is a list of integers\n        // `k` is\
    \ a positive integer\n        // You have to return a sorted list of length `k`\
    \ with the maximum k numbers in `arr`\n        // You can assume that `k` is less\
    \ than or equal to the length of `arr`\n        // You can assume that `k` is\
    \ greater than 0\n        arr.sorted.takeRight(k.toInt)", "        // Fill up\
    \ this function body\n        // `arr` is a list of integers\n        // `k` is\
    \ a positive integer\n        // You have to return a sorted list of length `k`\
    \ with the maximum k numbers in `arr`\n        val sorted = arr.sorted\n     \
    \   val len = arr.length\n        val result = new ListBuffer[Long]()\n      \
    \  for (i <- len - k.toInt to len - 1) {\n            result += sorted(i)\n  \
    \      }\n        result.toList", "        // Given a list arr of integers and\
    \ a positive integer k, return a sorted list \n        // of length k with the\
    \ maximum k numbers in arr.\n        // Example 1:\n        // >>> maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l))\n        // (List[Long](-4l.toLong, -3l.toLong,\
    \ 5l.toLong))\n        // Example 2:\n        // >>> maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l))\n        // (List[Long](4l.toLong, 4l.toLong))\n\
    \        // Example 3:\n        // >>> maximum((List[Long](-3l.toLong, 2l.toLong,\
    \ 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n        //\
    \ (List[Long](2l.toLong))\n        // Note:\n        // 1. The length of the list\
    \ will be in the range of [1, 1000].\n        // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n        // 3. 0 <= k <= len(arr)\n      \
    \  def maximum(arr : List[Long], k : Long) : List[Long] = {\n            // Given\
    \ a list arr of integers and a positive integer k, return a sorted list \n   \
    \         // of length k with the maximum k numbers in arr.\n            // Example\
    \ 1:\n            // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n            // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    \
    \        // Example 2:\n            // >>> maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l))\n            // (List[Long](4l.toLong, 4l.toLong))\n    \
    \        // Example 3:\n            // >>> maximum((List[Long](-3l.toLong, 2l.toLong,",
  "        // Define the maximum function as a recursive function\n        def maximum(arr\
    \ : List[Long], k : Long, result : List[Long]) : List[Long] = {\n            //\
    \ If the list is empty, return the result\n            if (arr.isEmpty) result\n\
    \            // If the list is not empty, call the maximum function recursively\n\
    \            else {\n                // If the result is empty, call the maximum\
    \ function recursively\n                if (result.isEmpty) maximum(arr.tail,\
    \ k, List(arr.head))\n                // If the result is not empty, call the\
    \ maximum function recursively\n                else {\n                    //\
    \ If the head of the list is less than the last element of the result, call the\
    \ maximum function recursively\n                    if (arr.head < result.last)\
    \ maximum(arr.tail, k, result)\n                    // If the head of the list\
    \ is greater than or equal to the last element of the result, call the maximum\
    \ function recursively\n                    else {\n                        //\
    \ If the length of the result is less than k, call the maximum function recursively\n\
    \                        if (result.length < k.toInt) maximum(arr.tail, k, result\
    \ :+ arr.head)\n                        // If the length of the result is greater\
    \ than or equal to k, call the maximum function recursively\n                \
    \        else maximum(arr.tail, k, result.init :+ arr.head)\n                \
    \    }\n                }\n            }\n        }\n        // Return the result\
    \ of the maximum function\n        maximum(arr, k, List())", "        // We can\
    \ use a max heap to solve this problem.\n        // First, we insert the first\
    \ k elements into the heap.\n        // Then, we iterate through the rest of the\
    \ elements.\n        // If the current element is greater than the root of the\
    \ heap,\n        // we remove the root and insert the current element.\n     \
    \   // Finally, we return the heap.\n        val heap = new PriorityQueue[Long]()(Ordering.by(-_))\n\
    \        for (i <- 0 until k.toInt) heap.enqueue(arr(i))\n        for (i <- k.toInt\
    \ until arr.length) {\n            if (arr(i) > heap.head) {\n               \
    \ heap.dequeue\n                heap.enqueue(arr(i))\n            }\n        }\n\
    \        heap.toList", "        var result : List[Long] = List[Long]()\n     \
    \   var temp : List[Long] = List[Long]()\n        var i : Long = 0l\n        while\
    \ (i < k) {\n            var max : Long = -1000l\n            var index : Long\
    \ = 0l\n            var j : Long = 0l\n            while (j < arr.length) {\n\
    \                if (arr(j.toInt) > max && !temp.contains(j)) {\n            \
    \        max = arr(j.toInt)\n                    index = j\n                }\n\
    \                j += 1\n            }\n            result = result :+ max\n \
    \           temp = temp :+ index\n            i += 1\n        }\n        return\
    \ result", "        // We use a priority queue to store the elements of the list.\n\
    \        // The priority queue is a min-heap, so the smallest element is at the\
    \ top.\n        // We add the first k elements to the priority queue.\n      \
    \  // Then, for each element in the list, we check if it is larger than the smallest\
    \ element in the priority queue.\n        // If it is, we remove the smallest\
    \ element from the priority queue and add the new element.\n        // When we\
    \ are done, we return the priority queue.\n        val pq = new PriorityQueue[Long]()(Ordering.Long.reverse)\n\
    \        for (i <- 0l until k) {\n            pq.enqueue(arr(i.toInt))\n     \
    \   }\n        for (i <- k until arr.length) {\n            if (arr(i.toInt) >\
    \ pq.head) {\n                pq.dequeue\n                pq.enqueue(arr(i.toInt))\n\
    \            }\n        }\n        pq.toList", "        // Fill up this function\
    \ body\n        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // Return a sorted list of length `k` with the maximum `k` numbers in\
    \ `arr`\n        arr.sortWith(_ > _).take(k.toInt)", "        // Write your code\
    \ here\n        arr.sorted.takeRight(k.toInt)", "        // Fill up this function\
    \ body\n        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // You have to return a sorted list of length `k` with the maximum k\
    \ numbers in `arr`\n        // You can assume that `k` is less than or equal to\
    \ the length of `arr`\n        // You can assume that `k` is greater than 0\n\
    \        // You can assume that `arr` is not empty\n        // You can assume\
    \ that `arr` does not contain duplicates\n        // You can assume that `arr`\
    \ contains only positive integers\n        // You can assume that `arr` contains\
    \ only negative integers\n        // You can assume that `arr` contains only non-negative\
    \ integers\n        // You can assume that `arr` contains only non-positive integers\n\
    \        // You can assume that `arr` contains only integers\n        arr.sorted.takeRight(k.toInt)",
  "        // Fill up this function body\n        // 'arr' is a list of integers\n\
    \        // 'k' is a positive integer\n        // Return a sorted list of length\
    \ 'k' with the maximum 'k' numbers in 'arr'\n        arr.sortWith(_ > _).take(k.toInt)",
  "        val heap = new PriorityQueue[Long]()(Ordering.by(-_))\n        for (i <-\
    \ arr) {\n            heap.enqueue(i)\n            if (heap.size > k) heap.dequeue\n\
    \        }\n        heap.toList.sorted", "        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // You have to return a sorted list of length `k` with the maximum k\
    \ numbers in `arr`\n        // If there are less than `k` numbers in `arr`, return\
    \ the maximum k numbers in `arr`\n        // If there are more than `k` numbers\
    \ in `arr`, return the maximum k numbers in `arr`\n        // You can assume that\
    \ `k` is always valid, 1 \u2264 k \u2264 arr.length\n        // The input array\
    \ will not be empty.\n        // The output array should be sorted in descending\
    \ order.\n        // For example,\n        // maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)) should return (List[Long](-4l.toLong, -3l.toLong,\
    \ 5l.toLong))\n        // maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)),\
    \ (2l)) should return (List[Long](4l.toLong, 4l.toLong))\n        // maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\
    \ should return (List[Long](2l.toLong))\n        arr.sortWith(_ > _).take(k.toInt)",
  "        // We can use a heap to solve this problem.\n        // The heap will contain\
    \ the k largest elements in arr.\n        // We will iterate through arr and add\
    \ each element to the heap.\n        // If the heap contains more than k elements,\
    \ we will pop the smallest element from the heap.\n        // At the end, we will\
    \ pop the elements from the heap and return them in reverse order.\n        val\
    \ heap = new PriorityQueue[Long]()\n        for (i <- arr) {\n            heap.enqueue(i)\n\
    \            if (heap.size > k) heap.dequeue\n        }\n        val result =\
    \ new ListBuffer[Long]()\n        while (heap.nonEmpty) result += heap.dequeue\n\
    \        result.reverse.toList", "        // We can use a max heap to solve this\
    \ problem.\n        // We can also use a min heap to solve this problem.\n   \
    \     // We can also use a max heap to solve this problem.\n        // We can\
    \ also use a min heap to solve this problem.\n        // We can also use a max\
    \ heap to solve this problem.\n        // We can also use a min heap to solve\
    \ this problem.\n        // We can also use a max heap to solve this problem.\n\
    \        // We can also use a min heap to solve this problem.\n        // We can\
    \ also use a max heap to solve this problem.\n        // We can also use a min\
    \ heap to solve this problem.\n        // We can also use a max heap to solve\
    \ this problem.\n        // We can also use a min heap to solve this problem.\n\
    \        // We can also use a max heap to solve this problem.\n        // We can\
    \ also use a min heap to solve this problem.\n        // We can also use a max\
    \ heap to solve this problem.\n        // We can also use a min heap to solve\
    \ this problem.\n        // We can also use a max heap to solve this problem.\n\
    \        // We can also use a min heap to solve this problem.\n        // We can\
    \ also use a max heap to solve this problem.\n        // We can also use a min\
    \ heap to solve this problem.\n        // We can also use a max heap to solve\
    \ this problem.\n        // We can also use a min heap to solve this problem.\n\
    \        // We can also use a max heap to solve this problem.\n        // We can\
    \ also use a min heap to solve this problem.\n        // We can also use a max\
    \ heap to solve this problem.\n        // We can also use a min heap to solve\
    \ this problem.\n        // We can also use a max heap to solve this problem.\n\
    \        // We can also use a min heap to solve this problem.\n        // We can\
    \ also use a max heap to solve this problem.\n        // We can also use a min\
    \ heap to solve this problem.\n        // We can also use a max heap to solve\
    \ this problem.\n        // We can also use a min heap to solve this problem.\n\
    \        // We can also use a max heap to solve this problem.\n        // We can\
    \ also use a min heap to solve this problem.\n        //", "        var result\
    \ : List[Long] = List[Long]()\n        var max : Long = 0\n        var max_index\
    \ : Long = 0\n        for (i <- 0l.toLong to k - 1l.toLong) {\n            max\
    \ = arr(0l.toInt)\n            max_index = 0l\n            for (j <- 0l.toLong\
    \ to arr.length - 1l.toLong) {\n                if (arr(j.toInt) > max) {\n  \
    \                  max = arr(j.toInt)\n                    max_index = j\n   \
    \             }\n            }\n            result = result :+ max\n         \
    \   arr = arr.patch(max_index.toInt, Nil, 1)\n        }\n        return result",
  "        // Fill up this function body\n        // 'arr' is a list of integers\n\
    \        // 'k' is a positive integer\n        // Return a sorted list of length\
    \ 'k' with the maximum 'k' numbers in 'arr'\n        arr.sorted.takeRight(k.toInt)",
  "        // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n        // of length k with the maximum k numbers in arr.\n        //\
    \ Example 1:\n        // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n        // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n        //\
    \ Example 2:\n        // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)),\
    \ (2l))\n        // (List[Long](4l.toLong, 4l.toLong))\n        // Example 3:\n\
    \        // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n        // (List[Long](2l.toLong))\n\
    \        // Note:\n        // 1. The length of the list will be in the range of\
    \ [1, 1000].\n        // 2. The elements in the list will be in the range of [-1000,\
    \ 1000].\n        // 3. 0 <= k <= len(arr)\n        def maximum(arr : List[Long],\
    \ k : Long) : List[Long] = {\n            // Given a list arr of integers and\
    \ a positive integer k, return a sorted list \n            // of length k with\
    \ the maximum k numbers in arr.\n            // Example 1:\n            // >>>\
    \ maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n           \
    \ // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n            // Example 2:\n\
    \            // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \            // (List[Long](4l.toLong, 4l.toLong))\n            // Example 3:\n\
    \            // >>> maximum((List[Long](-3l.toLong, 2l.toLong,", "        var\
    \ result : List[Long] = List[Long]()\n        var arr2 : List[Long] = arr\n  \
    \      for (i <- 0l.toLong to k - 1l.toLong) {\n            var max : Long = arr2.max\n\
    \            result = result :+ max\n            arr2 = arr2.filter(x => x !=\
    \ max)\n        }\n        return result", "        // Fill up this function body\n\
    \        // 'return List[Long]()' in case of timeout or internal error\n     \
    \   return List[Long]()", "        // We can use a max heap to solve this problem.\n\
    \        // The max heap will have a size of k.\n        // We will iterate through\
    \ the list and add each element to the heap.\n        // If the heap is full,\
    \ we will remove the max element from the heap\n        // and add the new element.\n\
    \        // At the end of the iteration, we will have a heap with the k largest\n\
    \        // elements in the list.\n        // We can then iterate through the\
    \ heap and add the elements to a list.\n        // This will be the sorted list\
    \ of the k largest elements in the list.\n        // Time Complexity: O(n * log(k))\n\
    \        // Space Complexity: O(k)\n        val heap = new PriorityQueue[Long]()(Ordering.by(-_))\n\
    \        for (element <- arr) {\n            if (heap.size < k) {\n          \
    \      heap.enqueue(element)\n            } else {\n                if (element\
    \ > heap.head) {\n                    heap.dequeue\n                    heap.enqueue(element)\n\
    \                }\n            }\n        }\n        val result = new ListBuffer[Long]()\n\
    \        while (heap.nonEmpty) {\n            result += heap.dequeue\n       \
    \ }\n        result.toList", "        // Fill up this function body\n        //\
    \ 'return List[Long]()' for the case of empty list\n        return List[Long]()",
  "        // Define a function to convert a list of integers to a list of longs.\n\
    \        def f(arr : List[Int]) : List[Long] = {\n            arr.map(x => x.toLong)\n\
    \        }\n        // Define a function to convert a list of longs to a list\
    \ of integers.\n        def g(arr : List[Long]) : List[Int] = {\n            arr.map(x\
    \ => x.toInt)\n        }\n        // Define a function to convert a list of integers\
    \ to a list of longs.\n        def h(arr : List[Int]) : List[Long] = {\n     \
    \       arr.map(x => x.toLong)\n        }\n        // Define a function to convert\
    \ a list of longs to a list of integers.\n        def i(arr : List[Long]) : List[Int]\
    \ = {\n            arr.map(x => x.toInt)\n        }\n        // Define a function\
    \ to convert a list of integers to a list of longs.\n        def j(arr : List[Int])\
    \ : List[Long] = {\n            arr.map(x => x.toLong)\n        }\n        //\
    \ Define a function to convert a list of longs to a list of integers.\n      \
    \  def k(arr : List[Long]) : List[Int] = {\n            arr.map(x => x.toInt)\n\
    \        }\n        // Define a function to convert a list of integers to a list\
    \ of longs.\n        def l(arr : List[Int]) : List[Long] = {\n            arr.map(x\
    \ => x.toLong)\n        }\n        // Define a function to convert a list of longs\
    \ to a list of integers.\n        def m(arr : List[Long]) : List[Int] = {\n  \
    \          arr.map(x => x.toInt)\n        }\n        // Define a function to convert\
    \ a list of integers to a list of longs.\n        def n(arr : List[Int]) : List[Long]\
    \ = {\n            arr.map(x => x.toLong)\n        }\n        // Define a function\
    \ to convert a list of longs to a list of integers.\n        def o(arr", "   \
    \     // Fill up this function body\n        // 'passed' variable is just an indicator\n\
    \        // 'passed' and 'arr' variables are defined in the test cases.\n    \
    \    // 'passed' should be replaced by the actual test result\n        var passed\
    \ : Boolean = false\n        arr", "        // Fill up this function body\n  \
    \      // 'return List[Long]()' for Scala, 'return new ArrayList<Long>()' for\
    \ Java\n        return List[Long]()", "        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // You have to return a sorted list of length `k` with the maximum k\
    \ numbers in `arr`\n        // You can assume that `k` is less than or equal to\
    \ the length of `arr`\n        // You can assume that `k` is greater than 0\n\
    \        arr.sortWith(_ > _).take(k.toInt)", "        // We can use a max heap\
    \ to solve this problem.\n        // The max heap will contain the k largest elements.\n\
    \        // We can then iterate through the remaining elements,\n        // and\
    \ if they are larger than the root of the max heap,\n        // we can replace\
    \ the root with that element.\n        // Then we can return the max heap.\n \
    \       // This algorithm will run in O(n log k) time.\n        val heap = new\
    \ PriorityQueue[Long]()(Ordering.by(-_))\n        for (i <- 0 until k.toInt) {\n\
    \            heap.enqueue(arr(i))\n        }\n        for (i <- k.toInt until\
    \ arr.length) {\n            if (arr(i) > heap.head) {\n                heap.dequeue\n\
    \                heap.enqueue(arr(i))\n            }\n        }\n        heap.toList",
  "        val heap = new PriorityQueue[Long]()(Ordering.by(-_))\n        for (i <-\
    \ arr) {\n            heap.enqueue(i)\n            if (heap.size > k) heap.dequeue\n\
    \        }\n        heap.toList.sorted", "        // We can use a min heap to\
    \ solve this problem.\n        // The heap will contain the k largest elements\
    \ of arr.\n        // We will iterate through arr, and if the current element\
    \ is larger than the smallest element in the heap,\n        // we will remove\
    \ the smallest element from the heap and add the current element to the heap.\n\
    \        // After iterating through arr, we will return the heap.\n        //\
    \ The heap will be sorted in ascending order, so we will reverse it to get the\
    \ result.\n        // Time Complexity: O(n log k)\n        // Space Complexity:\
    \ O(k)\n        var heap = new PriorityQueue[Long]()(Ordering.by(-_))\n      \
    \  for (i <- 0 until arr.length) {\n            if (heap.size < k) heap.enqueue(arr(i))\n\
    \            else if (arr(i) > heap.head) {\n                heap.dequeue\n  \
    \              heap.enqueue(arr(i))\n            }\n        }\n        heap.toList.reverse",
  "        val heap = new Heap[Long]()\n        for (i <- arr) {\n            heap.insert(i)\n\
    \            if (heap.size > k) heap.deleteMin()\n        }\n        heap.toList",
  "        // Fill up this function body\n        // `for` is Scala's list comprehension\n\
    \        // `yield` is used to build a new list\n        for (i <- arr.sorted.takeRight(k.toInt))\
    \ yield i", "        // We can use a max heap to solve this problem.\n       \
    \ // The max heap will have size k, and will contain the k largest elements.\n\
    \        // We can then extract the elements from the heap in reverse order to\
    \ get the\n        // elements in sorted order.\n        // The time complexity\
    \ is O(n log k) and the space complexity is O(k).\n        val heap = new MaxHeap[Long](k.toInt)\n\
    \        for (x <- arr) {\n            if (heap.size < k) heap.insert(x)\n   \
    \         else if (x > heap.peek) {\n                heap.extractMax\n       \
    \         heap.insert(x)\n            }\n        }\n        heap.extractAll.reverse",
  "        // Define a function to convert a list of integers to a list of longs.\n\
    \        def f(arr : List[Int]) : List[Long] = {\n            arr.map(x => x.toLong)\n\
    \        }\n        // Define a function to convert a list of longs to a list\
    \ of integers.\n        def g(arr : List[Long]) : List[Int] = {\n            arr.map(x\
    \ => x.toInt)\n        }\n        // Define a function to convert a list of integers\
    \ to a list of longs.\n        def h(arr : List[Int]) : List[Long] = {\n     \
    \       arr.map(x => x.toLong)\n        }\n        // Define a function to convert\
    \ a list of longs to a list of integers.\n        def i(arr : List[Long]) : List[Int]\
    \ = {\n            arr.map(x => x.toInt)\n        }\n        // Define a function\
    \ to convert a list of integers to a list of longs.\n        def j(arr : List[Int])\
    \ : List[Long] = {\n            arr.map(x => x.toLong)\n        }\n        //\
    \ Define a function to convert a list of longs to a list of integers.\n      \
    \  def k(arr : List[Long]) : List[Int] = {\n            arr.map(x => x.toInt)\n\
    \        }\n        // Define a function to convert a list of integers to a list\
    \ of longs.\n        def l(arr : List[Int]) : List[Long] = {\n            arr.map(x\
    \ => x.toLong)\n        }\n        // Define a function to convert a list of longs\
    \ to a list of integers.\n        def m(arr : List[Long]) : List[Int] = {\n  \
    \          arr.map(x => x.toInt)\n        }\n        // Define a function to convert\
    \ a list of integers to a list of longs.\n        def n(arr : List[Int]) : List[Long]\
    \ = {\n            arr.map(x => x.toLong)\n        }\n        // Define a function\
    \ to convert a list of longs to a list of integers.\n        def o(arr", "   \
    \     // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n        // of length k with the maximum k numbers in arr.\n        //\
    \ Example 1:\n        // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n        // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n        //\
    \ Example 2:\n        // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)),\
    \ (2l))\n        // (List[Long](4l.toLong, 4l.toLong))\n        // Example 3:\n\
    \        // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n        // (List[Long](2l.toLong))\n\
    \        // Note:\n        // 1. The length of the list will be in the range of\
    \ [1, 1000].\n        // 2. The elements in the list will be in the range of [-1000,\
    \ 1000].\n        // 3. 0 <= k <= len(arr)\n        arr.sorted.takeRight(k.toInt)",
  "        // We will use a heap to store the maximum k numbers.\n        // The heap\
    \ will be a min-heap, so the minimum number will be at the top.\n        // We\
    \ will use the heap to store the k smallest numbers.\n        // If we encounter\
    \ a number that is larger than the top of the heap,\n        // we will pop the\
    \ top of the heap and push the new number.\n        // At the end, we will pop\
    \ all the numbers from the heap and return them in reverse order.\n        val\
    \ heap = new mutable.PriorityQueue[Long]()\n        for (x <- arr) {\n       \
    \     if (heap.size < k) {\n                heap.enqueue(x)\n            } else\
    \ {\n                if (x > heap.head) {\n                    heap.dequeue\n\
    \                    heap.enqueue(x)\n                }\n            }\n     \
    \   }\n        val result = new ListBuffer[Long]()\n        while (heap.nonEmpty)\
    \ {\n            result += heap.dequeue\n        }\n        result.toList.reverse",
  "        // We can use a max heap to solve this problem.\n        // The time complexity\
    \ is O(n log k) and the space complexity is O(k).\n        val heap = new mutable.PriorityQueue[Long]()\n\
    \        for (i <- arr) {\n            heap.enqueue(i)\n            if (heap.size\
    \ > k) heap.dequeue\n        }\n        heap.toList.sorted", "        // Fill\
    \ up this function body\n        // `arr` is a list of integers\n        // `k`\
    \ is a positive integer\n        // You have to return a sorted list of length\
    \ `k` with the maximum k numbers in `arr`\n        // You can assume that `k`\
    \ is less than or equal to the length of `arr`\n        // You can assume that\
    \ `k` is greater than 0\n        var list = arr.sorted\n        var result = List[Long]()\n\
    \        for (i <- 0 to k.toInt - 1) {\n            result = result :+ list(list.length\
    \ - 1 - i)\n        }\n        result", "        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // You have to return a sorted list of length `k` with the maximum k\
    \ numbers in `arr`\n        // You can assume that `k` is always valid, 1 \u2264\
    \ k \u2264 arr.length\n        // You can assume that `arr` is always valid, arr.length\
    \ \u2265 k\n        // You can assume that `arr` is always valid, arr.length \u2265\
    \ k\n        // You can assume that `arr` is always valid, arr.length \u2265 k\n\
    \        // You can assume that `arr` is always valid, arr.length \u2265 k\n \
    \       // You can assume that `arr` is always valid, arr.length \u2265 k\n  \
    \      // You can assume that `arr` is always valid, arr.length \u2265 k\n   \
    \     // You can assume that `arr` is always valid, arr.length \u2265 k\n    \
    \    // You can assume that `arr` is always valid, arr.length \u2265 k\n     \
    \   // You can assume that `arr` is always valid, arr.length \u2265 k\n      \
    \  // You can assume that `arr` is always valid, arr.length \u2265 k\n       \
    \ // You can assume that `arr` is always valid, arr.length \u2265 k\n        //\
    \ You can assume that `arr` is always valid, arr.length \u2265 k\n        // You\
    \ can assume that `arr` is always valid, arr.length \u2265 k\n        // You can\
    \ assume that `arr` is always valid, arr.length \u2265 k\n        // You can assume\
    \ that `arr` is always valid, arr.length \u2265 k\n        // You can assume that\
    \ `arr` is always valid, arr.length \u2265 k\n        // You can assume that `arr`\
    \ is always valid, arr.length \u2265 k\n        // You can assume that `arr` is\
    \ always valid, arr.length \u2265 k\n        // You can assume that `arr` is always\
    \ valid, arr.length \u2265 k\n        // You can assume that `arr` is always valid,\
    \ arr.length \u2265 k\n        // You can assume that `arr` is always valid, arr.length\
    \ \u2265 k\n        // You can assume that `arr` is always valid, arr.length \u2265\
    \ k\n        // You can assume that `arr` is always valid, arr.length \u2265 k\n",
  "        // Fill up this function body\n        // `k` is the length of the output\
    \ list\n        // `arr` is the input list\n        // Return a sorted list of\
    \ length `k` with the maximum k numbers in `arr`\n        arr.sorted.takeRight(k.toInt)",
  "        // Fill up this function body\n        // `arr` is a list of integers\n\
    \        // `k` is a positive integer\n        // You have to return a sorted\
    \ list of length `k` with the maximum k numbers in `arr`\n        // You can assume\
    \ that `k` is less than or equal to the length of `arr`\n        // You can assume\
    \ that `k` is greater than 0\n        arr.sorted.takeRight(k.toInt)", "      \
    \  // Fill up this function body\n        // `arr` is a list of integers\n   \
    \     // `k` is a positive integer\n        // You have to return a sorted list\
    \ of length `k` with the maximum k numbers in `arr`\n        // You can assume\
    \ that `k` is less than or equal to the length of `arr`\n        // You can assume\
    \ that `k` is greater than 0\n        var result = List[Long]()\n        var max\
    \ = Long.MinValue\n        var maxIndex = 0\n        for (i <- 0 until k.toInt)\
    \ {\n            for (j <- i until arr.length) {\n                if (arr(j) >\
    \ max) {\n                    max = arr(j)\n                    maxIndex = j\n\
    \                }\n            }\n            result = result :+ max\n      \
    \      max = Long.MinValue\n            var temp = arr(i)\n            arr(i)\
    \ = arr(maxIndex)\n            arr(maxIndex) = temp\n        }\n        result",
  "        // We can use a heap to solve this problem.\n        // We can use a min-heap\
    \ to store the k largest elements.\n        // We can use a max-heap to store\
    \ the k smallest elements.\n        // We can use a min-heap to store the k largest\
    \ elements.\n        // We can use a max-heap to store the k smallest elements.\n\
    \        // We can use a min-heap to store the k largest elements.\n        //\
    \ We can use a max-heap to store the k smallest elements.\n        // We can use\
    \ a min-heap to store the k largest elements.\n        // We can use a max-heap\
    \ to store the k smallest elements.\n        // We can use a min-heap to store\
    \ the k largest elements.\n        // We can use a max-heap to store the k smallest\
    \ elements.\n        // We can use a min-heap to store the k largest elements.\n\
    \        // We can use a max-heap to store the k smallest elements.\n        //\
    \ We can use a min-heap to store the k largest elements.\n        // We can use\
    \ a max-heap to store the k smallest elements.\n        // We can use a min-heap\
    \ to store the k largest elements.\n        // We can use a max-heap to store\
    \ the k smallest elements.\n        // We can use a min-heap to store the k largest\
    \ elements.\n        // We can use a max-heap to store the k smallest elements.\n\
    \        // We can use a min-heap to store the k largest elements.\n        //\
    \ We can use a max-heap to store the k smallest elements.\n        // We can use\
    \ a min-heap to store the k largest elements.\n        // We can use a max-heap\
    \ to store the k smallest elements.\n        // We can use a min-heap to store\
    \ the k largest elements.\n        // We can use a max-heap to store the k smallest\
    \ elements.\n        // We can use a min-heap to store the k largest elements.\n\
    \        // We can use a max-heap to store the k smallest elements.\n        //\
    \ We can use a min-heap to store the k largest elements.\n        // We can use\
    \ a max-heap to store", "        // Fill up this function body\n        // 'return\
    \ List[Long]()' in case of timeout or other internal errors\n        return List[Long]()",
  "        // Fill up this function body\n        // `arr` is a list of integers\n\
    \        // `k` is a positive integer\n        // Return a sorted list of length\
    \ `k` with the maximum `k` numbers in `arr`\n        arr.sorted.takeRight(k.toInt)",
  "        // Fill up this function body\n        // `arr` is a list of integers\n\
    \        // `k` is a positive integer\n        // You have to return a sorted\
    \ list of length `k` with the maximum k numbers in `arr`\n        // You can assume\
    \ that `k` is less than or equal to the length of `arr`\n        // You can assume\
    \ that `k` is greater than 0\n        // You can assume that `arr` is not empty\n\
    \        // You can assume that `arr` is not null\n        // You can assume that\
    \ `arr` does not contain null elements\n        // You can assume that `arr` does\
    \ not contain duplicate elements\n        // You can assume that `arr` is sorted\
    \ in non-decreasing order\n        // You can assume that `arr` is sorted in non-increasing\
    \ order\n        // You can assume that `arr` is sorted in increasing order\n\
    \        // You can assume that `arr` is sorted in decreasing order\n        //\
    \ You can assume that `arr` is sorted in some order\n        // You can assume\
    \ that `arr` is not sorted in any order\n        // You can assume that `arr`\
    \ is sorted in some order\n        // You can assume that `arr` is not sorted\
    \ in any order\n        // You can assume that `arr` is sorted in some order\n\
    \        // You can assume that `arr` is not sorted in any order\n        // You\
    \ can assume that `arr` is sorted in some order\n        // You can assume that\
    \ `arr` is not sorted in any order\n        // You can assume that `arr` is sorted\
    \ in some order\n        // You can assume that `arr` is not sorted in any order\n\
    \        // You can assume that `arr` is sorted in some order\n        // You\
    \ can assume that `arr` is not sorted in any order\n        // You can assume\
    \ that `arr` is sorted in some order\n        // You can assume that `arr` is\
    \ not sorted in any order\n        // You can assume that `arr` is sorted in some\
    \ order\n        // You can assume that `arr` is not sorted in any order\n   \
    \     // You can assume that `arr` is sorted in some order\n        // You can\
    \ assume that `arr` is not sorted in any order\n        // You can assume that\
    \ `arr` is sorted in some order\n        // You can assume that", "        //\
    \ We can use a heap to solve this problem.\n        // We can use a min-heap to\
    \ store the maximum k numbers.\n        // The heap will have size k.\n      \
    \  // We insert the first k elements into the heap.\n        // Then we iterate\
    \ through the rest of the elements.\n        // If the element is greater than\
    \ the minimum element in the heap, we remove the minimum element and insert the\
    \ new element.\n        // After iterating through the list, we return the heap.\n\
    \        // Time Complexity: O(nlogk)\n        // Space Complexity: O(k)\n   \
    \     val heap = new Heap[Long](k.toInt, (a : Long, b : Long) => a < b)\n    \
    \    for (i <- 0 until k.toInt) heap.insert(arr(i))\n        for (i <- k.toInt\
    \ until arr.length) {\n            if (arr(i) > heap.peek()) {\n             \
    \   heap.remove()\n                heap.insert(arr(i))\n            }\n      \
    \  }\n        heap.toList", "        // Fill up this function body\n        //\
    \ You can add another function as well, if required\n        val pq = new PriorityQueue[Long]()(Ordering.by(-_))\n\
    \        for (i <- arr) {\n            pq.enqueue(i)\n            if (pq.size\
    \ > k) pq.dequeue\n        }\n        pq.toList.sorted", "        // Fill up this\
    \ function body\n        // `arr` is a list of integers\n        // `k` is a positive\
    \ integer\n        // Return a sorted list of length `k` with the maximum `k`\
    \ numbers in `arr`\n        arr.sorted.takeRight(k.toInt)", "        // Fill up\
    \ this function body\n        // `arr` is a list of integers\n        // `k` is\
    \ a positive integer\n        // You have to return a sorted list of length `k`\
    \ with the maximum k numbers in `arr`\n        // You can assume that `k` is less\
    \ than or equal to the length of `arr`\n        // You can assume that `k` is\
    \ greater than 0\n        // You can assume that `arr` is not empty\n        //\
    \ You can assume that `arr` is not null\n        // You can assume that `arr`\
    \ is not null\n        // You can assume that `arr` is not null\n        // You\
    \ can assume that `arr` is not null\n        // You can assume that `arr` is not\
    \ null\n        // You can assume that `arr` is not null\n        // You can assume\
    \ that `arr` is not null\n        // You can assume that `arr` is not null\n \
    \       // You can assume that `arr` is not null\n        // You can assume that\
    \ `arr` is not null\n        // You can assume that `arr` is not null\n      \
    \  // You can assume that `arr` is not null\n        // You can assume that `arr`\
    \ is not null\n        // You can assume that `arr` is not null\n        // You\
    \ can assume that `arr` is not null\n        // You can assume that `arr` is not\
    \ null\n        // You can assume that `arr` is not null\n        // You can assume\
    \ that `arr` is not null\n        // You can assume that `arr` is not null\n \
    \       // You can assume that `arr` is not null\n        // You can assume that\
    \ `arr` is not null\n        // You can assume that `arr` is not null\n      \
    \  // You can assume that `arr` is not null\n        // You can assume that `arr`\
    \ is not null\n        // You can assume that `arr` is not null\n        // You\
    \ can assume that `arr` is not null\n        // You can assume that `arr` is not\
    \ null\n        // You can assume that `arr` is not null\n        // You can assume\
    \ that `arr` is not null\n        // You can assume that `arr` is not null\n \
    \       // You can assume that `arr` is not null\n        // You can assume that",
  "        // Fill up this function body\n        // `arr` is a list of integers\n\
    \        // `k` is a positive integer\n        // You have to return a sorted\
    \ list of length `k` with the maximum k numbers in `arr`\n        arr.sortWith(_\
    \ > _).take(k.toInt)", "        // Fill up this function body\n        // `arr`\
    \ is a list of integers\n        // `k` is a positive integer\n        // Return\
    \ a sorted list of length `k` with the maximum `k` numbers in `arr`\n        arr.sortWith(_\
    \ > _).take(k.toInt)", "        // We will use a min-heap to store the maximum\
    \ k numbers.\n        // The heap will be initialized with the first k numbers\
    \ in the list.\n        // Then we will iterate through the rest of the list and\
    \ compare each number\n        // with the minimum number in the heap. If the\
    \ number is greater than the minimum\n        // number, we will remove the minimum\
    \ number and add the new number to the heap.\n        // We will continue this\
    \ process until we reach the end of the list.\n        // Finally, we will return\
    \ the heap as a sorted list.\n        val heap = new mutable.PriorityQueue[Long]()(Ordering.by(-_))\n\
    \        for (i <- 0 until k.toInt) {\n            heap.enqueue(arr(i))\n    \
    \    }\n        for (i <- k.toInt until arr.length) {\n            if (arr(i)\
    \ > heap.head) {\n                heap.dequeue\n                heap.enqueue(arr(i))\n\
    \            }\n        }\n        heap.toList.sorted", "        // Fill up this\
    \ function body\n        // `arr` is a list of integers\n        // `k` is a positive\
    \ integer\n        // You have to return a sorted list of length `k` with the\
    \ maximum k numbers in `arr`\n        // You can use the following functions:\n\
    \        //     - `arr.sorted`\n        //     - `arr.length`\n        //    \
    \ - `arr.take`\n        //     - `arr.drop`\n        //     - `arr.slice`\n  \
    \      //     - `arr.reverse`\n        //     - `arr.head`\n        //     - `arr.tail`\n\
    \        //     - `arr.init`\n        //     - `arr.last`\n        //     - `arr.max`\n\
    \        //     - `arr.min`\n        //     - `arr.sum`\n        //     - `arr.product`\n\
    \        //     - `arr.contains`\n        //     - `arr.mkString`\n        //\
    \     - `arr.mkString(sep)`\n        //     - `arr.mkString(start, sep, end)`\n\
    \        //     - `arr.toString`\n        //     - `arr.toList`\n        //  \
    \   - `arr.toArray`\n        //     - `arr.toSet`\n        //     - `arr.toMap`\n\
    \        //     - `arr.toSeq`\n        //     - `arr.toIndexedSeq`\n        //\
    \     - `arr.toBuffer`\n        //     - `arr.toIterable`\n        //     - `arr.toIterator`\n\
    \        //     - `arr.toStream`\n        //     - `arr.toStream`\n        //\
    \     - `arr.toVector`\n        //     - `arr.to(LazyList)`\n        //     -\
    \ `arr.to(List)`\n        //     - `arr.to(Array)`\n        //     - `arr.to(Set)`\n\
    \        //     - `arr.to(Map)`\n        //     - `arr.to(Seq)`\n        //  \
    \   - `arr.to(IndexedSeq)`\n        //     - `arr.", "        val heap = new PriorityQueue[Long]()(Ordering.by(-_))\n\
    \        for (i <- arr) {\n            heap.enqueue(i)\n            if (heap.size\
    \ > k) heap.dequeue\n        }\n        heap.toList.sorted", "        // Fill\
    \ up this function body\n        // `arr` is a list of integers\n        // `k`\
    \ is a positive integer\n        // Return a sorted list of length `k` with the\
    \ maximum k numbers in `arr`\n        arr.sorted.takeRight(k.toInt)", "      \
    \  val heap = new Heap[Long]()\n        for (i <- 0 until k.toInt) heap.insert(arr(i))\n\
    \        for (i <- k.toInt until arr.length) {\n            if (arr(i) > heap.peek)\
    \ {\n                heap.pop\n                heap.insert(arr(i))\n         \
    \   }\n        }\n        heap.toList", "        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // You have to return a sorted list of length `k` with the maximum k\
    \ numbers in `arr`\n        arr.sortWith(_ > _).take(k.toInt)", "        // We\
    \ can use a max heap to store the k largest elements.\n        // The heap will\
    \ be of size k and will store the k largest elements.\n        // We will iterate\
    \ through the list and if the current element is larger than the smallest element\
    \ in the heap,\n        // we will remove the smallest element and add the current\
    \ element to the heap.\n        // At the end, we will return the heap as a sorted\
    \ list.\n        // Time complexity: O(n log k)\n        // Space complexity:\
    \ O(k)\n        val heap = new PriorityQueue[Long]()(Ordering.by(-_))\n      \
    \  for (i <- arr) {\n            if (heap.size < k) heap.enqueue(i)\n        \
    \    else if (i > heap.head) {\n                heap.dequeue\n               \
    \ heap.enqueue(i)\n            }\n        }\n        heap.toList.sorted", "  \
    \      // Define the maximum function as requested above\n        def maximum(arr\
    \ : List[Long], k : Long, acc : List[Long]) : List[Long] = {\n            if (k\
    \ == 0) acc\n            else {\n                val max = arr.max\n         \
    \       maximum(arr.filter(_ != max), k - 1, acc :+ max)\n            }\n    \
    \    }\n        // Return the result of calling maximum with the correct arguments\n\
    \        maximum(arr, k, List[Long]())", "        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // You have to return a sorted list of length `k` with the maximum k\
    \ numbers in `arr`\n        // You can assume that `k` is less than or equal to\
    \ the length of `arr`\n        // You can assume that `k` is greater than 0\n\
    \        // You can assume that `arr` is not empty\n        // You can assume\
    \ that `arr` is not null\n        // You can assume that `arr` does not contain\
    \ null elements\n        // You can assume that `arr` is not a string\n      \
    \  // You can assume that `arr` is not a dictionary\n        // You can assume\
    \ that `arr` is not a set\n        // You can assume that `arr` is not a tuple\n\
    \        // You can assume that `arr` is not a range\n        // You can assume\
    \ that `arr` is not a matrix\n        // You can assume that `arr` is not a 2D\
    \ array\n        // You can assume that `arr` is not a 3D array\n        // You\
    \ can assume that `arr` is not a 4D array\n        // You can assume that `arr`\
    \ is not a 5D array\n        // You can assume that `arr` is not a 6D array\n\
    \        // You can assume that `arr` is not a 7D array\n        // You can assume\
    \ that `arr` is not a 8D array\n        // You can assume that `arr` is not a\
    \ 9D array\n        // You can assume that `arr` is not a 10D array\n        //\
    \ You can assume that `arr` is not a 11D array\n        // You can assume that\
    \ `arr` is not a 12D array\n        // You can assume that `arr` is not a 13D\
    \ array\n        // You can assume that `arr` is not a 14D array\n        // You\
    \ can assume that `arr` is not a 15D array\n        // You can assume that `arr`\
    \ is not a 16D array\n        // You can assume that `arr` is not a 17D array\n\
    \        // You can assume that `arr` is not a 18D array\n        // You can assume\
    \ that `arr` is not a 19D array\n        // You can assume that `arr`", "    \
    \    // Fill up this function body\n        // `arr` is a list of integers\n \
    \       // `k` is a positive integer\n        // You have to return a sorted list\
    \ of length `k` with the maximum k numbers in `arr`\n        // You can assume\
    \ that `k` is less than or equal to the length of `arr`\n        // You can assume\
    \ that `k` is greater than 0\n        arr.sorted.takeRight(k.toInt)", "      \
    \  // We can use a heap to solve this problem.\n        // The heap will be a\
    \ max heap.\n        // We will add all elements to the heap.\n        // If the\
    \ heap size is greater than k, we will remove the max element from the heap.\n\
    \        // When we are done, we will return the elements in the heap in reverse\
    \ order.\n        val heap = new PriorityQueue[Long]()(Ordering.Long.reverse)\n\
    \        for (i <- arr) {\n            heap.enqueue(i)\n            if (heap.size\
    \ > k) heap.dequeue\n        }\n        heap.toList.reverse", "        // Fill\
    \ up this function body\n        // 'return List[Long]()' for Scala and 'return\
    \ new ArrayList<Long>()' for Java\n        return List[Long]()", "        // We\
    \ can use a priority queue to solve this problem.\n        // We will add the\
    \ first k elements to the priority queue.\n        // Then we will iterate through\
    \ the rest of the elements.\n        // If the element is greater than the minimum\
    \ element in the priority queue,\n        // we will remove the minimum element\
    \ and add the new element.\n        // Then we will return the elements in the\
    \ priority queue.\n        val pq = new PriorityQueue[Long]()(Ordering.Long.reverse)\n\
    \        for (i <- 0l until k) {\n            pq.enqueue(arr(i.toInt))\n     \
    \   }\n        for (i <- k until arr.length) {\n            if (arr(i.toInt) >\
    \ pq.head) {\n                pq.dequeue\n                pq.enqueue(arr(i.toInt))\n\
    \            }\n        }\n        pq.toList", "        val heap = new PriorityQueue[Long]()(Ordering.by(-_))\n\
    \        for (i <- arr) {\n            heap.enqueue(i)\n            if (heap.size\
    \ > k) heap.dequeue\n        }\n        heap.toList.reverse", "        // Fill\
    \ up this function body\n        // `arr` is a list of integers\n        // `k`\
    \ is a positive integer\n        // return a sorted list of length `k` with the\
    \ maximum `k` numbers in `arr`\n        arr.sortWith(_ > _).take(k.toInt)", " \
    \       // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n        // of length k with the maximum k numbers in arr.\n        //\
    \ Example 1:\n        // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n        // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n        //\
    \ Example 2:\n        // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)),\
    \ (2l))\n        // (List[Long](4l.toLong, 4l.toLong))\n        // Example 3:\n\
    \        // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n        // (List[Long](2l.toLong))\n\
    \        // Note:\n        // 1. The length of the list will be in the range of\
    \ [1, 1000].\n        // 2. The elements in the list will be in the range of [-1000,\
    \ 1000].\n        // 3. 0 <= k <= len(arr)\n        def maximum(arr : List[Long],\
    \ k : Long) : List[Long] = {\n            // Given a list arr of integers and\
    \ a positive integer k, return a sorted list \n            // of length k with\
    \ the maximum k numbers in arr.\n            // Example 1:\n            // >>>\
    \ maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n           \
    \ // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n            // Example 2:\n\
    \            // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \            // (List[Long](4l.toLong, 4l.toLong))\n            // Example 3:\n\
    \            // >>> maximum((List[Long](-3l.toLong, 2l.toLong,", "        // Fill\
    \ up this function body\n        // You can add another function as well, if required\n\
    \        arr.sorted.takeRight(k.toInt)", "        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // You have to return a sorted list of length `k` with the maximum k\
    \ numbers in `arr`\n        // You can assume that `k` is less than or equal to\
    \ the length of `arr`\n        // You can assume that `k` is greater than 0\n\
    \        arr.sortWith(_ > _).take(k.toInt)", "        // Fill up this function\
    \ body\n        // `arr` is a list of integers\n        // `k` is the number of\
    \ elements to return\n        // You can return a list of integers\n        //\
    \ You can use the `println` function to debug\n        // Example:\n        //\
    \ println(arr)\n        // println(k)\n        // println(arr.length)\n      \
    \  // println(arr(0))\n        // println(arr(1))\n        // println(arr(2))\n\
    \        // println(arr(3))\n        // println(arr(4))\n        // println(arr(5))\n\
    \        // println(arr(6))\n        // println(arr(7))\n        // println(arr(8))\n\
    \        // println(arr(9))\n        // println(arr(10))\n        // println(arr(11))\n\
    \        // println(arr(12))\n        // println(arr(13))\n        // println(arr(14))\n\
    \        // println(arr(15))\n        // println(arr(16))\n        // println(arr(17))\n\
    \        // println(arr(18))\n        // println(arr(19))\n        // println(arr(20))\n\
    \        // println(arr(21))\n        // println(arr(22))\n        // println(arr(23))\n\
    \        // println(arr(24))\n        // println(arr(25))\n        // println(arr(26))\n\
    \        // println(arr(27))\n        // println(arr(28))\n        // println(arr(29))\n\
    \        // println(arr(30))\n        // println(arr(31))\n        // println(arr(32))\n\
    \        // println(arr(33))\n        // println(arr(34))\n        // println(arr(35))\n\
    \        // println(arr(36))\n        // println(arr(37))\n        // println(arr(38))\n\
    \        // println(arr(39))\n        // println(arr(40))\n        // println(arr(41))\n\
    \        // println(arr(42))\n        // println(arr(43))\n        // println(arr(44))\n\
    \        // println(arr(45))\n        // println(arr(46))\n        // println(arr",
  "        // We can use a heap to solve this problem.\n        // We can use a min-heap\
    \ to store the maximum k numbers.\n        // We can use a max-heap to store the\
    \ minimum k numbers.\n        // We can use a min-heap to store the maximum k\
    \ numbers.\n        // We can use a max-heap to store the minimum k numbers.\n\
    \        // We can use a min-heap to store the maximum k numbers.\n        //\
    \ We can use a max-heap to store the minimum k numbers.\n        // We can use\
    \ a min-heap to store the maximum k numbers.\n        // We can use a max-heap\
    \ to store the minimum k numbers.\n        // We can use a min-heap to store the\
    \ maximum k numbers.\n        // We can use a max-heap to store the minimum k\
    \ numbers.\n        // We can use a min-heap to store the maximum k numbers.\n\
    \        // We can use a max-heap to store the minimum k numbers.\n        //\
    \ We can use a min-heap to store the maximum k numbers.\n        // We can use\
    \ a max-heap to store the minimum k numbers.\n        // We can use a min-heap\
    \ to store the maximum k numbers.\n        // We can use a max-heap to store the\
    \ minimum k numbers.\n        // We can use a min-heap to store the maximum k\
    \ numbers.\n        // We can use a max-heap to store the minimum k numbers.\n\
    \        // We can use a min-heap to store the maximum k numbers.\n        //\
    \ We can use a max-heap to store the minimum k numbers.\n        // We can use\
    \ a min-heap to store the maximum k numbers.\n        // We can use a max-heap\
    \ to store the minimum k numbers.\n        // We can use a min-heap to store the\
    \ maximum k numbers.\n        // We can use a max-heap to store the minimum k\
    \ numbers.\n        // We can use a min-heap to store the maximum k numbers.\n\
    \        // We can use a max-heap to store the minimum k numbers.\n        //\
    \ We can use a min-heap to store the maximum k numbers.\n        // We can use\
    \ a max-heap to store", "        // Fill up this function body\n        // `arr`\
    \ is a list of integers\n        // `k` is a positive integer\n        // You\
    \ have to return a sorted list of length `k` with the maximum k numbers in `arr`\n\
    \        arr.sorted.takeRight(k.toInt)", '        arr.sortWith(_ > _).take(k.toInt)',
  "        // Fill up this function body\n        // `arr` is a list of integers\n\
    \        // `k` is a positive integer\n        // You have to return a sorted\
    \ list of length `k` with the maximum k numbers in `arr`\n        arr.sorted.takeRight(k.toInt)",
  "        // We can use a max heap to solve this problem.\n        // The max heap\
    \ will store the k largest elements in the array.\n        // We will iterate\
    \ through the array, and if the current element is larger than the smallest element\
    \ in the heap,\n        // we will remove the smallest element from the heap and\
    \ add the current element to the heap.\n        // After iterating through the\
    \ array, we will return the heap.\n        val heap = new MaxHeap[Long](k.toInt)\n\
    \        for (element <- arr) {\n            if (heap.size < k) heap.insert(element)\n\
    \            else if (element > heap.peek) {\n                heap.remove()\n\
    \                heap.insert(element)\n            }\n        }\n        heap.toList",
  "        // Your code here\n        return List[Long]()", "        // Fill up this\
    \ function body\n        // `arr` is a list of integers\n        // `k` is a positive\
    \ integer\n        // You have to return a sorted list of length `k` with the\
    \ maximum k numbers in `arr`\n        // You can assume that `k` is less than\
    \ or equal to the length of `arr`\n        // You can assume that `k` is greater\
    \ than 0\n        val heap = new Heap[Long]\n        for (i <- arr) {\n      \
    \      heap.insert(i)\n        }\n        val result = new ListBuffer[Long]\n\
    \        for (i <- 0 until k.toInt) {\n            result += heap.extractMax\n\
    \        }\n        result.toList", "        // Fill up this function body\n \
    \       // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // You have to return a sorted list of length `k` with the maximum k\
    \ numbers in `arr`\n        // You can assume that `k` is less than or equal to\
    \ the length of `arr`\n        // You can assume that `k` is greater than 0\n\
    \        arr.sorted.takeRight(k.toInt)", "        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // Return a sorted list of length `k` with the maximum k numbers in `arr`\n\
    \        arr.sorted.takeRight(k.toInt)", "        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // You have to return a sorted list of length `k` with the maximum k\
    \ numbers in `arr`\n        // You can assume that `k` is less than or equal to\
    \ the length of `arr`\n        // You can assume that `k` is greater than 0\n\
    \        arr.sorted.takeRight(k.toInt)", "        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // return a sorted list of length `k` with the maximum `k` numbers in\
    \ `arr`\n        arr.sorted.takeRight(k.toInt)", "        // Fill up this function\
    \ body\n        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // You have to return a sorted list of length `k` with the maximum k\
    \ numbers in `arr`\n        // You can assume that `k` is less than or equal to\
    \ the length of `arr`\n        // You can assume that `k` is greater than 0\n\
    \        // You can assume that `arr` is not empty\n        // You can assume\
    \ that `arr` is not null\n        // You can assume that `arr` does not contain\
    \ null\n        // You can assume that `arr` does not contain duplicates\n   \
    \     // You can assume that `arr` is sorted in descending order\n        // You\
    \ can assume that `arr` is sorted in ascending order\n        // You can assume\
    \ that `arr` is sorted in non-decreasing order\n        // You can assume that\
    \ `arr` is sorted in non-increasing order\n        // You can assume that `arr`\
    \ is sorted in random order\n        // You can assume that `arr` is sorted in\
    \ non-random order\n        // You can assume that `arr` is not sorted\n     \
    \   // You can assume that `arr` is sorted in non-ascending order\n        //\
    \ You can assume that `arr` is sorted in non-descending order\n        // You\
    \ can assume that `arr` is sorted in non-random non-ascending order\n        //\
    \ You can assume that `arr` is sorted in non-random non-descending order\n   \
    \     // You can assume that `arr` is sorted in non-random non-increasing order\n\
    \        // You can assume that `arr` is sorted in non-random non-decreasing order\n\
    \        // You can assume that `arr` is sorted in random non-ascending order\n\
    \        // You can assume that `arr` is sorted in random non-descending order\n\
    \        // You can assume that `arr` is sorted in random non-increasing order\n\
    \        // You can assume that `arr` is sorted in random non-decreasing order\n\
    \        // You can assume that `arr` is sorted in non-random non-ascending non-descending\
    \ order\n        // You can assume that `arr` is sorted in non-random non-ascending\
    \ non-increasing order\n        // You can assume that `arr` is sorted", "   \
    \     // Fill up this function body\n        // `arr` is a list of integers\n\
    \        // `k` is a positive integer\n        // You have to return a sorted\
    \ list of length `k` with the maximum k numbers in `arr`\n        // You can assume\
    \ that `k` is less than or equal to the length of `arr`\n        // You can assume\
    \ that `k` is greater than 0\n        val n = arr.length\n        val heap = new\
    \ Heap[Long](n)\n        for (i <- 0 until n) heap.insert(arr(i))\n        val\
    \ result = new Array[Long](k.toInt)\n        for (i <- 0 until k.toInt) result(i)\
    \ = heap.extractMax\n        result.toList", "        // Fill up this function\
    \ body\n        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // You have to return a sorted list of length `k` with the maximum k\
    \ numbers in `arr`\n        arr.sorted.takeRight(k.toInt)", "        // We can\
    \ use a heap to solve this problem.\n        // We can use a max heap to store\
    \ the first k elements of the list.\n        // Then, we can iterate through the\
    \ rest of the list and compare each element to the root of the heap.\n       \
    \ // If the element is greater than the root, we can remove the root and add the\
    \ element to the heap.\n        // After we have iterated through the entire list,\
    \ we can return the heap.\n        // This will take O(n log k) time and O(k)\
    \ space.\n        val heap = new mutable.PriorityQueue[Long]()\n        for (i\
    \ <- 0 until k.toInt) {\n            heap.enqueue(arr(i))\n        }\n       \
    \ for (i <- k.toInt until arr.length) {\n            if (arr(i) > heap.head) {\n\
    \                heap.dequeue\n                heap.enqueue(arr(i))\n        \
    \    }\n        }\n        heap.toList.sorted", "        // Fill up this function\
    \ body\n        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // You have to return a sorted list of length `k` with the maximum k\
    \ numbers in `arr`\n        // If `k` is greater than the length of `arr`, return\
    \ the entire list `arr` sorted\n        // If `k` is zero, return an empty list\n\
    \        // The elements in the list will be in the range of [-1000, 1000]\n \
    \       // The range of the length of the list will be in the range of [1, 1000]\n\
    \        // 0 <= k <= len(arr)\n        arr.sorted.takeRight(k.toInt)", "    \
    \    // Fill up this function body\n        // 'arr' is a list of integers\n \
    \       // 'k' is a positive integer\n        // Return a sorted list of length\
    \ 'k' with the maximum 'k' numbers in 'arr'\n        arr.sorted.takeRight(k.toInt)",
  "        // Fill up this function body\n        // `arr` is a list of integers\n\
    \        // `k` is a positive integer\n        // You have to return a sorted\
    \ list of length `k` with the maximum k numbers in `arr`\n        // You can assume\
    \ that `k` is always valid, 1 \u2264 k \u2264 arr.length\n        // If there\
    \ are multiple answers, return the answer that comes first in the array.\n   \
    \     // If there is no answer, return an empty list.\n        arr.sorted.takeRight(k.toInt).reverse",
  "        // Fill up this function body\n        // `arr` is a list of integers\n\
    \        // `k` is a positive integer\n        // Return a sorted list of length\
    \ `k` with the maximum k numbers in `arr`\n        arr.sorted.takeRight(k.toInt)",
  "        // Fill up this function body\n        // 'return List[Long]()' for Scala\
    \ and 'return new ArrayList<Long>()' for Java\n        return List[Long]()"]
stop_tokens:
- "\n    }\n"
