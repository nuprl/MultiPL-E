name: HumanEval_87_get_row
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // You are given a 2 dimensional data, as a nested lists,\n    // which is\
  \ similar to matrix, however, unlike matrices,\n    // each row may contain a different\
  \ number of columns.\n    // Given lst, and integer x, find integers x in the list,\n\
  \    // and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    // each\
  \ tuple is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates\
  \ initially by rows in ascending order.\n    // Also, sort coordinates of the row\
  \ by columns in descending order.\n    // Examples:\n    // >>> getRow((List[List[Long]](List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long,\
  \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
  \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
  \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
  \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
  \ x : Long) : List[Tuple2[Long, Long]] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
  \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
  \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 1l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 2l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
  \ Long]]((0l, 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l,\
  \ 0l), (5l, 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
  \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
  \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
  \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
  \ Long]]((2l, 2l)))));\n    }\n\n}\n"
completions: ["        // Fill up this function body\n        // 'lst' is a list of\
    \ lists, each list is a row\n        // 'x' is the number to be searched\n   \
    \     // Return a list of tuples, each tuple is a coordinate - (row, column)\n\
    \        // Sort coordinates initially by rows in ascending order.\n        //\
    \ Also, sort coordinates of the row by columns in descending order.\n        //\
    \ If the number is not found, return an empty list.\n        var result = List[Tuple2[Long,\
    \ Long]]()\n        for (i <- 0 until lst.length) {\n            for (j <- 0 until\
    \ lst(i).length) {\n                if (lst(i)(j) == x) {\n                  \
    \  result = result :+ (i.toLong, j.toLong)\n                }\n            }\n\
    \        }\n        result.sortWith(_._1 < _._1).sortWith(_._2 > _._2)", "   \
    \     var result : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n   \
    \     for (i <- 0 until lst.length) {\n            for (j <- 0 until lst(i).length)\
    \ {\n                if (lst(i)(j) == x) {\n                    result = (i, j)\
    \ :: result\n                }\n            }\n        }\n        result.sortWith((a,\
    \ b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))", "        var result :\
    \ List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until\
    \ lst.length) {\n            for (j <- 0 until lst(i).length) {\n            \
    \    if (lst(i)(j) == x) {\n                    result = result :+ (i.toLong,\
    \ j.toLong)\n                }\n            }\n        }\n        result.sortWith((a,\
    \ b) => {\n            if (a._1 < b._1) {\n                true\n            }\
    \ else if (a._1 == b._1) {\n                a._2 > b._2\n            } else {\n\
    \                false\n            }\n        })", "        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => a._1\
    \ < b._1 || (a._1 == b._1 && a._2 > b._2))", "        // Write your code here\n\
    \        var result : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n\
    \        for (i <- 0 until lst.length) {\n            for (j <- 0 until lst(i).length)\
    \ {\n                if (lst(i)(j) == x) {\n                    result = result\
    \ :+ (i.toLong, j.toLong)\n                }\n            }\n        }\n     \
    \   result.sortWith((a, b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))",
  "        // Fill up this function body\n        // 'lst' is a nested list, which\
    \ is similar to matrix, however, unlike matrices,\n        // each row may contain\
    \ a different number of columns.\n        // 'x' is an integer\n        // You\
    \ have to return list of tuples, [(x1, y1), (x2, y2) ...] such that\n        //\
    \ each tuple is a coordinate - (row, columns), starting with 0.\n        // Sort\
    \ coordinates initially by rows in ascending order.\n        // Also, sort coordinates\
    \ of the row by columns in descending order.\n        var result = List[Tuple2[Long,\
    \ Long]]()\n        for (i <- 0 until lst.length) {\n            for (j <- 0 until\
    \ lst(i).length) {\n                if (lst(i)(j) == x) {\n                  \
    \  result = result :+ (i.toLong, j.toLong)\n                }\n            }\n\
    \        }\n        result.sortWith(_._1 < _._1).sortWith(_._2 > _._2)", "   \
    \     var result : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n   \
    \     for (i <- 0 until lst.length) {\n            for (j <- 0 until lst(i).length)\
    \ {\n                if (lst(i)(j) == x) {\n                    result = result\
    \ :+ (i.toLong, j.toLong)\n                }\n            }\n        }\n     \
    \   result.sortWith((a, b) => (a._1 < b._1) || (a._1 == b._1 && a._2 > b._2))",
  "        var result : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n  \
    \      for (i <- 0 until lst.length) {\n            for (j <- 0 until lst(i).length)\
    \ {\n                if (lst(i)(j) == x) {\n                    result = result\
    \ :+ (i.toLong, j.toLong)\n                }\n            }\n        }\n     \
    \   result.sortWith((a, b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))",
  "        var result : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n  \
    \      for (i <- 0 until lst.length) {\n            for (j <- 0 until lst(i).length)\
    \ {\n                if (lst(i)(j) == x) {\n                    result = result\
    \ :+ (i.toLong, j.toLong)\n                }\n            }\n        }\n     \
    \   result.sortWith((a, b) => {\n            if (a._1 == b._1) {\n           \
    \     a._2 > b._2\n            } else {\n                a._1 < b._1\n       \
    \     }\n        })", "        // Fill up this function body\n        // 'lst'\
    \ is a nested list, similar to matrix,\n        // but unlike matrix, each row\
    \ may contain a different number of columns.\n        // 'x' is an integer.\n\
    \        // You have to find all the integers 'x' in the list,\n        // and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n        // each tuple\
    \ is a coordinate - (row, columns), starting with 0.\n        // Sort coordinates\
    \ initially by rows in ascending order.\n        // Also, sort coordinates of\
    \ the row by columns in descending order.\n        // If you find a coordinate\
    \ (row, column) of x,\n        // then you have to add it to the list,\n     \
    \   // and return the list.\n        // If you don't find any coordinate of x,\n\
    \        // then return an empty list.\n        // Note: You have to write this\
    \ function without using any inbuilt functions.\n        // Note: You have to\
    \ write this function without using any mutable data structures.\n        // Note:\
    \ You have to write this function without using any mutable variables.\n     \
    \   // Note: You have to write this function without using any mutable functions.\n\
    \        // Note: You have to write this function without using any mutable classes.\n\
    \        // Note: You have to write this function without using any mutable objects.\n\
    \        // Note: You have to write this function without using any mutable traits.\n\
    \        // Note: You have to write this function without using any mutable packages.\n\
    \        // Note: You have to write this function without using any mutable imports.\n\
    \        // Note: You have to write this function without using any mutable libraries.\n\
    \        // Note: You have to write this function without using any mutable frameworks.\n\
    \        // Note: You have to write this function without using any mutable platforms.\n\
    \        // Note: You have to write this function without using any mutable languages.\n\
    \        // Note: You have to write this function without using any mutable paradigms.\n\
    \        // Note: You have to write this function without using any mutable algorithms.\n\
    \        // Note: You have to write this function without using any mutable data.\n\
    \        // Note: You have to write this function without using any mutable code.\n\
    \       ", "        var result : List[Tuple2[Long, Long]] = List[Tuple2[Long,\
    \ Long]]()\n        for (i <- 0 until lst.length) {\n            for (j <- 0 until\
    \ lst(i).length) {\n                if (lst(i)(j) == x) {\n                  \
    \  result = (i, j) :: result\n                }\n            }\n        }\n  \
    \      result.sortWith((a, b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))",
  "        var result : List[Tuple2[Long, Long]] = List()\n        for (i <- 0 until\
    \ lst.length) {\n            for (j <- 0 until lst(i).length) {\n            \
    \    if (lst(i)(j) == x) {\n                    result = result :+ (i.toLong,\
    \ j.toLong)\n                }\n            }\n        }\n        result.sortWith((a,\
    \ b) => (a._1 < b._1) || (a._1 == b._1 && a._2 > b._2))", "        // Fill up\
    \ this function body\n        // 'lst' is a nested list, which is similar to matrix,\
    \ however, unlike matrices,\n        // each row may contain a different number\
    \ of columns.\n        // 'x' is an integer.\n        // You have to find integers\
    \ 'x' in the list,\n        // and return list of tuples, [(x1, y1), (x2, y2)\
    \ ...] such that\n        // each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n        // Sort coordinates initially by rows in ascending order.\n\
    \        // Also, sort coordinates of the row by columns in descending order.\n\
    \        // If there are no 'x' in the list, return empty list.\n        // If\
    \ the list is empty, return empty list.\n        // If the list is None, return\
    \ empty list.\n        // Note: You can use scala.math.Nil for empty list.\n \
    \       // Note: You can use scala.math.None for empty list.\n        // Note:\
    \ You can use scala.math.None for empty list.\n        // Note: You can use scala.math.None\
    \ for empty list.\n        // Note: You can use scala.math.None for empty list.\n\
    \        // Note: You can use scala.math.None for empty list.\n        // Note:\
    \ You can use scala.math.None for empty list.\n        // Note: You can use scala.math.None\
    \ for empty list.\n        // Note: You can use scala.math.None for empty list.\n\
    \        // Note: You can use scala.math.None for empty list.\n        // Note:\
    \ You can use scala.math.None for empty list.\n        // Note: You can use scala.math.None\
    \ for empty list.\n        // Note: You can use scala.math.None for empty list.\n\
    \        // Note: You can use scala.math.None for empty list.\n        // Note:\
    \ You can use scala.math.None for empty list.\n        // Note: You can use scala.math.None\
    \ for empty list.\n        // Note: You can use scala.math.None for empty list.\n\
    \        // Note: You can use scala.math.None for empty list", "        var result\
    \ : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0\
    \ until lst.length) {\n            for (j <- 0 until lst(i).length) {\n      \
    \          if (lst(i)(j) == x) {\n                    result = result :+ (i.toLong,\
    \ j.toLong)\n                }\n            }\n        }\n        result.sortWith((a,\
    \ b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))", "        var result :\
    \ List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until\
    \ lst.length) {\n            for (j <- 0 until lst(i).length) {\n            \
    \    if (lst(i)(j) == x) {\n                    result = result :+ (i.toLong,\
    \ j.toLong)\n                }\n            }\n        }\n        result.sortWith((a,\
    \ b) => {\n            if (a._1 < b._1) {\n                true\n            }\
    \ else if (a._1 == b._1) {\n                a._2 > b._2\n            } else {\n\
    \                false\n            }\n        })", "        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => (a._1\
    \ < b._1) || (a._1 == b._1 && a._2 > b._2))", "        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            var row : List[Long] = lst(i)\n            for (j <- 0 until row.length)\
    \ {\n                if (row(j) == x) {\n                    result = result :+\
    \ (i.toLong, j.toLong)\n                }\n            }\n        }\n        result.sortWith((a,\
    \ b) => {\n            if (a._1 < b._1) {\n                true\n            }\
    \ else if (a._1 == b._1) {\n                a._2 > b._2\n            } else {\n\
    \                false\n            }\n        })", "        // Fill up this function\
    \ body\n        // 'lst' is a nested list, similar to matrix,\n        // 'x'\
    \ is an integer to be searched in the list\n        // Return a list of tuples,\
    \ [(x1, y1), (x2, y2) ...] such that\n        // each tuple is a coordinate -\
    \ (row, columns), starting with 0.\n        // Sort coordinates initially by rows\
    \ in ascending order.\n        // Also, sort coordinates of the row by columns\
    \ in descending order.\n        // If 'x' is not found in the list, return empty\
    \ list.\n        // If 'lst' is empty, return empty list.\n        // Note:\n\
    \        // You can use built-in functions such as 'sortWith' and 'sorted'\n \
    \       // to sort the list of tuples.\n        // You can use built-in functions\
    \ such as 'zipWithIndex' to get\n        // the index of elements in the list.\n\
    \        // You can use built-in functions such as 'map' to apply a function\n\
    \        // to each element of a list.\n        // You can use built-in functions\
    \ such as 'filter' to filter a list.\n        // You can use built-in functions\
    \ such as 'flatMap' to flatten a list.\n        // You can use built-in functions\
    \ such as 'foldLeft' to fold a list.\n        // You can use built-in functions\
    \ such as 'foldRight' to fold a list.\n        // You can use built-in functions\
    \ such as 'fold' to fold a list.\n        // You can use built-in functions such\
    \ as 'reduceLeft' to reduce a list.\n        // You can use built-in functions\
    \ such as 'reduceRight' to reduce a list.\n        // You can use built-in functions\
    \ such as 'reduce' to reduce a list.\n        // You can use built-in functions\
    \ such as 'scanLeft' to scan a list.\n        // You can use built-in functions\
    \ such as 'scanRight' to scan a list.\n        // You can use built-in functions\
    \ such as 'scan' to scan a list.\n        // You can use built-in functions such\
    \ as 'mkString' to convert a list\n        // to a string.\n        // You can\
    \ use built-in functions such as", "        var result : List[Tuple2[Long, Long]]\
    \ = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n    \
    \        for (j <- 0 until lst(i).length) {\n                if (lst(i)(j) ==\
    \ x) {\n                    result = result :+ (i.toLong, j.toLong)\n        \
    \        }\n            }\n        }\n        result.sortWith((a, b) => a._1 <\
    \ b._1 || (a._1 == b._1 && a._2 > b._2))", "        // Fill up this function body\n\
    \        // 'lst' is a list of lists, and 'x' is the element to be searched\n\
    \        // Return a list of tuples, each tuple is a coordinate - (row, column)\n\
    \        // Sort the tuples initially by rows in ascending order\n        // Also,\
    \ sort coordinates of the row by columns in descending order\n        // If 'x'\
    \ is not found in 'lst', return an empty list\n        // If 'lst' is empty, return\
    \ an empty list\n        // If 'lst' is a list of empty lists, return an empty\
    \ list\n        var result = List[Tuple2[Long, Long]]()\n        var i = 0\n \
    \       for (row <- lst) {\n            var j = 0\n            for (col <- row)\
    \ {\n                if (col == x) {\n                    result = result :+ (i,\
    \ j)\n                }\n                j += 1\n            }\n            i\
    \ += 1\n        }\n        result.sortBy(x => (x._1, -x._2))"]
stop_tokens:
- "\n    }\n"
