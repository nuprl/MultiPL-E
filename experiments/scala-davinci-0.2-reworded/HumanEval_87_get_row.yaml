name: HumanEval_87_get_row
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // You are given a 2 dimensional data, as a nested lists,\n    // which is\
  \ similar to matrix, however, unlike matrices,\n    // each row may contain a different\
  \ number of columns.\n    // Given lst, and integer x, find integers x in the list,\n\
  \    // and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    // each\
  \ tuple is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates\
  \ initially by rows in ascending order.\n    // Also, sort coordinates of the row\
  \ by columns in descending order.\n    // Examples:\n    // >>> getRow((List[List[Long]](List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long,\
  \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
  \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
  \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
  \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
  \ x : Long) : List[Tuple2[Long, Long]] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
  \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
  \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 1l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 2l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
  \ Long]]((0l, 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l,\
  \ 0l), (5l, 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
  \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
  \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
  \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
  \ Long]]((2l, 2l)))));\n    }\n\n}\n"
completions: ["        // Fill up this function body\n        // 'lst' is a list of\
    \ lists, each list is a row\n        // 'x' is the number to be searched\n   \
    \     // Return a list of tuples, each tuple is a coordinate - (row, column)\n\
    \        // Sort coordinates initially by rows in ascending order.\n        //\
    \ Also, sort coordinates of the row by columns in descending order.\n        //\
    \ If the number is not found, return an empty list.\n        var result = List[Tuple2[Long,\
    \ Long]]()\n        for (i <- 0 until lst.length) {\n            for (j <- 0 until\
    \ lst(i).length) {\n                if (lst(i)(j) == x) {\n                  \
    \  result = result :+ (i.toLong, j.toLong)\n                }\n            }\n\
    \        }\n        result.sortWith(_._1 < _._1).sortWith(_._2 > _._2)", "   \
    \     var result : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n   \
    \     for (i <- 0 until lst.length) {\n            for (j <- 0 until lst(i).length)\
    \ {\n                if (lst(i)(j) == x) {\n                    result = (i, j)\
    \ :: result\n                }\n            }\n        }\n        result.sortWith((a,\
    \ b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))", "        var result :\
    \ List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until\
    \ lst.length) {\n            for (j <- 0 until lst(i).length) {\n            \
    \    if (lst(i)(j) == x) {\n                    result = result :+ (i.toLong,\
    \ j.toLong)\n                }\n            }\n        }\n        result.sortWith((a,\
    \ b) => {\n            if (a._1 < b._1) {\n                true\n            }\
    \ else if (a._1 == b._1) {\n                a._2 > b._2\n            } else {\n\
    \                false\n            }\n        })", "        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => a._1\
    \ < b._1 || (a._1 == b._1 && a._2 > b._2))", "        // Write your code here\n\
    \        var result : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n\
    \        for (i <- 0 until lst.length) {\n            for (j <- 0 until lst(i).length)\
    \ {\n                if (lst(i)(j) == x) {\n                    result = result\
    \ :+ (i.toLong, j.toLong)\n                }\n            }\n        }\n     \
    \   result.sortWith((a, b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))",
  "        // Fill up this function body\n        // 'lst' is a nested list, which\
    \ is similar to matrix, however, unlike matrices,\n        // each row may contain\
    \ a different number of columns.\n        // 'x' is an integer\n        // You\
    \ have to return list of tuples, [(x1, y1), (x2, y2) ...] such that\n        //\
    \ each tuple is a coordinate - (row, columns), starting with 0.\n        // Sort\
    \ coordinates initially by rows in ascending order.\n        // Also, sort coordinates\
    \ of the row by columns in descending order.\n        var result = List[Tuple2[Long,\
    \ Long]]()\n        for (i <- 0 until lst.length) {\n            for (j <- 0 until\
    \ lst(i).length) {\n                if (lst(i)(j) == x) {\n                  \
    \  result = result :+ (i.toLong, j.toLong)\n                }\n            }\n\
    \        }\n        result.sortWith(_._1 < _._1).sortWith(_._2 > _._2)", "   \
    \     var result : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n   \
    \     for (i <- 0 until lst.length) {\n            for (j <- 0 until lst(i).length)\
    \ {\n                if (lst(i)(j) == x) {\n                    result = result\
    \ :+ (i.toLong, j.toLong)\n                }\n            }\n        }\n     \
    \   result.sortWith((a, b) => (a._1 < b._1) || (a._1 == b._1 && a._2 > b._2))",
  "        var result : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n  \
    \      for (i <- 0 until lst.length) {\n            for (j <- 0 until lst(i).length)\
    \ {\n                if (lst(i)(j) == x) {\n                    result = result\
    \ :+ (i.toLong, j.toLong)\n                }\n            }\n        }\n     \
    \   result.sortWith((a, b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))",
  "        var result : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n  \
    \      for (i <- 0 until lst.length) {\n            for (j <- 0 until lst(i).length)\
    \ {\n                if (lst(i)(j) == x) {\n                    result = result\
    \ :+ (i.toLong, j.toLong)\n                }\n            }\n        }\n     \
    \   result.sortWith((a, b) => {\n            if (a._1 == b._1) {\n           \
    \     a._2 > b._2\n            } else {\n                a._1 < b._1\n       \
    \     }\n        })", "        // Fill up this function body\n        // 'lst'\
    \ is a nested list, similar to matrix,\n        // but unlike matrix, each row\
    \ may contain a different number of columns.\n        // 'x' is an integer.\n\
    \        // You have to find all the integers 'x' in the list,\n        // and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n        // each tuple\
    \ is a coordinate - (row, columns), starting with 0.\n        // Sort coordinates\
    \ initially by rows in ascending order.\n        // Also, sort coordinates of\
    \ the row by columns in descending order.\n        // If you find a coordinate\
    \ (row, column) of x,\n        // then you have to add it to the list,\n     \
    \   // and return the list.\n        // If you don't find any coordinate of x,\n\
    \        // then return an empty list.\n        // Note: You have to write this\
    \ function without using any inbuilt functions.\n        // Note: You have to\
    \ write this function without using any mutable data structures.\n        // Note:\
    \ You have to write this function without using any mutable variables.\n     \
    \   // Note: You have to write this function without using any mutable functions.\n\
    \        // Note: You have to write this function without using any mutable classes.\n\
    \        // Note: You have to write this function without using any mutable objects.\n\
    \        // Note: You have to write this function without using any mutable traits.\n\
    \        // Note: You have to write this function without using any mutable packages.\n\
    \        // Note: You have to write this function without using any mutable imports.\n\
    \        // Note: You have to write this function without using any mutable libraries.\n\
    \        // Note: You have to write this function without using any mutable frameworks.\n\
    \        // Note: You have to write this function without using any mutable platforms.\n\
    \        // Note: You have to write this function without using any mutable languages.\n\
    \        // Note: You have to write this function without using any mutable paradigms.\n\
    \        // Note: You have to write this function without using any mutable algorithms.\n\
    \        // Note: You have to write this function without using any mutable data.\n\
    \        // Note: You have to write this function without using any mutable code.\n\
    \       ", "        var result : List[Tuple2[Long, Long]] = List[Tuple2[Long,\
    \ Long]]()\n        for (i <- 0 until lst.length) {\n            for (j <- 0 until\
    \ lst(i).length) {\n                if (lst(i)(j) == x) {\n                  \
    \  result = (i, j) :: result\n                }\n            }\n        }\n  \
    \      result.sortWith((a, b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))",
  "        var result : List[Tuple2[Long, Long]] = List()\n        for (i <- 0 until\
    \ lst.length) {\n            for (j <- 0 until lst(i).length) {\n            \
    \    if (lst(i)(j) == x) {\n                    result = result :+ (i.toLong,\
    \ j.toLong)\n                }\n            }\n        }\n        result.sortWith((a,\
    \ b) => (a._1 < b._1) || (a._1 == b._1 && a._2 > b._2))", "        // Fill up\
    \ this function body\n        // 'lst' is a nested list, which is similar to matrix,\
    \ however, unlike matrices,\n        // each row may contain a different number\
    \ of columns.\n        // 'x' is an integer.\n        // You have to find integers\
    \ 'x' in the list,\n        // and return list of tuples, [(x1, y1), (x2, y2)\
    \ ...] such that\n        // each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n        // Sort coordinates initially by rows in ascending order.\n\
    \        // Also, sort coordinates of the row by columns in descending order.\n\
    \        // If there are no 'x' in the list, return empty list.\n        // If\
    \ the list is empty, return empty list.\n        // If the list is None, return\
    \ empty list.\n        // Note: You can use scala.math.Nil for empty list.\n \
    \       // Note: You can use scala.math.None for empty list.\n        // Note:\
    \ You can use scala.math.None for empty list.\n        // Note: You can use scala.math.None\
    \ for empty list.\n        // Note: You can use scala.math.None for empty list.\n\
    \        // Note: You can use scala.math.None for empty list.\n        // Note:\
    \ You can use scala.math.None for empty list.\n        // Note: You can use scala.math.None\
    \ for empty list.\n        // Note: You can use scala.math.None for empty list.\n\
    \        // Note: You can use scala.math.None for empty list.\n        // Note:\
    \ You can use scala.math.None for empty list.\n        // Note: You can use scala.math.None\
    \ for empty list.\n        // Note: You can use scala.math.None for empty list.\n\
    \        // Note: You can use scala.math.None for empty list.\n        // Note:\
    \ You can use scala.math.None for empty list.\n        // Note: You can use scala.math.None\
    \ for empty list.\n        // Note: You can use scala.math.None for empty list.\n\
    \        // Note: You can use scala.math.None for empty list", "        var result\
    \ : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0\
    \ until lst.length) {\n            for (j <- 0 until lst(i).length) {\n      \
    \          if (lst(i)(j) == x) {\n                    result = result :+ (i.toLong,\
    \ j.toLong)\n                }\n            }\n        }\n        result.sortWith((a,\
    \ b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))", "        var result :\
    \ List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until\
    \ lst.length) {\n            for (j <- 0 until lst(i).length) {\n            \
    \    if (lst(i)(j) == x) {\n                    result = result :+ (i.toLong,\
    \ j.toLong)\n                }\n            }\n        }\n        result.sortWith((a,\
    \ b) => {\n            if (a._1 < b._1) {\n                true\n            }\
    \ else if (a._1 == b._1) {\n                a._2 > b._2\n            } else {\n\
    \                false\n            }\n        })", "        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => (a._1\
    \ < b._1) || (a._1 == b._1 && a._2 > b._2))", "        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            var row : List[Long] = lst(i)\n            for (j <- 0 until row.length)\
    \ {\n                if (row(j) == x) {\n                    result = result :+\
    \ (i.toLong, j.toLong)\n                }\n            }\n        }\n        result.sortWith((a,\
    \ b) => {\n            if (a._1 < b._1) {\n                true\n            }\
    \ else if (a._1 == b._1) {\n                a._2 > b._2\n            } else {\n\
    \                false\n            }\n        })", "        // Fill up this function\
    \ body\n        // 'lst' is a nested list, similar to matrix,\n        // 'x'\
    \ is an integer to be searched in the list\n        // Return a list of tuples,\
    \ [(x1, y1), (x2, y2) ...] such that\n        // each tuple is a coordinate -\
    \ (row, columns), starting with 0.\n        // Sort coordinates initially by rows\
    \ in ascending order.\n        // Also, sort coordinates of the row by columns\
    \ in descending order.\n        // If 'x' is not found in the list, return empty\
    \ list.\n        // If 'lst' is empty, return empty list.\n        // Note:\n\
    \        // You can use built-in functions such as 'sortWith' and 'sorted'\n \
    \       // to sort the list of tuples.\n        // You can use built-in functions\
    \ such as 'zipWithIndex' to get\n        // the index of elements in the list.\n\
    \        // You can use built-in functions such as 'map' to apply a function\n\
    \        // to each element of a list.\n        // You can use built-in functions\
    \ such as 'filter' to filter a list.\n        // You can use built-in functions\
    \ such as 'flatMap' to flatten a list.\n        // You can use built-in functions\
    \ such as 'foldLeft' to fold a list.\n        // You can use built-in functions\
    \ such as 'foldRight' to fold a list.\n        // You can use built-in functions\
    \ such as 'fold' to fold a list.\n        // You can use built-in functions such\
    \ as 'reduceLeft' to reduce a list.\n        // You can use built-in functions\
    \ such as 'reduceRight' to reduce a list.\n        // You can use built-in functions\
    \ such as 'reduce' to reduce a list.\n        // You can use built-in functions\
    \ such as 'scanLeft' to scan a list.\n        // You can use built-in functions\
    \ such as 'scanRight' to scan a list.\n        // You can use built-in functions\
    \ such as 'scan' to scan a list.\n        // You can use built-in functions such\
    \ as 'mkString' to convert a list\n        // to a string.\n        // You can\
    \ use built-in functions such as", "        var result : List[Tuple2[Long, Long]]\
    \ = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n    \
    \        for (j <- 0 until lst(i).length) {\n                if (lst(i)(j) ==\
    \ x) {\n                    result = result :+ (i.toLong, j.toLong)\n        \
    \        }\n            }\n        }\n        result.sortWith((a, b) => a._1 <\
    \ b._1 || (a._1 == b._1 && a._2 > b._2))", "        // Fill up this function body\n\
    \        // 'lst' is a list of lists, and 'x' is the element to be searched\n\
    \        // Return a list of tuples, each tuple is a coordinate - (row, column)\n\
    \        // Sort the tuples initially by rows in ascending order\n        // Also,\
    \ sort coordinates of the row by columns in descending order\n        // If 'x'\
    \ is not found in 'lst', return an empty list\n        // If 'lst' is empty, return\
    \ an empty list\n        // If 'lst' is a list of empty lists, return an empty\
    \ list\n        var result = List[Tuple2[Long, Long]]()\n        var i = 0\n \
    \       for (row <- lst) {\n            var j = 0\n            for (col <- row)\
    \ {\n                if (col == x) {\n                    result = result :+ (i,\
    \ j)\n                }\n                j += 1\n            }\n            i\
    \ += 1\n        }\n        result.sortBy(x => (x._1, -x._2))", "        // Fill\
    \ up this function body\n        // 'lst' is a nested list, similar to matrix,\
    \ but each row may contain a different number of columns.\n        // 'x' is an\
    \ integer to be found in the list.\n        // Return list of tuples, [(x1, y1),\
    \ (x2, y2) ...] such that\n        // each tuple is a coordinate - (row, columns),\
    \ starting with 0.\n        // Sort coordinates initially by rows in ascending\
    \ order.\n        // Also, sort coordinates of the row by columns in descending\
    \ order.\n        var result : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n\
    \        for (i <- 0 until lst.length) {\n            for (j <- 0 until lst(i).length)\
    \ {\n                if (lst(i)(j) == x) {\n                    result = result\
    \ :+ (i.toLong, j.toLong)\n                }\n            }\n        }\n     \
    \   result.sortWith((a, b) => {\n            if (a._1 == b._1) {\n           \
    \     a._2 > b._2\n            } else {\n                a._1 < b._1\n       \
    \     }\n        })", "        var result : List[Tuple2[Long, Long]] = List[Tuple2[Long,\
    \ Long]]()\n        for (i <- 0 until lst.length) {\n            for (j <- 0 until\
    \ lst(i).length) {\n                if (lst(i)(j) == x) {\n                  \
    \  result = result :+ (i.toLong, j.toLong)\n                }\n            }\n\
    \        }\n        result.sortWith((a, b) => {\n            if (a._1 == b._1)\
    \ {\n                a._2 > b._2\n            } else {\n                a._1 <\
    \ b._1\n            }\n        })", "        var result : List[Tuple2[Long, Long]]\
    \ = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n    \
    \        for (j <- 0 until lst(i).length) {\n                if (lst(i)(j) ==\
    \ x) {\n                    result = result :+ (i.toLong, j.toLong)\n        \
    \        }\n            }\n        }\n        result.sortWith((a, b) => (a._1\
    \ < b._1) || (a._1 == b._1 && a._2 > b._2))", "        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => (a._1\
    \ < b._1) || (a._1 == b._1 && a._2 > b._2))", "        // Fill up this function\
    \ body\n        // 'lst' is a nested list, which is similar to matrix, however,\
    \ unlike matrices,\n        // each row may contain a different number of columns.\n\
    \        // 'x' is an integer.\n        // You have to find integers 'x' in the\
    \ list,\n        // and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    \        // each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \      // Sort coordinates initially by rows in ascending order.\n        // Also,\
    \ sort coordinates of the row by columns in descending order.\n        // If x\
    \ is not found in the list, return empty list.\n        // If the list is empty,\
    \ return empty list.\n        // If the list is None, return empty list.\n   \
    \     // Note:\n        // The list is not a matrix, it is a nested list.\n  \
    \      // Each row may contain a different number of columns.\n        // The\
    \ list may contain empty rows.\n        // The list may contain empty columns.\n\
    \        // The list may contain empty rows and empty columns.\n        // The\
    \ list may contain None.\n        // The list may contain None and empty rows\
    \ and empty columns.\n        // The list may contain None and empty rows and\
    \ empty columns and None.\n        // The list may contain None and empty rows\
    \ and empty columns and None and None.\n        // The list may contain None and\
    \ empty rows and empty columns and None and None and None.\n        // The list\
    \ may contain None and empty rows and empty columns and None and None and None\
    \ and None.\n        // The list may contain None and empty rows and empty columns\
    \ and None and None and None and None and None.\n        // The list may contain\
    \ None and empty rows and empty columns and None and None and None and None and\
    \ None and None.\n        // The list may contain None and empty rows and empty\
    \ columns and None and None and None and None and None and None and None.\n  \
    \      // The list may contain None and empty rows and empty columns and None\
    \ and None and None and None and None and None and None and None.\n        //\
    \ The list may contain None and empty rows and empty columns and None and None\
    \ and None and None and None and None and None and None and None.\n        //\
    \ The list may contain None and empty", "        // Fill up this function body\n\
    \        // 'lst' is a nested list, similar to matrix, but unlike matrices,\n\
    \        // each row may contain a different number of columns.\n        // 'x'\
    \ is an integer.\n        // Return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n        // each tuple is a coordinate - (row, columns), starting with\
    \ 0.\n        // Sort coordinates initially by rows in ascending order.\n    \
    \    // Also, sort coordinates of the row by columns in descending order.\n  \
    \      // If 'x' is not found in the list, return empty list.\n        // If 'lst'\
    \ is empty, return empty list.\n        // If 'lst' is a list of empty lists,\
    \ return empty list.\n        // For example,\n        // >>> getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n        //\
    \ (List[Tuple2[Long, Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n\
    \        // >>> getRow((List[List[Long]]()), (1l))\n        // (List[Tuple2[Long,\
    \ Long]]())\n        // >>> getRow((List[List[Long]](List[Long](), List[Long](1l.toLong),\
    \ List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n        // (List[Tuple2[Long,\
    \ Long]]((2l, 2l)))\n        // >>> getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong,", "        // Fill up this function body\n        // 'lst' is a nested\
    \ list, similar to matrix,\n        // however, unlike matrices, each row may\
    \ contain a different number of columns.\n        // 'x' is an integer.\n    \
    \    // You have to find integers x in the list,\n        // and return list of\
    \ tuples, [(x1, y1), (x2, y2) ...] such that\n        // each tuple is a coordinate\
    \ - (row, columns), starting with 0.\n        // Sort coordinates initially by\
    \ rows in ascending order.\n        // Also, sort coordinates of the row by columns\
    \ in descending order.\n        // If x is not found in the list, return empty\
    \ list.\n        // If the list is empty, return empty list.\n        // If the\
    \ list is not empty, but contains empty rows,\n        // return empty list.\n\
    \        // If the list is not empty, and contains non-empty rows,\n        //\
    \ return list of tuples.\n        // If the list is not empty, and contains non-empty\
    \ rows,\n        // and x is found in the list, return list of tuples.\n     \
    \   // If the list is not empty, and contains non-empty rows,\n        // and\
    \ x is not found in the list, return empty list.\n        // If the list is not\
    \ empty, and contains non-empty rows,\n        // and x is found in the list,\
    \ return list of tuples.\n        // If the list is not empty, and contains non-empty\
    \ rows,\n        // and x is found in the list, return list of tuples.\n     \
    \   // If the list is not empty, and contains non-empty rows,\n        // and\
    \ x is found in the list, return list of tuples.\n        // If the list is not\
    \ empty, and contains non-empty rows,\n        // and x is found in the list,\
    \ return list of tuples.\n        // If the list is not empty, and contains non-empty\
    \ rows,\n        // and x is found in the list, return list of tuples.\n     \
    \   // If the list is not empty, and contains non-empty rows,\n        // and\
    \ x is found in the list, return list of tuples.\n        // If the list is not\
    \ empty, and contains non-empty rows,\n        // and x is found", "        var\
    \ result : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n        for\
    \ (i <- 0 until lst.length) {\n            var row : List[Long] = lst(i)\n   \
    \         for (j <- 0 until row.length) {\n                if (row(j) == x) {\n\
    \                    result = result :+ (i.toLong, j.toLong)\n               \
    \ }\n            }\n        }\n        result.sortWith((a, b) => a._1 < b._1 ||\
    \ (a._1 == b._1 && a._2 > b._2))", "        var result : List[Tuple2[Long, Long]]\
    \ = List()\n        for (i <- 0 to lst.length - 1) {\n            for (j <- 0\
    \ to lst(i).length - 1) {\n                if (lst(i)(j) == x) {\n           \
    \         result = result :+ (i.toLong, j.toLong)\n                }\n       \
    \     }\n        }\n        result.sortWith((a, b) => {\n            if (a._1\
    \ == b._1) {\n                a._2 > b._2\n            } else {\n            \
    \    a._1 < b._1\n            }\n        })", "        var result : List[Tuple2[Long,\
    \ Long]] = List()\n        for (i <- 0 until lst.length) {\n            for (j\
    \ <- 0 until lst(i).length) {\n                if (lst(i)(j) == x) {\n       \
    \             result = (i, j) :: result\n                }\n            }\n  \
    \      }\n        result.sortWith((a, b) => a._1 < b._1 || (a._1 == b._1 && a._2\
    \ > b._2))", "        var result : List[Tuple2[Long, Long]] = List[Tuple2[Long,\
    \ Long]]()\n        for (i <- 0 until lst.length) {\n            for (j <- 0 until\
    \ lst(i).length) {\n                if (lst(i)(j) == x) {\n                  \
    \  result = result ::: List[Tuple2[Long, Long]]((i.toLong, j.toLong))\n      \
    \          }\n            }\n        }\n        result.sortWith((a, b) => a._1\
    \ < b._1 || (a._1 == b._1 && a._2 > b._2))", "        // Fill up this function\
    \ body\n        // 'lst' is a nested list, similar to matrix\n        // 'x' is\
    \ an integer\n        // Return a list of tuples, [(x1, y1), (x2, y2) ...]\n \
    \       // such that each tuple is a coordinate - (row, columns),\n        //\
    \ starting with 0.\n        // Sort coordinates initially by rows in ascending\
    \ order.\n        // Also, sort coordinates of the row by columns in descending\
    \ order.\n        // If you don't find x in the list, return empty list.\n   \
    \     var result = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length)\
    \ {\n            var row = lst(i)\n            for (j <- 0 until row.length) {\n\
    \                if (row(j) == x) {\n                    result = result :+ (i.toLong,\
    \ j.toLong)\n                }\n            }\n        }\n        result.sortWith((a,\
    \ b) => if (a._1 < b._1) true else if (a._1 == b._1) a._2 > b._2 else false)",
  "        // Fill up this function body\n        // `lst` is a nested list, similar\
    \ to matrix,\n        // however, unlike matrices, each row may contain a different\
    \ number of columns.\n        // `x` is an integer to be found in the list.\n\
    \        // You are required to return a list of tuples,\n        // [(x1, y1),\
    \ (x2, y2) ...] such that\n        // each tuple is a coordinate - (row, columns),\
    \ starting with 0.\n        // Sort coordinates initially by rows in ascending\
    \ order.\n        // Also, sort coordinates of the row by columns in descending\
    \ order.\n        // If `x` is not found in the list, return an empty list.\n\
    \        // If `lst` is empty, return an empty list.\n        // Note: You are\
    \ not required to handle the case\n        // when `x` is not found in the list.\n\
    \        // You are not required to handle the case when `lst` is empty.\n   \
    \     // You are not required to handle the case when `lst` is not a nested list.\n\
    \        // You are not required to handle the case when `lst` is not a nested\
    \ list of integers.\n        // You are not required to handle the case when `lst`\
    \ is not a nested list of integers of the same type as `x`.\n        // You are\
    \ not required to handle the case when `lst` is not a nested list of integers\
    \ of the same type as `x` and `y`.\n        // You are not required to handle\
    \ the case when `lst` is not a nested list of integers of the same type as `x`,\
    \ `y` and `z`.\n        // You are not required to handle the case when `lst`\
    \ is not a nested list of integers of the same type as `x`, `y`, `z` and `w`.\n\
    \        // You are not required to handle the case when `lst` is not a nested\
    \ list of integers of the same type as `x`, `y`, `z`, `w` and `v`.\n        //\
    \ You are not required to handle the case when `lst` is not a nested list of integers\
    \ of the same type as `x`, `y`, `z`, `w`, `v` and `u`.\n        // You are not\
    \ required to handle", "        var result : List[Tuple2[Long, Long]] = List[Tuple2[Long,\
    \ Long]]()\n        for (i <- 0 until lst.length) {\n            var row : List[Long]\
    \ = lst(i)\n            for (j <- 0 until row.length) {\n                if (row(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => a._1\
    \ < b._1 || (a._1 == b._1 && a._2 > b._2))", "        // Fill up this function\
    \ body\n        // 'lst' is a list of lists, and 'x' is the integer to be found\n\
    \        // Return a list of tuples, each tuple is a coordinate - (row, columns)\n\
    \        // Sort coordinates initially by rows in ascending order.\n        //\
    \ Also, sort coordinates of the row by columns in descending order.\n        //\
    \ If 'x' is not found in the list, return an empty list.\n        // If 'lst'\
    \ is empty, return an empty list.\n        // If 'lst' is a list of empty lists,\
    \ return an empty list.\n        // If 'lst' is a list of lists, and 'x' is found\
    \ in the list,\n        // return a list of tuples, each tuple is a coordinate\
    \ - (row, columns)\n        // Sort coordinates initially by rows in ascending\
    \ order.\n        // Also, sort coordinates of the row by columns in descending\
    \ order.\n        var result : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n\
    \        for (i <- 0 until lst.length) {\n            for (j <- 0 until lst(i).length)\
    \ {\n                if (lst(i)(j) == x) {\n                    result = result\
    \ :+ (i.toLong, j.toLong)\n                }\n            }\n        }\n     \
    \   result.sortWith((a, b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))",
  "        var result : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n  \
    \      for (i <- 0 until lst.length) {\n            for (j <- 0 until lst(i).length)\
    \ {\n                if (lst(i)(j) == x) {\n                    result = result\
    \ :+ (i.toLong, j.toLong)\n                }\n            }\n        }\n     \
    \   result.sortWith((a, b) => {\n            if (a._1 == b._1) {\n           \
    \     a._2 > b._2\n            } else {\n                a._1 < b._1\n       \
    \     }\n        })", "        // Fill up this function body\n        // 'lst'\
    \ is a nested list, which is similar to matrix,\n        // however, unlike matrices,\
    \ each row may contain a different number of columns.\n        // 'x' is an integer.\n\
    \        // You have to find integers 'x' in the list,\n        // and return\
    \ list of tuples, [(x1, y1), (x2, y2) ...] such that\n        // each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n        // Sort coordinates\
    \ initially by rows in ascending order.\n        // Also, sort coordinates of\
    \ the row by columns in descending order.\n        // If there is no 'x' in the\
    \ list, return empty list.\n        // If the list is empty, return empty list.\n\
    \        // If the list is a list of empty lists, return empty list.\n       \
    \ // For example,\n        // >>> getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n        //\
    \ (List[Tuple2[Long, Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n\
    \        // >>> getRow((List[List[Long]]()), (1l))\n        // (List[Tuple2[Long,\
    \ Long]]())\n        // >>> getRow((List[List[Long]](List[Long](), List[Long](1l.toLong),\
    \ List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n        // (List[Tuple2[Long,\
    \ Long]]((2l, 2l)))\n        // >>> getRow((List[List[Long]](List", "        //\
    \ Fill up this function body\n        // 'lst' is a nested list, similar to matrix,\n\
    \        // 'x' is the integer to be searched in the list\n        // Return a\
    \ list of tuples, [(x1, y1), (x2, y2) ...]\n        // such that each tuple is\
    \ a coordinate - (row, columns),\n        // starting with 0.\n        // Sort\
    \ coordinates initially by rows in ascending order.\n        // Also, sort coordinates\
    \ of the row by columns in descending order.\n        // If x is not found in\
    \ the list, return empty list.\n        // Note: You can use built-in sort function.\n\
    \        // Example:\n        // >>> getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n        //\
    \ (List[Tuple2[Long, Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n\
    \        // >>> getRow((List[List[Long]]()), (1l))\n        // (List[Tuple2[Long,\
    \ Long]]())\n        // >>> getRow((List[List[Long]](List[Long](), List[Long](1l.toLong),\
    \ List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n        // (List[Tuple2[Long,\
    \ Long]]((2l, 2l)))\n        var result : List[Tuple2[Long, Long]] = List[Tuple2[Long,\
    \ Long]]()\n        for (i <- 0 until lst.length) {\n            for (j <- 0 until\
    \ lst(i).length) {\n                if (l", "        var res : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    res = res :+ (i.toLong, j.toLong)\n           \
    \     }\n            }\n        }\n        res.sortWith((a, b) => {\n        \
    \    if (a._1 < b._1) {\n                true\n            } else if (a._1 ==\
    \ b._1) {\n                a._2 > b._2\n            } else {\n               \
    \ false\n            }\n        })", "        var result : List[Tuple2[Long, Long]]\
    \ = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n    \
    \        for (j <- 0 until lst(i).length) {\n                if (lst(i)(j) ==\
    \ x) {\n                    result = result :+ (i.toLong, j.toLong)\n        \
    \        }\n            }\n        }\n        result.sortWith((a, b) => a._1 <\
    \ b._1 || (a._1 == b._1 && a._2 > b._2))", "        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = (i, j) :: result\n                }\n\
    \            }\n        }\n        result.sortWith((a, b) => a._1 < b._1 || (a._1\
    \ == b._1 && a._2 > b._2))", "        // Fill up this function body\n        //\
    \ `lst` is a list of lists, where each list is a row\n        // `x` is the number\
    \ to be searched\n        // return a list of tuples, where each tuple is a coordinate\n\
    \        // (row, column)\n        // sort the list of tuples by rows in ascending\
    \ order\n        // and then by columns in descending order\n        // if the\
    \ number is not found, return an empty list\n        // if the list is empty,\
    \ return an empty list\n        // if the list is empty, return an empty list\n\
    \        var result = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length)\
    \ {\n            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => if\
    \ (a._1 == b._1) a._2 > b._2 else a._1 < b._1)", "        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((x, y) => x._1\
    \ < y._1 || (x._1 == y._1 && x._2 > y._2))", "        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => {\n\
    \            if (a._1 < b._1) true\n            else if (a._1 == b._1) {\n   \
    \             if (a._2 > b._2) true\n                else false\n            }\n\
    \            else false\n        })", "        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => (a._1\
    \ < b._1) || (a._1 == b._1 && a._2 > b._2))", "        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith(sortByRow)",
  "        var result : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n  \
    \      for (i <- 0 until lst.length) {\n            for (j <- 0 until lst(i).length)\
    \ {\n                if (lst(i)(j) == x) {\n                    result = result\
    \ :+ (i.toLong, j.toLong)\n                }\n            }\n        }\n     \
    \   result.sortWith((a, b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))",
  "        var result : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n  \
    \      for (i <- 0 until lst.length) {\n            var row : List[Long] = lst(i)\n\
    \            for (j <- 0 until row.length) {\n                if (row(j) == x)\
    \ {\n                    result = result :+ (i.toLong, j.toLong)\n           \
    \     }\n            }\n        }\n        result.sortWith((a, b) => {\n     \
    \       if (a._1 < b._1) {\n                true\n            } else if (a._1\
    \ == b._1) {\n                a._2 > b._2\n            } else {\n            \
    \    false\n            }\n        })", "        // Fill up this function body\n\
    \        // 'lst' is a nested list, which is similar to matrix, however, unlike\
    \ matrices,\n        // each row may contain a different number of columns.\n\
    \        // 'x' is the integer to be searched in the list\n        // Return list\
    \ of tuples, [(x1, y1), (x2, y2) ...] such that\n        // each tuple is a coordinate\
    \ - (row, columns), starting with 0.\n        // Sort coordinates initially by\
    \ rows in ascending order.\n        // Also, sort coordinates of the row by columns\
    \ in descending order.\n        // If x is not found in the list, return empty\
    \ list.\n        var result = List[Tuple2[Long, Long]]()\n        var row = 0l\n\
    \        for (i <- lst) {\n            var col = 0l\n            for (j <- i)\
    \ {\n                if (j == x) {\n                    result = result :+ (row,\
    \ col)\n                }\n                col += 1\n            }\n         \
    \   row += 1\n        }\n        result.sortWith((x, y) => x._1 < y._1 || (x._1\
    \ == y._1 && x._2 > y._2))", "        var result : List[Tuple2[Long, Long]] =\
    \ List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n      \
    \      for (j <- 0 until lst(i).length) {\n                if (lst(i)(j) == x)\
    \ {\n                    result = result :+ (i.toLong, j.toLong)\n           \
    \     }\n            }\n        }\n        result.sortWith((a, b) => {\n     \
    \       if (a._1 == b._1) {\n                a._2 > b._2\n            } else {\n\
    \                a._1 < b._1\n            }\n        })", "        var result\
    \ : List[Tuple2[Long, Long]] = List()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => a._1\
    \ < b._1 || (a._1 == b._1 && a._2 > b._2))", "        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => a._1\
    \ < b._1 || (a._1 == b._1 && a._2 > b._2))", "        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => {\n\
    \            if (a._1 < b._1) {\n                true\n            } else if (a._1\
    \ == b._1) {\n                a._2 > b._2\n            } else {\n            \
    \    false\n            }\n        })", "        // Fill up this function body\n\
    \        // `lst` is a nested list, similar to matrix, but unlike matrix,\n  \
    \      // each row may contain a different number of columns.\n        // `x`\
    \ is an integer to be searched in the list.\n        // Return a list of tuples,\
    \ [(x1, y1), (x2, y2) ...] such that\n        // each tuple is a coordinate -\
    \ (row, columns), starting with 0.\n        // Sort coordinates initially by rows\
    \ in ascending order.\n        // Also, sort coordinates of the row by columns\
    \ in descending order.\n        // If `x` is not found in the list, return empty\
    \ list.\n        // If `lst` is empty, return empty list.\n        // If `lst`\
    \ is a list of empty lists, return empty list.\n        // If `lst` is a list\
    \ of lists, each of which is empty, return empty list.\n        // If `lst` is\
    \ a list of lists, each of which is a list of empty lists, return empty list.\n\
    \        // If `lst` is a list of lists, each of which is a list of lists, each\
    \ of which is empty, return empty list.\n        // If `lst` is a list of lists,\
    \ each of which is a list of lists, each of which is a list of empty lists, return\
    \ empty list.\n        // If `lst` is a list of lists, each of which is a list\
    \ of lists, each of which is a list of lists, each of which is empty, return empty\
    \ list.\n        // If `lst` is a list of lists, each of which is a list of lists,\
    \ each of which is a list of lists, each of which is a list of empty lists, return\
    \ empty list.\n        // If `lst` is a list of lists, each of which is a list\
    \ of lists, each of which is a list of lists, each of which is a list of lists,\
    \ each of which is empty, return empty list.\n        // If `lst` is a list of\
    \ lists, each of which is a list of lists, each of which is a list of lists, each\
    \ of which is a list of lists, each of which is a list of empty lists, return\
    \ empty list.\n        // If `lst` is a list of lists", "        // Fill up this\
    \ function body\n        // 'lst' is a nested list, which is similar to matrix,\n\
    \        // however, unlike matrices, each row may contain a different number\
    \ of columns.\n        // 'x' is an integer to be found in the list.\n       \
    \ // You need to return a list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    \        // each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \      // Sort coordinates initially by rows in ascending order.\n        // Also,\
    \ sort coordinates of the row by columns in descending order.\n        var result\
    \ = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n    \
    \        for (j <- 0 until lst(i).length) {\n                if (lst(i)(j) ==\
    \ x) {\n                    result = result :+ (i.toLong, j.toLong)\n        \
    \        }\n            }\n        }\n        result.sortWith((a, b) => a._1 <\
    \ b._1 || (a._1 == b._1 && a._2 > b._2))", "        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => {\n\
    \            if (a._1 == b._1) {\n                a._2 > b._2\n            } else\
    \ {\n                a._1 < b._1\n            }\n        })", "        // Fill\
    \ up this function body\n        // 'lst' is a nested list, which is similar to\
    \ matrix, however, unlike matrices,\n        // each row may contain a different\
    \ number of columns.\n        // 'x' is a given integer\n        // You have to\
    \ return a list of tuples, [(x1, y1), (x2, y2) ...] such that\n        // each\
    \ tuple is a coordinate - (row, columns), starting with 0.\n        // Sort coordinates\
    \ initially by rows in ascending order.\n        // Also, sort coordinates of\
    \ the row by columns in descending order.\n        var result = List[Tuple2[Long,\
    \ Long]]()\n        var row = 0\n        for (i <- lst) {\n            var col\
    \ = 0\n            for (j <- i) {\n                if (j == x) {\n           \
    \         result = result :+ (row, col)\n                }\n                col\
    \ += 1\n            }\n            row += 1\n        }\n        result.sortBy(x\
    \ => x._1)\n        result.sortBy(x => -x._2)\n        result", "        var result\
    \ : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0\
    \ to lst.length - 1) {\n            var row = lst(i)\n            for (j <- 0\
    \ to row.length - 1) {\n                if (row(j) == x) {\n                 \
    \   result = result :+ (i.toLong, j.toLong)\n                }\n            }\n\
    \        }\n        result.sortWith((a, b) => {\n            if (a._1 == b._1)\
    \ {\n                a._2 > b._2\n            } else {\n                a._1 <\
    \ b._1\n            }\n        })", "        // Fill up this function body\n \
    \       // 'lst' is a nested list, similar to matrix,\n        // but unlike matrix,\
    \ each row may contain a different number of columns.\n        // 'x' is an integer,\
    \ which you need to find in the list.\n        // Return list of tuples, [(x1,\
    \ y1), (x2, y2) ...] such that\n        // each tuple is a coordinate - (row,\
    \ columns), starting with 0.\n        // Sort coordinates initially by rows in\
    \ ascending order.\n        // Also, sort coordinates of the row by columns in\
    \ descending order.\n        var result = List[Tuple2[Long, Long]]()\n       \
    \ for (i <- 0 until lst.length) {\n            for (j <- 0 until lst(i).length)\
    \ {\n                if (lst(i)(j) == x) {\n                    result = result\
    \ :+ (i.toLong, j.toLong)\n                }\n            }\n        }\n     \
    \   result.sortWith((a, b) => (a._1 < b._1) || (a._1 == b._1 && a._2 > b._2))",
  "        var result : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n  \
    \      for (i <- 0 until lst.length) {\n            for (j <- 0 until lst(i).length)\
    \ {\n                if (lst(i)(j) == x) {\n                    result = result\
    \ :+ (i.toLong, j.toLong)\n                }\n            }\n        }\n     \
    \   result.sortWith((x, y) => x._1 < y._1 || (x._1 == y._1 && x._2 > y._2))",
  "        var result : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n  \
    \      for (i <- 0 until lst.length) {\n            for (j <- 0 until lst(i).length)\
    \ {\n                if (lst(i)(j) == x) {\n                    result = result\
    \ :+ (i.toLong, j.toLong)\n                }\n            }\n        }\n     \
    \   result.sortWith((a, b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))",
  "        var res = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length)\
    \ {\n            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    res = (i, j) :: res\n                }\n      \
    \      }\n        }\n        res.sortWith((a, b) => {\n            if (a._1 ==\
    \ b._1) {\n                a._2 > b._2\n            } else {\n               \
    \ a._1 < b._1\n            }\n        })", "        // Fill up this function body\n\
    \        // `lst` is a list of lists, and `x` is the integer to find\n       \
    \ // Return a list of tuples, each tuple is a coordinate - (row, column)\n   \
    \     // Sort coordinates initially by rows in ascending order.\n        // Also,\
    \ sort coordinates of the row by columns in descending order.\n        // For\
    \ example, if `lst` is List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong)) and `x` is 1l, then the result should be List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l))\n        var result\
    \ = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n    \
    \        var row = lst(i)\n            for (j <- 0 until row.length) {\n     \
    \           if (row(j) == x) {\n                    result = result :+ (i.toLong,\
    \ j.toLong)\n                }\n            }\n        }\n        result.sortWith((a,\
    \ b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))", "        // Fill up this\
    \ function body\n        // 'lst' is a nested list, which is similar to matrix,\
    \ however, unlike matrices,\n        // each row may contain a different number\
    \ of columns.\n        // 'x' is an integer.\n        // You have to find integers\
    \ 'x' in the list,\n        // and return list of tuples, [(x1, y1), (x2, y2)\
    \ ...] such that\n        // each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n        // Sort coordinates initially by rows in ascending order.\n\
    \        // Also, sort coordinates of the row by columns in descending order.\n\
    \        // If you find multiple 'x' in the same row, sort them by columns in\
    \ descending order.\n        // If you find multiple 'x' in the same column, sort\
    \ them by rows in ascending order.\n        // If you find multiple 'x' in the\
    \ same row and column, sort them by rows in ascending order.\n        // If you\
    \ find no 'x' in the list, return an empty list.\n        // If you find 'x' in\
    \ the list, return a list of tuples.\n        // If you find 'x' in the list,\
    \ return a list of tuples,\n        // where each tuple is a coordinate - (row,\
    \ columns), starting with 0.\n        // Sort coordinates initially by rows in\
    \ ascending order.\n        // Also, sort coordinates of the row by columns in\
    \ descending order.\n        // If you find multiple 'x' in the same row, sort\
    \ them by columns in descending order.\n        // If you find multiple 'x' in\
    \ the same column, sort them by rows in ascending order.\n        // If you find\
    \ multiple 'x' in the same row and column, sort them by rows in ascending order.\n\
    \        // If you find no 'x' in the list, return an empty list.\n        //\
    \ If you find 'x' in the list, return a list of tuples.\n        // If you find\
    \ 'x' in the list, return a list of tuples,\n        // where each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n        // Sort coordinates initially\
    \ by rows in ascending order.\n        // Also, sort coordinates of the row by\
    \ columns in descending order.\n        // If you find multiple 'x' in the same\
    \ row", "        // Fill up this function body\n        // `lst` is a list of\
    \ lists, where each list is a row\n        // `x` is the integer to be searched\
    \ in the list\n        // Return a list of tuples, where each tuple is a coordinate\n\
    \        // (row, column)\n        var result = List[Tuple2[Long, Long]]()\n \
    \       for (i <- 0 until lst.length) {\n            for (j <- 0 until lst(i).length)\
    \ {\n                if (lst(i)(j) == x) {\n                    result = (i, j)\
    \ :: result\n                }\n            }\n        }\n        result.sortWith((a,\
    \ b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))", "        var result :\
    \ List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until\
    \ lst.length) {\n            for (j <- 0 until lst(i).length) {\n            \
    \    if (lst(i)(j) == x) {\n                    result = result :+ (i.toLong,\
    \ j.toLong)\n                }\n            }\n        }\n        result.sortWith((a,\
    \ b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))", "        var res = List[Tuple2[Long,\
    \ Long]]()\n        for (i <- 0 until lst.length) {\n            for (j <- 0 until\
    \ lst(i).length) {\n                if (lst(i)(j) == x) {\n                  \
    \  res = (i, j) :: res\n                }\n            }\n        }\n        res.sortWith((a,\
    \ b) => if (a._1 == b._1) a._2 > b._2 else a._1 < b._1)", "        var result\
    \ : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0\
    \ until lst.length) {\n            for (j <- 0 until lst(i).length) {\n      \
    \          if (lst(i)(j) == x) {\n                    result = result :+ (i.toLong,\
    \ j.toLong)\n                }\n            }\n        }\n        result.sortWith((a,\
    \ b) => {\n            if (a._1 == b._1) {\n                a._2 > b._2\n    \
    \        } else {\n                a._1 < b._1\n            }\n        })", " \
    \       // Fill up this function body\n        // 'lst' is a nested list, similar\
    \ to matrix, but each row may contain a different number of columns.\n       \
    \ // 'x' is an integer to be found in the list.\n        // Return list of tuples,\
    \ [(x1, y1), (x2, y2) ...] such that\n        // each tuple is a coordinate -\
    \ (row, columns), starting with 0.\n        // Sort coordinates initially by rows\
    \ in ascending order.\n        // Also, sort coordinates of the row by columns\
    \ in descending order.\n        // If x is not found in the list, return empty\
    \ list.\n        // If the list is empty, return empty list.\n        // Constraints:\n\
    \        // 1 <= number of rows <= 100\n        // 1 <= number of columns <= 100\n\
    \        // 1 <= x <= 1000\n        // 0 <= each element of the list <= 1000\n\
    \        var result : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n\
    \        for (i <- 0 until lst.length) {\n            for (j <- 0 until lst(i).length)\
    \ {\n                if (lst(i)(j) == x) {\n                    result = result\
    \ :+ (i.toLong, j.toLong)\n                }\n            }\n        }\n     \
    \   result.sortWith((a, b) => {\n            if (a._1 == b._1) {\n           \
    \     a._2 > b._2\n            } else {\n                a._1 < b._1\n       \
    \     }\n        })", "        var result : List[Tuple2[Long, Long]] = List[Tuple2[Long,\
    \ Long]]()\n        for (i <- 0 until lst.length) {\n            for (j <- 0 until\
    \ lst(i).length) {\n                if (lst(i)(j) == x) {\n                  \
    \  result = result :+ (i.toLong, j.toLong)\n                }\n            }\n\
    \        }\n        result.sortWith((a, b) => a._1 < b._1 || (a._1 == b._1 &&\
    \ a._2 > b._2))", "        var result : List[Tuple2[Long, Long]] = List[Tuple2[Long,\
    \ Long]]()\n        for (i <- 0 until lst.length) {\n            for (j <- 0 until\
    \ lst(i).length) {\n                if (lst(i)(j) == x) {\n                  \
    \  result = result :+ (i.toLong, j.toLong)\n                }\n            }\n\
    \        }\n        result.sortWith((a, b) => {\n            if (a._1 < b._1)\
    \ {\n                true\n            } else if (a._1 == b._1) {\n          \
    \      a._2 > b._2\n            } else {\n                false\n            }\n\
    \        })", "        // Fill up this function body\n        // 'lst' is a list\
    \ of lists, and 'x' is the integer to be found\n        // Return a list of tuples,\
    \ each tuple is a coordinate - (row, column)\n        // Sort the list of tuples\
    \ initially by rows in ascending order\n        // Also, sort coordinates of the\
    \ row by columns in descending order\n        // If there are no coordinates,\
    \ return empty list\n        // If there are no such integers in the list, return\
    \ empty list\n        var result = List[Tuple2[Long, Long]]()\n        for (i\
    \ <- 0 until lst.length) {\n            for (j <- 0 until lst(i).length) {\n \
    \               if (lst(i)(j) == x) {\n                    result = result :+\
    \ (i.toLong, j.toLong)\n                }\n            }\n        }\n        result.sortWith((a,\
    \ b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))", "        var result :\
    \ List[Tuple2[Long, Long]] = List()\n        for (i <- 0 until lst.length) {\n\
    \            val row = lst(i)\n            for (j <- 0 until row.length) {\n \
    \               if (row(j) == x) {\n                    result = (i, j) :: result\n\
    \                }\n            }\n        }\n        result.sortWith((a, b) =>\
    \ a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))", "        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            var row : List[Long] = lst(i)\n            for (j <- 0 until row.length)\
    \ {\n                if (row(j) == x) {\n                    result = result :+\
    \ (i.toLong, j.toLong)\n                }\n            }\n        }\n        result.sortWith((a,\
    \ b) => (a._1 < b._1) || (a._1 == b._1 && a._2 > b._2))", "        var result\
    \ : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0\
    \ until lst.length) {\n            val row = lst(i)\n            for (j <- 0 until\
    \ row.length) {\n                if (row(j) == x) {\n                    result\
    \ = (i, j) :: result\n                }\n            }\n        }\n        result.sortWith((a,\
    \ b) => (a._1 < b._1) || (a._1 == b._1 && a._2 > b._2))", "        var result\
    \ : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0\
    \ until lst.length) {\n            for (j <- 0 until lst(i).length) {\n      \
    \          if (lst(i)(j) == x) {\n                    result = result :+ (i.toLong,\
    \ j.toLong)\n                }\n            }\n        }\n        result.sortWith((a,\
    \ b) => {\n            if (a._1 < b._1) {\n                true\n            }\
    \ else if (a._1 == b._1) {\n                a._2 > b._2\n            } else {\n\
    \                false\n            }\n        })", "        var result : List[Tuple2[Long,\
    \ Long]] = List()\n        for (i <- 0 until lst.length) {\n            for (j\
    \ <- 0 until lst(i).length) {\n                if (lst(i)(j) == x) {\n       \
    \             result = (i, j) :: result\n                }\n            }\n  \
    \      }\n        result.sortWith((a, b) => (a._1 < b._1) || (a._1 == b._1 &&\
    \ a._2 > b._2))", "        var result : List[Tuple2[Long, Long]] = List[Tuple2[Long,\
    \ Long]]()\n        for (i <- 0 until lst.length) {\n            var row : List[Long]\
    \ = lst(i)\n            for (j <- 0 until row.length) {\n                if (row(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => {\n\
    \            if (a._1 == b._1) {\n                a._2 > b._2\n            } else\
    \ {\n                a._1 < b._1\n            }\n        })", "        // Your\
    \ code here\n        null", "        // Fill up this function body\n        //\
    \ 'lst' is a nested list, similar to matrix,\n        // 'x' is the integer to\
    \ be searched in the list\n        // Return a list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n        // each tuple is a coordinate - (row, columns),\
    \ starting with 0.\n        // Sort coordinates initially by rows in ascending\
    \ order.\n        // Also, sort coordinates of the row by columns in descending\
    \ order.\n        // If x is not found in the list, return empty list.\n     \
    \   // If the list is empty, return empty list.\n        // Note: You can use\
    \ scala.math.Ordering.Tuple2 to sort tuples.\n        // You can use scala.math.Ordering.Long\
    \ to sort Longs.\n        // You can use scala.math.Ordering.Tuple2.on[Long, Long](_._1,\
    \ _._2) to sort tuples by rows and columns.\n        // You can use scala.math.Ordering.Long.reverse\
    \ to reverse sort Longs.\n        // You can use scala.math.Ordering.Tuple2.on[Long,\
    \ Long](_._1, _._2).reverse to reverse sort tuples by rows and columns.\n    \
    \    // You can use scala.math.Ordering.Tuple2.on[Long, Long](_._2, _._1) to sort\
    \ tuples by columns and rows.\n        // You can use scala.math.Ordering.Tuple2.on[Long,\
    \ Long](_._2, _._1).reverse to reverse sort tuples by columns and rows.\n    \
    \    // You can use scala.math.Ordering.Tuple2.on[Long, Long](_._1, _._2).reverse.on[Long,\
    \ Long](_._2, _._1) to sort tuples by rows in ascending order and columns in descending\
    \ order.\n        // You can use scala.math.Ordering.Tuple2.on[Long, Long](_._1,\
    \ _._2).reverse.on[Long, Long](_._2, _._1).reverse to reverse sort tuples by rows\
    \ in ascending order and columns in descending order.\n        // You can use\
    \ sc", "        var result : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n\
    \        for (i <- 0 until lst.length) {\n            var row : List[Long] = lst(i)\n\
    \            for (j <- 0 until row.length) {\n                if (row(j) == x)\
    \ {\n                    result = result :+ (i.toLong, j.toLong)\n           \
    \     }\n            }\n        }\n        result.sortWith((a, b) => {\n     \
    \       if (a._1 < b._1) {\n                true\n            } else if (a._1\
    \ == b._1) {\n                a._2 > b._2\n            } else {\n            \
    \    false\n            }\n        })", "        // Fill up this function body\n\
    \        // 'lst' is a nested list, which is similar to matrix,\n        // however,\
    \ unlike matrices, each row may contain a different number of columns.\n     \
    \   // 'x' is an integer.\n        // You have to find integers 'x' in the list,\n\
    \        // and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n  \
    \      // each tuple is a coordinate - (row, columns), starting with 0.\n    \
    \    // Sort coordinates initially by rows in ascending order.\n        // Also,\
    \ sort coordinates of the row by columns in descending order.\n        // If there\
    \ is no 'x' in the list, return an empty list.\n        // If the list is empty,\
    \ return an empty list.\n        // If the list is a list of empty lists, return\
    \ an empty list.\n        // If the list is a list of lists of empty lists, return\
    \ an empty list.\n        // If the list is a list of lists of lists of empty\
    \ lists, return an empty list.\n        // If the list is a list of lists of lists\
    \ of lists of empty lists, return an empty list.\n        // If the list is a\
    \ list of lists of lists of lists of lists of empty lists, return an empty list.\n\
    \        // If the list is a list of lists of lists of lists of lists of lists\
    \ of empty lists, return an empty list.\n        // If the list is a list of lists\
    \ of lists of lists of lists of lists of lists of empty lists, return an empty\
    \ list.\n        // If the list is a list of lists of lists of lists of lists\
    \ of lists of lists of lists of empty lists, return an empty list.\n        //\
    \ If the list is a list of lists of lists of lists of lists of lists of lists\
    \ of lists of lists of empty lists, return an empty list.\n        // If the list\
    \ is a list of lists of lists of lists of lists of lists of lists of lists of\
    \ lists of lists of empty lists, return an empty list.\n        // If the list\
    \ is a list of lists of lists of lists of lists of lists of lists of lists of\
    \ lists of lists of lists of empty lists, return an empty list.\n        // If\
    \ the list is a list of lists of lists of lists of lists of lists of lists of\
    \ lists of lists of lists", "        // Fill up this function body\n        //\
    \ 'lst' is a nested list, similar to matrix,\n        // however, unlike matrices,\
    \ each row may contain a different number of columns.\n        // 'x' is an integer.\n\
    \        // You have to find integers x in the list,\n        // and return list\
    \ of tuples, [(x1, y1), (x2, y2) ...] such that\n        // each tuple is a coordinate\
    \ - (row, columns), starting with 0.\n        // Sort coordinates initially by\
    \ rows in ascending order.\n        // Also, sort coordinates of the row by columns\
    \ in descending order.\n        // If x is not found in the list, return empty\
    \ list.\n        // If the list is empty, return empty list.\n        // If the\
    \ list is not empty, but all the rows are empty, return empty list.\n        //\
    \ If the list is not empty, but all the rows are empty, return empty list.\n \
    \       // If the list is not empty, but all the rows are empty, return empty\
    \ list.\n        // If the list is not empty, but all the rows are empty, return\
    \ empty list.\n        // If the list is not empty, but all the rows are empty,\
    \ return empty list.\n        // If the list is not empty, but all the rows are\
    \ empty, return empty list.\n        // If the list is not empty, but all the\
    \ rows are empty, return empty list.\n        // If the list is not empty, but\
    \ all the rows are empty, return empty list.\n        // If the list is not empty,\
    \ but all the rows are empty, return empty list.\n        // If the list is not\
    \ empty, but all the rows are empty, return empty list.\n        // If the list\
    \ is not empty, but all the rows are empty, return empty list.\n        // If\
    \ the list is not empty, but all the rows are empty, return empty list.\n    \
    \    // If the list is not empty, but all the rows are empty, return empty list.\n\
    \        // If the list is not empty, but all the rows are empty, return empty\
    \ list.\n        // If the list is not empty, but all the rows are empty, return\
    \ empty list.\n        // If the list is not empty, but all the rows are empty,\
    \ return empty list.\n        // If the list is", "        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => {\n\
    \            if (a._1 == b._1) {\n                a._2 > b._2\n            } else\
    \ {\n                a._1 < b._1\n            }\n        })", "        var result\
    \ : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0\
    \ until lst.length) {\n            for (j <- 0 until lst(i).length) {\n      \
    \          if (lst(i)(j) == x) {\n                    result = result :+ (i.toLong,\
    \ j.toLong)\n                }\n            }\n        }\n        result.sortWith((a,\
    \ b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))", "        // Fill up this\
    \ function body\n        // 'lst' is a nested list, which is similar to matrix,\
    \ however, unlike matrices,\n        // each row may contain a different number\
    \ of columns.\n        // 'x' is an integer.\n        // You have to find integers\
    \ 'x' in the list,\n        // and return list of tuples, [(x1, y1), (x2, y2)\
    \ ...] such that\n        // each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n        // Sort coordinates initially by rows in ascending order.\n\
    \        // Also, sort coordinates of the row by columns in descending order.\n\
    \        // If you find multiple 'x' in a row, then sort them by columns in descending\
    \ order.\n        // If you find multiple 'x' in a column, then sort them by rows\
    \ in ascending order.\n        // If you find multiple 'x' in a row and column,\
    \ then sort them by rows in ascending order.\n        // If you don't find 'x'\
    \ in the list, then return empty list.\n        // If the list is empty, then\
    \ return empty list.\n        // Note: You can assume that all the elements in\
    \ the list are unique.\n        // Note: You can assume that all the elements\
    \ in the list are positive.\n        // Note: You can assume that all the elements\
    \ in the list are integers.\n        // Note: You can assume that all the elements\
    \ in the list are less than or equal to 100.\n        // Note: You can assume\
    \ that all the elements in the list are greater than or equal to 1.\n        //\
    \ Note: You can assume that the list is not null.\n        // Note: You can assume\
    \ that the list is not empty.\n        // Note: You can assume that the list is\
    \ not a nested list.\n        // Note: You can assume that the list is a nested\
    \ list.\n        // Note: You can assume that the list is a 2 dimensional data.\n\
    \        // Note: You can assume that the list is a nested list of integers.\n\
    \        // Note: You can assume that the list is a nested list of positive integers.\n\
    \        // Note: You can assume that the list is a nested list of unique integers.\n\
    \        // Note: You can assume that the list is a nested list of unique positive\
    \ integers.\n        // Note: You can", "        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => {\n\
    \            if (a._1 < b._1) {\n                true\n            } else if (a._1\
    \ == b._1) {\n                a._2 > b._2\n            } else {\n            \
    \    false\n            }\n        })", "        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => a._1\
    \ < b._1 || (a._1 == b._1 && a._2 > b._2))", "        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => {\n\
    \            if (a._1 == b._1) {\n                a._2 > b._2\n            } else\
    \ {\n                a._1 < b._1\n            }\n        })", "        val result\
    \ = new ListBuffer[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length)\
    \ {\n            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) result += ((i.toLong, j.toLong))\n            }\n        }\n        result.toList.sortWith((a,\
    \ b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))", "        var result :\
    \ List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 to\
    \ lst.length - 1) {\n            for (j <- 0 to lst(i).length - 1) {\n       \
    \         if (lst(i)(j) == x) {\n                    result = result :+ (i.toLong,\
    \ j.toLong)\n                }\n            }\n        }\n        result.sortWith((a,\
    \ b) => (a._1 < b._1) || (a._1 == b._1 && a._2 > b._2))", "        var result\
    \ : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0\
    \ until lst.length) {\n            for (j <- 0 until lst(i).length) {\n      \
    \          if (lst(i)(j) == x) {\n                    result = result :+ (i.toLong,\
    \ j.toLong)\n                }\n            }\n        }\n        result.sortWith((a,\
    \ b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))", "        // Fill up this\
    \ function body\n        // 'lst' is a 2 dimensional list, similar to matrix,\n\
    \        // but unlike matrix, each row may contain a different number of columns.\n\
    \        // 'x' is an integer to be searched in the list.\n        // Return list\
    \ of tuples, [(x1, y1), (x2, y2) ...] such that\n        // each tuple is a coordinate\
    \ - (row, columns), starting with 0.\n        // Sort coordinates initially by\
    \ rows in ascending order.\n        // Also, sort coordinates of the row by columns\
    \ in descending order.\n        // If x is not found in the list, return empty\
    \ list.\n        // Note: You can use built-in sort function.\n        //    \
    \   You can use built-in zipWithIndex function.\n        //       You can use\
    \ built-in flatten function.\n        //       You can use built-in filter function.\n\
    \        //       You can use built-in map function.\n        //       You can\
    \ use built-in foldLeft function.\n        //       You can use built-in foldRight\
    \ function.\n        //       You can use built-in reverse function.\n       \
    \ //       You can use built-in zip function.\n        //       You can use built-in\
    \ unzip function.\n        //       You can use built-in flatten function.\n \
    \       //       You can use built-in max function.\n        //       You can\
    \ use built-in min function.\n        //       You can use built-in sum function.\n\
    \        //       You can use built-in product function.\n        //       You\
    \ can use built-in mkString function.\n        //       You can use built-in toString\
    \ function.\n        //       You can use built-in toList function.\n        //\
    \       You can use built-in toSet function.\n        //       You can use built-in\
    \ toMap function.\n        //       You can use built-in toSeq function.\n   \
    \     //       You can use built-in toIndexedSeq function.\n        //       You\
    \ can use built-in toBuffer function.\n        //       You can use built-in toVector\
    \ function.\n        //       You can use built-in toIterable function.\n    \
    \    //       You can use built-in toIterator function.\n        //", "      \
    \  // Fill up this function body\n        // 'lst' is a nested list, similar to\
    \ matrix, but each row may contain a different number of columns.\n        //\
    \ 'x' is an integer to be searched in the list.\n        // Return a list of tuples,\
    \ [(x1, y1), (x2, y2) ...] such that\n        // each tuple is a coordinate -\
    \ (row, columns), starting with 0.\n        // Sort coordinates initially by rows\
    \ in ascending order.\n        // Also, sort coordinates of the row by columns\
    \ in descending order.\n        // If x is not found in the list, return an empty\
    \ list.\n        // If the list is empty, return an empty list.\n        // Note:\n\
    \        // 1. You can assume that the list is non-empty.\n        // 2. You can\
    \ assume that the list is non-null.\n        // 3. You can assume that the list\
    \ is not a string.\n        // 4. You can assume that the list is not a set.\n\
    \        // 5. You can assume that the list is not a map.\n        // 6. You can\
    \ assume that the list is not a vector.\n        // 7. You can assume that the\
    \ list is not a stream.\n        // 8. You can assume that the list is not a range.\n\
    \        // 9. You can assume that the list is not a sequence.\n        // 10.\
    \ You can assume that the list is not a collection.\n        // 11. You can assume\
    \ that the list is not an iterator.\n        // 12. You can assume that the list\
    \ is not a traversable.\n        // 13. You can assume that the list is not a\
    \ traversable once.\n        // 14. You can assume that the list is not an iterable.\n\
    \        // 15. You can assume that the list is not an iterable once.\n      \
    \  // 16. You can assume that the list is not a view.\n        // 17. You can\
    \ assume that the list is not a linear sequence.\n        // 18. You can assume\
    \ that the list is not a sequence view.\n        // 19. You can assume that the\
    \ list is not a slice.\n        // 20. You can assume that the list is not a sliceable.\n\
    \        // 21. You can assume that the list is not a linear sequence.\n     \
    \   // 22.", "        var result : List[Tuple2[Long, Long]] = List[Tuple2[Long,\
    \ Long]]()\n        for (i <- 0 until lst.length) {\n            for (j <- 0 until\
    \ lst(i).length) {\n                if (lst(i)(j) == x) {\n                  \
    \  result = result :+ (i.toLong, j.toLong)\n                }\n            }\n\
    \        }\n        result.sortWith((a, b) => a._1 < b._1 || (a._1 == b._1 &&\
    \ a._2 > b._2))", "        var result : List[Tuple2[Long, Long]] = List[Tuple2[Long,\
    \ Long]]()\n        for (i <- 0 until lst.length) {\n            for (j <- 0 until\
    \ lst(i).length) {\n                if (lst(i)(j) == x) {\n                  \
    \  result = result :+ (i.toLong, j.toLong)\n                }\n            }\n\
    \        }\n        result.sortWith((a, b) => {\n            if (a._1 < b._1)\
    \ {\n                true\n            } else if (a._1 == b._1) {\n          \
    \      a._2 > b._2\n            } else {\n                false\n            }\n\
    \        })", "        var result : List[Tuple2[Long, Long]] = List[Tuple2[Long,\
    \ Long]]()\n        for (i <- 0 until lst.length) {\n            for (j <- 0 until\
    \ lst(i).length) {\n                if (lst(i)(j) == x) {\n                  \
    \  result = result :+ (i.toLong, j.toLong)\n                }\n            }\n\
    \        }\n        result.sortWith((a, b) => {\n            if (a._1 == b._1)\
    \ {\n                a._2 > b._2\n            } else {\n                a._1 <\
    \ b._1\n            }\n        })", "        var result : List[Tuple2[Long, Long]]\
    \ = List[Tuple2[Long, Long]]()\n        for (i <- 0 to lst.length - 1) {\n   \
    \         val row = lst(i)\n            for (j <- 0 to row.length - 1) {\n   \
    \             if (row(j) == x) {\n                    result = result :+ (i.toLong,\
    \ j.toLong)\n                }\n            }\n        }\n        result.sortWith((a,\
    \ b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))", "        var result :\
    \ List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until\
    \ lst.length) {\n            var row : List[Long] = lst(i)\n            for (j\
    \ <- 0 until row.length) {\n                if (row(j) == x) {\n             \
    \       result = (i, j) :: result\n                }\n            }\n        }\n\
    \        result.sortWith((a, b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))",
  "        var result : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n  \
    \      for (i <- 0 until lst.length) {\n            var row : List[Long] = lst(i)\n\
    \            for (j <- 0 until row.length) {\n                if (row(j) == x)\
    \ {\n                    result = (i, j) :: result\n                }\n      \
    \      }\n        }\n        result.sortWith((a, b) => (a._1 < b._1 || (a._1 ==\
    \ b._1 && a._2 > b._2)))", "        // Fill up this function body\n        //\
    \ 'lst' is a nested list, which is similar to matrix,\n        // however, unlike\
    \ matrices, each row may contain a different number of columns.\n        // 'x'\
    \ is an integer to be found in the list.\n        // Return list of tuples, [(x1,\
    \ y1), (x2, y2) ...] such that\n        // each tuple is a coordinate - (row,\
    \ columns), starting with 0.\n        // Sort coordinates initially by rows in\
    \ ascending order.\n        // Also, sort coordinates of the row by columns in\
    \ descending order.\n        lst.zipWithIndex.flatMap(x => x._1.zipWithIndex.filter(y\
    \ => y._1 == x._2).map(y => (x._2, y._2))).sortBy(x => (x._1, -x._2))", "    \
    \    // Fill up this function body\n        // 'lst' is a nested list, which is\
    \ similar to matrix, however, unlike matrices,\n        // each row may contain\
    \ a different number of columns.\n        // 'x' is an integer to be searched\
    \ in the list.\n        // Return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n        // each tuple is a coordinate - (row, columns), starting with\
    \ 0.\n        // Sort coordinates initially by rows in ascending order.\n    \
    \    // Also, sort coordinates of the row by columns in descending order.\n  \
    \      // If 'x' is not found in the list, return empty list.\n        // If 'lst'\
    \ is empty, return empty list.\n        var result = List[Tuple2[Long, Long]]()\n\
    \        for (i <- 0 until lst.length) {\n            for (j <- 0 until lst(i).length)\
    \ {\n                if (lst(i)(j) == x) {\n                    result = result\
    \ :+ (i.toLong, j.toLong)\n                }\n            }\n        }\n     \
    \   result.sortWith((a, b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))",
  "        // Fill up this function body\n        // 'lst' is a nested list, similar\
    \ to matrix,\n        // however, unlike matrices, each row may contain a different\
    \ number of columns.\n        // 'x' is an integer, which you need to find in\
    \ the list.\n        // Return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    \        // each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \      // Sort coordinates initially by rows in ascending order.\n        // Also,\
    \ sort coordinates of the row by columns in descending order.\n        // If x\
    \ is not found in the list, return empty list.\n        // If list is empty, return\
    \ empty list.\n        // If list is None, return empty list.\n        // If x\
    \ is None, return empty list.\n        // If x is not an integer, return empty\
    \ list.\n        // If list is not a nested list, return empty list.\n       \
    \ // If list is not a nested list of integers, return empty list.\n        //\
    \ If list is a nested list of integers, but x is not found, return empty list.\n\
    \        // If list is a nested list of integers, and x is found, return list\
    \ of tuples,\n        // [(x1, y1), (x2, y2) ...] such that each tuple is a coordinate\
    \ - (row, columns),\n        // starting with 0.\n        // Sort coordinates\
    \ initially by rows in ascending order.\n        // Also, sort coordinates of\
    \ the row by columns in descending order.\n        // If x is not found in the\
    \ list, return empty list.\n        // If list is empty, return empty list.\n\
    \        // If list is None, return empty list.\n        // If x is None, return\
    \ empty list.\n        // If x is not an integer, return empty list.\n       \
    \ // If list is not a nested list, return empty list.\n        // If list is not\
    \ a nested list of integers, return empty list.\n        // If list is a nested\
    \ list of integers, but x is not found, return empty list.\n        // If list\
    \ is a nested list of integers, and x is found, return list of tuples,\n     \
    \   // [(x1, y1), (x2, y2) ...] such that each tuple is", "        // Fill up\
    \ this function body\n        // 'lst' is a nested list of integers\n        //\
    \ 'x' is an integer\n        // Return a list of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n        // each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n        // Sort coordinates initially by rows in ascending order.\n\
    \        // Also, sort coordinates of the row by columns in descending order.\n\
    \        // If there are no coordinates, return empty list.\n        // If there\
    \ are no coordinates, return empty list.\n        var result = List[Tuple2[Long,\
    \ Long]]()\n        for (i <- 0 until lst.length) {\n            for (j <- 0 until\
    \ lst(i).length) {\n                if (lst(i)(j) == x) {\n                  \
    \  result = result :+ (i.toLong, j.toLong)\n                }\n            }\n\
    \        }\n        result.sortWith((x, y) => x._1 < y._1 || (x._1 == y._1 &&\
    \ x._2 > y._2))", "        // Fill up this function body\n        // 'lst' is\
    \ a list of lists, where each list is a row of the matrix\n        // 'x' is the\
    \ integer to be searched in the matrix\n        // You have to return a list of\
    \ tuples, where each tuple is a coordinate - (row, columns), starting with 0.\n\
    \        // Sort coordinates initially by rows in ascending order.\n        //\
    \ Also, sort coordinates of the row by columns in descending order.\n        //\
    \ If the integer is not found in the matrix, return an empty list.\n        //\
    \ If the matrix is empty, return an empty list.\n        // If the matrix is not\
    \ empty, but the integer is not found, return an empty list.\n        // If the\
    \ matrix is not empty, and the integer is found, return the list of tuples.\n\
    \        // If the matrix is not empty, and the integer is found multiple times,\
    \ return the list of tuples.\n        // If the matrix is not empty, and the integer\
    \ is found multiple times, return the list of tuples,\n        // sorted by rows\
    \ in ascending order.\n        // If the matrix is not empty, and the integer\
    \ is found multiple times, return the list of tuples,\n        // sorted by rows\
    \ in ascending order, and also, sort coordinates of the row by columns in descending\
    \ order.\n        // If the matrix is not empty, and the integer is found multiple\
    \ times, return the list of tuples,\n        // sorted by rows in ascending order,\
    \ and also, sort coordinates of the row by columns in descending order.\n    \
    \    // If the matrix is not empty, and the integer is found multiple times, return\
    \ the list of tuples,\n        // sorted by rows in ascending order, and also,\
    \ sort coordinates of the row by columns in descending order.\n        // If the\
    \ matrix is not empty, and the integer is found multiple times, return the list\
    \ of tuples,\n        // sorted by rows in ascending order, and also, sort coordinates\
    \ of the row by columns in descending order.\n        // If the matrix is not\
    \ empty, and the integer is found multiple times, return the list of tuples,\n\
    \        // sorted by rows in ascending order, and also, sort coordinates of the\
    \ row by columns in descending order.\n        // If the matrix is not empty,\
    \ and the integer is found multiple times, return the list of tuples,\n      \
    \  //", "        var result : List[Tuple2[Long, Long]] = List()\n        for (i\
    \ <- 0 until lst.length) {\n            for (j <- 0 until lst(i).length) {\n \
    \               if (lst(i)(j) == x) {\n                    result = result :+\
    \ (i.toLong, j.toLong)\n                }\n            }\n        }\n        result.sortWith((a,\
    \ b) => {\n            if (a._1 < b._1) {\n                true\n            }\
    \ else if (a._1 == b._1) {\n                a._2 > b._2\n            } else {\n\
    \                false\n            }\n        })", "        // Fill up this function\
    \ body\n        // 'lst' is a nested list, similar to matrix, but each row may\
    \ contain a different number of columns.\n        // 'x' is an integer to be searched\
    \ in the list.\n        // Return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n        // each tuple is a coordinate - (row, columns), starting with\
    \ 0.\n        // Sort coordinates initially by rows in ascending order.\n    \
    \    // Also, sort coordinates of the row by columns in descending order.\n  \
    \      var result = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length)\
    \ {\n            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = (i, j) :: result\n                }\n\
    \            }\n        }\n        result.sortWith((a, b) => {\n            if\
    \ (a._1 == b._1) {\n                a._2 > b._2\n            } else {\n      \
    \          a._1 < b._1\n            }\n        })", "        // Fill up this function\
    \ body\n        // 'lst' is a nested list, similar to matrix,\n        // however,\
    \ unlike matrices, each row may contain a different number of columns.\n     \
    \   // 'x' is an integer.\n        // You have to find integers x in the list,\n\
    \        // and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n  \
    \      // each tuple is a coordinate - (row, columns), starting with 0.\n    \
    \    // Sort coordinates initially by rows in ascending order.\n        // Also,\
    \ sort coordinates of the row by columns in descending order.\n        var result\
    \ : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0\
    \ to lst.length - 1) {\n            var row : List[Long] = lst(i)\n          \
    \  for (j <- 0 to row.length - 1) {\n                if (row(j) == x) {\n    \
    \                result = result :+ (i.toLong, j.toLong)\n                }\n\
    \            }\n        }\n        result.sortWith((a, b) => a._1 < b._1 || (a._1\
    \ == b._1 && a._2 > b._2))", "        var result : List[Tuple2[Long, Long]] =\
    \ List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n      \
    \      for (j <- 0 until lst(i).length) {\n                if (lst(i)(j) == x)\
    \ {\n                    result = result :+ (i.toLong, j.toLong)\n           \
    \     }\n            }\n        }\n        result.sortWith((a, b) => {\n     \
    \       if (a._1 < b._1) {\n                true\n            } else if (a._1\
    \ == b._1) {\n                a._2 > b._2\n            } else {\n            \
    \    false\n            }\n        })", "        // Fill up this function body\n\
    \        // 'lst' is a nested list, similar to matrix, but each row may contain\
    \ a different number of columns.\n        // 'x' is an integer.\n        // Return\
    \ list of tuples, [(x1, y1), (x2, y2) ...] such that\n        // each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n        // Sort coordinates\
    \ initially by rows in ascending order.\n        // Also, sort coordinates of\
    \ the row by columns in descending order.\n        // If there are no coordinates,\
    \ return empty list.\n        // If there are no rows, return empty list.\n  \
    \      // If there are no columns, return empty list.\n        // If there are\
    \ no elements in the list, return empty list.\n        // If there are no elements\
    \ in the row, return empty list.\n        // If there are no elements in the column,\
    \ return empty list.\n        // If there are no elements in the matrix, return\
    \ empty list.\n        // If there are no elements in the nested list, return\
    \ empty list.\n        // If there are no elements in the nested list, return\
    \ empty list.\n        // If there are no elements in the nested list, return\
    \ empty list.\n        // If there are no elements in the nested list, return\
    \ empty list.\n        // If there are no elements in the nested list, return\
    \ empty list.\n        // If there are no elements in the nested list, return\
    \ empty list.\n        // If there are no elements in the nested list, return\
    \ empty list.\n        // If there are no elements in the nested list, return\
    \ empty list.\n        // If there are no elements in the nested list, return\
    \ empty list.\n        // If there are no elements in the nested list, return\
    \ empty list.\n        // If there are no elements in the nested list, return\
    \ empty list.\n        // If there are no elements in the nested list, return\
    \ empty list.\n        // If there are no elements in the nested list, return\
    \ empty list.\n        // If there are no elements in the nested list, return\
    \ empty list.\n        // If there are no elements in the nested list, return\
    \ empty list.\n        // If there are no elements in the nested list, return\
    \ empty list.\n        // If there are no elements in the nested list, return\
    \ empty list.\n       ", "        // Fill up this function body\n        // 'lst'\
    \ is a nested list, similar to matrix,\n        // however, unlike matrices, each\
    \ row may contain a different number of columns.\n        // 'x' is an integer\n\
    \        // You have to return a list of tuples,\n        // [(x1, y1), (x2, y2)\
    \ ...] such that\n        // each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n        // Sort coordinates initially by rows in ascending order.\n\
    \        // Also, sort coordinates of the row by columns in descending order.\n\
    \        // If there are no such coordinates, return an empty list.\n        //\
    \ If there are multiple such coordinates, return all of them.\n        // If there\
    \ are no rows, return an empty list.\n        // If there are no columns, return\
    \ an empty list.\n        // If there are no elements, return an empty list.\n\
    \        // If there are no such elements, return an empty list.\n        // If\
    \ there are multiple such elements, return all of them.\n        // If there are\
    \ no such elements, return an empty list.\n        // If there are multiple such\
    \ elements, return all of them.\n        // If there are no such elements, return\
    \ an empty list.\n        // If there are multiple such elements, return all of\
    \ them.\n        // If there are no such elements, return an empty list.\n   \
    \     // If there are multiple such elements, return all of them.\n        //\
    \ If there are no such elements, return an empty list.\n        // If there are\
    \ multiple such elements, return all of them.\n        // If there are no such\
    \ elements, return an empty list.\n        // If there are multiple such elements,\
    \ return all of them.\n        // If there are no such elements, return an empty\
    \ list.\n        // If there are multiple such elements, return all of them.\n\
    \        // If there are no such elements, return an empty list.\n        // If\
    \ there are multiple such elements, return all of them.\n        // If there are\
    \ no such elements, return an empty list.\n        // If there are multiple such\
    \ elements, return all of them.\n        // If there are no such elements, return\
    \ an empty list.\n        // If there are multiple such elements, return all of\
    \ them.\n        // If there are no such", "        // Fill up this function body\n\
    \        // 'lst' is a nested list, similar to matrix,\n        // however, unlike\
    \ matrices, each row may contain a different number of columns.\n        // 'x'\
    \ is an integer to be searched in the nested list.\n        // Return list of\
    \ tuples, [(x1, y1), (x2, y2) ...] such that\n        // each tuple is a coordinate\
    \ - (row, columns), starting with 0.\n        // Sort coordinates initially by\
    \ rows in ascending order.\n        // Also, sort coordinates of the row by columns\
    \ in descending order.\n        // If 'x' is not found, return empty list.\n \
    \       // If 'lst' is empty, return empty list.\n        var result = List[Tuple2[Long,\
    \ Long]]()\n        for (i <- 0 until lst.length) {\n            for (j <- 0 until\
    \ lst(i).length) {\n                if (lst(i)(j) == x) {\n                  \
    \  result = (i, j) :: result\n                }\n            }\n        }\n  \
    \      result.sortWith((a, b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))",
  "        var result : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n  \
    \      for (i <- 0 until lst.length) {\n            for (j <- 0 until lst(i).length)\
    \ {\n                if (lst(i)(j) == x) {\n                    result = (i, j)\
    \ :: result\n                }\n            }\n        }\n        result.sortWith((a,\
    \ b) => (a._1 < b._1) || (a._1 == b._1 && a._2 > b._2))", "        // Fill up\
    \ this function body\n        // 'lst' is a nested list, similar to matrix, but\
    \ each row may contain a different number of columns.\n        // 'x' is an integer\
    \ to be found in the list.\n        // You have to find integers x in the list,\
    \ and return list of tuples,\n        // [(x1, y1), (x2, y2) ...] such that each\
    \ tuple is a coordinate - (row, columns),\n        // starting with 0. Sort coordinates\
    \ initially by rows in ascending order.\n        // Also, sort coordinates of\
    \ the row by columns in descending order.\n        // If the list is empty, return\
    \ empty list.\n        // If the list is not empty, but the integer x is not found,\
    \ return empty list.\n        // If the list is not empty, and the integer x is\
    \ found, return list of tuples.\n        // If the list is not empty, and the\
    \ integer x is found multiple times,\n        // return list of tuples, which\
    \ contains all the coordinates.\n        // If the list is not empty, and the\
    \ integer x is found multiple times,\n        // return list of tuples, which\
    \ contains all the coordinates.\n        // If the list is not empty, and the\
    \ integer x is found multiple times,\n        // return list of tuples, which\
    \ contains all the coordinates.\n        // If the list is not empty, and the\
    \ integer x is found multiple times,\n        // return list of tuples, which\
    \ contains all the coordinates.\n        // If the list is not empty, and the\
    \ integer x is found multiple times,\n        // return list of tuples, which\
    \ contains all the coordinates.\n        // If the list is not empty, and the\
    \ integer x is found multiple times,\n        // return list of tuples, which\
    \ contains all the coordinates.\n        // If the list is not empty, and the\
    \ integer x is found multiple times,\n        // return list of tuples, which\
    \ contains all the coordinates.\n        // If the list is not empty, and the\
    \ integer x is found multiple times,\n        // return list of tuples, which\
    \ contains all the coordinates.\n        // If the list is not empty, and the\
    \ integer x is found multiple times,\n        // return list of tuples, which\
    \ contains all the coordinates.\n        // If the list is not empty, and the\
    \ integer", "        // Fill up this function body\n        // 'lst' is a nested\
    \ list, similar to matrix, but unlike matrix,\n        // each row may contain\
    \ a different number of columns.\n        // 'x' is an integer to be found in\
    \ the list.\n        // Return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    \        // each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \      // Sort coordinates initially by rows in ascending order.\n        // Also,\
    \ sort coordinates of the row by columns in descending order.\n        // If x\
    \ is not found in the list, return empty list.\n        // If the list is empty,\
    \ return empty list.\n        // If the list is None, return empty list.\n   \
    \     // If the list is not a nested list, return empty list.\n        // If the\
    \ list is not a list of lists, return empty list.\n        // If the list is not\
    \ a list of lists of integers, return empty list.\n        // If the list is not\
    \ a list of lists of longs, return empty list.\n        // If the list is not\
    \ a list of lists of longs, return empty list.\n        // If the list is not\
    \ a list of lists of longs, return empty list.\n        // If the list is not\
    \ a list of lists of longs, return empty list.\n        // If the list is not\
    \ a list of lists of longs, return empty list.\n        // If the list is not\
    \ a list of lists of longs, return empty list.\n        // If the list is not\
    \ a list of lists of longs, return empty list.\n        // If the list is not\
    \ a list of lists of longs, return empty list.\n        // If the list is not\
    \ a list of lists of longs, return empty list.\n        // If the list is not\
    \ a list of lists of longs, return empty list.\n        // If the list is not\
    \ a list of lists of longs, return empty list.\n        // If the list is not\
    \ a list of lists of longs, return empty list.\n        // If the list is not\
    \ a list of lists of longs, return empty list.\n        // If the list is not\
    \ a list of lists of longs, return empty list.\n        // If the list is not",
  "        var result : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n  \
    \      for (i <- 0 until lst.length) {\n            for (j <- 0 until lst(i).length)\
    \ {\n                if (lst(i)(j) == x) {\n                    result = (i, j)\
    \ :: result\n                }\n            }\n        }\n        result.sortWith((a,\
    \ b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))", "        var result :\
    \ List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until\
    \ lst.length) {\n            for (j <- 0 until lst(i).length) {\n            \
    \    if (lst(i)(j) == x) {\n                    result = result :+ (i.toLong,\
    \ j.toLong)\n                }\n            }\n        }\n        result.sortWith((a,\
    \ b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))", "        // Fill up this\
    \ function body\n        // 'lst' is a nested list, which is similar to matrix,\
    \ however, unlike matrices,\n        // each row may contain a different number\
    \ of columns.\n        // 'x' is an integer\n        // return list of tuples,\
    \ [(x1, y1), (x2, y2) ...] such that\n        // each tuple is a coordinate -\
    \ (row, columns), starting with 0.\n        // Sort coordinates initially by rows\
    \ in ascending order.\n        // Also, sort coordinates of the row by columns\
    \ in descending order.\n        var result = List[Tuple2[Long, Long]]()\n    \
    \    for (i <- 0 until lst.length) {\n            for (j <- 0 until lst(i).length)\
    \ {\n                if (lst(i)(j) == x) {\n                    result = result\
    \ :+ (i.toLong, j.toLong)\n                }\n            }\n        }\n     \
    \   result.sortWith((a, b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))",
  "        var result : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n  \
    \      for (i <- 0 until lst.length) {\n            for (j <- 0 until lst(i).length)\
    \ {\n                if (lst(i)(j) == x) {\n                    result = result\
    \ :+ (i.toLong, j.toLong)\n                }\n            }\n        }\n     \
    \   result.sortWith((a, b) => {\n            if (a._1 == b._1) {\n           \
    \     a._2 > b._2\n            } else {\n                a._1 < b._1\n       \
    \     }\n        })", "        // Fill up this function body\n        // 'lst'\
    \ is a nested list, similar to matrix,\n        // 'x' is an integer to be found\
    \ in the list\n        // Return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n        // each tuple is a coordinate - (row, columns), starting with\
    \ 0.\n        // Sort coordinates initially by rows in ascending order.\n    \
    \    // Also, sort coordinates of the row by columns in descending order.\n  \
    \      // If x is not found in the list, return empty list.\n        var result\
    \ = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n    \
    \        val row = lst(i)\n            for (j <- 0 until row.length) {\n     \
    \           if (row(j) == x) {\n                    result = (i, j) :: result\n\
    \                }\n            }\n        }\n        result.sortWith((a, b) =>\
    \ {\n            if (a._1 != b._1) {\n                a._1 < b._1\n          \
    \  } else {\n                a._2 > b._2\n            }\n        })", "      \
    \  // Fill up this function body\n        // 'lst' is a list of lists, and 'x'\
    \ is the number to be searched\n        // Return a list of tuples, each tuple\
    \ is a coordinate - (row, column)\n        // Sort coordinates initially by rows\
    \ in ascending order\n        // Also, sort coordinates of the row by columns\
    \ in descending order\n        // If x is not found, return an empty list\n  \
    \      // If lst is empty, return an empty list\n        var result = List[Tuple2[Long,\
    \ Long]]()\n        for (i <- 0 until lst.length) {\n            for (j <- 0 until\
    \ lst(i).length) {\n                if (lst(i)(j) == x) {\n                  \
    \  result = result :+ (i.toLong, j.toLong)\n                }\n            }\n\
    \        }\n        result.sortWith(_._1 < _._1).sortWith(_._2 > _._2)", "   \
    \     // Fill up this function body\n        // 'lst' is a nested list, which\
    \ is similar to matrix, however, unlike matrices,\n        // each row may contain\
    \ a different number of columns.\n        // 'x' is an integer\n        // You\
    \ have to return a list of tuples, [(x1, y1), (x2, y2) ...] such that\n      \
    \  // each tuple is a coordinate - (row, columns), starting with 0.\n        //\
    \ Sort coordinates initially by rows in ascending order.\n        // Also, sort\
    \ coordinates of the row by columns in descending order.\n        var result =\
    \ List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n      \
    \      for (j <- 0 until lst(i).length) {\n                if (lst(i)(j) == x)\
    \ {\n                    result = result :+ (i.toLong, j.toLong)\n           \
    \     }\n            }\n        }\n        result.sortWith((a, b) => (a._1 < b._1)\
    \ || (a._1 == b._1 && a._2 > b._2))", "        // Fill up this function body\n\
    \        // 'lst' is a nested list, similar to matrix, but unlike matrix,\n  \
    \      // each row may contain a different number of columns.\n        // 'x'\
    \ is an integer to be searched in the list.\n        // Return a list of tuples,\
    \ [(x1, y1), (x2, y2) ...] such that\n        // each tuple is a coordinate -\
    \ (row, columns), starting with 0.\n        // Sort coordinates initially by rows\
    \ in ascending order.\n        // Also, sort coordinates of the row by columns\
    \ in descending order.\n        // If x is not found in the list, return an empty\
    \ list.\n        // If the list is empty, return an empty list.\n        // If\
    \ the list is empty, return an empty list.\n        // If the list is empty, return\
    \ an empty list.\n        // If the list is empty, return an empty list.\n   \
    \     // If the list is empty, return an empty list.\n        // If the list is\
    \ empty, return an empty list.\n        // If the list is empty, return an empty\
    \ list.\n        // If the list is empty, return an empty list.\n        // If\
    \ the list is empty, return an empty list.\n        // If the list is empty, return\
    \ an empty list.\n        // If the list is empty, return an empty list.\n   \
    \     // If the list is empty, return an empty list.\n        // If the list is\
    \ empty, return an empty list.\n        // If the list is empty, return an empty\
    \ list.\n        // If the list is empty, return an empty list.\n        // If\
    \ the list is empty, return an empty list.\n        // If the list is empty, return\
    \ an empty list.\n        // If the list is empty, return an empty list.\n   \
    \     // If the list is empty, return an empty list.\n        // If the list is\
    \ empty, return an empty list.\n        // If the list is empty, return an empty\
    \ list.\n        // If the list is empty, return an empty list.\n        // If\
    \ the list is empty, return an empty list.\n        // If the list is empty, return\
    \ an empty list.\n        // If the list is empty, return an empty list.\n   \
    \     // If the list is empty, return an empty list.", "        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => a._1\
    \ < b._1 || (a._1 == b._1 && a._2 > b._2))", "        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => {\n\
    \            if (a._1 < b._1) {\n                true\n            } else if (a._1\
    \ == b._1) {\n                a._2 > b._2\n            } else {\n            \
    \    false\n            }\n        })", "        // Fill up this function body\n\
    \        // 'lst' is a nested list, similar to matrix,\n        // 'x' is an integer\
    \ to be searched in the list\n        // Return a list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n        // each tuple is a coordinate - (row, columns),\
    \ starting with 0.\n        // Sort coordinates initially by rows in ascending\
    \ order.\n        // Also, sort coordinates of the row by columns in descending\
    \ order.\n        // If x is not found in the list, return empty list.\n     \
    \   // If the list is empty, return empty list.\n        // If the list is None,\
    \ return empty list.\n        // If the list is not a nested list, return empty\
    \ list.\n        // If the list is not a list of lists, return empty list.\n \
    \       // If the list is not a list of list of integers, return empty list.\n\
    \        // If the list is not a list of list of longs, return empty list.\n \
    \       // If the list is not a list of list of longs, return empty list.\n  \
    \      // If the list is not a list of list of longs, return empty list.\n   \
    \     // If the list is not a list of list of longs, return empty list.\n    \
    \    // If the list is not a list of list of longs, return empty list.\n     \
    \   // If the list is not a list of list of longs, return empty list.\n      \
    \  // If the list is not a list of list of longs, return empty list.\n       \
    \ // If the list is not a list of list of longs, return empty list.\n        //\
    \ If the list is not a list of list of longs, return empty list.\n        // If\
    \ the list is not a list of list of longs, return empty list.\n        // If the\
    \ list is not a list of list of longs, return empty list.\n        // If the list\
    \ is not a list of list of longs, return empty list.\n        // If the list is\
    \ not a list of list of longs, return empty list.\n        // If the list is not\
    \ a list of list of longs, return empty list.\n        // If the list is not a\
    \ list of list of longs, return empty list.\n        // If the", "        // Fill\
    \ up this function body\n        // 'lst' is a nested list of integers\n     \
    \   // 'x' is an integer\n        // Return a list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n        // each tuple is a coordinate - (row, columns),\
    \ starting with 0.\n        // Sort coordinates initially by rows in ascending\
    \ order.\n        // Also, sort coordinates of the row by columns in descending\
    \ order.\n        // If there are no coordinates, return empty list.\n       \
    \ // If there are no coordinates, return empty list.\n        var result : List[Tuple2[Long,\
    \ Long]] = List()\n        for (i <- 0 to lst.length - 1) {\n            for (j\
    \ <- 0 to lst(i).length - 1) {\n                if (lst(i)(j) == x) {\n      \
    \              result = (i, j) :: result\n                }\n            }\n \
    \       }\n        result.sortWith((a, b) => (a._1 < b._1) || (a._1 == b._1 &&\
    \ a._2 > b._2))", "        // Fill up this function body\n        // 'lst' is\
    \ a nested list, which is similar to matrix,\n        // however, unlike matrices,\
    \ each row may contain a different number of columns.\n        // 'x' is an integer.\n\
    \        // You have to find integers 'x' in the list,\n        // and return\
    \ list of tuples, [(x1, y1), (x2, y2) ...] such that\n        // each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n        // Sort coordinates\
    \ initially by rows in ascending order.\n        // Also, sort coordinates of\
    \ the row by columns in descending order.\n        // If you find no 'x' in the\
    \ list, return empty list.\n        // If the list is empty, return empty list.\n\
    \        // If the list is empty, return empty list.\n        // If the list is\
    \ empty, return empty list.\n        // If the list is empty, return empty list.\n\
    \        // If the list is empty, return empty list.\n        // If the list is\
    \ empty, return empty list.\n        // If the list is empty, return empty list.\n\
    \        // If the list is empty, return empty list.\n        // If the list is\
    \ empty, return empty list.\n        // If the list is empty, return empty list.\n\
    \        // If the list is empty, return empty list.\n        // If the list is\
    \ empty, return empty list.\n        // If the list is empty, return empty list.\n\
    \        // If the list is empty, return empty list.\n        // If the list is\
    \ empty, return empty list.\n        // If the list is empty, return empty list.\n\
    \        // If the list is empty, return empty list.\n        // If the list is\
    \ empty, return empty list.\n        // If the list is empty, return empty list.\n\
    \        // If the list is empty, return empty list.\n        // If the list is\
    \ empty, return empty list.\n        // If the list is empty, return empty list.\n\
    \        // If the list is empty, return empty list.\n        // If the list is\
    \ empty, return empty list.\n        // If the list is empty, return empty list.\n\
    \        // If the list is empty, return empty list.\n        // If the list is\
    \ empty, return empty list", "        var result : List[Tuple2[Long, Long]] =\
    \ List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n      \
    \      for (j <- 0 until lst(i).length) {\n                if (lst(i)(j) == x)\
    \ {\n                    result = (i, j) :: result\n                }\n      \
    \      }\n        }\n        result.sortWith((a, b) => a._1 < b._1 || (a._1 ==\
    \ b._1 && a._2 > b._2))", "        // Fill up this function body\n        // 'lst'\
    \ is a nested list, similar to matrix, however,\n        // unlike matrices, each\
    \ row may contain a different number of columns.\n        // 'x' is an integer,\
    \ which is to be found in the list.\n        // Return list of tuples, [(x1, y1),\
    \ (x2, y2) ...] such that\n        // each tuple is a coordinate - (row, columns),\
    \ starting with 0.\n        // Sort coordinates initially by rows in ascending\
    \ order.\n        // Also, sort coordinates of the row by columns in descending\
    \ order.\n        // If 'x' is not found in the list, return empty list.\n   \
    \     // If 'lst' is empty, return empty list.\n        // If 'lst' is a list\
    \ of empty lists, return empty list.\n        // If 'lst' is a list of lists,\
    \ each of which is empty, return empty list.\n        // If 'lst' is a list of\
    \ lists, each of which is a list of empty lists, return empty list.\n        //\
    \ If 'lst' is a list of lists, each of which is a list of lists, each of which\
    \ is empty, return empty list.\n        // If 'lst' is a list of lists, each of\
    \ which is a list of lists, each of which is a list of empty lists, return empty\
    \ list.\n        // If 'lst' is a list of lists, each of which is a list of lists,\
    \ each of which is a list of lists, each of which is empty, return empty list.\n\
    \        // If 'lst' is a list of lists, each of which is a list of lists, each\
    \ of which is a list of lists, each of which is a list of empty lists, return\
    \ empty list.\n        // If 'lst' is a list of lists, each of which is a list\
    \ of lists, each of which is a list of lists, each of which is a list of lists,\
    \ each of which is empty, return empty list.\n        // If 'lst' is a list of\
    \ lists, each of which is a list of lists, each of which is a list of lists, each\
    \ of which is a list of lists, each of which is a list of empty lists, return\
    \ empty list.\n        // If 'lst' is", "        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            var row = lst(i)\n            for (j <- 0 until row.length) {\n \
    \               if (row(j) == x) {\n                    result = result :+ (i.toLong,\
    \ j.toLong)\n                }\n            }\n        }\n        result.sortWith((a,\
    \ b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))", "        // Fill up this\
    \ function body\n        // 'lst' is a nested list, similar to matrix,\n     \
    \   // however, unlike matrices, each row may contain a different number of columns.\n\
    \        // 'x' is an integer.\n        // You have to find integers x in the\
    \ list,\n        // and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    \        // each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \      // Sort coordinates initially by rows in ascending order.\n        // Also,\
    \ sort coordinates of the row by columns in descending order.\n        var result\
    \ = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n    \
    \        for (j <- 0 until lst(i).length) {\n                if (lst(i)(j) ==\
    \ x) {\n                    result = result :+ (i.toLong, j.toLong)\n        \
    \        }\n            }\n        }\n        result.sortWith((a, b) => a._1 <\
    \ b._1 || (a._1 == b._1 && a._2 > b._2))", "        // Fill up this function body\n\
    \        // 'lst' is a nested list, similar to matrix,\n        // 'x' is an integer\
    \ to be searched in the list\n        // Return a list of tuples, [(x1, y1), (x2,\
    \ y2) ...]\n        // such that each tuple is a coordinate - (row, columns),\n\
    \        // starting with 0.\n        // Sort coordinates initially by rows in\
    \ ascending order.\n        // Also, sort coordinates of the row by columns in\
    \ descending order.\n        // If x is not found, return empty list.\n      \
    \  // If lst is empty, return empty list.\n        // If lst is a list of empty\
    \ lists, return empty list.\n        // If lst is a list of lists, each of which\
    \ is empty, return empty list.\n        // If lst is a list of lists, each of\
    \ which contains only x, return empty list.\n        // If lst is a list of lists,\
    \ each of which contains only x, return empty list.\n        // If lst is a list\
    \ of lists, each of which contains only x, return empty list.\n        // If lst\
    \ is a list of lists, each of which contains only x, return empty list.\n    \
    \    // If lst is a list of lists, each of which contains only x, return empty\
    \ list.\n        // If lst is a list of lists, each of which contains only x,\
    \ return empty list.\n        // If lst is a list of lists, each of which contains\
    \ only x, return empty list.\n        // If lst is a list of lists, each of which\
    \ contains only x, return empty list.\n        // If lst is a list of lists, each\
    \ of which contains only x, return empty list.\n        // If lst is a list of\
    \ lists, each of which contains only x, return empty list.\n        // If lst\
    \ is a list of lists, each of which contains only x, return empty list.\n    \
    \    // If lst is a list of lists, each of which contains only x, return empty\
    \ list.\n        // If lst is a list of lists, each of which contains only x,\
    \ return empty list.\n        // If lst is a list of lists, each of which contains\
    \ only x, return empty list.\n        // If lst is a list", "        // Fill up\
    \ this function body\n        // 'lst' is a list of lists, each list is a row\n\
    \        // 'x' is the number to be searched in the list\n        // Return a\
    \ list of tuples, each tuple is a coordinate - (row, column)\n        // Sort\
    \ coordinates initially by rows in ascending order.\n        // Also, sort coordinates\
    \ of the row by columns in descending order.\n        var result = List[Tuple2[Long,\
    \ Long]]()\n        for (i <- 0 until lst.length) {\n            for (j <- 0 until\
    \ lst(i).length) {\n                if (lst(i)(j) == x) {\n                  \
    \  result = result :+ (i.toLong, j.toLong)\n                }\n            }\n\
    \        }\n        result.sortWith((a, b) => {\n            if (a._1 == b._1)\
    \ {\n                a._2 > b._2\n            } else {\n                a._1 <\
    \ b._1\n            }\n        })", "        // Fill up this function body\n \
    \       // 'lst' is a nested list, similar to matrix, but unlike matrix,\n   \
    \     // each row may contain a different number of columns.\n        // 'x' is\
    \ an integer, which is to be found in the list.\n        // Return list of tuples,\
    \ [(x1, y1), (x2, y2) ...] such that\n        // each tuple is a coordinate -\
    \ (row, columns), starting with 0.\n        // Sort coordinates initially by rows\
    \ in ascending order.\n        // Also, sort coordinates of the row by columns\
    \ in descending order.\n        // If x is not found in the list, return empty\
    \ list.\n        // If list is empty, return empty list.\n        // Note: You\
    \ can use built-in sort function, however,\n        // you can also write your\
    \ own sorting function.\n        // Note: You can use built-in sort function,\
    \ however,\n        // you can also write your own sorting function.\n       \
    \ var result : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n       \
    \ for (i <- 0 to lst.length - 1) {\n            for (j <- 0 to lst(i).length -\
    \ 1) {\n                if (lst(i)(j) == x) {\n                    result = result\
    \ :+ (i.toLong, j.toLong)\n                }\n            }\n        }\n     \
    \   result.sortWith((a, b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))",
  "        var result : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n  \
    \      for (i <- 0 until lst.length) {\n            val row = lst(i)\n       \
    \     for (j <- 0 until row.length) {\n                if (row(j) == x) {\n  \
    \                  result = (i, j) :: result\n                }\n            }\n\
    \        }\n        result.sortWith((a, b) => a._1 < b._1 || (a._1 == b._1 &&\
    \ a._2 > b._2))", "        var result : List[Tuple2[Long, Long]] = List[Tuple2[Long,\
    \ Long]]()\n        for (i <- 0 until lst.length) {\n            for (j <- 0 until\
    \ lst(i).length) {\n                if (lst(i)(j) == x) {\n                  \
    \  result = result :+ (i.toLong, j.toLong)\n                }\n            }\n\
    \        }\n        result.sortWith((a, b) => a._1 < b._1 || (a._1 == b._1 &&\
    \ a._2 > b._2))", "        var result : List[Tuple2[Long, Long]] = List[Tuple2[Long,\
    \ Long]]()\n        for (i <- 0 until lst.length) {\n            for (j <- 0 until\
    \ lst(i).length) {\n                if (lst(i)(j) == x) {\n                  \
    \  result = result :+ (i.toLong, j.toLong)\n                }\n            }\n\
    \        }\n        result.sortWith((a, b) => a._1 < b._1 || (a._1 == b._1 &&\
    \ a._2 > b._2))", "        var result : List[Tuple2[Long, Long]] = List[Tuple2[Long,\
    \ Long]]()\n        for (i <- 0 until lst.length) {\n            for (j <- 0 until\
    \ lst(i).length) {\n                if (lst(i)(j) == x) {\n                  \
    \  result = (i, j) :: result\n                }\n            }\n        }\n  \
    \      result.sortWith((x, y) => (x._1 < y._1) || (x._1 == y._1 && x._2 > y._2))",
  "        var result : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n  \
    \      for (i <- 0 until lst.length) {\n            for (j <- 0 until lst(i).length)\
    \ {\n                if (lst(i)(j) == x) {\n                    result = result\
    \ :+ (i.toLong, j.toLong)\n                }\n            }\n        }\n     \
    \   result.sortWith((a, b) => {\n            if (a._1 < b._1) {\n            \
    \    true\n            } else if (a._1 == b._1) {\n                a._2 > b._2\n\
    \            } else {\n                false\n            }\n        })", "  \
    \      // Fill up this function body\n        // 'lst' is a nested list, which\
    \ is similar to matrix,\n        // however, unlike matrices, each row may contain\
    \ a different number of columns.\n        // 'x' is an integer, which is to be\
    \ found in the list.\n        // You have to return a list of tuples, [(x1, y1),\
    \ (x2, y2) ...] such that\n        // each tuple is a coordinate - (row, columns),\
    \ starting with 0.\n        // Sort coordinates initially by rows in ascending\
    \ order.\n        // Also, sort coordinates of the row by columns in descending\
    \ order.\n        // If x is not found in the list, return empty list.\n     \
    \   // If the list is empty, return empty list.\n        // If the list is None,\
    \ return empty list.\n        // If the list is not a nested list, return empty\
    \ list.\n        // If the list is not a list of lists, return empty list.\n \
    \       // If the list is not a list of list of integers, return empty list.\n\
    \        // If the list is not a list of list of longs, return empty list.\n \
    \       // If the list is not a list of list of longs, return empty list.\n  \
    \      // If the list is not a list of list of longs, return empty list.\n   \
    \     // If the list is not a list of list of longs, return empty list.\n    \
    \    // If the list is not a list of list of longs, return empty list.\n     \
    \   // If the list is not a list of list of longs, return empty list.\n      \
    \  // If the list is not a list of list of longs, return empty list.\n       \
    \ // If the list is not a list of list of longs, return empty list.\n        //\
    \ If the list is not a list of list of longs, return empty list.\n        // If\
    \ the list is not a list of list of longs, return empty list.\n        // If the\
    \ list is not a list of list of longs, return empty list.\n        // If the list\
    \ is not a list of list of longs, return empty list.\n        // If the list is\
    \ not a list of list of longs, return empty list.\n        // If the list is not\
    \ a list of list of longs, return", "        // Fill up this function body\n \
    \       // 'lst' is a nested list, which is similar to matrix, however, unlike\
    \ matrices,\n        // each row may contain a different number of columns.\n\
    \        // 'x' is an integer\n        // You have to find integers 'x' in the\
    \ list,\n        // and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    \        // each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \      // Sort coordinates initially by rows in ascending order.\n        // Also,\
    \ sort coordinates of the row by columns in descending order.\n        var result\
    \ : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0\
    \ until lst.length) {\n            for (j <- 0 until lst(i).length) {\n      \
    \          if (lst(i)(j) == x) {\n                    result = result :+ (i.toLong,\
    \ j.toLong)\n                }\n            }\n        }\n        result.sortWith(_._1\
    \ < _._1).sortWith(_._2 > _._2)", "        var result : List[Tuple2[Long, Long]]\
    \ = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n    \
    \        for (j <- 0 until lst(i).length) {\n                if (lst(i)(j) ==\
    \ x) {\n                    result = (i, j) :: result\n                }\n   \
    \         }\n        }\n        result.sortWith((a, b) => a._1 < b._1 || (a._1\
    \ == b._1 && a._2 > b._2))", "        var result : List[Tuple2[Long, Long]] =\
    \ List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n      \
    \      for (j <- 0 until lst(i).length) {\n                if (lst(i)(j) == x)\
    \ {\n                    result = result :+ (i.toLong, j.toLong)\n           \
    \     }\n            }\n        }\n        result.sortWith((a, b) => {\n     \
    \       if (a._1 < b._1) {\n                true\n            } else if (a._1\
    \ == b._1) {\n                a._2 > b._2\n            } else {\n            \
    \    false\n            }\n        })", "        // Fill up this function body\n\
    \        // 'lst' is a nested list, which is similar to matrix,\n        // however,\
    \ unlike matrices, each row may contain a different number of columns.\n     \
    \   // 'x' is an integer to be searched in the list.\n        // Return a list\
    \ of tuples, [(x1, y1), (x2, y2) ...] such that\n        // each tuple is a coordinate\
    \ - (row, columns), starting with 0.\n        // Sort coordinates initially by\
    \ rows in ascending order.\n        // Also, sort coordinates of the row by columns\
    \ in descending order.\n        var result = List[Tuple2[Long, Long]]()\n    \
    \    for (i <- 0 until lst.length) {\n            for (j <- 0 until lst(i).length)\
    \ {\n                if (lst(i)(j) == x) {\n                    result = result\
    \ :+ (i.toLong, j.toLong)\n                }\n            }\n        }\n     \
    \   result.sortWith((a, b) => {\n            if (a._1 < b._1) true\n         \
    \   else if (a._1 == b._1) a._2 > b._2\n            else false\n        })", " \
    \       var result : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n \
    \       for (i <- 0 until lst.length) {\n            for (j <- 0 until lst(i).length)\
    \ {\n                if (lst(i)(j) == x) {\n                    result = result\
    \ :+ (i.toLong, j.toLong)\n                }\n            }\n        }\n     \
    \   result.sortWith((a, b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))",
  "        var result : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n  \
    \      for (i <- 0 until lst.length) {\n            for (j <- 0 until lst(i).length)\
    \ {\n                if (lst(i)(j) == x) {\n                    result = (i, j)\
    \ :: result\n                }\n            }\n        }\n        result.sortWith((a,\
    \ b) => (a._1 < b._1) || (a._1 == b._1 && a._2 > b._2))", "        var result\
    \ : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0\
    \ until lst.length) {\n            for (j <- 0 until lst(i).length) {\n      \
    \          if (lst(i)(j) == x) {\n                    result = result :+ (i.toLong,\
    \ j.toLong)\n                }\n            }\n        }\n        result.sortWith((a,\
    \ b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))", "        var lst2 = List[Tuple2[Long,\
    \ Long]]()\n        for (i <- 0 until lst.length) {\n            for (j <- 0 until\
    \ lst(i).length) {\n                if (lst(i)(j) == x) {\n                  \
    \  lst2 = (i.toLong, j.toLong) :: lst2\n                }\n            }\n   \
    \     }\n        lst2.sortWith((t1, t2) => {\n            if (t1._1 < t2._1) true\n\
    \            else if (t1._1 == t2._1) t1._2 > t2._2\n            else false\n\
    \        })", "        var result : List[Tuple2[Long, Long]] = List[Tuple2[Long,\
    \ Long]]()\n        for (i <- 0 until lst.length) {\n            for (j <- 0 until\
    \ lst(i).length) {\n                if (lst(i)(j) == x) {\n                  \
    \  result = result :+ (i.toLong, j.toLong)\n                }\n            }\n\
    \        }\n        result.sortWith((a, b) => a._1 < b._1 || (a._1 == b._1 &&\
    \ a._2 > b._2))", "        // Fill up this function body\n        // 'lst' is\
    \ a list of lists, each list is a row\n        // 'x' is the number to be searched\
    \ for\n        // return a list of tuples, each tuple is a coordinate (row, column)\n\
    \        // sort the coordinates initially by rows in ascending order\n      \
    \  // also, sort coordinates of the row by columns in descending order\n     \
    \   // if 'x' is not found, return an empty list\n        // if 'lst' is empty,\
    \ return an empty list\n        // if 'lst' is not a list of lists, return an\
    \ empty list\n        // if 'x' is not a number, return an empty list\n      \
    \  // if 'lst' contains an empty list, return an empty list\n        // if 'lst'\
    \ contains a list with non-numbers, return an empty list\n        // if 'lst'\
    \ contains a list with non-integers, return an empty list\n        // if 'lst'\
    \ contains a list with negative integers, return an empty list\n        // if\
    \ 'lst' contains a list with integers greater than 2^31 - 1, return an empty list\n\
    \        // if 'lst' contains a list with integers less than -2^31, return an\
    \ empty list\n        // if 'lst' contains a list with integers greater than 2^63\
    \ - 1, return an empty list\n        // if 'lst' contains a list with integers\
    \ less than -2^63, return an empty list\n        // if 'lst' contains a list with\
    \ integers greater than 2^127 - 1, return an empty list\n        // if 'lst' contains\
    \ a list with integers less than -2^127, return an empty list\n        // if 'lst'\
    \ contains a list with integers greater than 2^255 - 1, return an empty list\n\
    \        // if 'lst' contains a list with integers less than -2^255, return an\
    \ empty list\n        // if 'lst' contains a list with integers greater than 2^511\
    \ - 1, return an empty list\n        // if 'lst' contains a list with integers\
    \ less than -2^511, return an empty list\n        // if 'lst' contains a list\
    \ with integers greater than 2^1023 - 1, return an empty list\n        // if 'lst'\
    \ contains a list with", "        // Fill up this function body\n        // 'lst'\
    \ is a nested list, similar to matrix, but each row may contain a different number\
    \ of columns.\n        // 'x' is an integer to be searched in the list.\n    \
    \    // Return a list of tuples, [(x1, y1), (x2, y2) ...] such that\n        //\
    \ each tuple is a coordinate - (row, columns), starting with 0.\n        // Sort\
    \ coordinates initially by rows in ascending order.\n        // Also, sort coordinates\
    \ of the row by columns in descending order.\n        // If x is not found in\
    \ the list, return an empty list.\n        // If the list is empty, return an\
    \ empty list.\n        var result = List[Tuple2[Long, Long]]()\n        for (i\
    \ <- 0 until lst.length) {\n            for (j <- 0 until lst(i).length) {\n \
    \               if (lst(i)(j) == x) {\n                    result = result :+\
    \ (i.toLong, j.toLong)\n                }\n            }\n        }\n        result.sortWith((a,\
    \ b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))", "        var result :\
    \ List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until\
    \ lst.length) {\n            for (j <- 0 until lst(i).length) {\n            \
    \    if (lst(i)(j) == x) {\n                    result = result :+ (i.toLong,\
    \ j.toLong)\n                }\n            }\n        }\n        result.sortWith((a,\
    \ b) => {\n            if (a._1 < b._1) {\n                true\n            }\
    \ else if (a._1 == b._1) {\n                a._2 > b._2\n            } else {\n\
    \                false\n            }\n        })", "        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => {\n\
    \            if (a._1 == b._1) {\n                a._2 > b._2\n            } else\
    \ {\n                a._1 < b._1\n            }\n        })", "        // Fill\
    \ up this function body\n        // 'lst' is a list of lists, where each list\
    \ is a row of a matrix\n        // 'x' is the element to be searched in the matrix\n\
    \        // Return a list of tuples, each tuple is a coordinate of the element\n\
    \        // Sort the list of tuples initially by rows in ascending order\n   \
    \     // Also, sort coordinates of the row by columns in descending order\n  \
    \      // If the element is not found, return an empty list\n        // If the\
    \ list is empty, return an empty list\n        var result = List[Tuple2[Long,\
    \ Long]]()\n        var row = 0\n        for (i <- lst) {\n            var col\
    \ = 0\n            for (j <- i) {\n                if (j == x) {\n           \
    \         result = result :+ (row, col)\n                }\n                col\
    \ += 1\n            }\n            row += 1\n        }\n        result.sortBy(x\
    \ => (x._1, -x._2))", "        var result : List[Tuple2[Long, Long]] = List[Tuple2[Long,\
    \ Long]]()\n        for (i <- 0 until lst.length) {\n            for (j <- 0 until\
    \ lst(i).length) {\n                if (lst(i)(j) == x) {\n                  \
    \  result = result :+ (i.toLong, j.toLong)\n                }\n            }\n\
    \        }\n        result.sortWith((a, b) => {\n            if (a._1 < b._1)\
    \ {\n                true\n            } else if (a._1 == b._1) {\n          \
    \      a._2 > b._2\n            } else {\n                false\n            }\n\
    \        })", "        // Fill up this function body\n        // 'lst' is a nested\
    \ list, similar to matrix, but unlike matrix,\n        // each row may contain\
    \ a different number of columns.\n        // 'x' is an integer.\n        // Return\
    \ a list of tuples, [(x1, y1), (x2, y2) ...] such that\n        // each tuple\
    \ is a coordinate - (row, columns), starting with 0.\n        // Sort coordinates\
    \ initially by rows in ascending order.\n        // Also, sort coordinates of\
    \ the row by columns in descending order.\n        // If x is not found, return\
    \ empty list.\n        // If lst is empty, return empty list.\n        // Note:\
    \ You can use built-in sort function.\n        // Note: You can use built-in zipWithIndex\
    \ function.\n        // Note: You can use built-in flatten function.\n       \
    \ // Note: You can use built-in map function.\n        // Note: You can use built-in\
    \ filter function.\n        // Note: You can use built-in reverse function.\n\
    \        // Note: You can use built-in toList function.\n        // Note: You\
    \ can use built-in sortWith function.\n        // Note: You can use built-in groupBy\
    \ function.\n        // Note: You can use built-in toList function.\n        //\
    \ Note: You can use built-in sortWith function.\n        // Note: You can use\
    \ built-in sortWith function.\n        // Note: You can use built-in sortWith\
    \ function.\n        // Note: You can use built-in sortWith function.\n      \
    \  // Note: You can use built-in sortWith function.\n        // Note: You can\
    \ use built-in sortWith function.\n        // Note: You can use built-in sortWith\
    \ function.\n        // Note: You can use built-in sortWith function.\n      \
    \  // Note: You can use built-in sortWith function.\n        // Note: You can\
    \ use built-in sortWith function.\n        // Note: You can use built-in sortWith\
    \ function.\n        // Note: You can use built-in sortWith function.\n      \
    \  // Note: You can use built-in sortWith function.\n        // Note: You can\
    \ use built-in sortWith function.\n        // Note", "        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = (i, j) :: result\n                }\n\
    \            }\n        }\n        result.sortWith((a, b) => {\n            if\
    \ (a._1 == b._1) {\n                a._2 > b._2\n            } else {\n      \
    \          a._1 < b._1\n            }\n        })", "        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => (a._1\
    \ < b._1) || (a._1 == b._1 && a._2 > b._2))", "        // Fill up this function\
    \ body\n        // 'lst' is a nested list, which is similar to matrix, however,\
    \ unlike matrices,\n        // each row may contain a different number of columns.\n\
    \        // 'x' is an integer.\n        // You have to find integers 'x' in the\
    \ list,\n        // and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    \        // each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \      // Sort coordinates initially by rows in ascending order.\n        // Also,\
    \ sort coordinates of the row by columns in descending order.\n        var result\
    \ = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n    \
    \        for (j <- 0 until lst(i).length) {\n                if (lst(i)(j) ==\
    \ x) {\n                    result = (i.toLong, j.toLong) :: result\n        \
    \        }\n            }\n        }\n        result.sortWith((a, b) => if (a._1\
    \ == b._1) a._2 > b._2 else a._1 < b._1)", "        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = (i, j) :: result\n                }\n\
    \            }\n        }\n        result.sortWith((a, b) => a._1 < b._1 || (a._1\
    \ == b._1 && a._2 > b._2))", "        var result : List[Tuple2[Long, Long]] =\
    \ List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n      \
    \      for (j <- 0 until lst(i).length) {\n                if (lst(i)(j) == x)\
    \ {\n                    result = result :+ (i.toLong, j.toLong)\n           \
    \     }\n            }\n        }\n        result.sortWith((a, b) => a._1 < b._1\
    \ || (a._1 == b._1 && a._2 > b._2))", "        // Fill up this function body\n\
    \        // `lst` is a nested list, which is similar to matrix,\n        // however,\
    \ unlike matrices, each row may contain a different number of columns.\n     \
    \   // `x` is an integer, which you need to find in the list.\n        // Return\
    \ list of tuples, [(x1, y1), (x2, y2) ...] such that\n        // each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n        // Sort coordinates\
    \ initially by rows in ascending order.\n        // Also, sort coordinates of\
    \ the row by columns in descending order.\n        // If `x` is not found in the\
    \ list, return empty list.\n        // If `lst` is empty, return empty list.\n\
    \        // If `lst` is a list of empty lists, return empty list.\n        //\
    \ If `lst` is a list of empty lists, except one list,\n        // and `x` is not\
    \ found in that list, return empty list.\n        // If `lst` is a list of empty\
    \ lists, except one list,\n        // and `x` is found in that list, return list\
    \ of tuples,\n        // [(0, 0), (0, 1), ...] such that each tuple is a coordinate\
    \ - (row, columns),\n        // starting with 0.\n        // Sort coordinates\
    \ initially by rows in ascending order.\n        // Also, sort coordinates of\
    \ the row by columns in descending order.\n        // If `x` is found in the list,\
    \ return list of tuples,\n        // [(x1, y1), (x2, y2) ...] such that each tuple\
    \ is a coordinate - (row, columns),\n        // starting with 0.\n        // Sort\
    \ coordinates initially by rows in ascending order.\n        // Also, sort coordinates\
    \ of the row by columns in descending order.\n        // If `x` is not found in\
    \ the list, return empty list.\n        // If `lst` is empty, return empty list.\n\
    \        // If `lst` is a list of empty lists, return empty list.\n        //\
    \ If `lst` is a list of empty lists, except one list,\n        // and `x` is not\
    \ found in that list, return empty list.\n        // If `lst` is a", "       \
    \ // Write your code here\n        val result = ListBuffer[Tuple2[Long, Long]]()\n\
    \        for (i <- 0 until lst.length) {\n            for (j <- 0 until lst(i).length)\
    \ {\n                if (lst(i)(j) == x) {\n                    result += Tuple2(i.toLong,\
    \ j.toLong)\n                }\n            }\n        }\n        result.toList.sortWith((a,\
    \ b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))", "        var result :\
    \ List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until\
    \ lst.length) {\n            for (j <- 0 until lst(i).length) {\n            \
    \    if (lst(i)(j) == x) {\n                    result = result :+ (i.toLong,\
    \ j.toLong)\n                }\n            }\n        }\n        result.sortWith((a,\
    \ b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))", "        var result :\
    \ List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until\
    \ lst.length) {\n            for (j <- 0 until lst(i).length) {\n            \
    \    if (lst(i)(j) == x) {\n                    result = result :+ (i.toLong,\
    \ j.toLong)\n                }\n            }\n        }\n        result.sortWith((a,\
    \ b) => {\n            if (a._1 == b._1) {\n                a._2 > b._2\n    \
    \        } else {\n                a._1 < b._1\n            }\n        })", " \
    \       // Fill up this function body\n        // 'lst' is a list of lists, each\
    \ list is a row\n        // 'x' is the number to be searched in the list\n   \
    \     // Return a list of tuples, each tuple is a coordinate - (row, columns)\n\
    \        // Sort coordinates initially by rows in ascending order.\n        //\
    \ Also, sort coordinates of the row by columns in descending order.\n        var\
    \ result = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => (a._1\
    \ < b._1) || (a._1 == b._1 && a._2 > b._2))", "        var result : List[Tuple2[Long,\
    \ Long]] = List()\n        for (i <- 0 until lst.length) {\n            for (j\
    \ <- 0 until lst(i).length) {\n                if (lst(i)(j) == x) {\n       \
    \             result = result :+ (i.toLong, j.toLong)\n                }\n   \
    \         }\n        }\n        result.sortWith((a, b) => a._1 < b._1 || (a._1\
    \ == b._1 && a._2 > b._2))", "        var result : List[Tuple2[Long, Long]] =\
    \ List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n      \
    \      for (j <- 0 until lst(i).length) {\n                if (lst(i)(j) == x)\
    \ {\n                    result = result :+ (i.toLong, j.toLong)\n           \
    \     }\n            }\n        }\n        result.sortWith((a, b) => {\n     \
    \       if (a._1 < b._1) {\n                true\n            } else if (a._1\
    \ == b._1) {\n                a._2 > b._2\n            } else {\n            \
    \    false\n            }\n        })", "        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => {\n\
    \            if (a._1 < b._1) {\n                true\n            } else if (a._1\
    \ == b._1) {\n                a._2 > b._2\n            } else {\n            \
    \    false\n            }\n        })", "        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => {\n\
    \            if (a._1 == b._1) {\n                a._2 > b._2\n            } else\
    \ {\n                a._1 < b._1\n            }\n        })", "        var result\
    \ : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0\
    \ until lst.length) {\n            for (j <- 0 until lst(i).length) {\n      \
    \          if (lst(i)(j) == x) {\n                    result = result :+ (i.toLong,\
    \ j.toLong)\n                }\n            }\n        }\n        result.sortWith((a,\
    \ b) => {\n            if (a._1 == b._1) {\n                a._2 > b._2\n    \
    \        } else {\n                a._1 < b._1\n            }\n        })", " \
    \       var result : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n \
    \       for (i <- 0 until lst.length) {\n            for (j <- 0 until lst(i).length)\
    \ {\n                if (lst(i)(j) == x) {\n                    result = result\
    \ :+ (i.toLong, j.toLong)\n                }\n            }\n        }\n     \
    \   result.sortWith((a, b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))",
  "        var result : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n  \
    \      for (i <- 0 until lst.length) {\n            for (j <- 0 until lst(i).length)\
    \ {\n                if (lst(i)(j) == x) {\n                    result = result\
    \ :+ (i.toLong, j.toLong)\n                }\n            }\n        }\n     \
    \   result.sortWith((a, b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))",
  "        val result = ListBuffer[Tuple2[Long, Long]]()\n        for (i <- 0 until\
    \ lst.length) {\n            val row = lst(i)\n            for (j <- 0 until row.length)\
    \ {\n                if (row(j) == x) {\n                    result += Tuple2(i.toLong,\
    \ j.toLong)\n                }\n            }\n        }\n        result.toList.sortWith((a,\
    \ b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))", "        var result :\
    \ List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until\
    \ lst.length) {\n            for (j <- 0 until lst(i).length) {\n            \
    \    if (lst(i)(j) == x) {\n                    result = (i, j) :: result\n  \
    \              }\n            }\n        }\n        result.sortWith((a, b) =>\
    \ a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))", "        // Fill up this function\
    \ body\n        // 'lst' is a nested list, which is similar to matrix,\n     \
    \   // however, unlike matrices, each row may contain a different number of columns.\n\
    \        // 'x' is an integer.\n        // You have to find integers 'x' in the\
    \ list,\n        // and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    \        // each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \      // Sort coordinates initially by rows in ascending order.\n        // Also,\
    \ sort coordinates of the row by columns in descending order.\n        val result\
    \ = new ListBuffer[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length)\
    \ {\n            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result += Tuple2(i.toLong, j.toLong)\n        \
    \        }\n            }\n        }\n        result.toList.sortWith((a, b) =>\
    \ a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))", "        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => {\n\
    \            if (a._1 < b._1) {\n                true\n            } else if (a._1\
    \ == b._1) {\n                a._2 > b._2\n            } else {\n            \
    \    false\n            }\n        })", "        // Fill up this function body\n\
    \        // 'lst' is a nested list, which is similar to matrix, however, unlike\
    \ matrices,\n        // each row may contain a different number of columns.\n\
    \        // 'x' is an integer\n        // You have to return a list of tuples,\
    \ [(x1, y1), (x2, y2) ...] such that\n        // each tuple is a coordinate -\
    \ (row, columns), starting with 0.\n        // Sort coordinates initially by rows\
    \ in ascending order.\n        // Also, sort coordinates of the row by columns\
    \ in descending order.\n        var result : List[Tuple2[Long, Long]] = List()\n\
    \        for (i <- 0 to lst.length - 1) {\n            for (j <- 0 to lst(i).length\
    \ - 1) {\n                if (lst(i)(j) == x) {\n                    result =\
    \ result :+ (i.toLong, j.toLong)\n                }\n            }\n        }\n\
    \        result.sortWith((a, b) => {\n            if (a._1 == b._1) {\n      \
    \          a._2 > b._2\n            } else {\n                a._1 < b._1\n  \
    \          }\n        })", "        var result : List[Tuple2[Long, Long]] = List[Tuple2[Long,\
    \ Long]]()\n        for (i <- 0 until lst.length) {\n            for (j <- 0 until\
    \ lst(i).length) {\n                if (lst(i)(j) == x) {\n                  \
    \  result = result :+ (i.toLong, j.toLong)\n                }\n            }\n\
    \        }\n        result.sortWith((a, b) => {\n            if (a._1 < b._1)\
    \ {\n                true\n            } else if (a._1 == b._1) {\n          \
    \      a._2 > b._2\n            } else {\n                false\n            }\n\
    \        })", "        var result : List[Tuple2[Long, Long]] = List[Tuple2[Long,\
    \ Long]]()\n        for (i <- 0 until lst.length) {\n            for (j <- 0 until\
    \ lst(i).length) {\n                if (lst(i)(j) == x) {\n                  \
    \  result = result :+ (i.toLong, j.toLong)\n                }\n            }\n\
    \        }\n        result.sortWith((x, y) => x._1 < y._1 || (x._1 == y._1 &&\
    \ x._2 > y._2))", "        // Fill up this function body\n        // 'lst' is\
    \ a nested list, which is similar to matrix, however, unlike matrices,\n     \
    \   // each row may contain a different number of columns.\n        // 'x' is\
    \ an integer to be found in the list.\n        // You have to return a list of\
    \ tuples, [(x1, y1), (x2, y2) ...] such that\n        // each tuple is a coordinate\
    \ - (row, columns), starting with 0.\n        // Sort coordinates initially by\
    \ rows in ascending order.\n        // Also, sort coordinates of the row by columns\
    \ in descending order.\n        var result = List[Tuple2[Long, Long]]()\n    \
    \    for (i <- 0 until lst.length) {\n            for (j <- 0 until lst(i).length)\
    \ {\n                if (lst(i)(j) == x) {\n                    result = result\
    \ :+ (i.toLong, j.toLong)\n                }\n            }\n        }\n     \
    \   result.sortWith((a, b) => {\n            if (a._1 < b._1) {\n            \
    \    true\n            } else if (a._1 == b._1) {\n                a._2 > b._2\n\
    \            } else {\n                false\n            }\n        })", "  \
    \      var result : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n  \
    \      for (i <- 0 until lst.length) {\n            for (j <- 0 until lst(i).length)\
    \ {\n                if (lst(i)(j) == x) {\n                    result = result\
    \ :+ (i.toLong, j.toLong)\n                }\n            }\n        }\n     \
    \   result.sortWith((a, b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))",
  "        var result : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n  \
    \      for (i <- 0 until lst.length) {\n            var row = lst(i)\n       \
    \     for (j <- 0 until row.length) {\n                if (row(j) == x) {\n  \
    \                  result = result :+ (i.toLong, j.toLong)\n                }\n\
    \            }\n        }\n        result.sortWith((a, b) => {\n            if\
    \ (a._1 < b._1) {\n                true\n            } else if (a._1 == b._1)\
    \ {\n                a._2 > b._2\n            } else {\n                false\n\
    \            }\n        })", "        // Fill up this function body\n        //\
    \ 'lst' is a nested list, similar to matrix,\n        // 'x' is the integer to\
    \ be searched in the list\n        // Return list of tuples, [(x1, y1), (x2, y2)\
    \ ...] such that\n        // each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n        // Sort coordinates initially by rows in ascending order.\n\
    \        // Also, sort coordinates of the row by columns in descending order.\n\
    \        var result = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length)\
    \ {\n            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => a._1\
    \ < b._1 || (a._1 == b._1 && a._2 > b._2))", "        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = (i, j) :: result\n                }\n\
    \            }\n        }\n        result.sortWith((a, b) => if (a._1 == b._1)\
    \ a._2 > b._2 else a._1 < b._1)", "        var result : List[Tuple2[Long, Long]]\
    \ = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n    \
    \        for (j <- 0 until lst(i).length) {\n                if (lst(i)(j) ==\
    \ x) {\n                    result = result :+ (i.toLong, j.toLong)\n        \
    \        }\n            }\n        }\n        result.sortWith((a, b) => {\n  \
    \          if (a._1 != b._1) {\n                a._1 < b._1\n            } else\
    \ {\n                a._2 > b._2\n            }\n        })", "        var result\
    \ : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0\
    \ until lst.length) {\n            for (j <- 0 until lst(i).length) {\n      \
    \          if (lst(i)(j) == x) {\n                    result = (i, j) :: result\n\
    \                }\n            }\n        }\n        result.sortWith((a, b) =>\
    \ (a._1 < b._1) || (a._1 == b._1 && a._2 > b._2))", "        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            var row : List[Long] = lst(i)\n            for (j <- 0 until row.length)\
    \ {\n                if (row(j) == x) {\n                    result = result :+\
    \ (i.toLong, j.toLong)\n                }\n            }\n        }\n        result.sortWith((a,\
    \ b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))", "        var result :\
    \ List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until\
    \ lst.length) {\n            for (j <- 0 until lst(i).length) {\n            \
    \    if (lst(i)(j) == x) {\n                    result = result :+ Tuple2(i.toLong,\
    \ j.toLong)\n                }\n            }\n        }\n        result.sortWith((a,\
    \ b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))", "        // Fill up this\
    \ function body\n        // 'lst' is a nested list, similar to matrix,\n     \
    \   // 'x' is the integer to be searched in the list\n        // Return a list\
    \ of tuples, [(x1, y1), (x2, y2) ...]\n        // such that each tuple is a coordinate\
    \ - (row, columns),\n        // starting with 0.\n        // Sort coordinates\
    \ initially by rows in ascending order.\n        // Also, sort coordinates of\
    \ the row by columns in descending order.\n        // If x is not found in the\
    \ list, return empty list.\n        // If list is empty, return empty list.\n\
    \        // If list is None, return empty list.\n        // If list is not a nested\
    \ list, return empty list.\n        // If list is not a list of lists, return\
    \ empty list.\n        // If list is not a list of lists of integers, return empty\
    \ list.\n        // If list is not a list of lists of longs, return empty list.\n\
    \        // If list is not a list of lists of longs, return empty list.\n    \
    \    // If list is not a list of lists of longs, return empty list.\n        //\
    \ If list is not a list of lists of longs, return empty list.\n        // If list\
    \ is not a list of lists of longs, return empty list.\n        // If list is not\
    \ a list of lists of longs, return empty list.\n        // If list is not a list\
    \ of lists of longs, return empty list.\n        // If list is not a list of lists\
    \ of longs, return empty list.\n        // If list is not a list of lists of longs,\
    \ return empty list.\n        // If list is not a list of lists of longs, return\
    \ empty list.\n        // If list is not a list of lists of longs, return empty\
    \ list.\n        // If list is not a list of lists of longs, return empty list.\n\
    \        // If list is not a list of lists of longs, return empty list.\n    \
    \    // If list is not a list of lists of longs, return empty list.\n        //\
    \ If list is not a list of lists of longs, return empty list.\n        // If list\
    \ is not a list of lists of longs, return empty list.\n        //", "        //\
    \ Fill up this function body\n        // 'lst' is a nested list, similar to matrix,\
    \ however, unlike matrices,\n        // each row may contain a different number\
    \ of columns.\n        // 'x' is an integer which you need to find in the list.\n\
    \        // Return list of tuples, [(x1, y1), (x2, y2) ...] such that\n      \
    \  // each tuple is a coordinate - (row, columns), starting with 0.\n        //\
    \ Sort coordinates initially by rows in ascending order.\n        // Also, sort\
    \ coordinates of the row by columns in descending order.\n        var result =\
    \ List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n      \
    \      for (j <- 0 until lst(i).length) {\n                if (lst(i)(j) == x)\
    \ {\n                    result = (i, j) :: result\n                }\n      \
    \      }\n        }\n        result.sortWith((a, b) => {\n            if (a._1\
    \ == b._1) {\n                a._2 > b._2\n            } else {\n            \
    \    a._1 < b._1\n            }\n        })", "        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => (a._1\
    \ < b._1) || (a._1 == b._1 && a._2 > b._2))", "        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => a._1\
    \ < b._1 || (a._1 == b._1 && a._2 > b._2))", "        // Fill up this function\
    \ body\n        // `lst` is a 2 dimensional list, similar to matrix,\n       \
    \ // but each row may contain a different number of columns.\n        // `x` is\
    \ an integer to be found in the list.\n        // Return list of tuples, [(x1,\
    \ y1), (x2, y2) ...] such that\n        // each tuple is a coordinate - (row,\
    \ columns), starting with 0.\n        // Sort coordinates initially by rows in\
    \ ascending order.\n        // Also, sort coordinates of the row by columns in\
    \ descending order.\n        // If `x` is not found, return empty list.\n    \
    \    // If `lst` is empty, return empty list.\n        // If `lst` is None, return\
    \ empty list.\n        var result : List[Tuple2[Long, Long]] = List[Tuple2[Long,\
    \ Long]]()\n        if (lst == null) {\n            return result\n        }\n\
    \        for (i <- 0 until lst.length) {\n            for (j <- 0 until lst(i).length)\
    \ {\n                if (lst(i)(j) == x) {\n                    result = result\
    \ :+ (i.toLong, j.toLong)\n                }\n            }\n        }\n     \
    \   result = result.sortWith((a, b) => a._1 < b._1 || (a._1 == b._1 && a._2 >\
    \ b._2))\n        return result", "        // Fill up this function body\n   \
    \     // 'lst' is a nested list of integers\n        // 'x' is an integer\n  \
    \      // Return a list of tuples, each tuple is a coordinate - (row, columns),\n\
    \        // starting with 0.\n        // Sort coordinates initially by rows in\
    \ ascending order.\n        // Also, sort coordinates of the row by columns in\
    \ descending order.\n        var result : List[Tuple2[Long, Long]] = List[Tuple2[Long,\
    \ Long]]()\n        for (i <- 0 to lst.length - 1) {\n            for (j <- 0\
    \ to lst(i).length - 1) {\n                if (lst(i)(j) == x) {\n           \
    \         result = result :+ (i.toLong, j.toLong)\n                }\n       \
    \     }\n        }\n        result.sortWith((a, b) => {\n            if (a._1\
    \ == b._1) {\n                a._2 > b._2\n            } else {\n            \
    \    a._1 < b._1\n            }\n        })", "        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => (a._1\
    \ < b._1) || (a._1 == b._1 && a._2 > b._2))", '        val row = lst.zipWithIndex.map(x
    => x._1.zipWithIndex.map(y => (x._2, y._2))).flatten.filter(x => x._2 == x._2).filter(x
    => x._1 == x._1).filter(x => x._2 == x._2).filter(x => x._1 == x._1).filter(x
    => x._2 == x._2).filter(x => x._1 == x._1).filter(x => x._2 == x._2).filter(x
    => x._1 == x._1).filter(x => x._2 == x._2).filter(x => x._1 == x._1).filter(x
    => x._2 == x._2).filter(x => x._1 == x._1).filter(x => x._2 == x._2).filter(x
    => x._1 == x._1).filter(x => x._2 == x._2).filter(x => x._1 == x._1).filter(x
    => x._2 == x._2).filter(x => x._1 == x._1).filter(x => x._2 == x._2).filter(x
    => x._1 == x._1).filter(x => x._2 == x._2).filter(x => x._1 == x._1).filter(x
    => x._2 == x._2).filter(x => x._1 == x._1).filter(x => x._2 == x._2).filter(x
    => x._1 == x._1).filter(x => x._2 == x._2).filter(x => x._1 == x._1).filter(x
    => x._2 == x._2).filter(x => x._1 == x._1).filter(x => x._2 == x._2).filter(x
    => x._1 == x._1).filter(x => x._2 == x._2).filter(x => x._1 == x._1).filter(x
    => x._2 == x._2).filter(x => x._1 == x._1).filter(x => x._2 == x._2).filter(x
    => x._1 == x._1).filter(x => x._2 == x._2).filter(x', "        // Fill up this\
    \ function body\n        // 'lst' is a nested list, similar to matrix,\n     \
    \   // 'x' is the integer to be searched in the list\n        // Return the list\
    \ of tuples, [(x1, y1), (x2, y2) ...] such that\n        // each tuple is a coordinate\
    \ - (row, columns), starting with 0.\n        // Sort coordinates initially by\
    \ rows in ascending order.\n        // Also, sort coordinates of the row by columns\
    \ in descending order.\n        // If x is not found in the list, return empty\
    \ list.\n        // If lst is empty, return empty list.\n        // If lst is\
    \ not a nested list, return empty list.\n        // If lst is a nested list, but\
    \ not a list of lists, return empty list.\n        // If lst is a list of lists,\
    \ but any of the lists is not a list,\n        // return empty list.\n       \
    \ // If lst is a list of lists, but any of the lists is not a list of\n      \
    \  // integers, return empty list.\n        // If lst is a list of lists, but\
    \ any of the lists is a list of\n        // integers, but any of the integers\
    \ is not a Long, return empty list.\n        // If lst is a list of lists, but\
    \ any of the lists is a list of\n        // integers, but any of the integers\
    \ is not a Long, return empty list.\n        // If lst is a list of lists, but\
    \ any of the lists is a list of\n        // integers, but any of the integers\
    \ is not a Long, return empty list.\n        // If lst is a list of lists, but\
    \ any of the lists is a list of\n        // integers, but any of the integers\
    \ is not a Long, return empty list.\n        // If lst is a list of lists, but\
    \ any of the lists is a list of\n        // integers, but any of the integers\
    \ is not a Long, return empty list.\n        // If lst is a list of lists, but\
    \ any of the lists is a list of\n        // integers, but any of the integers\
    \ is not a Long, return empty list.\n        // If lst is a list of lists, but\
    \ any of the lists is a list of\n        // integers, but any of the integers\
    \ is", "        var result : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n\
    \        for (i <- 0 until lst.length) {\n            for (j <- 0 until lst(i).length)\
    \ {\n                if (lst(i)(j) == x) {\n                    result = result\
    \ :+ (i.toLong, j.toLong)\n                }\n            }\n        }\n     \
    \   result.sortWith((a, b) => {\n            if (a._1 < b._1) {\n            \
    \    true\n            } else if (a._1 == b._1) {\n                a._2 > b._2\n\
    \            } else {\n                false\n            }\n        })"]
stop_tokens:
- "\n    }\n"
