name: HumanEval_161_solve
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // You are given a string s.\n    // if s[i] is a letter, reverse its case\
  \ from lower to upper or vise versa, \n    // otherwise keep it as it is.\n    //\
  \ If the string contains no letters, reverse the string.\n    // The function should\
  \ return the resulted string.\n    // Examples\n    // >>> solve((\"1234\"))\n \
  \   // (\"4321\")\n    // >>> solve((\"ab\"))\n    // (\"AB\")\n    // >>> solve((\"\
  #a@C\"))\n    // (\"#A@c\")\n    def solve(s : String) : String = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(solve((\"AsDf\")).equals((\"\
  aSdF\")));\n    assert(solve((\"1234\")).equals((\"4321\")));\n    assert(solve((\"\
  ab\")).equals((\"AB\")));\n    assert(solve((\"#a@C\")).equals((\"#A@c\")));\n \
  \   assert(solve((\"#AsdfW^45\")).equals((\"#aSDFw^45\")));\n    assert(solve((\"\
  #6@2\")).equals((\"2@6#\")));\n    assert(solve((\"#$a^D\")).equals((\"#$A^d\")));\n\
  \    assert(solve((\"#ccc\")).equals((\"#CCC\")));\n    }\n\n}\n"
completions: ["        val letters = s.filter(c => c.isLetter)\n        if (letters.isEmpty)\
    \ s.reverse\n        else s.map(c => if (c.isLetter) c.toUpper ^ c.toLower else\
    \ c)", "        val letters = s.filter(c => c.isLetter)\n        if (letters.isEmpty)\
    \ s.reverse\n        else letters.map(c => if (c.isUpper) c.toLower else c.toUpper).mkString",
  "        if (s.exists(c => c.isLetter)) {\n            s.map(c => if (c.isLetter)\
    \ c.toUpper ^ c.toLower else c).reverse\n        } else {\n            s.reverse\n\
    \        }", "        if (s.forall(c => !c.isLetter)) s.reverse\n        else\
    \ s.map(c => if (c.isLetter) c.toUpper ^ c.toLower else c)", "        val letters\
    \ = s.filter(_.isLetter)\n        if (letters.isEmpty) s.reverse\n        else\
    \ s.map(c => if (c.isLetter) c.toUpper ^ c.toLower else c)", "        if (s.forall(!_.isLetter))\
    \ s.reverse\n        else s.map(c => if (c.isLetter) c.toLower ^ c.toUpper else\
    \ c)", "        var result = \"\"\n        for (i <- 0 until s.length) {\n   \
    \         if (s(i).isLetter) {\n                if (s(i).isUpper) result += s(i).toLower\n\
    \                else result += s(i).toUpper\n            }\n            else\
    \ result += s(i)\n        }\n        if (result.length == s.length) result\n \
    \       else s.reverse", "        val letters = s.filter(c => c.isLetter)\n  \
    \      if (letters.isEmpty) s.reverse\n        else letters.map(c => if (c.isUpper)\
    \ c.toLower else c.toUpper).mkString", "        if (s.length == 0) return s\n\
    \        var result = \"\"\n        for (i <- 0 until s.length) {\n          \
    \  if (s(i).isLetter) {\n                if (s(i).isUpper) result += s(i).toLower\n\
    \                else result += s(i).toUpper\n            }\n            else\
    \ result += s(i)\n        }\n        result", "        val letters = s.filter(c\
    \ => c.isLetter)\n        if (letters.isEmpty) s.reverse\n        else letters.map(c\
    \ => if (c.isUpper) c.toLower else c.toUpper).mkString", "        val letters\
    \ = s.filter(c => c.isLetter)\n        if (letters.isEmpty) s.reverse\n      \
    \  else letters.map(c => if (c.isUpper) c.toLower else c.toUpper).mkString", " \
    \       val sb = new StringBuilder\n        var flag = true\n        for (c <-\
    \ s) {\n            if (c.isLetter) {\n                if (flag) {\n         \
    \           sb.append(c.toUpper)\n                    flag = false\n         \
    \       } else {\n                    sb.append(c.toLower)\n                 \
    \   flag = true\n                }\n            } else {\n                sb.append(c)\n\
    \            }\n        }\n        if (flag) sb.reverse.toString else sb.toString",
  "        val letters = s.filter(c => c.isLetter)\n        if (letters.isEmpty) s.reverse\n\
    \        else letters.map(c => if (c.isUpper) c.toLower else c.toUpper).mkString",
  "        val sb = new StringBuilder\n        var hasLetter = false\n        for\
    \ (c <- s) {\n            if (c.isLetter) {\n                sb.append(c.toUpper)\n\
    \                hasLetter = true\n            } else {\n                sb.append(c)\n\
    \            }\n        }\n        if (hasLetter) sb.toString\n        else sb.reverse.toString",
  "        var result = \"\"\n        for (c <- s) {\n            if (c.isLetter)\
    \ {\n                if (c.isUpper) result += c.toLower\n                else\
    \ result += c.toUpper\n            }\n            else result += c\n        }\n\
    \        if (result.isEmpty) s.reverse\n        else result", "        val letters\
    \ = s.filter(c => c.isLetter)\n        if (letters.isEmpty) s.reverse\n      \
    \  else letters.map(c => if (c.isUpper) c.toLower else c.toUpper).mkString", " \
    \       // Write your code here\n        var result = \"\"\n        for (c <-\
    \ s) {\n            if (c.isLetter) {\n                if (c.isUpper) {\n    \
    \                result += c.toLower\n                } else {\n             \
    \       result += c.toUpper\n                }\n            } else {\n       \
    \         result += c\n            }\n        }\n        if (result.isEmpty) {\n\
    \            s.reverse\n        } else {\n            result\n        }", "  \
    \      val letters = s.filter(c => c.isLetter)\n        if (letters.length ==\
    \ 0) s.reverse\n        else letters.map(c => if (c.isUpper) c.toLower else c.toUpper)",
  "        val letters = s.filter(c => c.isLetter)\n        if (letters.isEmpty) s.reverse\n\
    \        else letters.map(c => if (c.isUpper) c.toLower else c.toUpper).mkString",
  "        val letters = s.filter(c => c.isLetter)\n        if (letters.isEmpty) s.reverse\n\
    \        else letters.map(c => if (c.isUpper) c.toLower else c.toUpper).mkString"]
stop_tokens:
- "\n    }\n"
