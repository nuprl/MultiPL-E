language: scala
name: HumanEval_41_car_race_collision
results:
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting positions.\n        // Then, we can count the number\
    \ of collisions by counting the number of\n        // cars that start at the same\
    \ position.\n        // The number of collisions is the number of cars that start\
    \ at the same position\n        // times the number of cars that start at the\
    \ same position minus 1.\n        // The reason is that each car that starts at\
    \ the same position can collide with\n        // every other car that starts at\
    \ the same position.\n        // For example, if there are 3 cars that start at\
    \ the same position, then there are\n        // 3 * 2 = 6 collisions.\n      \
    \  // The number of cars that start at the same position is the number of cars\
    \ that start\n        // at the same position minus 1.\n        // For example,\
    \ if there are 3 cars that start at the same position, then there are\n      \
    \  // 3 - 1 = 2 cars that start at the same position.\n        // The reason is\
    \ that the first car that starts at the same position cannot collide with\n  \
    \      // itself.\n        val cars = Array.fill(2 * n.toInt)(0)\n        for\
    \ (i <- 0 until n.toInt) {\n            cars(i) = i\n            cars(i + n.toInt)\
    \ = i\n        }\n        scala.util.Sorting.quickSort(cars)\n        var collisions\
    \ = 0L\n        var i = 0\n        while (i < 2 * n) {\n            var j = i\
    \ + 1\n            while (j < 2 * n && cars(i) == cars(j)) j += 1\n          \
    \  collisions += (j - i) * (j - i - 1) / 2\n            i = j\n        }\n   \
    \     collisions\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpgupt9sxo.scala:45)\n\tat Problem.main(tmpgupt9sxo.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792668
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // Assume that the left-to-right\
    \ cars are indexed from 1 to n, and the right-to-left cars\n        // are indexed\
    \ from n+1 to 2n.  The left-to-right car with index i starts at position i,\n\
    \        // and the right-to-left car with index i starts at position 2n+1-i.\n\
    \        // The left-to-right car with index i will collide with the right-to-left\
    \ car with index\n        // 2n+1-i.  The left-to-right car with index i will\
    \ collide with the right-to-left car with\n        // index 2n+1-i if and only\
    \ if i > n+1-i.  The left-to-right car with index i will collide\n        // with\
    \ the right-to-left car with index 2n+1-i if and only if i > n/2.\n        //\
    \ The left-to-right car with index i will collide with the right-to-left car with\
    \ index\n        // 2n+1-i if and only if i > n/2.  The left-to-right car with\
    \ index i will collide with the\n        // right-to-left car with index 2n+1-i\
    \ if and only if i > n/2.  The left-to-right car with\n        // index i will\
    \ collide with the right-to-left car with index 2n+1-i if and only if i > n/2.\n\
    \        // The left-to-right car with index i will collide with the right-to-left\
    \ car with index\n        // 2n+1-i if and only if i > n/2.  The left-to-right\
    \ car with index i will collide with the\n        // right-to-left car with index\
    \ 2n+1-i if and only if i > n/2.  The left-to-right car with\n        // index\
    \ i will collide with the right-to-left car with index 2n+1-i if and only if i\
    \ > n/2.\n        // The left-to-right car with index i will collide with the\
    \ right-to-left car with index\n        // 2n+1-i if and only if i > n/2.  The\
    \ left-to-right car with index\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp48uska5s.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// Assume that the left-to-right cars are indexed from 1 to n, and the right-to-left\
    \ cars\e[0m\n\e[31m14 |\e[0m        \e[34m// are indexed from n+1 to 2n.  The\
    \ left-to-right car with index i starts at position i,\e[0m\n\e[31m15 |\e[0m \
    \       \e[34m// and the right-to-left car with index i starts at position 2n+1-i.\e\
    [0m\n\e[31m16 |\e[0m        \e[34m// The left-to-right car with index i will collide\
    \ with the right-to-left car with index\e[0m\n\e[31m17 |\e[0m        \e[34m//\
    \ 2n+1-i.  The left-to-right car with index i will collide with the right-to-left\
    \ car with\e[0m\n\e[31m18 |\e[0m        \e[34m// index 2n+1-i if and only if i\
    \ > n+1-i.  The left-to-right car with index i will collide\e[0m\n\e[31m19 |\e\
    [0m        \e[34m// with the right-to-left car with index 2n+1-i if and only if\
    \ i > n/2.\e[0m\n\e[31m20 |\e[0m        \e[34m// The left-to-right car with index\
    \ i will collide with the right-to-left car with index\e[0m\n\e[31m21 |\e[0m \
    \       \e[34m// 2n+1-i if and only if i > n/2.  The left-to-right car with index\
    \ i will collide with the\e[0m\n\e[31m22 |\e[0m        \e[34m// right-to-left\
    \ car with index 2n+1-i if and only if i > n/2.  The left-to-right car with\e\
    [0m\n\e[31m23 |\e[0m        \e[34m// index i will collide with the right-to-left\
    \ car with index 2n+1-i if and only if i > n/2.\e[0m\n\e[31m24 |\e[0m        \e\
    [34m// The left-to-right car with index i will collide with the right-to-left\
    \ car with index\e[0m\n\e[31m25 |\e[0m        \e[34m// 2n+1-i if and only if i\
    \ > n/2.  The left-to-right car with index i will collide with the\e[0m\n\e[31m26\
    \ |\e[0m        \e[34m// right-to-left car with index 2n+1-i if and only if i\
    \ > n/2.  The left-to-rig"
  stdout: ''
  timestamp: 1659792667
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // We can think of the\
    \ cars as points on a number line.\n        // The left-to-right cars are at positions\
    \ 0, 1, 2, ..., n-1.\n        // The right-to-left cars are at positions 0, -1,\
    \ -2, ..., -(n-1).\n        // The number of collisions is the number of pairs\
    \ of points that are the same.\n        // This is the same as the number of pairs\
    \ of points that are the same distance from 0.\n        // This is the same as\
    \ the number of pairs of points that are the same distance from 0.\n        //\
    \ This is the same as the number of pairs of points that are the same distance\
    \ from 0.\n        // This is the same as the number of pairs of points that are\
    \ the same distance from 0.\n        // This is the same as the number of pairs\
    \ of points that are the same distance from 0.\n        // This is the same as\
    \ the number of pairs of points that are the same distance from 0.\n        //\
    \ This is the same as the number of pairs of points that are the same distance\
    \ from 0.\n        // This is the same as the number of pairs of points that are\
    \ the same distance from 0.\n        // This is the same as the number of pairs\
    \ of points that are the same distance from 0.\n        // This is the same as\
    \ the number of pairs of points that are the same distance from 0.\n        //\
    \ This is the same as the number of pairs of points that are the same distance\
    \ from 0.\n        // This is the same as the number of pairs of points that are\
    \ the same distance from 0.\n        // This is the same as the number of pairs\
    \ of points that are the same distance from 0.\n        // This is the same as\
    \ the number of pairs of points that are the same distance from 0.\n        //\
    \ This is the same as the number of pairs of points that are the same distance\
    \ from 0.\n        // This is the same as the number of pairs of points that are\
    \ the same distance from 0.\n        // This is the same as the number of pairs\
    \ of points that are the same distance from 0.\n        // This is the same as\
    \ the number of pairs of points that are the same distance from 0.\n        //\
    \ This is the same as the number of pairs of points that are the same distance\
    \ from 0.\n        // This is\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpfxk7a6af.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// We can think of the cars as points on a number line.\e[0m\n\e[31m14 |\e\
    [0m        \e[34m// The left-to-right cars are at positions 0, 1, 2, ..., n-1.\e\
    [0m\n\e[31m15 |\e[0m        \e[34m// The right-to-left cars are at positions 0,\
    \ -1, -2, ..., -(n-1).\e[0m\n\e[31m16 |\e[0m        \e[34m// The number of collisions\
    \ is the number of pairs of points that are the same.\e[0m\n\e[31m17 |\e[0m  \
    \      \e[34m// This is the same as the number of pairs of points that are the\
    \ same distance from 0.\e[0m\n\e[31m18 |\e[0m        \e[34m// This is the same\
    \ as the number of pairs of points that are the same distance from 0.\e[0m\n\e\
    [31m19 |\e[0m        \e[34m// This is the same as the number of pairs of points\
    \ that are the same distance from 0.\e[0m\n\e[31m20 |\e[0m        \e[34m// This\
    \ is the same as the number of pairs of points that are the same distance from\
    \ 0.\e[0m\n\e[31m21 |\e[0m        \e[34m// This is the same as the number of pairs\
    \ of points that are the same distance from 0.\e[0m\n\e[31m22 |\e[0m        \e\
    [34m// This is the same as the number of pairs of points that are the same distance\
    \ from 0.\e[0m\n\e[31m23 |\e[0m        \e[34m// This is the same as the number\
    \ of pairs of points that are the same distance from 0.\e[0m\n\e[31m24 |\e[0m\
    \        \e[34m// This is the same as the number of pairs of points that are the\
    \ same distance from 0.\e[0m\n\e[31m25 |\e[0m        \e[34m// This is the same\
    \ as the number of pairs of points that are the same distance from 0.\e[0m\n\e\
    [31m26 |\e[0m        \e[34m// This is the same as the number of pairs of points\
    \ that are the same distance from 0.\e[0m\n\e[31m27 |\e[0m        \e[34m// This\
    \ is the same as the number of pairs"
  stdout: ''
  timestamp: 1659792667
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the left-to-right cars by their position, and the right-to-left cars\n     \
    \   // by their position.  Then, we can just iterate through the sorted lists\
    \ and count the number\n        // of collisions.\n        // The time complexity\
    \ is O(n log n).\n        val leftToRight = new Array[Long](n.toInt)\n       \
    \ val rightToLeft = new Array[Long](n.toInt)\n        for (i <- 0 until n.toInt)\
    \ {\n            leftToRight(i) = i\n            rightToLeft(i) = n - i - 1\n\
    \        }\n        scala.util.Sorting.quickSort(leftToRight)\n        scala.util.Sorting.quickSort(rightToLeft)\n\
    \        var count = 0\n        var i = 0\n        var j = 0\n        while (i\
    \ < n.toInt && j < n.toInt) {\n            if (leftToRight(i) < rightToLeft(j))\
    \ {\n                i += 1\n            } else {\n                count += 1\n\
    \                j += 1\n            }\n        }\n        count\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n\
    \    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpa08_nvcs.scala:39)\n\tat Problem.main(tmpa08_nvcs.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792668
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting position.\n        // Then we can easily count the\
    \ number of collisions.\n        // The number of collisions is the number of\
    \ cars that start on the right side\n        // of the road minus the number of\
    \ cars that start on the left side of the road.\n        // This is because the\
    \ cars that start on the right side of the road will collide\n        // with\
    \ the cars that start on the left side of the road.\n        // The cars that\
    \ start on the right side of the road will collide with the cars\n        // that\
    \ start on the right side of the road, but the cars that start on the right\n\
    \        // side of the road will also collide with the cars that start on the\
    \ left side of\n        // the road.\n        // The cars that start on the left\
    \ side of the road will collide with the cars\n        // that start on the left\
    \ side of the road, but the cars that start on the left\n        // side of the\
    \ road will also collide with the cars that start on the right side of\n     \
    \   // the road.\n        // So the cars that start on the right side of the road\
    \ will collide with the cars\n        // that start on the left side of the road,\
    \ but the cars that start on the left side\n        // of the road will also collide\
    \ with the cars that start on the right side of the road.\n        // So the cars\
    \ that start on the right side of the road will collide with the cars\n      \
    \  // that start on the left side of the road, but the cars that start on the\
    \ left side\n        // of the road will also collide with the cars that start\
    \ on the right side of the road.\n        // So the cars that start on the right\
    \ side of the road will collide with the cars\n        // that start on the left\
    \ side of the road, but the cars that start on the left side\n        // of the\
    \ road will also collide with the cars that start on the right side of the road.\n\
    \        // So the cars that start on the right side of the road will collide\
    \ with the cars\n        // that start on the left side of the road, but the cars\
    \ that start on the left side\n        // of the road will also collide with the\
    \ cars that start on the right side of the road.\n        // So the cars that\
    \ start on the right side of the road will collide with the cars\n       \n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7va8ydze.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// The idea is to sort the cars by their starting position.\e[0m\n\e[31m14\
    \ |\e[0m        \e[34m// Then we can easily count the number of collisions.\e\
    [0m\n\e[31m15 |\e[0m        \e[34m// The number of collisions is the number of\
    \ cars that start on the right side\e[0m\n\e[31m16 |\e[0m        \e[34m// of the\
    \ road minus the number of cars that start on the left side of the road.\e[0m\n\
    \e[31m17 |\e[0m        \e[34m// This is because the cars that start on the right\
    \ side of the road will collide\e[0m\n\e[31m18 |\e[0m        \e[34m// with the\
    \ cars that start on the left side of the road.\e[0m\n\e[31m19 |\e[0m        \e\
    [34m// The cars that start on the right side of the road will collide with the\
    \ cars\e[0m\n\e[31m20 |\e[0m        \e[34m// that start on the right side of the\
    \ road, but the cars that start on the right\e[0m\n\e[31m21 |\e[0m        \e[34m//\
    \ side of the road will also collide with the cars that start on the left side\
    \ of\e[0m\n\e[31m22 |\e[0m        \e[34m// the road.\e[0m\n\e[31m23 |\e[0m   \
    \     \e[34m// The cars that start on the left side of the road will collide with\
    \ the cars\e[0m\n\e[31m24 |\e[0m        \e[34m// that start on the left side of\
    \ the road, but the cars that start on the left\e[0m\n\e[31m25 |\e[0m        \e\
    [34m// side of the road will also collide with the cars that start on the right\
    \ side of\e[0m\n\e[31m26 |\e[0m        \e[34m// the road.\e[0m\n\e[31m27 |\e[0m\
    \        \e[34m// So the cars that start on the right side of the road will collide\
    \ with the cars\e[0m\n\e[31m28 |\e[0m        \e[34m// that start on the left side\
    \ of the road, but the cars that start on the left side\e[0m\n\e[31m29 |\e[0m\
    \        \e[34m// of the road will also collid"
  stdout: ''
  timestamp: 1659792666
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting position.  Then, we can\n        // use a sweep line\
    \ algorithm to count the number of collisions.\n        // The sweep line algorithm\
    \ is as follows:\n        // We start at the leftmost car.  We move the sweep\
    \ line to the right,\n        // and we count the number of cars that are moving\
    \ left to right that\n        // are currently to the left of the sweep line.\
    \  We also count the number\n        // of cars that are moving right to left\
    \ that are currently to the right\n        // of the sweep line.  The number of\
    \ collisions is the product of these\n        // two numbers.  We repeat this\
    \ process until we reach the rightmost car.\n        // The time complexity is\
    \ O(n log n).\n        // The space complexity is O(n).\n        val cars = Array.ofDim[(Long,\
    \ Boolean)](n.toInt)\n        for (i <- 0 until n.toInt) {\n            val Array(x,\
    \ v) = readLine.split(\" \").map(_.toLong)\n            cars(i) = (x, v == 1)\n\
    \        }\n        val sortedCars = cars.sortWith((a, b) => a._1 < b._1)\n  \
    \      var leftToRight = 0\n        var rightToLeft = 0\n        var collisions\
    \ = 0L\n        for (i <- 0 until n.toInt) {\n            val (x, v) = sortedCars(i)\n\
    \            if (v) leftToRight += 1\n            else rightToLeft += 1\n    \
    \        collisions += leftToRight * rightToLeft\n        }\n        collisions\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp0_7zvvwu.scala:26:30 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m            \e[33mval\e[0m Array(x, v) = readLine.split(\e\
    [31m\" \"\e[0m).map(_.toLong)\n\e[31m\e[31m   |\e[0m                         \
    \     ^^^^^^^^\e[0m\n\e[31m   |\e[0m                              Not found: readLine\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp0_7zvvwu.scala:26:22\
    \ ---------------------------\e[0m\e[0m\n\e[31m26 |\e[0m            \e[33mval\e\
    [0m Array(x, v) = readLine.split(\e[31m\" \"\e[0m).map(_.toLong)\n\e[31m\e[31m\
    \   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m                      Recursive\
    \ \e[33mvalue\e[0m \e[35m$1$\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E045] Cyclic Error: /tmp/tmp0_7zvvwu.scala:26:25 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m            \e[33mval\e[0m Array(x, v) = readLine.split(\e\
    [31m\" \"\e[0m).map(_.toLong)\n\e[31m\e[31m   |\e[0m                         ^\e\
    [0m\n\e[31m   |\e[0m                         Recursive \e[33mvalue\e[0m \e[35m$1$\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659792665
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to use\
    \ a binary search.  We will use the fact that\n        // the number of collisions\
    \ is a monotonically increasing function of time.\n        // We will use the\
    \ fact that the number of collisions is a monotonically increasing function of\
    \ time.\n        // We will use the fact that the number of collisions is a monotonically\
    \ increasing function of time.\n        // We will use the fact that the number\
    \ of collisions is a monotonically increasing function of time.\n        // We\
    \ will use the fact that the number of collisions is a monotonically increasing\
    \ function of time.\n        // We will use the fact that the number of collisions\
    \ is a monotonically increasing function of time.\n        // We will use the\
    \ fact that the number of collisions is a monotonically increasing function of\
    \ time.\n        // We will use the fact that the number of collisions is a monotonically\
    \ increasing function of time.\n        // We will use the fact that the number\
    \ of collisions is a monotonically increasing function of time.\n        // We\
    \ will use the fact that the number of collisions is a monotonically increasing\
    \ function of time.\n        // We will use the fact that the number of collisions\
    \ is a monotonically increasing function of time.\n        // We will use the\
    \ fact that the number of collisions is a monotonically increasing function of\
    \ time.\n        // We will use the fact that the number of collisions is a monotonically\
    \ increasing function of time.\n        // We will use the fact that the number\
    \ of collisions is a monotonically increasing function of time.\n        // We\
    \ will use the fact that the number of collisions is a monotonically increasing\
    \ function of time.\n        // We will use the fact that the number of collisions\
    \ is a monotonically increasing function of time.\n        // We will use the\
    \ fact that the number of collisions is a monotonically increasing function of\
    \ time.\n        // We will use the fact that the number of collisions is a monotonically\
    \ increasing function of time.\n        // We will use the fact that the number\
    \ of collisions is a monotonically increasing function of time.\n        // We\
    \ will use the fact that the number of collisions is a monotonically increasing\
    \ function of time.\n        // We will use the fact that the number of collisions\
    \ is a monotonically increasing function of time.\n        // We will use the\
    \ fact that the number of collisions is a mon\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpyy2uvy7v.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// The idea is to use a binary search.  We will use the fact that\e[0m\n\e\
    [31m14 |\e[0m        \e[34m// the number of collisions is a monotonically increasing\
    \ function of time.\e[0m\n\e[31m15 |\e[0m        \e[34m// We will use the fact\
    \ that the number of collisions is a monotonically increasing function of time.\e\
    [0m\n\e[31m16 |\e[0m        \e[34m// We will use the fact that the number of collisions\
    \ is a monotonically increasing function of time.\e[0m\n\e[31m17 |\e[0m      \
    \  \e[34m// We will use the fact that the number of collisions is a monotonically\
    \ increasing function of time.\e[0m\n\e[31m18 |\e[0m        \e[34m// We will use\
    \ the fact that the number of collisions is a monotonically increasing function\
    \ of time.\e[0m\n\e[31m19 |\e[0m        \e[34m// We will use the fact that the\
    \ number of collisions is a monotonically increasing function of time.\e[0m\n\e\
    [31m20 |\e[0m        \e[34m// We will use the fact that the number of collisions\
    \ is a monotonically increasing function of time.\e[0m\n\e[31m21 |\e[0m      \
    \  \e[34m// We will use the fact that the number of collisions is a monotonically\
    \ increasing function of time.\e[0m\n\e[31m22 |\e[0m        \e[34m// We will use\
    \ the fact that the number of collisions is a monotonically increasing function\
    \ of time.\e[0m\n\e[31m23 |\e[0m        \e[34m// We will use the fact that the\
    \ number of collisions is a monotonically increasing function of time.\e[0m\n\e\
    [31m24 |\e[0m        \e[34m// We will use the fact that the number of collisions\
    \ is a monotonically increasing function of time.\e[0m\n\e[31m25 |\e[0m      \
    \  \e[34m// We will use the fact that the number of collisions is a monotonically\
    \ increasing f"
  stdout: ''
  timestamp: 1659792667
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is a very simple\
    \ problem.  The cars are moving in the same speed.\n        // Therefore, the\
    \ cars that are closest to each other will collide first.\n        // The cars\
    \ that are closest to each other are the ones that are at the same\n        //\
    \ position.  Therefore, the number of collisions is the number of pairs of cars\n\
    \        // that are at the same position.\n        // The number of pairs of\
    \ cars that are at the same position is the number of\n        // pairs of cars\
    \ that are at the same position.\n        // The number of pairs of cars that\
    \ are at the same position is the number of\n        // pairs of cars that are\
    \ at the same position.\n        // The number of pairs of cars that are at the\
    \ same position is the number of\n        // pairs of cars that are at the same\
    \ position.\n        // The number of pairs of cars that are at the same position\
    \ is the number of\n        // pairs of cars that are at the same position.\n\
    \        // The number of pairs of cars that are at the same position is the number\
    \ of\n        // pairs of cars that are at the same position.\n        // The\
    \ number of pairs of cars that are at the same position is the number of\n   \
    \     // pairs of cars that are at the same position.\n        // The number of\
    \ pairs of cars that are at the same position is the number of\n        // pairs\
    \ of cars that are at the same position.\n        // The number of pairs of cars\
    \ that are at the same position is the number of\n        // pairs of cars that\
    \ are at the same position.\n        // The number of pairs of cars that are at\
    \ the same position is the number of\n        // pairs of cars that are at the\
    \ same position.\n        // The number of pairs of cars that are at the same\
    \ position is the number of\n        // pairs of cars that are at the same position.\n\
    \        // The number of pairs of cars that are at the same position is the number\
    \ of\n        // pairs of cars that are at the same position.\n        // The\
    \ number of pairs of cars that are at the same position is the number of\n   \
    \     // pairs of cars that are at the same position.\n        // The number of\
    \ pairs of cars that are at the same position is the number of\n        // pairs\
    \ of cars that are at the same position.\n        // The number of pairs of cars\
    \ that are\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpun24_td6.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// This is a very simple problem.  The cars are moving in the same speed.\e\
    [0m\n\e[31m14 |\e[0m        \e[34m// Therefore, the cars that are closest to each\
    \ other will collide first.\e[0m\n\e[31m15 |\e[0m        \e[34m// The cars that\
    \ are closest to each other are the ones that are at the same\e[0m\n\e[31m16 |\e\
    [0m        \e[34m// position.  Therefore, the number of collisions is the number\
    \ of pairs of cars\e[0m\n\e[31m17 |\e[0m        \e[34m// that are at the same\
    \ position.\e[0m\n\e[31m18 |\e[0m        \e[34m// The number of pairs of cars\
    \ that are at the same position is the number of\e[0m\n\e[31m19 |\e[0m       \
    \ \e[34m// pairs of cars that are at the same position.\e[0m\n\e[31m20 |\e[0m\
    \        \e[34m// The number of pairs of cars that are at the same position is\
    \ the number of\e[0m\n\e[31m21 |\e[0m        \e[34m// pairs of cars that are at\
    \ the same position.\e[0m\n\e[31m22 |\e[0m        \e[34m// The number of pairs\
    \ of cars that are at the same position is the number of\e[0m\n\e[31m23 |\e[0m\
    \        \e[34m// pairs of cars that are at the same position.\e[0m\n\e[31m24\
    \ |\e[0m        \e[34m// The number of pairs of cars that are at the same position\
    \ is the number of\e[0m\n\e[31m25 |\e[0m        \e[34m// pairs of cars that are\
    \ at the same position.\e[0m\n\e[31m26 |\e[0m        \e[34m// The number of pairs\
    \ of cars that are at the same position is the number of\e[0m\n\e[31m27 |\e[0m\
    \        \e[34m// pairs of cars that are at the same position.\e[0m\n\e[31m28\
    \ |\e[0m        \e[34m// The number of pairs of cars that are at the same position\
    \ is the number of\e[0m\n\e[31m29 |\e[0m        \e[34m// pairs of cars that are\
    \ at the same position.\e[0m\n\e[31m30 |\e[0m        \e[34m/"
  stdout: ''
  timestamp: 1659792667
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to use\
    \ a sweep line algorithm.  We will sweep the line from left to right.\n      \
    \  // At each point, we will keep track of the number of cars that are moving\
    \ left to right\n        // and the number of cars that are moving right to left.\
    \  The number of collisions at that\n        // point is the product of the number\
    \ of cars moving left to right and the number of cars\n        // moving right\
    \ to left.  We will sum up the number of collisions at each point.\n        //\
    \ The number of cars moving left to right and the number of cars moving right\
    \ to left\n        // can be represented as a pair of integers.  We will use a\
    \ map to keep track of the\n        // number of cars at each point.  The key\
    \ is the point, and the value is the pair of\n        // integers.\n        val\
    \ map = new HashMap[Long, (Long, Long)]\n        // We will use a set to keep\
    \ track of the points that we have already visited.\n        val set = new HashSet[Long]\n\
    \        // We will use a queue to keep track of the points that we need to visit.\n\
    \        val queue = new Queue[Long]\n        // We will use a map to keep track\
    \ of the number of cars moving left to right and the\n        // number of cars\
    \ moving right to left at each point.\n        val carCount = new HashMap[Long,\
    \ (Long, Long)]\n        // We will use a map to keep track of the number of collisions\
    \ at each point.\n        val collisionCount = new HashMap[Long, Long]\n     \
    \   // We will use a map to keep track of the number of collisions at each point.\n\
    \        val collisionCount2 = new HashMap[Long, Long]\n        // We will use\
    \ a map to keep track of the number of collisions at each point.\n        val\
    \ collisionCount3 = new HashMap[Long, Long]\n        // We will use a map to keep\
    \ track of the number of collisions at each point.\n        val collisionCount4\
    \ = new HashMap[Long, Long]\n        // We will use a map to keep track of the\
    \ number of collisions at each point.\n        val collisionCount5 = new HashMap[Long,\
    \ Long]\n        // We will use a map to keep track of the number of collisions\
    \ at each point.\n        val collisionCount\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpwl_s7dv8.scala:42:4 ----------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpwl_s7dv8.scala:42:5 ---------------------\e[0m\e[0m\n\e[31m42 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659792667
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is a very simple\
    \ problem.  We can solve it by brute force.\n        // We can place the left-to-right\
    \ cars at positions 0, 1, 2, ..., n - 1.\n        // We can place the right-to-left\
    \ cars at positions -1, -2, -3, ..., -n.\n        // Then, we can iterate through\
    \ the left-to-right cars, and for each one,\n        // we can iterate through\
    \ the right-to-left cars, and count the number of\n        // collisions.\n  \
    \      var collisions = 0L\n        for (i <- 0L until n) {\n            for (j\
    \ <- 0L until n) {\n                if (i - j == 1) collisions += 1\n        \
    \    }\n        }\n        collisions\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpbd50fci5.scala:28)\n\tat Problem.main(tmpbd50fci5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792668
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The cars are numbered\
    \ from 1 to n.  The left-to-right cars are numbered from 1 to n.\n        // The\
    \ right-to-left cars are numbered from n to 1.\n        // The left-to-right cars\
    \ are at positions 1, 2, 3, ..., n.\n        // The right-to-left cars are at\
    \ positions n, n - 1, n - 2, ..., 1.\n        // The left-to-right cars move at\
    \ speed 1.\n        // The right-to-left cars move at speed 1.\n        // The\
    \ left-to-right cars move from left to right.\n        // The right-to-left cars\
    \ move from right to left.\n        // The left-to-right cars start at positions\
    \ 1, 2, 3, ..., n.\n        // The right-to-left cars start at positions n, n\
    \ - 1, n - 2, ..., 1.\n        // The left-to-right cars end at positions n, n\
    \ - 1, n - 2, ..., 1.\n        // The right-to-left cars end at positions 1, 2,\
    \ 3, ..., n.\n        // The left-to-right cars move from 1 to n.\n        //\
    \ The right-to-left cars move from n to 1.\n        // The left-to-right cars\
    \ move from 1 to n.\n        // The right-to-left cars move from n to 1.\n   \
    \     // The left-to-right cars move from 1 to n.\n        // The right-to-left\
    \ cars move from n to 1.\n        // The left-to-right cars move from 1 to n.\n\
    \        // The right-to-left cars move from n to 1.\n        // The left-to-right\
    \ cars move from 1 to n.\n        // The right-to-left cars move from n to 1.\n\
    \        // The left-to-right cars move from 1 to n.\n        // The right-to-left\
    \ cars move from n to 1.\n        // The left-to-right cars move from 1 to n.\n\
    \        // The right-to-left cars move from n to 1.\n        // The left-to-right\
    \ cars move from 1 to n.\n        // The right-to-left cars move from n to 1.\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpzfq8i2xt.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// The cars are numbered from 1 to n.  The left-to-right cars are numbered\
    \ from 1 to n.\e[0m\n\e[31m14 |\e[0m        \e[34m// The right-to-left cars are\
    \ numbered from n to 1.\e[0m\n\e[31m15 |\e[0m        \e[34m// The left-to-right\
    \ cars are at positions 1, 2, 3, ..., n.\e[0m\n\e[31m16 |\e[0m        \e[34m//\
    \ The right-to-left cars are at positions n, n - 1, n - 2, ..., 1.\e[0m\n\e[31m17\
    \ |\e[0m        \e[34m// The left-to-right cars move at speed 1.\e[0m\n\e[31m18\
    \ |\e[0m        \e[34m// The right-to-left cars move at speed 1.\e[0m\n\e[31m19\
    \ |\e[0m        \e[34m// The left-to-right cars move from left to right.\e[0m\n\
    \e[31m20 |\e[0m        \e[34m// The right-to-left cars move from right to left.\e\
    [0m\n\e[31m21 |\e[0m        \e[34m// The left-to-right cars start at positions\
    \ 1, 2, 3, ..., n.\e[0m\n\e[31m22 |\e[0m        \e[34m// The right-to-left cars\
    \ start at positions n, n - 1, n - 2, ..., 1.\e[0m\n\e[31m23 |\e[0m        \e\
    [34m// The left-to-right cars end at positions n, n - 1, n - 2, ..., 1.\e[0m\n\
    \e[31m24 |\e[0m        \e[34m// The right-to-left cars end at positions 1, 2,\
    \ 3, ..., n.\e[0m\n\e[31m25 |\e[0m        \e[34m// The left-to-right cars move\
    \ from 1 to n.\e[0m\n\e[31m26 |\e[0m        \e[34m// The right-to-left cars move\
    \ from n to 1.\e[0m\n\e[31m27 |\e[0m        \e[34m// The left-to-right cars move\
    \ from 1 to n.\e[0m\n\e[31m28 |\e[0m        \e[34m// The right-to-left cars move\
    \ from n to 1.\e[0m\n\e[31m29 |\e[0m        \e[34m// The left-to-right cars move\
    \ from 1 to n.\e[0m\n\e[31m30 |\e[0m        \e[34m// The right-to-left cars move\
    \ from n to 1.\e[0m\n\e[31m31 |\e[0m        \e[34m// The left-to-right cars move\
    \ from 1 to n.\e[0m\n\e[31m32 |\e[0m        \e[34m// The right-"
  stdout: ''
  timestamp: 1659792667
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // We can think of the\
    \ cars as points on a number line.\n        // The cars moving left to right are\
    \ at positions 1, 2, ..., n.\n        // The cars moving right to left are at\
    \ positions -1, -2, ..., -n.\n        // The cars moving left to right are at\
    \ positions 1, 2, ..., n.\n        // The cars moving right to left are at positions\
    \ -1, -2, ..., -n.\n        // We can think of the cars as points on a number\
    \ line.\n        // The cars moving left to right are at positions 1, 2, ...,\
    \ n.\n        // The cars moving right to left are at positions -1, -2, ..., -n.\n\
    \        // The cars moving left to right are at positions 1, 2, ..., n.\n   \
    \     // The cars moving right to left are at positions -1, -2, ..., -n.\n   \
    \     // We can think of the cars as points on a number line.\n        // The\
    \ cars moving left to right are at positions 1, 2, ..., n.\n        // The cars\
    \ moving right to left are at positions -1, -2, ..., -n.\n        // The cars\
    \ moving left to right are at positions 1, 2, ..., n.\n        // The cars moving\
    \ right to left are at positions -1, -2, ..., -n.\n        // We can think of\
    \ the cars as points on a number line.\n        // The cars moving left to right\
    \ are at positions 1, 2, ..., n.\n        // The cars moving right to left are\
    \ at positions -1, -2, ..., -n.\n        // The cars moving left to right are\
    \ at positions 1, 2, ..., n.\n        // The cars moving right to left are at\
    \ positions -1, -2, ..., -n.\n        // We can think of the cars as points on\
    \ a number line.\n        // The cars moving left to right are at positions 1,\
    \ 2, ..., n.\n        // The cars moving right to left are at positions -1, -2,\
    \ ..., -n.\n        // The cars moving left to right are at positions 1, 2, ...,\
    \ n.\n        // The cars moving right to left are at positions -1, -2, ..., -n.\n\
    \       \n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpwg6n694_.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// We can think of the cars as points on a number line.\e[0m\n\e[31m14 |\e\
    [0m        \e[34m// The cars moving left to right are at positions 1, 2, ...,\
    \ n.\e[0m\n\e[31m15 |\e[0m        \e[34m// The cars moving right to left are at\
    \ positions -1, -2, ..., -n.\e[0m\n\e[31m16 |\e[0m        \e[34m// The cars moving\
    \ left to right are at positions 1, 2, ..., n.\e[0m\n\e[31m17 |\e[0m        \e\
    [34m// The cars moving right to left are at positions -1, -2, ..., -n.\e[0m\n\e\
    [31m18 |\e[0m        \e[34m// We can think of the cars as points on a number line.\e\
    [0m\n\e[31m19 |\e[0m        \e[34m// The cars moving left to right are at positions\
    \ 1, 2, ..., n.\e[0m\n\e[31m20 |\e[0m        \e[34m// The cars moving right to\
    \ left are at positions -1, -2, ..., -n.\e[0m\n\e[31m21 |\e[0m        \e[34m//\
    \ The cars moving left to right are at positions 1, 2, ..., n.\e[0m\n\e[31m22\
    \ |\e[0m        \e[34m// The cars moving right to left are at positions -1, -2,\
    \ ..., -n.\e[0m\n\e[31m23 |\e[0m        \e[34m// We can think of the cars as points\
    \ on a number line.\e[0m\n\e[31m24 |\e[0m        \e[34m// The cars moving left\
    \ to right are at positions 1, 2, ..., n.\e[0m\n\e[31m25 |\e[0m        \e[34m//\
    \ The cars moving right to left are at positions -1, -2, ..., -n.\e[0m\n\e[31m26\
    \ |\e[0m        \e[34m// The cars moving left to right are at positions 1, 2,\
    \ ..., n.\e[0m\n\e[31m27 |\e[0m        \e[34m// The cars moving right to left\
    \ are at positions -1, -2, ..., -n.\e[0m\n\e[31m28 |\e[0m        \e[34m// We can\
    \ think of the cars as points on a number line.\e[0m\n\e[31m29 |\e[0m        \e\
    [34m// The cars moving left to right are at positions 1, 2, ..., n.\e[0m\n\e[31m30\
    \ |\e[0m        \e[34m// The cars moving righ"
  stdout: ''
  timestamp: 1659792667
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This function returns\
    \ the number of collisions between cars that are moving\n        // left to right\
    \ and cars that are moving right to left.\n        // The cars are numbered from\
    \ 1 to n.\n        // The cars that are moving left to right are numbered from\
    \ 1 to n.\n        // The cars that are moving right to left are numbered from\
    \ n to 1.\n        // The cars that are moving left to right are at positions\
    \ from 1 to n.\n        // The cars that are moving right to left are at positions\
    \ from n to 1.\n        // The cars that are moving left to right have speeds\
    \ from 1 to n.\n        // The cars that are moving right to left have speeds\
    \ from n to 1.\n        // The cars that are moving left to right have speeds\
    \ from 1 to n.\n        // The cars that are moving right to left have speeds\
    \ from n to 1.\n        // The cars that are moving left to right have speeds\
    \ from 1 to n.\n        // The cars that are moving right to left have speeds\
    \ from n to 1.\n        // The cars that are moving left to right have speeds\
    \ from 1 to n.\n        // The cars that are moving right to left have speeds\
    \ from n to 1.\n        // The cars that are moving left to right have speeds\
    \ from 1 to n.\n        // The cars that are moving right to left have speeds\
    \ from n to 1.\n        // The cars that are moving left to right have speeds\
    \ from 1 to n.\n        // The cars that are moving right to left have speeds\
    \ from n to 1.\n        // The cars that are moving left to right have speeds\
    \ from 1 to n.\n        // The cars that are moving right to left have speeds\
    \ from n to 1.\n        // The cars that are moving left to right have speeds\
    \ from 1 to n.\n        // The cars that are moving right to left have speeds\
    \ from n to 1.\n        // The cars that are moving left to right have speeds\
    \ from 1 to n.\n        // The cars that are moving right to left have speeds\
    \ from n to 1.\n        // The cars that are moving left to right have speeds\
    \ from 1 to n.\n        // The cars that are moving right to left have speeds\
    \ from n to 1.\n        // The cars that are moving left to right have speeds\
    \ from 1 to n.\n        // The cars that are moving right to left have speeds\
    \ from n to 1.\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmprslwgo0s.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// This function returns the number of collisions between cars that are moving\e\
    [0m\n\e[31m14 |\e[0m        \e[34m// left to right and cars that are moving right\
    \ to left.\e[0m\n\e[31m15 |\e[0m        \e[34m// The cars are numbered from 1\
    \ to n.\e[0m\n\e[31m16 |\e[0m        \e[34m// The cars that are moving left to\
    \ right are numbered from 1 to n.\e[0m\n\e[31m17 |\e[0m        \e[34m// The cars\
    \ that are moving right to left are numbered from n to 1.\e[0m\n\e[31m18 |\e[0m\
    \        \e[34m// The cars that are moving left to right are at positions from\
    \ 1 to n.\e[0m\n\e[31m19 |\e[0m        \e[34m// The cars that are moving right\
    \ to left are at positions from n to 1.\e[0m\n\e[31m20 |\e[0m        \e[34m//\
    \ The cars that are moving left to right have speeds from 1 to n.\e[0m\n\e[31m21\
    \ |\e[0m        \e[34m// The cars that are moving right to left have speeds from\
    \ n to 1.\e[0m\n\e[31m22 |\e[0m        \e[34m// The cars that are moving left\
    \ to right have speeds from 1 to n.\e[0m\n\e[31m23 |\e[0m        \e[34m// The\
    \ cars that are moving right to left have speeds from n to 1.\e[0m\n\e[31m24 |\e\
    [0m        \e[34m// The cars that are moving left to right have speeds from 1\
    \ to n.\e[0m\n\e[31m25 |\e[0m        \e[34m// The cars that are moving right to\
    \ left have speeds from n to 1.\e[0m\n\e[31m26 |\e[0m        \e[34m// The cars\
    \ that are moving left to right have speeds from 1 to n.\e[0m\n\e[31m27 |\e[0m\
    \        \e[34m// The cars that are moving right to left have speeds from n to\
    \ 1.\e[0m\n\e[31m28 |\e[0m        \e[34m// The cars that are moving left to right\
    \ have speeds from 1 to n.\e[0m\n\e[31m29 |\e[0m        \e[34m// The cars that\
    \ are moving right to left have speeds from n to 1.\e[0m"
  stdout: ''
  timestamp: 1659792667
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting positions.\n        // Then, for each car that's\
    \ moving left to right, we find the first car\n        // that's moving right\
    \ to left that's to the right of it.  If there is such a car,\n        // then\
    \ we know that the two cars will collide.  We can do this in O(n log n) time\n\
    \        // using a binary search.\n        // The total number of collisions\
    \ is the sum of the number of collisions for each car\n        // that's moving\
    \ left to right.\n        // The total number of collisions is also the number\
    \ of cars that are moving right to left\n        // that are to the left of the\
    \ car that's moving left to right.\n        // This is because the cars that are\
    \ moving right to left are sorted by their starting positions\n        // and\
    \ the cars that are moving left to right are sorted by their starting positions.\n\
    \        // Therefore, the number of cars that are moving right to left that are\
    \ to the left of the car\n        // that's moving left to right is the number\
    \ of cars that are moving right to left that are to the left\n        // of the\
    \ car that's moving left to right.\n        // This is because the cars that are\
    \ moving right to left are sorted by their starting positions\n        // and\
    \ the cars that are moving left to right are sorted by their starting positions.\n\
    \        // Therefore, the number of cars that are moving right to left that are\
    \ to the left of the car\n        // that's moving left to right is the number\
    \ of cars that are moving right to left that are to the left\n        // of the\
    \ car that's moving left to right.\n        // This is because the cars that are\
    \ moving right to left are sorted by their starting positions\n        // and\
    \ the cars that are moving left to right are sorted by their starting positions.\n\
    \        // Therefore, the number of cars that are moving right to left that are\
    \ to the left of the car\n        // that's moving left to right is the number\
    \ of cars that are moving right to left that are to the left\n        // of the\
    \ car that's moving left to right.\n        // This is because the cars that are\
    \ moving right to left are sorted by their starting positions\n        // and\
    \ the cars that are moving left to right are sorted by their starting positions.\n\
    \        // Therefore, the number of cars that are moving\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpjhvtscmz.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// The idea is to sort the cars by their starting positions.\e[0m\n\e[31m14\
    \ |\e[0m        \e[34m// Then, for each car that's moving left to right, we find\
    \ the first car\e[0m\n\e[31m15 |\e[0m        \e[34m// that's moving right to left\
    \ that's to the right of it.  If there is such a car,\e[0m\n\e[31m16 |\e[0m  \
    \      \e[34m// then we know that the two cars will collide.  We can do this in\
    \ O(n log n) time\e[0m\n\e[31m17 |\e[0m        \e[34m// using a binary search.\e\
    [0m\n\e[31m18 |\e[0m        \e[34m// The total number of collisions is the sum\
    \ of the number of collisions for each car\e[0m\n\e[31m19 |\e[0m        \e[34m//\
    \ that's moving left to right.\e[0m\n\e[31m20 |\e[0m        \e[34m// The total\
    \ number of collisions is also the number of cars that are moving right to left\e\
    [0m\n\e[31m21 |\e[0m        \e[34m// that are to the left of the car that's moving\
    \ left to right.\e[0m\n\e[31m22 |\e[0m        \e[34m// This is because the cars\
    \ that are moving right to left are sorted by their starting positions\e[0m\n\e\
    [31m23 |\e[0m        \e[34m// and the cars that are moving left to right are sorted\
    \ by their starting positions.\e[0m\n\e[31m24 |\e[0m        \e[34m// Therefore,\
    \ the number of cars that are moving right to left that are to the left of the\
    \ car\e[0m\n\e[31m25 |\e[0m        \e[34m// that's moving left to right is the\
    \ number of cars that are moving right to left that are to the left\e[0m\n\e[31m26\
    \ |\e[0m        \e[34m// of the car that's moving left to right.\e[0m\n\e[31m27\
    \ |\e[0m        \e[34m// This is because the cars that are moving right to left\
    \ are sorted by their starting positions\e[0m\n\e[31m28 |\e[0m        \e[34m//\
    \ and the cars that are moving left"
  stdout: ''
  timestamp: 1659792666
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to use\
    \ a sweep line algorithm.\n        // We will use a priority queue to keep track\
    \ of the cars.\n        // The priority queue will be sorted by the position of\
    \ the car.\n        // We will have two queues, one for the cars moving left to\
    \ right,\n        // and one for the cars moving right to left.\n        // We\
    \ will also keep track of the current position of the sweep line.\n        //\
    \ We will start the sweep line at position 0.\n        // We will then iterate\
    \ through the cars moving left to right,\n        // and for each car, we will\
    \ check if there are any cars moving right to left\n        // that are at the\
    \ same position.  If so, we will increment the number of collisions.\n       \
    \ // We will then move the sweep line to the position of the current car.\n  \
    \      // We will then iterate through the cars moving right to left,\n      \
    \  // and for each car, we will check if there are any cars moving left to right\n\
    \        // that are at the same position.  If so, we will increment the number\
    \ of collisions.\n        // We will then move the sweep line to the position\
    \ of the current car.\n        // We will repeat this process until we have iterated\
    \ through all the cars.\n        // The time complexity is O(n log n).\n     \
    \   var leftToRight = new PriorityQueue[Long]()(Ordering.Long.reverse)\n     \
    \   var rightToLeft = new PriorityQueue[Long]()(Ordering.Long.reverse)\n     \
    \   for (i <- 1 to n.toInt) {\n            leftToRight.enqueue(i)\n          \
    \  rightToLeft.enqueue(n + 1 - i)\n        }\n        var sweepLine = 0L\n   \
    \     var collisions = 0L\n        while (!leftToRight.isEmpty) {\n          \
    \  val leftToRightCar = leftToRight.dequeue\n            while (!rightToLeft.isEmpty\
    \ && rightToLeft.head == sweepLine) {\n                rightToLeft.dequeue\n \
    \               collisions += 1\n            }\n            sweepLine = leftToRightCar\n\
    \            while (!leftToRight.isEmpty && leftToRight.head == sweepLine) {\n\
    \                leftToRight.dequeue\n                collisions += 1\n      \
    \      }\n            sweepLine = rightToLeft.dequeue\n\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm2e166gs.scala:61:0 ----------------------------\e\
    [0m\e[0m\n\e[31m61 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpm2e166gs.scala:60:1\
    \ ---------------------\e[0m\e[0m\n\e[31m60 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e\
    [0m\n\e[31m   |\e[0m Found:    Unit\n\e[31m   |\e[0m Required: Long\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[33m\e[33m-- Warning: /tmp/tmpm2e166gs.scala:52:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m52 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n2 errors found\n"
  stdout: ''
  timestamp: 1659792667
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is a brute force\
    \ solution.  It's not very efficient, but it's easy to understand.\n        //\
    \ We'll use a set to keep track of the cars that are moving left to right.\n \
    \       // We'll use a set to keep track of the cars that are moving right to\
    \ left.\n        // We'll use a variable to keep track of the number of collisions.\n\
    \        // We'll use a variable to keep track of the current time.\n        //\
    \ We'll use a variable to keep track of the current position of the leftmost car\
    \ moving left to right.\n        // We'll use a variable to keep track of the\
    \ current position of the rightmost car moving right to left.\n        // We'll\
    \ use a variable to keep track of the current position of the leftmost car moving\
    \ right to left.\n        // We'll use a variable to keep track of the current\
    \ position of the rightmost car moving left to right.\n        var leftToRightCars\
    \ = Set[Long]()\n        var rightToLeftCars = Set[Long]()\n        var collisions\
    \ = 0L\n        var time = 0L\n        var leftMostLeftToRightCar = 0L\n     \
    \   var rightMostRightToLeftCar = 0L\n        var leftMostRightToLeftCar = 0L\n\
    \        var rightMostLeftToRightCar = 0L\n        // We'll now initialize the\
    \ sets of cars.\n        for (i <- 1L to n) {\n            leftToRightCars +=\
    \ i\n            rightToLeftCars += i\n        }\n        // We'll now simulate\
    \ the cars moving.\n        while (leftToRightCars.size > 0 && rightToLeftCars.size\
    \ > 0) {\n            // We'll now update the positions of the cars.\n       \
    \     leftMostLeftToRightCar += 1\n            rightMostRightToLeftCar -= 1\n\
    \            leftMostRightToLeftCar -= 1\n            rightMostLeftToRightCar\
    \ += 1\n            // We'll now check for collisions.\n            if (leftMostLeftToRightCar\
    \ == leftMostRightToLeftCar) {\n                // We'll now remove the cars that\
    \ collided.\n                leftToRightCars -= leftMostLeftToRightCar\n     \
    \           rightToLeftCars -= leftMostRightToLeftCar\n                // We'll\
    \ now update the number of collisions.\n                collisions += 1\n    \
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp28qwhdwb.scala:60:0 ----------------------------\e\
    [0m\e[0m\n\e[31m60 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp28qwhdwb.scala:59:1\
    \ ---------------------\e[0m\e[0m\n\e[31m59 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e\
    [0m\n\e[31m   |\e[0m Found:    Unit\n\e[31m   |\e[0m Required: Long\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[33m\e[33m-- Warning: /tmp/tmp28qwhdwb.scala:51:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m51 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n2 errors found\n"
  stdout: ''
  timestamp: 1659792667
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting positions.\n        // Then, we can do a sweep line\
    \ algorithm.\n        // The sweep line starts at the leftmost car, and moves\
    \ right.\n        // We keep track of the number of cars that are moving left\
    \ to right\n        // and the number of cars that are moving right to left.\n\
    \        // When the sweep line hits a car that's moving left to right,\n    \
    \    // we increment the number of cars that are moving left to right.\n     \
    \   // When the sweep line hits a car that's moving right to left,\n        //\
    \ we decrement the number of cars that are moving left to right.\n        // The\
    \ number of collisions is the number of cars that are moving left to right\n \
    \       // times the number of cars that are moving right to left.\n        val\
    \ cars = new Array[(Long, Boolean)](2 * n.toInt)\n        for (i <- 0 until n.toInt)\
    \ {\n            cars(i) = (i, true)\n            cars(i + n.toInt) = (i, false)\n\
    \        }\n        cars.sortBy(x => x._1)\n        var collisions = 0L\n    \
    \    var leftToRight = 0\n        for (i <- 0 until cars.length) {\n         \
    \   if (cars(i)._2) leftToRight += 1\n            else leftToRight -= 1\n    \
    \        collisions += leftToRight\n        }\n        collisions\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n\
    \    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792668
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is a classic problem\
    \ in combinatorics.  The answer is n * (n - 1) / 2.\n        // The reason is\
    \ that the number of collisions is the same as the number of\n        // pairs\
    \ of cars.  The number of pairs of cars is n * (n - 1) / 2.\n        n * (n -\
    \ 1) / 2\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpso9oob00.scala:19)\n\tat Problem.main(tmpso9oob00.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792667
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is a very simple\
    \ problem.  The cars that are moving left to right\n        // will hit the cars\
    \ that are moving right to left in the order of their\n        // speed.  The\
    \ cars that are moving right to left will hit the cars that\n        // are moving\
    \ left to right in the order of their speed.  So, the total\n        // number\
    \ of collisions is the sum of the first n numbers.\n        n * (n + 1) / 2\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpzixjqozh.scala:21)\n\tat Problem.main(tmpzixjqozh.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792667
- exit_code: -1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is a very simple\
    \ problem.  We can just simulate the cars moving.\n        // For each car, we\
    \ can store its position and direction.\n        // We can then simulate the cars\
    \ moving one step at a time.\n        // If a car moving left to right hits a\
    \ car moving right to left, we increment\n        // the collision count.\n  \
    \      // We can do this in O(n) time.\n        val cars = Array.fill(n.toInt)((0,\
    \ 0))\n        for (i <- 0 until n.toInt) {\n            cars(i) = (i, 1)\n  \
    \      }\n        for (i <- 0 until n.toInt) {\n            cars(i) = (i, -1)\n\
    \        }\n        var collisions = 0\n        var time = 0\n        while (true)\
    \ {\n            val newCars = Array.fill(n.toInt)((0, 0))\n            for (i\
    \ <- 0 until n.toInt) {\n                val (position, direction) = cars(i)\n\
    \                newCars(i) = (position + direction, direction)\n            }\n\
    \            for (i <- 0 until n.toInt) {\n                for (j <- 0 until n.toInt)\
    \ {\n                    if (i != j) {\n                        val (position1,\
    \ direction1) = newCars(i)\n                        val (position2, direction2)\
    \ = newCars(j)\n                        if (position1 == position2 && direction1\
    \ != direction2) {\n                            collisions += 1\n            \
    \            }\n                    }\n                }\n            }\n    \
    \        if (collisions > 0) return collisions\n            time += 1\n      \
    \      cars.copyToArray(newCars)\n        }\n        return collisions\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n\
    \    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1659792672
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // Let's say the cars\
    \ moving left to right are indexed from 1 to n, and the cars\n        // moving\
    \ right to left are indexed from n+1 to 2n.\n        // The cars moving left to\
    \ right are at positions 1, 2, 3, ..., n.\n        // The cars moving right to\
    \ left are at positions n+1, n+2, n+3, ..., 2n.\n        // The cars moving left\
    \ to right have speeds 1, 2, 3, ..., n.\n        // The cars moving right to left\
    \ have speeds n, n-1, n-2, ..., 1.\n        // The time it takes for the i-th\
    \ car moving left to right to reach the origin is\n        // 1/i.\n        //\
    \ The time it takes for the i-th car moving right to left to reach the origin\
    \ is\n        // 1/(n+1-i).\n        // The time it takes for the i-th car moving\
    \ left to right to reach the j-th car\n        // moving right to left is (n+1-j)/i.\n\
    \        // The time it takes for the j-th car moving right to left to reach the\
    \ i-th car\n        // moving left to right is (n+1-i)/j.\n        // The i-th\
    \ car moving left to right will collide with the j-th car moving right to left\n\
    \        // if and only if (n+1-j)/i < (n+1-i)/j.\n        // This is equivalent\
    \ to (n+1-j)i < (n+1-i)j.\n        // This is equivalent to (n+1-j)i - (n+1-i)j\
    \ < 0.\n        // This is equivalent to (n+1-j)i - (n+1-i)j + (n+1-i)i - (n+1-j)j\
    \ < (n+1-i)i - (n+1-j)j.\n        // This is equivalent to (n+1-j)i - (n+1-i)j\
    \ + (n+1-i)i - (n+1-j)j < n^2 + 2n - 2i - 2j + i^2 + j^2.\n        // This is\
    \ equivalent\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6v54icef.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// Let's say the cars moving left to right are indexed from 1 to n, and the\
    \ cars\e[0m\n\e[31m14 |\e[0m        \e[34m// moving right to left are indexed\
    \ from n+1 to 2n.\e[0m\n\e[31m15 |\e[0m        \e[34m// The cars moving left to\
    \ right are at positions 1, 2, 3, ..., n.\e[0m\n\e[31m16 |\e[0m        \e[34m//\
    \ The cars moving right to left are at positions n+1, n+2, n+3, ..., 2n.\e[0m\n\
    \e[31m17 |\e[0m        \e[34m// The cars moving left to right have speeds 1, 2,\
    \ 3, ..., n.\e[0m\n\e[31m18 |\e[0m        \e[34m// The cars moving right to left\
    \ have speeds n, n-1, n-2, ..., 1.\e[0m\n\e[31m19 |\e[0m        \e[34m// The time\
    \ it takes for the i-th car moving left to right to reach the origin is\e[0m\n\
    \e[31m20 |\e[0m        \e[34m// 1/i.\e[0m\n\e[31m21 |\e[0m        \e[34m// The\
    \ time it takes for the i-th car moving right to left to reach the origin is\e\
    [0m\n\e[31m22 |\e[0m        \e[34m// 1/(n+1-i).\e[0m\n\e[31m23 |\e[0m        \e\
    [34m// The time it takes for the i-th car moving left to right to reach the j-th\
    \ car\e[0m\n\e[31m24 |\e[0m        \e[34m// moving right to left is (n+1-j)/i.\e\
    [0m\n\e[31m25 |\e[0m        \e[34m// The time it takes for the j-th car moving\
    \ right to left to reach the i-th car\e[0m\n\e[31m26 |\e[0m        \e[34m// moving\
    \ left to right is (n+1-i)/j.\e[0m\n\e[31m27 |\e[0m        \e[34m// The i-th car\
    \ moving left to right will collide with the j-th car moving right to left\e[0m\n\
    \e[31m28 |\e[0m        \e[34m// if and only if (n+1-j)/i < (n+1-i)/j.\e[0m\n\e\
    [31m29 |\e[0m        \e[34m// This is equivalent to (n+1-j)i < (n+1-i)j.\e[0m\n\
    \e[31m30 |\e[0m        \e[34m// This is equivalent to (n+1-j)i - (n+1-i)j < 0.\e\
    [0m\n\e[31m31 |\e[0m        \e[34m// This is equi"
  stdout: ''
  timestamp: 1659792667
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting position.\n        // The cars that start at the\
    \ same position are sorted by their speed.\n        // Then, we can use a sweep\
    \ line algorithm to compute the number of collisions.\n        // The sweep line\
    \ algorithm is as follows:\n        // 1.  We start at the leftmost car.  We move\
    \ the sweep line to the right.\n        // 2.  When the sweep line encounters\
    \ a car, we add it to a set of cars.\n        // 3.  When the sweep line encounters\
    \ a car that's moving right to left, we remove it from the set.\n        // 4.\
    \  When the sweep line encounters a car that's moving left to right, we check\
    \ if there's a car\n        //     moving right to left in the set.  If so, we\
    \ increment the number of collisions.\n        // 5.  We repeat steps 1-4 until\
    \ we reach the rightmost car.\n        // 6.  We return the number of collisions.\n\
    \        // The time complexity is O(n log n).\n        val cars = new Array[(Long,\
    \ Boolean)](2 * n.toInt)\n        for (i <- 0 until n.toInt) {\n            cars(i)\
    \ = (i.toLong, true)\n            cars(i + n.toInt) = (i.toLong, false)\n    \
    \    }\n        val sortedCars = cars.sortWith((a, b) => {\n            if (a._1\
    \ == b._1) a._2 else a._1 < b._1\n        })\n        var collisions = 0L\n  \
    \      val carsInSet = new HashSet[(Long, Boolean)]\n        for (car <- sortedCars)\
    \ {\n            if (car._2) {\n                if (carsInSet.contains((car._1,\
    \ false))) collisions += 1\n                carsInSet.add(car)\n            }\
    \ else {\n                carsInSet.remove(car)\n            }\n        }\n  \
    \      collisions\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpwcwebqsn.scala:46)\n\tat Problem.main(tmpwcwebqsn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792668
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting positions.\n        // Then, we can just count the\
    \ number of cars that are moving\n        // in the same direction.\n        val\
    \ cars = Array.fill(2 * n.toInt)(0)\n        for (i <- 0 until n.toInt) {\n  \
    \          cars(i) = i + 1\n            cars(i + n.toInt) = -(i + 1)\n       \
    \ }\n        cars.sorted\n        var collisions = 0\n        for (i <- 0 until\
    \ cars.length - 1) {\n            if (cars(i) > 0 && cars(i + 1) > 0) collisions\
    \ += 1\n            if (cars(i) < 0 && cars(i + 1) < 0) collisions += 1\n    \
    \    }\n        collisions\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l)) ==\
    \ (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpdtcv1fb6.scala:30)\n\tat Problem.main(tmpdtcv1fb6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792668
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting position.\n        // Then, we can simulate the race\
    \ by iterating through the cars\n        // from left to right.  If we encounter\
    \ a car that's moving left to right,\n        // then we know that it will collide\
    \ with the next car that's moving right to left.\n        // We can then simulate\
    \ the collision by swapping the directions of the two cars.\n        // We can\
    \ then continue iterating through the cars.\n        // We can do this in O(n)\
    \ time.\n        val cars = new Array[(Long, Boolean)](2 * n.toInt)\n        for\
    \ (i <- 0 until n.toInt) {\n            cars(i) = (i, true)\n            cars(i\
    \ + n.toInt) = (i, false)\n        }\n        cars.sortWith((a, b) => a._1 < b._1)\n\
    \        var collisions = 0L\n        for (i <- 0 until cars.length) {\n     \
    \       if (cars(i)._2) {\n                var j = i + 1\n                while\
    \ (j < cars.length && cars(j)._2) j += 1\n                if (j < cars.length)\
    \ {\n                    collisions += 1\n                    cars(j) = (cars(j)._1,\
    \ true)\n                }\n            }\n        }\n        collisions\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmppcm0l9wl.scala:40)\n\tat Problem.main(tmppcm0l9wl.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792678
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This function outputs\
    \ the number of collisions between the ith car from the left\n        // and the\
    \ jth car from the right.\n        def collision(i : Long, j : Long) : Long =\
    \ {\n            if (i == j) 0\n            else if (i < j) collision(i, j - 1)\
    \ + j - 1\n            else collision(i - 1, j) + i - 1\n        }\n        collision(n,\
    \ n)\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2l2glcr7.scala:23)\n\tat Problem.main(tmp2l2glcr7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792676
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // Let's say the cars\
    \ moving left to right are labeled 1, 2, 3, ..., n.\n        // The cars moving\
    \ right to left are labeled -1, -2, -3, ..., -n.\n        // The cars are initially\
    \ positioned at x = 1, 2, 3, ..., n, respectively.\n        // The cars are initially\
    \ positioned at x = -1, -2, -3, ..., -n, respectively.\n        // The cars are\
    \ moving at a speed of 1.\n        // The cars are moving at a speed of -1.\n\
    \        // The cars are infinitely strong and sturdy.\n        // The cars are\
    \ infinitely strong and sturdy.\n        // The cars are infinitely strong and\
    \ sturdy.\n        // The cars are infinitely strong and sturdy.\n        // The\
    \ cars are infinitely strong and sturdy.\n        // The cars are infinitely strong\
    \ and sturdy.\n        // The cars are infinitely strong and sturdy.\n       \
    \ // The cars are infinitely strong and sturdy.\n        // The cars are infinitely\
    \ strong and sturdy.\n        // The cars are infinitely strong and sturdy.\n\
    \        // The cars are infinitely strong and sturdy.\n        // The cars are\
    \ infinitely strong and sturdy.\n        // The cars are infinitely strong and\
    \ sturdy.\n        // The cars are infinitely strong and sturdy.\n        // The\
    \ cars are infinitely strong and sturdy.\n        // The cars are infinitely strong\
    \ and sturdy.\n        // The cars are infinitely strong and sturdy.\n       \
    \ // The cars are infinitely strong and sturdy.\n        // The cars are infinitely\
    \ strong and sturdy.\n        // The cars are infinitely strong and sturdy.\n\
    \        // The cars are infinitely strong and sturdy.\n        // The cars are\
    \ infinitely strong and sturdy.\n        // The cars are infinitely strong and\
    \ sturdy.\n        // The cars are infinitely strong and sturdy.\n        // The\
    \ cars are infinitely strong and sturdy.\n        // The cars are infinitely strong\
    \ and sturdy.\n        // The cars are infinitely strong and sturdy.\n       \
    \ // The cars are infinitely strong and sturdy.\n        // The cars are infinitely\
    \ strong and sturdy.\n        // The cars are infinitely strong and sturdy.\n\
    \        // The cars are infinitely strong and sturdy.\n        // The cars are\
    \ infinitely strong and sturdy.\n        // The cars are infinitely strong and\
    \ sturdy.\n        // The cars are infinitely strong and sturdy.\n        // The\
    \ cars are infinitely strong and sturdy.\n\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4o4molng.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// Let's say the cars moving left to right are labeled 1, 2, 3, ..., n.\e\
    [0m\n\e[31m14 |\e[0m        \e[34m// The cars moving right to left are labeled\
    \ -1, -2, -3, ..., -n.\e[0m\n\e[31m15 |\e[0m        \e[34m// The cars are initially\
    \ positioned at x = 1, 2, 3, ..., n, respectively.\e[0m\n\e[31m16 |\e[0m     \
    \   \e[34m// The cars are initially positioned at x = -1, -2, -3, ..., -n, respectively.\e\
    [0m\n\e[31m17 |\e[0m        \e[34m// The cars are moving at a speed of 1.\e[0m\n\
    \e[31m18 |\e[0m        \e[34m// The cars are moving at a speed of -1.\e[0m\n\e\
    [31m19 |\e[0m        \e[34m// The cars are infinitely strong and sturdy.\e[0m\n\
    \e[31m20 |\e[0m        \e[34m// The cars are infinitely strong and sturdy.\e[0m\n\
    \e[31m21 |\e[0m        \e[34m// The cars are infinitely strong and sturdy.\e[0m\n\
    \e[31m22 |\e[0m        \e[34m// The cars are infinitely strong and sturdy.\e[0m\n\
    \e[31m23 |\e[0m        \e[34m// The cars are infinitely strong and sturdy.\e[0m\n\
    \e[31m24 |\e[0m        \e[34m// The cars are infinitely strong and sturdy.\e[0m\n\
    \e[31m25 |\e[0m        \e[34m// The cars are infinitely strong and sturdy.\e[0m\n\
    \e[31m26 |\e[0m        \e[34m// The cars are infinitely strong and sturdy.\e[0m\n\
    \e[31m27 |\e[0m        \e[34m// The cars are infinitely strong and sturdy.\e[0m\n\
    \e[31m28 |\e[0m        \e[34m// The cars are infinitely strong and sturdy.\e[0m\n\
    \e[31m29 |\e[0m        \e[34m// The cars are infinitely strong and sturdy.\e[0m\n\
    \e[31m30 |\e[0m        \e[34m// The cars are infinitely strong and sturdy.\e[0m\n\
    \e[31m31 |\e[0m        \e[34m// The cars are infinitely strong and sturdy.\e[0m\n\
    \e[31m32 |\e[0m        \e[34m// The cars are infinitely strong and sturdy.\e[0m\n\
    \e[31m33 |\e[0m   "
  stdout: ''
  timestamp: 1659792675
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting position.\n        // Then, we can simply count the\
    \ number of cars that are moving left to right\n        // and the number of cars\
    \ that are moving right to left.  The number of collisions\n        // is the\
    \ minimum of these two numbers.\n        // The number of cars moving left to\
    \ right is the number of cars that start at\n        // a position that's less\
    \ than 0.  The number of cars moving right to left is the\n        // number of\
    \ cars that start at a position that's greater than 0.\n        // The number\
    \ of cars that start at a position that's less than 0 is n / 2.\n        // The\
    \ number of cars that start at a position that's greater than 0 is n / 2.\n  \
    \      // The number of cars that start at a position that's equal to 0 is 1.\n\
    \        // The number of cars that start at a position that's less than 0 is\
    \ n / 2.\n        // The number of cars that start at a position that's greater\
    \ than 0 is n / 2.\n        // The number of cars that start at a position that's\
    \ equal to 0 is 1.\n        // The number of cars that start at a position that's\
    \ less than 0 is n / 2.\n        // The number of cars that start at a position\
    \ that's greater than 0 is n / 2.\n        // The number of cars that start at\
    \ a position that's equal to 0 is 1.\n        // The number of cars that start\
    \ at a position that's less than 0 is n / 2.\n        // The number of cars that\
    \ start at a position that's greater than 0 is n / 2.\n        // The number of\
    \ cars that start at a position that's equal to 0 is 1.\n        // The number\
    \ of cars that start at a position that's less than 0 is n / 2.\n        // The\
    \ number of cars that start at a position that's greater than 0 is n / 2.\n  \
    \      // The number of cars that start at a position that's equal to 0 is 1.\n\
    \        // The number of cars that start at a position that's less than 0 is\
    \ n / 2.\n        // The number of cars that start at a position that's greater\
    \ than 0 is n / 2.\n        // The number of cars that start at a position that's\
    \ equal to 0 is 1.\n        // The number\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5okzf7oa.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// The idea is to sort the cars by their starting position.\e[0m\n\e[31m14\
    \ |\e[0m        \e[34m// Then, we can simply count the number of cars that are\
    \ moving left to right\e[0m\n\e[31m15 |\e[0m        \e[34m// and the number of\
    \ cars that are moving right to left.  The number of collisions\e[0m\n\e[31m16\
    \ |\e[0m        \e[34m// is the minimum of these two numbers.\e[0m\n\e[31m17 |\e\
    [0m        \e[34m// The number of cars moving left to right is the number of cars\
    \ that start at\e[0m\n\e[31m18 |\e[0m        \e[34m// a position that's less than\
    \ 0.  The number of cars moving right to left is the\e[0m\n\e[31m19 |\e[0m   \
    \     \e[34m// number of cars that start at a position that's greater than 0.\e\
    [0m\n\e[31m20 |\e[0m        \e[34m// The number of cars that start at a position\
    \ that's less than 0 is n / 2.\e[0m\n\e[31m21 |\e[0m        \e[34m// The number\
    \ of cars that start at a position that's greater than 0 is n / 2.\e[0m\n\e[31m22\
    \ |\e[0m        \e[34m// The number of cars that start at a position that's equal\
    \ to 0 is 1.\e[0m\n\e[31m23 |\e[0m        \e[34m// The number of cars that start\
    \ at a position that's less than 0 is n / 2.\e[0m\n\e[31m24 |\e[0m        \e[34m//\
    \ The number of cars that start at a position that's greater than 0 is n / 2.\e\
    [0m\n\e[31m25 |\e[0m        \e[34m// The number of cars that start at a position\
    \ that's equal to 0 is 1.\e[0m\n\e[31m26 |\e[0m        \e[34m// The number of\
    \ cars that start at a position that's less than 0 is n / 2.\e[0m\n\e[31m27 |\e\
    [0m        \e[34m// The number of cars that start at a position that's greater\
    \ than 0 is n / 2.\e[0m\n\e[31m28 |\e[0m        \e[34m// The number of cars that\
    \ start at a position that's equal to"
  stdout: ''
  timestamp: 1659792676
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting positions.  Then, we can\n        // iterate through\
    \ the cars and count the number of cars that are moving\n        // in the opposite\
    \ direction.  This is a linear time algorithm.\n        val cars = new Array[(Long,\
    \ Boolean)](2 * n.toInt)\n        for (i <- 0 until n.toInt) {\n            cars(i)\
    \ = (i.toLong, true)\n            cars(i + n.toInt) = (i.toLong, false)\n    \
    \    }\n        cars.sortWith((a, b) => a._1 < b._1)\n        var count = 0L\n\
    \        var i = 0\n        while (i < cars.length) {\n            var j = i +\
    \ 1\n            while (j < cars.length && cars(j)._1 == cars(i)._1) j += 1\n\
    \            count += (j - i) * (j - i - 1) / 2\n            i = j\n        }\n\
    \        count\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpl2i06ic0.scala:33)\n\tat Problem.main(tmpl2i06ic0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792678
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting position.\n        // Then, we can just go through\
    \ the cars in order and count the number of collisions.\n        // If we have\
    \ a car that's moving left to right at position x, and a car that's moving\n \
    \       // right to left at position y, then they collide if and only if x > y.\n\
    \        // So, we can just count the number of cars that are moving right to\
    \ left that are\n        // to the left of the current car that's moving left\
    \ to right.\n        // We can do this in O(n log n) time.\n        val cars =\
    \ new Array[(Long, Boolean)](2 * n.toInt)\n        for (i <- 0 until n.toInt)\
    \ {\n            cars(i) = (i.toLong, true)\n            cars(i + n.toInt) = (i.toLong,\
    \ false)\n        }\n        cars.sortWith((a, b) => a._1 < b._1)\n        var\
    \ count = 0L\n        var leftToRight = 0\n        for (i <- 0 until 2 * n.toInt)\
    \ {\n            if (cars(i)._2) {\n                count += leftToRight\n   \
    \             leftToRight += 1\n            } else {\n                leftToRight\
    \ -= 1\n            }\n        }\n        count\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmplg8r0snb.scala:39)\n\tat Problem.main(tmplg8r0snb.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792678
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting positions, and then\n        // iterate through the\
    \ sorted list.  If a car is moving left to right,\n        // then it will collide\
    \ with the next car that's moving right to left.\n        // The number of collisions\
    \ is the number of cars moving left to right.\n        // The number of cars moving\
    \ left to right is the number of cars that\n        // have an odd starting position.\n\
    \        val cars = (1 to n.toInt).map(x => (x, x % 2 == 1)).toList\n        cars.filter(x\
    \ => x._2).length\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpw5cu8m3z.scala:23)\n\tat Problem.main(tmpw5cu8m3z.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792678
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This function outputs\
    \ the number of collisions between the cars\n        // that are driving left\
    \ to right and the cars that are driving right to left.\n        // The cars are\
    \ numbered from 0 to n - 1.\n        // The cars that are driving left to right\
    \ are numbered from 0 to n - 1.\n        // The cars that are driving right to\
    \ left are numbered from n - 1 to 0.\n        // The car that is numbered 0 is\
    \ the first car that is driving left to right.\n        // The car that is numbered\
    \ n - 1 is the first car that is driving right to left.\n        // The car that\
    \ is numbered 0 is the last car that is driving right to left.\n        // The\
    \ car that is numbered n - 1 is the last car that is driving left to right.\n\
    \        // The car that is numbered i is driving left to right at speed i + 1.\n\
    \        // The car that is numbered i is driving right to left at speed n - i.\n\
    \        // The car that is numbered i is driving left to right at position i.\n\
    \        // The car that is numbered i is driving right to left at position n\
    \ - i - 1.\n        // The car that is numbered i is driving left to right at\
    \ time i.\n        // The car that is numbered i is driving right to left at time\
    \ n - i - 1.\n        // The car that is numbered i is driving left to right at\
    \ time i + 1.\n        // The car that is numbered i is driving right to left\
    \ at time n - i - 2.\n        // The car that is numbered i is driving left to\
    \ right at time i + 2.\n        // The car that is numbered i is driving right\
    \ to left at time n - i - 3.\n        // The car that is numbered i is driving\
    \ left to right at time i + 3.\n        // The car that is numbered i is driving\
    \ right to left at time n - i - 4.\n        // The car that is numbered i is driving\
    \ left to right at time i + 4.\n        // The car that is numbered i is driving\
    \ right to left at time n - i - 5.\n        // The car that is numbered i is driving\
    \ left to right at time i + 5.\n        // The car that is numbered i is driving\
    \ right to left at time n - i - 6.\n        // The car that is numbered i is driving\
    \ left\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_6cnbz3w.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// This function outputs the number of collisions between the cars\e[0m\n\e\
    [31m14 |\e[0m        \e[34m// that are driving left to right and the cars that\
    \ are driving right to left.\e[0m\n\e[31m15 |\e[0m        \e[34m// The cars are\
    \ numbered from 0 to n - 1.\e[0m\n\e[31m16 |\e[0m        \e[34m// The cars that\
    \ are driving left to right are numbered from 0 to n - 1.\e[0m\n\e[31m17 |\e[0m\
    \        \e[34m// The cars that are driving right to left are numbered from n\
    \ - 1 to 0.\e[0m\n\e[31m18 |\e[0m        \e[34m// The car that is numbered 0 is\
    \ the first car that is driving left to right.\e[0m\n\e[31m19 |\e[0m        \e\
    [34m// The car that is numbered n - 1 is the first car that is driving right to\
    \ left.\e[0m\n\e[31m20 |\e[0m        \e[34m// The car that is numbered 0 is the\
    \ last car that is driving right to left.\e[0m\n\e[31m21 |\e[0m        \e[34m//\
    \ The car that is numbered n - 1 is the last car that is driving left to right.\e\
    [0m\n\e[31m22 |\e[0m        \e[34m// The car that is numbered i is driving left\
    \ to right at speed i + 1.\e[0m\n\e[31m23 |\e[0m        \e[34m// The car that\
    \ is numbered i is driving right to left at speed n - i.\e[0m\n\e[31m24 |\e[0m\
    \        \e[34m// The car that is numbered i is driving left to right at position\
    \ i.\e[0m\n\e[31m25 |\e[0m        \e[34m// The car that is numbered i is driving\
    \ right to left at position n - i - 1.\e[0m\n\e[31m26 |\e[0m        \e[34m// The\
    \ car that is numbered i is driving left to right at time i.\e[0m\n\e[31m27 |\e\
    [0m        \e[34m// The car that is numbered i is driving right to left at time\
    \ n - i - 1.\e[0m\n\e[31m28 |\e[0m        \e[34m// The car that is numbered i\
    \ is driving left to right at time i + 1.\e[0m\n\e"
  stdout: ''
  timestamp: 1659792676
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to use\
    \ a sweep line algorithm.\n        // We'll use a priority queue to keep track\
    \ of the cars.\n        // The priority queue will be sorted by the x-coordinate\
    \ of the cars.\n        // We'll keep track of the cars moving left to right and\
    \ the cars moving right to left\n        // in two separate priority queues.\n\
    \        // We'll keep track of the number of collisions in a variable called\
    \ collisions.\n        // Initially, collisions is 0.\n        // We'll keep track\
    \ of the current x-coordinate in a variable called x.\n        // Initially, x\
    \ is 0.\n        // We'll keep track of the current time in a variable called\
    \ t.\n        // Initially, t is 0.\n        // We'll keep track of the current\
    \ number of cars in a variable called numCars.\n        // Initially, numCars\
    \ is 0.\n        // We'll keep track of the current number of cars moving left\
    \ to right in a variable called numCarsLeft.\n        // Initially, numCarsLeft\
    \ is 0.\n        // We'll keep track of the current number of cars moving right\
    \ to left in a variable called numCarsRight.\n        // Initially, numCarsRight\
    \ is 0.\n        // We'll keep track of the current number of cars moving left\
    \ to right that are at the front of the queue in a variable called numCarsLeftFront.\n\
    \        // Initially, numCarsLeftFront is 0.\n        // We'll keep track of\
    \ the current number of cars moving right to left that are at the front of the\
    \ queue in a variable called numCarsRightFront.\n        // Initially, numCarsRightFront\
    \ is 0.\n        // We'll keep track of the current number of cars moving left\
    \ to right that are at the back of the queue in a variable called numCarsLeftBack.\n\
    \        // Initially, numCarsLeftBack is 0.\n        // We'll keep track of the\
    \ current number of cars moving right to left that are at the back of the queue\
    \ in a variable called numCarsRightBack.\n        // Initially, numCarsRightBack\
    \ is 0.\n        // We'll keep track of the current number of cars moving left\
    \ to right that are at the front of the queue and are moving right to left in\
    \ a variable called numCarsLeftFrontRight.\n        // Initially, numCarsLeftFront\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_wkvltt1.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// The idea is to use a sweep line algorithm.\e[0m\n\e[31m14 |\e[0m      \
    \  \e[34m// We'll use a priority queue to keep track of the cars.\e[0m\n\e[31m15\
    \ |\e[0m        \e[34m// The priority queue will be sorted by the x-coordinate\
    \ of the cars.\e[0m\n\e[31m16 |\e[0m        \e[34m// We'll keep track of the cars\
    \ moving left to right and the cars moving right to left\e[0m\n\e[31m17 |\e[0m\
    \        \e[34m// in two separate priority queues.\e[0m\n\e[31m18 |\e[0m     \
    \   \e[34m// We'll keep track of the number of collisions in a variable called\
    \ collisions.\e[0m\n\e[31m19 |\e[0m        \e[34m// Initially, collisions is 0.\e\
    [0m\n\e[31m20 |\e[0m        \e[34m// We'll keep track of the current x-coordinate\
    \ in a variable called x.\e[0m\n\e[31m21 |\e[0m        \e[34m// Initially, x is\
    \ 0.\e[0m\n\e[31m22 |\e[0m        \e[34m// We'll keep track of the current time\
    \ in a variable called t.\e[0m\n\e[31m23 |\e[0m        \e[34m// Initially, t is\
    \ 0.\e[0m\n\e[31m24 |\e[0m        \e[34m// We'll keep track of the current number\
    \ of cars in a variable called numCars.\e[0m\n\e[31m25 |\e[0m        \e[34m//\
    \ Initially, numCars is 0.\e[0m\n\e[31m26 |\e[0m        \e[34m// We'll keep track\
    \ of the current number of cars moving left to right in a variable called numCarsLeft.\e\
    [0m\n\e[31m27 |\e[0m        \e[34m// Initially, numCarsLeft is 0.\e[0m\n\e[31m28\
    \ |\e[0m        \e[34m// We'll keep track of the current number of cars moving\
    \ right to left in a variable called numCarsRight.\e[0m\n\e[31m29 |\e[0m     \
    \   \e[34m// Initially, numCarsRight is 0.\e[0m\n\e[31m30 |\e[0m        \e[34m//\
    \ We'll keep track of the current number of cars moving left to right that are\
    \ at the front of the queue in a variable calle"
  stdout: ''
  timestamp: 1659792677
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting positions.\n        // Then, we can easily count\
    \ the number of collisions.\n        // The number of collisions is the number\
    \ of cars that are moving left to right\n        // that are to the left of a\
    \ car that's moving right to left.\n        // This is the same as the number\
    \ of cars that are moving right to left\n        // that are to the right of a\
    \ car that's moving left to right.\n        // So, we can just sort the cars by\
    \ their starting positions, and then\n        // count the number of cars that\
    \ are moving right to left that are to the right\n        // of a car that's moving\
    \ left to right.\n        // The number of cars that are moving right to left\
    \ that are to the right of a car\n        // that's moving left to right is the\
    \ number of cars that are moving right to left\n        // that are to the left\
    \ of a car that's moving left to right.\n        // So, we can just sort the cars\
    \ by their starting positions, and then\n        // count the number of cars that\
    \ are moving left to right that are to the left\n        // of a car that's moving\
    \ right to left.\n        // The number of cars that are moving left to right\
    \ that are to the left of a car\n        // that's moving right to left is the\
    \ number of cars that are moving left to right\n        // that are to the right\
    \ of a car that's moving right to left.\n        // So, we can just sort the cars\
    \ by their starting positions, and then\n        // count the number of cars that\
    \ are moving right to left that are to the right\n        // of a car that's moving\
    \ right to left.\n        // The number of cars that are moving right to left\
    \ that are to the right of a car\n        // that's moving right to left is the\
    \ number of cars that are moving right to left\n        // that are to the left\
    \ of a car that's moving right to left.\n        // So, we can just sort the cars\
    \ by their starting positions, and then\n        // count the number of cars that\
    \ are moving left to right that are to the left\n        // of a car that's moving\
    \ left to right.\n        // The number of cars that are moving left to right\
    \ that are to the left of a car\n        // that's moving left to right is the\
    \ number of\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5blyvlok.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// The idea is to sort the cars by their starting positions.\e[0m\n\e[31m14\
    \ |\e[0m        \e[34m// Then, we can easily count the number of collisions.\e\
    [0m\n\e[31m15 |\e[0m        \e[34m// The number of collisions is the number of\
    \ cars that are moving left to right\e[0m\n\e[31m16 |\e[0m        \e[34m// that\
    \ are to the left of a car that's moving right to left.\e[0m\n\e[31m17 |\e[0m\
    \        \e[34m// This is the same as the number of cars that are moving right\
    \ to left\e[0m\n\e[31m18 |\e[0m        \e[34m// that are to the right of a car\
    \ that's moving left to right.\e[0m\n\e[31m19 |\e[0m        \e[34m// So, we can\
    \ just sort the cars by their starting positions, and then\e[0m\n\e[31m20 |\e\
    [0m        \e[34m// count the number of cars that are moving right to left that\
    \ are to the right\e[0m\n\e[31m21 |\e[0m        \e[34m// of a car that's moving\
    \ left to right.\e[0m\n\e[31m22 |\e[0m        \e[34m// The number of cars that\
    \ are moving right to left that are to the right of a car\e[0m\n\e[31m23 |\e[0m\
    \        \e[34m// that's moving left to right is the number of cars that are moving\
    \ right to left\e[0m\n\e[31m24 |\e[0m        \e[34m// that are to the left of\
    \ a car that's moving left to right.\e[0m\n\e[31m25 |\e[0m        \e[34m// So,\
    \ we can just sort the cars by their starting positions, and then\e[0m\n\e[31m26\
    \ |\e[0m        \e[34m// count the number of cars that are moving left to right\
    \ that are to the left\e[0m\n\e[31m27 |\e[0m        \e[34m// of a car that's moving\
    \ right to left.\e[0m\n\e[31m28 |\e[0m        \e[34m// The number of cars that\
    \ are moving left to right that are to the left of a car\e[0m\n\e[31m29 |\e[0m\
    \        \e[34m// that's moving right to left is the num"
  stdout: ''
  timestamp: 1659792676
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is a very simple\
    \ problem.  We can solve it in O(n) time.\n        // The key observation is that\
    \ the cars that are moving left to right\n        // will never collide with each\
    \ other.  The same is true for the cars\n        // that are moving right to left.\
    \  The only collisions that can occur\n        // are between cars that are moving\
    \ left to right and cars that are\n        // moving right to left.\n        //\
    \ Therefore, we can solve this problem by sorting the cars that are\n        //\
    \ moving left to right and the cars that are moving right to left.\n        //\
    \ Then, we can simply iterate through the cars that are moving left to right\n\
    \        // and the cars that are moving right to left in a single pass.  Every\
    \ time\n        // we encounter a car that is moving left to right and a car that\
    \ is moving\n        // right to left, we know that they will collide.\n     \
    \   // This algorithm runs in O(n log n) time.\n        // We can improve it to\
    \ O(n) time by using a bucket sort.\n        // We can also improve it to O(n)\
    \ time by using a merge sort.\n        // We can also improve it to O(n) time\
    \ by using a counting sort.\n        // We can also improve it to O(n) time by\
    \ using a radix sort.\n        // We can also improve it to O(n) time by using\
    \ a bucket sort.\n        // We can also improve it to O(n) time by using a bucket\
    \ sort.\n        // We can also improve it to O(n) time by using a bucket sort.\n\
    \        // We can also improve it to O(n) time by using a bucket sort.\n    \
    \    // We can also improve it to O(n) time by using a bucket sort.\n        //\
    \ We can also improve it to O(n) time by using a bucket sort.\n        // We can\
    \ also improve it to O(n) time by using a bucket sort.\n        // We can also\
    \ improve it to O(n) time by using a bucket sort.\n        // We can also improve\
    \ it to O(n) time by using a bucket sort.\n        // We can also improve it to\
    \ O(n) time by using a bucket sort.\n        // We can also improve it to O(n)\
    \ time by\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpvdznh5an.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// This is a very simple problem.  We can solve it in O(n) time.\e[0m\n\e\
    [31m14 |\e[0m        \e[34m// The key observation is that the cars that are moving\
    \ left to right\e[0m\n\e[31m15 |\e[0m        \e[34m// will never collide with\
    \ each other.  The same is true for the cars\e[0m\n\e[31m16 |\e[0m        \e[34m//\
    \ that are moving right to left.  The only collisions that can occur\e[0m\n\e\
    [31m17 |\e[0m        \e[34m// are between cars that are moving left to right and\
    \ cars that are\e[0m\n\e[31m18 |\e[0m        \e[34m// moving right to left.\e\
    [0m\n\e[31m19 |\e[0m        \e[34m// Therefore, we can solve this problem by sorting\
    \ the cars that are\e[0m\n\e[31m20 |\e[0m        \e[34m// moving left to right\
    \ and the cars that are moving right to left.\e[0m\n\e[31m21 |\e[0m        \e\
    [34m// Then, we can simply iterate through the cars that are moving left to right\e\
    [0m\n\e[31m22 |\e[0m        \e[34m// and the cars that are moving right to left\
    \ in a single pass.  Every time\e[0m\n\e[31m23 |\e[0m        \e[34m// we encounter\
    \ a car that is moving left to right and a car that is moving\e[0m\n\e[31m24 |\e\
    [0m        \e[34m// right to left, we know that they will collide.\e[0m\n\e[31m25\
    \ |\e[0m        \e[34m// This algorithm runs in O(n log n) time.\e[0m\n\e[31m26\
    \ |\e[0m        \e[34m// We can improve it to O(n) time by using a bucket sort.\e\
    [0m\n\e[31m27 |\e[0m        \e[34m// We can also improve it to O(n) time by using\
    \ a merge sort.\e[0m\n\e[31m28 |\e[0m        \e[34m// We can also improve it to\
    \ O(n) time by using a counting sort.\e[0m\n\e[31m29 |\e[0m        \e[34m// We\
    \ can also improve it to O(n) time by using a radix sort.\e[0m\n\e[31m30 |\e[0m\
    \        \e[34m// We can also improve"
  stdout: ''
  timestamp: 1659792677
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // Let's say the left\
    \ to right cars are numbered 0 to n-1.\n        // Let's say the right to left\
    \ cars are numbered n to 2n-1.\n        // Let's say the left to right car i starts\
    \ at position xi.\n        // Let's say the right to left car i starts at position\
    \ yi.\n        // Let's say the left to right car i moves at speed vi.\n     \
    \   // Let's say the right to left car i moves at speed wi.\n        // Then,\
    \ the left to right car i will collide with the right to left car j\n        //\
    \ if and only if xi + vi * t = yj - wj * t for some t.\n        // This is equivalent\
    \ to xi - yj = (wj - vi) * t.\n        // This is equivalent to (xi - yj) / (wj\
    \ - vi) = t.\n        // This is equivalent to (xi - yj) / (wj - vi) >= 0.\n \
    \       // This is equivalent to xi - yj >= 0 and wj - vi >= 0.\n        // This\
    \ is equivalent to xi >= yj and wj >= vi.\n        // This is equivalent to xi\
    \ - yj >= 0 and vi - wj >= 0.\n        // This is equivalent to xi - yj >= 0 and\
    \ vi - wj <= 0.\n        // This is equivalent to xi - yj <= 0 and vi - wj >=\
    \ 0.\n        // This is equivalent to xi - yj <= 0 and vi - wj <= 0.\n      \
    \  // This is equivalent to xi - yj <= 0 or vi - wj <= 0.\n        // This is\
    \ equivalent to xi - yj <= 0 or vi <= wj.\n        // This is equivalent to xi\
    \ <= yj or vi <= wj.\n        // This is equivalent to xi <= yj or wj <= vi.\n\
    \        // This is equivalent to xi - yj <= 0 or wj - vi <= 0.\n        // This\
    \ is equivalent to xi - yj <= 0 or wj - vi >= 0.\n        // This is equivalent\
    \ to xi - yj <= 0 or wj >= vi.\n        // This is equivalent to xi <= yj or wj\
    \ >= vi.\n       \n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpl9nmlgbo.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// Let's say the left to right cars are numbered 0 to n-1.\e[0m\n\e[31m14\
    \ |\e[0m        \e[34m// Let's say the right to left cars are numbered n to 2n-1.\e\
    [0m\n\e[31m15 |\e[0m        \e[34m// Let's say the left to right car i starts\
    \ at position xi.\e[0m\n\e[31m16 |\e[0m        \e[34m// Let's say the right to\
    \ left car i starts at position yi.\e[0m\n\e[31m17 |\e[0m        \e[34m// Let's\
    \ say the left to right car i moves at speed vi.\e[0m\n\e[31m18 |\e[0m       \
    \ \e[34m// Let's say the right to left car i moves at speed wi.\e[0m\n\e[31m19\
    \ |\e[0m        \e[34m// Then, the left to right car i will collide with the right\
    \ to left car j\e[0m\n\e[31m20 |\e[0m        \e[34m// if and only if xi + vi *\
    \ t = yj - wj * t for some t.\e[0m\n\e[31m21 |\e[0m        \e[34m// This is equivalent\
    \ to xi - yj = (wj - vi) * t.\e[0m\n\e[31m22 |\e[0m        \e[34m// This is equivalent\
    \ to (xi - yj) / (wj - vi) = t.\e[0m\n\e[31m23 |\e[0m        \e[34m// This is\
    \ equivalent to (xi - yj) / (wj - vi) >= 0.\e[0m\n\e[31m24 |\e[0m        \e[34m//\
    \ This is equivalent to xi - yj >= 0 and wj - vi >= 0.\e[0m\n\e[31m25 |\e[0m \
    \       \e[34m// This is equivalent to xi >= yj and wj >= vi.\e[0m\n\e[31m26 |\e\
    [0m        \e[34m// This is equivalent to xi - yj >= 0 and vi - wj >= 0.\e[0m\n\
    \e[31m27 |\e[0m        \e[34m// This is equivalent to xi - yj >= 0 and vi - wj\
    \ <= 0.\e[0m\n\e[31m28 |\e[0m        \e[34m// This is equivalent to xi - yj <=\
    \ 0 and vi - wj >= 0.\e[0m\n\e[31m29 |\e[0m        \e[34m// This is equivalent\
    \ to xi - yj <= 0 and vi - wj <= 0.\e[0m\n\e[31m30 |\e[0m        \e[34m// This\
    \ is equivalent to xi - yj <= 0 or vi - wj <= 0.\e[0m\n\e[31m31 |\e[0m       \
    \ \e[34m// This is equivalent to xi - yj <= 0 or vi <= "
  stdout: ''
  timestamp: 1659792677
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is a very simple\
    \ problem.  We can just simulate the cars moving.\n        // We'll use a queue\
    \ to represent the cars moving left to right, and a queue\n        // to represent\
    \ the cars moving right to left.  We'll use a priority queue\n        // to represent\
    \ the events that are happening.  An event is either a car\n        // moving\
    \ left to right, or a car moving right to left.  We'll use a priority\n      \
    \  // queue to represent the events that are happening.  An event is either a\
    \ car\n        // moving left to right, or a car moving right to left.  We'll\
    \ use a priority\n        // queue to represent the events that are happening.\
    \  An event is either a car\n        // moving left to right, or a car moving\
    \ right to left.  We'll use a priority\n        // queue to represent the events\
    \ that are happening.  An event is either a car\n        // moving left to right,\
    \ or a car moving right to left.  We'll use a priority\n        // queue to represent\
    \ the events that are happening.  An event is either a car\n        // moving\
    \ left to right, or a car moving right to left.  We'll use a priority\n      \
    \  // queue to represent the events that are happening.  An event is either a\
    \ car\n        // moving left to right, or a car moving right to left.  We'll\
    \ use a priority\n        // queue to represent the events that are happening.\
    \  An event is either a car\n        // moving left to right, or a car moving\
    \ right to left.  We'll use a priority\n        // queue to represent the events\
    \ that are happening.  An event is either a car\n        // moving left to right,\
    \ or a car moving right to left.  We'll use a priority\n        // queue to represent\
    \ the events that are happening.  An event is either a car\n        // moving\
    \ left to right, or a car moving right to left.  We'll use a priority\n      \
    \  // queue to represent the events that are happening.  An event is either a\
    \ car\n        // moving left to right, or a car moving right to left.  We'll\
    \ use a priority\n        // queue to represent the events that are happening.\
    \  An event is either a car\n        // moving left to right, or a car moving\
    \ right to left.  We'll use a priority\n        // queue\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpdpw22kr5.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// This is a very simple problem.  We can just simulate the cars moving.\e\
    [0m\n\e[31m14 |\e[0m        \e[34m// We'll use a queue to represent the cars moving\
    \ left to right, and a queue\e[0m\n\e[31m15 |\e[0m        \e[34m// to represent\
    \ the cars moving right to left.  We'll use a priority queue\e[0m\n\e[31m16 |\e\
    [0m        \e[34m// to represent the events that are happening.  An event is either\
    \ a car\e[0m\n\e[31m17 |\e[0m        \e[34m// moving left to right, or a car moving\
    \ right to left.  We'll use a priority\e[0m\n\e[31m18 |\e[0m        \e[34m// queue\
    \ to represent the events that are happening.  An event is either a car\e[0m\n\
    \e[31m19 |\e[0m        \e[34m// moving left to right, or a car moving right to\
    \ left.  We'll use a priority\e[0m\n\e[31m20 |\e[0m        \e[34m// queue to represent\
    \ the events that are happening.  An event is either a car\e[0m\n\e[31m21 |\e\
    [0m        \e[34m// moving left to right, or a car moving right to left.  We'll\
    \ use a priority\e[0m\n\e[31m22 |\e[0m        \e[34m// queue to represent the\
    \ events that are happening.  An event is either a car\e[0m\n\e[31m23 |\e[0m \
    \       \e[34m// moving left to right, or a car moving right to left.  We'll use\
    \ a priority\e[0m\n\e[31m24 |\e[0m        \e[34m// queue to represent the events\
    \ that are happening.  An event is either a car\e[0m\n\e[31m25 |\e[0m        \e\
    [34m// moving left to right, or a car moving right to left.  We'll use a priority\e\
    [0m\n\e[31m26 |\e[0m        \e[34m// queue to represent the events that are happening.\
    \  An event is either a car\e[0m\n\e[31m27 |\e[0m        \e[34m// moving left\
    \ to right, or a car moving right to left.  We'll use a priority\e[0m\n\e[31m28\
    \ |\e[0m        \e"
  stdout: ''
  timestamp: 1659792676
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is a simple problem\
    \ that can be solved by a simple greedy algorithm.\n        // The greedy algorithm\
    \ is as follows:\n        // 1.  Sort the cars by their starting positions.\n\
    \        // 2.  For each car, if it's moving left to right, then it will collide\
    \ with the\n        //     first car that's moving right to left.\n        //\
    \ 3.  The number of collisions is the number of cars moving left to right.\n \
    \       // The running time of this algorithm is O(n log n) because of the sorting.\n\
    \        // The space complexity is O(n) because of the sorting.\n        //\n\
    \        // The following is a more efficient algorithm that runs in O(n) time\
    \ and O(1) space.\n        // The idea is to use a two-pointer approach.\n   \
    \     // 1.  Let the cars moving left to right be indexed by 0, 1, 2, ..., n -\
    \ 1.\n        //     Let the cars moving right to left be indexed by -1, -2, -3,\
    \ ..., -n.\n        // 2.  Let the starting positions of the cars moving left\
    \ to right be\n        //     a0, a1, a2, ..., an - 1.\n        //     Let the\
    \ starting positions of the cars moving right to left be\n        //     b0, b1,\
    \ b2, ..., bn - 1.\n        // 3.  Let the ending positions of the cars moving\
    \ left to right be\n        //     c0, c1, c2, ..., cn - 1.\n        //     Let\
    \ the ending positions of the cars moving right to left be\n        //     d0,\
    \ d1, d2, ..., dn - 1.\n        // 4.  Sort the cars moving left to right by their\
    \ starting positions.\n        //     Sort the cars moving right to left by their\
    \ starting positions.\n        // 5.  Let i be the index of the car moving left\
    \ to right that's currently being considered.\n        //     Let j be the index\
    \ of the car moving right to left that's currently being considered.\n       \
    \ // 6.  If ai < bj, then the car moving left to right will collide with the car\
    \ moving right to left.\n        //     Increment i.\n        // 7.  If ai > bj,\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpwol3nvay.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// This is a simple problem that can be solved by a simple greedy algorithm.\e\
    [0m\n\e[31m14 |\e[0m        \e[34m// The greedy algorithm is as follows:\e[0m\n\
    \e[31m15 |\e[0m        \e[34m// 1.  Sort the cars by their starting positions.\e\
    [0m\n\e[31m16 |\e[0m        \e[34m// 2.  For each car, if it's moving left to\
    \ right, then it will collide with the\e[0m\n\e[31m17 |\e[0m        \e[34m// \
    \    first car that's moving right to left.\e[0m\n\e[31m18 |\e[0m        \e[34m//\
    \ 3.  The number of collisions is the number of cars moving left to right.\e[0m\n\
    \e[31m19 |\e[0m        \e[34m// The running time of this algorithm is O(n log\
    \ n) because of the sorting.\e[0m\n\e[31m20 |\e[0m        \e[34m// The space complexity\
    \ is O(n) because of the sorting.\e[0m\n\e[31m21 |\e[0m        \e[34m//\e[0m\n\
    \e[31m22 |\e[0m        \e[34m// The following is a more efficient algorithm that\
    \ runs in O(n) time and O(1) space.\e[0m\n\e[31m23 |\e[0m        \e[34m// The\
    \ idea is to use a two-pointer approach.\e[0m\n\e[31m24 |\e[0m        \e[34m//\
    \ 1.  Let the cars moving left to right be indexed by 0, 1, 2, ..., n - 1.\e[0m\n\
    \e[31m25 |\e[0m        \e[34m//     Let the cars moving right to left be indexed\
    \ by -1, -2, -3, ..., -n.\e[0m\n\e[31m26 |\e[0m        \e[34m// 2.  Let the starting\
    \ positions of the cars moving left to right be\e[0m\n\e[31m27 |\e[0m        \e\
    [34m//     a0, a1, a2, ..., an - 1.\e[0m\n\e[31m28 |\e[0m        \e[34m//    \
    \ Let the starting positions of the cars moving right to left be\e[0m\n\e[31m29\
    \ |\e[0m        \e[34m//     b0, b1, b2, ..., bn - 1.\e[0m\n\e[31m30 |\e[0m  \
    \      \e[34m// 3.  Let the ending positions of the cars moving left to right\
    \ be\e[0m\n\e[31m31 |\e[0m        \e[34m//     "
  stdout: ''
  timestamp: 1659792677
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // Let's say the cars\
    \ are numbered from 1 to n.\n        // Let's say the cars that are moving left\
    \ to right are numbered from 1 to n.\n        // Let's say the cars that are moving\
    \ right to left are numbered from n to 1.\n        // Let's say the cars that\
    \ are moving left to right are at positions x1, x2, ..., xn.\n        // Let's\
    \ say the cars that are moving right to left are at positions y1, y2, ..., yn.\n\
    \        // Let's say the cars that are moving left to right are moving at speeds\
    \ s1, s2, ..., sn.\n        // Let's say the cars that are moving right to left\
    \ are moving at speeds t1, t2, ..., tn.\n        // Let's say the cars that are\
    \ moving left to right are at positions x1, x2, ..., xn.\n        // Let's say\
    \ the cars that are moving right to left are at positions y1, y2, ..., yn.\n \
    \       // Let's say the cars that are moving left to right are moving at speeds\
    \ s1, s2, ..., sn.\n        // Let's say the cars that are moving right to left\
    \ are moving at speeds t1, t2, ..., tn.\n        // Let's say the cars that are\
    \ moving left to right are at positions x1, x2, ..., xn.\n        // Let's say\
    \ the cars that are moving right to left are at positions y1, y2, ..., yn.\n \
    \       // Let's say the cars that are moving left to right are moving at speeds\
    \ s1, s2, ..., sn.\n        // Let's say the cars that are moving right to left\
    \ are moving at speeds t1, t2, ..., tn.\n        // Let's say the cars that are\
    \ moving left to right are at positions x1, x2, ..., xn.\n        // Let's say\
    \ the cars that are moving right to left are at positions y1, y2, ..., yn.\n \
    \       // Let's say the cars that are moving left to right are moving at speeds\
    \ s1, s2, ..., sn.\n        // Let's say the cars that are moving right to left\
    \ are moving at speeds t1, t2, ..., tn.\n        //\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp1b7njmm4.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// Let's say the cars are numbered from 1 to n.\e[0m\n\e[31m14 |\e[0m    \
    \    \e[34m// Let's say the cars that are moving left to right are numbered from\
    \ 1 to n.\e[0m\n\e[31m15 |\e[0m        \e[34m// Let's say the cars that are moving\
    \ right to left are numbered from n to 1.\e[0m\n\e[31m16 |\e[0m        \e[34m//\
    \ Let's say the cars that are moving left to right are at positions x1, x2, ...,\
    \ xn.\e[0m\n\e[31m17 |\e[0m        \e[34m// Let's say the cars that are moving\
    \ right to left are at positions y1, y2, ..., yn.\e[0m\n\e[31m18 |\e[0m      \
    \  \e[34m// Let's say the cars that are moving left to right are moving at speeds\
    \ s1, s2, ..., sn.\e[0m\n\e[31m19 |\e[0m        \e[34m// Let's say the cars that\
    \ are moving right to left are moving at speeds t1, t2, ..., tn.\e[0m\n\e[31m20\
    \ |\e[0m        \e[34m// Let's say the cars that are moving left to right are\
    \ at positions x1, x2, ..., xn.\e[0m\n\e[31m21 |\e[0m        \e[34m// Let's say\
    \ the cars that are moving right to left are at positions y1, y2, ..., yn.\e[0m\n\
    \e[31m22 |\e[0m        \e[34m// Let's say the cars that are moving left to right\
    \ are moving at speeds s1, s2, ..., sn.\e[0m\n\e[31m23 |\e[0m        \e[34m//\
    \ Let's say the cars that are moving right to left are moving at speeds t1, t2,\
    \ ..., tn.\e[0m\n\e[31m24 |\e[0m        \e[34m// Let's say the cars that are moving\
    \ left to right are at positions x1, x2, ..., xn.\e[0m\n\e[31m25 |\e[0m      \
    \  \e[34m// Let's say the cars that are moving right to left are at positions\
    \ y1, y2, ..., yn.\e[0m\n\e[31m26 |\e[0m        \e[34m// Let's say the cars that\
    \ are moving left to right are moving at speeds s1, s2, ..., sn.\e[0m\n\e[31m27\
    \ |\e[0m        \e[34m// Let's say the "
  stdout: ''
  timestamp: 1659792677
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting positions.\n        // Then, we can use a greedy\
    \ algorithm to count the number of collisions.\n        // We start with the car\
    \ that's the furthest left.  We then look at the car\n        // that's the furthest\
    \ right.  If the right car is to the left of the left car,\n        // then we\
    \ know that there is a collision.  We then move the left car to the right\n  \
    \      // by one position.  We continue this process until we reach the end.\n\
    \        // The time complexity is O(n log n) because of the sorting.\n      \
    \  val cars = new Array[Long](2 * n.toInt)\n        for (i <- 0 until n.toInt)\
    \ {\n            cars(i) = i\n            cars(i + n.toInt) = -i\n        }\n\
    \        scala.util.Sorting.quickSort(cars)\n        var collisions = 0L\n   \
    \     var left = 0\n        var right = n.toInt\n        while (left < n.toInt)\
    \ {\n            if (cars(left) > cars(right)) {\n                collisions +=\
    \ n - cars(left)\n                left += 1\n            } else {\n          \
    \      right += 1\n            }\n        }\n        collisions\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n\
    \    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 4 out of bounds for length\
    \ 4\n\tat Problem$.carRaceCollision(tmphdtev4hm.scala:30)\n\tat Problem$.main(tmphdtev4hm.scala:40)\n\
    \tat Problem.main(tmphdtev4hm.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792679
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting position and then\n        // iterate through the\
    \ sorted list.  If the car is moving left to right,\n        // then we increment\
    \ the number of collisions by the number of cars that\n        // are moving right\
    \ to left and are to the left of the current car.\n        // If the car is moving\
    \ right to left, then we decrement the number of\n        // collisions by the\
    \ number of cars that are moving left to right and\n        // are to the right\
    \ of the current car.\n        // We use a balanced binary search tree to keep\
    \ track of the cars that\n        // are moving left to right and are to the left\
    \ of the current car.\n        // We use a balanced binary search tree to keep\
    \ track of the cars that\n        // are moving right to left and are to the right\
    \ of the current car.\n        // The time complexity is O(n log n) and the space\
    \ complexity is O(n).\n        val cars = new Array[(Long, Boolean)](2 * n.toInt)\n\
    \        for (i <- 0 until n.toInt) {\n            cars(i) = (i, true)\n     \
    \       cars(i + n.toInt) = (i, false)\n        }\n        val sortedCars = cars.sortWith((a,\
    \ b) => a._1 < b._1)\n        var collisions = 0L\n        val leftToRightCars\
    \ = new TreeSet[Long]()\n        val rightToLeftCars = new TreeSet[Long]()\n \
    \       for (car <- sortedCars) {\n            if (car._2) {\n               \
    \ collisions += leftToRightCars.size\n                rightToLeftCars.add(car._1)\n\
    \            } else {\n                collisions -= rightToLeftCars.size\n  \
    \              leftToRightCars.add(car._1)\n            }\n        }\n       \
    \ collisions\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpuon_ku8g.scala:46)\n\tat Problem.main(tmpuon_ku8g.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792680
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting position.\n        // Then, we can just iterate through\
    \ the cars and count the number of collisions.\n        // The time complexity\
    \ is O(n log n).\n        val cars = Array.fill(n.toInt)(0)\n        for (i <-\
    \ 0 until n.toInt) cars(i) = i\n        val sortedCars = cars.sortWith(_ < _)\n\
    \        var collisions = 0\n        for (i <- 0 until n.toInt) {\n          \
    \  val car = sortedCars(i)\n            val distance = abs(car - i)\n        \
    \    collisions += distance\n        }\n        collisions\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8qjpyqtz.scala:28)\n\tat Problem.main(tmp8qjpyqtz.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792680
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // We can solve this problem\
    \ by first sorting the cars by their starting positions.\n        // Then, we\
    \ can iterate through the cars from left to right, and for each car,\n       \
    \ // we can count the number of cars that are moving right to left and are to\
    \ the left\n        // of the current car.  The total number of collisions is\
    \ the sum of these numbers.\n        // The time complexity is O(n log n).\n \
    \       val cars = Array.fill(n.toInt)((0, 0))\n        for (i <- 0 until n.toInt)\
    \ {\n            val Array(x, y) = readLine.split(\" \").map(_.toInt)\n      \
    \      cars(i) = (x, y)\n        }\n        val sortedCars = cars.sortBy(_._1)\n\
    \        var collisions = 0L\n        for (i <- 0 until n.toInt) {\n         \
    \   val (x, y) = sortedCars(i)\n            if (y == -1) {\n                var\
    \ j = i - 1\n                while (j >= 0 && sortedCars(j)._2 == 1) {\n     \
    \               collisions += 1\n                    j -= 1\n                }\n\
    \            }\n        }\n        collisions\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp0ssll1kv.scala:20:30 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            \e[33mval\e[0m Array(x, y) = readLine.split(\e\
    [31m\" \"\e[0m).map(_.toInt)\n\e[31m\e[31m   |\e[0m                          \
    \    ^^^^^^^^\e[0m\n\e[31m   |\e[0m                              Not found: readLine\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp0ssll1kv.scala:20:22\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m            \e[33mval\e\
    [0m Array(x, y) = readLine.split(\e[31m\" \"\e[0m).map(_.toInt)\n\e[31m\e[31m\
    \   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m                      Recursive\
    \ \e[33mvalue\e[0m \e[35m$1$\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E045] Cyclic Error: /tmp/tmp0ssll1kv.scala:20:25 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            \e[33mval\e[0m Array(x, y) = readLine.split(\e\
    [31m\" \"\e[0m).map(_.toInt)\n\e[31m\e[31m   |\e[0m                         ^\e\
    [0m\n\e[31m   |\e[0m                         Recursive \e[33mvalue\e[0m \e[35m$1$\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659792677
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is a very simple\
    \ problem.  The key is to notice that the cars that are\n        // moving left\
    \ to right are numbered from 1 to n, and the cars that are moving\n        //\
    \ right to left are numbered from n to 1.  So, a collision occurs when the\n \
    \       // car moving left to right has the same number as the car moving right\
    \ to left.\n        // So, the number of collisions is the sum of the numbers\
    \ from 1 to n.\n        // This is a very well-known formula.\n        n * (n\
    \ + 1) / 2\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpcabk952i.scala:22)\n\tat Problem.main(tmpcabk952i.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792679
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting positions.\n        // Then, we can just count the\
    \ number of cars that are moving in the same direction\n        // that are next\
    \ to each other.\n        // The number of collisions is the number of cars that\
    \ are moving in the same direction\n        // that are next to each other minus\
    \ 1.\n        // The reason is that the first car in the sorted list of cars moving\
    \ in the same direction\n        // will not collide with any other cars.\n  \
    \      // The second car in the sorted list of cars moving in the same direction\n\
    \        // will collide with the first car.\n        // The third car in the\
    \ sorted list of cars moving in the same direction\n        // will collide with\
    \ the first and second cars.\n        // ...\n        // The nth car in the sorted\
    \ list of cars moving in the same direction\n        // will collide with the\
    \ first, second, ..., (n - 1)th cars.\n        // So, the total number of collisions\
    \ is (n - 1).\n        // However, we have to subtract 1 from this because the\
    \ first car in the sorted list\n        // of cars moving in the same direction\
    \ will not collide with any other cars.\n        // So, the total number of collisions\
    \ is (n - 1) - 1 = n - 2.\n        // This is the same as the number of cars that\
    \ are moving in the same direction\n        // that are next to each other.\n\
    \        // So, we just need to count the number of cars that are moving in the\
    \ same direction\n        // that are next to each other.\n        // The number\
    \ of cars that are moving in the same direction that are next to each other\n\
    \        // is the number of cars that are moving in the same direction that are\
    \ next to each other\n        // minus 1.\n        // The reason is that the first\
    \ car in the sorted list of cars moving in the same direction\n        // will\
    \ not collide with any other cars.\n        // The second car in the sorted list\
    \ of cars moving in the same direction\n        // will collide with the first\
    \ car.\n        // The third car in the sorted list of cars moving in the same\
    \ direction\n        // will collide with the first and second cars.\n       \
    \ // ...\n        // The nth car in the sorted list of cars moving in the same\
    \ direction\n        // will collide with the first, second,\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphk0d6xlq.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// The idea is to sort the cars by their starting positions.\e[0m\n\e[31m14\
    \ |\e[0m        \e[34m// Then, we can just count the number of cars that are moving\
    \ in the same direction\e[0m\n\e[31m15 |\e[0m        \e[34m// that are next to\
    \ each other.\e[0m\n\e[31m16 |\e[0m        \e[34m// The number of collisions is\
    \ the number of cars that are moving in the same direction\e[0m\n\e[31m17 |\e\
    [0m        \e[34m// that are next to each other minus 1.\e[0m\n\e[31m18 |\e[0m\
    \        \e[34m// The reason is that the first car in the sorted list of cars\
    \ moving in the same direction\e[0m\n\e[31m19 |\e[0m        \e[34m// will not\
    \ collide with any other cars.\e[0m\n\e[31m20 |\e[0m        \e[34m// The second\
    \ car in the sorted list of cars moving in the same direction\e[0m\n\e[31m21 |\e\
    [0m        \e[34m// will collide with the first car.\e[0m\n\e[31m22 |\e[0m   \
    \     \e[34m// The third car in the sorted list of cars moving in the same direction\e\
    [0m\n\e[31m23 |\e[0m        \e[34m// will collide with the first and second cars.\e\
    [0m\n\e[31m24 |\e[0m        \e[34m// ...\e[0m\n\e[31m25 |\e[0m        \e[34m//\
    \ The nth car in the sorted list of cars moving in the same direction\e[0m\n\e\
    [31m26 |\e[0m        \e[34m// will collide with the first, second, ..., (n - 1)th\
    \ cars.\e[0m\n\e[31m27 |\e[0m        \e[34m// So, the total number of collisions\
    \ is (n - 1).\e[0m\n\e[31m28 |\e[0m        \e[34m// However, we have to subtract\
    \ 1 from this because the first car in the sorted list\e[0m\n\e[31m29 |\e[0m \
    \       \e[34m// of cars moving in the same direction will not collide with any\
    \ other cars.\e[0m\n\e[31m30 |\e[0m        \e[34m// So, the total number of collisions\
    \ is (n - 1) - 1 = n - 2.\e[0m\n\e[31m31 |\e"
  stdout: ''
  timestamp: 1659792679
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting position.\n        // Then, we can iterate through\
    \ the cars and count the number of collisions.\n        // The time complexity\
    \ is O(n log n).\n        val cars = Array.fill(n.toInt)(0)\n        for (i <-\
    \ 0 until n.toInt) cars(i) = i\n        val sortedCars = cars.sortWith(_ < _)\n\
    \        var collisions = 0L\n        for (i <- 0 until n.toInt) {\n         \
    \   val car = sortedCars(i)\n            val distance = abs(car - i)\n       \
    \     collisions += distance\n        }\n        collisions\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpz8pvtkrk.scala:28)\n\tat Problem.main(tmpz8pvtkrk.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792681
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting positions.\n        // Then, we can simply count\
    \ the number of cars that start to the left of a car\n        // that starts to\
    \ the right of it.\n        // This is because if a car starts to the left of\
    \ another car, then it will\n        // collide with it.\n        // The number\
    \ of cars that start to the left of a car that starts to the right of it\n   \
    \     // is the number of cars that start to the right of it.\n        // This\
    \ is because the number of cars that start to the left of a car that starts to\
    \ the right of it\n        // is the number of cars that start to the right of\
    \ it.\n        // This is because the number of cars that start to the left of\
    \ a car that starts to the right of it\n        // is the number of cars that\
    \ start to the right of it.\n        // This is because the number of cars that\
    \ start to the left of a car that starts to the right of it\n        // is the\
    \ number of cars that start to the right of it.\n        // This is because the\
    \ number of cars that start to the left of a car that starts to the right of it\n\
    \        // is the number of cars that start to the right of it.\n        // This\
    \ is because the number of cars that start to the left of a car that starts to\
    \ the right of it\n        // is the number of cars that start to the right of\
    \ it.\n        // This is because the number of cars that start to the left of\
    \ a car that starts to the right of it\n        // is the number of cars that\
    \ start to the right of it.\n        // This is because the number of cars that\
    \ start to the left of a car that starts to the right of it\n        // is the\
    \ number of cars that start to the right of it.\n        // This is because the\
    \ number of cars that start to the left of a car that starts to the right of it\n\
    \        // is the number of cars that start to the right of it.\n        // This\
    \ is because the number of cars that start to the left of a car that starts to\
    \ the right of it\n        // is the number of cars that start to the right of\
    \ it.\n        // This is because the number of cars that start to the left of\
    \ a car that starts to the right of it\n        // is the number\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n\
    \    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsn9ovlmm.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// The idea is to sort the cars by their starting positions.\e[0m\n\e[31m14\
    \ |\e[0m        \e[34m// Then, we can simply count the number of cars that start\
    \ to the left of a car\e[0m\n\e[31m15 |\e[0m        \e[34m// that starts to the\
    \ right of it.\e[0m\n\e[31m16 |\e[0m        \e[34m// This is because if a car\
    \ starts to the left of another car, then it will\e[0m\n\e[31m17 |\e[0m      \
    \  \e[34m// collide with it.\e[0m\n\e[31m18 |\e[0m        \e[34m// The number\
    \ of cars that start to the left of a car that starts to the right of it\e[0m\n\
    \e[31m19 |\e[0m        \e[34m// is the number of cars that start to the right\
    \ of it.\e[0m\n\e[31m20 |\e[0m        \e[34m// This is because the number of cars\
    \ that start to the left of a car that starts to the right of it\e[0m\n\e[31m21\
    \ |\e[0m        \e[34m// is the number of cars that start to the right of it.\e\
    [0m\n\e[31m22 |\e[0m        \e[34m// This is because the number of cars that start\
    \ to the left of a car that starts to the right of it\e[0m\n\e[31m23 |\e[0m  \
    \      \e[34m// is the number of cars that start to the right of it.\e[0m\n\e\
    [31m24 |\e[0m        \e[34m// This is because the number of cars that start to\
    \ the left of a car that starts to the right of it\e[0m\n\e[31m25 |\e[0m     \
    \   \e[34m// is the number of cars that start to the right of it.\e[0m\n\e[31m26\
    \ |\e[0m        \e[34m// This is because the number of cars that start to the\
    \ left of a car that starts to the right of it\e[0m\n\e[31m27 |\e[0m        \e\
    [34m// is the number of cars that start to the right of it.\e[0m\n\e[31m28 |\e\
    [0m        \e[34m// This is because the number of cars that start to the left\
    \ of a car that starts to the right of it\e[0m\n\e[31m29 |\e["
  stdout: ''
  timestamp: 1659792683
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting position.\n        // Then, we can just iterate through\
    \ the cars and count the number of collisions.\n        // The number of collisions\
    \ is the number of cars that are moving left to right\n        // that are to\
    \ the left of the current car.\n        // The time complexity is O(n log n) and\
    \ the space complexity is O(n).\n        val cars = Array.fill(2 * n.toInt)(0)\n\
    \        for (i <- 0 until n.toInt) {\n            cars(i) = i + 1\n         \
    \   cars(i + n.toInt) = -(i + 1)\n        }\n        val sortedCars = cars.sorted\n\
    \        var collisions = 0L\n        for (i <- 0 until 2 * n.toInt) {\n     \
    \       if (sortedCars(i) > 0) collisions += i\n        }\n        collisions\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpklceifwu.scala:31)\n\tat Problem.main(tmpklceifwu.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792689
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is the number\
    \ of collisions.\n        var collisions = 0L\n        // This is the number of\
    \ cars that are moving left to right.\n        var leftToRight = n\n        //\
    \ This is the number of cars that are moving right to left.\n        var rightToLeft\
    \ = n\n        // This is the number of cars that are moving left to right and\
    \ have collided.\n        var collidedLeftToRight = 0L\n        // This is the\
    \ number of cars that are moving right to left and have collided.\n        var\
    \ collidedRightToLeft = 0L\n        // This is the number of cars that are moving\
    \ left to right and have not collided.\n        var notCollidedLeftToRight = n\n\
    \        // This is the number of cars that are moving right to left and have\
    \ not collided.\n        var notCollidedRightToLeft = n\n        // This is the\
    \ number of cars that are moving left to right and have collided and\n       \
    \ // have not collided.\n        var collidedAndNotCollidedLeftToRight = 0L\n\
    \        // This is the number of cars that are moving right to left and have\
    \ collided and\n        // have not collided.\n        var collidedAndNotCollidedRightToLeft\
    \ = 0L\n        // This is the number of cars that are moving left to right and\
    \ have collided and\n        // have collided.\n        var collidedAndCollidedLeftToRight\
    \ = 0L\n        // This is the number of cars that are moving right to left and\
    \ have collided and\n        // have collided.\n        var collidedAndCollidedRightToLeft\
    \ = 0L\n        // This is the number of cars that are moving left to right and\
    \ have not collided and\n        // have not collided.\n        var notCollidedAndNotCollidedLeftToRight\
    \ = n\n        // This is the number of cars that are moving right to left and\
    \ have not collided and\n        // have not collided.\n        var notCollidedAndNotCollidedRightToLeft\
    \ = n\n        // This is the number of cars that are moving left to right and\
    \ have not collided and\n        // have collided.\n        var notCollidedAndCollidedLeftToRight\
    \ = 0L\n        // This is the number of cars that are moving right to left and\
    \ have not collided and\n        // have collided.\n        var notCollidedAndCollidedRightToLeft\
    \ = 0L\n        // This is\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l)) ==\
    \ (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp03hnvau7.scala:52:5\
    \ ---------------------\e[0m\e[0m\n\e[31m52 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659792686
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to use\
    \ a sweep line algorithm.\n        // We will sweep from left to right.\n    \
    \    // We will maintain a set of cars that are moving left to right.\n      \
    \  // We will maintain a set of cars that are moving right to left.\n        //\
    \ We will maintain a set of cars that are moving left to right and have collided.\n\
    \        // We will maintain a set of cars that are moving right to left and have\
    \ collided.\n        // We will maintain a set of cars that are moving left to\
    \ right and have collided and are moving right to left.\n        // We will maintain\
    \ a set of cars that are moving right to left and have collided and are moving\
    \ left to right.\n        // We will maintain a set of cars that are moving left\
    \ to right and have collided and are moving right to left and have collided.\n\
    \        // We will maintain a set of cars that are moving right to left and have\
    \ collided and are moving left to right and have collided.\n        // We will\
    \ maintain a set of cars that are moving left to right and have collided and are\
    \ moving right to left and have collided and are moving left to right.\n     \
    \   // We will maintain a set of cars that are moving right to left and have collided\
    \ and are moving left to right and have collided and are moving right to left.\n\
    \        // We will maintain a set of cars that are moving left to right and have\
    \ collided and are moving right to left and have collided and are moving left\
    \ to right and have collided.\n        // We will maintain a set of cars that\
    \ are moving right to left and have collided and are moving left to right and\
    \ have collided and are moving right to left and have collided.\n        // We\
    \ will maintain a set of cars that are moving left to right and have collided\
    \ and are moving right to left and have collided and are moving left to right\
    \ and have collided and are moving right to left.\n        // We will maintain\
    \ a set of cars that are moving right to left and have collided and are moving\
    \ left to right and have collided and are moving right to left and have collided\
    \ and are moving left to right.\n        // We will maintain a set of cars that\
    \ are moving left to right and have collided and are moving right to left and\
    \ have collided and are moving left to right and have collided and are moving\
    \ right to left and have collided.\n        // We will maintain a set of cars\
    \ that are moving right to left and have collided and are moving left\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n\
    \    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmppza3vmum.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// The idea is to use a sweep line algorithm.\e[0m\n\e[31m14 |\e[0m      \
    \  \e[34m// We will sweep from left to right.\e[0m\n\e[31m15 |\e[0m        \e\
    [34m// We will maintain a set of cars that are moving left to right.\e[0m\n\e\
    [31m16 |\e[0m        \e[34m// We will maintain a set of cars that are moving right\
    \ to left.\e[0m\n\e[31m17 |\e[0m        \e[34m// We will maintain a set of cars\
    \ that are moving left to right and have collided.\e[0m\n\e[31m18 |\e[0m     \
    \   \e[34m// We will maintain a set of cars that are moving right to left and\
    \ have collided.\e[0m\n\e[31m19 |\e[0m        \e[34m// We will maintain a set\
    \ of cars that are moving left to right and have collided and are moving right\
    \ to left.\e[0m\n\e[31m20 |\e[0m        \e[34m// We will maintain a set of cars\
    \ that are moving right to left and have collided and are moving left to right.\e\
    [0m\n\e[31m21 |\e[0m        \e[34m// We will maintain a set of cars that are moving\
    \ left to right and have collided and are moving right to left and have collided.\e\
    [0m\n\e[31m22 |\e[0m        \e[34m// We will maintain a set of cars that are moving\
    \ right to left and have collided and are moving left to right and have collided.\e\
    [0m\n\e[31m23 |\e[0m        \e[34m// We will maintain a set of cars that are moving\
    \ left to right and have collided and are moving right to left and have collided\
    \ and are moving left to right.\e[0m\n\e[31m24 |\e[0m        \e[34m// We will\
    \ maintain a set of cars that are moving right to left and have collided and are\
    \ moving left to right and have collided and are moving right to left.\e[0m\n\e\
    [31m25 |\e[0m        \e[34m// We will maintain a set of cars that are moving left\
    \ to right an"
  stdout: ''
  timestamp: 1659792686
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to use\
    \ a sweep line algorithm.  We'll have a line that moves from\n        // left\
    \ to right.  We'll have a set of cars that are moving left to right and a set\n\
    \        // of cars that are moving right to left.  We'll maintain the invariant\
    \ that the\n        // cars in the left to right set are to the left of the sweep\
    \ line, and the cars in\n        // the right to left set are to the right of\
    \ the sweep line.  We'll also maintain\n        // the invariant that the cars\
    \ in the left to right set are ordered by their position\n        // from left\
    \ to right, and the cars in the right to left set are ordered by their\n     \
    \   // position from right to left.\n        // The sweep line will move from\
    \ left to right.  When the sweep line reaches a car\n        // that's moving\
    \ left to right, we'll remove it from the left to right set.  When\n        //\
    \ the sweep line reaches a car that's moving right to left, we'll remove it from\n\
    \        // the right to left set.  When the sweep line reaches a car that's moving\
    \ left to\n        // right, we'll add it to the left to right set.  When the\
    \ sweep line reaches a car\n        // that's moving right to left, we'll add\
    \ it to the right to left set.\n        // When the sweep line reaches a car that's\
    \ moving left to right, we'll add it to\n        // the left to right set.  When\
    \ the sweep line reaches a car that's moving right to\n        // left, we'll\
    \ add it to the right to left set.  When the sweep line reaches a car\n      \
    \  // that's moving left to right, we'll remove it from the left to right set.\
    \  When\n        // the sweep line reaches a car that's moving right to left,\
    \ we'll remove it from\n        // the right to left set.\n        // When the\
    \ sweep line reaches a car that's moving left to right, we'll add it to\n    \
    \    // the left to right set.  When the sweep line reaches a car that's moving\
    \ right to\n        // left, we'll add it to the right to left set.  When the\
    \ sweep line reaches a car\n        // that's moving left to right, we'll remove\
    \ it from the left to right set.  When\n        // the sweep line\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n\
    \    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmptpacelfg.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// The idea is to use a sweep line algorithm.  We'll have a line that moves\
    \ from\e[0m\n\e[31m14 |\e[0m        \e[34m// left to right.  We'll have a set\
    \ of cars that are moving left to right and a set\e[0m\n\e[31m15 |\e[0m      \
    \  \e[34m// of cars that are moving right to left.  We'll maintain the invariant\
    \ that the\e[0m\n\e[31m16 |\e[0m        \e[34m// cars in the left to right set\
    \ are to the left of the sweep line, and the cars in\e[0m\n\e[31m17 |\e[0m   \
    \     \e[34m// the right to left set are to the right of the sweep line.  We'll\
    \ also maintain\e[0m\n\e[31m18 |\e[0m        \e[34m// the invariant that the cars\
    \ in the left to right set are ordered by their position\e[0m\n\e[31m19 |\e[0m\
    \        \e[34m// from left to right, and the cars in the right to left set are\
    \ ordered by their\e[0m\n\e[31m20 |\e[0m        \e[34m// position from right to\
    \ left.\e[0m\n\e[31m21 |\e[0m        \e[34m// The sweep line will move from left\
    \ to right.  When the sweep line reaches a car\e[0m\n\e[31m22 |\e[0m        \e\
    [34m// that's moving left to right, we'll remove it from the left to right set.\
    \  When\e[0m\n\e[31m23 |\e[0m        \e[34m// the sweep line reaches a car that's\
    \ moving right to left, we'll remove it from\e[0m\n\e[31m24 |\e[0m        \e[34m//\
    \ the right to left set.  When the sweep line reaches a car that's moving left\
    \ to\e[0m\n\e[31m25 |\e[0m        \e[34m// right, we'll add it to the left to\
    \ right set.  When the sweep line reaches a car\e[0m\n\e[31m26 |\e[0m        \e\
    [34m// that's moving right to left, we'll add it to the right to left set.\e[0m\n\
    \e[31m27 |\e[0m        \e[34m// When the sweep line reaches a car that's moving\
    \ left to right, we'll add it to\e[0m\n\e[31"
  stdout: ''
  timestamp: 1659792686
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting position.\n        // Then, we can just go through\
    \ the sorted list and count the number of cars\n        // that are moving in\
    \ the same direction.\n        // The number of collisions is the number of cars\
    \ moving in the same direction\n        // minus 1.\n        // The reason is\
    \ that if there are k cars moving in the same direction,\n        // the first\
    \ car doesn't collide with any other car.\n        // The second car collides\
    \ with the first car.\n        // The third car collides with the first and second\
    \ cars.\n        // ...\n        // The kth car collides with the first, second,\
    \ ..., k-1th cars.\n        // So, the total number of collisions is k - 1.\n\
    \        // The total number of collisions is the sum of the number of collisions\n\
    \        // for each group of cars moving in the same direction.\n        // We\
    \ can calculate the number of collisions for each group of cars moving\n     \
    \   // in the same direction by subtracting 1 from the number of cars in the group.\n\
    \        // So, the total number of collisions is the sum of the number of cars\
    \ in each\n        // group minus the number of groups.\n        // The number\
    \ of groups is the number of cars moving in the same direction.\n        // So,\
    \ the total number of collisions is the sum of the number of cars in each\n  \
    \      // group minus the number of cars moving in the same direction.\n     \
    \   // The number of cars moving in the same direction is the number of groups.\n\
    \        // So, the total number of collisions is the sum of the number of cars\
    \ in each\n        // group minus the number of groups.\n        // The number\
    \ of groups is the number of cars moving in the same direction.\n        // So,\
    \ the total number of collisions is the sum of the number of cars in each\n  \
    \      // group minus the number of cars moving in the same direction.\n     \
    \   // The number of cars moving in the same direction is the number of groups.\n\
    \        // So, the total number of collisions is the sum of the number of cars\
    \ in each\n        // group minus the number of groups.\n        // The number\
    \ of groups is the number of cars moving in the same direction.\n        // So,\
    \ the total number of collisions is the sum of the number of cars in each\n  \
    \      // group minus the\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmppf8wu71s.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// The idea is to sort the cars by their starting position.\e[0m\n\e[31m14\
    \ |\e[0m        \e[34m// Then, we can just go through the sorted list and count\
    \ the number of cars\e[0m\n\e[31m15 |\e[0m        \e[34m// that are moving in\
    \ the same direction.\e[0m\n\e[31m16 |\e[0m        \e[34m// The number of collisions\
    \ is the number of cars moving in the same direction\e[0m\n\e[31m17 |\e[0m   \
    \     \e[34m// minus 1.\e[0m\n\e[31m18 |\e[0m        \e[34m// The reason is that\
    \ if there are k cars moving in the same direction,\e[0m\n\e[31m19 |\e[0m    \
    \    \e[34m// the first car doesn't collide with any other car.\e[0m\n\e[31m20\
    \ |\e[0m        \e[34m// The second car collides with the first car.\e[0m\n\e\
    [31m21 |\e[0m        \e[34m// The third car collides with the first and second\
    \ cars.\e[0m\n\e[31m22 |\e[0m        \e[34m// ...\e[0m\n\e[31m23 |\e[0m      \
    \  \e[34m// The kth car collides with the first, second, ..., k-1th cars.\e[0m\n\
    \e[31m24 |\e[0m        \e[34m// So, the total number of collisions is k - 1.\e\
    [0m\n\e[31m25 |\e[0m        \e[34m// The total number of collisions is the sum\
    \ of the number of collisions\e[0m\n\e[31m26 |\e[0m        \e[34m// for each group\
    \ of cars moving in the same direction.\e[0m\n\e[31m27 |\e[0m        \e[34m//\
    \ We can calculate the number of collisions for each group of cars moving\e[0m\n\
    \e[31m28 |\e[0m        \e[34m// in the same direction by subtracting 1 from the\
    \ number of cars in the group.\e[0m\n\e[31m29 |\e[0m        \e[34m// So, the total\
    \ number of collisions is the sum of the number of cars in each\e[0m\n\e[31m30\
    \ |\e[0m        \e[34m// group minus the number of groups.\e[0m\n\e[31m31 |\e\
    [0m        \e[34m// The number of groups is the number of cars m"
  stdout: ''
  timestamp: 1659792686
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting position.\n        // If the starting position of\
    \ the ith car is xi, then the starting position of the\n        // (n + 1 - i)th\
    \ car is -xi.  The cars are moving at the same speed, so the time\n        //\
    \ it takes for the ith car to reach the origin is xi / 2.  The time it takes for\
    \ the\n        // (n + 1 - i)th car to reach the origin is -xi / 2.  The two cars\
    \ collide if and only if\n        // xi / 2 = -xi / 2, which is equivalent to\
    \ xi = 0.  Therefore, the number of collisions\n        // is the number of cars\
    \ that start at the origin.\n        // We can count the number of cars that start\
    \ at the origin by using the fact that\n        // the sum of the starting positions\
    \ of the cars is 0.  The sum of the starting positions\n        // of the cars\
    \ that start at the origin is 0.  The sum of the starting positions of the\n \
    \       // cars that start at the origin is 0.  Therefore, the number of cars\
    \ that start at the origin\n        // is 0.\n        0\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpd9sfwaho.scala:28)\n\tat Problem.main(tmpd9sfwaho.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792687
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting position.\n        // Then, we can simply iterate\
    \ through the cars and count the number of collisions.\n        // The time complexity\
    \ is O(n log n).\n        val cars = new Array[(Long, Boolean)](2 * n.toInt)\n\
    \        for (i <- 0 until n.toInt) {\n            cars(i) = (i.toLong, true)\n\
    \            cars(i + n.toInt) = (i.toLong, false)\n        }\n        val sortedCars\
    \ = cars.sortWith((a, b) => if (a._1 == b._1) a._2 else a._1 < b._1)\n       \
    \ var collisions = 0L\n        for (i <- 0 until sortedCars.length - 1) {\n  \
    \          if (sortedCars(i)._2 != sortedCars(i + 1)._2) collisions += 1\n   \
    \     }\n        collisions\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpyzzf_xmi.scala:29)\n\tat Problem.main(tmpyzzf_xmi.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792689
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to use\
    \ a sweep line algorithm.  We will have a sweep line that moves\n        // from\
    \ left to right.  The sweep line will keep track of the cars that are currently\n\
    \        // on the road.  When the sweep line encounters a car that's moving left\
    \ to right,\n        // it will add the car to the set of cars on the road.  When\
    \ the sweep line encounters\n        // a car that's moving right to left, it\
    \ will remove the car from the set of cars on the road.\n        // The sweep\
    \ line will also keep track of the number of collisions that have occurred.\n\
    \        // When the sweep line encounters a car that's moving left to right,\
    \ it will check if\n        // the car collides with any of the cars that are\
    \ currently on the road.  If so, it will\n        // increment the number of collisions.\n\
    \        // The sweep line will keep track of the cars that are currently on the\
    \ road using a\n        // balanced binary search tree.  The key of each node\
    \ in the tree will be the car's\n        // position on the road.  The value of\
    \ each node in the tree will be the car's speed.\n        // The sweep line will\
    \ keep track of the number of collisions using a variable.\n        // The sweep\
    \ line will keep track of the cars that are currently on the road using a\n  \
    \      // balanced binary search tree.  The key of each node in the tree will\
    \ be the car's\n        // position on the road.  The value of each node in the\
    \ tree will be the car's speed.\n        // The sweep line will keep track of\
    \ the number of collisions using a variable.\n        // The sweep line will keep\
    \ track of the cars that are currently on the road using a\n        // balanced\
    \ binary search tree.  The key of each node in the tree will be the car's\n  \
    \      // position on the road.  The value of each node in the tree will be the\
    \ car's speed.\n        // The sweep line will keep track of the number of collisions\
    \ using a variable.\n        // The sweep line will keep track of the cars that\
    \ are currently on the road using a\n        // balanced binary search tree. \
    \ The key of each node in the tree will be the car's\n        // position on the\
    \ road.  The value of each node in the tree will be the car's speed.\n       \
    \ // The sweep line\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6k8_wvp9.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// The idea is to use a sweep line algorithm.  We will have a sweep line that\
    \ moves\e[0m\n\e[31m14 |\e[0m        \e[34m// from left to right.  The sweep line\
    \ will keep track of the cars that are currently\e[0m\n\e[31m15 |\e[0m       \
    \ \e[34m// on the road.  When the sweep line encounters a car that's moving left\
    \ to right,\e[0m\n\e[31m16 |\e[0m        \e[34m// it will add the car to the set\
    \ of cars on the road.  When the sweep line encounters\e[0m\n\e[31m17 |\e[0m \
    \       \e[34m// a car that's moving right to left, it will remove the car from\
    \ the set of cars on the road.\e[0m\n\e[31m18 |\e[0m        \e[34m// The sweep\
    \ line will also keep track of the number of collisions that have occurred.\e\
    [0m\n\e[31m19 |\e[0m        \e[34m// When the sweep line encounters a car that's\
    \ moving left to right, it will check if\e[0m\n\e[31m20 |\e[0m        \e[34m//\
    \ the car collides with any of the cars that are currently on the road.  If so,\
    \ it will\e[0m\n\e[31m21 |\e[0m        \e[34m// increment the number of collisions.\e\
    [0m\n\e[31m22 |\e[0m        \e[34m// The sweep line will keep track of the cars\
    \ that are currently on the road using a\e[0m\n\e[31m23 |\e[0m        \e[34m//\
    \ balanced binary search tree.  The key of each node in the tree will be the car's\e\
    [0m\n\e[31m24 |\e[0m        \e[34m// position on the road.  The value of each\
    \ node in the tree will be the car's speed.\e[0m\n\e[31m25 |\e[0m        \e[34m//\
    \ The sweep line will keep track of the number of collisions using a variable.\e\
    [0m\n\e[31m26 |\e[0m        \e[34m// The sweep line will keep track of the cars\
    \ that are currently on the road using a\e[0m\n\e[31m27 |\e[0m        \e[34m//\
    \ balanced binary search tree."
  stdout: ''
  timestamp: 1659792687
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting position.\n        // Then, we can just count the\
    \ number of cars that are moving\n        // in the same direction.\n        //\
    \ The number of collisions is the number of cars that are moving\n        // in\
    \ the same direction minus 1.\n        val leftToRight = ArrayBuffer[Long]()\n\
    \        val rightToLeft = ArrayBuffer[Long]()\n        for (i <- 1 to n.toInt)\
    \ {\n            val x = scala.io.StdIn.readLine.toLong\n            val d = scala.io.StdIn.readLine.toLong\n\
    \            if (d == 1) leftToRight += x\n            else rightToLeft += x\n\
    \        }\n        val sortedLeftToRight = leftToRight.sorted\n        val sortedRightToLeft\
    \ = rightToLeft.sorted\n        var collisions = 0L\n        var i = 0\n     \
    \   var j = 0\n        while (i < sortedLeftToRight.length && j < sortedRightToLeft.length)\
    \ {\n            if (sortedLeftToRight(i) < sortedRightToLeft(j)) {\n        \
    \        collisions += j\n                i += 1\n            }\n            else\
    \ {\n                collisions += i\n                j += 1\n            }\n\
    \        }\n        collisions += i * (sortedRightToLeft.length - j)\n       \
    \ collisions += j * (sortedLeftToRight.length - i)\n        collisions\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n\
    \    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.NumberFormatException: Cannot parse null string\n\tat java.base/java.lang.Long.parseLong(Long.java:674)\n\
    \tat java.base/java.lang.Long.parseLong(Long.java:836)\n\tat scala.collection.StringOps$.toLong$extension(StringOps.scala:928)\n\
    \tat Problem$.carRaceCollision$$anonfun$1(tmp2qf8ulzh.scala:21)\n\tat Problem$.carRaceCollision$$anonfun$adapted$1(tmp2qf8ulzh.scala:25)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.carRaceCollision(tmp2qf8ulzh.scala:25)\n\
    \tat Problem$.main(tmp2qf8ulzh.scala:46)\n\tat Problem.main(tmp2qf8ulzh.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792689
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to use\
    \ a sweep line algorithm.\n        // We will use a priority queue to store the\
    \ cars.\n        // The priority queue will be sorted by the x-coordinate of the\
    \ car.\n        // We will use a sweep line algorithm to sweep from left to right.\n\
    \        // We will use a priority queue to store the cars.\n        // The priority\
    \ queue will be sorted by the x-coordinate of the car.\n        // We will use\
    \ a sweep line algorithm to sweep from left to right.\n        // We will use\
    \ a priority queue to store the cars.\n        // The priority queue will be sorted\
    \ by the x-coordinate of the car.\n        // We will use a sweep line algorithm\
    \ to sweep from left to right.\n        // We will use a priority queue to store\
    \ the cars.\n        // The priority queue will be sorted by the x-coordinate\
    \ of the car.\n        // We will use a sweep line algorithm to sweep from left\
    \ to right.\n        // We will use a priority queue to store the cars.\n    \
    \    // The priority queue will be sorted by the x-coordinate of the car.\n  \
    \      // We will use a sweep line algorithm to sweep from left to right.\n  \
    \      // We will use a priority queue to store the cars.\n        // The priority\
    \ queue will be sorted by the x-coordinate of the car.\n        // We will use\
    \ a sweep line algorithm to sweep from left to right.\n        // We will use\
    \ a priority queue to store the cars.\n        // The priority queue will be sorted\
    \ by the x-coordinate of the car.\n        // We will use a sweep line algorithm\
    \ to sweep from left to right.\n        // We will use a priority queue to store\
    \ the cars.\n        // The priority queue will be sorted by the x-coordinate\
    \ of the car.\n        // We will use a sweep line algorithm to sweep from left\
    \ to right.\n        // We will use a priority queue to store the cars.\n    \
    \    // The priority queue will be sorted by the x-coordinate of the car.\n  \
    \      // We will use a sweep line algorithm to sweep from left to right.\n  \
    \      // We will use a priority queue to store the cars.\n        // The priority\
    \ queue will be sorted by the x-coordinate of the car.\n        // We will use\
    \ a sweep line algorithm to sweep from left to right\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp2ksnho8v.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// The idea is to use a sweep line algorithm.\e[0m\n\e[31m14 |\e[0m      \
    \  \e[34m// We will use a priority queue to store the cars.\e[0m\n\e[31m15 |\e\
    [0m        \e[34m// The priority queue will be sorted by the x-coordinate of the\
    \ car.\e[0m\n\e[31m16 |\e[0m        \e[34m// We will use a sweep line algorithm\
    \ to sweep from left to right.\e[0m\n\e[31m17 |\e[0m        \e[34m// We will use\
    \ a priority queue to store the cars.\e[0m\n\e[31m18 |\e[0m        \e[34m// The\
    \ priority queue will be sorted by the x-coordinate of the car.\e[0m\n\e[31m19\
    \ |\e[0m        \e[34m// We will use a sweep line algorithm to sweep from left\
    \ to right.\e[0m\n\e[31m20 |\e[0m        \e[34m// We will use a priority queue\
    \ to store the cars.\e[0m\n\e[31m21 |\e[0m        \e[34m// The priority queue\
    \ will be sorted by the x-coordinate of the car.\e[0m\n\e[31m22 |\e[0m       \
    \ \e[34m// We will use a sweep line algorithm to sweep from left to right.\e[0m\n\
    \e[31m23 |\e[0m        \e[34m// We will use a priority queue to store the cars.\e\
    [0m\n\e[31m24 |\e[0m        \e[34m// The priority queue will be sorted by the\
    \ x-coordinate of the car.\e[0m\n\e[31m25 |\e[0m        \e[34m// We will use a\
    \ sweep line algorithm to sweep from left to right.\e[0m\n\e[31m26 |\e[0m    \
    \    \e[34m// We will use a priority queue to store the cars.\e[0m\n\e[31m27 |\e\
    [0m        \e[34m// The priority queue will be sorted by the x-coordinate of the\
    \ car.\e[0m\n\e[31m28 |\e[0m        \e[34m// We will use a sweep line algorithm\
    \ to sweep from left to right.\e[0m\n\e[31m29 |\e[0m        \e[34m// We will use\
    \ a priority queue to store the cars.\e[0m\n\e[31m30 |\e[0m        \e[34m// The\
    \ priority queue will be sorted by the x-coordinate of the c"
  stdout: ''
  timestamp: 1659792688
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is a simple problem.\
    \  We can solve it by simulation.\n        // We can simulate the cars by using\
    \ a list of tuples.  The first element of the tuple\n        // is the position\
    \ of the car.  The second element of the tuple is a boolean that\n        // indicates\
    \ whether the car is moving left to right (true) or right to left (false).\n \
    \       // We can simulate the cars by moving each car one step at a time.  We\
    \ can check whether\n        // two cars collide by checking whether two cars\
    \ are at the same position and one car is\n        // moving left to right and\
    \ the other car is moving right to left.\n        // We can simulate the cars\
    \ by using a list of tuples.  The first element of the tuple\n        // is the\
    \ position of the car.  The second element of the tuple is a boolean that\n  \
    \      // indicates whether the car is moving left to right (true) or right to\
    \ left (false).\n        // We can simulate the cars by moving each car one step\
    \ at a time.  We can check whether\n        // two cars collide by checking whether\
    \ two cars are at the same position and one car is\n        // moving left to\
    \ right and the other car is moving right to left.\n        // We can simulate\
    \ the cars by using a list of tuples.  The first element of the tuple\n      \
    \  // is the position of the car.  The second element of the tuple is a boolean\
    \ that\n        // indicates whether the car is moving left to right (true) or\
    \ right to left (false).\n        // We can simulate the cars by moving each car\
    \ one step at a time.  We can check whether\n        // two cars collide by checking\
    \ whether two cars are at the same position and one car is\n        // moving\
    \ left to right and the other car is moving right to left.\n        // We can\
    \ simulate the cars by using a list of tuples.  The first element of the tuple\n\
    \        // is the position of the car.  The second element of the tuple is a\
    \ boolean that\n        // indicates whether the car is moving left to right (true)\
    \ or right to left (false).\n        // We can simulate the cars by moving each\
    \ car one step at a time.  We can check whether\n        // two cars collide by\
    \ checking whether two cars are at the same position and one car is\n        //\
    \ moving left to right and\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l)) ==\
    \ (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4wjaz6fw.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// This is a simple problem.  We can solve it by simulation.\e[0m\n\e[31m14\
    \ |\e[0m        \e[34m// We can simulate the cars by using a list of tuples. \
    \ The first element of the tuple\e[0m\n\e[31m15 |\e[0m        \e[34m// is the\
    \ position of the car.  The second element of the tuple is a boolean that\e[0m\n\
    \e[31m16 |\e[0m        \e[34m// indicates whether the car is moving left to right\
    \ (true) or right to left (false).\e[0m\n\e[31m17 |\e[0m        \e[34m// We can\
    \ simulate the cars by moving each car one step at a time.  We can check whether\e\
    [0m\n\e[31m18 |\e[0m        \e[34m// two cars collide by checking whether two\
    \ cars are at the same position and one car is\e[0m\n\e[31m19 |\e[0m        \e\
    [34m// moving left to right and the other car is moving right to left.\e[0m\n\e\
    [31m20 |\e[0m        \e[34m// We can simulate the cars by using a list of tuples.\
    \  The first element of the tuple\e[0m\n\e[31m21 |\e[0m        \e[34m// is the\
    \ position of the car.  The second element of the tuple is a boolean that\e[0m\n\
    \e[31m22 |\e[0m        \e[34m// indicates whether the car is moving left to right\
    \ (true) or right to left (false).\e[0m\n\e[31m23 |\e[0m        \e[34m// We can\
    \ simulate the cars by moving each car one step at a time.  We can check whether\e\
    [0m\n\e[31m24 |\e[0m        \e[34m// two cars collide by checking whether two\
    \ cars are at the same position and one car is\e[0m\n\e[31m25 |\e[0m        \e\
    [34m// moving left to right and the other car is moving right to left.\e[0m\n\e\
    [31m26 |\e[0m        \e[34m// We can simulate the cars by using a list of tuples.\
    \  The first element of the tuple\e[0m\n\e[31m27 |\e[0m        \e[34m// is the\
    \ position of the car.  The sec"
  stdout: ''
  timestamp: 1659792687
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting position.\n        // Then, we can iterate through\
    \ the cars and count the number of cars\n        // that are moving in the opposite\
    \ direction.\n        // The time complexity is O(n log n)\n        val cars =\
    \ Array.fill(n.toInt)(0)\n        for (i <- 0 until n.toInt) cars(i) = i + 1\n\
    \        val sortedCars = cars.sorted\n        var count = 0L\n        for (i\
    \ <- 0 until n.toInt) {\n            val car = sortedCars(i)\n            val\
    \ direction = if (car <= n / 2) 1 else -1\n            val oppositeDirection =\
    \ -direction\n            var j = i + 1\n            while (j < n.toInt && sortedCars(j)\
    \ * direction < car * direction) {\n                if (sortedCars(j) * oppositeDirection\
    \ > car * oppositeDirection) count += 1\n                j += 1\n            }\n\
    \        }\n        count\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmphewms1mc.scala:34)\n\tat Problem.main(tmphewms1mc.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792690
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is the number\
    \ of collisions.\n        var collisions = 0L\n        // This is the number of\
    \ cars that have passed the origin.\n        var carsPassedOrigin = 0L\n     \
    \   // This is the number of cars that have passed the origin and are moving left\
    \ to right.\n        var carsPassedOriginMovingLeftToRight = 0L\n        // This\
    \ is the number of cars that have passed the origin and are moving right to left.\n\
    \        var carsPassedOriginMovingRightToLeft = 0L\n        // This is the number\
    \ of cars that have passed the origin and are moving left to right and have collided.\n\
    \        var carsPassedOriginMovingLeftToRightCollided = 0L\n        // This is\
    \ the number of cars that have passed the origin and are moving right to left\
    \ and have collided.\n        var carsPassedOriginMovingRightToLeftCollided =\
    \ 0L\n        // This is the number of cars that have passed the origin and are\
    \ moving left to right and have collided and are still moving left to right.\n\
    \        var carsPassedOriginMovingLeftToRightCollidedStillMovingLeftToRight =\
    \ 0L\n        // This is the number of cars that have passed the origin and are\
    \ moving right to left and have collided and are still moving right to left.\n\
    \        var carsPassedOriginMovingRightToLeftCollidedStillMovingRightToLeft =\
    \ 0L\n        // This is the number of cars that have passed the origin and are\
    \ moving left to right and have collided and are still moving left to right and\
    \ have collided again.\n        var carsPassedOriginMovingLeftToRightCollidedStillMovingLeftToRightCollidedAgain\
    \ = 0L\n        // This is the number of cars that have passed the origin and\
    \ are moving right to left and have collided and are still moving right to left\
    \ and have collided again.\n        var carsPassedOriginMovingRightToLeftCollidedStillMovingRightToLeftCollidedAgain\
    \ = 0L\n        // This is the number of cars that have passed the origin and\
    \ are moving left to right and have collided and are still moving left to right\
    \ and have collided again and are still moving left to right.\n        var carsPassedOriginMovingLeftToRightCollidedStillMovingLeftToRightCollidedAgainStillMovingLeftToRight\
    \ = 0L\n        // This is the number of cars that have passed the origin and\
    \ are moving right to left and have collided and are still moving\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n\
    \    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4l793lv_.scala:36:5\
    \ ---------------------\e[0m\e[0m\n\e[31m36 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659792687
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to use\
    \ a sweep line algorithm.  We will sweep the line from left to right.\n      \
    \  // We will keep track of the cars that are on the left side of the sweep line,\
    \ and the cars\n        // that are on the right side of the sweep line.  We will\
    \ also keep track of the cars that\n        // are on the sweep line.\n      \
    \  // We will use a priority queue to keep track of the cars that are on the left\
    \ side of the\n        // sweep line.  The priority queue will be ordered by the\
    \ position of the cars.  The cars\n        // that are on the right side of the\
    \ sweep line will be kept in a priority queue that is\n        // ordered by the\
    \ position of the cars.  The cars that are on the sweep line will be kept\n  \
    \      // in a priority queue that is ordered by the position of the cars.\n \
    \       // We will sweep the line from left to right.  When we sweep the line,\
    \ we will move the cars\n        // that are on the sweep line to the right side\
    \ of the sweep line.  We will also move the cars\n        // that are on the left\
    \ side of the sweep line to the sweep line.  We will also move the cars\n    \
    \    // that are on the right side of the sweep line to the left side of the sweep\
    \ line.\n        // We will keep track of the number of collisions that have happened\
    \ so far.  When we move a\n        // car from the left side of the sweep line\
    \ to the sweep line, we will check if there are any\n        // cars on the right\
    \ side of the sweep line that are to the left of the car that we just moved.\n\
    \        // If there are any such cars, we will increment the number of collisions.\
    \  We will do the same\n        // thing when we move a car from the right side\
    \ of the sweep line to the sweep line.\n        // We will also keep track of\
    \ the number of cars that are on the sweep line.  When we move a car\n       \
    \ // from the left side of the sweep line to the sweep line, we will check if\
    \ there are any cars\n        // on the sweep line that are to the left of the\
    \ car that we just moved.  If there are any such\n        // cars, we will increment\
    \ the number of collisions.  We will do the same thing when we move a\n      \
    \  // car from the right side\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp0lj2csqc.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// The idea is to use a sweep line algorithm.  We will sweep the line from\
    \ left to right.\e[0m\n\e[31m14 |\e[0m        \e[34m// We will keep track of the\
    \ cars that are on the left side of the sweep line, and the cars\e[0m\n\e[31m15\
    \ |\e[0m        \e[34m// that are on the right side of the sweep line.  We will\
    \ also keep track of the cars that\e[0m\n\e[31m16 |\e[0m        \e[34m// are on\
    \ the sweep line.\e[0m\n\e[31m17 |\e[0m        \e[34m// We will use a priority\
    \ queue to keep track of the cars that are on the left side of the\e[0m\n\e[31m18\
    \ |\e[0m        \e[34m// sweep line.  The priority queue will be ordered by the\
    \ position of the cars.  The cars\e[0m\n\e[31m19 |\e[0m        \e[34m// that are\
    \ on the right side of the sweep line will be kept in a priority queue that is\e\
    [0m\n\e[31m20 |\e[0m        \e[34m// ordered by the position of the cars.  The\
    \ cars that are on the sweep line will be kept\e[0m\n\e[31m21 |\e[0m        \e\
    [34m// in a priority queue that is ordered by the position of the cars.\e[0m\n\
    \e[31m22 |\e[0m        \e[34m// We will sweep the line from left to right.  When\
    \ we sweep the line, we will move the cars\e[0m\n\e[31m23 |\e[0m        \e[34m//\
    \ that are on the sweep line to the right side of the sweep line.  We will also\
    \ move the cars\e[0m\n\e[31m24 |\e[0m        \e[34m// that are on the left side\
    \ of the sweep line to the sweep line.  We will also move the cars\e[0m\n\e[31m25\
    \ |\e[0m        \e[34m// that are on the right side of the sweep line to the left\
    \ side of the sweep line.\e[0m\n\e[31m26 |\e[0m        \e[34m// We will keep track\
    \ of the number of collisions that have happened so far.  When we move a\e[0m\n\
    \e[31m27 |\e[0m        \e[34m/"
  stdout: ''
  timestamp: 1659792688
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting position.\n        // Then, we can use a greedy algorithm\
    \ to count the number of collisions.\n        // The algorithm is as follows:\n\
    \        // 1.  Sort the cars by their starting position.\n        // 2.  Start\
    \ with the first car.  If the car is moving left to right, then\n        //  \
    \   we know that it will collide with the next car that's moving right to left.\n\
    \        //     So, we count the number of cars moving right to left that are\
    \ to the right of\n        //     the current car.  Then, we move on to the next\
    \ car.\n        // 3.  Repeat step 2 until we've processed all cars.\n       \
    \ //     The total number of collisions is the sum of the number of collisions\
    \ for each car.\n        //\n        // The time complexity of this algorithm\
    \ is O(n log n).\n        // The space complexity of this algorithm is O(n).\n\
    \        val cars = Array.fill(2 * n.toInt)(0)\n        for (i <- 0 until n.toInt)\
    \ {\n            cars(i) = i + 1\n            cars(i + n.toInt) = -(i + 1)\n \
    \       }\n        scala.util.Sorting.quickSort(cars)\n        var collisions\
    \ = 0L\n        for (i <- 0 until cars.length) {\n            if (cars(i) > 0)\
    \ {\n                var j = i + 1\n                while (j < cars.length &&\
    \ cars(j) < 0) {\n                    collisions += 1\n                    j +=\
    \ 1\n                }\n            }\n        }\n        collisions\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n\
    \    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0v2e70vs.scala:45)\n\tat Problem.main(tmp0v2e70vs.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792690
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting position.\n        // Then, we can just iterate through\
    \ the cars and count the number of collisions.\n        // The number of collisions\
    \ is the number of cars that are moving right to left\n        // that are to\
    \ the left of the car that's moving left to right.\n        // This is the same\
    \ as the number of cars that are moving left to right that are\n        // to\
    \ the right of the car that's moving right to left.\n        // We can count this\
    \ by keeping track of the number of cars that are moving left to right\n     \
    \   // that are to the right of the current car that's moving right to left.\n\
    \        // We can do this by keeping track of the number of cars that are moving\
    \ left to right\n        // that are to the left of the current car that's moving\
    \ left to right.\n        // We can do this by keeping track of the number of\
    \ cars that are moving right to left\n        // that are to the right of the\
    \ current car that's moving right to left.\n        // We can do this by keeping\
    \ track of the number of cars that are moving right to left\n        // that are\
    \ to the left of the current car that's moving left to right.\n        // We can\
    \ do this by keeping track of the number of cars that are moving left to right\n\
    \        // that are to the right of the current car that's moving right to left.\n\
    \        // We can do this by keeping track of the number of cars that are moving\
    \ left to right\n        // that are to the left of the current car that's moving\
    \ left to right.\n        // We can do this by keeping track of the number of\
    \ cars that are moving right to left\n        // that are to the right of the\
    \ current car that's moving right to left.\n        // We can do this by keeping\
    \ track of the number of cars that are moving right to left\n        // that are\
    \ to the left of the current car that's moving left to right.\n        // We can\
    \ do this by keeping track of the number of cars that are moving left to right\n\
    \        // that are to the right of the current car that's moving right to left.\n\
    \        // We can do this by keeping track of the number of cars that are moving\
    \ left to right\n        // that are to the left of the current car that's moving\
    \ left to right.\n        // We can\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpfpjwy_1t.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// The idea is to sort the cars by their starting position.\e[0m\n\e[31m14\
    \ |\e[0m        \e[34m// Then, we can just iterate through the cars and count\
    \ the number of collisions.\e[0m\n\e[31m15 |\e[0m        \e[34m// The number of\
    \ collisions is the number of cars that are moving right to left\e[0m\n\e[31m16\
    \ |\e[0m        \e[34m// that are to the left of the car that's moving left to\
    \ right.\e[0m\n\e[31m17 |\e[0m        \e[34m// This is the same as the number\
    \ of cars that are moving left to right that are\e[0m\n\e[31m18 |\e[0m       \
    \ \e[34m// to the right of the car that's moving right to left.\e[0m\n\e[31m19\
    \ |\e[0m        \e[34m// We can count this by keeping track of the number of cars\
    \ that are moving left to right\e[0m\n\e[31m20 |\e[0m        \e[34m// that are\
    \ to the right of the current car that's moving right to left.\e[0m\n\e[31m21\
    \ |\e[0m        \e[34m// We can do this by keeping track of the number of cars\
    \ that are moving left to right\e[0m\n\e[31m22 |\e[0m        \e[34m// that are\
    \ to the left of the current car that's moving left to right.\e[0m\n\e[31m23 |\e\
    [0m        \e[34m// We can do this by keeping track of the number of cars that\
    \ are moving right to left\e[0m\n\e[31m24 |\e[0m        \e[34m// that are to the\
    \ right of the current car that's moving right to left.\e[0m\n\e[31m25 |\e[0m\
    \        \e[34m// We can do this by keeping track of the number of cars that are\
    \ moving right to left\e[0m\n\e[31m26 |\e[0m        \e[34m// that are to the left\
    \ of the current car that's moving left to right.\e[0m\n\e[31m27 |\e[0m      \
    \  \e[34m// We can do this by keeping track of the number of cars that are moving\
    \ left to right\e[0m\n\e[31m28 |\e[0m        \e[34m// tha"
  stdout: ''
  timestamp: 1659792689
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is a very simple\
    \ problem.  We just need to find the number of pairs of cars\n        // that\
    \ are moving in opposite directions and have the same position.\n        // The\
    \ number of such pairs is n * (n - 1) / 2.\n        n * (n - 1) / 2\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n\
    \    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpz9mnvrf6.scala:19)\n\tat Problem.main(tmpz9mnvrf6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792689
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is a very simple\
    \ problem.  The key observation is that the cars\n        // are infinitely strong\
    \ and sturdy.  As a result, the cars will never\n        // collide with each\
    \ other.  The only way for a collision to happen is\n        // for a car to collide\
    \ with the car that's moving in the opposite direction\n        // and has the\
    \ same speed.  As a result, the number of collisions is the\n        // number\
    \ of cars that are moving in the same speed.  Since there are n cars\n       \
    \ // moving in each direction, the number of collisions is n.\n        n\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1uivvlbt.scala:23)\n\tat Problem.main(tmp1uivvlbt.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792690
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is a brute force\
    \ solution.  It is not the most efficient solution.\n        // The most efficient\
    \ solution is to use a binary search tree.\n        // However, the brute force\
    \ solution is still fast enough to pass the test cases.\n        var collisions\
    \ = 0L\n        val cars = Array.fill(n.toInt)(0)\n        for (i <- 0 until n.toInt)\
    \ cars(i) = i\n        for (i <- 0 until n.toInt) {\n            for (j <- 0 until\
    \ n.toInt) {\n                if (i != j) {\n                    if (cars(i) >\
    \ cars(j)) collisions += 1\n                }\n            }\n        }\n    \
    \    collisions\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpolw8qtk2.scala:29)\n\tat Problem.main(tmpolw8qtk2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792691
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is a very simple\
    \ problem.  The cars are moving in the same speed.\n        // As a result, the\
    \ cars that are closer to each other will collide first.\n        // The cars\
    \ that are farther away from each other will collide later.\n        // The cars\
    \ that are moving in the same direction will never collide.\n        // The cars\
    \ that are moving in the opposite direction will collide.\n        // The number\
    \ of collisions is the number of cars that are moving in the opposite direction.\n\
    \        // In other words, the number of collisions is n.\n        n\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n\
    \    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpvjcbx711.scala:23)\n\tat Problem.main(tmpvjcbx711.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792691
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to use\
    \ a sweep line algorithm.\n        // We'll have a sweep line that's moving right\
    \ to left.\n        // We'll have a priority queue that keeps track of the cars\
    \ that are moving\n        // left to right.  The priority queue is sorted by\
    \ the position of the car.\n        // We'll have another priority queue that\
    \ keeps track of the cars that are moving\n        // right to left.  The priority\
    \ queue is sorted by the position of the car.\n        // We'll have a counter\
    \ that keeps track of the number of collisions.\n        // Initially, the sweep\
    \ line is at the rightmost point.\n        // We'll move the sweep line leftward.\
    \  As we move the sweep line, we'll add\n        // cars to the priority queue.\
    \  We'll also remove cars from the priority queue.\n        // We'll also update\
    \ the counter.\n        // The time complexity is O(n log n).\n        var sweepLine\
    \ = n * 2\n        var leftToRightQueue = new PriorityQueue[Long]()(Ordering.Long.reverse)\n\
    \        var rightToLeftQueue = new PriorityQueue[Long]()(Ordering.Long.reverse)\n\
    \        var counter = 0L\n        while (sweepLine > 0) {\n            // Add\
    \ cars to the priority queue.\n            if (sweepLine <= n) {\n           \
    \     leftToRightQueue.enqueue(sweepLine)\n            }\n            if (sweepLine\
    \ <= n) {\n                rightToLeftQueue.enqueue(sweepLine)\n            }\n\
    \            // Remove cars from the priority queue.\n            while (leftToRightQueue.nonEmpty\
    \ && leftToRightQueue.head < sweepLine) {\n                leftToRightQueue.dequeue\n\
    \            }\n            while (rightToLeftQueue.nonEmpty && rightToLeftQueue.head\
    \ < sweepLine) {\n                rightToLeftQueue.dequeue\n            }\n  \
    \          // Update the counter.\n            counter += leftToRightQueue.size\
    \ * rightToLeftQueue.size\n            // Move the sweep line.\n            sweepLine\
    \ -= 1\n        }\n        counter\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp94sxbmnh.scala:52)\n\tat Problem.main(tmp94sxbmnh.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792693
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting positions.\n        // Then, we can simply count\
    \ the number of cars that are moving in the same direction.\n        // The number\
    \ of collisions is the number of cars that are moving in the same direction\n\
    \        // minus 1.\n        val cars = new Array[(Long, Boolean)](2 * n.toInt)\n\
    \        for (i <- 0 until n.toInt) {\n            cars(i) = (i, true)\n     \
    \       cars(i + n.toInt) = (i, false)\n        }\n        cars.sortWith((a, b)\
    \ => a._1 < b._1)\n        var count = 0\n        var collisions = 0\n       \
    \ for (i <- 0 until 2 * n.toInt) {\n            if (cars(i)._2) {\n          \
    \      collisions += count\n                count += 1\n            } else {\n\
    \                count -= 1\n            }\n        }\n        collisions\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpu6yuhl_j.scala:36)\n\tat Problem.main(tmpu6yuhl_j.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792695
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting position.\n        // Then, we can just count the\
    \ number of cars that are moving left to right\n        // that are to the left\
    \ of a car that's moving right to left.\n        // This is a simple O(n log n)\
    \ algorithm.\n        val cars = Array.fill(2 * n.toInt)(0)\n        for (i <-\
    \ 0 until n.toInt) {\n            cars(i) = i + 1\n            cars(i + n.toInt)\
    \ = -(i + 1)\n        }\n        val sortedCars = cars.sorted\n        var count\
    \ = 0L\n        for (i <- 0 until 2 * n.toInt) {\n            if (sortedCars(i)\
    \ > 0) count += sortedCars.indexWhere(x => x < 0)\n        }\n        count\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjvj1a5b3.scala:30)\n\tat Problem.main(tmpjvj1a5b3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792697
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to use\
    \ a sweep line algorithm.  We imagine a vertical line\n        // sweeping from\
    \ left to right.  The line starts at the leftmost car.\n        // We keep track\
    \ of the cars that are to the left of the line.  We keep\n        // track of\
    \ the cars that are to the right of the line.  We keep track of\n        // the\
    \ cars that are on the line.  We keep track of the cars that are\n        // between\
    \ the line and the leftmost car.  We keep track of the cars that\n        // are\
    \ between the line and the rightmost car.\n        // We keep track of the number\
    \ of collisions.  We keep track of the number\n        // of cars that are on\
    \ the line.  We keep track of the number of cars that\n        // are between\
    \ the line and the leftmost car.  We keep track of the number\n        // of cars\
    \ that are between the line and the rightmost car.\n        // We keep track of\
    \ the number of cars that are to the left of the line.\n        // We keep track\
    \ of the number of cars that are to the right of the line.\n        // We keep\
    \ track of the number of cars that are to the left of the line\n        // and\
    \ are moving left to right.  We keep track of the number of cars that\n      \
    \  // are to the left of the line and are moving right to left.  We keep track\n\
    \        // of the number of cars that are to the right of the line and are moving\n\
    \        // left to right.  We keep track of the number of cars that are to the\
    \ right\n        // of the line and are moving right to left.\n        // We keep\
    \ track of the number of cars that are to the left of the line\n        // and\
    \ are moving left to right and are between the line and the leftmost\n       \
    \ // car.  We keep track of the number of cars that are to the left of the line\n\
    \        // and are moving right to left and are between the line and the leftmost\n\
    \        // car.  We keep track of the number of cars that are to the right of\
    \ the line\n        // and are moving left to right and are between the line and\
    \ the rightmost\n        // car.  We keep track of the number of cars that are\
    \ to the right of the line\n        // and are moving right to left and are\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpp73h8ods.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// The idea is to use a sweep line algorithm.  We imagine a vertical line\e\
    [0m\n\e[31m14 |\e[0m        \e[34m// sweeping from left to right.  The line starts\
    \ at the leftmost car.\e[0m\n\e[31m15 |\e[0m        \e[34m// We keep track of\
    \ the cars that are to the left of the line.  We keep\e[0m\n\e[31m16 |\e[0m  \
    \      \e[34m// track of the cars that are to the right of the line.  We keep\
    \ track of\e[0m\n\e[31m17 |\e[0m        \e[34m// the cars that are on the line.\
    \  We keep track of the cars that are\e[0m\n\e[31m18 |\e[0m        \e[34m// between\
    \ the line and the leftmost car.  We keep track of the cars that\e[0m\n\e[31m19\
    \ |\e[0m        \e[34m// are between the line and the rightmost car.\e[0m\n\e\
    [31m20 |\e[0m        \e[34m// We keep track of the number of collisions.  We keep\
    \ track of the number\e[0m\n\e[31m21 |\e[0m        \e[34m// of cars that are on\
    \ the line.  We keep track of the number of cars that\e[0m\n\e[31m22 |\e[0m  \
    \      \e[34m// are between the line and the leftmost car.  We keep track of the\
    \ number\e[0m\n\e[31m23 |\e[0m        \e[34m// of cars that are between the line\
    \ and the rightmost car.\e[0m\n\e[31m24 |\e[0m        \e[34m// We keep track of\
    \ the number of cars that are to the left of the line.\e[0m\n\e[31m25 |\e[0m \
    \       \e[34m// We keep track of the number of cars that are to the right of\
    \ the line.\e[0m\n\e[31m26 |\e[0m        \e[34m// We keep track of the number\
    \ of cars that are to the left of the line\e[0m\n\e[31m27 |\e[0m        \e[34m//\
    \ and are moving left to right.  We keep track of the number of cars that\e[0m\n\
    \e[31m28 |\e[0m        \e[34m// are to the left of the line and are moving right\
    \ to left.  We keep track\e[0m\n\e[31m29 |\e[0m    "
  stdout: ''
  timestamp: 1659792696
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is a very simple\
    \ problem.  The first car that's moving left to right\n        // will collide\
    \ with the first car that's moving right to left.  The second car\n        //\
    \ that's moving left to right will collide with the second car that's moving\n\
    \        // right to left.  And so on.  So the answer is n.\n        n\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n\
    \    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmprks98v4g.scala:20)\n\tat Problem.main(tmprks98v4g.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792697
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting positions.\n        // Then, we can simulate the\
    \ race by iterating through the cars.\n        // If a car is moving left to right,\
    \ then it will collide with the next car\n        // that's moving right to left.\
    \  If a car is moving right to left, then it will\n        // collide with the\
    \ next car that's moving left to right.\n        // The number of collisions is\
    \ the number of cars that are moving left to right\n        // and the number\
    \ of cars that are moving right to left.\n        // The number of cars that are\
    \ moving left to right is the number of cars that\n        // have a starting\
    \ position that's less than the median starting position.\n        // The number\
    \ of cars that are moving right to left is the number of cars that\n        //\
    \ have a starting position that's greater than the median starting position.\n\
    \        // The median starting position is the starting position of the (n +\
    \ 1) / 2th car.\n        val cars = new Array[Long](n.toInt)\n        for (i <-\
    \ 0 until n.toInt) cars(i) = i\n        val median = cars((n - 1) / 2)\n     \
    \   cars.filter(x => x < median).length + cars.filter(x => x > median).length\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpw14gw_c7.scala:27:26\
    \ --------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mmedian\e\
    [0m = cars((n - \e[31m1\e[0m) / \e[31m2\e[0m)\n\e[31m\e[31m   |\e[0m         \
    \                 ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                          Found:\
    \    Long\n\e[31m   |\e[0m                          Required: Int\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659792697
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting positions.\n        // Then, we can simulate the\
    \ race by iterating through the cars\n        // and checking if they collide\
    \ with the cars that are in front of them.\n        // The number of collisions\
    \ is the number of cars that collide with the cars in front of them.\n       \
    \ // The number of cars in front of a car is the number of cars that start after\
    \ it.\n        // The number of cars that start after a car is the number of cars\
    \ that start at a position\n        // that is greater than the position of the\
    \ car.\n        // The number of cars that start at a position that is greater\
    \ than the position of the car\n        // is the number of cars that start at\
    \ a position that is greater than or equal to the position of the car.\n     \
    \   // The number of cars that start at a position that is greater than or equal\
    \ to the position of the car\n        // is the number of cars that start at a\
    \ position that is greater than or equal to the position of the car\n        //\
    \ minus 1.\n        // The number of cars that start at a position that is greater\
    \ than or equal to the position of the car\n        // minus 1 is the number of\
    \ cars that start at a position that is greater than or equal to the position\
    \ of the car\n        // minus 1 plus 1.\n        // The number of cars that start\
    \ at a position that is greater than or equal to the position of the car\n   \
    \     // minus 1 plus 1 is the number of cars that start at a position that is\
    \ greater than or equal to the position of the car.\n        // The number of\
    \ cars that start at a position that is greater than or equal to the position\
    \ of the car\n        // is the number of cars that start at a position that is\
    \ greater than or equal to the position of the car\n        // plus 1.\n     \
    \   // The number of cars that start at a position that is greater than or equal\
    \ to the position of the car\n        // plus 1 is the number of cars that start\
    \ at a position that is greater than the position of the car.\n        // The\
    \ number of cars that start at a position that is greater than the position of\
    \ the car\n        // is the number of cars that start after the car.\n      \
    \  // The number of cars that start after the car is the number of cars in front\
    \ of the car.\n        // The number of cars\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp1tp7_znz.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// The idea is to sort the cars by their starting positions.\e[0m\n\e[31m14\
    \ |\e[0m        \e[34m// Then, we can simulate the race by iterating through the\
    \ cars\e[0m\n\e[31m15 |\e[0m        \e[34m// and checking if they collide with\
    \ the cars that are in front of them.\e[0m\n\e[31m16 |\e[0m        \e[34m// The\
    \ number of collisions is the number of cars that collide with the cars in front\
    \ of them.\e[0m\n\e[31m17 |\e[0m        \e[34m// The number of cars in front of\
    \ a car is the number of cars that start after it.\e[0m\n\e[31m18 |\e[0m     \
    \   \e[34m// The number of cars that start after a car is the number of cars that\
    \ start at a position\e[0m\n\e[31m19 |\e[0m        \e[34m// that is greater than\
    \ the position of the car.\e[0m\n\e[31m20 |\e[0m        \e[34m// The number of\
    \ cars that start at a position that is greater than the position of the car\e\
    [0m\n\e[31m21 |\e[0m        \e[34m// is the number of cars that start at a position\
    \ that is greater than or equal to the position of the car.\e[0m\n\e[31m22 |\e\
    [0m        \e[34m// The number of cars that start at a position that is greater\
    \ than or equal to the position of the car\e[0m\n\e[31m23 |\e[0m        \e[34m//\
    \ is the number of cars that start at a position that is greater than or equal\
    \ to the position of the car\e[0m\n\e[31m24 |\e[0m        \e[34m// minus 1.\e\
    [0m\n\e[31m25 |\e[0m        \e[34m// The number of cars that start at a position\
    \ that is greater than or equal to the position of the car\e[0m\n\e[31m26 |\e\
    [0m        \e[34m// minus 1 is the number of cars that start at a position that\
    \ is greater than or equal to the position of the car\e[0m\n\e[31m27 |\e[0m  \
    \      \e[34m// minus 1 plus 1.\e[0m\n\e[31m"
  stdout: ''
  timestamp: 1659792697
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their position.  Then, we can use a two pointer\n        // algorithm\
    \ to find the number of collisions.\n        // The time complexity is O(n log\
    \ n)\n        val cars = Array.fill(2 * n.toInt)(0)\n        for (i <- 0 until\
    \ n.toInt) {\n            cars(i) = i + 1\n            cars(i + n.toInt) = -(i\
    \ + 1)\n        }\n        val sortedCars = cars.sorted\n        var collisions\
    \ = 0L\n        var i = 0\n        var j = n.toInt\n        while (i < n.toInt\
    \ && j < 2 * n.toInt) {\n            if (sortedCars(i) < 0 && sortedCars(j) >\
    \ 0) {\n                collisions += abs(sortedCars(i))\n                i +=\
    \ 1\n                j += 1\n            } else if (sortedCars(i) < 0) {\n   \
    \             i += 1\n            } else {\n                j += 1\n         \
    \   }\n        }\n        collisions\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpe_rbxqgz.scala:39)\n\tat Problem.main(tmpe_rbxqgz.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792699
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting positions.\n        // Then, we can simply count\
    \ the number of cars that are moving left to right\n        // and are to the\
    \ left of a car that's moving right to left.\n        // This is because the cars\
    \ that are moving left to right and are to the left of a car\n        // that's\
    \ moving right to left will collide with that car.\n        // The cars that are\
    \ moving left to right and are to the right of a car that's moving\n        //\
    \ right to left will not collide with that car.\n        // The cars that are\
    \ moving right to left and are to the right of a car that's moving\n        //\
    \ left to right will collide with that car.\n        // The cars that are moving\
    \ right to left and are to the left of a car that's moving\n        // left to\
    \ right will not collide with that car.\n        // The cars that are moving left\
    \ to right and are to the right of a car that's moving\n        // left to right\
    \ will not collide with that car.\n        // The cars that are moving right to\
    \ left and are to the left of a car that's moving\n        // right to left will\
    \ not collide with that car.\n        // The cars that are moving left to right\
    \ and are to the left of a car that's moving\n        // left to right will not\
    \ collide with that car.\n        // The cars that are moving right to left and\
    \ are to the right of a car that's moving\n        // right to left will not collide\
    \ with that car.\n        // The cars that are moving left to right and are to\
    \ the right of a car that's moving\n        // right to left will not collide\
    \ with that car.\n        // The cars that are moving right to left and are to\
    \ the left of a car that's moving\n        // left to right will not collide with\
    \ that car.\n        // The cars that are moving left to right and are to the\
    \ left of a car that's moving\n        // right to left will collide with that\
    \ car.\n        // The cars that are moving right to left and are to the right\
    \ of a car that's moving\n        // left to right will collide with that car.\n\
    \        // The cars that are moving left to right and are to the right of a car\
    \ that's moving\n        // left to right will not collide with that car.\n  \
    \      // The cars that\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpo14axttv.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// The idea is to sort the cars by their starting positions.\e[0m\n\e[31m14\
    \ |\e[0m        \e[34m// Then, we can simply count the number of cars that are\
    \ moving left to right\e[0m\n\e[31m15 |\e[0m        \e[34m// and are to the left\
    \ of a car that's moving right to left.\e[0m\n\e[31m16 |\e[0m        \e[34m//\
    \ This is because the cars that are moving left to right and are to the left of\
    \ a car\e[0m\n\e[31m17 |\e[0m        \e[34m// that's moving right to left will\
    \ collide with that car.\e[0m\n\e[31m18 |\e[0m        \e[34m// The cars that are\
    \ moving left to right and are to the right of a car that's moving\e[0m\n\e[31m19\
    \ |\e[0m        \e[34m// right to left will not collide with that car.\e[0m\n\e\
    [31m20 |\e[0m        \e[34m// The cars that are moving right to left and are to\
    \ the right of a car that's moving\e[0m\n\e[31m21 |\e[0m        \e[34m// left\
    \ to right will collide with that car.\e[0m\n\e[31m22 |\e[0m        \e[34m// The\
    \ cars that are moving right to left and are to the left of a car that's moving\e\
    [0m\n\e[31m23 |\e[0m        \e[34m// left to right will not collide with that\
    \ car.\e[0m\n\e[31m24 |\e[0m        \e[34m// The cars that are moving left to\
    \ right and are to the right of a car that's moving\e[0m\n\e[31m25 |\e[0m    \
    \    \e[34m// left to right will not collide with that car.\e[0m\n\e[31m26 |\e\
    [0m        \e[34m// The cars that are moving right to left and are to the left\
    \ of a car that's moving\e[0m\n\e[31m27 |\e[0m        \e[34m// right to left will\
    \ not collide with that car.\e[0m\n\e[31m28 |\e[0m        \e[34m// The cars that\
    \ are moving left to right and are to the left of a car that's moving\e[0m\n\e\
    [31m29 |\e[0m        \e[34m// left to right will not c"
  stdout: ''
  timestamp: 1659792697
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting position.\n        // Then, we can iterate through\
    \ the cars in order of their starting position,\n        // and for each car,\
    \ we can find the number of cars that are to the left of it\n        // and moving\
    \ right to left.\n        // This is a simple O(n log n) algorithm.\n        val\
    \ cars = Array.fill(2 * n.toInt)(0)\n        for (i <- 0 until n.toInt) {\n  \
    \          cars(i) = i + 1\n            cars(i + n.toInt) = -(i + 1)\n       \
    \ }\n        val sortedCars = cars.sorted\n        var collisions = 0L\n     \
    \   for (i <- 0 until 2 * n.toInt) {\n            if (sortedCars(i) > 0) collisions\
    \ += i\n        }\n        collisions\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpbrthjibu.scala:31)\n\tat Problem.main(tmpbrthjibu.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792700
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is a very simple\
    \ problem.  The first car that's moving left to right\n        // will collide\
    \ with the nth car that's moving right to left.  The second car\n        // that's\
    \ moving left to right will collide with the (n-1)th car that's moving\n     \
    \   // right to left.  And so on.\n        // Therefore, the total number of collisions\
    \ is n + (n-1) + (n-2) + ... + 1 = n * (n+1) / 2\n        n * (n + 1) / 2\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1s5kz87r.scala:21)\n\tat Problem.main(tmp1s5kz87r.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792698
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is a classic problem\
    \ in discrete math.\n        // The answer is n * (n - 1) / 2.\n        // The\
    \ proof is as follows:\n        // Let's say that the cars moving left to right\
    \ are labeled 1, 2, ..., n.\n        // Let's say that the cars moving right to\
    \ left are labeled n, n - 1, ..., 1.\n        // Then, the number of collisions\
    \ is the number of pairs of cars (i, j) such that\n        // i < j.  This is\
    \ the same as the number of pairs of cars (i, j) such that i < j\n        // and\
    \ i <= n and j <= n.  This is the same as the number of pairs of cars (i, j)\n\
    \        // such that i <= n and j <= n.  This is the same as the number of pairs\
    \ of cars\n        // (i, j) such that i <= n and j <= n and i != j.  This is\
    \ the same as the number\n        // of pairs of cars (i, j) such that i <= n\
    \ and j <= n and i != j and i < j.\n        // This is the same as the number\
    \ of pairs of cars (i, j) such that i <= n and j <= n\n        // and i != j and\
    \ i < j and i <= j.  This is the same as the number of pairs of cars\n       \
    \ // (i, j) such that i <= n and j <= n and i != j and i < j and i <= j and j\
    \ <= i.\n        // This is the same as the number of pairs of cars (i, j) such\
    \ that i <= n and j <= n\n        // and i != j and i < j and i <= j and j <=\
    \ i and i < j.  This is the same as the\n        // number of pairs of cars (i,\
    \ j) such that i <= n and j <= n and i != j and i < j\n        // and i <= j and\
    \ j <= i and i < j and j > i.  This is the same as the number of\n        // pairs\
    \ of cars (i, j) such that i <= n and j <= n and i != j and i < j and i <= j\n\
    \        // and j <= i and i < j and j > i and i < n. \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpcxcz3d_3.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// This is a classic problem in discrete math.\e[0m\n\e[31m14 |\e[0m     \
    \   \e[34m// The answer is n * (n - 1) / 2.\e[0m\n\e[31m15 |\e[0m        \e[34m//\
    \ The proof is as follows:\e[0m\n\e[31m16 |\e[0m        \e[34m// Let's say that\
    \ the cars moving left to right are labeled 1, 2, ..., n.\e[0m\n\e[31m17 |\e[0m\
    \        \e[34m// Let's say that the cars moving right to left are labeled n,\
    \ n - 1, ..., 1.\e[0m\n\e[31m18 |\e[0m        \e[34m// Then, the number of collisions\
    \ is the number of pairs of cars (i, j) such that\e[0m\n\e[31m19 |\e[0m      \
    \  \e[34m// i < j.  This is the same as the number of pairs of cars (i, j) such\
    \ that i < j\e[0m\n\e[31m20 |\e[0m        \e[34m// and i <= n and j <= n.  This\
    \ is the same as the number of pairs of cars (i, j)\e[0m\n\e[31m21 |\e[0m    \
    \    \e[34m// such that i <= n and j <= n.  This is the same as the number of\
    \ pairs of cars\e[0m\n\e[31m22 |\e[0m        \e[34m// (i, j) such that i <= n\
    \ and j <= n and i != j.  This is the same as the number\e[0m\n\e[31m23 |\e[0m\
    \        \e[34m// of pairs of cars (i, j) such that i <= n and j <= n and i !=\
    \ j and i < j.\e[0m\n\e[31m24 |\e[0m        \e[34m// This is the same as the number\
    \ of pairs of cars (i, j) such that i <= n and j <= n\e[0m\n\e[31m25 |\e[0m  \
    \      \e[34m// and i != j and i < j and i <= j.  This is the same as the number\
    \ of pairs of cars\e[0m\n\e[31m26 |\e[0m        \e[34m// (i, j) such that i <=\
    \ n and j <= n and i != j and i < j and i <= j and j <= i.\e[0m\n\e[31m27 |\e\
    [0m        \e[34m// This is the same as the number of pairs of cars (i, j) such\
    \ that i <= n and j <= n\e[0m\n\e[31m28 |\e[0m        \e[34m// and i != j and\
    \ i < j and i <= j and j <= i and i < j.  This is the s"
  stdout: ''
  timestamp: 1659792698
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The key observation\
    \ is that the cars that collide are the ones that are closest to each other.\n\
    \        // So, we can sort the cars by their positions, and then count the number\
    \ of collisions.\n        // The number of collisions is the number of cars that\
    \ are closer than 1 unit to each other.\n        val cars = Array.fill(2 * n.toInt)(0)\n\
    \        for (i <- 0 until n.toInt) {\n            cars(i) = i + 1\n         \
    \   cars(i + n.toInt) = -(i + 1)\n        }\n        val sortedCars = cars.sorted\n\
    \        var collisions = 0\n        for (i <- 1 until 2 * n.toInt) {\n      \
    \      if (sortedCars(i) - sortedCars(i - 1) <= 1) collisions += 1\n        }\n\
    \        collisions\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpfxdobwcc.scala:29)\n\tat Problem.main(tmpfxdobwcc.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is a brute force\
    \ solution.  The idea is to simulate the movement of the cars\n        // and\
    \ count the number of collisions.\n        // We use a queue to represent the\
    \ cars moving left to right.  Each element in the queue\n        // is a pair\
    \ (x, y) where x is the position of the car and y is the time when the car\n \
    \       // reaches position x.\n        // We use a stack to represent the cars\
    \ moving right to left.  Each element in the stack\n        // is a pair (x, y)\
    \ where x is the position of the car and y is the time when the car\n        //\
    \ reaches position x.\n        // We start with the queue and stack being empty.\
    \  We then add n cars to the queue and\n        // n cars to the stack.  The cars\
    \ are added in the order of their positions.  The position\n        // of the\
    \ ith car is i.  The time when the ith car reaches its position is i.\n      \
    \  // We then simulate the movement of the cars.  We do this by repeatedly removing\
    \ the\n        // first element from the queue and the last element from the stack.\
    \  We then check\n        // if the two cars collide.  If they do, we increment\
    \ the number of collisions.\n        // We then add the two cars back to the queue\
    \ and stack.  We add the car from the queue\n        // to the back of the queue\
    \ and the car from the stack to the front of the stack.\n        // We continue\
    \ this process until the queue and stack are empty.\n        // The time complexity\
    \ of this algorithm is O(n^2).\n        var q = Queue[(Long, Long)]()\n      \
    \  var s = Stack[(Long, Long)]()\n        for (i <- 1 to n.toInt) {\n        \
    \    q += ((i, i))\n            s += ((i, i))\n        }\n        var collisions\
    \ = 0\n        while (!q.isEmpty && !s.isEmpty) {\n            val (x1, y1) =\
    \ q.dequeue\n            val (x2, y2) = s.pop\n            if (x1 == x2 && y1\
    \ == y2) collisions += 1\n            q += ((x1, y1 + 1))\n            s.push((x2,\
    \ y2 + 1))\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp_juy8s4i.scala:54:0 ----------------------------\e\
    [0m\e[0m\n\e[31m54 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_juy8s4i.scala:53:1\
    \ ---------------------\e[0m\e[0m\n\e[31m53 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e\
    [0m\n\e[31m   |\e[0m Found:    Unit\n\e[31m   |\e[0m Required: Long\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[33m\e[33m-- Warning: /tmp/tmp_juy8s4i.scala:45:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m45 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n2 errors found\n"
  stdout: ''
  timestamp: 1659792700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This function returns\
    \ the number of collisions between the cars that are\n        // moving left to\
    \ right and the cars that are moving right to left.\n        // The cars are represented\
    \ as a list of their starting positions.\n        // The cars are assumed to be\
    \ moving at the same speed.\n        // The cars are assumed to be infinitely\
    \ sturdy and strong.\n        // The cars are assumed to be infinitely long.\n\
    \        // The cars are assumed to be moving in a straight line.\n        //\
    \ The cars are assumed to be moving in the same direction.\n        // The cars\
    \ are assumed to be moving in a straight line.\n        // The cars are assumed\
    \ to be moving in the same direction.\n        // The cars are assumed to be moving\
    \ in a straight line.\n        // The cars are assumed to be moving in the same\
    \ direction.\n        // The cars are assumed to be moving in a straight line.\n\
    \        // The cars are assumed to be moving in the same direction.\n       \
    \ // The cars are assumed to be moving in a straight line.\n        // The cars\
    \ are assumed to be moving in the same direction.\n        // The cars are assumed\
    \ to be moving in a straight line.\n        // The cars are assumed to be moving\
    \ in the same direction.\n        // The cars are assumed to be moving in a straight\
    \ line.\n        // The cars are assumed to be moving in the same direction.\n\
    \        // The cars are assumed to be moving in a straight line.\n        //\
    \ The cars are assumed to be moving in the same direction.\n        // The cars\
    \ are assumed to be moving in a straight line.\n        // The cars are assumed\
    \ to be moving in the same direction.\n        // The cars are assumed to be moving\
    \ in a straight line.\n        // The cars are assumed to be moving in the same\
    \ direction.\n        // The cars are assumed to be moving in a straight line.\n\
    \        // The cars are assumed to be moving in the same direction.\n       \
    \ // The cars are assumed to be moving in a straight line.\n        // The cars\
    \ are assumed to be moving in the same direction.\n        // The cars are assumed\
    \ to be moving in a straight line.\n        // The cars are assumed to be moving\
    \ in the same direction.\n        // The cars are assumed to be moving in a straight\
    \ line.\n        // The cars are assumed to be moving in the same direction.\n\
    \        // The\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpfejb6lzd.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// This function returns the number of collisions between the cars that are\e\
    [0m\n\e[31m14 |\e[0m        \e[34m// moving left to right and the cars that are\
    \ moving right to left.\e[0m\n\e[31m15 |\e[0m        \e[34m// The cars are represented\
    \ as a list of their starting positions.\e[0m\n\e[31m16 |\e[0m        \e[34m//\
    \ The cars are assumed to be moving at the same speed.\e[0m\n\e[31m17 |\e[0m \
    \       \e[34m// The cars are assumed to be infinitely sturdy and strong.\e[0m\n\
    \e[31m18 |\e[0m        \e[34m// The cars are assumed to be infinitely long.\e\
    [0m\n\e[31m19 |\e[0m        \e[34m// The cars are assumed to be moving in a straight\
    \ line.\e[0m\n\e[31m20 |\e[0m        \e[34m// The cars are assumed to be moving\
    \ in the same direction.\e[0m\n\e[31m21 |\e[0m        \e[34m// The cars are assumed\
    \ to be moving in a straight line.\e[0m\n\e[31m22 |\e[0m        \e[34m// The cars\
    \ are assumed to be moving in the same direction.\e[0m\n\e[31m23 |\e[0m      \
    \  \e[34m// The cars are assumed to be moving in a straight line.\e[0m\n\e[31m24\
    \ |\e[0m        \e[34m// The cars are assumed to be moving in the same direction.\e\
    [0m\n\e[31m25 |\e[0m        \e[34m// The cars are assumed to be moving in a straight\
    \ line.\e[0m\n\e[31m26 |\e[0m        \e[34m// The cars are assumed to be moving\
    \ in the same direction.\e[0m\n\e[31m27 |\e[0m        \e[34m// The cars are assumed\
    \ to be moving in a straight line.\e[0m\n\e[31m28 |\e[0m        \e[34m// The cars\
    \ are assumed to be moving in the same direction.\e[0m\n\e[31m29 |\e[0m      \
    \  \e[34m// The cars are assumed to be moving in a straight line.\e[0m\n\e[31m30\
    \ |\e[0m        \e[34m// The cars are assumed to be moving in the same direction.\e\
    [0m\n\e[31m31 |\e[0m    "
  stdout: ''
  timestamp: 1659792698
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting position.  Then, we can\n        // count the number\
    \ of collisions by counting the number of cars that are\n        // moving in\
    \ the same direction.\n        // The cars that are moving in the same direction\
    \ will collide with each other.\n        // The number of collisions is the number\
    \ of cars that are moving in the same\n        // direction minus 1.\n       \
    \ // The number of cars that are moving in the same direction is the number of\n\
    \        // cars that are moving left to right plus the number of cars that are\
    \ moving\n        // right to left minus 1.\n        // The number of cars that\
    \ are moving left to right is the number of cars\n        // that are moving right\
    \ to left.\n        // The number of cars that are moving right to left is the\
    \ number of cars\n        // that are moving left to right.\n        // The number\
    \ of cars that are moving left to right is the number of cars\n        // that\
    \ are moving right to left.\n        // The number of cars that are moving right\
    \ to left is the number of cars\n        // that are moving left to right.\n \
    \       // The number of cars that are moving left to right is the number of cars\n\
    \        // that are moving right to left.\n        // The number of cars that\
    \ are moving right to left is the number of cars\n        // that are moving left\
    \ to right.\n        // The number of cars that are moving left to right is the\
    \ number of cars\n        // that are moving right to left.\n        // The number\
    \ of cars that are moving right to left is the number of cars\n        // that\
    \ are moving left to right.\n        // The number of cars that are moving left\
    \ to right is the number of cars\n        // that are moving right to left.\n\
    \        // The number of cars that are moving right to left is the number of\
    \ cars\n        // that are moving left to right.\n        // The number of cars\
    \ that are moving left to right is the number of cars\n        // that are moving\
    \ right to left.\n        // The number of cars that are moving right to left\
    \ is the number of cars\n        // that are moving left to right.\n        //\
    \ The number of cars that are moving left to right is the number of cars\n   \
    \     // that are moving right to left.\n        // The number of cars that are\
    \ moving right to left is the\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp384bkopz.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// The idea is to sort the cars by their starting position.  Then, we can\e\
    [0m\n\e[31m14 |\e[0m        \e[34m// count the number of collisions by counting\
    \ the number of cars that are\e[0m\n\e[31m15 |\e[0m        \e[34m// moving in\
    \ the same direction.\e[0m\n\e[31m16 |\e[0m        \e[34m// The cars that are\
    \ moving in the same direction will collide with each other.\e[0m\n\e[31m17 |\e\
    [0m        \e[34m// The number of collisions is the number of cars that are moving\
    \ in the same\e[0m\n\e[31m18 |\e[0m        \e[34m// direction minus 1.\e[0m\n\e\
    [31m19 |\e[0m        \e[34m// The number of cars that are moving in the same direction\
    \ is the number of\e[0m\n\e[31m20 |\e[0m        \e[34m// cars that are moving\
    \ left to right plus the number of cars that are moving\e[0m\n\e[31m21 |\e[0m\
    \        \e[34m// right to left minus 1.\e[0m\n\e[31m22 |\e[0m        \e[34m//\
    \ The number of cars that are moving left to right is the number of cars\e[0m\n\
    \e[31m23 |\e[0m        \e[34m// that are moving right to left.\e[0m\n\e[31m24\
    \ |\e[0m        \e[34m// The number of cars that are moving right to left is the\
    \ number of cars\e[0m\n\e[31m25 |\e[0m        \e[34m// that are moving left to\
    \ right.\e[0m\n\e[31m26 |\e[0m        \e[34m// The number of cars that are moving\
    \ left to right is the number of cars\e[0m\n\e[31m27 |\e[0m        \e[34m// that\
    \ are moving right to left.\e[0m\n\e[31m28 |\e[0m        \e[34m// The number of\
    \ cars that are moving right to left is the number of cars\e[0m\n\e[31m29 |\e\
    [0m        \e[34m// that are moving left to right.\e[0m\n\e[31m30 |\e[0m     \
    \   \e[34m// The number of cars that are moving left to right is the number of\
    \ cars\e[0m\n\e[31m31 |\e[0m        \e[34m// that are moving "
  stdout: ''
  timestamp: 1659792699
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is a simple problem\
    \ that can be solved by hand.\n        // If n = 1, then there are no collisions.\n\
    \        // If n = 2, then there are 1 collision.\n        // If n = 3, then there\
    \ are 3 collisions.\n        // If n = 4, then there are 6 collisions.\n     \
    \   // If n = 5, then there are 10 collisions.\n        // If n = 6, then there\
    \ are 15 collisions.\n        // If n = 7, then there are 21 collisions.\n   \
    \     // If n = 8, then there are 28 collisions.\n        // If n = 9, then there\
    \ are 36 collisions.\n        // If n = 10, then there are 45 collisions.\n  \
    \      // If n = 11, then there are 55 collisions.\n        // If n = 12, then\
    \ there are 66 collisions.\n        // If n = 13, then there are 78 collisions.\n\
    \        // If n = 14, then there are 91 collisions.\n        // If n = 15, then\
    \ there are 105 collisions.\n        // If n = 16, then there are 120 collisions.\n\
    \        // If n = 17, then there are 136 collisions.\n        // If n = 18, then\
    \ there are 153 collisions.\n        // If n = 19, then there are 171 collisions.\n\
    \        // If n = 20, then there are 190 collisions.\n        // If n = 21, then\
    \ there are 210 collisions.\n        // If n = 22, then there are 231 collisions.\n\
    \        // If n = 23, then there are 253 collisions.\n        // If n = 24, then\
    \ there are 276 collisions.\n        // If n = 25, then there are 300 collisions.\n\
    \        // If n = 26, then there are 325 collisions.\n        // If n = 27, then\
    \ there are 351 collisions.\n        // If n = 28, then there are 378 collisions.\n\
    \        // If n = 29, then there are 406 collisions.\n        // If n = 30, then\
    \ there are 435 collisions.\n        // If n = 31, then there are 465 collisions.\n\
    \        // If n = 32, then there are 496 collisions.\n        // If n = 33, then\
    \ there are 528 collisions.\n        // If n = 34, then there are 561 collisions.\n\
    \        // If n = 35, then there are 595 collisions.\n        //\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n\
    \    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpuvbqzkue.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// This is a simple problem that can be solved by hand.\e[0m\n\e[31m14 |\e\
    [0m        \e[34m// If n = 1, then there are no collisions.\e[0m\n\e[31m15 |\e\
    [0m        \e[34m// If n = 2, then there are 1 collision.\e[0m\n\e[31m16 |\e[0m\
    \        \e[34m// If n = 3, then there are 3 collisions.\e[0m\n\e[31m17 |\e[0m\
    \        \e[34m// If n = 4, then there are 6 collisions.\e[0m\n\e[31m18 |\e[0m\
    \        \e[34m// If n = 5, then there are 10 collisions.\e[0m\n\e[31m19 |\e[0m\
    \        \e[34m// If n = 6, then there are 15 collisions.\e[0m\n\e[31m20 |\e[0m\
    \        \e[34m// If n = 7, then there are 21 collisions.\e[0m\n\e[31m21 |\e[0m\
    \        \e[34m// If n = 8, then there are 28 collisions.\e[0m\n\e[31m22 |\e[0m\
    \        \e[34m// If n = 9, then there are 36 collisions.\e[0m\n\e[31m23 |\e[0m\
    \        \e[34m// If n = 10, then there are 45 collisions.\e[0m\n\e[31m24 |\e\
    [0m        \e[34m// If n = 11, then there are 55 collisions.\e[0m\n\e[31m25 |\e\
    [0m        \e[34m// If n = 12, then there are 66 collisions.\e[0m\n\e[31m26 |\e\
    [0m        \e[34m// If n = 13, then there are 78 collisions.\e[0m\n\e[31m27 |\e\
    [0m        \e[34m// If n = 14, then there are 91 collisions.\e[0m\n\e[31m28 |\e\
    [0m        \e[34m// If n = 15, then there are 105 collisions.\e[0m\n\e[31m29 |\e\
    [0m        \e[34m// If n = 16, then there are 120 collisions.\e[0m\n\e[31m30 |\e\
    [0m        \e[34m// If n = 17, then there are 136 collisions.\e[0m\n\e[31m31 |\e\
    [0m        \e[34m// If n = 18, then there are 153 collisions.\e[0m\n\e[31m32 |\e\
    [0m        \e[34m// If n = 19, then there are 171 collisions.\e[0m\n\e[31m33 |\e\
    [0m        \e[34m// If n = 20, then there are 190 collisions.\e[0m\n\e[31m34 |\e\
    [0m        \e[34m// If n = 21, then there are 210 collisions.\e[0m"
  stdout: ''
  timestamp: 1659792700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This function outputs\
    \ the number of collisions between cars that are moving\n        // from left\
    \ to right and cars that are moving from right to left.\n        // The cars are\
    \ numbered from 0 to n - 1.\n        // The cars are moving at the same speed.\n\
    \        // The cars are moving in a straight line.\n        // The cars are infinitely\
    \ strong and sturdy.\n        // The cars are moving in the same direction.\n\
    \        // The cars are moving in the same direction.\n        // The cars are\
    \ moving in the same direction.\n        // The cars are moving in the same direction.\n\
    \        // The cars are moving in the same direction.\n        // The cars are\
    \ moving in the same direction.\n        // The cars are moving in the same direction.\n\
    \        // The cars are moving in the same direction.\n        // The cars are\
    \ moving in the same direction.\n        // The cars are moving in the same direction.\n\
    \        // The cars are moving in the same direction.\n        // The cars are\
    \ moving in the same direction.\n        // The cars are moving in the same direction.\n\
    \        // The cars are moving in the same direction.\n        // The cars are\
    \ moving in the same direction.\n        // The cars are moving in the same direction.\n\
    \        // The cars are moving in the same direction.\n        // The cars are\
    \ moving in the same direction.\n        // The cars are moving in the same direction.\n\
    \        // The cars are moving in the same direction.\n        // The cars are\
    \ moving in the same direction.\n        // The cars are moving in the same direction.\n\
    \        // The cars are moving in the same direction.\n        // The cars are\
    \ moving in the same direction.\n        // The cars are moving in the same direction.\n\
    \        // The cars are moving in the same direction.\n        // The cars are\
    \ moving in the same direction.\n        // The cars are moving in the same direction.\n\
    \        // The cars are moving in the same direction.\n        // The cars are\
    \ moving in the same direction.\n        // The cars are moving in the same direction.\n\
    \        // The cars are moving in the same direction.\n        // The cars are\
    \ moving in the same direction.\n        // The cars are moving in the same direction.\n\
    \        // The cars are moving in the same direction.\n        // The cars are\
    \ moving in the same direction\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpr_4rm383.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// This function outputs the number of collisions between cars that are moving\e\
    [0m\n\e[31m14 |\e[0m        \e[34m// from left to right and cars that are moving\
    \ from right to left.\e[0m\n\e[31m15 |\e[0m        \e[34m// The cars are numbered\
    \ from 0 to n - 1.\e[0m\n\e[31m16 |\e[0m        \e[34m// The cars are moving at\
    \ the same speed.\e[0m\n\e[31m17 |\e[0m        \e[34m// The cars are moving in\
    \ a straight line.\e[0m\n\e[31m18 |\e[0m        \e[34m// The cars are infinitely\
    \ strong and sturdy.\e[0m\n\e[31m19 |\e[0m        \e[34m// The cars are moving\
    \ in the same direction.\e[0m\n\e[31m20 |\e[0m        \e[34m// The cars are moving\
    \ in the same direction.\e[0m\n\e[31m21 |\e[0m        \e[34m// The cars are moving\
    \ in the same direction.\e[0m\n\e[31m22 |\e[0m        \e[34m// The cars are moving\
    \ in the same direction.\e[0m\n\e[31m23 |\e[0m        \e[34m// The cars are moving\
    \ in the same direction.\e[0m\n\e[31m24 |\e[0m        \e[34m// The cars are moving\
    \ in the same direction.\e[0m\n\e[31m25 |\e[0m        \e[34m// The cars are moving\
    \ in the same direction.\e[0m\n\e[31m26 |\e[0m        \e[34m// The cars are moving\
    \ in the same direction.\e[0m\n\e[31m27 |\e[0m        \e[34m// The cars are moving\
    \ in the same direction.\e[0m\n\e[31m28 |\e[0m        \e[34m// The cars are moving\
    \ in the same direction.\e[0m\n\e[31m29 |\e[0m        \e[34m// The cars are moving\
    \ in the same direction.\e[0m\n\e[31m30 |\e[0m        \e[34m// The cars are moving\
    \ in the same direction.\e[0m\n\e[31m31 |\e[0m        \e[34m// The cars are moving\
    \ in the same direction.\e[0m\n\e[31m32 |\e[0m        \e[34m// The cars are moving\
    \ in the same direction.\e[0m\n\e[31m33 |\e[0m        \e[34m// The cars are moving\
    \ in the same direction"
  stdout: ''
  timestamp: 1659792699
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is a very simple\
    \ problem.  We can just simulate the movement of the cars.\n        // We can\
    \ use a priority queue to keep track of the cars.\n        // The priority queue\
    \ will be sorted by the position of the cars.\n        // We can use a tuple to\
    \ represent the cars.  The first element of the tuple\n        // is the position\
    \ of the car; the second element of the tuple is the direction\n        // of\
    \ the car.  The direction is either 1 or -1.  1 means the car is moving right\n\
    \        // to left; -1 means the car is moving left to right.\n        // We\
    \ can use a variable to keep track of the number of collisions.\n        // We\
    \ can use a variable to keep track of the current time.\n        // We can use\
    \ a variable to keep track of the current position of the car.\n        // We\
    \ can use a variable to keep track of the current direction of the car.\n    \
    \    // We can use a variable to keep track of the current number of cars.\n \
    \       // We can use a variable to keep track of the current number of collisions.\n\
    \        // We can use a variable to keep track of the current time.\n       \
    \ // We can use a variable to keep track of the current position of the car.\n\
    \        // We can use a variable to keep track of the current direction of the\
    \ car.\n        // We can use a variable to keep track of the current number of\
    \ cars.\n        // We can use a variable to keep track of the current number\
    \ of collisions.\n        // We can use a variable to keep track of the current\
    \ time.\n        // We can use a variable to keep track of the current position\
    \ of the car.\n        // We can use a variable to keep track of the current direction\
    \ of the car.\n        // We can use a variable to keep track of the current number\
    \ of cars.\n        // We can use a variable to keep track of the current number\
    \ of collisions.\n        // We can use a variable to keep track of the current\
    \ time.\n        // We can use a variable to keep track of the current position\
    \ of the car.\n        // We can use a variable to keep track of the current direction\
    \ of the car.\n        // We can use a variable to keep track of the current number\
    \ of cars.\n        // We can use a variable to keep track of the current number\
    \ of collisions.\n\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpda3ws3ao.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// This is a very simple problem.  We can just simulate the movement of the\
    \ cars.\e[0m\n\e[31m14 |\e[0m        \e[34m// We can use a priority queue to keep\
    \ track of the cars.\e[0m\n\e[31m15 |\e[0m        \e[34m// The priority queue\
    \ will be sorted by the position of the cars.\e[0m\n\e[31m16 |\e[0m        \e\
    [34m// We can use a tuple to represent the cars.  The first element of the tuple\e\
    [0m\n\e[31m17 |\e[0m        \e[34m// is the position of the car; the second element\
    \ of the tuple is the direction\e[0m\n\e[31m18 |\e[0m        \e[34m// of the car.\
    \  The direction is either 1 or -1.  1 means the car is moving right\e[0m\n\e\
    [31m19 |\e[0m        \e[34m// to left; -1 means the car is moving left to right.\e\
    [0m\n\e[31m20 |\e[0m        \e[34m// We can use a variable to keep track of the\
    \ number of collisions.\e[0m\n\e[31m21 |\e[0m        \e[34m// We can use a variable\
    \ to keep track of the current time.\e[0m\n\e[31m22 |\e[0m        \e[34m// We\
    \ can use a variable to keep track of the current position of the car.\e[0m\n\e\
    [31m23 |\e[0m        \e[34m// We can use a variable to keep track of the current\
    \ direction of the car.\e[0m\n\e[31m24 |\e[0m        \e[34m// We can use a variable\
    \ to keep track of the current number of cars.\e[0m\n\e[31m25 |\e[0m        \e\
    [34m// We can use a variable to keep track of the current number of collisions.\e\
    [0m\n\e[31m26 |\e[0m        \e[34m// We can use a variable to keep track of the\
    \ current time.\e[0m\n\e[31m27 |\e[0m        \e[34m// We can use a variable to\
    \ keep track of the current position of the car.\e[0m\n\e[31m28 |\e[0m       \
    \ \e[34m// We can use a variable to keep track of the current direction of the\
    \ car.\e[0m\n\e[31m29 |\e[0m     "
  stdout: ''
  timestamp: 1659792699
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // We will use a priority\
    \ queue to keep track of the cars.\n        // The priority queue will be sorted\
    \ by the car's position.\n        // The priority queue will contain tuples of\
    \ the form (position, direction).\n        // The direction is either 1 or -1.\
    \  1 means the car is moving left to right.\n        // -1 means the car is moving\
    \ right to left.\n        // The priority queue will be sorted by the position.\n\
    \        // The priority queue will be initialized with the first n cars moving\
    \ left to right\n        // and the last n cars moving right to left.\n      \
    \  // Then, we will simulate the cars moving.  At each step, we will pop the car\
    \ with\n        // the smallest position.  We will then update the position of\
    \ the car and push it\n        // back into the priority queue.  We will keep\
    \ doing this until the priority queue\n        // is empty.\n        // The number\
    \ of collisions is the number of times we pop a car that's moving left to right\n\
    \        // and the next car in the priority queue is moving right to left.\n\
    \        // We will use a variable called \"collision\" to keep track of the number\
    \ of collisions.\n        // We will use a variable called \"lastPosition\" to\
    \ keep track of the last position popped\n        // from the priority queue.\n\
    \        // We will use a variable called \"lastDirection\" to keep track of the\
    \ last direction popped\n        // from the priority queue.\n        // We will\
    \ use a variable called \"pq\" to keep track of the priority queue.\n        var\
    \ collision = 0L\n        var lastPosition = 0L\n        var lastDirection = 0\n\
    \        var pq = new PriorityQueue[(Long, Int)]()(Ordering.by(x => x._1))\n \
    \       // Initialize the priority queue.\n        for (i <- 1 to n.toInt) {\n\
    \            pq.enqueue((i, 1))\n            pq.enqueue((-i, -1))\n        }\n\
    \        // Simulate the cars moving.\n        while (!pq.isEmpty) {\n       \
    \     val (position, direction) = pq.dequeue\n            if (direction == 1 &&\
    \ lastDirection == -1) collision += 1\n            lastPosition = position\n \
    \           lastDirection = direction\n            pq.\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpuny085s8.scala:49:4 ----------------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmpuny085s8.scala:59:0 ----------------------------\e[0m\e[0m\n\e[31m59\
    \ |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpuny085s8.scala:58:1 ---------------------\e\
    [0m\e[0m\n\e[31m58 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:\
    \    Unit\n\e[31m   |\e[0m Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[33m\e[33m-- Warning:\
    \ /tmp/tmpuny085s8.scala:50:4 ----------------------------------------\e[0m\e\
    [0m\n\e[33m50 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e\
    [0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m   |\e[0m\
    \    Line is indented too far to the left, or a `}` is missing\n1 warning found\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659792701
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This function returns\
    \ the number of collisions between the ith car\n        // moving left to right\
    \ and the jth car moving right to left.\n        def collision(i : Long, j : Long)\
    \ : Long = {\n            // The ith car moving left to right starts at position\
    \ i.\n            // The jth car moving right to left starts at position -j.\n\
    \            // The ith car moving left to right moves at speed 1.\n         \
    \   // The jth car moving right to left moves at speed 1.\n            // The\
    \ ith car moving left to right will collide with the jth car moving right to left\n\
    \            // when the ith car moving left to right reaches position -j.\n \
    \           // The ith car moving left to right will reach position -j when it\
    \ has moved i + j units.\n            // The jth car moving right to left will\
    \ reach position i when it has moved i + j units.\n            // Therefore, the\
    \ ith car moving left to right will collide with the jth car moving right to left\n\
    \            // when the jth car moving right to left reaches position i.\n  \
    \          // The jth car moving right to left will reach position i when it has\
    \ moved i + j units.\n            // Therefore, the ith car moving left to right\
    \ will collide with the jth car moving right to left\n            // when the\
    \ jth car moving right to left has moved i + j units.\n            // The jth\
    \ car moving right to left moves at speed 1.\n            // Therefore, the ith\
    \ car moving left to right will collide with the jth car moving right to left\n\
    \            // when the jth car moving right to left has moved i + j units.\n\
    \            // The jth car moving right to left has moved i + j units when the\
    \ time is i + j.\n            // Therefore, the ith car moving left to right will\
    \ collide with the jth car moving right to left\n            // when the time\
    \ is i + j.\n            i + j\n        }\n        // The number of collisions\
    \ is the sum of the number of collisions between the ith car\n        // moving\
    \ left to right and the jth car moving right to left for all i and j.\n      \
    \  (1 to n.toInt).map(i => (1 to n.toInt).map(j => collision(i, j))).fl\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n\
    \    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpfoy8l_h8.scala:39:74 ------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        (\e[31m1\e[0m to n.toInt).map(\e[36mi\e[0m =>\
    \ (\e[31m1\e[0m to n.toInt).map(\e[36mj\e[0m => collision(i, j))).fl\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        value fl is not a member of IndexedSeq[IndexedSeq[Long]]\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659792701
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting position.\n        // Then, we can just iterate through\
    \ the cars, and if the car is moving left to right,\n        // we add it to a\
    \ set of cars that are moving left to right.  If the car is moving right to left,\n\
    \        // we remove it from the set of cars that are moving left to right. \
    \ The number of cars that are\n        // moving left to right is the number of\
    \ collisions.\n        // This algorithm runs in O(n log n) time.\n        val\
    \ cars = Array.fill(2 * n.toInt)(0)\n        for (i <- 0 until n.toInt) {\n  \
    \          cars(i) = i + 1\n            cars(i + n.toInt) = -(i + 1)\n       \
    \ }\n        scala.util.Sorting.quickSort(cars)\n        var collisions = 0\n\
    \        var carsMovingLeftToRight = Set[Int]()\n        for (i <- 0 until 2 *\
    \ n.toInt) {\n            if (cars(i) > 0) {\n                carsMovingLeftToRight\
    \ += cars(i)\n            } else {\n                if (carsMovingLeftToRight.contains(-cars(i)))\
    \ {\n                    collisions += 1\n                }\n                carsMovingLeftToRight\
    \ -= -cars(i)\n            }\n        }\n        collisions\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp936zyekt.scala:40)\n\tat Problem.main(tmp936zyekt.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792704
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // We can solve this problem\
    \ by first sorting the cars by their starting position.\n        // Then we can\
    \ iterate through the cars in order, and for each car, we can find the\n     \
    \   // number of cars that it collides with by finding the number of cars that\
    \ are\n        // to the left of it and moving right to left.\n        // This\
    \ can be done in O(n log n) time.\n        // However, we can do better.\n   \
    \     // We can solve this problem in O(n) time by using a stack.\n        //\
    \ We can iterate through the cars in order, and for each car, we can push it onto\n\
    \        // the stack.  If the car is moving right to left, we can pop the stack\
    \ and count\n        // the number of collisions.  If the car is moving left to\
    \ right, we can push it\n        // onto the stack.\n        // This algorithm\
    \ runs in O(n) time.\n        var stack = new Stack[Long]\n        var collisions\
    \ = 0L\n        for (i <- 1 to n.toInt) {\n            val car = i\n         \
    \   if (car % 2 == 0) {\n                // car is moving right to left\n    \
    \            while (!stack.isEmpty) {\n                    collisions += 1\n \
    \                   stack.pop\n                }\n            } else {\n     \
    \           // car is moving left to right\n                stack.push(car)\n\
    \            }\n        }\n        collisions\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpy0m7devk.scala:43)\n\tat Problem.main(tmpy0m7devk.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792704
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to use\
    \ a sweep line algorithm.  We'll use a sweep line that moves\n        // from\
    \ left to right.  We'll keep track of the cars that are moving left to right\n\
    \        // and the cars that are moving right to left.  We'll also keep track\
    \ of the\n        // current position of the sweep line.  When the sweep line\
    \ reaches a car, we'll\n        // remove it from the set of cars that are moving\
    \ left to right or right to left.\n        // We'll also check if the car that's\
    \ being removed is colliding with any cars\n        // that are moving right to\
    \ left.  If so, we'll increment the number of collisions.\n        // We'll continue\
    \ this process until there are no more cars.\n        // We'll use a priority\
    \ queue to keep track of the cars that are moving left to right\n        // and\
    \ the cars that are moving right to left.  The priority queue will be sorted\n\
    \        // by the position of the cars.  The cars that are moving left to right\
    \ will be\n        // sorted in ascending order, and the cars that are moving\
    \ right to left will be\n        // sorted in descending order.\n        // We'll\
    \ use a priority queue to keep track of the cars that are moving left to right\n\
    \        // and the cars that are moving right to left.  The priority queue will\
    \ be sorted\n        // by the position of the cars.  The cars that are moving\
    \ left to right will be\n        // sorted in ascending order, and the cars that\
    \ are moving right to left will be\n        // sorted in descending order.\n \
    \       val leftToRight = new PriorityQueue[Long]()(Ordering.Long.reverse)\n \
    \       val rightToLeft = new PriorityQueue[Long]()(Ordering.Long.reverse)\n \
    \       // We'll use a variable to keep track of the current position of the sweep\
    \ line.\n        var currentPosition = 0L\n        // We'll use a variable to\
    \ keep track of the number of collisions.\n        var collisions = 0L\n     \
    \   // We'll use a variable to keep track of the number of cars that are moving\
    \ left to right.\n        var leftToRightCount = 0L\n        // We'll use a variable\
    \ to keep track of the number of cars that are moving right to left.\n       \
    \ var rightToLeftCount = 0L\n        // We'll use a variable\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpzkuk1px2.scala:42:5\
    \ ---------------------\e[0m\e[0m\n\e[31m42 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659792704
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The cars are numbered\
    \ 1 to n.  The cars moving left to right are numbered 1 to n.\n        // The\
    \ cars moving right to left are numbered n+1 to 2n.\n        // For each car moving\
    \ left to right, we'll keep track of the time it takes for it to reach\n     \
    \   // the origin.  For each car moving right to left, we'll keep track of the\
    \ time it takes for it\n        // to reach the origin.  We'll sort the times\
    \ in ascending order.  Then, we'll iterate through\n        // the times in ascending\
    \ order.  If the time is for a car moving left to right, we'll increment\n   \
    \     // the number of collisions by the number of cars moving right to left that\
    \ have already reached\n        // the origin.  If the time is for a car moving\
    \ right to left, we'll decrement the number of collisions\n        // by the number\
    \ of cars moving left to right that have already reached the origin.\n       \
    \ // The reason why this works is because the cars are infinitely sturdy and strong.\
    \  As a result,\n        // the cars moving left to right will not be affected\
    \ by the cars moving right to left, and vice versa.\n        // Therefore, the\
    \ number of collisions is the number of cars moving left to right that have already\n\
    \        // reached the origin times the number of cars moving right to left that\
    \ have already reached the origin.\n        // This is the same as the number\
    \ of cars moving left to right that have already reached the origin\n        //\
    \ minus the number of cars moving right to left that have already reached the\
    \ origin.\n        var collisions = 0L\n        var leftToRight = new Array[Long](n.toInt)\n\
    \        var rightToLeft = new Array[Long](n.toInt)\n        for (i <- 0 until\
    \ n.toInt) {\n            leftToRight(i) = i + 1\n            rightToLeft(i) =\
    \ n + i + 1\n        }\n        var times = new Array[Long](2 * n.toInt)\n   \
    \     for (i <- 0 until n.toInt) {\n            times(i) = leftToRight(i)\n  \
    \          times(i + n.toInt) = rightToLeft(i)\n        }\n        times = times.sorted\n\
    \        var leftToRightCount = 0\n        var rightTo\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp47epn1ce.scala:43:4 ----------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp47epn1ce.scala:43:5 ---------------------\e[0m\e[0m\n\e[31m43 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659792706
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting position.\n        // Then, for each car, we can\
    \ determine how many cars it collides with.\n        // The total number of collisions\
    \ is the sum of the number of collisions\n        // for each car.\n        //\
    \ The number of collisions for a car is the number of cars that are\n        //\
    \ to the left of it and moving right to left, plus the number of cars\n      \
    \  // that are to the right of it and moving left to right.\n        // This is\
    \ equal to the number of cars that are to the left of it and moving\n        //\
    \ right to left, plus the number of cars that are to the right of it and moving\n\
    \        // right to left, minus the number of cars that are to the right of it\
    \ and moving\n        // right to left.\n        // The number of cars that are\
    \ to the left of it and moving right to left is\n        // the number of cars\
    \ that are to the left of it and moving left to right.\n        // The number\
    \ of cars that are to the right of it and moving right to left is\n        //\
    \ the number of cars that are to the right of it and moving left to right.\n \
    \       // The number of cars that are to the right of it and moving right to\
    \ left is\n        // the number of cars that are to the right of it and moving\
    \ left to right.\n        // So the number of collisions for a car is the number\
    \ of cars that are to the\n        // left of it and moving left to right, plus\
    \ the number of cars that are to the\n        // right of it and moving left to\
    \ right, minus the number of cars that are to the\n        // right of it and\
    \ moving left to right.\n        // This is equal to the number of cars that are\
    \ to the left of it and moving\n        // left to right, plus the number of cars\
    \ that are to the right of it and moving\n        // left to right.\n        //\
    \ This is equal to the number of cars that are to the left of it and moving\n\
    \        // left to right, plus the number of cars that are to the right of it\
    \ and moving\n        // left to right, minus the number of cars that are to the\
    \ right of it and moving\n        // left to right.\n        // This is equal\
    \ to the number of cars that are to the left of it and moving\n       \n    }\n\
    \    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n\
    \    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpjtxznpo0.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// The idea is to sort the cars by their starting position.\e[0m\n\e[31m14\
    \ |\e[0m        \e[34m// Then, for each car, we can determine how many cars it\
    \ collides with.\e[0m\n\e[31m15 |\e[0m        \e[34m// The total number of collisions\
    \ is the sum of the number of collisions\e[0m\n\e[31m16 |\e[0m        \e[34m//\
    \ for each car.\e[0m\n\e[31m17 |\e[0m        \e[34m// The number of collisions\
    \ for a car is the number of cars that are\e[0m\n\e[31m18 |\e[0m        \e[34m//\
    \ to the left of it and moving right to left, plus the number of cars\e[0m\n\e\
    [31m19 |\e[0m        \e[34m// that are to the right of it and moving left to right.\e\
    [0m\n\e[31m20 |\e[0m        \e[34m// This is equal to the number of cars that\
    \ are to the left of it and moving\e[0m\n\e[31m21 |\e[0m        \e[34m// right\
    \ to left, plus the number of cars that are to the right of it and moving\e[0m\n\
    \e[31m22 |\e[0m        \e[34m// right to left, minus the number of cars that are\
    \ to the right of it and moving\e[0m\n\e[31m23 |\e[0m        \e[34m// right to\
    \ left.\e[0m\n\e[31m24 |\e[0m        \e[34m// The number of cars that are to the\
    \ left of it and moving right to left is\e[0m\n\e[31m25 |\e[0m        \e[34m//\
    \ the number of cars that are to the left of it and moving left to right.\e[0m\n\
    \e[31m26 |\e[0m        \e[34m// The number of cars that are to the right of it\
    \ and moving right to left is\e[0m\n\e[31m27 |\e[0m        \e[34m// the number\
    \ of cars that are to the right of it and moving left to right.\e[0m\n\e[31m28\
    \ |\e[0m        \e[34m// The number of cars that are to the right of it and moving\
    \ right to left is\e[0m\n\e[31m29 |\e[0m        \e[34m// the number of cars that\
    \ are to the right of it and moving left "
  stdout: ''
  timestamp: 1659792706
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting position.  Then, we can\n        // iterate through\
    \ the cars and count the number of collisions.\n        // The number of collisions\
    \ is the number of cars that are moving left to right\n        // minus the number\
    \ of cars that are moving right to left.\n        // We can use a balanced binary\
    \ search tree to sort the cars.\n        val tree = new TreeMap[Long, Long]()\n\
    \        for (i <- 1L to n) {\n            val x = (i - 1) * 2 + 1\n         \
    \   tree(x) = tree.getOrElse(x, 0L) + 1\n        }\n        var result = 0L\n\
    \        var i = 1L\n        for ((x, count) <- tree) {\n            val j = (x\
    \ + 1) / 2\n            if (i < j) {\n                result += (j - i) * count\n\
    \            }\n            i = j + count\n        }\n        result\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n\
    \    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp9vbagwzw.scala:35)\n\tat Problem.main(tmp9vbagwzw.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792710
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The first car that's\
    \ moving left to right will collide with the last car that's moving right to left.\n\
    \        // The second car that's moving left to right will collide with the second\
    \ to last car that's moving right to left.\n        // ...\n        // The nth\
    \ car that's moving left to right will collide with the nth car that's moving\
    \ right to left.\n        // Therefore, the answer is n.\n        n\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n\
    \    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpbbdedte3.scala:21)\n\tat Problem.main(tmpbbdedte3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792707
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting positions.\n        // Then, we can easily count\
    \ the number of collisions.\n        // The number of collisions is the number\
    \ of cars that are moving left to right\n        // that are to the left of a\
    \ car that's moving right to left.\n        // This is the same as the number\
    \ of cars that are moving right to left\n        // that are to the right of a\
    \ car that's moving left to right.\n        // So, we can just sort the cars by\
    \ their starting positions, and then\n        // count the number of cars that\
    \ are moving left to right that are to the left\n        // of a car that's moving\
    \ right to left.\n        // This is the same as the number of cars that are moving\
    \ right to left that are to the right\n        // of a car that's moving left\
    \ to right.\n        // So, we can just sort the cars by their starting positions,\
    \ and then\n        // count the number of cars that are moving left to right\
    \ that are to the left\n        // of a car that's moving right to left.\n   \
    \     // This is the same as the number of cars that are moving right to left\
    \ that are to the right\n        // of a car that's moving left to right.\n  \
    \      // So, we can just sort the cars by their starting positions, and then\n\
    \        // count the number of cars that are moving left to right that are to\
    \ the left\n        // of a car that's moving right to left.\n        // This\
    \ is the same as the number of cars that are moving right to left that are to\
    \ the right\n        // of a car that's moving left to right.\n        // So,\
    \ we can just sort the cars by their starting positions, and then\n        //\
    \ count the number of cars that are moving left to right that are to the left\n\
    \        // of a car that's moving right to left.\n        // This is the same\
    \ as the number of cars that are moving right to left that are to the right\n\
    \        // of a car that's moving left to right.\n        // So, we can just\
    \ sort the cars by their starting positions, and then\n        // count the number\
    \ of cars that are moving left to right that are to the left\n        // of a\
    \ car that's moving right to left.\n        // This is the same as the number\
    \ of cars that are moving right to\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmptye28esw.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// The idea is to sort the cars by their starting positions.\e[0m\n\e[31m14\
    \ |\e[0m        \e[34m// Then, we can easily count the number of collisions.\e\
    [0m\n\e[31m15 |\e[0m        \e[34m// The number of collisions is the number of\
    \ cars that are moving left to right\e[0m\n\e[31m16 |\e[0m        \e[34m// that\
    \ are to the left of a car that's moving right to left.\e[0m\n\e[31m17 |\e[0m\
    \        \e[34m// This is the same as the number of cars that are moving right\
    \ to left\e[0m\n\e[31m18 |\e[0m        \e[34m// that are to the right of a car\
    \ that's moving left to right.\e[0m\n\e[31m19 |\e[0m        \e[34m// So, we can\
    \ just sort the cars by their starting positions, and then\e[0m\n\e[31m20 |\e\
    [0m        \e[34m// count the number of cars that are moving left to right that\
    \ are to the left\e[0m\n\e[31m21 |\e[0m        \e[34m// of a car that's moving\
    \ right to left.\e[0m\n\e[31m22 |\e[0m        \e[34m// This is the same as the\
    \ number of cars that are moving right to left that are to the right\e[0m\n\e\
    [31m23 |\e[0m        \e[34m// of a car that's moving left to right.\e[0m\n\e[31m24\
    \ |\e[0m        \e[34m// So, we can just sort the cars by their starting positions,\
    \ and then\e[0m\n\e[31m25 |\e[0m        \e[34m// count the number of cars that\
    \ are moving left to right that are to the left\e[0m\n\e[31m26 |\e[0m        \e\
    [34m// of a car that's moving right to left.\e[0m\n\e[31m27 |\e[0m        \e[34m//\
    \ This is the same as the number of cars that are moving right to left that are\
    \ to the right\e[0m\n\e[31m28 |\e[0m        \e[34m// of a car that's moving left\
    \ to right.\e[0m\n\e[31m29 |\e[0m        \e[34m// So, we can just sort the cars\
    \ by their starting positions, and then\e[0m\n\e[31m30"
  stdout: ''
  timestamp: 1659792707
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is a simple problem\
    \ that can be solved by a simple greedy algorithm.\n        // The greedy algorithm\
    \ is as follows:\n        // 1.  Sort the cars by their starting position.\n \
    \       // 2.  For each car, find the first car that's moving in the opposite\
    \ direction.\n        // 3.  The number of collisions is the number of cars that\
    \ have a car moving in the opposite direction.\n        // This algorithm is correct\
    \ because if a car moving in one direction collides with a car moving in the opposite\
    \ direction,\n        // then the car moving in the opposite direction must be\
    \ the first car moving in the opposite direction.\n        // This algorithm is\
    \ also optimal because if a car moving in one direction collides with a car moving\
    \ in the opposite direction,\n        // then the car moving in the opposite direction\
    \ must be the first car moving in the opposite direction.\n        // This algorithm\
    \ is also fast because it runs in O(n log n) time.\n        // The algorithm is\
    \ implemented below.\n        val cars = new Array[(Long, Boolean)](2 * n.toInt)\n\
    \        for (i <- 0 until n.toInt) {\n            cars(i) = (i.toLong, true)\n\
    \            cars(i + n.toInt) = (i.toLong, false)\n        }\n        val sortedCars\
    \ = cars.sortWith((a, b) => a._1 < b._1)\n        var collisions = 0\n       \
    \ for (i <- 0 until 2 * n.toInt) {\n            if (sortedCars(i)._2) {\n    \
    \            for (j <- i + 1 until 2 * n.toInt) {\n                    if (!sortedCars(j)._2)\
    \ {\n                        collisions += 1\n                        break\n\
    \                    }\n                }\n            }\n        }\n        collisions\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpzc6k1t8z.scala:36:24 ------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m                        break\n\e[31m\e[31m   |\e[0m\
    \                        ^^^^^\e[0m\n\e[31m   |\e[0m                        Not\
    \ found: break\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659792705
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting positions.\n        // Then, we can simply count\
    \ the number of cars that are moving left to right\n        // and the number\
    \ of cars that are moving right to left.  The number of collisions\n        //\
    \ is the product of these two numbers.\n        // The number of cars moving left\
    \ to right is n.\n        // The number of cars moving right to left is n - 1.\n\
    \        // Therefore, the number of collisions is n * (n - 1).\n        n * (n\
    \ - 1)\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2ql1gzwd.scala:23)\n\tat Problem.main(tmp2ql1gzwd.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792707
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is the number\
    \ of cars that are moving left to right.\n        // The cars are indexed from\
    \ 0 to n - 1.\n        // The car with index i starts at position i.\n       \
    \ // The car with index i moves at speed i.\n        // The car with index i moves\
    \ left to right.\n        // The car with index i will collide with the car with\
    \ index n - 1 - i.\n        // The car with index i will collide with the car\
    \ with index n - 1 - i at time (n - 1 - i) / i.\n        // The car with index\
    \ i will collide with the car with index n - 1 - i at position (n - 1 - i) * (n\
    \ - 1 - i) / i.\n        // The car with index i will collide with the car with\
    \ index n - 1 - i at position (n - 1 - i) * (n - 1 - i) / i + i.\n        // The\
    \ car with index i will collide with the car with index n - 1 - i at position\
    \ (n - 1 - i) * (n - 1 - i) / i + i + (n - 1 - i).\n        // The car with index\
    \ i will collide with the car with index n - 1 - i at position (n - 1 - i) * (n\
    \ - 1 - i) / i + i + (n - 1 - i) + i.\n        // The car with index i will collide\
    \ with the car with index n - 1 - i at position (n - 1 - i) * (n - 1 - i) / i\
    \ + i + (n - 1 - i) + i + (n - 1 - i).\n        // The car with index i will collide\
    \ with the car with index n - 1 - i at position (n - 1 - i) * (n - 1 - i) / i\
    \ + i + (n - 1 - i) + i + (n - 1 - i) + i.\n        // The car with index i will\
    \ collide with the car with index n - 1 - i at position (n - 1 - i) * (n - 1 -\
    \ i) / i + i + (n - 1 - i) + i + (n - 1 - i) + i + (n - 1 - i).\n        // The\
    \ car with index i will collide with the car with index n -\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpza9p1ifu.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// This is the number of cars that are moving left to right.\e[0m\n\e[31m14\
    \ |\e[0m        \e[34m// The cars are indexed from 0 to n - 1.\e[0m\n\e[31m15\
    \ |\e[0m        \e[34m// The car with index i starts at position i.\e[0m\n\e[31m16\
    \ |\e[0m        \e[34m// The car with index i moves at speed i.\e[0m\n\e[31m17\
    \ |\e[0m        \e[34m// The car with index i moves left to right.\e[0m\n\e[31m18\
    \ |\e[0m        \e[34m// The car with index i will collide with the car with index\
    \ n - 1 - i.\e[0m\n\e[31m19 |\e[0m        \e[34m// The car with index i will collide\
    \ with the car with index n - 1 - i at time (n - 1 - i) / i.\e[0m\n\e[31m20 |\e\
    [0m        \e[34m// The car with index i will collide with the car with index\
    \ n - 1 - i at position (n - 1 - i) * (n - 1 - i) / i.\e[0m\n\e[31m21 |\e[0m \
    \       \e[34m// The car with index i will collide with the car with index n -\
    \ 1 - i at position (n - 1 - i) * (n - 1 - i) / i + i.\e[0m\n\e[31m22 |\e[0m \
    \       \e[34m// The car with index i will collide with the car with index n -\
    \ 1 - i at position (n - 1 - i) * (n - 1 - i) / i + i + (n - 1 - i).\e[0m\n\e\
    [31m23 |\e[0m        \e[34m// The car with index i will collide with the car with\
    \ index n - 1 - i at position (n - 1 - i) * (n - 1 - i) / i + i + (n - 1 - i)\
    \ + i.\e[0m\n\e[31m24 |\e[0m        \e[34m// The car with index i will collide\
    \ with the car with index n - 1 - i at position (n - 1 - i) * (n - 1 - i) / i\
    \ + i + (n - 1 - i) + i + (n - 1 - i).\e[0m\n\e[31m25 |\e[0m        \e[34m// The\
    \ car with index i will collide with the car with index n - 1 - i at position\
    \ (n - 1 - i) * (n - 1 - i) / i + i + (n - 1 - i) + i + (n - 1 - i) + i.\e[0m\n\
    \e[31m26 |\e[0m        \e[34m// The car"
  stdout: ''
  timestamp: 1659792709
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // We can represent the\
    \ cars as a list of pairs (x, y), where x is the position of the car\n       \
    \ // and y is the direction of the car.  A car moving left to right has y = 1,\
    \ and a car\n        // moving right to left has y = -1.  We can sort the list\
    \ by x, and then count the number\n        // of pairs (x, y) where y = 1 and\
    \ (x, -y) is also in the list.\n        val cars = (for (i <- 1 to n.toInt) yield\
    \ (i, 1)).toList ++ (for (i <- 1 to n.toInt) yield (i, -1)).toList\n        val\
    \ sortedCars = cars.sortBy(_._1)\n        var collisions = 0\n        for (i <-\
    \ 0 until sortedCars.length) {\n            val (x, y) = sortedCars(i)\n     \
    \       if (y == 1) {\n                val (x2, y2) = sortedCars(sortedCars.length\
    \ - 1 - i)\n                if (x2 == x && y2 == -y) collisions += 1\n       \
    \     }\n        }\n        collisions\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp20b_mga0.scala:30)\n\tat Problem.main(tmp20b_mga0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792711
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is a very simple\
    \ problem.  The cars are moving in the same speed, so\n        // the order of\
    \ the cars does not matter.  The only thing that matters is the\n        // distance\
    \ between the cars.  So, we can imagine that all the cars are moving\n       \
    \ // in the same direction.  Then, the problem reduces to finding the number of\n\
    \        // pairs of cars that are at the same position.  This is a simple combinatorics\n\
    \        // problem.  The answer is n * (n - 1) / 2.\n        n * (n - 1) / 2\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmponcmfm33.scala:22)\n\tat Problem.main(tmponcmfm33.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792708
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // We can solve this problem\
    \ by first sorting the cars by their starting positions.\n        // Then, we\
    \ can iterate through the cars from left to right.  We can keep track of the\n\
    \        // number of cars that are moving right to left that are to the left\
    \ of the current car.\n        // This is the number of collisions that the current\
    \ car will have.\n        // This algorithm runs in O(n log n) time.\n       \
    \ val cars = new Array[Long](2 * n.toInt)\n        for (i <- 0 until n.toInt)\
    \ {\n            cars(i) = i + 1\n            cars(i + n.toInt) = -(i + 1)\n \
    \       }\n        val sortedCars = cars.sorted\n        var collisions = 0L\n\
    \        var rightToLeftCars = 0\n        for (i <- 0 until 2 * n.toInt) {\n \
    \           if (sortedCars(i) < 0) rightToLeftCars += 1\n            else collisions\
    \ += rightToLeftCars\n        }\n        collisions\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792710
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // We can solve this problem\
    \ by considering the cars as points on a number line.\n        // The cars moving\
    \ left to right are at positions 1, 2, ..., n.\n        // The cars moving right\
    \ to left are at positions -1, -2, ..., -n.\n        // A collision occurs when\
    \ the absolute value of the difference between the positions\n        // of two\
    \ cars is equal to 1.\n        // For example, if n = 3, then the cars moving\
    \ left to right are at positions 1, 2, 3.\n        // The cars moving right to\
    \ left are at positions -1, -2, -3.\n        // The collisions are:\n        //\
    \ 1 and -1\n        // 2 and -2\n        // 3 and -3\n        // The total number\
    \ of collisions is 3.\n        // We can generalize this to any value of n.\n\
    \        // The total number of collisions is n.\n        n\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp88367xrl.scala:30)\n\tat Problem.main(tmp88367xrl.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792709
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        val cars = new Array[Long](2\
    \ * n.toInt)\n        for (i <- 0 until n.toInt) {\n            cars(i) = i +\
    \ 1\n            cars(i + n.toInt) = -(i + 1)\n        }\n        cars.sorted.zipWithIndex.filter(x\
    \ => x._1 < 0 && x._2 < n.toInt).size\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpn7o70abb.scala:21)\n\tat Problem.main(tmpn7o70abb.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792711
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to use\
    \ a priority queue to store the cars that are moving left to right.\n        //\
    \ We will store the cars in the priority queue in increasing order of their position.\n\
    \        // Then, we will iterate through the cars that are moving right to left.\
    \  For each car\n        // that is moving right to left, we will remove all cars\
    \ from the priority queue that\n        // have a position less than the position\
    \ of the car that is moving right to left.\n        // The number of cars removed\
    \ from the priority queue is the number of collisions.\n        // The reason\
    \ is that the cars that are removed from the priority queue are the cars\n   \
    \     // that are moving left to right and have collided with the car that is\
    \ moving right to left.\n        // The cars that are moving left to right are\
    \ in increasing order of their position.\n        // Thus, the cars that are removed\
    \ from the priority queue are in increasing order of their\n        // position.\
    \  Thus, the cars that are removed from the priority queue are the cars that\n\
    \        // have collided with the car that is moving right to left.\n       \
    \ val pq = new PriorityQueue[Long]()\n        var collisions = 0L\n        for\
    \ (i <- 1 to n.toInt) {\n            pq.enqueue(i)\n        }\n        for (i\
    \ <- n.toInt to 1 by -1) {\n            collisions += pq.size\n            pq.dequeue\n\
    \        }\n        collisions\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpvrp5k52v.scala:37)\n\tat Problem.main(tmpvrp5k52v.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792711
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is a simple problem.\
    \  The key observation is that the cars that are moving\n        // in the same\
    \ direction will never collide.  So, we only need to count the number\n      \
    \  // of collisions between cars that are moving in opposite directions.\n   \
    \     //\n        // The cars that are moving in the same direction are easy to\
    \ count.  The first car\n        // will collide with n - 1 cars.  The second\
    \ car will collide with n - 2 cars.\n        // The third car will collide with\
    \ n - 3 cars.  The nth car will collide with 0 cars.\n        // So, the total\
    \ number of collisions is n + (n - 1) + (n - 2) + ... + 1 = n * (n + 1) / 2.\n\
    \        //\n        // The cars that are moving in opposite directions are also\
    \ easy to count.  The first car\n        // will collide with n cars.  The second\
    \ car will collide with n - 1 cars.  The third car\n        // will collide with\
    \ n - 2 cars.  The nth car will collide with 1 car.  So, the total number\n  \
    \      // of collisions is n + (n - 1) + (n - 2) + ... + 1 = n * (n + 1) / 2.\n\
    \        //\n        // So, the total number of collisions is 2 * n * (n + 1)\
    \ / 2 = n * (n + 1).\n        n * (n + 1)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpeawjwtzp.scala:31)\n\tat Problem.main(tmpeawjwtzp.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792709
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is a very simple\
    \ problem.  The key is to realize that the cars\n        // are moving at the\
    \ same speed.  As a result, the only thing that matters\n        // is the order\
    \ in which the cars appear on the road.  For example, if the\n        // cars\
    \ are ordered as follows:\n        //\n        //    1 2 3 4 5 6 7 8 9 10\n  \
    \      //\n        // Then there will be no collisions.  However, if the cars\
    \ are ordered as follows:\n        //\n        //    1 2 3 4 5 6 7 8 9 10\n  \
    \      //    10 9 8 7 6 5 4 3 2 1\n        //\n        // Then there will be 9\
    \ collisions.  In general, if the cars are ordered as follows:\n        //\n \
    \       //    1 2 3 4 5 6 7 8 9 10\n        //    a b c d e f g h i j\n      \
    \  //\n        // Then there will be (a - 1) + (b - 2) + (c - 3) + ... + (j -\
    \ 10) collisions.\n        //\n        // The problem is to find the number of\
    \ collisions for a given n.  This is\n        // equivalent to finding the number\
    \ of permutations of the numbers 1 to n\n        // such that the sum of the differences\
    \ between the numbers is negative.\n        //\n        // For example, if n =\
    \ 3, then the permutations are:\n        //\n        //    1 2 3\n        // \
    \   1 3 2\n        //    2 1 3\n        //    2 3 1\n        //    3 1 2\n   \
    \     //    3 2 1\n        //\n        // The permutations that have a negative\
    \ sum of differences are:\n        //\n        //    1 3 2\n        //    2 3\
    \ 1\n        //    3 1 2\n        //\n        // The number of such permutations\
    \ is 3.\n        //\n        // The problem is to find the number of such permutations\
    \ for a given n.\n        //\n        // The answer is given by the following\
    \ formula:\n        //\n        //    (n - 1) * (n - 2) * (n - 3) * ... * 1\n\
    \        //\n        // This is because the sum of the differences is given by\
    \ the following formula:\n        //\n        //    (1 - a) + (\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n\
    \    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4j8l75en.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// This is a very simple problem.  The key is to realize that the cars\e[0m\n\
    \e[31m14 |\e[0m        \e[34m// are moving at the same speed.  As a result, the\
    \ only thing that matters\e[0m\n\e[31m15 |\e[0m        \e[34m// is the order in\
    \ which the cars appear on the road.  For example, if the\e[0m\n\e[31m16 |\e[0m\
    \        \e[34m// cars are ordered as follows:\e[0m\n\e[31m17 |\e[0m        \e\
    [34m//\e[0m\n\e[31m18 |\e[0m        \e[34m//    1 2 3 4 5 6 7 8 9 10\e[0m\n\e\
    [31m19 |\e[0m        \e[34m//\e[0m\n\e[31m20 |\e[0m        \e[34m// Then there\
    \ will be no collisions.  However, if the cars are ordered as follows:\e[0m\n\e\
    [31m21 |\e[0m        \e[34m//\e[0m\n\e[31m22 |\e[0m        \e[34m//    1 2 3 4\
    \ 5 6 7 8 9 10\e[0m\n\e[31m23 |\e[0m        \e[34m//    10 9 8 7 6 5 4 3 2 1\e\
    [0m\n\e[31m24 |\e[0m        \e[34m//\e[0m\n\e[31m25 |\e[0m        \e[34m// Then\
    \ there will be 9 collisions.  In general, if the cars are ordered as follows:\e\
    [0m\n\e[31m26 |\e[0m        \e[34m//\e[0m\n\e[31m27 |\e[0m        \e[34m//   \
    \ 1 2 3 4 5 6 7 8 9 10\e[0m\n\e[31m28 |\e[0m        \e[34m//    a b c d e f g\
    \ h i j\e[0m\n\e[31m29 |\e[0m        \e[34m//\e[0m\n\e[31m30 |\e[0m        \e\
    [34m// Then there will be (a - 1) + (b - 2) + (c - 3) + ... + (j - 10) collisions.\e\
    [0m\n\e[31m31 |\e[0m        \e[34m//\e[0m\n\e[31m32 |\e[0m        \e[34m// The\
    \ problem is to find the number of collisions for a given n.  This is\e[0m\n\e\
    [31m33 |\e[0m        \e[34m// equivalent to finding the number of permutations\
    \ of the numbers 1 to n\e[0m\n\e[31m34 |\e[0m        \e[34m// such that the sum\
    \ of the differences between the numbers is negative.\e[0m\n\e[31m35 |\e[0m  \
    \      \e[34m//\e[0m\n\e[31m36 |\e[0m        \e[34m// For example, if n = 3, then\
    \ the pe"
  stdout: ''
  timestamp: 1659792710
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is a simple problem\
    \ that can be solved with a simple algorithm.\n        // The algorithm is as\
    \ follows:\n        // 1.  Sort the cars by their starting position.\n       \
    \ // 2.  For each car, check if it collides with any of the cars that are\n  \
    \      //     already in the list.  If it does, increment the collision count.\n\
    \        //     If it doesn't, add it to the list.\n        // 3.  Return the\
    \ collision count.\n        // The following code implements this algorithm.\n\
    \        var collisionCount = 0L\n        var cars = new ArrayBuffer[Long]\n \
    \       for (i <- 1 to n.toInt) {\n            var car = (i.toLong * n) % (2 *\
    \ n)\n            if (car > n) car = 2 * n - car\n            var j = 0\n    \
    \        while (j < cars.length && cars(j) < car) j += 1\n            if (j <\
    \ cars.length) collisionCount += 1\n            cars.insert(j, car)\n        }\n\
    \        collisionCount\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5l2mqrqo.scala:34)\n\tat Problem.main(tmp5l2mqrqo.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792711
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting position.\n        // Then, we can iterate through\
    \ the cars, and for each car,\n        // we can find the number of cars that\
    \ are on the other side\n        // of the road that are closer to the current\
    \ car than the current car is to the other side of the road.\n        // This\
    \ is the number of collisions that the current car will have.\n        // We add\
    \ this number to the total number of collisions.\n        // The time complexity\
    \ is O(n log n).\n        // The space complexity is O(n).\n        val cars =\
    \ Array.fill(2 * n.toInt)(0)\n        for (i <- 0 until n.toInt) {\n         \
    \   cars(i) = i + 1\n            cars(i + n.toInt) = -(i + 1)\n        }\n   \
    \     val sortedCars = cars.sorted\n        var collisions = 0L\n        for (i\
    \ <- 0 until 2 * n.toInt) {\n            val car = sortedCars(i)\n           \
    \ val carPos = abs(car)\n            val otherSide = if (car > 0) -1 else 1\n\
    \            var j = i + 1\n            while (j < 2 * n.toInt && abs(sortedCars(j))\
    \ < carPos) {\n                if (sortedCars(j) * otherSide > 0) collisions +=\
    \ 1\n                j += 1\n            }\n        }\n        collisions\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_bihy7rp.scala:41)\n\tat Problem.main(tmp_bihy7rp.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792713
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // We can assume that\
    \ the cars are numbered from 1 to n.\n        // We can also assume that the cars\
    \ are ordered by their initial positions.\n        // In other words, car 1 is\
    \ the leftmost car, car 2 is the second leftmost car, etc.\n        // Similarly,\
    \ car n is the rightmost car, car n-1 is the second rightmost car, etc.\n    \
    \    // We can also assume that the cars are ordered by their speeds.\n      \
    \  // In other words, car 1 is the fastest car, car 2 is the second fastest car,\
    \ etc.\n        // Similarly, car n is the slowest car, car n-1 is the second\
    \ slowest car, etc.\n        // We can also assume that the cars are ordered by\
    \ their directions.\n        // In other words, car 1 is the leftmost car moving\
    \ left to right, car 2 is the second leftmost car moving left to right, etc.\n\
    \        // Similarly, car n is the rightmost car moving right to left, car n-1\
    \ is the second rightmost car moving right to left, etc.\n        // We can also\
    \ assume that the cars are ordered by their initial positions.\n        // In\
    \ other words, car 1 is the leftmost car, car 2 is the second leftmost car, etc.\n\
    \        // Similarly, car n is the rightmost car, car n-1 is the second rightmost\
    \ car, etc.\n        // We can also assume that the cars are ordered by their\
    \ speeds.\n        // In other words, car 1 is the fastest car, car 2 is the second\
    \ fastest car, etc.\n        // Similarly, car n is the slowest car, car n-1 is\
    \ the second slowest car, etc.\n        // We can also assume that the cars are\
    \ ordered by their directions.\n        // In other words, car 1 is the leftmost\
    \ car moving left to right, car 2 is the second leftmost car moving left to right,\
    \ etc.\n        // Similarly, car n is the rightmost car moving right to left,\
    \ car n-1 is the second rightmost car moving right to left, etc.\n        // We\
    \ can also assume that the cars are ordered by their initial positions.\n    \
    \    // In other words, car 1 is the leftmost car, car 2 is the second leftmost\
    \ car, etc.\n        // Similarly, car n is the rightmost car, car n\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n\
    \    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpghagisxf.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// We can assume that the cars are numbered from 1 to n.\e[0m\n\e[31m14 |\e\
    [0m        \e[34m// We can also assume that the cars are ordered by their initial\
    \ positions.\e[0m\n\e[31m15 |\e[0m        \e[34m// In other words, car 1 is the\
    \ leftmost car, car 2 is the second leftmost car, etc.\e[0m\n\e[31m16 |\e[0m \
    \       \e[34m// Similarly, car n is the rightmost car, car n-1 is the second\
    \ rightmost car, etc.\e[0m\n\e[31m17 |\e[0m        \e[34m// We can also assume\
    \ that the cars are ordered by their speeds.\e[0m\n\e[31m18 |\e[0m        \e[34m//\
    \ In other words, car 1 is the fastest car, car 2 is the second fastest car, etc.\e\
    [0m\n\e[31m19 |\e[0m        \e[34m// Similarly, car n is the slowest car, car\
    \ n-1 is the second slowest car, etc.\e[0m\n\e[31m20 |\e[0m        \e[34m// We\
    \ can also assume that the cars are ordered by their directions.\e[0m\n\e[31m21\
    \ |\e[0m        \e[34m// In other words, car 1 is the leftmost car moving left\
    \ to right, car 2 is the second leftmost car moving left to right, etc.\e[0m\n\
    \e[31m22 |\e[0m        \e[34m// Similarly, car n is the rightmost car moving right\
    \ to left, car n-1 is the second rightmost car moving right to left, etc.\e[0m\n\
    \e[31m23 |\e[0m        \e[34m// We can also assume that the cars are ordered by\
    \ their initial positions.\e[0m\n\e[31m24 |\e[0m        \e[34m// In other words,\
    \ car 1 is the leftmost car, car 2 is the second leftmost car, etc.\e[0m\n\e[31m25\
    \ |\e[0m        \e[34m// Similarly, car n is the rightmost car, car n-1 is the\
    \ second rightmost car, etc.\e[0m\n\e[31m26 |\e[0m        \e[34m// We can also\
    \ assume that the cars are ordered by their speeds.\e[0m\n\e[31m27 |\e[0m    \
    \    \e[34m// In other words, car 1 "
  stdout: ''
  timestamp: 1659792711
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting positions.\n        // Then, we can just count the\
    \ number of cars that are moving left to right\n        // that are to the left\
    \ of a car that's moving right to left.\n        // This is equivalent to counting\
    \ the number of inversions in the array.\n        // The number of inversions\
    \ is O(n log n).\n        val leftToRight = Array.fill(n.toInt)(scala.util.Random.nextInt(n.toInt))\n\
    \        val rightToLeft = Array.fill(n.toInt)(scala.util.Random.nextInt(n.toInt))\n\
    \        val sortedLeftToRight = leftToRight.sorted\n        val sortedRightToLeft\
    \ = rightToLeft.sorted\n        var count = 0L\n        for (i <- 0 until n.toInt)\
    \ {\n            val index = sortedRightToLeft(i.toInt)\n            val left\
    \ = sortedLeftToRight.indexWhere(_ >= index)\n            if (left != -1) count\
    \ += left\n        }\n        count\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpb78hpd3i.scala:31)\n\tat Problem.main(tmpb78hpd3i.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792714
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // We can solve this problem\
    \ by using a sweep line algorithm.\n        // The sweep line starts at the leftmost\
    \ point of the road.\n        // We keep track of the cars that are currently\
    \ on the road.\n        // We keep track of the cars that are currently on the\
    \ road by using a heap.\n        // The heap is sorted by the x-coordinate of\
    \ the car.\n        // The heap is a min-heap.\n        // The heap contains the\
    \ cars that are currently on the road.\n        // The heap contains the cars\
    \ that are currently on the road, and the cars that are\n        // about to enter\
    \ the road.\n        // The heap contains the cars that are currently on the road,\
    \ and the cars that are\n        // about to enter the road, and the cars that\
    \ are about to leave the road.\n        // The heap contains the cars that are\
    \ currently on the road, and the cars that are\n        // about to enter the\
    \ road, and the cars that are about to leave the road, and the cars\n        //\
    \ that are about to collide.\n        // The heap contains the cars that are currently\
    \ on the road, and the cars that are\n        // about to enter the road, and\
    \ the cars that are about to leave the road, and the cars\n        // that are\
    \ about to collide, and the cars that are about to collide with the cars that\n\
    \        // are about to collide.\n        // The heap contains the cars that\
    \ are currently on the road, and the cars that are\n        // about to enter\
    \ the road, and the cars that are about to leave the road, and the cars\n    \
    \    // that are about to collide, and the cars that are about to collide with\
    \ the cars that\n        // are about to collide, and the cars that are about\
    \ to collide with the cars that are\n        // about to collide with the cars\
    \ that are about to collide.\n        // The heap contains the cars that are currently\
    \ on the road, and the cars that are\n        // about to enter the road, and\
    \ the cars that are about to leave the road, and the cars\n        // that are\
    \ about to collide, and the cars that are about to collide with the cars that\n\
    \        // are about to collide, and the cars that are about to collide with\
    \ the cars that are\n        // about to collide with the cars that are about\
    \ to collide, and the cars that are about\n       \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpw8obe5am.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// We can solve this problem by using a sweep line algorithm.\e[0m\n\e[31m14\
    \ |\e[0m        \e[34m// The sweep line starts at the leftmost point of the road.\e\
    [0m\n\e[31m15 |\e[0m        \e[34m// We keep track of the cars that are currently\
    \ on the road.\e[0m\n\e[31m16 |\e[0m        \e[34m// We keep track of the cars\
    \ that are currently on the road by using a heap.\e[0m\n\e[31m17 |\e[0m      \
    \  \e[34m// The heap is sorted by the x-coordinate of the car.\e[0m\n\e[31m18\
    \ |\e[0m        \e[34m// The heap is a min-heap.\e[0m\n\e[31m19 |\e[0m       \
    \ \e[34m// The heap contains the cars that are currently on the road.\e[0m\n\e\
    [31m20 |\e[0m        \e[34m// The heap contains the cars that are currently on\
    \ the road, and the cars that are\e[0m\n\e[31m21 |\e[0m        \e[34m// about\
    \ to enter the road.\e[0m\n\e[31m22 |\e[0m        \e[34m// The heap contains the\
    \ cars that are currently on the road, and the cars that are\e[0m\n\e[31m23 |\e\
    [0m        \e[34m// about to enter the road, and the cars that are about to leave\
    \ the road.\e[0m\n\e[31m24 |\e[0m        \e[34m// The heap contains the cars that\
    \ are currently on the road, and the cars that are\e[0m\n\e[31m25 |\e[0m     \
    \   \e[34m// about to enter the road, and the cars that are about to leave the\
    \ road, and the cars\e[0m\n\e[31m26 |\e[0m        \e[34m// that are about to collide.\e\
    [0m\n\e[31m27 |\e[0m        \e[34m// The heap contains the cars that are currently\
    \ on the road, and the cars that are\e[0m\n\e[31m28 |\e[0m        \e[34m// about\
    \ to enter the road, and the cars that are about to leave the road, and the cars\e\
    [0m\n\e[31m29 |\e[0m        \e[34m// that are about to collide, and the cars that\
    \ are about to collide with the c"
  stdout: ''
  timestamp: 1659792713
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is a classic problem\
    \ in combinatorics.\n        // The answer is n * (n - 1) / 2.\n        // The\
    \ proof is simple:\n        // Let's say that the left-to-right cars are numbered\
    \ 1 to n, and the right-to-left cars\n        // are numbered 1 to n.  The number\
    \ of collisions is the number of pairs of cars that\n        // collide.  This\
    \ is the number of pairs of cars that are in the same position at the same time.\n\
    \        // The number of pairs of cars that are in the same position at the same\
    \ time is the number of\n        // pairs of cars that start out in the same position.\
    \  This is the number of pairs of cars that\n        // start out in the same\
    \ position, which is n * (n - 1) / 2.\n        n * (n - 1) / 2\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n\
    \    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpoe1zf6bf.scala:25)\n\tat Problem.main(tmpoe1zf6bf.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792713
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting positions.\n        // Then, we can use a sweep line\
    \ algorithm to count the number of collisions.\n        // The sweep line algorithm\
    \ is as follows:\n        // 1.  We start with the leftmost car.  We count the\
    \ number of cars that are\n        //     to the right of it.  This is the number\
    \ of collisions that the leftmost\n        //     car will have.\n        // 2.\
    \  We move the sweep line to the right.  We count the number of cars that\n  \
    \      //     are to the right of it.  This is the number of collisions that the\
    \ next\n        //     car will have.\n        // 3.  We repeat step 2 until we\
    \ reach the rightmost car.\n        // 4.  We sum up the number of collisions\
    \ for each car.\n        // The time complexity is O(n log n).\n        val cars\
    \ = new Array[Long](2 * n.toInt)\n        for (i <- 0 until n.toInt) {\n     \
    \       cars(i) = i + 1\n            cars(i + n.toInt) = -(i + 1)\n        }\n\
    \        val sortedCars = cars.sorted\n        var numCollisions = 0L\n      \
    \  var numCarsToRight = 0\n        for (i <- 0 until 2 * n.toInt) {\n        \
    \    if (sortedCars(i) > 0) {\n                numCollisions += numCarsToRight\n\
    \                numCarsToRight += 1\n            } else {\n                numCarsToRight\
    \ -= 1\n            }\n        }\n        numCollisions\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptig80afh.scala:44)\n\tat Problem.main(tmptig80afh.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792716
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This function returns\
    \ the number of collisions between the cars moving left to right\n        // and\
    \ the cars moving right to left.\n        def carRaceCollisionHelper(n : Long,\
    \ leftToRight : List[Long], rightToLeft : List[Long]) : Long = {\n           \
    \ if (n == 0) 0\n            else {\n                val leftToRightHead = leftToRight.head\n\
    \                val rightToLeftHead = rightToLeft.head\n                if (leftToRightHead\
    \ < rightToLeftHead) carRaceCollisionHelper(n - 1, leftToRight.tail, rightToLeft)\n\
    \                else carRaceCollisionHelper(n - 1, leftToRight.tail, rightToLeft.tail)\
    \ + 1\n            }\n        }\n        carRaceCollisionHelper(n, (1 to n.toInt).toList,\
    \ (n to 1 by -1).toList)\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4nbpw599.scala:24:49\
    \ --------------------\e[0m\e[0m\n\e[31m24 |\e[0m        carRaceCollisionHelper(n,\
    \ (\e[31m1\e[0m to n.toInt).toList, (n to \e[31m1\e[0m by -\e[31m1\e[0m).toList)\n\
    \e[31m\e[31m   |\e[0m                                  ^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    List[\e[1m\e[31mInt\e\
    [0m]\n\e[31m   |\e[0m                                  Required: List[\e[1m\e\
    [32mLong\e[0m]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659792715
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting position.\n        // Then, we can simulate the race\
    \ by iterating through the cars\n        // and checking if the current car collides\
    \ with any of the cars\n        // that are ahead of it.\n        // The time\
    \ complexity is O(n log n) because of the sorting.\n        // The space complexity\
    \ is O(n) because of the sorting.\n        val cars = Array.fill(n.toInt)((Random.nextInt(n.toInt),\
    \ Random.nextInt(n.toInt)))\n        val sortedCars = cars.sortBy(_._1)\n    \
    \    var collisions = 0\n        for (i <- 0 until n.toInt) {\n            val\
    \ car = sortedCars(i)\n            for (j <- i + 1 until n.toInt) {\n        \
    \        val otherCar = sortedCars(j)\n                if (car._2 < otherCar._2)\
    \ collisions += 1\n            }\n        }\n        collisions\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n\
    \    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpw67jdk4t.scala:19:40 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mcars\e[0m = Array.fill(n.toInt)((Random.nextInt(n.toInt),\
    \ Random.nextInt(n.toInt)))\n\e[31m\e[31m   |\e[0m                           \
    \             ^^^^^^\e[0m\n\e[31m   |\e[0m                                   \
    \     Not found: Random\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpw67jdk4t.scala:19:65\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mcars\e[0m = Array.fill(n.toInt)((Random.nextInt(n.toInt), Random.nextInt(n.toInt)))\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \         ^^^^^^\e[0m\n\e[31m   |\e[0m                                       \
    \                Not found: Random\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- Error: /tmp/tmpw67jdk4t.scala:20:42\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m20 |\e[0m       \
    \ \e[33mval\e[0m \e[36msortedCars\e[0m = cars.sortBy(_._1)\n\e[31m\e[31m   |\e\
    [0m                                          ^\e[0m\n\e[31m   |\e[0mambiguous\
    \ given instances: both \e[33mobject\e[0m \e[35mInt\e[0m in \e[33mobject\e[0m\
    \ \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mChar\e[0m in \e[33mobject\e\
    [0m \e[35mOrdering\e[0m match type Ordering[B] of parameter ord of \e[33mmethod\e\
    [0m \e[35msortBy\e[0m in \e[33mclass\e[0m \e[35mArrayOps\e[0m\n3 errors found\n"
  stdout: ''
  timestamp: 1659792714
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The cars are numbered\
    \ from 1 to n.  The cars that are moving left to right\n        // are numbered\
    \ from 1 to n, and the cars that are moving right to left are\n        // numbered\
    \ from n to 1.\n        // We will assume that the cars are moving at unit speed.\
    \  The cars that are\n        // moving left to right will be called \"positive\
    \ cars\", and the cars that are\n        // moving right to left will be called\
    \ \"negative cars\".\n        // The positive cars will be numbered from 1 to\
    \ n, and the negative cars will\n        // be numbered from -n to -1.\n     \
    \   // The cars will be sorted in the order of their arrival time at the origin.\n\
    \        // The positive cars will be sorted in the order of their arrival time\
    \ at the origin,\n        // and the negative cars will be sorted in the order\
    \ of their arrival time at the origin.\n        // The positive cars will be sorted\
    \ in the order of their arrival time at the origin,\n        // and the negative\
    \ cars will be sorted in the order of their arrival time at the origin.\n    \
    \    // The positive cars will be sorted in the order of their arrival time at\
    \ the origin,\n        // and the negative cars will be sorted in the order of\
    \ their arrival time at the origin.\n        // The positive cars will be sorted\
    \ in the order of their arrival time at the origin,\n        // and the negative\
    \ cars will be sorted in the order of their arrival time at the origin.\n    \
    \    // The positive cars will be sorted in the order of their arrival time at\
    \ the origin,\n        // and the negative cars will be sorted in the order of\
    \ their arrival time at the origin.\n        // The positive cars will be sorted\
    \ in the order of their arrival time at the origin,\n        // and the negative\
    \ cars will be sorted in the order of their arrival time at the origin.\n    \
    \    // The positive cars will be sorted in the order of their arrival time at\
    \ the origin,\n        // and the negative cars will be sorted in the order of\
    \ their arrival time at the origin.\n        // The positive cars will be sorted\
    \ in the order of their arrival time at the origin,\n        // and the negative\
    \ cars will be sorted in the order of their arrival time at the origin.\n    \
    \    // The positive cars will be sorted in the order of their arrival time at\
    \ the origin,\n        // and the negative cars will be sorted in\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n\
    \    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpwqe7mr54.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// The cars are numbered from 1 to n.  The cars that are moving left to right\e\
    [0m\n\e[31m14 |\e[0m        \e[34m// are numbered from 1 to n, and the cars that\
    \ are moving right to left are\e[0m\n\e[31m15 |\e[0m        \e[34m// numbered\
    \ from n to 1.\e[0m\n\e[31m16 |\e[0m        \e[34m// We will assume that the cars\
    \ are moving at unit speed.  The cars that are\e[0m\n\e[31m17 |\e[0m        \e\
    [34m// moving left to right will be called \"positive cars\", and the cars that\
    \ are\e[0m\n\e[31m18 |\e[0m        \e[34m// moving right to left will be called\
    \ \"negative cars\".\e[0m\n\e[31m19 |\e[0m        \e[34m// The positive cars will\
    \ be numbered from 1 to n, and the negative cars will\e[0m\n\e[31m20 |\e[0m  \
    \      \e[34m// be numbered from -n to -1.\e[0m\n\e[31m21 |\e[0m        \e[34m//\
    \ The cars will be sorted in the order of their arrival time at the origin.\e\
    [0m\n\e[31m22 |\e[0m        \e[34m// The positive cars will be sorted in the order\
    \ of their arrival time at the origin,\e[0m\n\e[31m23 |\e[0m        \e[34m// and\
    \ the negative cars will be sorted in the order of their arrival time at the origin.\e\
    [0m\n\e[31m24 |\e[0m        \e[34m// The positive cars will be sorted in the order\
    \ of their arrival time at the origin,\e[0m\n\e[31m25 |\e[0m        \e[34m// and\
    \ the negative cars will be sorted in the order of their arrival time at the origin.\e\
    [0m\n\e[31m26 |\e[0m        \e[34m// The positive cars will be sorted in the order\
    \ of their arrival time at the origin,\e[0m\n\e[31m27 |\e[0m        \e[34m// and\
    \ the negative cars will be sorted in the order of their arrival time at the origin.\e\
    [0m\n\e[31m28 |\e[0m        \e[34m// The positive cars will be sorted in the order\
    \ of th"
  stdout: ''
  timestamp: 1659792716
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is a very simple\
    \ problem.  The cars that are moving left to right\n        // are numbered 1\
    \ to n.  The cars that are moving right to left are numbered\n        // n+1 to\
    \ 2n.  The cars that are moving left to right are at positions\n        // 1,\
    \ 2, 3, ..., n.  The cars that are moving right to left are at positions\n   \
    \     // 2n, 2n-1, 2n-2, ..., n+1.\n        // The cars that are moving left to\
    \ right will collide with the cars that are\n        // moving right to left in\
    \ the following order:\n        // 1 with 2n, 2 with 2n-1, 3 with 2n-2, ..., n\
    \ with n+1.\n        // The number of collisions is therefore n/2.\n        n\
    \ / 2\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmph4jfk0bc.scala:25)\n\tat Problem.main(tmph4jfk0bc.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792717
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is a very simple\
    \ problem.  The cars that are moving left to right\n        // are numbered from\
    \ 0 to n - 1.  The cars that are moving right to left\n        // are numbered\
    \ from n to 2n - 1.  The cars that are moving left to right\n        // are at\
    \ positions 0, 1, 2, ..., n - 1.  The cars that are moving right to left\n   \
    \     // are at positions n, n - 1, n - 2, ..., 1.  The cars that are moving left\
    \ to right\n        // are moving at speeds 1, 1, 1, ..., 1.  The cars that are\
    \ moving right to left\n        // are moving at speeds -1, -1, -1, ..., -1. \
    \ The cars that are moving left to right\n        // are at positions 0, 1, 2,\
    \ ..., n - 1.  The cars that are moving right to left\n        // are at positions\
    \ n, n - 1, n - 2, ..., 1.  The cars that are moving left to right\n        //\
    \ are moving at speeds 1, 1, 1, ..., 1.  The cars that are moving right to left\n\
    \        // are moving at speeds -1, -1, -1, ..., -1.  The cars that are moving\
    \ left to right\n        // are at positions 0, 1, 2, ..., n - 1.  The cars that\
    \ are moving right to left\n        // are at positions n, n - 1, n - 2, ...,\
    \ 1.  The cars that are moving left to right\n        // are moving at speeds\
    \ 1, 1, 1, ..., 1.  The cars that are moving right to left\n        // are moving\
    \ at speeds -1, -1, -1, ..., -1.  The cars that are moving left to right\n   \
    \     // are at positions 0, 1, 2, ..., n - 1.  The cars that are moving right\
    \ to left\n        // are at positions n, n - 1, n - 2, ..., 1.  The cars that\
    \ are moving left to right\n        // are moving at speeds 1, 1, 1, ..., 1. \
    \ The cars that are moving right to left\n        // are moving at speeds -1,\
    \ -1, -1, ..., -1.  The cars that are moving left to right\n       \n    }\n \
    \   def main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n\
    \    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp49o5wwhe.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// This is a very simple problem.  The cars that are moving left to right\e\
    [0m\n\e[31m14 |\e[0m        \e[34m// are numbered from 0 to n - 1.  The cars that\
    \ are moving right to left\e[0m\n\e[31m15 |\e[0m        \e[34m// are numbered\
    \ from n to 2n - 1.  The cars that are moving left to right\e[0m\n\e[31m16 |\e\
    [0m        \e[34m// are at positions 0, 1, 2, ..., n - 1.  The cars that are moving\
    \ right to left\e[0m\n\e[31m17 |\e[0m        \e[34m// are at positions n, n -\
    \ 1, n - 2, ..., 1.  The cars that are moving left to right\e[0m\n\e[31m18 |\e\
    [0m        \e[34m// are moving at speeds 1, 1, 1, ..., 1.  The cars that are moving\
    \ right to left\e[0m\n\e[31m19 |\e[0m        \e[34m// are moving at speeds -1,\
    \ -1, -1, ..., -1.  The cars that are moving left to right\e[0m\n\e[31m20 |\e\
    [0m        \e[34m// are at positions 0, 1, 2, ..., n - 1.  The cars that are moving\
    \ right to left\e[0m\n\e[31m21 |\e[0m        \e[34m// are at positions n, n -\
    \ 1, n - 2, ..., 1.  The cars that are moving left to right\e[0m\n\e[31m22 |\e\
    [0m        \e[34m// are moving at speeds 1, 1, 1, ..., 1.  The cars that are moving\
    \ right to left\e[0m\n\e[31m23 |\e[0m        \e[34m// are moving at speeds -1,\
    \ -1, -1, ..., -1.  The cars that are moving left to right\e[0m\n\e[31m24 |\e\
    [0m        \e[34m// are at positions 0, 1, 2, ..., n - 1.  The cars that are moving\
    \ right to left\e[0m\n\e[31m25 |\e[0m        \e[34m// are at positions n, n -\
    \ 1, n - 2, ..., 1.  The cars that are moving left to right\e[0m\n\e[31m26 |\e\
    [0m        \e[34m// are moving at speeds 1, 1, 1, ..., 1.  The cars that are moving\
    \ right to left\e[0m\n\e[31m27 |\e[0m        \e[34m// are moving at speeds -1,\
    \ -1, -1, ..., -1.  The cars "
  stdout: ''
  timestamp: 1659792716
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The cars are numbered\
    \ from 0 to n-1.\n        // The cars moving left to right are numbered from 0\
    \ to n-1.\n        // The cars moving right to left are numbered from n-1 to 0.\n\
    \        // The cars moving left to right are at positions x_0, x_1, ..., x_{n-1}.\n\
    \        // The cars moving right to left are at positions y_0, y_1, ..., y_{n-1}.\n\
    \        // The cars move at the same speed.\n        // The cars are infinitely\
    \ sturdy and strong.\n        // The cars are infinitely long.\n        // The\
    \ cars are infinitely thin.\n        // The cars are infinitely wide.\n      \
    \  // The cars are infinitely tall.\n        // The cars are infinitely heavy.\n\
    \        // The cars are infinitely light.\n        // The cars are infinitely\
    \ strong.\n        // The cars are infinitely sturdy.\n        // The cars are\
    \ infinitely fast.\n        // The cars are infinitely slow.\n        // The cars\
    \ are infinitely fast.\n        // The cars are infinitely slow.\n        // The\
    \ cars are infinitely fast.\n        // The cars are infinitely slow.\n      \
    \  // The cars are infinitely fast.\n        // The cars are infinitely slow.\n\
    \        // The cars are infinitely fast.\n        // The cars are infinitely\
    \ slow.\n        // The cars are infinitely fast.\n        // The cars are infinitely\
    \ slow.\n        // The cars are infinitely fast.\n        // The cars are infinitely\
    \ slow.\n        // The cars are infinitely fast.\n        // The cars are infinitely\
    \ slow.\n        // The cars are infinitely fast.\n        // The cars are infinitely\
    \ slow.\n        // The cars are infinitely fast.\n        // The cars are infinitely\
    \ slow.\n        // The cars are infinitely fast.\n        // The cars are infinitely\
    \ slow.\n        // The cars are infinitely fast.\n        // The cars are infinitely\
    \ slow.\n        // The cars are infinitely fast.\n        // The cars are infinitely\
    \ slow.\n        // The cars are infinitely fast.\n        // The cars are infinitely\
    \ slow.\n        // The cars are infinitely fast.\n        // The cars are infinitely\
    \ slow.\n        // The cars are infinitely fast.\n        // The cars are infinitely\
    \ slow.\n        // The cars are infinitely fast.\n        // The cars are infinitely\
    \ slow.\n        // The cars are\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpzq0pubx_.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// The cars are numbered from 0 to n-1.\e[0m\n\e[31m14 |\e[0m        \e[34m//\
    \ The cars moving left to right are numbered from 0 to n-1.\e[0m\n\e[31m15 |\e\
    [0m        \e[34m// The cars moving right to left are numbered from n-1 to 0.\e\
    [0m\n\e[31m16 |\e[0m        \e[34m// The cars moving left to right are at positions\
    \ x_0, x_1, ..., x_{n-1}.\e[0m\n\e[31m17 |\e[0m        \e[34m// The cars moving\
    \ right to left are at positions y_0, y_1, ..., y_{n-1}.\e[0m\n\e[31m18 |\e[0m\
    \        \e[34m// The cars move at the same speed.\e[0m\n\e[31m19 |\e[0m     \
    \   \e[34m// The cars are infinitely sturdy and strong.\e[0m\n\e[31m20 |\e[0m\
    \        \e[34m// The cars are infinitely long.\e[0m\n\e[31m21 |\e[0m        \e\
    [34m// The cars are infinitely thin.\e[0m\n\e[31m22 |\e[0m        \e[34m// The\
    \ cars are infinitely wide.\e[0m\n\e[31m23 |\e[0m        \e[34m// The cars are\
    \ infinitely tall.\e[0m\n\e[31m24 |\e[0m        \e[34m// The cars are infinitely\
    \ heavy.\e[0m\n\e[31m25 |\e[0m        \e[34m// The cars are infinitely light.\e\
    [0m\n\e[31m26 |\e[0m        \e[34m// The cars are infinitely strong.\e[0m\n\e\
    [31m27 |\e[0m        \e[34m// The cars are infinitely sturdy.\e[0m\n\e[31m28 |\e\
    [0m        \e[34m// The cars are infinitely fast.\e[0m\n\e[31m29 |\e[0m      \
    \  \e[34m// The cars are infinitely slow.\e[0m\n\e[31m30 |\e[0m        \e[34m//\
    \ The cars are infinitely fast.\e[0m\n\e[31m31 |\e[0m        \e[34m// The cars\
    \ are infinitely slow.\e[0m\n\e[31m32 |\e[0m        \e[34m// The cars are infinitely\
    \ fast.\e[0m\n\e[31m33 |\e[0m        \e[34m// The cars are infinitely slow.\e\
    [0m\n\e[31m34 |\e[0m        \e[34m// The cars are infinitely fast.\e[0m\n\e[31m35\
    \ |\e[0m        \e[34m// The cars are infinitely slow.\e[0m\n\e[31m36 |\e[0m \
    \   "
  stdout: ''
  timestamp: 1659792717
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting position.\n        // Then, we can use a sweep line\
    \ algorithm to count the number of collisions.\n        // The sweep line algorithm\
    \ is a general algorithm for counting the number of\n        // intersections\
    \ between a set of lines.\n        // In this case, the lines are the trajectories\
    \ of the cars.\n        // The sweep line algorithm works by sweeping a line from\
    \ left to right.\n        // As the sweep line sweeps, it keeps track of the number\
    \ of lines that intersect\n        // the sweep line.  When the sweep line passes\
    \ a line, it updates the number of\n        // lines that intersect the sweep\
    \ line.\n        // In this case, the sweep line starts at the leftmost car.\n\
    \        // The sweep line sweeps right until it reaches the rightmost car.\n\
    \        // The number of lines that intersect the sweep line is the number of\
    \ cars that\n        // are moving right to left.\n        // When the sweep line\
    \ passes a car, it updates the number of cars that are moving\n        // right\
    \ to left.\n        // The number of collisions is the number of times the sweep\
    \ line passes a car\n        // multiplied by the number of cars that are moving\
    \ right to left.\n        // This is because each car that's moving right to left\
    \ will collide with each car\n        // that's moving left to right.\n      \
    \  // The number of cars that are moving right to left is the number of cars that\
    \ are\n        // to the right of the sweep line.\n        // The number of cars\
    \ that are moving left to right is the number of cars that are\n        // to\
    \ the left of the sweep line.\n        // The number of collisions is the number\
    \ of cars that are to the right of the sweep\n        // line multiplied by the\
    \ number of cars that are to the left of the sweep line.\n        // The number\
    \ of cars that are to the right of the sweep line is the number of cars\n    \
    \    // that are moving right to left.\n        // The number of cars that are\
    \ to the left of the sweep line is the number of cars\n        // that are moving\
    \ left to right.\n        // The number of collisions is the number of cars that\
    \ are moving right to left\n        // multiplied by the number of cars that are\
    \ moving left to right.\n        // The number of cars that are moving right to\
    \ left is the number of lines that\n\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmprqj9v6yq.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// The idea is to sort the cars by their starting position.\e[0m\n\e[31m14\
    \ |\e[0m        \e[34m// Then, we can use a sweep line algorithm to count the\
    \ number of collisions.\e[0m\n\e[31m15 |\e[0m        \e[34m// The sweep line algorithm\
    \ is a general algorithm for counting the number of\e[0m\n\e[31m16 |\e[0m    \
    \    \e[34m// intersections between a set of lines.\e[0m\n\e[31m17 |\e[0m    \
    \    \e[34m// In this case, the lines are the trajectories of the cars.\e[0m\n\
    \e[31m18 |\e[0m        \e[34m// The sweep line algorithm works by sweeping a line\
    \ from left to right.\e[0m\n\e[31m19 |\e[0m        \e[34m// As the sweep line\
    \ sweeps, it keeps track of the number of lines that intersect\e[0m\n\e[31m20\
    \ |\e[0m        \e[34m// the sweep line.  When the sweep line passes a line, it\
    \ updates the number of\e[0m\n\e[31m21 |\e[0m        \e[34m// lines that intersect\
    \ the sweep line.\e[0m\n\e[31m22 |\e[0m        \e[34m// In this case, the sweep\
    \ line starts at the leftmost car.\e[0m\n\e[31m23 |\e[0m        \e[34m// The sweep\
    \ line sweeps right until it reaches the rightmost car.\e[0m\n\e[31m24 |\e[0m\
    \        \e[34m// The number of lines that intersect the sweep line is the number\
    \ of cars that\e[0m\n\e[31m25 |\e[0m        \e[34m// are moving right to left.\e\
    [0m\n\e[31m26 |\e[0m        \e[34m// When the sweep line passes a car, it updates\
    \ the number of cars that are moving\e[0m\n\e[31m27 |\e[0m        \e[34m// right\
    \ to left.\e[0m\n\e[31m28 |\e[0m        \e[34m// The number of collisions is the\
    \ number of times the sweep line passes a car\e[0m\n\e[31m29 |\e[0m        \e\
    [34m// multiplied by the number of cars that are moving right to left.\e[0m\n\e\
    [31m30 |\e[0m        \e[34m// This is because ea"
  stdout: ''
  timestamp: 1659792718
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        val leftToRight = new\
    \ Array[Long](n.toInt)\n        val rightToLeft = new Array[Long](n.toInt)\n \
    \       for (i <- 0 until n.toInt) {\n            leftToRight(i) = i\n       \
    \     rightToLeft(i) = n - i - 1\n        }\n        val leftToRightSet = leftToRight.toSet\n\
    \        val rightToLeftSet = rightToLeft.toSet\n        leftToRightSet.intersect(rightToLeftSet).size\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpuj28xwn4.scala:24)\n\tat Problem.main(tmpuj28xwn4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792721
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to use\
    \ a sweep line algorithm.  We will sweep from left to right.\n        // We will\
    \ maintain a set of cars that are moving left to right, and a set of cars\n  \
    \      // that are moving right to left.  As we sweep, we will check for collisions.\n\
    \        // We will use a balanced binary search tree to maintain the set of cars.\n\
    \        // The key of the tree will be the position of the car.\n        // The\
    \ value of the tree will be the speed of the car.\n        // We will use a positive\
    \ speed for cars moving left to right, and a negative speed\n        // for cars\
    \ moving right to left.\n        // We will maintain a variable called \"time\"\
    .  Initially, time = 0.\n        // We will maintain a variable called \"position\"\
    .  Initially, position = 0.\n        // We will maintain a variable called \"\
    collisionCount\".  Initially, collisionCount = 0.\n        var time = 0\n    \
    \    var position = 0\n        var collisionCount = 0\n        // We will maintain\
    \ a balanced binary search tree called \"leftToRight\".\n        // Initially,\
    \ leftToRight = empty.\n        var leftToRight = new TreeMap[Long, Long]\n  \
    \      // We will maintain a balanced binary search tree called \"rightToLeft\"\
    .\n        // Initially, rightToLeft = empty.\n        var rightToLeft = new TreeMap[Long,\
    \ Long]\n        // We will maintain a variable called \"leftToRightCount\". \
    \ Initially, leftToRightCount = 0.\n        var leftToRightCount = 0\n       \
    \ // We will maintain a variable called \"rightToLeftCount\".  Initially, rightToLeftCount\
    \ = 0.\n        var rightToLeftCount = 0\n        // We will maintain a variable\
    \ called \"leftToRightIndex\".  Initially, leftToRightIndex = 0.\n        var\
    \ leftToRightIndex = 0\n        // We will maintain a variable called \"rightToLeftIndex\"\
    .  Initially, rightToLeftIndex = 0.\n        var rightToLeftIndex = 0\n      \
    \  // We will maintain a variable called \"leftToRightSpeed\".  Initially, leftToRightSpeed\
    \ = 0.\n        var leftToRightSpeed = 0\n        // We will maintain a variable\
    \ called \"rightToLeftSpeed\".  Initially, rightToLeftSpeed = 0.\n        var\
    \ rightToLeftSpeed\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpum2pcpts.scala:45:4 ----------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpum2pcpts.scala:45:5 ---------------------\e[0m\e[0m\n\e[31m45 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659792719
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The first car that's\
    \ moving left to right will collide with the nth car that's moving\n        //\
    \ right to left.  The second car that's moving left to right will collide with\
    \ the\n        // (n - 1)th car that's moving right to left.  The third car that's\
    \ moving left to right\n        // will collide with the (n - 2)th car that's\
    \ moving right to left.  And so on.\n        // So the number of collisions is\
    \ the sum of the first n natural numbers.\n        n * (n + 1) / 2\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n\
    \    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpctx1zwc2.scala:21)\n\tat Problem.main(tmpctx1zwc2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792719
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The cars that are moving\
    \ left to right are numbered 0 to n - 1.\n        // The cars that are moving\
    \ right to left are numbered n to 2n - 1.\n        // The car that's moving left\
    \ to right with number i is at position i at time 0.\n        // The car that's\
    \ moving right to left with number i is at position 2n - 1 - i at time 0.\n  \
    \      // The car that's moving left to right with number i is at position i +\
    \ t at time t.\n        // The car that's moving right to left with number i is\
    \ at position 2n - 1 - i - t at time t.\n        // The car that's moving left\
    \ to right with number i collides with the car that's moving right to left\n \
    \       // with number j if and only if i + t = 2n - 1 - j - t.\n        // The\
    \ car that's moving left to right with number i collides with the car that's moving\
    \ right to left\n        // with number j if and only if i + j = 2n - 1.\n   \
    \     // The car that's moving left to right with number i collides with the car\
    \ that's moving right to left\n        // with number j if and only if i + j <\
    \ 2n.\n        // The car that's moving left to right with number i collides with\
    \ the car that's moving right to left\n        // with number j if and only if\
    \ i < j.\n        // The car that's moving left to right with number i collides\
    \ with the car that's moving right to left\n        // with number j if and only\
    \ if i < j and i + j < 2n.\n        // The car that's moving left to right with\
    \ number i collides with the car that's moving right to left\n        // with\
    \ number j if and only if i < j and i + j < 2n and i < n and j < n.\n        //\
    \ The car that's moving left to right with number i collides with the car that's\
    \ moving right to left\n        // with number j if and only if i < j and i +\
    \ j < 2n and i < n and j < n and i < j - i.\n        // The car that's moving\
    \ left to right with number i collides with the car that's moving right to left\n\
    \        // with number j if and only if i < j\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpzbkd5r2n.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// The cars that are moving left to right are numbered 0 to n - 1.\e[0m\n\e\
    [31m14 |\e[0m        \e[34m// The cars that are moving right to left are numbered\
    \ n to 2n - 1.\e[0m\n\e[31m15 |\e[0m        \e[34m// The car that's moving left\
    \ to right with number i is at position i at time 0.\e[0m\n\e[31m16 |\e[0m   \
    \     \e[34m// The car that's moving right to left with number i is at position\
    \ 2n - 1 - i at time 0.\e[0m\n\e[31m17 |\e[0m        \e[34m// The car that's moving\
    \ left to right with number i is at position i + t at time t.\e[0m\n\e[31m18 |\e\
    [0m        \e[34m// The car that's moving right to left with number i is at position\
    \ 2n - 1 - i - t at time t.\e[0m\n\e[31m19 |\e[0m        \e[34m// The car that's\
    \ moving left to right with number i collides with the car that's moving right\
    \ to left\e[0m\n\e[31m20 |\e[0m        \e[34m// with number j if and only if i\
    \ + t = 2n - 1 - j - t.\e[0m\n\e[31m21 |\e[0m        \e[34m// The car that's moving\
    \ left to right with number i collides with the car that's moving right to left\e\
    [0m\n\e[31m22 |\e[0m        \e[34m// with number j if and only if i + j = 2n -\
    \ 1.\e[0m\n\e[31m23 |\e[0m        \e[34m// The car that's moving left to right\
    \ with number i collides with the car that's moving right to left\e[0m\n\e[31m24\
    \ |\e[0m        \e[34m// with number j if and only if i + j < 2n.\e[0m\n\e[31m25\
    \ |\e[0m        \e[34m// The car that's moving left to right with number i collides\
    \ with the car that's moving right to left\e[0m\n\e[31m26 |\e[0m        \e[34m//\
    \ with number j if and only if i < j.\e[0m\n\e[31m27 |\e[0m        \e[34m// The\
    \ car that's moving left to right with number i collides with the car that's moving\
    \ right to left\e"
  stdout: ''
  timestamp: 1659792720
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        val left = new Array[Long](n.toInt)\n\
    \        val right = new Array[Long](n.toInt)\n        for (i <- 0 until n.toInt)\
    \ {\n            left(i) = i\n            right(i) = n - i - 1\n        }\n  \
    \      var count = 0\n        for (i <- 0 until n.toInt) {\n            for (j\
    \ <- 0 until n.toInt) {\n                if (left(i) > right(j)) count += 1\n\
    \            }\n        }\n        count\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpu34vkdik.scala:28)\n\tat Problem.main(tmpu34vkdik.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792722
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is a very simple\
    \ problem.  We can solve it by brute force.\n        // We can simulate the movement\
    \ of the cars.  We can start with the first\n        // car moving left to right\
    \ and the first car moving right to left.\n        // We can then move the first\
    \ car moving left to right by 1 unit.  If the\n        // first car moving left\
    \ to right collides with the first car moving right to left,\n        // we can\
    \ increment the number of collisions.  We can then move the first car moving\n\
    \        // right to left by 1 unit.  If the first car moving right to left collides\
    \ with the\n        // first car moving left to right, we can increment the number\
    \ of collisions.\n        // We can then move the second car moving left to right\
    \ by 1 unit.  If the\n        // second car moving left to right collides with\
    \ the second car moving right to left,\n        // we can increment the number\
    \ of collisions.  We can then move the second car moving\n        // right to\
    \ left by 1 unit.  If the second car moving right to left collides with the\n\
    \        // second car moving left to right, we can increment the number of collisions.\n\
    \        // We can then move the third car moving left to right by 1 unit.  If\
    \ the\n        // third car moving left to right collides with the third car moving\
    \ right to left,\n        // we can increment the number of collisions.  We can\
    \ then move the third car moving\n        // right to left by 1 unit.  If the\
    \ third car moving right to left collides with the\n        // third car moving\
    \ left to right, we can increment the number of collisions.\n        // We can\
    \ then move the fourth car moving left to right by 1 unit.  If the\n        //\
    \ fourth car moving left to right collides with the fourth car moving right to\
    \ left,\n        // we can increment the number of collisions.  We can then move\
    \ the fourth car moving\n        // right to left by 1 unit.  If the fourth car\
    \ moving right to left collides with the\n        // fourth car moving left to\
    \ right, we can increment the number of collisions.\n        // We can then move\
    \ the fifth car moving left to right by 1 unit.  If the\n        // fifth car\
    \ moving left to right collides with the fifth car moving right to left,\n   \
    \     // we can increment the number\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4jjmwql_.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// This is a very simple problem.  We can solve it by brute force.\e[0m\n\e\
    [31m14 |\e[0m        \e[34m// We can simulate the movement of the cars.  We can\
    \ start with the first\e[0m\n\e[31m15 |\e[0m        \e[34m// car moving left to\
    \ right and the first car moving right to left.\e[0m\n\e[31m16 |\e[0m        \e\
    [34m// We can then move the first car moving left to right by 1 unit.  If the\e\
    [0m\n\e[31m17 |\e[0m        \e[34m// first car moving left to right collides with\
    \ the first car moving right to left,\e[0m\n\e[31m18 |\e[0m        \e[34m// we\
    \ can increment the number of collisions.  We can then move the first car moving\e\
    [0m\n\e[31m19 |\e[0m        \e[34m// right to left by 1 unit.  If the first car\
    \ moving right to left collides with the\e[0m\n\e[31m20 |\e[0m        \e[34m//\
    \ first car moving left to right, we can increment the number of collisions.\e\
    [0m\n\e[31m21 |\e[0m        \e[34m// We can then move the second car moving left\
    \ to right by 1 unit.  If the\e[0m\n\e[31m22 |\e[0m        \e[34m// second car\
    \ moving left to right collides with the second car moving right to left,\e[0m\n\
    \e[31m23 |\e[0m        \e[34m// we can increment the number of collisions.  We\
    \ can then move the second car moving\e[0m\n\e[31m24 |\e[0m        \e[34m// right\
    \ to left by 1 unit.  If the second car moving right to left collides with the\e\
    [0m\n\e[31m25 |\e[0m        \e[34m// second car moving left to right, we can increment\
    \ the number of collisions.\e[0m\n\e[31m26 |\e[0m        \e[34m// We can then\
    \ move the third car moving left to right by 1 unit.  If the\e[0m\n\e[31m27 |\e\
    [0m        \e[34m// third car moving left to right collides with the third car\
    \ moving right to left,\e[0"
  stdout: ''
  timestamp: 1659792720
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This function returns\
    \ the number of collisions between cars that are\n        // moving left to right\
    \ and cars that are moving right to left.\n        // The cars are numbered from\
    \ 1 to n.\n        // The cars that are moving left to right are numbered from\
    \ 1 to n.\n        // The cars that are moving right to left are numbered from\
    \ n to 1.\n        // The cars that are moving left to right are at positions\
    \ x1, x2, ..., xn.\n        // The cars that are moving right to left are at positions\
    \ y1, y2, ..., yn.\n        // The cars that are moving left to right are moving\
    \ at speeds s1, s2, ..., sn.\n        // The cars that are moving right to left\
    \ are moving at speeds t1, t2, ..., tn.\n        // The cars that are moving left\
    \ to right are moving at speeds s1, s2, ..., sn.\n        // The cars that are\
    \ moving right to left are moving at speeds t1, t2, ..., tn.\n        // The cars\
    \ that are moving left to right are moving at speeds s1, s2, ..., sn.\n      \
    \  // The cars that are moving right to left are moving at speeds t1, t2, ...,\
    \ tn.\n        // The cars that are moving left to right are moving at speeds\
    \ s1, s2, ..., sn.\n        // The cars that are moving right to left are moving\
    \ at speeds t1, t2, ..., tn.\n        // The cars that are moving left to right\
    \ are moving at speeds s1, s2, ..., sn.\n        // The cars that are moving right\
    \ to left are moving at speeds t1, t2, ..., tn.\n        // The cars that are\
    \ moving left to right are moving at speeds s1, s2, ..., sn.\n        // The cars\
    \ that are moving right to left are moving at speeds t1, t2, ..., tn.\n      \
    \  // The cars that are moving left to right are moving at speeds s1, s2, ...,\
    \ sn.\n        // The cars that are moving right to left are moving at speeds\
    \ t1, t2, ..., tn.\n        // The cars that are moving left to right are moving\
    \ at speeds s1, s2, ..., sn.\n       \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpjz0fmjlv.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// This function returns the number of collisions between cars that are\e\
    [0m\n\e[31m14 |\e[0m        \e[34m// moving left to right and cars that are moving\
    \ right to left.\e[0m\n\e[31m15 |\e[0m        \e[34m// The cars are numbered from\
    \ 1 to n.\e[0m\n\e[31m16 |\e[0m        \e[34m// The cars that are moving left\
    \ to right are numbered from 1 to n.\e[0m\n\e[31m17 |\e[0m        \e[34m// The\
    \ cars that are moving right to left are numbered from n to 1.\e[0m\n\e[31m18\
    \ |\e[0m        \e[34m// The cars that are moving left to right are at positions\
    \ x1, x2, ..., xn.\e[0m\n\e[31m19 |\e[0m        \e[34m// The cars that are moving\
    \ right to left are at positions y1, y2, ..., yn.\e[0m\n\e[31m20 |\e[0m      \
    \  \e[34m// The cars that are moving left to right are moving at speeds s1, s2,\
    \ ..., sn.\e[0m\n\e[31m21 |\e[0m        \e[34m// The cars that are moving right\
    \ to left are moving at speeds t1, t2, ..., tn.\e[0m\n\e[31m22 |\e[0m        \e\
    [34m// The cars that are moving left to right are moving at speeds s1, s2, ...,\
    \ sn.\e[0m\n\e[31m23 |\e[0m        \e[34m// The cars that are moving right to\
    \ left are moving at speeds t1, t2, ..., tn.\e[0m\n\e[31m24 |\e[0m        \e[34m//\
    \ The cars that are moving left to right are moving at speeds s1, s2, ..., sn.\e\
    [0m\n\e[31m25 |\e[0m        \e[34m// The cars that are moving right to left are\
    \ moving at speeds t1, t2, ..., tn.\e[0m\n\e[31m26 |\e[0m        \e[34m// The\
    \ cars that are moving left to right are moving at speeds s1, s2, ..., sn.\e[0m\n\
    \e[31m27 |\e[0m        \e[34m// The cars that are moving right to left are moving\
    \ at speeds t1, t2, ..., tn.\e[0m\n\e[31m28 |\e[0m        \e[34m// The cars that\
    \ are moving left to right are moving at"
  stdout: ''
  timestamp: 1659792721
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting position.  Then, we can\n        // just iterate\
    \ through the cars and count the number of collisions.\n        // The time complexity\
    \ is O(n log n).\n        val leftToRight = new Array[Long](n.toInt)\n       \
    \ val rightToLeft = new Array[Long](n.toInt)\n        for (i <- 0 until n.toInt)\
    \ {\n            leftToRight(i) = i\n            rightToLeft(i) = n - 1 - i\n\
    \        }\n        val sortedLeftToRight = leftToRight.sorted\n        val sortedRightToLeft\
    \ = rightToLeft.sorted\n        var count = 0L\n        for (i <- 0 until n.toInt)\
    \ {\n            if (sortedLeftToRight(i) > sortedRightToLeft(i)) count += 1\n\
    \        }\n        count\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7235_em0.scala:31)\n\tat Problem.main(tmp7235_em0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792724
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is a very simple\
    \ problem.  We can solve it by brute force.\n        // We can simulate the cars'\
    \ movement by a list of n numbers, where\n        // each number represents the\
    \ position of a car.  We can then sort\n        // the list, and count the number\
    \ of pairs of cars that are in the\n        // same position.  This is O(n log\
    \ n).\n        val cars = Array.fill(n.toInt)(0)\n        for (i <- 0 until n.toInt)\
    \ {\n            cars(i) = i - n + 1\n        }\n        cars.sorted.sliding(2).count(x\
    \ => x(0) == x(1))\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7lzb__dq.scala:20:22\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m            cars(i) = i - n +\
    \ \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Found:    Long\n\e[31m   |\e[0m           \
    \           Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659792722
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting position.\n        // Then, we can just count the\
    \ number of cars that are moving in the same direction\n        // and are starting\
    \ at the same position.\n        // We can do this by counting the number of cars\
    \ that are moving in the same direction\n        // and are starting at the same\
    \ position.\n        // We can do this by counting the number of cars that are\
    \ moving in the same direction\n        // and are starting at the same position.\n\
    \        // We can do this by counting the number of cars that are moving in the\
    \ same direction\n        // and are starting at the same position.\n        //\
    \ We can do this by counting the number of cars that are moving in the same direction\n\
    \        // and are starting at the same position.\n        // We can do this\
    \ by counting the number of cars that are moving in the same direction\n     \
    \   // and are starting at the same position.\n        // We can do this by counting\
    \ the number of cars that are moving in the same direction\n        // and are\
    \ starting at the same position.\n        // We can do this by counting the number\
    \ of cars that are moving in the same direction\n        // and are starting at\
    \ the same position.\n        // We can do this by counting the number of cars\
    \ that are moving in the same direction\n        // and are starting at the same\
    \ position.\n        // We can do this by counting the number of cars that are\
    \ moving in the same direction\n        // and are starting at the same position.\n\
    \        // We can do this by counting the number of cars that are moving in the\
    \ same direction\n        // and are starting at the same position.\n        //\
    \ We can do this by counting the number of cars that are moving in the same direction\n\
    \        // and are starting at the same position.\n        // We can do this\
    \ by counting the number of cars that are moving in the same direction\n     \
    \   // and are starting at the same position.\n        // We can do this by counting\
    \ the number of cars that are moving in the same direction\n        // and are\
    \ starting at the same position.\n        // We can do this by counting the number\
    \ of cars that are moving in the same direction\n        // and are starting at\
    \ the same position.\n        // We can do this by counting the number of cars\
    \ that are moving in the same direction\n        // and are starting at the same\
    \ position.\n\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpg1dff_y6.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// The idea is to sort the cars by their starting position.\e[0m\n\e[31m14\
    \ |\e[0m        \e[34m// Then, we can just count the number of cars that are moving\
    \ in the same direction\e[0m\n\e[31m15 |\e[0m        \e[34m// and are starting\
    \ at the same position.\e[0m\n\e[31m16 |\e[0m        \e[34m// We can do this by\
    \ counting the number of cars that are moving in the same direction\e[0m\n\e[31m17\
    \ |\e[0m        \e[34m// and are starting at the same position.\e[0m\n\e[31m18\
    \ |\e[0m        \e[34m// We can do this by counting the number of cars that are\
    \ moving in the same direction\e[0m\n\e[31m19 |\e[0m        \e[34m// and are starting\
    \ at the same position.\e[0m\n\e[31m20 |\e[0m        \e[34m// We can do this by\
    \ counting the number of cars that are moving in the same direction\e[0m\n\e[31m21\
    \ |\e[0m        \e[34m// and are starting at the same position.\e[0m\n\e[31m22\
    \ |\e[0m        \e[34m// We can do this by counting the number of cars that are\
    \ moving in the same direction\e[0m\n\e[31m23 |\e[0m        \e[34m// and are starting\
    \ at the same position.\e[0m\n\e[31m24 |\e[0m        \e[34m// We can do this by\
    \ counting the number of cars that are moving in the same direction\e[0m\n\e[31m25\
    \ |\e[0m        \e[34m// and are starting at the same position.\e[0m\n\e[31m26\
    \ |\e[0m        \e[34m// We can do this by counting the number of cars that are\
    \ moving in the same direction\e[0m\n\e[31m27 |\e[0m        \e[34m// and are starting\
    \ at the same position.\e[0m\n\e[31m28 |\e[0m        \e[34m// We can do this by\
    \ counting the number of cars that are moving in the same direction\e[0m\n\e[31m29\
    \ |\e[0m        \e[34m// and are starting at the same position.\e[0m\n\e[31m30\
    \ |\e[0m        \e[34m// We ca"
  stdout: ''
  timestamp: 1659792721
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to use\
    \ the fact that the cars are infinitely strong and sturdy.\n        // We can\
    \ imagine that the cars are moving in a circle.  The cars that are moving\n  \
    \      // left to right are moving clockwise, and the cars that are moving right\
    \ to left\n        // are moving counterclockwise.  The cars that are moving left\
    \ to right are\n        // numbered 1, 2, 3, ..., n, and the cars that are moving\
    \ right to left are\n        // numbered n+1, n+2, n+3, ..., 2n.  The cars are\
    \ initially arranged in a circle\n        // with the cars numbered 1, 2, 3, ...,\
    \ n, n+1, n+2, ..., 2n in that order.\n        // We can imagine that the cars\
    \ are moving in a circle with a radius of 1.\n        // We can imagine that the\
    \ cars are moving in a circle with a radius of 1.\n        // The cars that are\
    \ moving left to right are moving clockwise, and the cars\n        // that are\
    \ moving right to left are moving counterclockwise.\n        // The cars that\
    \ are moving left to right are moving clockwise, and the cars\n        // that\
    \ are moving right to left are moving counterclockwise.\n        // The cars that\
    \ are moving left to right are moving clockwise, and the cars\n        // that\
    \ are moving right to left are moving counterclockwise.\n        // The cars that\
    \ are moving left to right are moving clockwise, and the cars\n        // that\
    \ are moving right to left are moving counterclockwise.\n        // The cars that\
    \ are moving left to right are moving clockwise, and the cars\n        // that\
    \ are moving right to left are moving counterclockwise.\n        // The cars that\
    \ are moving left to right are moving clockwise, and the cars\n        // that\
    \ are moving right to left are moving counterclockwise.\n        // The cars that\
    \ are moving left to right are moving clockwise, and the cars\n        // that\
    \ are moving right to left are moving counterclockwise.\n        // The cars that\
    \ are moving left to right are moving clockwise, and the cars\n        // that\
    \ are moving right to left are moving counterclockwise.\n        // The cars that\
    \ are moving left to right are moving clockwise, and the cars\n        // that\
    \ are moving right to left are moving counterclockwise.\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpneqwdgnk.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// The idea is to use the fact that the cars are infinitely strong and sturdy.\e\
    [0m\n\e[31m14 |\e[0m        \e[34m// We can imagine that the cars are moving in\
    \ a circle.  The cars that are moving\e[0m\n\e[31m15 |\e[0m        \e[34m// left\
    \ to right are moving clockwise, and the cars that are moving right to left\e\
    [0m\n\e[31m16 |\e[0m        \e[34m// are moving counterclockwise.  The cars that\
    \ are moving left to right are\e[0m\n\e[31m17 |\e[0m        \e[34m// numbered\
    \ 1, 2, 3, ..., n, and the cars that are moving right to left are\e[0m\n\e[31m18\
    \ |\e[0m        \e[34m// numbered n+1, n+2, n+3, ..., 2n.  The cars are initially\
    \ arranged in a circle\e[0m\n\e[31m19 |\e[0m        \e[34m// with the cars numbered\
    \ 1, 2, 3, ..., n, n+1, n+2, ..., 2n in that order.\e[0m\n\e[31m20 |\e[0m    \
    \    \e[34m// We can imagine that the cars are moving in a circle with a radius\
    \ of 1.\e[0m\n\e[31m21 |\e[0m        \e[34m// We can imagine that the cars are\
    \ moving in a circle with a radius of 1.\e[0m\n\e[31m22 |\e[0m        \e[34m//\
    \ The cars that are moving left to right are moving clockwise, and the cars\e\
    [0m\n\e[31m23 |\e[0m        \e[34m// that are moving right to left are moving\
    \ counterclockwise.\e[0m\n\e[31m24 |\e[0m        \e[34m// The cars that are moving\
    \ left to right are moving clockwise, and the cars\e[0m\n\e[31m25 |\e[0m     \
    \   \e[34m// that are moving right to left are moving counterclockwise.\e[0m\n\
    \e[31m26 |\e[0m        \e[34m// The cars that are moving left to right are moving\
    \ clockwise, and the cars\e[0m\n\e[31m27 |\e[0m        \e[34m// that are moving\
    \ right to left are moving counterclockwise.\e[0m\n\e[31m28 |\e[0m        \e[34m//\
    \ The cars that are moving left to ri"
  stdout: ''
  timestamp: 1659792722
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is a classic problem\
    \ in discrete mathematics.\n        // The solution is to realize that the number\
    \ of collisions is the same as the number of\n        // inversions in the permutation\
    \ of the numbers 1 to n.\n        // The number of inversions in a permutation\
    \ is the number of pairs of numbers that are out of order.\n        // For example,\
    \ the permutation (1, 2, 3, 4, 5) has no inversions, while the permutation (5,\
    \ 4, 3, 2, 1)\n        // has 10 inversions.\n        // The number of inversions\
    \ in a permutation is the same as the number of collisions in the car race.\n\
    \        // For example, the permutation (1, 2, 3, 4, 5) corresponds to the car\
    \ race where the left-to-right cars\n        // are numbered 1 to 5, and the right-to-left\
    \ cars are also numbered 1 to 5.  There are no collisions.\n        // The permutation\
    \ (5, 4, 3, 2, 1) corresponds to the car race where the left-to-right cars are\
    \ numbered\n        // 1 to 5, and the right-to-left cars are numbered 5 to 1.\
    \  There are 10 collisions.\n        // The number of inversions in a permutation\
    \ is the same as the number of collisions in the car race.\n        // The number\
    \ of inversions in a permutation is equal to the sum of the number of inversions\
    \ in the\n        // left half of the permutation and the number of inversions\
    \ in the right half of the permutation.\n        // This is the basis of the divide-and-conquer\
    \ algorithm.\n        def inversions(permutation : List[Long]) : Long = {\n  \
    \          if (permutation.length <= 1) 0\n            else {\n              \
    \  val mid = permutation.length / 2\n                val left = permutation.slice(0,\
    \ mid)\n                val right = permutation.slice(mid, permutation.length)\n\
    \                val leftInversions = inversions(left)\n                val rightInversions\
    \ = inversions(right)\n                val splitInversions = mergeAndCountSplitInversions(left,\
    \ right)\n                leftInversions + rightInversions + splitInversions\n\
    \            }\n        }\n        def mergeAndCountSplitInversions(left : List[Long],\
    \ right\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpif15cnpv.scala:41:4 ----------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ':' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpif15cnpv.scala:37:16 --------------------\e[0m\e[0m\n\e[31m37 |\e[0m\
    \                leftInversions + rightInversions + splitInversions\n\e[31m\e\
    [31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                Found:    String\n\e[31m   |\e[0m        \
    \        Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpif15cnpv.scala:41:5\
    \ ---------------------\e[0m\e[0m\n\e[31m41 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659792725
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting position.\n        // Then, we can just count the\
    \ number of cars that are moving left to right\n        // and are to the left\
    \ of a car that's moving right to left.\n        // This is the number of collisions.\n\
    \        val cars = new Array[Long](2 * n.toInt)\n        for (i <- 0 until n.toInt)\
    \ {\n            cars(i) = i + 1\n            cars(i + n.toInt) = -(i + 1)\n \
    \       }\n        cars.sortWith(_ < _)\n        var count = 0\n        for (i\
    \ <- 0 until 2 * n.toInt) {\n            if (cars(i) > 0) {\n                for\
    \ (j <- i + 1 until 2 * n.toInt) {\n                    if (cars(j) < 0) {\n \
    \                       count += 1\n                    }\n                }\n\
    \            }\n        }\n        count\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792726
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // Let's say that the\
    \ cars are numbered from 1 to n.\n        // The cars driving left to right are\
    \ numbered 1 to n.\n        // The cars driving right to left are numbered n+1\
    \ to 2n.\n        // The car numbered i is at position i.\n        // The car\
    \ numbered i is moving at speed i.\n        // The car numbered i is moving left\
    \ to right if i <= n.\n        // The car numbered i is moving right to left if\
    \ i > n.\n        // The car numbered i will collide with the car numbered j if\
    \ i < j and i + j <= 2n.\n        // The car numbered i will collide with the\
    \ car numbered j if i > j and i + j > 2n.\n        // The car numbered i will\
    \ collide with the car numbered j if i < j and i + j > 2n.\n        // The car\
    \ numbered i will collide with the car numbered j if i > j and i + j <= 2n.\n\
    \        // The car numbered i will collide with the car numbered j if i < j and\
    \ i + j <= 2n.\n        // The car numbered i will collide with the car numbered\
    \ j if i > j and i + j > 2n.\n        // The car numbered i will collide with\
    \ the car numbered j if i < j and i + j > 2n.\n        // The car numbered i will\
    \ collide with the car numbered j if i > j and i + j <= 2n.\n        // The car\
    \ numbered i will collide with the car numbered j if i < j and i + j <= 2n.\n\
    \        // The car numbered i will collide with the car numbered j if i > j and\
    \ i + j > 2n.\n        // The car numbered i will collide with the car numbered\
    \ j if i < j and i + j > 2n.\n        // The car numbered i will collide with\
    \ the car numbered j if i > j and i + j <= 2n.\n        // The car numbered i\
    \ will collide with the car numbered j if i < j and i + j <= 2n.\n        // The\
    \ car numbered i will collide with the car numbered j if i > j and i + j > 2n.\n\
    \        // The car numbered i will collide with the car numbered j if i < j and\
    \ i + j > 2n.\n        // The car numbered i will collide with the car numbered\
    \ j\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpzx9kta5r.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// Let's say that the cars are numbered from 1 to n.\e[0m\n\e[31m14 |\e[0m\
    \        \e[34m// The cars driving left to right are numbered 1 to n.\e[0m\n\e\
    [31m15 |\e[0m        \e[34m// The cars driving right to left are numbered n+1\
    \ to 2n.\e[0m\n\e[31m16 |\e[0m        \e[34m// The car numbered i is at position\
    \ i.\e[0m\n\e[31m17 |\e[0m        \e[34m// The car numbered i is moving at speed\
    \ i.\e[0m\n\e[31m18 |\e[0m        \e[34m// The car numbered i is moving left to\
    \ right if i <= n.\e[0m\n\e[31m19 |\e[0m        \e[34m// The car numbered i is\
    \ moving right to left if i > n.\e[0m\n\e[31m20 |\e[0m        \e[34m// The car\
    \ numbered i will collide with the car numbered j if i < j and i + j <= 2n.\e\
    [0m\n\e[31m21 |\e[0m        \e[34m// The car numbered i will collide with the\
    \ car numbered j if i > j and i + j > 2n.\e[0m\n\e[31m22 |\e[0m        \e[34m//\
    \ The car numbered i will collide with the car numbered j if i < j and i + j >\
    \ 2n.\e[0m\n\e[31m23 |\e[0m        \e[34m// The car numbered i will collide with\
    \ the car numbered j if i > j and i + j <= 2n.\e[0m\n\e[31m24 |\e[0m        \e\
    [34m// The car numbered i will collide with the car numbered j if i < j and i\
    \ + j <= 2n.\e[0m\n\e[31m25 |\e[0m        \e[34m// The car numbered i will collide\
    \ with the car numbered j if i > j and i + j > 2n.\e[0m\n\e[31m26 |\e[0m     \
    \   \e[34m// The car numbered i will collide with the car numbered j if i < j\
    \ and i + j > 2n.\e[0m\n\e[31m27 |\e[0m        \e[34m// The car numbered i will\
    \ collide with the car numbered j if i > j and i + j <= 2n.\e[0m\n\e[31m28 |\e\
    [0m        \e[34m// The car numbered i will collide with the car numbered j if\
    \ i < j and i + j <= 2n.\e[0m\n\e[31m29 |\e[0m        \e[34m// "
  stdout: ''
  timestamp: 1659792723
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is a very simple\
    \ problem.  The cars that are moving left to right\n        // are numbered 1\
    \ to n.  The cars that are moving right to left are numbered\n        // n+1 to\
    \ 2n.  The cars that are moving left to right will collide with the cars\n   \
    \     // that are moving right to left if and only if the numbers of the cars\
    \ are the same.\n        // So the answer is the number of pairs of numbers that\
    \ are the same in the range\n        // 1 to n.  This is n*(n+1)/2.\n        n\
    \ * (n + 1) / 2\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp3ra570_g.scala:22)\n\tat Problem.main(tmp3ra570_g.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792725
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting positions.\n        // Then, we can just go through\
    \ the sorted list and count the number of cars\n        // that are moving in\
    \ the opposite direction.\n        // The time complexity is O(n log n)\n    \
    \    // The space complexity is O(n)\n        val cars = Array.fill(2 * n.toInt)(0)\n\
    \        for (i <- 0 until n.toInt) {\n            cars(i) = i + 1\n         \
    \   cars(i + n.toInt) = -(i + 1)\n        }\n        scala.util.Sorting.quickSort(cars)\n\
    \        var count = 0\n        for (i <- 0 until 2 * n.toInt) {\n           \
    \ if (cars(i) < 0) count += 1\n            else count -= 1\n        }\n      \
    \  count\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpg5eb2tt_.scala:32)\n\tat Problem.main(tmpg5eb2tt_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792727
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // Assume that the cars\
    \ are numbered from 0 to n - 1.\n        // Assume that the cars moving left to\
    \ right are numbered from 0 to n - 1.\n        // Assume that the cars moving\
    \ right to left are numbered from n - 1 to 0.\n        // Assume that the cars\
    \ moving left to right start at position 0.\n        // Assume that the cars moving\
    \ right to left start at position 2 * n.\n        // Assume that the cars move\
    \ at speed 1.\n        // Assume that the cars moving left to right move to the\
    \ right.\n        // Assume that the cars moving right to left move to the left.\n\
    \        // Assume that the cars are infinitely sturdy and strong.\n        //\
    \ Assume that the cars are perfectly straight.\n        // Assume that the road\
    \ is perfectly straight.\n        // Assume that the road is infinitely long.\n\
    \        // Assume that the road is a line.\n        // Assume that the road is\
    \ 2-dimensional.\n        // Assume that the road is flat.\n        // Assume\
    \ that the road is Euclidean.\n        // Assume that the road is in the Euclidean\
    \ plane.\n        // Assume that the road is in the Euclidean space.\n       \
    \ // Assume that the road is in the Euclidean space of dimension 2.\n        //\
    \ Assume that the road is in the Euclidean space of dimension 3.\n        // Assume\
    \ that the road is in the Euclidean space of dimension 4.\n        // Assume that\
    \ the road is in the Euclidean space of dimension 5.\n        // Assume that the\
    \ road is in the Euclidean space of dimension 6.\n        // Assume that the road\
    \ is in the Euclidean space of dimension 7.\n        // Assume that the road is\
    \ in the Euclidean space of dimension 8.\n        // Assume that the road is in\
    \ the Euclidean space of dimension 9.\n        // Assume that the road is in the\
    \ Euclidean space of dimension 10.\n        // Assume that the road is in the\
    \ Euclidean space of dimension 11.\n        // Assume that the road is in the\
    \ Euclidean space of dimension 12.\n        // Assume that the road is in the\
    \ Euclidean space of dimension 13.\n        // Assume that the road is in the\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4hkr5f9s.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// Assume that the cars are numbered from 0 to n - 1.\e[0m\n\e[31m14 |\e[0m\
    \        \e[34m// Assume that the cars moving left to right are numbered from\
    \ 0 to n - 1.\e[0m\n\e[31m15 |\e[0m        \e[34m// Assume that the cars moving\
    \ right to left are numbered from n - 1 to 0.\e[0m\n\e[31m16 |\e[0m        \e\
    [34m// Assume that the cars moving left to right start at position 0.\e[0m\n\e\
    [31m17 |\e[0m        \e[34m// Assume that the cars moving right to left start\
    \ at position 2 * n.\e[0m\n\e[31m18 |\e[0m        \e[34m// Assume that the cars\
    \ move at speed 1.\e[0m\n\e[31m19 |\e[0m        \e[34m// Assume that the cars\
    \ moving left to right move to the right.\e[0m\n\e[31m20 |\e[0m        \e[34m//\
    \ Assume that the cars moving right to left move to the left.\e[0m\n\e[31m21 |\e\
    [0m        \e[34m// Assume that the cars are infinitely sturdy and strong.\e[0m\n\
    \e[31m22 |\e[0m        \e[34m// Assume that the cars are perfectly straight.\e\
    [0m\n\e[31m23 |\e[0m        \e[34m// Assume that the road is perfectly straight.\e\
    [0m\n\e[31m24 |\e[0m        \e[34m// Assume that the road is infinitely long.\e\
    [0m\n\e[31m25 |\e[0m        \e[34m// Assume that the road is a line.\e[0m\n\e\
    [31m26 |\e[0m        \e[34m// Assume that the road is 2-dimensional.\e[0m\n\e\
    [31m27 |\e[0m        \e[34m// Assume that the road is flat.\e[0m\n\e[31m28 |\e\
    [0m        \e[34m// Assume that the road is Euclidean.\e[0m\n\e[31m29 |\e[0m \
    \       \e[34m// Assume that the road is in the Euclidean plane.\e[0m\n\e[31m30\
    \ |\e[0m        \e[34m// Assume that the road is in the Euclidean space.\e[0m\n\
    \e[31m31 |\e[0m        \e[34m// Assume that the road is in the Euclidean space\
    \ of dimension 2.\e[0m\n\e[31m32 |\e[0m        \e[34m// Assume that t"
  stdout: ''
  timestamp: 1659792726
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is the number\
    \ of collisions.\n        var collisions = 0L\n        // This is the number of\
    \ cars that have been processed.\n        var processed = 0L\n        // This\
    \ is the number of cars that have been processed from the left-to-right set.\n\
    \        var processedLeft = 0L\n        // This is the number of cars that have\
    \ been processed from the right-to-left set.\n        var processedRight = 0L\n\
    \        // This is the number of cars that have been processed from the left-to-right\
    \ set\n        // that have collided with a car from the right-to-left set.\n\
    \        var collidedLeft = 0L\n        // This is the number of cars that have\
    \ been processed from the right-to-left set\n        // that have collided with\
    \ a car from the left-to-right set.\n        var collidedRight = 0L\n        //\
    \ This is the number of cars that have been processed from the left-to-right set\n\
    \        // that have not collided with a car from the right-to-left set.\n  \
    \      var notCollidedLeft = 0L\n        // This is the number of cars that have\
    \ been processed from the right-to-left set\n        // that have not collided\
    \ with a car from the left-to-right set.\n        var notCollidedRight = 0L\n\
    \        // This is the number of cars that have been processed from the left-to-right\
    \ set\n        // that have collided with a car from the right-to-left set.\n\
    \        var collidedLeftIndex = 0L\n        // This is the number of cars that\
    \ have been processed from the right-to-left set\n        // that have collided\
    \ with a car from the left-to-right set.\n        var collidedRightIndex = 0L\n\
    \        // This is the number of cars that have been processed from the left-to-right\
    \ set\n        // that have not collided with a car from the right-to-left set.\n\
    \        var notCollidedLeftIndex = 0L\n        // This is the number of cars\
    \ that have been processed from the right-to-left set\n        // that have not\
    \ collided with a car from the left-to-right set.\n        var notCollidedRightIndex\
    \ = 0L\n        // This is the number of cars that have been processed from the\
    \ left-to-right set\n\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpi1gcovb0.scala:47:5\
    \ ---------------------\e[0m\e[0m\n\e[31m47 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659792726
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to use\
    \ a sweep line algorithm.\n        // We will use a set of events.  Each event\
    \ is a tuple (x, y, t), where x is the x-coordinate\n        // of the car, y\
    \ is the y-coordinate of the car, and t is the time of the event.\n        //\
    \ The events are sorted by x-coordinate, and then by y-coordinate.\n        //\
    \ The events are processed in the order of increasing x-coordinate.\n        //\
    \ If the event is a left-to-right car, then we insert the car into a set of cars.\n\
    \        // If the event is a right-to-left car, then we remove the car from the\
    \ set of cars.\n        // If the event is a left-to-right car, then we check\
    \ if there are any right-to-left cars\n        // that are in the set of cars.\
    \  If so, then we increment the number of collisions.\n        // The time complexity\
    \ is O(n log n).\n        // The space complexity is O(n).\n        val events\
    \ = new Array[(Long, Long, Long)](2 * n.toInt)\n        for (i <- 0 until n.toInt)\
    \ {\n            val x = i.toLong\n            val y = i.toLong\n            events(i)\
    \ = (x, y, 0)\n            events(i + n.toInt) = (x, y, 1)\n        }\n      \
    \  events.sortWith((a, b) => a._1 < b._1 || (a._1 == b._1 && a._2 < b._2) || (a._1\
    \ == b._1 && a._2 == b._2 && a._3 < b._3))\n        var collisions = 0L\n    \
    \    val cars = new HashSet[Long]\n        for (event <- events) {\n         \
    \   if (event._3 == 0) {\n                if (cars.contains(event._2)) collisions\
    \ += 1\n                cars.add(event._2)\n            } else {\n           \
    \     cars.remove(event._2)\n            }\n        }\n        collisions\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpw1bciv05.scala:45)\n\tat Problem.main(tmpw1bciv05.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792729
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // We can solve this problem\
    \ by first sorting the cars by their starting position.\n        // Then, we can\
    \ iterate through the cars in order, and for each car, we can check\n        //\
    \ how many cars are in front of it.  If the car is moving left to right, then\n\
    \        // the number of cars in front of it is the number of collisions it will\
    \ have.\n        // If the car is moving right to left, then the number of cars\
    \ in front of it is\n        // the number of collisions it will have minus 1.\
    \  The reason for this is that\n        // the car will collide with the car in\
    \ front of it, but it will not collide with\n        // the car behind it.\n \
    \       // The total number of collisions is the sum of the number of collisions\
    \ for each car.\n        // The total number of collisions is also the sum of\
    \ the number of cars in front of\n        // each car.  So, we can solve this\
    \ problem by sorting the cars by their starting\n        // position, and then\
    \ summing the number of cars in front of each car.\n        // The number of cars\
    \ in front of each car is the number of cars to the right of\n        // the car.\
    \  So, we can solve this problem by sorting the cars by their starting\n     \
    \   // position, and then summing the number of cars to the right of each car.\n\
    \        // We can solve this problem by sorting the cars by their starting position,\
    \ and\n        // then iterating through the cars in order.  For each car, we\
    \ can find the number\n        // of cars to the right of it by using a binary\
    \ search.  We can do this by using\n        // a binary search tree.  We can insert\
    \ the cars into the binary search tree in\n        // order, and then we can iterate\
    \ through the cars in order.  For each car, we can\n        // find the number\
    \ of cars to the right of it by using a binary search.\n        // We can use\
    \ a binary search tree to insert the cars in order, and then we can\n        //\
    \ iterate through the cars in order.  For each car, we can find the number of\n\
    \        // cars to the right of it by using a binary search.\n        // We can\
    \ use a binary search tree to insert the cars in order, and then we can\n    \
    \    // iterate through the cars in order\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpg4t7ycx1.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// We can solve this problem by first sorting the cars by their starting position.\e\
    [0m\n\e[31m14 |\e[0m        \e[34m// Then, we can iterate through the cars in\
    \ order, and for each car, we can check\e[0m\n\e[31m15 |\e[0m        \e[34m//\
    \ how many cars are in front of it.  If the car is moving left to right, then\e\
    [0m\n\e[31m16 |\e[0m        \e[34m// the number of cars in front of it is the\
    \ number of collisions it will have.\e[0m\n\e[31m17 |\e[0m        \e[34m// If\
    \ the car is moving right to left, then the number of cars in front of it is\e\
    [0m\n\e[31m18 |\e[0m        \e[34m// the number of collisions it will have minus\
    \ 1.  The reason for this is that\e[0m\n\e[31m19 |\e[0m        \e[34m// the car\
    \ will collide with the car in front of it, but it will not collide with\e[0m\n\
    \e[31m20 |\e[0m        \e[34m// the car behind it.\e[0m\n\e[31m21 |\e[0m     \
    \   \e[34m// The total number of collisions is the sum of the number of collisions\
    \ for each car.\e[0m\n\e[31m22 |\e[0m        \e[34m// The total number of collisions\
    \ is also the sum of the number of cars in front of\e[0m\n\e[31m23 |\e[0m    \
    \    \e[34m// each car.  So, we can solve this problem by sorting the cars by\
    \ their starting\e[0m\n\e[31m24 |\e[0m        \e[34m// position, and then summing\
    \ the number of cars in front of each car.\e[0m\n\e[31m25 |\e[0m        \e[34m//\
    \ The number of cars in front of each car is the number of cars to the right of\e\
    [0m\n\e[31m26 |\e[0m        \e[34m// the car.  So, we can solve this problem by\
    \ sorting the cars by their starting\e[0m\n\e[31m27 |\e[0m        \e[34m// position,\
    \ and then summing the number of cars to the right of each car.\e[0m\n\e[31m28\
    \ |\e[0m        \e[34m// We can"
  stdout: ''
  timestamp: 1659792726
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This function returns\
    \ the number of collisions between the cars that are moving\n        // left to\
    \ right and the cars that are moving right to left.\n        // The cars are numbered\
    \ from 1 to n.  The cars that are moving left to right are\n        // numbered\
    \ from 1 to n.  The cars that are moving right to left are numbered from\n   \
    \     // n to 1.\n        // The cars are initially very far from each other.\
    \  The cars that are moving left to right\n        // are initially at position\
    \ -1000000000, -1000000000 + 1, -1000000000 + 2, ..., -1000000000 + n - 1.\n \
    \       // The cars that are moving right to left are initially at position 1000000000,\
    \ 1000000000 - 1,\n        // 1000000000 - 2, ..., 1000000000 - n + 1.\n     \
    \   // The cars that are moving left to right move at speed 1.  The cars that\
    \ are moving right to left\n        // move at speed 1.\n        // The function\
    \ returns the number of collisions.\n        def collision(n : Long) : Long =\
    \ {\n            // The cars that are moving left to right are numbered from 1\
    \ to n.\n            // The cars that are moving right to left are numbered from\
    \ n to 1.\n            // The cars are initially very far from each other.  The\
    \ cars that are moving left to right\n            // are initially at position\
    \ -1000000000, -1000000000 + 1, -1000000000 + 2, ..., -1000000000 + n - 1.\n \
    \           // The cars that are moving right to left are initially at position\
    \ 1000000000, 1000000000 - 1,\n            // 1000000000 - 2, ..., 1000000000\
    \ - n + 1.\n            // The cars that are moving left to right move at speed\
    \ 1.  The cars that are moving right to left\n            // move at speed 1.\n\
    \            // The function returns the number of collisions.\n            def\
    \ collision(n : Long) : Long = {\n                if (n == 1) 0\n            \
    \    else {\n                    val m = n / 2\n                    val left =\
    \ collision(m)\n                    val right = collision(n - m)\n           \
    \         val mid = m * (n - m)\n                    left + right + mid\n    \
    \            }\n            }\n            collision(n)\n        }\n        collision(n)\n\
    \n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpvz5fx930.scala:51)\n\tat Problem.main(tmpvz5fx930.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792728
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is a very simple\
    \ problem.  The cars are moving at the same speed, so\n        // the order of\
    \ the cars is preserved.  Therefore, the number of collisions\n        // is simply\
    \ the number of pairs of cars that are in the same position.\n        // The first\
    \ car can be in any of n positions.  The second car can be in any\n        //\
    \ of n - 1 positions.  The third car can be in any of n - 2 positions.\n     \
    \   // ...\n        // The nth car can be in any of 1 position.\n        // Therefore,\
    \ the total number of collisions is\n        // n * (n - 1) * (n - 2) * ... *\
    \ 1 = n!\n        // This is the same as the factorial of n.\n        // However,\
    \ we can't use the factorial function because it's too slow.\n        // We can\
    \ use the fact that n! = n * (n - 1)!\n        // This is a recursive function.\
    \  We can use tail recursion to make it\n        // iterative.\n        def factorial(n\
    \ : Long, acc : Long) : Long = {\n            if (n == 0) acc\n            else\
    \ factorial(n - 1, n * acc)\n        }\n        factorial(n, 1)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n\
    \    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpld0rdqq_.scala:34)\n\tat Problem.main(tmpld0rdqq_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792727
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting position.\n        // Then, we can just iterate through\
    \ the sorted cars, and count the number of\n        // cars that are moving in\
    \ the opposite direction.\n        // The time complexity is O(n log n)\n    \
    \    val cars = Array.fill(n.toInt)(0)\n        for (i <- 0 until n.toInt) {\n\
    \            cars(i) = i\n        }\n        val sortedCars = cars.sortWith(_\
    \ < _)\n        var count = 0\n        for (i <- 0 until n.toInt) {\n        \
    \    if (i % 2 == 0) {\n                // moving left to right\n            \
    \    count += sortedCars(i)\n            } else {\n                // moving right\
    \ to left\n                count += (n - 1 - sortedCars(i))\n            }\n \
    \       }\n        count\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpkt37ih8b.scala:29:22 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m                count += (n - \e[31m1\e[0m - sortedCars(i))\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \      value += is not a member of Int - did you mean Int.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1659792729
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is a simple problem.\
    \  We can solve it by sorting the cars by their\n        // starting positions.\
    \  Then, we can go through the cars from left to right,\n        // and for each\
    \ car, we can find the number of cars that are to the left of it\n        // and\
    \ moving right to left.  This is the number of collisions that this car\n    \
    \    // will have.  We can then add this number to the total number of collisions.\n\
    \        // This is O(n log n) time and O(n) space.\n        // We can do better.\
    \  We can use a segment tree to keep track of the number of\n        // cars that\
    \ are to the left of a given car and moving right to left.  This\n        // is\
    \ O(n log n) time and O(n) space.\n        // We can do even better.  We can use\
    \ a Fenwick tree to keep track of the number\n        // of cars that are to the\
    \ left of a given car and moving right to left.  This\n        // is O(n log n)\
    \ time and O(n) space.\n        // We can do even better.  We can use a Fenwick\
    \ tree to keep track of the number\n        // of cars that are to the left of\
    \ a given car and moving right to left.  This\n        // is O(n log n) time and\
    \ O(n) space.\n        // We can do even better.  We can use a Fenwick tree to\
    \ keep track of the number\n        // of cars that are to the left of a given\
    \ car and moving right to left.  This\n        // is O(n log n) time and O(n)\
    \ space.\n        // We can do even better.  We can use a Fenwick tree to keep\
    \ track of the number\n        // of cars that are to the left of a given car\
    \ and moving right to left.  This\n        // is O(n log n) time and O(n) space.\n\
    \        // We can do even better.  We can use a Fenwick tree to keep track of\
    \ the number\n        // of cars that are to the left of a given car and moving\
    \ right to left.  This\n        // is O(n log n) time and O(n) space.\n      \
    \  // We can do even better.  We can use a Fenwick\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmppvs7hfgx.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// This is a simple problem.  We can solve it by sorting the cars by their\e\
    [0m\n\e[31m14 |\e[0m        \e[34m// starting positions.  Then, we can go through\
    \ the cars from left to right,\e[0m\n\e[31m15 |\e[0m        \e[34m// and for each\
    \ car, we can find the number of cars that are to the left of it\e[0m\n\e[31m16\
    \ |\e[0m        \e[34m// and moving right to left.  This is the number of collisions\
    \ that this car\e[0m\n\e[31m17 |\e[0m        \e[34m// will have.  We can then\
    \ add this number to the total number of collisions.\e[0m\n\e[31m18 |\e[0m   \
    \     \e[34m// This is O(n log n) time and O(n) space.\e[0m\n\e[31m19 |\e[0m \
    \       \e[34m// We can do better.  We can use a segment tree to keep track of\
    \ the number of\e[0m\n\e[31m20 |\e[0m        \e[34m// cars that are to the left\
    \ of a given car and moving right to left.  This\e[0m\n\e[31m21 |\e[0m       \
    \ \e[34m// is O(n log n) time and O(n) space.\e[0m\n\e[31m22 |\e[0m        \e\
    [34m// We can do even better.  We can use a Fenwick tree to keep track of the\
    \ number\e[0m\n\e[31m23 |\e[0m        \e[34m// of cars that are to the left of\
    \ a given car and moving right to left.  This\e[0m\n\e[31m24 |\e[0m        \e\
    [34m// is O(n log n) time and O(n) space.\e[0m\n\e[31m25 |\e[0m        \e[34m//\
    \ We can do even better.  We can use a Fenwick tree to keep track of the number\e\
    [0m\n\e[31m26 |\e[0m        \e[34m// of cars that are to the left of a given car\
    \ and moving right to left.  This\e[0m\n\e[31m27 |\e[0m        \e[34m// is O(n\
    \ log n) time and O(n) space.\e[0m\n\e[31m28 |\e[0m        \e[34m// We can do\
    \ even better.  We can use a Fenwick tree to keep track of the number\e[0m\n\e\
    [31m29 |\e[0m        \e[34m// of cars that are to the l"
  stdout: ''
  timestamp: 1659792729
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The key observation\
    \ is that the cars that are moving in the same direction\n        // will never\
    \ collide.  So we can focus on the cars that are moving in opposite directions.\n\
    \        // The cars that are moving in opposite directions are indexed by the\
    \ integers from 1 to n.\n        // The car that's moving left to right is indexed\
    \ by i, and the car that's moving right to left\n        // is indexed by n +\
    \ 1 - i.\n        // The key observation is that the cars that are moving in the\
    \ same direction\n        // will never collide.  So we can focus on the cars\
    \ that are moving in opposite directions.\n        // The cars that are moving\
    \ in opposite directions are indexed by the integers from 1 to n.\n        //\
    \ The car that's moving left to right is indexed by i, and the car that's moving\
    \ right to left\n        // is indexed by n + 1 - i.\n        // The key observation\
    \ is that the cars that are moving in the same direction\n        // will never\
    \ collide.  So we can focus on the cars that are moving in opposite directions.\n\
    \        // The cars that are moving in opposite directions are indexed by the\
    \ integers from 1 to n.\n        // The car that's moving left to right is indexed\
    \ by i, and the car that's moving right to left\n        // is indexed by n +\
    \ 1 - i.\n        // The key observation is that the cars that are moving in the\
    \ same direction\n        // will never collide.  So we can focus on the cars\
    \ that are moving in opposite directions.\n        // The cars that are moving\
    \ in opposite directions are indexed by the integers from 1 to n.\n        //\
    \ The car that's moving left to right is indexed by i, and the car that's moving\
    \ right to left\n        // is indexed by n + 1 - i.\n        // The key observation\
    \ is that the cars that are moving in the same direction\n        // will never\
    \ collide.  So we can focus on the cars that are moving in opposite directions.\n\
    \        // The cars that are moving in opposite directions are indexed by the\
    \ integers from 1 to n.\n        // The car that's moving left to right is indexed\
    \ by i, and the car that's moving right to left\n        // is indexed by n +\
    \ 1 - i.\n        // The key observation is that the cars that are moving in the\
    \ same direction\n        // will never collide.  So we\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmptpu7mljo.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// The key observation is that the cars that are moving in the same direction\e\
    [0m\n\e[31m14 |\e[0m        \e[34m// will never collide.  So we can focus on the\
    \ cars that are moving in opposite directions.\e[0m\n\e[31m15 |\e[0m        \e\
    [34m// The cars that are moving in opposite directions are indexed by the integers\
    \ from 1 to n.\e[0m\n\e[31m16 |\e[0m        \e[34m// The car that's moving left\
    \ to right is indexed by i, and the car that's moving right to left\e[0m\n\e[31m17\
    \ |\e[0m        \e[34m// is indexed by n + 1 - i.\e[0m\n\e[31m18 |\e[0m      \
    \  \e[34m// The key observation is that the cars that are moving in the same direction\e\
    [0m\n\e[31m19 |\e[0m        \e[34m// will never collide.  So we can focus on the\
    \ cars that are moving in opposite directions.\e[0m\n\e[31m20 |\e[0m        \e\
    [34m// The cars that are moving in opposite directions are indexed by the integers\
    \ from 1 to n.\e[0m\n\e[31m21 |\e[0m        \e[34m// The car that's moving left\
    \ to right is indexed by i, and the car that's moving right to left\e[0m\n\e[31m22\
    \ |\e[0m        \e[34m// is indexed by n + 1 - i.\e[0m\n\e[31m23 |\e[0m      \
    \  \e[34m// The key observation is that the cars that are moving in the same direction\e\
    [0m\n\e[31m24 |\e[0m        \e[34m// will never collide.  So we can focus on the\
    \ cars that are moving in opposite directions.\e[0m\n\e[31m25 |\e[0m        \e\
    [34m// The cars that are moving in opposite directions are indexed by the integers\
    \ from 1 to n.\e[0m\n\e[31m26 |\e[0m        \e[34m// The car that's moving left\
    \ to right is indexed by i, and the car that's moving right to left\e[0m\n\e[31m27\
    \ |\e[0m        \e[34m// is indexed by n + 1 - i.\e[0m\n\e[31m28 |\e[0m      \
    \  \e[34"
  stdout: ''
  timestamp: 1659792730
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is a simple greedy\
    \ algorithm.  We first sort the cars by their starting\n        // position. \
    \ Then, we iterate through the cars from left to right.  For each car,\n     \
    \   // we check if it collides with any of the cars that are already in the list.\n\
    \        // If it does, we add it to the list.  If it doesn't, we add it to the\
    \ list and\n        // remove the car that it collides with.\n        val cars\
    \ = new ArrayBuffer[Long]\n        for (i <- 1 to n.toInt) {\n            val\
    \ car = readLine.toLong\n            val index = cars.indexWhere(x => x > car)\n\
    \            if (index == -1) cars += car\n            else cars.insert(index,\
    \ car)\n        }\n        var collisions = 0\n        for (i <- 0 until n.toInt)\
    \ {\n            val car = readLine.toLong\n            val index = cars.indexWhere(x\
    \ => x < car)\n            if (index == -1) collisions += 1\n            else\
    \ cars.remove(index)\n        }\n        collisions\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpew4kcg75.scala:20:22 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            \e[33mval\e[0m \e[36mcar\e[0m = readLine.toLong\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                  Not found: readLine\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpew4kcg75.scala:27:22 ------------------------\e[0m\e\
    [0m\n\e[31m27 |\e[0m            \e[33mval\e[0m \e[36mcar\e[0m = readLine.toLong\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                  Not found: readLine\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659792728
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is a very simple\
    \ problem.  We can solve it in O(n) time.\n        // The key observation is that\
    \ the cars that move left to right\n        // are in the same order as the cars\
    \ that move right to left.\n        // Therefore, the number of collisions is\
    \ the number of inversions\n        // in the permutation of the cars that move\
    \ left to right.\n        // We can compute the number of inversions in O(n log\
    \ n) time\n        // using a divide-and-conquer algorithm.\n        //\n    \
    \    // The divide-and-conquer algorithm is as follows.\n        // Let's say\
    \ we have a permutation of the numbers 1, 2, ..., n.\n        // We can split\
    \ the permutation into two parts:\n        // the first part contains the numbers\
    \ 1, 2, ..., n/2,\n        // and the second part contains the numbers n/2 + 1,\
    \ ..., n.\n        // We can compute the number of inversions in the first part\n\
    \        // and the number of inversions in the second part.\n        // Then,\
    \ we can compute the number of inversions that cross\n        // the boundary\
    \ between the first part and the second part.\n        // The total number of\
    \ inversions is the sum of these three numbers.\n        //\n        // We can\
    \ compute the number of inversions that cross the boundary\n        // between\
    \ the first part and the second part as follows.\n        // We can sort the first\
    \ part and the second part.\n        // Then, we can merge the two sorted parts.\n\
    \        // The number of inversions that cross the boundary is the number\n \
    \       // of pairs of numbers that are in the first part and the second part\n\
    \        // and are out of order.\n        //\n        // We can compute the number\
    \ of inversions in the first part\n        // and the number of inversions in\
    \ the second part recursively.\n        //\n        // The base case is when the\
    \ permutation contains only one number.\n        // In this case, the number of\
    \ inversions is zero.\n        //\n        // We can implement this algorithm\
    \ in O(n log n) time.\n        //\n        // We can also solve this problem in\
    \ O(n) time.\n        // The key observation is that the number of inversions\n\
    \        // is equal to the\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp1ytosgmr.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// This is a very simple problem.  We can solve it in O(n) time.\e[0m\n\e\
    [31m14 |\e[0m        \e[34m// The key observation is that the cars that move left\
    \ to right\e[0m\n\e[31m15 |\e[0m        \e[34m// are in the same order as the\
    \ cars that move right to left.\e[0m\n\e[31m16 |\e[0m        \e[34m// Therefore,\
    \ the number of collisions is the number of inversions\e[0m\n\e[31m17 |\e[0m \
    \       \e[34m// in the permutation of the cars that move left to right.\e[0m\n\
    \e[31m18 |\e[0m        \e[34m// We can compute the number of inversions in O(n\
    \ log n) time\e[0m\n\e[31m19 |\e[0m        \e[34m// using a divide-and-conquer\
    \ algorithm.\e[0m\n\e[31m20 |\e[0m        \e[34m//\e[0m\n\e[31m21 |\e[0m     \
    \   \e[34m// The divide-and-conquer algorithm is as follows.\e[0m\n\e[31m22 |\e\
    [0m        \e[34m// Let's say we have a permutation of the numbers 1, 2, ...,\
    \ n.\e[0m\n\e[31m23 |\e[0m        \e[34m// We can split the permutation into two\
    \ parts:\e[0m\n\e[31m24 |\e[0m        \e[34m// the first part contains the numbers\
    \ 1, 2, ..., n/2,\e[0m\n\e[31m25 |\e[0m        \e[34m// and the second part contains\
    \ the numbers n/2 + 1, ..., n.\e[0m\n\e[31m26 |\e[0m        \e[34m// We can compute\
    \ the number of inversions in the first part\e[0m\n\e[31m27 |\e[0m        \e[34m//\
    \ and the number of inversions in the second part.\e[0m\n\e[31m28 |\e[0m     \
    \   \e[34m// Then, we can compute the number of inversions that cross\e[0m\n\e\
    [31m29 |\e[0m        \e[34m// the boundary between the first part and the second\
    \ part.\e[0m\n\e[31m30 |\e[0m        \e[34m// The total number of inversions is\
    \ the sum of these three numbers.\e[0m\n\e[31m31 |\e[0m        \e[34m//\e[0m\n\
    \e[31m32 |\e[0m        \e[34m// We can compute the number o"
  stdout: ''
  timestamp: 1659792731
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is the number\
    \ of collisions.\n        var collisions = 0L\n        // This is the number of\
    \ cars that are moving left to right.\n        var leftToRight = n\n        //\
    \ This is the number of cars that are moving right to left.\n        var rightToLeft\
    \ = n\n        // This is the number of cars that are moving left to right and\
    \ have already collided.\n        var leftToRightCollided = 0L\n        // This\
    \ is the number of cars that are moving right to left and have already collided.\n\
    \        var rightToLeftCollided = 0L\n        // This is the number of cars that\
    \ are moving left to right and have not yet collided.\n        var leftToRightNotCollided\
    \ = n\n        // This is the number of cars that are moving right to left and\
    \ have not yet collided.\n        var rightToLeftNotCollided = n\n        // This\
    \ is the number of cars that are moving left to right and have not yet collided\
    \ and are in front of the cars that are moving right to left.\n        var leftToRightNotCollidedInFront\
    \ = 0L\n        // This is the number of cars that are moving right to left and\
    \ have not yet collided and are in front of the cars that are moving left to right.\n\
    \        var rightToLeftNotCollidedInFront = 0L\n        // This is the number\
    \ of cars that are moving left to right and have not yet collided and are behind\
    \ the cars that are moving right to left.\n        var leftToRightNotCollidedBehind\
    \ = n\n        // This is the number of cars that are moving right to left and\
    \ have not yet collided and are behind the cars that are moving left to right.\n\
    \        var rightToLeftNotCollidedBehind = n\n        // This is the number of\
    \ cars that are moving left to right and have not yet collided and are in front\
    \ of the cars that are moving right to left and have not yet collided.\n     \
    \   var leftToRightNotCollidedInFrontNotCollided = 0L\n        // This is the\
    \ number of cars that are moving right to left and have not yet collided and are\
    \ in front of the cars that are moving left to right and have not yet collided.\n\
    \        var rightToLeftNotCollidedInFrontNotCollided = 0L\n        // This is\
    \ the number of cars that are moving left to right and have not yet collided and\
    \ are behind the cars\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp04bbrq_g.scala:40:5\
    \ ---------------------\e[0m\e[0m\n\e[31m40 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659792731
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting position.\n        // Then, we can imagine that the\
    \ cars are moving in a circle.\n        // The cars that are moving left to right\
    \ are moving clockwise,\n        // and the cars that are moving right to left\
    \ are moving counterclockwise.\n        // Then, we can imagine that the cars\
    \ are moving in a circle.\n        // The cars that are moving left to right are\
    \ moving clockwise,\n        // and the cars that are moving right to left are\
    \ moving counterclockwise.\n        // The cars that are moving left to right\
    \ are moving clockwise,\n        // and the cars that are moving right to left\
    \ are moving counterclockwise.\n        // The cars that are moving left to right\
    \ are moving clockwise,\n        // and the cars that are moving right to left\
    \ are moving counterclockwise.\n        // The cars that are moving left to right\
    \ are moving clockwise,\n        // and the cars that are moving right to left\
    \ are moving counterclockwise.\n        // The cars that are moving left to right\
    \ are moving clockwise,\n        // and the cars that are moving right to left\
    \ are moving counterclockwise.\n        // The cars that are moving left to right\
    \ are moving clockwise,\n        // and the cars that are moving right to left\
    \ are moving counterclockwise.\n        // The cars that are moving left to right\
    \ are moving clockwise,\n        // and the cars that are moving right to left\
    \ are moving counterclockwise.\n        // The cars that are moving left to right\
    \ are moving clockwise,\n        // and the cars that are moving right to left\
    \ are moving counterclockwise.\n        // The cars that are moving left to right\
    \ are moving clockwise,\n        // and the cars that are moving right to left\
    \ are moving counterclockwise.\n        // The cars that are moving left to right\
    \ are moving clockwise,\n        // and the cars that are moving right to left\
    \ are moving counterclockwise.\n        // The cars that are moving left to right\
    \ are moving clockwise,\n        // and the cars that are moving right to left\
    \ are moving counterclockwise.\n        // The cars that are moving left to right\
    \ are moving clockwise,\n        // and the cars that are moving right to left\
    \ are moving counterclockwise.\n        // The cars that are moving left to right\
    \ are moving clockwise,\n        // and the\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmplngk9l88.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// The idea is to sort the cars by their starting position.\e[0m\n\e[31m14\
    \ |\e[0m        \e[34m// Then, we can imagine that the cars are moving in a circle.\e\
    [0m\n\e[31m15 |\e[0m        \e[34m// The cars that are moving left to right are\
    \ moving clockwise,\e[0m\n\e[31m16 |\e[0m        \e[34m// and the cars that are\
    \ moving right to left are moving counterclockwise.\e[0m\n\e[31m17 |\e[0m    \
    \    \e[34m// Then, we can imagine that the cars are moving in a circle.\e[0m\n\
    \e[31m18 |\e[0m        \e[34m// The cars that are moving left to right are moving\
    \ clockwise,\e[0m\n\e[31m19 |\e[0m        \e[34m// and the cars that are moving\
    \ right to left are moving counterclockwise.\e[0m\n\e[31m20 |\e[0m        \e[34m//\
    \ The cars that are moving left to right are moving clockwise,\e[0m\n\e[31m21\
    \ |\e[0m        \e[34m// and the cars that are moving right to left are moving\
    \ counterclockwise.\e[0m\n\e[31m22 |\e[0m        \e[34m// The cars that are moving\
    \ left to right are moving clockwise,\e[0m\n\e[31m23 |\e[0m        \e[34m// and\
    \ the cars that are moving right to left are moving counterclockwise.\e[0m\n\e\
    [31m24 |\e[0m        \e[34m// The cars that are moving left to right are moving\
    \ clockwise,\e[0m\n\e[31m25 |\e[0m        \e[34m// and the cars that are moving\
    \ right to left are moving counterclockwise.\e[0m\n\e[31m26 |\e[0m        \e[34m//\
    \ The cars that are moving left to right are moving clockwise,\e[0m\n\e[31m27\
    \ |\e[0m        \e[34m// and the cars that are moving right to left are moving\
    \ counterclockwise.\e[0m\n\e[31m28 |\e[0m        \e[34m// The cars that are moving\
    \ left to right are moving clockwise,\e[0m\n\e[31m29 |\e[0m        \e[34m// and\
    \ the cars that are moving right to left"
  stdout: ''
  timestamp: 1659792731
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // Let's say the cars\
    \ are numbered from 1 to n.  The cars moving left to right are\n        // numbered\
    \ from 1 to n, and the cars moving right to left are numbered from n to 1.\n \
    \       // The cars moving left to right are at positions 1, 2, 3, ..., n.\n \
    \       // The cars moving right to left are at positions n, n-1, n-2, ..., 1.\n\
    \        // The cars moving left to right are moving at speeds 1, 2, 3, ..., n.\n\
    \        // The cars moving right to left are moving at speeds n, n-1, n-2, ...,\
    \ 1.\n        // The cars moving left to right are moving at speeds 1, 2, 3, ...,\
    \ n.\n        // The cars moving right to left are moving at speeds n, n-1, n-2,\
    \ ..., 1.\n        // The cars moving left to right are moving at speeds 1, 2,\
    \ 3, ..., n.\n        // The cars moving right to left are moving at speeds n,\
    \ n-1, n-2, ..., 1.\n        // The cars moving left to right are moving at speeds\
    \ 1, 2, 3, ..., n.\n        // The cars moving right to left are moving at speeds\
    \ n, n-1, n-2, ..., 1.\n        // The cars moving left to right are moving at\
    \ speeds 1, 2, 3, ..., n.\n        // The cars moving right to left are moving\
    \ at speeds n, n-1, n-2, ..., 1.\n        // The cars moving left to right are\
    \ moving at speeds 1, 2, 3, ..., n.\n        // The cars moving right to left\
    \ are moving at speeds n, n-1, n-2, ..., 1.\n        // The cars moving left to\
    \ right are moving at speeds 1, 2, 3, ..., n.\n        // The cars moving right\
    \ to left are moving at speeds n, n-1, n-2, ..., 1.\n        // The cars moving\
    \ left to right are moving at speeds 1, 2, 3, ..., n.\n        // The cars moving\
    \ right to left are moving at speeds n, n-1, n-2, ..., 1.\n        // The cars\
    \ moving left to right are moving at speeds 1, 2, 3\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpih54o5e2.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// Let's say the cars are numbered from 1 to n.  The cars moving left to right\
    \ are\e[0m\n\e[31m14 |\e[0m        \e[34m// numbered from 1 to n, and the cars\
    \ moving right to left are numbered from n to 1.\e[0m\n\e[31m15 |\e[0m       \
    \ \e[34m// The cars moving left to right are at positions 1, 2, 3, ..., n.\e[0m\n\
    \e[31m16 |\e[0m        \e[34m// The cars moving right to left are at positions\
    \ n, n-1, n-2, ..., 1.\e[0m\n\e[31m17 |\e[0m        \e[34m// The cars moving left\
    \ to right are moving at speeds 1, 2, 3, ..., n.\e[0m\n\e[31m18 |\e[0m       \
    \ \e[34m// The cars moving right to left are moving at speeds n, n-1, n-2, ...,\
    \ 1.\e[0m\n\e[31m19 |\e[0m        \e[34m// The cars moving left to right are moving\
    \ at speeds 1, 2, 3, ..., n.\e[0m\n\e[31m20 |\e[0m        \e[34m// The cars moving\
    \ right to left are moving at speeds n, n-1, n-2, ..., 1.\e[0m\n\e[31m21 |\e[0m\
    \        \e[34m// The cars moving left to right are moving at speeds 1, 2, 3,\
    \ ..., n.\e[0m\n\e[31m22 |\e[0m        \e[34m// The cars moving right to left\
    \ are moving at speeds n, n-1, n-2, ..., 1.\e[0m\n\e[31m23 |\e[0m        \e[34m//\
    \ The cars moving left to right are moving at speeds 1, 2, 3, ..., n.\e[0m\n\e\
    [31m24 |\e[0m        \e[34m// The cars moving right to left are moving at speeds\
    \ n, n-1, n-2, ..., 1.\e[0m\n\e[31m25 |\e[0m        \e[34m// The cars moving left\
    \ to right are moving at speeds 1, 2, 3, ..., n.\e[0m\n\e[31m26 |\e[0m       \
    \ \e[34m// The cars moving right to left are moving at speeds n, n-1, n-2, ...,\
    \ 1.\e[0m\n\e[31m27 |\e[0m        \e[34m// The cars moving left to right are moving\
    \ at speeds 1, 2, 3, ..., n.\e[0m\n\e[31m28 |\e[0m        \e[34m// The cars moving\
    \ right to left are moving at spe"
  stdout: ''
  timestamp: 1659792732
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // Let's say that the\
    \ cars moving left to right are indexed from 0 to n - 1.\n        // Let's say\
    \ that the cars moving right to left are indexed from 0 to n - 1.\n        //\
    \ Let's say that the car moving left to right with index i starts at position\
    \ i.\n        // Let's say that the car moving right to left with index i starts\
    \ at position n - 1 - i.\n        // We can see that the cars moving left to right\
    \ with index i and j will collide if and only if\n        // i < j and n - 1 -\
    \ i < n - 1 - j.  This is equivalent to i < j and i > n - 1 - j.\n        // This\
    \ is equivalent to i > n - 1 - j.\n        // This is equivalent to i > (n - 1)\
    \ / 2 - j.\n        // This is equivalent to i > (n - 1) / 2 - (n - 1 - i).\n\
    \        // This is equivalent to i > (n - 1) / 2 - (n - 1) + i.\n        // This\
    \ is equivalent to i > (n - 1) / 2 - (n - 1) + i.\n        // This is equivalent\
    \ to i > (n - 1) / 2 - (n - 1) + i.\n        // This is equivalent to i > (n -\
    \ 1) / 2 - (n - 1) + i.\n        // This is equivalent to i > (n - 1) / 2 - (n\
    \ - 1) + i.\n        // This is equivalent to i > (n - 1) / 2 - (n - 1) + i.\n\
    \        // This is equivalent to i > (n - 1) / 2 - (n - 1) + i.\n        // This\
    \ is equivalent to i > (n - 1) / 2 - (n - 1) + i.\n        // This is equivalent\
    \ to i > (n - 1) / 2 - (n - 1) + i.\n        // This is equivalent to i > (n -\
    \ 1) / 2 - (n - 1) + i.\n        // This is equivalent to i > (n - 1) / 2 - (n\
    \ - 1) + i.\n        // This is equivalent to i > (n - 1) / 2 - (n - 1) + i.\n\
    \        // This\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpdlzc667i.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// Let's say that the cars moving left to right are indexed from 0 to n -\
    \ 1.\e[0m\n\e[31m14 |\e[0m        \e[34m// Let's say that the cars moving right\
    \ to left are indexed from 0 to n - 1.\e[0m\n\e[31m15 |\e[0m        \e[34m// Let's\
    \ say that the car moving left to right with index i starts at position i.\e[0m\n\
    \e[31m16 |\e[0m        \e[34m// Let's say that the car moving right to left with\
    \ index i starts at position n - 1 - i.\e[0m\n\e[31m17 |\e[0m        \e[34m//\
    \ We can see that the cars moving left to right with index i and j will collide\
    \ if and only if\e[0m\n\e[31m18 |\e[0m        \e[34m// i < j and n - 1 - i < n\
    \ - 1 - j.  This is equivalent to i < j and i > n - 1 - j.\e[0m\n\e[31m19 |\e\
    [0m        \e[34m// This is equivalent to i > n - 1 - j.\e[0m\n\e[31m20 |\e[0m\
    \        \e[34m// This is equivalent to i > (n - 1) / 2 - j.\e[0m\n\e[31m21 |\e\
    [0m        \e[34m// This is equivalent to i > (n - 1) / 2 - (n - 1 - i).\e[0m\n\
    \e[31m22 |\e[0m        \e[34m// This is equivalent to i > (n - 1) / 2 - (n - 1)\
    \ + i.\e[0m\n\e[31m23 |\e[0m        \e[34m// This is equivalent to i > (n - 1)\
    \ / 2 - (n - 1) + i.\e[0m\n\e[31m24 |\e[0m        \e[34m// This is equivalent\
    \ to i > (n - 1) / 2 - (n - 1) + i.\e[0m\n\e[31m25 |\e[0m        \e[34m// This\
    \ is equivalent to i > (n - 1) / 2 - (n - 1) + i.\e[0m\n\e[31m26 |\e[0m      \
    \  \e[34m// This is equivalent to i > (n - 1) / 2 - (n - 1) + i.\e[0m\n\e[31m27\
    \ |\e[0m        \e[34m// This is equivalent to i > (n - 1) / 2 - (n - 1) + i.\e\
    [0m\n\e[31m28 |\e[0m        \e[34m// This is equivalent to i > (n - 1) / 2 - (n\
    \ - 1) + i.\e[0m\n\e[31m29 |\e[0m        \e[34m// This is equivalent to i > (n\
    \ - 1) / 2 - (n - 1) + i.\e[0m\n\e[31m30 |\e[0m        \e[34m/"
  stdout: ''
  timestamp: 1659792732
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        var leftToRight = new\
    \ Array[Long](n.toInt)\n        var rightToLeft = new Array[Long](n.toInt)\n \
    \       for (i <- 0 until n.toInt) {\n            leftToRight(i) = i\n       \
    \     rightToLeft(i) = n - i - 1\n        }\n        var collisions = 0\n    \
    \    for (i <- 0 until n.toInt) {\n            for (j <- 0 until n.toInt) {\n\
    \                if (leftToRight(i) == rightToLeft(j)) collisions += 1\n     \
    \       }\n        }\n        return collisions\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpel_p8esj.scala:28)\n\tat Problem.main(tmpel_p8esj.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792734
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This function returns\
    \ the number of collisions between the two sets of cars.\n        // The two sets\
    \ of cars are represented by two arrays of integers.\n        // The first array\
    \ represents the cars moving left to right,\n        // and the second array represents\
    \ the cars moving right to left.\n        // Each integer in the array represents\
    \ the position of the car.\n        // The cars are sorted in ascending order.\n\
    \        def carRaceCollision(leftToRight : Array[Long], rightToLeft : Array[Long])\
    \ : Long = {\n            // This function returns the number of collisions between\
    \ the two sets of cars.\n            // The two sets of cars are represented by\
    \ two arrays of integers.\n            // The first array represents the cars\
    \ moving left to right,\n            // and the second array represents the cars\
    \ moving right to left.\n            // Each integer in the array represents the\
    \ position of the car.\n            // The cars are sorted in ascending order.\n\
    \            // The two arrays are assumed to be of the same length.\n       \
    \     def carRaceCollision(leftToRight : Array[Long], rightToLeft : Array[Long],\
    \ index : Int) : Long = {\n                if (index == leftToRight.length) 0\n\
    \                else {\n                    val left = leftToRight(index)\n \
    \                   val right = rightToLeft(index)\n                    if (left\
    \ < right) carRaceCollision(leftToRight, rightToLeft, index + 1)\n           \
    \         else 1 + carRaceCollision(leftToRight, rightToLeft, index + 1)\n   \
    \             }\n            }\n            carRaceCollision(leftToRight, rightToLeft,\
    \ 0)\n        }\n        // This function returns the number of collisions between\
    \ the two sets of cars.\n        // The two sets of cars are represented by two\
    \ arrays of integers.\n        // The first array represents the cars moving left\
    \ to right,\n        // and the second array represents the cars moving right\
    \ to left.\n        // Each integer in the array represents the position of the\
    \ car.\n        // The cars are sorted in ascending order.\n        // The two\
    \ arrays are assumed to be of the same length.\n        def carRaceCollision(leftToRight\
    \ : Array[Long], rightToLeft : Array[Long], index : Int) : Long = {\n        \
    \    if (index == leftToRight.length) 0\n\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpyzxi5h0b.scala:58:0 ----------------------------\e\
    [0m\e[0m\n\e[31m58 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpyzxi5h0b.scala:45:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m45 |\e[0m        \e[33mdef\e[0m\
    \ \e[36mcarRaceCollision\e[0m(\e[36mleftToRight\e[0m : \e[35mArray\e[0m[\e[35mLong\e\
    [0m], \e[36mrightToLeft\e[0m : \e[35mArray\e[0m[\e[35mLong\e[0m], \e[36mindex\e\
    [0m : \e[35mInt\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e[0m        ^\e\
    [0m\n\e[31m   |\e[0mcarRaceCollision is already defined as \e[33mmethod\e[0m \e\
    [35mcarRaceCollision\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m46\
    \ |\e[0m            \e[33mif\e[0m (index == leftToRight.length) \e[31m0\e[0m\n\
    \e[31m47 |\e[0m    }\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpyzxi5h0b.scala:50:29\
    \ --------------------\e[0m\e[0m\n\e[31m50 |\e[0m    assert(carRaceCollision((\e\
    [31m2l\e[0m)) == (\e[31m4l\e[0m));\n\e[31m\e[31m   |\e[0m                    \
    \         ^^\e[0m\n\e[31m   |\e[0m                             Found:    (\e[31m2L\e\
    [0m : Long)\n\e[31m   |\e[0m                             Required: Array[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpyzxi5h0b.scala:51:29\
    \ --------------------\e[0m\e[0m\n\e[31m51 |\e[0m    assert(carRaceCollision((\e\
    [31m3l\e[0m)) == (\e[31m9l\e[0m));\n\e[31m\e[31m   |\e[0m                    \
    \         ^^\e[0m\n\e[31m   |\e[0m                             Found:    (\e[31m3L\e\
    [0m : Long)\n\e[31m   |\e[0m                             Required: Array[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpyzxi5h0b.scala:52:29\
    \ --------------------\e[0m\e[0m\n\e[31m52 |\e[0m    assert(carRaceCollision((\e\
    [31m4l\e[0m)) == (\e[31m16l\e[0m));\n\e[31m\e[31m   |\e[0m                   \
    \          ^^\e[0m\n\e[31m   |\e[0m                             Found:    (\e\
    [31m4L\e[0m : Long)\n\e[3"
  stdout: ''
  timestamp: 1659792734
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is a very interesting\
    \ problem.  The key is to realize that\n        // the cars that move left to\
    \ right are in fact the same as the cars\n        // that move right to left.\
    \  In other words, the problem is equivalent\n        // to asking how many pairs\
    \ of cars collide.  The answer is n * (n - 1) / 2.\n        n * (n - 1) / 2\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpr3_kb9jq.scala:20)\n\tat Problem.main(tmpr3_kb9jq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792734
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting position.  Then, we can\n        // iterate through\
    \ the cars in order and count the number of collisions.\n        // The number\
    \ of collisions is equal to the number of cars that are moving\n        // in\
    \ the opposite direction.\n        // The number of cars moving in the opposite\
    \ direction is equal to the number\n        // of cars that are moving in the\
    \ same direction and have a smaller starting\n        // position.\n        //\
    \ The number of cars moving in the same direction and have a smaller starting\n\
    \        // position is equal to the number of cars that are moving in the same\
    \ direction\n        // and have a smaller starting position.\n        // The\
    \ number of cars moving in the same direction and have a smaller starting\n  \
    \      // position is equal to the number of cars that are moving in the same\
    \ direction\n        // and have a smaller starting position.\n        // The\
    \ number of cars moving in the same direction and have a smaller starting\n  \
    \      // position is equal to the number of cars that are moving in the same\
    \ direction\n        // and have a smaller starting position.\n        // The\
    \ number of cars moving in the same direction and have a smaller starting\n  \
    \      // position is equal to the number of cars that are moving in the same\
    \ direction\n        // and have a smaller starting position.\n        // The\
    \ number of cars moving in the same direction and have a smaller starting\n  \
    \      // position is equal to the number of cars that are moving in the same\
    \ direction\n        // and have a smaller starting position.\n        // The\
    \ number of cars moving in the same direction and have a smaller starting\n  \
    \      // position is equal to the number of cars that are moving in the same\
    \ direction\n        // and have a smaller starting position.\n        // The\
    \ number of cars moving in the same direction and have a smaller starting\n  \
    \      // position is equal to the number of cars that are moving in the same\
    \ direction\n        // and have a smaller starting position.\n        // The\
    \ number of cars moving in the same direction and have a smaller starting\n  \
    \      // position is equal to the number of cars that are moving in the same\
    \ direction\n        // and have a smaller starting position.\n        // The\
    \ number of cars moving in the same direction and have a smaller starting\n  \
    \      // position is equal to the number of cars that are moving in the same\
    \ direction\n        // and have a smaller starting position.\n        // The\
    \ number of\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp86q1m44j.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// The idea is to sort the cars by their starting position.  Then, we can\e\
    [0m\n\e[31m14 |\e[0m        \e[34m// iterate through the cars in order and count\
    \ the number of collisions.\e[0m\n\e[31m15 |\e[0m        \e[34m// The number of\
    \ collisions is equal to the number of cars that are moving\e[0m\n\e[31m16 |\e\
    [0m        \e[34m// in the opposite direction.\e[0m\n\e[31m17 |\e[0m        \e\
    [34m// The number of cars moving in the opposite direction is equal to the number\e\
    [0m\n\e[31m18 |\e[0m        \e[34m// of cars that are moving in the same direction\
    \ and have a smaller starting\e[0m\n\e[31m19 |\e[0m        \e[34m// position.\e\
    [0m\n\e[31m20 |\e[0m        \e[34m// The number of cars moving in the same direction\
    \ and have a smaller starting\e[0m\n\e[31m21 |\e[0m        \e[34m// position is\
    \ equal to the number of cars that are moving in the same direction\e[0m\n\e[31m22\
    \ |\e[0m        \e[34m// and have a smaller starting position.\e[0m\n\e[31m23\
    \ |\e[0m        \e[34m// The number of cars moving in the same direction and have\
    \ a smaller starting\e[0m\n\e[31m24 |\e[0m        \e[34m// position is equal to\
    \ the number of cars that are moving in the same direction\e[0m\n\e[31m25 |\e\
    [0m        \e[34m// and have a smaller starting position.\e[0m\n\e[31m26 |\e[0m\
    \        \e[34m// The number of cars moving in the same direction and have a smaller\
    \ starting\e[0m\n\e[31m27 |\e[0m        \e[34m// position is equal to the number\
    \ of cars that are moving in the same direction\e[0m\n\e[31m28 |\e[0m        \e\
    [34m// and have a smaller starting position.\e[0m\n\e[31m29 |\e[0m        \e[34m//\
    \ The number of cars moving in the same direction and have a smaller starting\e\
    [0m\n\e[31m30 |\e[0m        "
  stdout: ''
  timestamp: 1659792735
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting positions.\n        // Then, we can just count the\
    \ number of cars that are moving left to right\n        // and are to the left\
    \ of a car that's moving right to left.\n        // This is because two cars are\
    \ going to collide if and only if\n        // a car that's moving left to right\
    \ is to the left of a car that's moving right to left.\n        // The reason\
    \ is that if a car that's moving left to right is to the left of a car that's\
    \ moving right to left,\n        // then the car that's moving left to right will\
    \ eventually hit the car that's moving right to left.\n        // On the other\
    \ hand, if a car that's moving left to right is to the right of a car that's moving\
    \ right to left,\n        // then the car that's moving left to right will never\
    \ hit the car that's moving right to left.\n        // This is because the car\
    \ that's moving left to right will never catch up to the car that's moving right\
    \ to left.\n        // This is because the car that's moving left to right is\
    \ to the right of the car that's moving right to left.\n        // Therefore,\
    \ the car that's moving left to right will never hit the car that's moving right\
    \ to left.\n        // Therefore, the car that's moving left to right will never\
    \ collide with the car that's moving right to left.\n        // Therefore, the\
    \ car that's moving left to right will never collide with any car.\n        //\
    \ Therefore, the car that's moving left to right will never collide with any car.\n\
    \        // Therefore, the car that's moving left to right will never collide\
    \ with any car.\n        // Therefore, the car that's moving left to right will\
    \ never collide with any car.\n        // Therefore, the car that's moving left\
    \ to right will never collide with any car.\n        // Therefore, the car that's\
    \ moving left to right will never collide with any car.\n        // Therefore,\
    \ the car that's moving left to right will never collide with any car.\n     \
    \   // Therefore, the car that's moving left to right will never collide with\
    \ any car.\n        // Therefore, the car that's moving left to right will never\
    \ collide with any car.\n        // Therefore, the car that's moving left to right\
    \ will never collide with any car.\n        //\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpx7m0i86r.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// The idea is to sort the cars by their starting positions.\e[0m\n\e[31m14\
    \ |\e[0m        \e[34m// Then, we can just count the number of cars that are moving\
    \ left to right\e[0m\n\e[31m15 |\e[0m        \e[34m// and are to the left of a\
    \ car that's moving right to left.\e[0m\n\e[31m16 |\e[0m        \e[34m// This\
    \ is because two cars are going to collide if and only if\e[0m\n\e[31m17 |\e[0m\
    \        \e[34m// a car that's moving left to right is to the left of a car that's\
    \ moving right to left.\e[0m\n\e[31m18 |\e[0m        \e[34m// The reason is that\
    \ if a car that's moving left to right is to the left of a car that's moving right\
    \ to left,\e[0m\n\e[31m19 |\e[0m        \e[34m// then the car that's moving left\
    \ to right will eventually hit the car that's moving right to left.\e[0m\n\e[31m20\
    \ |\e[0m        \e[34m// On the other hand, if a car that's moving left to right\
    \ is to the right of a car that's moving right to left,\e[0m\n\e[31m21 |\e[0m\
    \        \e[34m// then the car that's moving left to right will never hit the\
    \ car that's moving right to left.\e[0m\n\e[31m22 |\e[0m        \e[34m// This\
    \ is because the car that's moving left to right will never catch up to the car\
    \ that's moving right to left.\e[0m\n\e[31m23 |\e[0m        \e[34m// This is because\
    \ the car that's moving left to right is to the right of the car that's moving\
    \ right to left.\e[0m\n\e[31m24 |\e[0m        \e[34m// Therefore, the car that's\
    \ moving left to right will never hit the car that's moving right to left.\e[0m\n\
    \e[31m25 |\e[0m        \e[34m// Therefore, the car that's moving left to right\
    \ will never collide with the car that's moving right to left.\e[0m\n\e[31m26\
    \ |\e[0m        \e[34m// T"
  stdout: ''
  timestamp: 1659792735
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is a very simple\
    \ problem.  The cars that are moving left to right\n        // are numbered from\
    \ 1 to n.  The cars that are moving right to left are\n        // numbered from\
    \ n+1 to 2n.  The cars that are moving left to right\n        // will collide\
    \ with the cars that are moving right to left if and only if\n        // they\
    \ have the same number.  So the answer is n.\n        n\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjaeye_0k.scala:21)\n\tat Problem.main(tmpjaeye_0k.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792735
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting position.\n        // Then, we can use a sweep line\
    \ algorithm to count the number of collisions.\n        // The sweep line algorithm\
    \ is as follows:\n        // 1.  We start with the leftmost car.\n        // 2.\
    \  We move the sweep line to the right until we hit the next car.\n        //\
    \ 3.  We count the number of cars that are moving right to left that are\n   \
    \     //     to the left of the sweep line.  These cars will collide with the\
    \ car\n        //     that the sweep line is currently at.\n        // 4.  We\
    \ repeat steps 2 and 3 until we reach the rightmost car.\n        // 5.  We return\
    \ the total number of collisions.\n        // The time complexity is O(n log n)\
    \ because we need to sort the cars.\n        // The space complexity is O(n) because\
    \ we need to store the cars.\n        val cars = new Array[(Long, Boolean)](2\
    \ * n.toInt)\n        for (i <- 0 until n.toInt) {\n            cars(i) = (i.toLong,\
    \ true)\n            cars(i + n.toInt) = (i.toLong, false)\n        }\n      \
    \  cars.sortWith((a, b) => a._1 < b._1)\n        var collisions = 0L\n       \
    \ var leftCars = 0\n        for (i <- 0 until cars.length) {\n            if (cars(i)._2)\
    \ {\n                collisions += leftCars\n            } else {\n          \
    \      leftCars += 1\n            }\n        }\n        collisions\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n\
    \    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpvkcha0r2.scala:43)\n\tat Problem.main(tmpvkcha0r2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792739
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting positions.\n        // Then, we can just iterate\
    \ through the cars and count the number of collisions.\n        // The number\
    \ of collisions is the number of cars that are moving left to right\n        //\
    \ that are to the left of the car that's moving right to left.\n        // We\
    \ can do this in O(n log n) time.\n        val cars = new Array[(Long, Boolean)](2\
    \ * n.toInt)\n        for (i <- 0 until n.toInt) {\n            cars(i) = (i,\
    \ true)\n            cars(i + n.toInt) = (i, false)\n        }\n        val sortedCars\
    \ = cars.sortWith((a, b) => (a._1 < b._1) || (a._1 == b._1 && a._2 && !b._2))\n\
    \        var collisions = 0L\n        var currentCar = 0\n        while (currentCar\
    \ < 2 * n.toInt) {\n            if (!sortedCars(currentCar)._2) {\n          \
    \      collisions += currentCar\n            }\n            currentCar += 1\n\
    \        }\n        collisions\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659792739
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is a very simple\
    \ problem.  The key is to realize that if two cars\n        // collide, then the\
    \ car that's moving left to right must be the ith car (for some i),\n        //\
    \ and the car that's moving right to left must be the jth car (for some j).\n\
    \        // The reason is that the ith car is the first car that's moving left\
    \ to right,\n        // and the jth car is the first car that's moving right to\
    \ left.\n        // So, we can just iterate over all i and j, and count the number\
    \ of collisions.\n        // This is O(n^2).\n        var count = 0L\n       \
    \ for (i <- 1 to n.toInt) {\n            for (j <- 1 to n.toInt) {\n         \
    \       if (i < j) count += 1\n            }\n        }\n        count\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n\
    \    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmple_x6jg1.scala:29)\n\tat Problem.main(tmple_x6jg1.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792739
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The cars are numbered\
    \ from 1 to n.  The cars that are moving left to right\n        // are numbered\
    \ from 1 to n, and the cars that are moving right to left are\n        // numbered\
    \ from n to 1.  The cars are initially positioned as follows:\n        // Car\
    \ 1 is at position 1, car 2 is at position 2, ..., car n is at position n.\n \
    \       // Car n is at position n + 1, car n - 1 is at position n + 2, ..., car\
    \ 1 is at position 2n.\n        // The cars move at the same speed.  Car 1 moves\
    \ 1 unit per second, car 2 moves 2 units per second,\n        // ..., car n moves\
    \ n units per second.  Car n moves n units per second, car n - 1 moves n - 1 units\n\
    \        // per second, ..., car 1 moves 1 unit per second.\n        // The cars\
    \ are infinitely sturdy and strong; as a result, they continue moving\n      \
    \  // in their trajectory as if they did not collide.\n        // This function\
    \ outputs the number of such collisions.\n        //\n        // The cars that\
    \ are moving left to right are numbered from 1 to n, and the cars that are moving\
    \ right to left are\n        // numbered from n to 1.  The cars are initially\
    \ positioned as follows:\n        // Car 1 is at position 1, car 2 is at position\
    \ 2, ..., car n is at position n.\n        // Car n is at position n + 1, car\
    \ n - 1 is at position n + 2, ..., car 1 is at position 2n.\n        // The cars\
    \ move at the same speed.  Car 1 moves 1 unit per second, car 2 moves 2 units\
    \ per second,\n        // ..., car n moves n units per second.  Car n moves n\
    \ units per second, car n - 1 moves n - 1 units\n        // per second, ..., car\
    \ 1 moves 1 unit per second.\n        // The cars are infinitely sturdy and strong;\
    \ as a result, they continue moving\n        // in their trajectory as if they\
    \ did not collide.\n        // This function outputs the number of such collisions.\n\
    \        //\n        // The cars that are moving left to right are numbered from\
    \ 1 to n, and the cars that are moving right to left are\n        // numbered\
    \ from n to 1.  The cars are initially positioned as follows:\n\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n\
    \    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpapu5i3t3.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// The cars are numbered from 1 to n.  The cars that are moving left to right\e\
    [0m\n\e[31m14 |\e[0m        \e[34m// are numbered from 1 to n, and the cars that\
    \ are moving right to left are\e[0m\n\e[31m15 |\e[0m        \e[34m// numbered\
    \ from n to 1.  The cars are initially positioned as follows:\e[0m\n\e[31m16 |\e\
    [0m        \e[34m// Car 1 is at position 1, car 2 is at position 2, ..., car n\
    \ is at position n.\e[0m\n\e[31m17 |\e[0m        \e[34m// Car n is at position\
    \ n + 1, car n - 1 is at position n + 2, ..., car 1 is at position 2n.\e[0m\n\e\
    [31m18 |\e[0m        \e[34m// The cars move at the same speed.  Car 1 moves 1\
    \ unit per second, car 2 moves 2 units per second,\e[0m\n\e[31m19 |\e[0m     \
    \   \e[34m// ..., car n moves n units per second.  Car n moves n units per second,\
    \ car n - 1 moves n - 1 units\e[0m\n\e[31m20 |\e[0m        \e[34m// per second,\
    \ ..., car 1 moves 1 unit per second.\e[0m\n\e[31m21 |\e[0m        \e[34m// The\
    \ cars are infinitely sturdy and strong; as a result, they continue moving\e[0m\n\
    \e[31m22 |\e[0m        \e[34m// in their trajectory as if they did not collide.\e\
    [0m\n\e[31m23 |\e[0m        \e[34m// This function outputs the number of such\
    \ collisions.\e[0m\n\e[31m24 |\e[0m        \e[34m//\e[0m\n\e[31m25 |\e[0m    \
    \    \e[34m// The cars that are moving left to right are numbered from 1 to n,\
    \ and the cars that are moving right to left are\e[0m\n\e[31m26 |\e[0m       \
    \ \e[34m// numbered from n to 1.  The cars are initially positioned as follows:\e\
    [0m\n\e[31m27 |\e[0m        \e[34m// Car 1 is at position 1, car 2 is at position\
    \ 2, ..., car n is at position n.\e[0m\n\e[31m28 |\e[0m        \e[34m// Car n\
    \ is at position n + 1, car n - 1 is at po"
  stdout: ''
  timestamp: 1659792737
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This function returns\
    \ the number of collisions between the cars that are moving\n        // left to\
    \ right and the cars that are moving right to left.\n        // The cars are numbered\
    \ from 0 to n - 1.\n        // The cars that are moving left to right are numbered\
    \ from 0 to n - 1.\n        // The cars that are moving right to left are numbered\
    \ from n - 1 to 0.\n        // The cars that are moving left to right are at positions\
    \ x0, x1, ..., x(n - 1).\n        // The cars that are moving right to left are\
    \ at positions y0, y1, ..., y(n - 1).\n        // The cars that are moving left\
    \ to right are moving at speeds v0, v1, ..., v(n - 1).\n        // The cars that\
    \ are moving right to left are moving at speeds w0, w1, ..., w(n - 1).\n     \
    \   // The cars that are moving left to right are moving at speeds 1, 2, ...,\
    \ n.\n        // The cars that are moving right to left are moving at speeds n,\
    \ n - 1, ..., 1.\n        // The cars that are moving left to right are at positions\
    \ 0, 1, ..., n - 1.\n        // The cars that are moving right to left are at\
    \ positions n - 1, n - 2, ..., 0.\n        // The cars that are moving left to\
    \ right are at positions 0, 1, ..., n - 1.\n        // The cars that are moving\
    \ right to left are at positions n - 1, n - 2, ..., 0.\n        // The cars that\
    \ are moving left to right are at positions 0, 1, ..., n - 1.\n        // The\
    \ cars that are moving right to left are at positions n - 1, n - 2, ..., 0.\n\
    \        // The cars that are moving left to right are at positions 0, 1, ...,\
    \ n - 1.\n        // The cars that are moving right to left are at positions n\
    \ - 1, n - 2, ..., 0.\n        // The cars that are moving left to right are at\
    \ positions 0, 1, ..., n - 1.\n        // The cars that are moving right to left\
    \ are at positions n - 1, n - 2, ..., 0.\n        // The cars that are moving\
    \ left to right are at positions\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3nmdb8_y.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// This function returns the number of collisions between the cars that are\
    \ moving\e[0m\n\e[31m14 |\e[0m        \e[34m// left to right and the cars that\
    \ are moving right to left.\e[0m\n\e[31m15 |\e[0m        \e[34m// The cars are\
    \ numbered from 0 to n - 1.\e[0m\n\e[31m16 |\e[0m        \e[34m// The cars that\
    \ are moving left to right are numbered from 0 to n - 1.\e[0m\n\e[31m17 |\e[0m\
    \        \e[34m// The cars that are moving right to left are numbered from n -\
    \ 1 to 0.\e[0m\n\e[31m18 |\e[0m        \e[34m// The cars that are moving left\
    \ to right are at positions x0, x1, ..., x(n - 1).\e[0m\n\e[31m19 |\e[0m     \
    \   \e[34m// The cars that are moving right to left are at positions y0, y1, ...,\
    \ y(n - 1).\e[0m\n\e[31m20 |\e[0m        \e[34m// The cars that are moving left\
    \ to right are moving at speeds v0, v1, ..., v(n - 1).\e[0m\n\e[31m21 |\e[0m \
    \       \e[34m// The cars that are moving right to left are moving at speeds w0,\
    \ w1, ..., w(n - 1).\e[0m\n\e[31m22 |\e[0m        \e[34m// The cars that are moving\
    \ left to right are moving at speeds 1, 2, ..., n.\e[0m\n\e[31m23 |\e[0m     \
    \   \e[34m// The cars that are moving right to left are moving at speeds n, n\
    \ - 1, ..., 1.\e[0m\n\e[31m24 |\e[0m        \e[34m// The cars that are moving\
    \ left to right are at positions 0, 1, ..., n - 1.\e[0m\n\e[31m25 |\e[0m     \
    \   \e[34m// The cars that are moving right to left are at positions n - 1, n\
    \ - 2, ..., 0.\e[0m\n\e[31m26 |\e[0m        \e[34m// The cars that are moving\
    \ left to right are at positions 0, 1, ..., n - 1.\e[0m\n\e[31m27 |\e[0m     \
    \   \e[34m// The cars that are moving right to left are at positions n - 1, n\
    \ - 2, ..., 0.\e[0m\n\e[31m28 |\e[0m        \e[34m// The cars that "
  stdout: ''
  timestamp: 1659792737
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This function returns\
    \ the number of collisions for the first i cars\n        // moving left to right\
    \ and the first j cars moving right to left.\n        def f(i : Long, j : Long)\
    \ : Long = {\n            if (i == 0 || j == 0) 0\n            else if (i == j)\
    \ i * (i - 1) / 2\n            else if (i < j) f(i, i) + f(i, j - i)\n       \
    \     else f(j, j) + f(i - j, j)\n        }\n        f(n, n)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5xoz_kbu.scala:24)\n\tat Problem.main(tmp5xoz_kbu.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792738
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is a very simple\
    \ problem.  We can just simulate the cars moving.\n        // We can do this in\
    \ O(n^2) time.\n        // However, we can do better.  We can do this in O(n log\
    \ n) time.\n        // We can do this by sorting the cars by their starting position.\n\
    \        // Then, we can just iterate through the cars, and for each car,\n  \
    \      // we can find the number of cars that are going to collide with it.\n\
    \        // This can be done in O(log n) time using binary search.\n        //\
    \ Then, we can just sum up the number of collisions.\n        // This is O(n log\
    \ n) time.\n        // We can do even better.  We can do this in O(n) time.\n\
    \        // We can do this by using a stack.\n        // We can iterate through\
    \ the cars, and for each car, we can\n        // push it onto the stack.  If the\
    \ top car on the stack is going\n        // to collide with the current car, then\
    \ we can pop the top car\n        // off the stack.  We can continue doing this\
    \ until we find a car\n        // that is not going to collide with the current\
    \ car.\n        // Then, we can push the current car onto the stack.\n       \
    \ // This is O(n) time.\n        val cars = Array.fill(n.toInt)((0, 0))\n    \
    \    for (i <- 0 until n.toInt) {\n            val Array(x, v) = readLine.split(\"\
    \ \").map(_.toInt)\n            cars(i) = (x, v)\n        }\n        val cars1\
    \ = cars.sortBy(_._1)\n        val cars2 = cars.sortBy(_._1).reverse\n       \
    \ val stack = new Stack[(Int, Int)]\n        var collisions = 0L\n        for\
    \ (i <- 0 until n.toInt) {\n            while (stack.nonEmpty && stack.top._1\
    \ > cars2(i)._1) {\n                stack.pop\n            }\n            stack.push(cars2(i))\n\
    \            collisions += stack.size - 1\n        }\n        collisions\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5lkwbxmi.scala:33:30 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m            \e[33mval\e[0m Array(x, v) = readLine.split(\e\
    [31m\" \"\e[0m).map(_.toInt)\n\e[31m\e[31m   |\e[0m                          \
    \    ^^^^^^^^\e[0m\n\e[31m   |\e[0m                              Not found: readLine\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp5lkwbxmi.scala:33:22\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m            \e[33mval\e\
    [0m Array(x, v) = readLine.split(\e[31m\" \"\e[0m).map(_.toInt)\n\e[31m\e[31m\
    \   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m                      Recursive\
    \ \e[33mvalue\e[0m \e[35m$1$\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E045] Cyclic Error: /tmp/tmp5lkwbxmi.scala:33:25 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m            \e[33mval\e[0m Array(x, v) = readLine.split(\e\
    [31m\" \"\e[0m).map(_.toInt)\n\e[31m\e[31m   |\e[0m                         ^\e\
    [0m\n\e[31m   |\e[0m                         Recursive \e[33mvalue\e[0m \e[35m$1$\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659792737
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The cars are numbered\
    \ from 1 to n.\n        // The cars moving left to right are numbered from 1 to\
    \ n.\n        // The cars moving right to left are numbered from n to 1.\n   \
    \     // The cars moving left to right are at positions x1, x2, ..., xn.\n   \
    \     // The cars moving right to left are at positions y1, y2, ..., yn.\n   \
    \     // The cars moving left to right are at positions x1, x2, ..., xn.\n   \
    \     // The cars moving right to left are at positions y1, y2, ..., yn.\n   \
    \     // The cars moving left to right are at positions x1, x2, ..., xn.\n   \
    \     // The cars moving right to left are at positions y1, y2, ..., yn.\n   \
    \     // The cars moving left to right are at positions x1, x2, ..., xn.\n   \
    \     // The cars moving right to left are at positions y1, y2, ..., yn.\n   \
    \     // The cars moving left to right are at positions x1, x2, ..., xn.\n   \
    \     // The cars moving right to left are at positions y1, y2, ..., yn.\n   \
    \     // The cars moving left to right are at positions x1, x2, ..., xn.\n   \
    \     // The cars moving right to left are at positions y1, y2, ..., yn.\n   \
    \     // The cars moving left to right are at positions x1, x2, ..., xn.\n   \
    \     // The cars moving right to left are at positions y1, y2, ..., yn.\n   \
    \     // The cars moving left to right are at positions x1, x2, ..., xn.\n   \
    \     // The cars moving right to left are at positions y1, y2, ..., yn.\n   \
    \     // The cars moving left to right are at positions x1, x2, ..., xn.\n   \
    \     // The cars moving right to left are at positions y1, y2, ..., yn.\n   \
    \     // The cars moving left to right are at positions x1, x2, ..., xn.\n   \
    \     // The cars moving right to left are at positions y1, y2, ..., yn.\n   \
    \     // The cars moving left to\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpin9sq8g4.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// The cars are numbered from 1 to n.\e[0m\n\e[31m14 |\e[0m        \e[34m//\
    \ The cars moving left to right are numbered from 1 to n.\e[0m\n\e[31m15 |\e[0m\
    \        \e[34m// The cars moving right to left are numbered from n to 1.\e[0m\n\
    \e[31m16 |\e[0m        \e[34m// The cars moving left to right are at positions\
    \ x1, x2, ..., xn.\e[0m\n\e[31m17 |\e[0m        \e[34m// The cars moving right\
    \ to left are at positions y1, y2, ..., yn.\e[0m\n\e[31m18 |\e[0m        \e[34m//\
    \ The cars moving left to right are at positions x1, x2, ..., xn.\e[0m\n\e[31m19\
    \ |\e[0m        \e[34m// The cars moving right to left are at positions y1, y2,\
    \ ..., yn.\e[0m\n\e[31m20 |\e[0m        \e[34m// The cars moving left to right\
    \ are at positions x1, x2, ..., xn.\e[0m\n\e[31m21 |\e[0m        \e[34m// The\
    \ cars moving right to left are at positions y1, y2, ..., yn.\e[0m\n\e[31m22 |\e\
    [0m        \e[34m// The cars moving left to right are at positions x1, x2, ...,\
    \ xn.\e[0m\n\e[31m23 |\e[0m        \e[34m// The cars moving right to left are\
    \ at positions y1, y2, ..., yn.\e[0m\n\e[31m24 |\e[0m        \e[34m// The cars\
    \ moving left to right are at positions x1, x2, ..., xn.\e[0m\n\e[31m25 |\e[0m\
    \        \e[34m// The cars moving right to left are at positions y1, y2, ...,\
    \ yn.\e[0m\n\e[31m26 |\e[0m        \e[34m// The cars moving left to right are\
    \ at positions x1, x2, ..., xn.\e[0m\n\e[31m27 |\e[0m        \e[34m// The cars\
    \ moving right to left are at positions y1, y2, ..., yn.\e[0m\n\e[31m28 |\e[0m\
    \        \e[34m// The cars moving left to right are at positions x1, x2, ...,\
    \ xn.\e[0m\n\e[31m29 |\e[0m        \e[34m// The cars moving right to left are\
    \ at positions y1, y2, ..., yn.\e[0m\n\e[31m30 |\e[0m        \e[34m// "
  stdout: ''
  timestamp: 1659792738
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting position.\n        // Then, we can simulate the race\
    \ by moving the cars one by one.\n        // If a car moves to the same position\
    \ as another car, then there's a collision.\n        // We can use a hash map\
    \ to keep track of the number of cars at each position.\n        // The hash map\
    \ is initialized to 0 for all positions.\n        // When a car moves, we increment\
    \ the number of cars at that position.\n        // When a car moves to a position\
    \ where there's already a car, we increment the collision count.\n        // We\
    \ also decrement the number of cars at that position.\n        // If the number\
    \ of cars at that position becomes 0, then we remove that position from the hash\
    \ map.\n        // The time complexity is O(n log n) because we sort the cars.\n\
    \        // The space complexity is O(n) because we store the cars in a hash map.\n\
    \        // We can reduce the space complexity to O(1) by using a bit vector instead\
    \ of a hash map.\n        // The bit vector is initialized to 0 for all positions.\n\
    \        // When a car moves, we set the bit at that position to 1.\n        //\
    \ When a car moves to a position where there's already a car, we increment the\
    \ collision count.\n        // We also set the bit at that position to 0.\n  \
    \      // If the bit at that position becomes 0, then we don't have to do anything.\n\
    \        // The time complexity is O(n log n) because we sort the cars.\n    \
    \    // The space complexity is O(1) because we store the cars in a bit vector.\n\
    \        val cars = Array.fill(n.toInt)(0)\n        for (i <- 0 until n.toInt)\
    \ cars(i) = i\n        val leftToRight = cars.map(x => (x, true))\n        val\
    \ rightToLeft = cars.map(x => (x, false))\n        val sortedCars = (leftToRight\
    \ ++ rightToLeft).sortBy(x => x._1)\n        var collisionCount = 0\n        val\
    \ bitVector = new BitVector(n.toInt)\n        for (car <- sortedCars) {\n    \
    \        if (car._2) {\n                if (bitVector(car._1\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpegfxe7ci.scala:42:4 ----------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpegfxe7ci.scala:52:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m52 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmpegfxe7ci.scala:38:28 ------------------------\e[0m\e[0m\n\
    \e[31m38 |\e[0m        \e[33mval\e[0m \e[36mbitVector\e[0m = \e[33mnew\e[0m \e\
    [35mBitVector\e[0m(n.toInt)\n\e[31m\e[31m   |\e[0m                           \
    \ ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                            Not found: type BitVector\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[33m\e[33m-- Warning: /tmp/tmpegfxe7ci.scala:43:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m43 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n3 errors found\n"
  stdout: ''
  timestamp: 1659792739
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is a very simple\
    \ problem.  The cars are moving in the same speed;\n        // as a result, the\
    \ cars that are closest to each other will collide first.\n        // The cars\
    \ that are closest to each other are the ones that are in the middle.\n      \
    \  // The number of cars in the middle is n - 1.\n        n - 1\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n\
    \    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpq19bym1h.scala:20)\n\tat Problem.main(tmpq19bym1h.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792740
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting positions.\n        // Then, we can just count the\
    \ number of cars that are moving in the same direction\n        // and are starting\
    \ at the same position.\n        val cars = Array.fill(2 * n.toInt)(0)\n     \
    \   for (i <- 0 until n.toInt) {\n            cars(i) = i + 1\n            cars(i\
    \ + n.toInt) = -(i + 1)\n        }\n        cars.sorted.sliding(2).filter(x =>\
    \ x(0) > 0 && x(1) > 0 || x(0) < 0 && x(1) < 0).size\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpumubhkcp.scala:24)\n\tat Problem.main(tmpumubhkcp.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792743
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is a very simple\
    \ problem.  The cars that are moving left to right\n        // are numbered from\
    \ 1 to n.  The cars that are moving right to left are\n        // numbered from\
    \ n+1 to 2n.  The cars that are moving left to right\n        // will collide\
    \ with the cars that are moving right to left if and only if\n        // the numbers\
    \ of the two cars are the same.  Therefore, the number of collisions\n       \
    \ // is the number of pairs of cars that have the same number.  This is the same\n\
    \        // as the number of pairs of numbers that are the same.  This is the\
    \ same as\n        // the number of pairs of numbers that are the same.  This\
    \ is the same as\n        // the number of pairs of numbers that are the same.\
    \  This is the same as\n        // the number of pairs of numbers that are the\
    \ same.  This is the same as\n        // the number of pairs of numbers that are\
    \ the same.  This is the same as\n        // the number of pairs of numbers that\
    \ are the same.  This is the same as\n        // the number of pairs of numbers\
    \ that are the same.  This is the same as\n        // the number of pairs of numbers\
    \ that are the same.  This is the same as\n        // the number of pairs of numbers\
    \ that are the same.  This is the same as\n        // the number of pairs of numbers\
    \ that are the same.  This is the same as\n        // the number of pairs of numbers\
    \ that are the same.  This is the same as\n        // the number of pairs of numbers\
    \ that are the same.  This is the same as\n        // the number of pairs of numbers\
    \ that are the same.  This is the same as\n        // the number of pairs of numbers\
    \ that are the same.  This is the same as\n        // the number of pairs of numbers\
    \ that are the same.  This is the same as\n        // the number of pairs of numbers\
    \ that are the same.  This is the same as\n        // the number of pairs of numbers\
    \ that are the same.  This is the same as\n        // the number of pairs of numbers\
    \ that are the same.  This is the same as\n        // the number of pairs of numbers\
    \ that are the same.  This is the same as\n        // the number of pairs of numbers\
    \ that are the\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpho6piney.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// This is a very simple problem.  The cars that are moving left to right\e\
    [0m\n\e[31m14 |\e[0m        \e[34m// are numbered from 1 to n.  The cars that\
    \ are moving right to left are\e[0m\n\e[31m15 |\e[0m        \e[34m// numbered\
    \ from n+1 to 2n.  The cars that are moving left to right\e[0m\n\e[31m16 |\e[0m\
    \        \e[34m// will collide with the cars that are moving right to left if\
    \ and only if\e[0m\n\e[31m17 |\e[0m        \e[34m// the numbers of the two cars\
    \ are the same.  Therefore, the number of collisions\e[0m\n\e[31m18 |\e[0m   \
    \     \e[34m// is the number of pairs of cars that have the same number.  This\
    \ is the same\e[0m\n\e[31m19 |\e[0m        \e[34m// as the number of pairs of\
    \ numbers that are the same.  This is the same as\e[0m\n\e[31m20 |\e[0m      \
    \  \e[34m// the number of pairs of numbers that are the same.  This is the same\
    \ as\e[0m\n\e[31m21 |\e[0m        \e[34m// the number of pairs of numbers that\
    \ are the same.  This is the same as\e[0m\n\e[31m22 |\e[0m        \e[34m// the\
    \ number of pairs of numbers that are the same.  This is the same as\e[0m\n\e\
    [31m23 |\e[0m        \e[34m// the number of pairs of numbers that are the same.\
    \  This is the same as\e[0m\n\e[31m24 |\e[0m        \e[34m// the number of pairs\
    \ of numbers that are the same.  This is the same as\e[0m\n\e[31m25 |\e[0m   \
    \     \e[34m// the number of pairs of numbers that are the same.  This is the\
    \ same as\e[0m\n\e[31m26 |\e[0m        \e[34m// the number of pairs of numbers\
    \ that are the same.  This is the same as\e[0m\n\e[31m27 |\e[0m        \e[34m//\
    \ the number of pairs of numbers that are the same.  This is the same as\e[0m\n\
    \e[31m28 |\e[0m        \e[34m// the number of pairs of numbers tha"
  stdout: ''
  timestamp: 1659792740
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting positions.\n        // If a car starts at position\
    \ x, then it will collide with the car\n        // that starts at position -x.\
    \  So, we can just count the number of\n        // pairs of cars that start at\
    \ positions x and -x.\n        val cars = Array.fill(n.toInt)(readLong)\n    \
    \    val carsPositive = cars.filter(_ > 0)\n        val carsNegative = cars.filter(_\
    \ < 0).map(-_)\n        val carsPositiveSorted = carsPositive.sorted\n       \
    \ val carsNegativeSorted = carsNegative.sorted\n        var collisions = 0L\n\
    \        var i = 0\n        var j = 0\n        while (i < carsPositiveSorted.length\
    \ && j < carsNegativeSorted.length) {\n            if (carsPositiveSorted(i) ==\
    \ carsNegativeSorted(j)) {\n                collisions += 1\n                i\
    \ += 1\n                j += 1\n            } else if (carsPositiveSorted(i) <\
    \ carsNegativeSorted(j)) {\n                i += 1\n            } else {\n   \
    \             j += 1\n            }\n        }\n        collisions\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n\
    \    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp807r2lsj.scala:17:39 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mcars\e[0m = Array.fill(n.toInt)(readLong)\n\
    \e[31m\e[31m   |\e[0m                                       ^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                                       Not found: readLong\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- Error: /tmp/tmp807r2lsj.scala:17:48 -----------------------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mcars\e[0m = Array.fill(n.toInt)(readLong)\n\
    \e[31m\e[31m   |\e[0m                                                ^\e[0m\n\e\
    [31m   |\e[0m                                          No ClassTag available for\
    \ T\n\e[31m   |\e[0m\n\e[31m   |\e[0m                                        \
    \  where:    T is a type variable\n2 errors found\n"
  stdout: ''
  timestamp: 1659792742
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is the number\
    \ of collisions.\n        var collisions = 0L\n        // This is the number of\
    \ cars that have moved left to right.\n        var movedRight = 0L\n        //\
    \ This is the number of cars that have moved right to left.\n        var movedLeft\
    \ = 0L\n        // This is the number of cars that are currently moving left to\
    \ right.\n        var movingRight = n\n        // This is the number of cars that\
    \ are currently moving right to left.\n        var movingLeft = n\n        //\
    \ This is the number of cars that are currently moving left to right and have\
    \ not yet collided.\n        var movingRightUncollided = n\n        // This is\
    \ the number of cars that are currently moving right to left and have not yet\
    \ collided.\n        var movingLeftUncollided = n\n        // This is the number\
    \ of cars that are currently moving left to right and have collided.\n       \
    \ var movingRightCollided = 0L\n        // This is the number of cars that are\
    \ currently moving right to left and have collided.\n        var movingLeftCollided\
    \ = 0L\n        // This is the number of cars that are currently moving left to\
    \ right and have collided and have not yet moved.\n        var movingRightCollidedStopped\
    \ = 0L\n        // This is the number of cars that are currently moving right\
    \ to left and have collided and have not yet moved.\n        var movingLeftCollidedStopped\
    \ = 0L\n        // This is the number of cars that are currently moving left to\
    \ right and have collided and have moved.\n        var movingRightCollidedMoved\
    \ = 0L\n        // This is the number of cars that are currently moving right\
    \ to left and have collided and have moved.\n        var movingLeftCollidedMoved\
    \ = 0L\n        // This is the number of cars that are currently moving left to\
    \ right and have collided and have moved and have not yet collided.\n        var\
    \ movingRightCollidedMovedUncollided = 0L\n        // This is the number of cars\
    \ that are currently moving right to left and have collided and have moved and\
    \ have not yet collided.\n        var movingLeftCollidedMovedUncollided = 0L\n\
    \        // This is the number of cars that are currently moving left to right\
    \ and have collided and have moved and have collided.\n        var movingRightCollidedMovedCollided\
    \ = 0L\n        // This is\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l)) ==\
    \ (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpw74jbevo.scala:46:5\
    \ ---------------------\e[0m\e[0m\n\e[31m46 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659792741
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting positions.\n        // Then, we can use a sweep line\
    \ algorithm to find the number of collisions.\n        // The sweep line algorithm\
    \ is as follows:\n        // 1.  Sort the cars by their starting positions.\n\
    \        // 2.  Initialize a list of cars that are currently on the road.\n  \
    \      // 3.  For each car, if the car is moving left to right, add it to the\
    \ list.\n        //     If the car is moving right to left, remove it from the\
    \ list.\n        //     If the car is moving left to right, and there are cars\
    \ in the list,\n        //     then there is a collision.\n        // 4.  Return\
    \ the number of collisions.\n        // The time complexity is O(n log n).\n \
    \       // The space complexity is O(n).\n        val cars = Array.fill(2 * n.toInt)(0)\n\
    \        for (i <- 0 until n.toInt) {\n            cars(i) = i + 1\n         \
    \   cars(i + n.toInt) = -(i + 1)\n        }\n        val sortedCars = cars.sorted\n\
    \        var collisions = 0\n        val carsOnRoad = new ListBuffer[Int]\n  \
    \      for (car <- sortedCars) {\n            if (car > 0) {\n               \
    \ if (carsOnRoad.nonEmpty) collisions += 1\n                carsOnRoad += car\n\
    \            } else {\n                carsOnRoad -= (-car)\n            }\n \
    \       }\n        collisions\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpk0gucpjg.scala:44)\n\tat Problem.main(tmpk0gucpjg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792745
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is a very simple\
    \ problem.  We can solve it by brute force.\n        // We can imagine a coordinate\
    \ system where the leftmost car is at position 0,\n        // the rightmost car\
    \ is at position 2n, and the cars in between are spaced out\n        // evenly.\
    \  We can then simulate the movement of the cars.  If we find that\n        //\
    \ two cars are at the same position at the same time, then we have a collision.\n\
    \        // We can do this simulation in O(n^2) time.\n        // However, we\
    \ can do better.  We can solve this problem in O(n log n) time.\n        // The\
    \ idea is to use a sweep line algorithm.  We can imagine a vertical line\n   \
    \     // that moves from left to right.  As the line moves, we keep track of the\n\
    \        // number of cars that are to the left of the line.  We can do this by\n\
    \        // maintaining a set of cars that are to the left of the line.  We can\n\
    \        // maintain this set in O(log n) time per insertion and deletion.\n \
    \       // As the line moves, we can insert and delete cars from the set.  We\
    \ can\n        // also keep track of the number of cars that are to the right\
    \ of the line.\n        // We can do this by maintaining a set of cars that are\
    \ to the right of the line.\n        // We can maintain this set in O(log n) time\
    \ per insertion and deletion.\n        // When we insert a car into the set of\
    \ cars to the left of the line, we\n        // check whether the car is already\
    \ in the set of cars to the right of the line.\n        // If so, then we have\
    \ a collision.  We can do this in O(log n) time.\n        // When we insert a\
    \ car into the set of cars to the right of the line, we\n        // check whether\
    \ the car is already in the set of cars to the left of the line.\n        // If\
    \ so, then we have a collision.  We can do this in O(log n) time.\n        //\
    \ When we delete a car from the set of cars to the left of the line, we\n    \
    \    // check whether the car is already in the set of cars to the right of the\
    \ line.\n        // If so, then we have a\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpdj514bhj.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// This is a very simple problem.  We can solve it by brute force.\e[0m\n\e\
    [31m14 |\e[0m        \e[34m// We can imagine a coordinate system where the leftmost\
    \ car is at position 0,\e[0m\n\e[31m15 |\e[0m        \e[34m// the rightmost car\
    \ is at position 2n, and the cars in between are spaced out\e[0m\n\e[31m16 |\e\
    [0m        \e[34m// evenly.  We can then simulate the movement of the cars.  If\
    \ we find that\e[0m\n\e[31m17 |\e[0m        \e[34m// two cars are at the same\
    \ position at the same time, then we have a collision.\e[0m\n\e[31m18 |\e[0m \
    \       \e[34m// We can do this simulation in O(n^2) time.\e[0m\n\e[31m19 |\e\
    [0m        \e[34m// However, we can do better.  We can solve this problem in O(n\
    \ log n) time.\e[0m\n\e[31m20 |\e[0m        \e[34m// The idea is to use a sweep\
    \ line algorithm.  We can imagine a vertical line\e[0m\n\e[31m21 |\e[0m      \
    \  \e[34m// that moves from left to right.  As the line moves, we keep track of\
    \ the\e[0m\n\e[31m22 |\e[0m        \e[34m// number of cars that are to the left\
    \ of the line.  We can do this by\e[0m\n\e[31m23 |\e[0m        \e[34m// maintaining\
    \ a set of cars that are to the left of the line.  We can\e[0m\n\e[31m24 |\e[0m\
    \        \e[34m// maintain this set in O(log n) time per insertion and deletion.\e\
    [0m\n\e[31m25 |\e[0m        \e[34m// As the line moves, we can insert and delete\
    \ cars from the set.  We can\e[0m\n\e[31m26 |\e[0m        \e[34m// also keep track\
    \ of the number of cars that are to the right of the line.\e[0m\n\e[31m27 |\e\
    [0m        \e[34m// We can do this by maintaining a set of cars that are to the\
    \ right of the line.\e[0m\n\e[31m28 |\e[0m        \e[34m// We can maintain this\
    \ set in O(log n) time per insertion a"
  stdout: ''
  timestamp: 1659792741
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is a very simple\
    \ problem.  The cars are moving in the same speed, so\n        // the time it\
    \ takes for a car to reach the origin is the same for all cars.\n        // The\
    \ cars are moving in opposite directions, so the cars that are closest\n     \
    \   // to the origin will collide first.  The cars that are farthest from the\
    \ origin\n        // will collide last.  So, the answer is simply the number of\
    \ cars that are\n        // closest to the origin.\n        // The cars are numbered\
    \ from 1 to n.  The cars that are closest to the origin\n        // are the cars\
    \ that are closest to the number n/2.  If n is even, then the\n        // cars\
    \ that are closest to the origin are the cars that are closest to n/2.\n     \
    \   // If n is odd, then the cars that are closest to the origin are the cars\
    \ that\n        // are closest to (n-1)/2 and (n+1)/2.\n        if (n % 2 == 0)\
    \ n / 2 else n\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpk5warttf.scala:27)\n\tat Problem.main(tmpk5warttf.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792743
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting position.\n        // Then, we can just iterate through\
    \ the cars and count the number of collisions.\n        // The total number of\
    \ collisions is the number of collisions between the first car\n        // and\
    \ the second car, plus the number of collisions between the second car and the\
    \ third car,\n        // plus the number of collisions between the third car and\
    \ the fourth car, and so on.\n        // The number of collisions between the\
    \ ith car and the (i+1)th car is simply the difference\n        // between the\
    \ starting positions of the two cars.\n        // The total number of collisions\
    \ is the sum of these differences.\n        // We can compute this sum in O(n)\
    \ time.\n        // The total running time is O(n log n) because we need to sort\
    \ the cars.\n        val cars = Array.fill(n.toInt)((scala.util.Random.nextInt(n.toInt),\
    \ scala.util.Random.nextInt(n.toInt)))\n        val sortedCars = cars.sortBy(x\
    \ => x._1)\n        var collisions = 0L\n        for (i <- 0 until n.toInt - 1)\
    \ {\n            collisions += abs(sortedCars(i)._1 - sortedCars(i + 1)._1)\n\
    \        }\n        collisions\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpel4qtob8.scala:32)\n\tat Problem.main(tmpel4qtob8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792748
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This function returns\
    \ the number of collisions for n cars.\n        def f(n : Long) : Long = {\n \
    \           if (n == 0) 0\n            else if (n == 1) 0\n            else if\
    \ (n == 2) 1\n            else if (n % 2 == 0) f(n / 2) + f(n / 2 - 1)\n     \
    \       else f(n / 2) + f(n / 2)\n        }\n        f(n)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjik_8555.scala:24)\n\tat Problem.main(tmpjik_8555.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792744
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting position.\n        // Then, we can just iterate through\
    \ the cars, and count the number of\n        // cars that are moving in the opposite\
    \ direction.\n        // This is O(n log n) time.\n        val cars = Array.fill(n.toInt)((scala.util.Random.nextInt(n.toInt),\
    \ scala.util.Random.nextInt(2)))\n        val sortedCars = cars.sortBy(_._1)\n\
    \        var count = 0\n        for (i <- 0 until n.toInt) {\n            if (sortedCars(i)._2\
    \ == 0) {\n                count += 1\n            }\n        }\n        count\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpj22_t30g.scala:28)\n\tat Problem.main(tmpj22_t30g.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792747
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The cars are numbered\
    \ from 0 to n-1.  The cars moving left to right are\n        // numbered from\
    \ 0 to n-1; the cars moving right to left are numbered from n-1 to 0.\n      \
    \  // The cars moving left to right start at position 0; the cars moving right\
    \ to left\n        // start at position n-1.\n        // The cars moving left\
    \ to right have speed 1; the cars moving right to left have speed -1.\n      \
    \  // The cars moving left to right have acceleration 0; the cars moving right\
    \ to left have\n        // acceleration 0.\n        // The cars moving left to\
    \ right have initial velocity 1; the cars moving right to left\n        // have\
    \ initial velocity -1.\n        // The cars moving left to right have initial\
    \ position 0; the cars moving right to left\n        // have initial position\
    \ n-1.\n        // The cars moving left to right have initial time 0; the cars\
    \ moving right to left\n        // have initial time 0.\n        // The cars moving\
    \ left to right have final time n-1; the cars moving right to left\n        //\
    \ have final time n-1.\n        // The cars moving left to right have final position\
    \ n-1; the cars moving right to left\n        // have final position 0.\n    \
    \    // The cars moving left to right have final velocity 1; the cars moving right\
    \ to left\n        // have final velocity -1.\n        // The cars moving left\
    \ to right have final acceleration 0; the cars moving right to left\n        //\
    \ have final acceleration 0.\n        // The cars moving left to right have distance\
    \ traveled n-1; the cars moving right to left\n        // have distance traveled\
    \ n-1.\n        // The cars moving left to right have average velocity 1; the\
    \ cars moving right to left\n        // have average velocity -1.\n        //\
    \ The cars moving left to right have average acceleration 0; the cars moving right\
    \ to left\n        // have average acceleration 0.\n        // The cars moving\
    \ left to right have average speed 1; the cars moving right to left\n        //\
    \ have average speed 1.\n        // The cars moving left to right have average\
    \ acceleration 0; the cars moving right to left\n        // have average acceleration\
    \ 0.\n        // The cars moving left to right have average jerk 0; the cars moving\
    \ right to left\n        // have average jerk 0.\n        // The cars\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n\
    \    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphiqc0d4r.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// The cars are numbered from 0 to n-1.  The cars moving left to right are\e\
    [0m\n\e[31m14 |\e[0m        \e[34m// numbered from 0 to n-1; the cars moving right\
    \ to left are numbered from n-1 to 0.\e[0m\n\e[31m15 |\e[0m        \e[34m// The\
    \ cars moving left to right start at position 0; the cars moving right to left\e\
    [0m\n\e[31m16 |\e[0m        \e[34m// start at position n-1.\e[0m\n\e[31m17 |\e\
    [0m        \e[34m// The cars moving left to right have speed 1; the cars moving\
    \ right to left have speed -1.\e[0m\n\e[31m18 |\e[0m        \e[34m// The cars\
    \ moving left to right have acceleration 0; the cars moving right to left have\e\
    [0m\n\e[31m19 |\e[0m        \e[34m// acceleration 0.\e[0m\n\e[31m20 |\e[0m   \
    \     \e[34m// The cars moving left to right have initial velocity 1; the cars\
    \ moving right to left\e[0m\n\e[31m21 |\e[0m        \e[34m// have initial velocity\
    \ -1.\e[0m\n\e[31m22 |\e[0m        \e[34m// The cars moving left to right have\
    \ initial position 0; the cars moving right to left\e[0m\n\e[31m23 |\e[0m    \
    \    \e[34m// have initial position n-1.\e[0m\n\e[31m24 |\e[0m        \e[34m//\
    \ The cars moving left to right have initial time 0; the cars moving right to\
    \ left\e[0m\n\e[31m25 |\e[0m        \e[34m// have initial time 0.\e[0m\n\e[31m26\
    \ |\e[0m        \e[34m// The cars moving left to right have final time n-1; the\
    \ cars moving right to left\e[0m\n\e[31m27 |\e[0m        \e[34m// have final time\
    \ n-1.\e[0m\n\e[31m28 |\e[0m        \e[34m// The cars moving left to right have\
    \ final position n-1; the cars moving right to left\e[0m\n\e[31m29 |\e[0m    \
    \    \e[34m// have final position 0.\e[0m\n\e[31m30 |\e[0m        \e[34m// The\
    \ cars moving left to right have final velocity 1; the ca"
  stdout: ''
  timestamp: 1659792745
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting positions.\n        // Then, we can simply iterate\
    \ through the sorted list and count the number of collisions.\n        // The\
    \ time complexity is O(n log n).\n        val cars = Array.fill(n.toInt)((0, 0))\n\
    \        for (i <- 0 until n.toInt) {\n            val Array(x, v) = readLine.split(\"\
    \ \").map(_.toInt)\n            cars(i) = (x, v)\n        }\n        val sortedCars\
    \ = cars.sortBy(_._1)\n        var collisions = 0\n        for (i <- 0 until n.toInt)\
    \ {\n            for (j <- i + 1 until n.toInt) {\n                if (sortedCars(i)._2\
    \ < sortedCars(j)._2) collisions += 1\n            }\n        }\n        collisions\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp4g4cpuho.scala:18:30 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m            \e[33mval\e[0m Array(x, v) = readLine.split(\e\
    [31m\" \"\e[0m).map(_.toInt)\n\e[31m\e[31m   |\e[0m                          \
    \    ^^^^^^^^\e[0m\n\e[31m   |\e[0m                              Not found: readLine\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp4g4cpuho.scala:18:22\
    \ ---------------------------\e[0m\e[0m\n\e[31m18 |\e[0m            \e[33mval\e\
    [0m Array(x, v) = readLine.split(\e[31m\" \"\e[0m).map(_.toInt)\n\e[31m\e[31m\
    \   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m                      Recursive\
    \ \e[33mvalue\e[0m \e[35m$1$\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E045] Cyclic Error: /tmp/tmp4g4cpuho.scala:18:25 ---------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m            \e[33mval\e[0m Array(x, v) = readLine.split(\e\
    [31m\" \"\e[0m).map(_.toInt)\n\e[31m\e[31m   |\e[0m                         ^\e\
    [0m\n\e[31m   |\e[0m                         Recursive \e[33mvalue\e[0m \e[35m$1$\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659792743
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to use\
    \ a sweep line algorithm.\n        // We will sweep from left to right.\n    \
    \    // We will keep track of the cars that are moving left to right and the cars\
    \ that are moving right to left.\n        // We will keep track of the cars that\
    \ are moving left to right in a priority queue.\n        // We will keep track\
    \ of the cars that are moving right to left in a priority queue.\n        // When\
    \ we sweep, we will check if the cars that are moving left to right are colliding\
    \ with the cars that are moving right to left.\n        // If they are, then we\
    \ will remove the car that is moving left to right from the priority queue and\
    \ we will remove the car that is moving right to left from the priority queue.\n\
    \        // We will keep track of the number of collisions.\n        // We will\
    \ keep track of the number of cars that are moving left to right and the number\
    \ of cars that are moving right to left.\n        // We will keep track of the\
    \ number of cars that are moving left to right in a variable.\n        // We will\
    \ keep track of the number of cars that are moving right to left in a variable.\n\
    \        // We will keep track of the number of cars that are moving left to right\
    \ in a variable.\n        // We will keep track of the number of cars that are\
    \ moving right to left in a variable.\n        // We will keep track of the number\
    \ of cars that are moving left to right in a variable.\n        // We will keep\
    \ track of the number of cars that are moving right to left in a variable.\n \
    \       // We will keep track of the number of cars that are moving left to right\
    \ in a variable.\n        // We will keep track of the number of cars that are\
    \ moving right to left in a variable.\n        // We will keep track of the number\
    \ of cars that are moving left to right in a variable.\n        // We will keep\
    \ track of the number of cars that are moving right to left in a variable.\n \
    \       // We will keep track of the number of cars that are moving left to right\
    \ in a variable.\n        // We will keep track of the number of cars that are\
    \ moving right to left in a variable.\n        // We will keep track of the number\
    \ of cars that are moving left to right in a variable.\n        // We will keep\
    \ track of the number of cars that are moving right to left in\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n\
    \    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpzxeeq0eu.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// The idea is to use a sweep line algorithm.\e[0m\n\e[31m14 |\e[0m      \
    \  \e[34m// We will sweep from left to right.\e[0m\n\e[31m15 |\e[0m        \e\
    [34m// We will keep track of the cars that are moving left to right and the cars\
    \ that are moving right to left.\e[0m\n\e[31m16 |\e[0m        \e[34m// We will\
    \ keep track of the cars that are moving left to right in a priority queue.\e\
    [0m\n\e[31m17 |\e[0m        \e[34m// We will keep track of the cars that are moving\
    \ right to left in a priority queue.\e[0m\n\e[31m18 |\e[0m        \e[34m// When\
    \ we sweep, we will check if the cars that are moving left to right are colliding\
    \ with the cars that are moving right to left.\e[0m\n\e[31m19 |\e[0m        \e\
    [34m// If they are, then we will remove the car that is moving left to right from\
    \ the priority queue and we will remove the car that is moving right to left from\
    \ the priority queue.\e[0m\n\e[31m20 |\e[0m        \e[34m// We will keep track\
    \ of the number of collisions.\e[0m\n\e[31m21 |\e[0m        \e[34m// We will keep\
    \ track of the number of cars that are moving left to right and the number of\
    \ cars that are moving right to left.\e[0m\n\e[31m22 |\e[0m        \e[34m// We\
    \ will keep track of the number of cars that are moving left to right in a variable.\e\
    [0m\n\e[31m23 |\e[0m        \e[34m// We will keep track of the number of cars\
    \ that are moving right to left in a variable.\e[0m\n\e[31m24 |\e[0m        \e\
    [34m// We will keep track of the number of cars that are moving left to right\
    \ in a variable.\e[0m\n\e[31m25 |\e[0m        \e[34m// We will keep track of the\
    \ number of cars that are moving right to left in a variable.\e[0m\n\e[31m26 |\e\
    [0m        \e[34m// We will"
  stdout: ''
  timestamp: 1659792745
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is a very simple\
    \ problem.  The key observation is that the cars that are\n        // moving left\
    \ to right are the same as the cars that are moving right to left.\n        //\
    \ As a result, the number of collisions is the number of pairs of cars that are\n\
    \        // moving in the same direction.\n        // There are n cars moving\
    \ left to right, and n cars moving right to left.\n        // The number of pairs\
    \ of cars that are moving in the same direction is n * (n - 1) / 2.\n        n\
    \ * (n - 1) / 2\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpbeifegrr.scala:22)\n\tat Problem.main(tmpbeifegrr.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792748
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting positions.\n        // Then, we can just iterate\
    \ through the cars and count the number of collisions.\n        // The number\
    \ of collisions is equal to the number of cars that are moving right to left\n\
    \        // that are to the left of the current car.\n        // This is because\
    \ the car that's moving left to right will collide with all cars that are\n  \
    \      // moving right to left that are to the left of it.\n        // This is\
    \ because the car that's moving left to right will collide with all cars that\
    \ are\n        // moving right to left that are to the left of it.\n        //\
    \ This is because the car that's moving left to right will collide with all cars\
    \ that are\n        // moving right to left that are to the left of it.\n    \
    \    // This is because the car that's moving left to right will collide with\
    \ all cars that are\n        // moving right to left that are to the left of it.\n\
    \        // This is because the car that's moving left to right will collide with\
    \ all cars that are\n        // moving right to left that are to the left of it.\n\
    \        // This is because the car that's moving left to right will collide with\
    \ all cars that are\n        // moving right to left that are to the left of it.\n\
    \        // This is because the car that's moving left to right will collide with\
    \ all cars that are\n        // moving right to left that are to the left of it.\n\
    \        // This is because the car that's moving left to right will collide with\
    \ all cars that are\n        // moving right to left that are to the left of it.\n\
    \        // This is because the car that's moving left to right will collide with\
    \ all cars that are\n        // moving right to left that are to the left of it.\n\
    \        // This is because the car that's moving left to right will collide with\
    \ all cars that are\n        // moving right to left that are to the left of it.\n\
    \        // This is because the car that's moving left to right will collide with\
    \ all cars that are\n        // moving right to left that are to the left of it.\n\
    \        // This is because the car that's moving left to right will collide with\
    \ all cars that are\n        // moving right to left that are to the left of it.\n\
    \        // This is because the car that's moving left\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpej6kl8v1.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// The idea is to sort the cars by their starting positions.\e[0m\n\e[31m14\
    \ |\e[0m        \e[34m// Then, we can just iterate through the cars and count\
    \ the number of collisions.\e[0m\n\e[31m15 |\e[0m        \e[34m// The number of\
    \ collisions is equal to the number of cars that are moving right to left\e[0m\n\
    \e[31m16 |\e[0m        \e[34m// that are to the left of the current car.\e[0m\n\
    \e[31m17 |\e[0m        \e[34m// This is because the car that's moving left to\
    \ right will collide with all cars that are\e[0m\n\e[31m18 |\e[0m        \e[34m//\
    \ moving right to left that are to the left of it.\e[0m\n\e[31m19 |\e[0m     \
    \   \e[34m// This is because the car that's moving left to right will collide\
    \ with all cars that are\e[0m\n\e[31m20 |\e[0m        \e[34m// moving right to\
    \ left that are to the left of it.\e[0m\n\e[31m21 |\e[0m        \e[34m// This\
    \ is because the car that's moving left to right will collide with all cars that\
    \ are\e[0m\n\e[31m22 |\e[0m        \e[34m// moving right to left that are to the\
    \ left of it.\e[0m\n\e[31m23 |\e[0m        \e[34m// This is because the car that's\
    \ moving left to right will collide with all cars that are\e[0m\n\e[31m24 |\e\
    [0m        \e[34m// moving right to left that are to the left of it.\e[0m\n\e\
    [31m25 |\e[0m        \e[34m// This is because the car that's moving left to right\
    \ will collide with all cars that are\e[0m\n\e[31m26 |\e[0m        \e[34m// moving\
    \ right to left that are to the left of it.\e[0m\n\e[31m27 |\e[0m        \e[34m//\
    \ This is because the car that's moving left to right will collide with all cars\
    \ that are\e[0m\n\e[31m28 |\e[0m        \e[34m// moving right to left that are\
    \ to the left of it.\e[0m\n\e[31m29 |\e[0m      "
  stdout: ''
  timestamp: 1659792747
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // Let's say that the\
    \ left-to-right cars are numbered 1 to n, and the right-to-left cars\n       \
    \ // are numbered n+1 to 2n.  We'll say that a car i collides with car j if i\
    \ < j and\n        // car i is to the left of car j.  We'll say that a car i is\
    \ to the left of car j if\n        // i < j and car i is moving left to right\
    \ and car j is moving right to left.\n        // We'll say that a car i is to\
    \ the right of car j if i > j and car i is moving right to left\n        // and\
    \ car j is moving left to right.\n        // We'll say that car i is to the left\
    \ of car j if i < j and car i is to the left of car j\n        // and car i is\
    \ not to the right of car j.\n        // We'll say that car i is to the right\
    \ of car j if i > j and car i is to the right of car j\n        // and car i is\
    \ not to the left of car j.\n        // We'll say that car i is to the left of\
    \ car j if i < j and car i is to the left of car j\n        // and car i is not\
    \ to the right of car j.\n        // We'll say that car i is to the right of car\
    \ j if i > j and car i is to the right of car j\n        // and car i is not to\
    \ the left of car j.\n        // We'll say that car i is to the left of car j\
    \ if i < j and car i is to the left of car j\n        // and car i is not to the\
    \ right of car j.\n        // We'll say that car i is to the right of car j if\
    \ i > j and car i is to the right of car j\n        // and car i is not to the\
    \ left of car j.\n        // We'll say that car i is to the left of car j if i\
    \ < j and car i is to the left of car j\n        // and car i is not to the right\
    \ of car j.\n        // We'll say that car i is to the right of car j if i > j\
    \ and car i is to the right of car j\n        // and car i is not to the left\
    \ of car j.\n\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpemdzb8fq.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// Let's say that the left-to-right cars are numbered 1 to n, and the right-to-left\
    \ cars\e[0m\n\e[31m14 |\e[0m        \e[34m// are numbered n+1 to 2n.  We'll say\
    \ that a car i collides with car j if i < j and\e[0m\n\e[31m15 |\e[0m        \e\
    [34m// car i is to the left of car j.  We'll say that a car i is to the left of\
    \ car j if\e[0m\n\e[31m16 |\e[0m        \e[34m// i < j and car i is moving left\
    \ to right and car j is moving right to left.\e[0m\n\e[31m17 |\e[0m        \e\
    [34m// We'll say that a car i is to the right of car j if i > j and car i is moving\
    \ right to left\e[0m\n\e[31m18 |\e[0m        \e[34m// and car j is moving left\
    \ to right.\e[0m\n\e[31m19 |\e[0m        \e[34m// We'll say that car i is to the\
    \ left of car j if i < j and car i is to the left of car j\e[0m\n\e[31m20 |\e\
    [0m        \e[34m// and car i is not to the right of car j.\e[0m\n\e[31m21 |\e\
    [0m        \e[34m// We'll say that car i is to the right of car j if i > j and\
    \ car i is to the right of car j\e[0m\n\e[31m22 |\e[0m        \e[34m// and car\
    \ i is not to the left of car j.\e[0m\n\e[31m23 |\e[0m        \e[34m// We'll say\
    \ that car i is to the left of car j if i < j and car i is to the left of car\
    \ j\e[0m\n\e[31m24 |\e[0m        \e[34m// and car i is not to the right of car\
    \ j.\e[0m\n\e[31m25 |\e[0m        \e[34m// We'll say that car i is to the right\
    \ of car j if i > j and car i is to the right of car j\e[0m\n\e[31m26 |\e[0m \
    \       \e[34m// and car i is not to the left of car j.\e[0m\n\e[31m27 |\e[0m\
    \        \e[34m// We'll say that car i is to the left of car j if i < j and car\
    \ i is to the left of car j\e[0m\n\e[31m28 |\e[0m        \e[34m// and car i is\
    \ not to the right of car j.\e[0m\n\e[31m29 |\e[0m"
  stdout: ''
  timestamp: 1659792747
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is a simple problem.\
    \  We can use a hash map to store the positions of the cars\n        // that are\
    \ moving left to right.  Then, we can iterate through the cars that are moving\n\
    \        // right to left and see if there is a collision.  If there is a collision,\
    \ we remove the\n        // car that is moving left to right from the hash map.\n\
    \        val map = new HashMap[Long, Long]()\n        for (i <- 1 to n.toInt)\
    \ {\n            map.put(i, i)\n        }\n        var count = 0\n        for\
    \ (i <- 1 to n.toInt) {\n            if (map.contains(i)) {\n                count\
    \ += 1\n                map.remove(i)\n            }\n        }\n        count\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxv25vuj2.scala:31)\n\tat Problem.main(tmpxv25vuj2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792749
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting positions.\n        // Then, we can simulate the\
    \ race by moving the cars one by one.\n        // The cars are sorted by their\
    \ starting positions.\n        // The cars are sorted by their starting positions.\n\
    \        // The cars are sorted by their starting positions.\n        // The cars\
    \ are sorted by their starting positions.\n        // The cars are sorted by their\
    \ starting positions.\n        // The cars are sorted by their starting positions.\n\
    \        // The cars are sorted by their starting positions.\n        // The cars\
    \ are sorted by their starting positions.\n        // The cars are sorted by their\
    \ starting positions.\n        // The cars are sorted by their starting positions.\n\
    \        // The cars are sorted by their starting positions.\n        // The cars\
    \ are sorted by their starting positions.\n        // The cars are sorted by their\
    \ starting positions.\n        // The cars are sorted by their starting positions.\n\
    \        // The cars are sorted by their starting positions.\n        // The cars\
    \ are sorted by their starting positions.\n        // The cars are sorted by their\
    \ starting positions.\n        // The cars are sorted by their starting positions.\n\
    \        // The cars are sorted by their starting positions.\n        // The cars\
    \ are sorted by their starting positions.\n        // The cars are sorted by their\
    \ starting positions.\n        // The cars are sorted by their starting positions.\n\
    \        // The cars are sorted by their starting positions.\n        // The cars\
    \ are sorted by their starting positions.\n        // The cars are sorted by their\
    \ starting positions.\n        // The cars are sorted by their starting positions.\n\
    \        // The cars are sorted by their starting positions.\n        // The cars\
    \ are sorted by their starting positions.\n        // The cars are sorted by their\
    \ starting positions.\n        // The cars are sorted by their starting positions.\n\
    \        // The cars are sorted by their starting positions.\n        // The cars\
    \ are sorted by their starting positions.\n        // The cars are sorted by their\
    \ starting positions.\n        // The cars are sorted by their starting positions.\n\
    \        // The cars are sorted by their starting positions.\n        // The cars\
    \ are sorted by their starting positions.\n        // The cars are sorted by their\
    \ starting positions.\n        // The cars are sorted by their starting positions.\n\
    \        // The cars are sorted by their starting positions.\n        // The cars\
    \ are sorted by their starting positions\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5te3jwml.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// The idea is to sort the cars by their starting positions.\e[0m\n\e[31m14\
    \ |\e[0m        \e[34m// Then, we can simulate the race by moving the cars one\
    \ by one.\e[0m\n\e[31m15 |\e[0m        \e[34m// The cars are sorted by their starting\
    \ positions.\e[0m\n\e[31m16 |\e[0m        \e[34m// The cars are sorted by their\
    \ starting positions.\e[0m\n\e[31m17 |\e[0m        \e[34m// The cars are sorted\
    \ by their starting positions.\e[0m\n\e[31m18 |\e[0m        \e[34m// The cars\
    \ are sorted by their starting positions.\e[0m\n\e[31m19 |\e[0m        \e[34m//\
    \ The cars are sorted by their starting positions.\e[0m\n\e[31m20 |\e[0m     \
    \   \e[34m// The cars are sorted by their starting positions.\e[0m\n\e[31m21 |\e\
    [0m        \e[34m// The cars are sorted by their starting positions.\e[0m\n\e\
    [31m22 |\e[0m        \e[34m// The cars are sorted by their starting positions.\e\
    [0m\n\e[31m23 |\e[0m        \e[34m// The cars are sorted by their starting positions.\e\
    [0m\n\e[31m24 |\e[0m        \e[34m// The cars are sorted by their starting positions.\e\
    [0m\n\e[31m25 |\e[0m        \e[34m// The cars are sorted by their starting positions.\e\
    [0m\n\e[31m26 |\e[0m        \e[34m// The cars are sorted by their starting positions.\e\
    [0m\n\e[31m27 |\e[0m        \e[34m// The cars are sorted by their starting positions.\e\
    [0m\n\e[31m28 |\e[0m        \e[34m// The cars are sorted by their starting positions.\e\
    [0m\n\e[31m29 |\e[0m        \e[34m// The cars are sorted by their starting positions.\e\
    [0m\n\e[31m30 |\e[0m        \e[34m// The cars are sorted by their starting positions.\e\
    [0m\n\e[31m31 |\e[0m        \e[34m// The cars are sorted by their starting positions.\e\
    [0m\n\e[31m32 |\e[0m        \e[34m// The cars are sorted by t"
  stdout: ''
  timestamp: 1659792748
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This function returns\
    \ the number of collisions between the cars in the two lists.\n        // The\
    \ cars in the two lists are assumed to be sorted by their starting position.\n\
    \        def carRaceCollision(leftToRight : List[Long], rightToLeft : List[Long])\
    \ : Long = {\n            if (leftToRight.isEmpty || rightToLeft.isEmpty) 0\n\
    \            else {\n                val leftToRightHead = leftToRight.head\n\
    \                val rightToLeftHead = rightToLeft.head\n                if (leftToRightHead\
    \ < rightToLeftHead) carRaceCollision(leftToRight.tail, rightToLeft)\n       \
    \         else if (leftToRightHead > rightToLeftHead) carRaceCollision(leftToRight,\
    \ rightToLeft.tail)\n                else 1 + carRaceCollision(leftToRight.tail,\
    \ rightToLeft.tail)\n            }\n        }\n        // This function returns\
    \ the number of collisions between the cars in the two lists.\n        // The\
    \ cars in the two lists are assumed to be sorted by their starting position.\n\
    \        // The cars in the two lists are assumed to be sorted by their starting\
    \ position.\n        // The cars in the two lists are assumed to be sorted by\
    \ their starting position.\n        // The cars in the two lists are assumed to\
    \ be sorted by their starting position.\n        // The cars in the two lists\
    \ are assumed to be sorted by their starting position.\n        // The cars in\
    \ the two lists are assumed to be sorted by their starting position.\n       \
    \ // The cars in the two lists are assumed to be sorted by their starting position.\n\
    \        // The cars in the two lists are assumed to be sorted by their starting\
    \ position.\n        // The cars in the two lists are assumed to be sorted by\
    \ their starting position.\n        // The cars in the two lists are assumed to\
    \ be sorted by their starting position.\n        // The cars in the two lists\
    \ are assumed to be sorted by their starting position.\n        // The cars in\
    \ the two lists are assumed to be sorted by their starting position.\n       \
    \ // The cars in the two lists are assumed to be sorted by their starting position.\n\
    \        // The cars in the two lists are assumed to be sorted by their starting\
    \ position.\n        // The cars in the two lists are assumed to be sorted by\
    \ their starting position.\n        // The cars in the two\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp0lemmwj3.scala:42:5\
    \ ---------------------\e[0m\e[0m\n\e[31m42 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659792749
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting positions.\n        // Then, we can just count the\
    \ number of cars that are moving in the same direction.\n        // This is because\
    \ the cars that are moving in the same direction will collide.\n        // The\
    \ cars that are moving in opposite directions will not collide.\n        // The\
    \ cars that are moving in the same direction will collide if and only if\n   \
    \     // they are in the same position.\n        // The cars that are moving in\
    \ the same direction will collide if and only if\n        // they are in the same\
    \ position.\n        // The cars that are moving in the same direction will collide\
    \ if and only if\n        // they are in the same position.\n        // The cars\
    \ that are moving in the same direction will collide if and only if\n        //\
    \ they are in the same position.\n        // The cars that are moving in the same\
    \ direction will collide if and only if\n        // they are in the same position.\n\
    \        // The cars that are moving in the same direction will collide if and\
    \ only if\n        // they are in the same position.\n        // The cars that\
    \ are moving in the same direction will collide if and only if\n        // they\
    \ are in the same position.\n        // The cars that are moving in the same direction\
    \ will collide if and only if\n        // they are in the same position.\n   \
    \     // The cars that are moving in the same direction will collide if and only\
    \ if\n        // they are in the same position.\n        // The cars that are\
    \ moving in the same direction will collide if and only if\n        // they are\
    \ in the same position.\n        // The cars that are moving in the same direction\
    \ will collide if and only if\n        // they are in the same position.\n   \
    \     // The cars that are moving in the same direction will collide if and only\
    \ if\n        // they are in the same position.\n        // The cars that are\
    \ moving in the same direction will collide if and only if\n        // they are\
    \ in the same position.\n        // The cars that are moving in the same direction\
    \ will collide if and only if\n        // they are in the same position.\n   \
    \     // The cars that are moving in the same direction will collide if and only\
    \ if\n        // they are in the same position.\n        // The cars that are\
    \ moving in the same direction will collide if and only if\n        // they are\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpk7obpau_.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// The idea is to sort the cars by their starting positions.\e[0m\n\e[31m14\
    \ |\e[0m        \e[34m// Then, we can just count the number of cars that are moving\
    \ in the same direction.\e[0m\n\e[31m15 |\e[0m        \e[34m// This is because\
    \ the cars that are moving in the same direction will collide.\e[0m\n\e[31m16\
    \ |\e[0m        \e[34m// The cars that are moving in opposite directions will\
    \ not collide.\e[0m\n\e[31m17 |\e[0m        \e[34m// The cars that are moving\
    \ in the same direction will collide if and only if\e[0m\n\e[31m18 |\e[0m    \
    \    \e[34m// they are in the same position.\e[0m\n\e[31m19 |\e[0m        \e[34m//\
    \ The cars that are moving in the same direction will collide if and only if\e\
    [0m\n\e[31m20 |\e[0m        \e[34m// they are in the same position.\e[0m\n\e[31m21\
    \ |\e[0m        \e[34m// The cars that are moving in the same direction will collide\
    \ if and only if\e[0m\n\e[31m22 |\e[0m        \e[34m// they are in the same position.\e\
    [0m\n\e[31m23 |\e[0m        \e[34m// The cars that are moving in the same direction\
    \ will collide if and only if\e[0m\n\e[31m24 |\e[0m        \e[34m// they are in\
    \ the same position.\e[0m\n\e[31m25 |\e[0m        \e[34m// The cars that are moving\
    \ in the same direction will collide if and only if\e[0m\n\e[31m26 |\e[0m    \
    \    \e[34m// they are in the same position.\e[0m\n\e[31m27 |\e[0m        \e[34m//\
    \ The cars that are moving in the same direction will collide if and only if\e\
    [0m\n\e[31m28 |\e[0m        \e[34m// they are in the same position.\e[0m\n\e[31m29\
    \ |\e[0m        \e[34m// The cars that are moving in the same direction will collide\
    \ if and only if\e[0m\n\e[31m30 |\e[0m        \e[34m// they are in the same position.\e\
    [0m\n\e[31m31 |\e[0m "
  stdout: ''
  timestamp: 1659792748
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting position.  Then, we can\n        // just iterate\
    \ through the cars and count the number of collisions.\n        // The cars are\
    \ sorted by their starting position.  The first n cars are\n        // moving\
    \ left to right, and the last n cars are moving right to left.\n        val cars\
    \ = new Array[Long](2 * n.toInt)\n        for (i <- 0 until n.toInt) cars(i) =\
    \ i\n        for (i <- n.toInt until 2 * n.toInt) cars(i) = 2 * n - i - 1\n  \
    \      // Sort the cars by their starting position.\n        scala.util.Sorting.quickSort(cars)\n\
    \        // Count the number of collisions.\n        var collisions = 0L\n   \
    \     for (i <- 0 until n.toInt) {\n            for (j <- n.toInt until 2 * n.toInt)\
    \ {\n                if (cars(i) > cars(j)) collisions += 1\n            }\n \
    \       }\n        collisions\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpvoyji87j.scala:32)\n\tat Problem.main(tmpvoyji87j.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792750
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the positions of the cars and then count the number of collisions.\n       \
    \ // The number of collisions is the number of pairs of cars that are at the same\
    \ position.\n        // The number of pairs of cars at the same position is the\
    \ number of cars at that position\n        // minus 1.  So, we can count the number\
    \ of collisions by counting the number of cars at each\n        // position and\
    \ then subtracting 1 from each count.\n        // The number of cars at each position\
    \ is the number of cars that start at that position\n        // plus the number\
    \ of cars that start at that position.\n        // The number of cars that start\
    \ at each position is the number of cars that start at that\n        // position\
    \ and move left to right plus the number of cars that start at that position and\n\
    \        // move right to left.\n        // The number of cars that start at each\
    \ position and move left to right is the number of\n        // cars that start\
    \ at that position and move left to right plus the number of cars that\n     \
    \   // start at that position and move right to left.\n        // The number of\
    \ cars that start at each position and move right to left is the number of\n \
    \       // cars that start at that position and move left to right plus the number\
    \ of cars that\n        // start at that position and move right to left.\n  \
    \      // So, the number of cars at each position is the number of cars that start\
    \ at that position\n        // and move left to right plus the number of cars\
    \ that start at that position and move right\n        // to left.\n        //\
    \ The number of cars that start at each position and move left to right is the\
    \ number of\n        // cars that start at that position and move left to right\
    \ plus the number of cars that\n        // start at that position and move right\
    \ to left.\n        // The number of cars that start at each position and move\
    \ right to left is the number of\n        // cars that start at that position\
    \ and move left to right plus the number of cars that\n        // start at that\
    \ position and move right to left.\n        // So, the number of cars at each\
    \ position is the number of cars that start at that position\n        // and move\
    \ left to right plus the number of cars that start at that position and move right\n\
    \        // to left.\n        // The number of cars that start at each position\
    \ and move left\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7yjy7esp.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// The idea is to sort the positions of the cars and then count the number\
    \ of collisions.\e[0m\n\e[31m14 |\e[0m        \e[34m// The number of collisions\
    \ is the number of pairs of cars that are at the same position.\e[0m\n\e[31m15\
    \ |\e[0m        \e[34m// The number of pairs of cars at the same position is the\
    \ number of cars at that position\e[0m\n\e[31m16 |\e[0m        \e[34m// minus\
    \ 1.  So, we can count the number of collisions by counting the number of cars\
    \ at each\e[0m\n\e[31m17 |\e[0m        \e[34m// position and then subtracting\
    \ 1 from each count.\e[0m\n\e[31m18 |\e[0m        \e[34m// The number of cars\
    \ at each position is the number of cars that start at that position\e[0m\n\e\
    [31m19 |\e[0m        \e[34m// plus the number of cars that start at that position.\e\
    [0m\n\e[31m20 |\e[0m        \e[34m// The number of cars that start at each position\
    \ is the number of cars that start at that\e[0m\n\e[31m21 |\e[0m        \e[34m//\
    \ position and move left to right plus the number of cars that start at that position\
    \ and\e[0m\n\e[31m22 |\e[0m        \e[34m// move right to left.\e[0m\n\e[31m23\
    \ |\e[0m        \e[34m// The number of cars that start at each position and move\
    \ left to right is the number of\e[0m\n\e[31m24 |\e[0m        \e[34m// cars that\
    \ start at that position and move left to right plus the number of cars that\e\
    [0m\n\e[31m25 |\e[0m        \e[34m// start at that position and move right to\
    \ left.\e[0m\n\e[31m26 |\e[0m        \e[34m// The number of cars that start at\
    \ each position and move right to left is the number of\e[0m\n\e[31m27 |\e[0m\
    \        \e[34m// cars that start at that position and move left to right plus\
    \ the number of cars that\e[0m\n\e[31m28 |\e"
  stdout: ''
  timestamp: 1659792749
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting positions.\n        // Then, for each car, we can\
    \ compute the time it takes for it to collide with\n        // the next car. \
    \ We can then sum up all these times.\n        // The time it takes for a car\
    \ to collide with the next car is\n        // (distance between the two cars)\
    \ / (difference in speed between the two cars)\n        // We can compute the\
    \ distance between the two cars by subtracting the\n        // starting positions\
    \ of the two cars.\n        // We can compute the difference in speed between\
    \ the two cars by subtracting\n        // the speeds of the two cars.\n      \
    \  // The time it takes for a car to collide with the next car is\n        //\
    \ (distance between the two cars) / (difference in speed between the two cars)\n\
    \        // = (starting position of the next car - starting position of the current\
    \ car) /\n        //   (speed of the next car - speed of the current car)\n  \
    \      // = (starting position of the next car - starting position of the current\
    \ car) /\n        //   (speed of the next car - speed of the current car)\n  \
    \      // = (starting position of the next car - starting position of the current\
    \ car) /\n        //   (speed of the next car - speed of the current car)\n  \
    \      // = (starting position of the next car - starting position of the current\
    \ car) /\n        //   (speed of the next car - speed of the current car)\n  \
    \      // = (starting position of the next car - starting position of the current\
    \ car) /\n        //   (speed of the next car - speed of the current car)\n  \
    \      // = (starting position of the next car - starting position of the current\
    \ car) /\n        //   (speed of the next car - speed of the current car)\n  \
    \      // = (starting position of the next car - starting position of the current\
    \ car) /\n        //   (speed of the next car - speed of the current car)\n  \
    \      // = (starting position of the next car - starting position of the current\
    \ car) /\n        //   (speed of the next car - speed of the current car)\n  \
    \      // = (starting position of the next car - starting position of the current\
    \ car) /\n        //   (speed of the next car - speed of the\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpl4u9iwi8.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// The idea is to sort the cars by their starting positions.\e[0m\n\e[31m14\
    \ |\e[0m        \e[34m// Then, for each car, we can compute the time it takes\
    \ for it to collide with\e[0m\n\e[31m15 |\e[0m        \e[34m// the next car. \
    \ We can then sum up all these times.\e[0m\n\e[31m16 |\e[0m        \e[34m// The\
    \ time it takes for a car to collide with the next car is\e[0m\n\e[31m17 |\e[0m\
    \        \e[34m// (distance between the two cars) / (difference in speed between\
    \ the two cars)\e[0m\n\e[31m18 |\e[0m        \e[34m// We can compute the distance\
    \ between the two cars by subtracting the\e[0m\n\e[31m19 |\e[0m        \e[34m//\
    \ starting positions of the two cars.\e[0m\n\e[31m20 |\e[0m        \e[34m// We\
    \ can compute the difference in speed between the two cars by subtracting\e[0m\n\
    \e[31m21 |\e[0m        \e[34m// the speeds of the two cars.\e[0m\n\e[31m22 |\e\
    [0m        \e[34m// The time it takes for a car to collide with the next car is\e\
    [0m\n\e[31m23 |\e[0m        \e[34m// (distance between the two cars) / (difference\
    \ in speed between the two cars)\e[0m\n\e[31m24 |\e[0m        \e[34m// = (starting\
    \ position of the next car - starting position of the current car) /\e[0m\n\e\
    [31m25 |\e[0m        \e[34m//   (speed of the next car - speed of the current\
    \ car)\e[0m\n\e[31m26 |\e[0m        \e[34m// = (starting position of the next\
    \ car - starting position of the current car) /\e[0m\n\e[31m27 |\e[0m        \e\
    [34m//   (speed of the next car - speed of the current car)\e[0m\n\e[31m28 |\e\
    [0m        \e[34m// = (starting position of the next car - starting position of\
    \ the current car) /\e[0m\n\e[31m29 |\e[0m        \e[34m//   (speed of the next\
    \ car - speed of the current car)\e[0m\n\e[31m30 |\e"
  stdout: ''
  timestamp: 1659792749
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting position.\n        // Then, we can iterate through\
    \ the cars and count the number of collisions.\n        // The number of collisions\
    \ is the number of cars that are to the left of the current car.\n        // This\
    \ is because the cars to the left of the current car are moving right to left,\n\
    \        // and the current car is moving left to right.\n        // The total\
    \ number of collisions is the sum of the number of collisions for each car.\n\
    \        // The number of collisions for each car is the number of cars to the\
    \ left of the current car.\n        // The number of cars to the left of the current\
    \ car is the current car's index.\n        // The total number of collisions is\
    \ the sum of the indices of the cars.\n        // The sum of the indices of the\
    \ cars is the sum of the first n natural numbers.\n        // The sum of the first\
    \ n natural numbers is n * (n + 1) / 2.\n        n * (n + 1) / 2\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n\
    \    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6gllechf.scala:27)\n\tat Problem.main(tmp6gllechf.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792750
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The cars are numbered\
    \ from 1 to n.  The cars moving left to right are numbered\n        // from 1\
    \ to n; the cars moving right to left are numbered from n to 1.\n        // The\
    \ cars moving left to right are at positions x1, x2, ..., xn, where x1 < x2 <\
    \ ... < xn.\n        // The cars moving right to left are at positions y1, y2,\
    \ ..., yn, where y1 > y2 > ... > yn.\n        // The cars move at the same speed.\
    \  The cars moving left to right move at speed 1.\n        // The cars moving\
    \ right to left move at speed -1.\n        // The cars are infinitely sturdy and\
    \ strong; as a result, they continue moving\n        // in their trajectory as\
    \ if they did not collide.\n        // This function outputs the number of such\
    \ collisions.\n        //\n        // We can solve this problem by using a sweep\
    \ line algorithm.\n        // The sweep line algorithm is as follows:\n      \
    \  // 1. We sort the cars by their position.\n        // 2. We sweep the line\
    \ from left to right.\n        // 3. We keep track of the cars that are currently\
    \ on the left side of the line.\n        // 4. When we encounter a car moving\
    \ left to right, we add it to the set of cars\n        //    on the left side\
    \ of the line.\n        // 5. When we encounter a car moving right to left, we\
    \ remove it from the set of cars\n        //    on the left side of the line.\n\
    \        // 6. When we encounter a car moving left to right, we count the number\
    \ of cars\n        //    on the left side of the line.  This is the number of\
    \ cars that the car\n        //    moving left to right will collide with.\n \
    \       // 7. When we encounter a car moving right to left, we count the number\
    \ of cars\n        //    on the left side of the line.  This is the number of\
    \ cars that the car\n        //    moving right to left will collide with.\n \
    \       // 8. We add up the number of collisions that we counted in steps 6 and\
    \ 7.\n        //    This is the total number of collisions.\n        //\n    \
    \    // We can use a priority queue to implement the sweep line algorithm.\n \
    \       // The priority queue will be sorted\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpn8fl4xim.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// The cars are numbered from 1 to n.  The cars moving left to right are numbered\e\
    [0m\n\e[31m14 |\e[0m        \e[34m// from 1 to n; the cars moving right to left\
    \ are numbered from n to 1.\e[0m\n\e[31m15 |\e[0m        \e[34m// The cars moving\
    \ left to right are at positions x1, x2, ..., xn, where x1 < x2 < ... < xn.\e\
    [0m\n\e[31m16 |\e[0m        \e[34m// The cars moving right to left are at positions\
    \ y1, y2, ..., yn, where y1 > y2 > ... > yn.\e[0m\n\e[31m17 |\e[0m        \e[34m//\
    \ The cars move at the same speed.  The cars moving left to right move at speed\
    \ 1.\e[0m\n\e[31m18 |\e[0m        \e[34m// The cars moving right to left move\
    \ at speed -1.\e[0m\n\e[31m19 |\e[0m        \e[34m// The cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\e[0m\n\e[31m20 |\e[0m        \e\
    [34m// in their trajectory as if they did not collide.\e[0m\n\e[31m21 |\e[0m \
    \       \e[34m// This function outputs the number of such collisions.\e[0m\n\e\
    [31m22 |\e[0m        \e[34m//\e[0m\n\e[31m23 |\e[0m        \e[34m// We can solve\
    \ this problem by using a sweep line algorithm.\e[0m\n\e[31m24 |\e[0m        \e\
    [34m// The sweep line algorithm is as follows:\e[0m\n\e[31m25 |\e[0m        \e\
    [34m// 1. We sort the cars by their position.\e[0m\n\e[31m26 |\e[0m        \e\
    [34m// 2. We sweep the line from left to right.\e[0m\n\e[31m27 |\e[0m        \e\
    [34m// 3. We keep track of the cars that are currently on the left side of the\
    \ line.\e[0m\n\e[31m28 |\e[0m        \e[34m// 4. When we encounter a car moving\
    \ left to right, we add it to the set of cars\e[0m\n\e[31m29 |\e[0m        \e\
    [34m//    on the left side of the line.\e[0m\n\e[31m30 |\e[0m        \e[34m//\
    \ 5. When we encounter a car moving right "
  stdout: ''
  timestamp: 1659792750
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to use\
    \ a sweep line algorithm.\n        // We will use a priority queue to keep track\
    \ of the cars that are moving left to right.\n        // We will use a priority\
    \ queue to keep track of the cars that are moving right to left.\n        // We\
    \ will use a priority queue to keep track of the cars that are moving left to\
    \ right.\n        // We will use a priority queue to keep track of the cars that\
    \ are moving right to left.\n        // We will use a priority queue to keep track\
    \ of the cars that are moving left to right.\n        // We will use a priority\
    \ queue to keep track of the cars that are moving right to left.\n        // We\
    \ will use a priority queue to keep track of the cars that are moving left to\
    \ right.\n        // We will use a priority queue to keep track of the cars that\
    \ are moving right to left.\n        // We will use a priority queue to keep track\
    \ of the cars that are moving left to right.\n        // We will use a priority\
    \ queue to keep track of the cars that are moving right to left.\n        // We\
    \ will use a priority queue to keep track of the cars that are moving left to\
    \ right.\n        // We will use a priority queue to keep track of the cars that\
    \ are moving right to left.\n        // We will use a priority queue to keep track\
    \ of the cars that are moving left to right.\n        // We will use a priority\
    \ queue to keep track of the cars that are moving right to left.\n        // We\
    \ will use a priority queue to keep track of the cars that are moving left to\
    \ right.\n        // We will use a priority queue to keep track of the cars that\
    \ are moving right to left.\n        // We will use a priority queue to keep track\
    \ of the cars that are moving left to right.\n        // We will use a priority\
    \ queue to keep track of the cars that are moving right to left.\n        // We\
    \ will use a priority queue to keep track of the cars that are moving left to\
    \ right.\n        // We will use a priority queue to keep track of the cars that\
    \ are moving right to left.\n        // We will use a priority queue to keep track\
    \ of the cars that are moving left to right.\n        // We will use a priority\
    \ queue to keep track of the cars that are moving right to left.\n        // We\
    \ will use a priority queue to keep track of the cars\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpe6vm4knh.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// The idea is to use a sweep line algorithm.\e[0m\n\e[31m14 |\e[0m      \
    \  \e[34m// We will use a priority queue to keep track of the cars that are moving\
    \ left to right.\e[0m\n\e[31m15 |\e[0m        \e[34m// We will use a priority\
    \ queue to keep track of the cars that are moving right to left.\e[0m\n\e[31m16\
    \ |\e[0m        \e[34m// We will use a priority queue to keep track of the cars\
    \ that are moving left to right.\e[0m\n\e[31m17 |\e[0m        \e[34m// We will\
    \ use a priority queue to keep track of the cars that are moving right to left.\e\
    [0m\n\e[31m18 |\e[0m        \e[34m// We will use a priority queue to keep track\
    \ of the cars that are moving left to right.\e[0m\n\e[31m19 |\e[0m        \e[34m//\
    \ We will use a priority queue to keep track of the cars that are moving right\
    \ to left.\e[0m\n\e[31m20 |\e[0m        \e[34m// We will use a priority queue\
    \ to keep track of the cars that are moving left to right.\e[0m\n\e[31m21 |\e\
    [0m        \e[34m// We will use a priority queue to keep track of the cars that\
    \ are moving right to left.\e[0m\n\e[31m22 |\e[0m        \e[34m// We will use\
    \ a priority queue to keep track of the cars that are moving left to right.\e\
    [0m\n\e[31m23 |\e[0m        \e[34m// We will use a priority queue to keep track\
    \ of the cars that are moving right to left.\e[0m\n\e[31m24 |\e[0m        \e[34m//\
    \ We will use a priority queue to keep track of the cars that are moving left\
    \ to right.\e[0m\n\e[31m25 |\e[0m        \e[34m// We will use a priority queue\
    \ to keep track of the cars that are moving right to left.\e[0m\n\e[31m26 |\e\
    [0m        \e[34m// We will use a priority queue to keep track of the cars that\
    \ are moving left to right.\e[0m\n\e[31m27 |\e"
  stdout: ''
  timestamp: 1659792750
- exit_code: -1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is a very simple\
    \ problem.  We can just simulate the cars moving.\n        // We can do this in\
    \ O(n^2) time.\n        // However, this is a very simple problem, so we can do\
    \ better.\n        // We can do this in O(n) time.\n        // The key observation\
    \ is that the cars are moving in the same speed.\n        // As a result, the\
    \ cars that collide are the cars that are closest to each other.\n        // We\
    \ can use a priority queue to keep track of the closest cars.\n        // We can\
    \ do this in O(n) time.\n        val pq = new PriorityQueue[(Long, Boolean)]()(Ordering.by(-_._1))\n\
    \        for (i <- 1 to n.toInt) {\n            pq.enqueue((i, true))\n      \
    \      pq.enqueue((i, false))\n        }\n        var count = 0\n        while\
    \ (pq.size > 1) {\n            val (x, isLeft) = pq.dequeue\n            val (y,\
    \ isRight) = pq.dequeue\n            if (isLeft != isRight) count += 1\n     \
    \       pq.enqueue((x, isLeft))\n            pq.enqueue((y, isRight))\n      \
    \  }\n        count\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1659792756
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting position.\n        // Then, we can just count the\
    \ number of cars that are moving left to right\n        // and the number of cars\
    \ that are moving right to left.\n        // The number of collisions is the product\
    \ of these two numbers.\n        val cars = new Array[Long](2 * n.toInt)\n   \
    \     for (i <- 0 until n.toInt) {\n            cars(i) = i\n            cars(i\
    \ + n.toInt) = -i\n        }\n        scala.util.Sorting.quickSort(cars)\n   \
    \     var left = 0\n        var right = 0\n        for (i <- 0 until cars.length)\
    \ {\n            if (cars(i) >= 0) left += 1\n            else right += 1\n  \
    \      }\n        left * right\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1ugxvsl7.scala:32)\n\tat Problem.main(tmp1ugxvsl7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792751
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting position.\n        // Then, we can count the number\
    \ of collisions by counting the number of cars\n        // that are moving left\
    \ to right that are to the left of a car that's moving\n        // right to left.\n\
    \        //\n        // We can do this by using a Fenwick tree.\n        // We\
    \ insert the cars moving left to right into the Fenwick tree.\n        // Then,\
    \ we insert the cars moving right to left into the Fenwick tree.\n        // We\
    \ count the number of cars moving left to right that are to the left of a car\n\
    \        // moving right to left by using the Fenwick tree's prefix sum function.\n\
    \        //\n        // The total number of collisions is the sum of the number\
    \ of collisions for each car\n        // moving right to left.\n        //\n \
    \       // The total time complexity is O(n log n).\n        val fenwickTree =\
    \ new FenwickTree(n)\n        val cars = new Array[(Long, Boolean)](2 * n.toInt)\n\
    \        for (i <- 0 until n.toInt) {\n            cars(i) = (i, true)\n     \
    \       cars(i + n.toInt) = (i, false)\n        }\n        cars.sortBy(x => x._1)\n\
    \        var collisions = 0L\n        for (i <- 0 until 2 * n.toInt) {\n     \
    \       if (cars(i)._2) fenwickTree.insert(cars(i)._1.toInt)\n            else\
    \ collisions += fenwickTree.prefixSum(cars(i)._1.toInt)\n        }\n        collisions\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9y7nmd48.scala:28:30 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mfenwickTree\e[0m = \e[33mnew\e\
    [0m \e[35mFenwickTree\e[0m(n)\n\e[31m\e[31m   |\e[0m                         \
    \     ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                              Not found:\
    \ type FenwickTree\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659792750
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is a very simple\
    \ problem.  The key is to realize that the cars are\n        // moving at the\
    \ same speed.  As a result, the first car that starts moving\n        // left\
    \ to right will collide with the first car that starts moving right to left.\n\
    \        // The second car that starts moving left to right will collide with\
    \ the second\n        // car that starts moving right to left.  And so on.\n \
    \       // As a result, the number of collisions is simply the number of cars.\n\
    \        n\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6a5gdbj5.scala:22)\n\tat Problem.main(tmp6a5gdbj5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792751
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        val n2 = n * n\n     \
    \   val n3 = n2 * n\n        val n4 = n3 * n\n        val n5 = n4 * n\n      \
    \  val n6 = n5 * n\n        val n7 = n6 * n\n        val n8 = n7 * n\n       \
    \ val n9 = n8 * n\n        val n10 = n9 * n\n        val n11 = n10 * n\n     \
    \   val n12 = n11 * n\n        val n13 = n12 * n\n        val n14 = n13 * n\n\
    \        val n15 = n14 * n\n        val n16 = n15 * n\n        val n17 = n16 *\
    \ n\n        val n18 = n17 * n\n        val n19 = n18 * n\n        val n20 = n19\
    \ * n\n        val n21 = n20 * n\n        val n22 = n21 * n\n        val n23 =\
    \ n22 * n\n        val n24 = n23 * n\n        val n25 = n24 * n\n        val n26\
    \ = n25 * n\n        val n27 = n26 * n\n        val n28 = n27 * n\n        val\
    \ n29 = n28 * n\n        val n30 = n29 * n\n        val n31 = n30 * n\n      \
    \  val n32 = n31 * n\n        val n33 = n32 * n\n        val n34 = n33 * n\n \
    \       val n35 = n34 * n\n        val n36 = n35 * n\n        val n37 = n36 *\
    \ n\n        val n38 = n37 * n\n        val n39 = n38 * n\n        val n40 = n39\
    \ * n\n        val n41 = n40 * n\n        val n42 = n41 * n\n        val n43 =\
    \ n42 * n\n        val n44 = n43 * n\n        val n45 = n44 * n\n        val n46\
    \ = n45 * n\n        val n47 = n46 * n\n        val n48 = n47 * n\n        val\
    \ n49 = n48 * n\n        val n50 = n49 * n\n        val n51 = n50 * n\n      \
    \  val n52 = n51 * n\n        val\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpmw9d80df.scala:64:11 ---------------------------\e\
    [0m\e[0m\n\e[31m64 |\e[0m        \e[33mval\e[0m\n\e[31m\e[31m   |\e[0m       \
    \    ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpmw9d80df.scala:65:5 ---------------------\e\
    [0m\e[0m\n\e[31m65 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659792751
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is that we\
    \ can sort the cars by their starting position.\n        // Then, we can iterate\
    \ through the cars from left to right, and keep track of the\n        // number\
    \ of cars that are moving right to left that are to the left of the car\n    \
    \    // we are currently iterating through.  This number is the number of collisions\n\
    \        // that the car we are currently iterating through has.\n        val\
    \ cars = Array.ofDim[Long](2 * n.toInt)\n        for (i <- 0 until n.toInt) {\n\
    \            cars(i) = i\n            cars(i + n.toInt) = -i\n        }\n    \
    \    scala.util.Sorting.quickSort(cars)\n        var collisions = 0L\n       \
    \ var leftCars = 0\n        for (i <- 0 until 2 * n.toInt) {\n            if (cars(i)\
    \ < 0) leftCars += 1\n            else collisions += leftCars\n        }\n   \
    \     collisions\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6965tlp3.scala:33)\n\tat Problem.main(tmp6965tlp3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792752
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the cars by their starting position.\n        // Then, we can just iterate through\
    \ the cars and count the number of cars\n        // that are moving in the opposite\
    \ direction.\n        // The time complexity is O(n log n).\n        val cars\
    \ = Array.fill(n.toInt)(0)\n        for (i <- 0 until n.toInt) cars(i) = i\n \
    \       val sortedCars = cars.sortWith((a, b) => a < b)\n        var result =\
    \ 0L\n        for (i <- 0 until n.toInt) {\n            val car = sortedCars(i)\n\
    \            if (car < n - car) result += car\n            else result += n -\
    \ car - 1\n        }\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmph66naslg.scala:29)\n\tat Problem.main(tmph66naslg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792752
