language: scala
name: HumanEval_87_get_row
results:
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // Fill up this function body\n\
    \        // 'lst' is a list of lists, each list is a row\n        // 'x' is the\
    \ number to be searched\n        // Return a list of tuples, each tuple is a coordinate\
    \ - (row, column)\n        // Sort coordinates initially by rows in ascending\
    \ order.\n        // Also, sort coordinates of the row by columns in descending\
    \ order.\n        // If the number is not found, return an empty list.\n     \
    \   var result = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length)\
    \ {\n            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith(_._1 < _._1).sortWith(_._2\
    \ > _._2)\n    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptkkpcdaf.scala:38)\n\tat Problem.main(tmptkkpcdaf.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659804084
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = (i, j) :: result\n                }\n\
    \            }\n        }\n        result.sortWith((a, b) => a._1 < b._1 || (a._1\
    \ == b._1 && a._2 > b._2))\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804084
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => {\n\
    \            if (a._1 < b._1) {\n                true\n            } else if (a._1\
    \ == b._1) {\n                a._2 > b._2\n            } else {\n            \
    \    false\n            }\n        })\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804084
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => a._1\
    \ < b._1 || (a._1 == b._1 && a._2 > b._2))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804084
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // Write your code here\n\
    \        var result : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n\
    \        for (i <- 0 until lst.length) {\n            for (j <- 0 until lst(i).length)\
    \ {\n                if (lst(i)(j) == x) {\n                    result = result\
    \ :+ (i.toLong, j.toLong)\n                }\n            }\n        }\n     \
    \   result.sortWith((a, b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804084
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // Fill up this function body\n\
    \        // 'lst' is a nested list, which is similar to matrix, however, unlike\
    \ matrices,\n        // each row may contain a different number of columns.\n\
    \        // 'x' is an integer\n        // You have to return list of tuples, [(x1,\
    \ y1), (x2, y2) ...] such that\n        // each tuple is a coordinate - (row,\
    \ columns), starting with 0.\n        // Sort coordinates initially by rows in\
    \ ascending order.\n        // Also, sort coordinates of the row by columns in\
    \ descending order.\n        var result = List[Tuple2[Long, Long]]()\n       \
    \ for (i <- 0 until lst.length) {\n            for (j <- 0 until lst(i).length)\
    \ {\n                if (lst(i)(j) == x) {\n                    result = result\
    \ :+ (i.toLong, j.toLong)\n                }\n            }\n        }\n     \
    \   result.sortWith(_._1 < _._1).sortWith(_._2 > _._2)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpiizgyz8f.scala:39)\n\tat Problem.main(tmpiizgyz8f.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659804084
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => (a._1\
    \ < b._1) || (a._1 == b._1 && a._2 > b._2))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804084
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => a._1\
    \ < b._1 || (a._1 == b._1 && a._2 > b._2))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804084
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => {\n\
    \            if (a._1 == b._1) {\n                a._2 > b._2\n            } else\
    \ {\n                a._1 < b._1\n            }\n        })\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804084
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // Fill up this function body\n\
    \        // 'lst' is a nested list, similar to matrix,\n        // but unlike\
    \ matrix, each row may contain a different number of columns.\n        // 'x'\
    \ is an integer.\n        // You have to find all the integers 'x' in the list,\n\
    \        // and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n  \
    \      // each tuple is a coordinate - (row, columns), starting with 0.\n    \
    \    // Sort coordinates initially by rows in ascending order.\n        // Also,\
    \ sort coordinates of the row by columns in descending order.\n        // If you\
    \ find a coordinate (row, column) of x,\n        // then you have to add it to\
    \ the list,\n        // and return the list.\n        // If you don't find any\
    \ coordinate of x,\n        // then return an empty list.\n        // Note: You\
    \ have to write this function without using any inbuilt functions.\n        //\
    \ Note: You have to write this function without using any mutable data structures.\n\
    \        // Note: You have to write this function without using any mutable variables.\n\
    \        // Note: You have to write this function without using any mutable functions.\n\
    \        // Note: You have to write this function without using any mutable classes.\n\
    \        // Note: You have to write this function without using any mutable objects.\n\
    \        // Note: You have to write this function without using any mutable traits.\n\
    \        // Note: You have to write this function without using any mutable packages.\n\
    \        // Note: You have to write this function without using any mutable imports.\n\
    \        // Note: You have to write this function without using any mutable libraries.\n\
    \        // Note: You have to write this function without using any mutable frameworks.\n\
    \        // Note: You have to write this function without using any mutable platforms.\n\
    \        // Note: You have to write this function without using any mutable languages.\n\
    \        // Note: You have to write this function without using any mutable paradigms.\n\
    \        // Note: You have to write this function without using any mutable algorithms.\n\
    \        // Note: You have to write this function without using any mutable data.\n\
    \        // Note: You have to write this function without using any mutable code.\n\
    \       \n    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpygvasejj.scala:19:78\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m    \e[33mdef\e[0m \e[36mgetRow\e\
    [0m(\e[36mlst\e[0m : \e[35mList\e[0m[\e[35mList\e[0m[\e[35mLong\e[0m]], \e[36mx\e\
    [0m : \e[35mLong\e[0m) : \e[35mList\e[0m[\e[35mTuple2\e[0m[\e[35mLong\e[0m, \e\
    [35mLong\e[0m]] = {\n\e[31m\e[31m   |\e[0m                                   \
    \                                           ^\e[0m\n\e[31m   |\e[0m          \
    \                                  Found:    Unit\n\e[31m   |\e[0m           \
    \                                 Required: List[(Long, Long)]\n\e[31m20 |\e[0m\
    \        \e[34m// Fill up this function body\e[0m\n\e[31m21 |\e[0m        \e[34m//\
    \ 'lst' is a nested list, similar to matrix,\e[0m\n\e[31m22 |\e[0m        \e[34m//\
    \ but unlike matrix, each row may contain a different number of columns.\e[0m\n\
    \e[31m23 |\e[0m        \e[34m// 'x' is an integer.\e[0m\n\e[31m24 |\e[0m     \
    \   \e[34m// You have to find all the integers 'x' in the list,\e[0m\n\e[31m25\
    \ |\e[0m        \e[34m// and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\e[0m\n\e[31m26 |\e[0m        \e[34m// each tuple is a coordinate - (row,\
    \ columns), starting with 0.\e[0m\n\e[31m27 |\e[0m        \e[34m// Sort coordinates\
    \ initially by rows in ascending order.\e[0m\n\e[31m28 |\e[0m        \e[34m//\
    \ Also, sort coordinates of the row by columns in descending order.\e[0m\n\e[31m29\
    \ |\e[0m        \e[34m// If you find a coordinate (row, column) of x,\e[0m\n\e\
    [31m30 |\e[0m        \e[34m// then you have to add it to the list,\e[0m\n\e[31m31\
    \ |\e[0m        \e[34m// and return the list.\e[0m\n\e[31m32 |\e[0m        \e\
    [34m// If you don't find any coordinate of x,\e[0m\n\e[31m33 |\e[0m        \e\
    [34m// then return an empty list.\e[0m\n\e[31m34 |\e[0m        \e[34m// Note:\
    \ You have to write this function without using any inbuilt functions.\e[0m\n\e\
    [31m35 |\e[0m        \e[34m// Note: You have to write this function without using\
    \ any mutable data structures.\e[0m\n\e[31m36 |\e[0m        \e[34m// Note: You\
    \ have to write this function without using any mutable variables.\e[0m\n\e[31m37\
    \ |\e[0m        \e[34m// Note: You have to write this function with"
  stdout: ''
  timestamp: 1659804083
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = (i, j) :: result\n                }\n\
    \            }\n        }\n        result.sortWith((a, b) => a._1 < b._1 || (a._1\
    \ == b._1 && a._2 > b._2))\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804084
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List()\n        for (i <- 0 until lst.length) {\n            for (j\
    \ <- 0 until lst(i).length) {\n                if (lst(i)(j) == x) {\n       \
    \             result = result :+ (i.toLong, j.toLong)\n                }\n   \
    \         }\n        }\n        result.sortWith((a, b) => (a._1 < b._1) || (a._1\
    \ == b._1 && a._2 > b._2))\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804084
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // Fill up this function body\n\
    \        // 'lst' is a nested list, which is similar to matrix, however, unlike\
    \ matrices,\n        // each row may contain a different number of columns.\n\
    \        // 'x' is an integer.\n        // You have to find integers 'x' in the\
    \ list,\n        // and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    \        // each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \      // Sort coordinates initially by rows in ascending order.\n        // Also,\
    \ sort coordinates of the row by columns in descending order.\n        // If there\
    \ are no 'x' in the list, return empty list.\n        // If the list is empty,\
    \ return empty list.\n        // If the list is None, return empty list.\n   \
    \     // Note: You can use scala.math.Nil for empty list.\n        // Note: You\
    \ can use scala.math.None for empty list.\n        // Note: You can use scala.math.None\
    \ for empty list.\n        // Note: You can use scala.math.None for empty list.\n\
    \        // Note: You can use scala.math.None for empty list.\n        // Note:\
    \ You can use scala.math.None for empty list.\n        // Note: You can use scala.math.None\
    \ for empty list.\n        // Note: You can use scala.math.None for empty list.\n\
    \        // Note: You can use scala.math.None for empty list.\n        // Note:\
    \ You can use scala.math.None for empty list.\n        // Note: You can use scala.math.None\
    \ for empty list.\n        // Note: You can use scala.math.None for empty list.\n\
    \        // Note: You can use scala.math.None for empty list.\n        // Note:\
    \ You can use scala.math.None for empty list.\n        // Note: You can use scala.math.None\
    \ for empty list.\n        // Note: You can use scala.math.None for empty list.\n\
    \        // Note: You can use scala.math.None for empty list.\n        // Note:\
    \ You can use scala.math.None for empty list\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpm1jghle7.scala:19:78\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m    \e[33mdef\e[0m \e[36mgetRow\e\
    [0m(\e[36mlst\e[0m : \e[35mList\e[0m[\e[35mList\e[0m[\e[35mLong\e[0m]], \e[36mx\e\
    [0m : \e[35mLong\e[0m) : \e[35mList\e[0m[\e[35mTuple2\e[0m[\e[35mLong\e[0m, \e\
    [35mLong\e[0m]] = {\n\e[31m\e[31m   |\e[0m                                   \
    \                                           ^\e[0m\n\e[31m   |\e[0m          \
    \                                  Found:    Unit\n\e[31m   |\e[0m           \
    \                                 Required: List[(Long, Long)]\n\e[31m20 |\e[0m\
    \        \e[34m// Fill up this function body\e[0m\n\e[31m21 |\e[0m        \e[34m//\
    \ 'lst' is a nested list, which is similar to matrix, however, unlike matrices,\e\
    [0m\n\e[31m22 |\e[0m        \e[34m// each row may contain a different number of\
    \ columns.\e[0m\n\e[31m23 |\e[0m        \e[34m// 'x' is an integer.\e[0m\n\e[31m24\
    \ |\e[0m        \e[34m// You have to find integers 'x' in the list,\e[0m\n\e[31m25\
    \ |\e[0m        \e[34m// and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\e[0m\n\e[31m26 |\e[0m        \e[34m// each tuple is a coordinate - (row,\
    \ columns), starting with 0.\e[0m\n\e[31m27 |\e[0m        \e[34m// Sort coordinates\
    \ initially by rows in ascending order.\e[0m\n\e[31m28 |\e[0m        \e[34m//\
    \ Also, sort coordinates of the row by columns in descending order.\e[0m\n\e[31m29\
    \ |\e[0m        \e[34m// If there are no 'x' in the list, return empty list.\e\
    [0m\n\e[31m30 |\e[0m        \e[34m// If the list is empty, return empty list.\e\
    [0m\n\e[31m31 |\e[0m        \e[34m// If the list is None, return empty list.\e\
    [0m\n\e[31m32 |\e[0m        \e[34m// Note: You can use scala.math.Nil for empty\
    \ list.\e[0m\n\e[31m33 |\e[0m        \e[34m// Note: You can use scala.math.None\
    \ for empty list.\e[0m\n\e[31m34 |\e[0m        \e[34m// Note: You can use scala.math.None\
    \ for empty list.\e[0m\n\e[31m35 |\e[0m        \e[34m// Note: You can use scala.math.None\
    \ for empty list.\e[0m\n\e[31m36 |\e[0m        \e[34m// Note: You can use scala.math.None\
    \ for empty list.\e[0m\n\e[31m37 |\e[0m        \e[34m// Note: You can use scala.math.None\
    \ for empty list.\e[0"
  stdout: ''
  timestamp: 1659804082
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => a._1\
    \ < b._1 || (a._1 == b._1 && a._2 > b._2))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804084
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => {\n\
    \            if (a._1 < b._1) {\n                true\n            } else if (a._1\
    \ == b._1) {\n                a._2 > b._2\n            } else {\n            \
    \    false\n            }\n        })\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804084
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => (a._1\
    \ < b._1) || (a._1 == b._1 && a._2 > b._2))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804084
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            var row : List[Long] = lst(i)\n            for (j <- 0 until row.length)\
    \ {\n                if (row(j) == x) {\n                    result = result :+\
    \ (i.toLong, j.toLong)\n                }\n            }\n        }\n        result.sortWith((a,\
    \ b) => {\n            if (a._1 < b._1) {\n                true\n            }\
    \ else if (a._1 == b._1) {\n                a._2 > b._2\n            } else {\n\
    \                false\n            }\n        })\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804085
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // Fill up this function body\n\
    \        // 'lst' is a nested list, similar to matrix,\n        // 'x' is an integer\
    \ to be searched in the list\n        // Return a list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n        // each tuple is a coordinate - (row, columns),\
    \ starting with 0.\n        // Sort coordinates initially by rows in ascending\
    \ order.\n        // Also, sort coordinates of the row by columns in descending\
    \ order.\n        // If 'x' is not found in the list, return empty list.\n   \
    \     // If 'lst' is empty, return empty list.\n        // Note:\n        // You\
    \ can use built-in functions such as 'sortWith' and 'sorted'\n        // to sort\
    \ the list of tuples.\n        // You can use built-in functions such as 'zipWithIndex'\
    \ to get\n        // the index of elements in the list.\n        // You can use\
    \ built-in functions such as 'map' to apply a function\n        // to each element\
    \ of a list.\n        // You can use built-in functions such as 'filter' to filter\
    \ a list.\n        // You can use built-in functions such as 'flatMap' to flatten\
    \ a list.\n        // You can use built-in functions such as 'foldLeft' to fold\
    \ a list.\n        // You can use built-in functions such as 'foldRight' to fold\
    \ a list.\n        // You can use built-in functions such as 'fold' to fold a\
    \ list.\n        // You can use built-in functions such as 'reduceLeft' to reduce\
    \ a list.\n        // You can use built-in functions such as 'reduceRight' to\
    \ reduce a list.\n        // You can use built-in functions such as 'reduce' to\
    \ reduce a list.\n        // You can use built-in functions such as 'scanLeft'\
    \ to scan a list.\n        // You can use built-in functions such as 'scanRight'\
    \ to scan a list.\n        // You can use built-in functions such as 'scan' to\
    \ scan a list.\n        // You can use built-in functions such as 'mkString' to\
    \ convert a list\n        // to a string.\n        // You can use built-in functions\
    \ such as\n    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6pvo0w1f.scala:19:78\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m    \e[33mdef\e[0m \e[36mgetRow\e\
    [0m(\e[36mlst\e[0m : \e[35mList\e[0m[\e[35mList\e[0m[\e[35mLong\e[0m]], \e[36mx\e\
    [0m : \e[35mLong\e[0m) : \e[35mList\e[0m[\e[35mTuple2\e[0m[\e[35mLong\e[0m, \e\
    [35mLong\e[0m]] = {\n\e[31m\e[31m   |\e[0m                                   \
    \                                           ^\e[0m\n\e[31m   |\e[0m          \
    \                                  Found:    Unit\n\e[31m   |\e[0m           \
    \                                 Required: List[(Long, Long)]\n\e[31m20 |\e[0m\
    \        \e[34m// Fill up this function body\e[0m\n\e[31m21 |\e[0m        \e[34m//\
    \ 'lst' is a nested list, similar to matrix,\e[0m\n\e[31m22 |\e[0m        \e[34m//\
    \ 'x' is an integer to be searched in the list\e[0m\n\e[31m23 |\e[0m        \e\
    [34m// Return a list of tuples, [(x1, y1), (x2, y2) ...] such that\e[0m\n\e[31m24\
    \ |\e[0m        \e[34m// each tuple is a coordinate - (row, columns), starting\
    \ with 0.\e[0m\n\e[31m25 |\e[0m        \e[34m// Sort coordinates initially by\
    \ rows in ascending order.\e[0m\n\e[31m26 |\e[0m        \e[34m// Also, sort coordinates\
    \ of the row by columns in descending order.\e[0m\n\e[31m27 |\e[0m        \e[34m//\
    \ If 'x' is not found in the list, return empty list.\e[0m\n\e[31m28 |\e[0m  \
    \      \e[34m// If 'lst' is empty, return empty list.\e[0m\n\e[31m29 |\e[0m  \
    \      \e[34m// Note:\e[0m\n\e[31m30 |\e[0m        \e[34m// You can use built-in\
    \ functions such as 'sortWith' and 'sorted'\e[0m\n\e[31m31 |\e[0m        \e[34m//\
    \ to sort the list of tuples.\e[0m\n\e[31m32 |\e[0m        \e[34m// You can use\
    \ built-in functions such as 'zipWithIndex' to get\e[0m\n\e[31m33 |\e[0m     \
    \   \e[34m// the index of elements in the list.\e[0m\n\e[31m34 |\e[0m        \e\
    [34m// You can use built-in functions such as 'map' to apply a function\e[0m\n\
    \e[31m35 |\e[0m        \e[34m// to each element of a list.\e[0m\n\e[31m36 |\e\
    [0m        \e[34m// You can use built-in functions such as 'filter' to filter\
    \ a list.\e[0m\n\e[31m37 |\e[0m        \e[34m// You can use built-in functions\
    \ such as 'flatMap' to flatten a list.\e[0m\n\e[31m38 |\e[0m        \e[34m/"
  stdout: ''
  timestamp: 1659804083
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => a._1\
    \ < b._1 || (a._1 == b._1 && a._2 > b._2))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804084
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // Fill up this function body\n\
    \        // 'lst' is a list of lists, and 'x' is the element to be searched\n\
    \        // Return a list of tuples, each tuple is a coordinate - (row, column)\n\
    \        // Sort the tuples initially by rows in ascending order\n        // Also,\
    \ sort coordinates of the row by columns in descending order\n        // If 'x'\
    \ is not found in 'lst', return an empty list\n        // If 'lst' is empty, return\
    \ an empty list\n        // If 'lst' is a list of empty lists, return an empty\
    \ list\n        var result = List[Tuple2[Long, Long]]()\n        var i = 0\n \
    \       for (row <- lst) {\n            var j = 0\n            for (col <- row)\
    \ {\n                if (col == x) {\n                    result = result :+ (i,\
    \ j)\n                }\n                j += 1\n            }\n            i\
    \ += 1\n        }\n        result.sortBy(x => (x._1, -x._2))\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804084
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // Fill up this function body\n\
    \        // 'lst' is a nested list, similar to matrix, but each row may contain\
    \ a different number of columns.\n        // 'x' is an integer to be found in\
    \ the list.\n        // Return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    \        // each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \      // Sort coordinates initially by rows in ascending order.\n        // Also,\
    \ sort coordinates of the row by columns in descending order.\n        var result\
    \ : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0\
    \ until lst.length) {\n            for (j <- 0 until lst(i).length) {\n      \
    \          if (lst(i)(j) == x) {\n                    result = result :+ (i.toLong,\
    \ j.toLong)\n                }\n            }\n        }\n        result.sortWith((a,\
    \ b) => {\n            if (a._1 == b._1) {\n                a._2 > b._2\n    \
    \        } else {\n                a._1 < b._1\n            }\n        })\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804084
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => {\n\
    \            if (a._1 == b._1) {\n                a._2 > b._2\n            } else\
    \ {\n                a._1 < b._1\n            }\n        })\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804084
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => (a._1\
    \ < b._1) || (a._1 == b._1 && a._2 > b._2))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804084
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => (a._1\
    \ < b._1) || (a._1 == b._1 && a._2 > b._2))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804084
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // Fill up this function body\n\
    \        // 'lst' is a nested list, which is similar to matrix, however, unlike\
    \ matrices,\n        // each row may contain a different number of columns.\n\
    \        // 'x' is an integer.\n        // You have to find integers 'x' in the\
    \ list,\n        // and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    \        // each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \      // Sort coordinates initially by rows in ascending order.\n        // Also,\
    \ sort coordinates of the row by columns in descending order.\n        // If x\
    \ is not found in the list, return empty list.\n        // If the list is empty,\
    \ return empty list.\n        // If the list is None, return empty list.\n   \
    \     // Note:\n        // The list is not a matrix, it is a nested list.\n  \
    \      // Each row may contain a different number of columns.\n        // The\
    \ list may contain empty rows.\n        // The list may contain empty columns.\n\
    \        // The list may contain empty rows and empty columns.\n        // The\
    \ list may contain None.\n        // The list may contain None and empty rows\
    \ and empty columns.\n        // The list may contain None and empty rows and\
    \ empty columns and None.\n        // The list may contain None and empty rows\
    \ and empty columns and None and None.\n        // The list may contain None and\
    \ empty rows and empty columns and None and None and None.\n        // The list\
    \ may contain None and empty rows and empty columns and None and None and None\
    \ and None.\n        // The list may contain None and empty rows and empty columns\
    \ and None and None and None and None and None.\n        // The list may contain\
    \ None and empty rows and empty columns and None and None and None and None and\
    \ None and None.\n        // The list may contain None and empty rows and empty\
    \ columns and None and None and None and None and None and None and None.\n  \
    \      // The list may contain None and empty rows and empty columns and None\
    \ and None and None and None and None and None and None and None.\n        //\
    \ The list may contain None and empty rows and empty columns and None and None\
    \ and None and None and None and None and None and None and None.\n        //\
    \ The list may contain None and empty\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpef2xnv5e.scala:19:78\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m    \e[33mdef\e[0m \e[36mgetRow\e\
    [0m(\e[36mlst\e[0m : \e[35mList\e[0m[\e[35mList\e[0m[\e[35mLong\e[0m]], \e[36mx\e\
    [0m : \e[35mLong\e[0m) : \e[35mList\e[0m[\e[35mTuple2\e[0m[\e[35mLong\e[0m, \e\
    [35mLong\e[0m]] = {\n\e[31m\e[31m   |\e[0m                                   \
    \                                           ^\e[0m\n\e[31m   |\e[0m          \
    \                                  Found:    Unit\n\e[31m   |\e[0m           \
    \                                 Required: List[(Long, Long)]\n\e[31m20 |\e[0m\
    \        \e[34m// Fill up this function body\e[0m\n\e[31m21 |\e[0m        \e[34m//\
    \ 'lst' is a nested list, which is similar to matrix, however, unlike matrices,\e\
    [0m\n\e[31m22 |\e[0m        \e[34m// each row may contain a different number of\
    \ columns.\e[0m\n\e[31m23 |\e[0m        \e[34m// 'x' is an integer.\e[0m\n\e[31m24\
    \ |\e[0m        \e[34m// You have to find integers 'x' in the list,\e[0m\n\e[31m25\
    \ |\e[0m        \e[34m// and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\e[0m\n\e[31m26 |\e[0m        \e[34m// each tuple is a coordinate - (row,\
    \ columns), starting with 0.\e[0m\n\e[31m27 |\e[0m        \e[34m// Sort coordinates\
    \ initially by rows in ascending order.\e[0m\n\e[31m28 |\e[0m        \e[34m//\
    \ Also, sort coordinates of the row by columns in descending order.\e[0m\n\e[31m29\
    \ |\e[0m        \e[34m// If x is not found in the list, return empty list.\e[0m\n\
    \e[31m30 |\e[0m        \e[34m// If the list is empty, return empty list.\e[0m\n\
    \e[31m31 |\e[0m        \e[34m// If the list is None, return empty list.\e[0m\n\
    \e[31m32 |\e[0m        \e[34m// Note:\e[0m\n\e[31m33 |\e[0m        \e[34m// The\
    \ list is not a matrix, it is a nested list.\e[0m\n\e[31m34 |\e[0m        \e[34m//\
    \ Each row may contain a different number of columns.\e[0m\n\e[31m35 |\e[0m  \
    \      \e[34m// The list may contain empty rows.\e[0m\n\e[31m36 |\e[0m       \
    \ \e[34m// The list may contain empty columns.\e[0m\n\e[31m37 |\e[0m        \e\
    [34m// The list may contain empty rows and empty columns.\e[0m\n\e[31m38 |\e[0m\
    \        \e[34m// The list may contain None.\e[0m\n\e[31m39 |\e[0m "
  stdout: ''
  timestamp: 1659804082
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // Fill up this function body\n\
    \        // 'lst' is a nested list, similar to matrix, but unlike matrices,\n\
    \        // each row may contain a different number of columns.\n        // 'x'\
    \ is an integer.\n        // Return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n        // each tuple is a coordinate - (row, columns), starting with\
    \ 0.\n        // Sort coordinates initially by rows in ascending order.\n    \
    \    // Also, sort coordinates of the row by columns in descending order.\n  \
    \      // If 'x' is not found in the list, return empty list.\n        // If 'lst'\
    \ is empty, return empty list.\n        // If 'lst' is a list of empty lists,\
    \ return empty list.\n        // For example,\n        // >>> getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n        //\
    \ (List[Tuple2[Long, Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n\
    \        // >>> getRow((List[List[Long]]()), (1l))\n        // (List[Tuple2[Long,\
    \ Long]]())\n        // >>> getRow((List[List[Long]](List[Long](), List[Long](1l.toLong),\
    \ List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n        // (List[Tuple2[Long,\
    \ Long]]((2l, 2l)))\n        // >>> getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong,\n    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5yb7kvmn.scala:19:78\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m    \e[33mdef\e[0m \e[36mgetRow\e\
    [0m(\e[36mlst\e[0m : \e[35mList\e[0m[\e[35mList\e[0m[\e[35mLong\e[0m]], \e[36mx\e\
    [0m : \e[35mLong\e[0m) : \e[35mList\e[0m[\e[35mTuple2\e[0m[\e[35mLong\e[0m, \e\
    [35mLong\e[0m]] = {\n\e[31m\e[31m   |\e[0m                                   \
    \                                           ^\e[0m\n\e[31m   |\e[0m          \
    \                                  Found:    Unit\n\e[31m   |\e[0m           \
    \                                 Required: List[(Long, Long)]\n\e[31m20 |\e[0m\
    \        \e[34m// Fill up this function body\e[0m\n\e[31m21 |\e[0m        \e[34m//\
    \ 'lst' is a nested list, similar to matrix, but unlike matrices,\e[0m\n\e[31m22\
    \ |\e[0m        \e[34m// each row may contain a different number of columns.\e\
    [0m\n\e[31m23 |\e[0m        \e[34m// 'x' is an integer.\e[0m\n\e[31m24 |\e[0m\
    \        \e[34m// Return list of tuples, [(x1, y1), (x2, y2) ...] such that\e\
    [0m\n\e[31m25 |\e[0m        \e[34m// each tuple is a coordinate - (row, columns),\
    \ starting with 0.\e[0m\n\e[31m26 |\e[0m        \e[34m// Sort coordinates initially\
    \ by rows in ascending order.\e[0m\n\e[31m27 |\e[0m        \e[34m// Also, sort\
    \ coordinates of the row by columns in descending order.\e[0m\n\e[31m28 |\e[0m\
    \        \e[34m// If 'x' is not found in the list, return empty list.\e[0m\n\e\
    [31m29 |\e[0m        \e[34m// If 'lst' is empty, return empty list.\e[0m\n\e[31m30\
    \ |\e[0m        \e[34m// If 'lst' is a list of empty lists, return empty list.\e\
    [0m\n\e[31m31 |\e[0m        \e[34m// For example,\e[0m\n\e[31m32 |\e[0m      \
    \  \e[34m// >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\e[0m\n\e[31m33 |\e[0m        \e[34m//\
    \ (List[Tuple2[Long, Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\e\
    [0m\n\e[31m34 |\e[0m        \e[34m// >>> getRow((List[List[Long]]()), (1l))\e\
    [0m\n\e[31m35 |\e[0m        \e[34m// (List[Tuple2[Long"
  stdout: ''
  timestamp: 1659804083
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // Fill up this function body\n\
    \        // 'lst' is a nested list, similar to matrix,\n        // however, unlike\
    \ matrices, each row may contain a different number of columns.\n        // 'x'\
    \ is an integer.\n        // You have to find integers x in the list,\n      \
    \  // and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n        //\
    \ each tuple is a coordinate - (row, columns), starting with 0.\n        // Sort\
    \ coordinates initially by rows in ascending order.\n        // Also, sort coordinates\
    \ of the row by columns in descending order.\n        // If x is not found in\
    \ the list, return empty list.\n        // If the list is empty, return empty\
    \ list.\n        // If the list is not empty, but contains empty rows,\n     \
    \   // return empty list.\n        // If the list is not empty, and contains non-empty\
    \ rows,\n        // return list of tuples.\n        // If the list is not empty,\
    \ and contains non-empty rows,\n        // and x is found in the list, return\
    \ list of tuples.\n        // If the list is not empty, and contains non-empty\
    \ rows,\n        // and x is not found in the list, return empty list.\n     \
    \   // If the list is not empty, and contains non-empty rows,\n        // and\
    \ x is found in the list, return list of tuples.\n        // If the list is not\
    \ empty, and contains non-empty rows,\n        // and x is found in the list,\
    \ return list of tuples.\n        // If the list is not empty, and contains non-empty\
    \ rows,\n        // and x is found in the list, return list of tuples.\n     \
    \   // If the list is not empty, and contains non-empty rows,\n        // and\
    \ x is found in the list, return list of tuples.\n        // If the list is not\
    \ empty, and contains non-empty rows,\n        // and x is found in the list,\
    \ return list of tuples.\n        // If the list is not empty, and contains non-empty\
    \ rows,\n        // and x is found in the list, return list of tuples.\n     \
    \   // If the list is not empty, and contains non-empty rows,\n        // and\
    \ x is found\n    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmppdngwzd4.scala:19:78\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m    \e[33mdef\e[0m \e[36mgetRow\e\
    [0m(\e[36mlst\e[0m : \e[35mList\e[0m[\e[35mList\e[0m[\e[35mLong\e[0m]], \e[36mx\e\
    [0m : \e[35mLong\e[0m) : \e[35mList\e[0m[\e[35mTuple2\e[0m[\e[35mLong\e[0m, \e\
    [35mLong\e[0m]] = {\n\e[31m\e[31m   |\e[0m                                   \
    \                                           ^\e[0m\n\e[31m   |\e[0m          \
    \                                  Found:    Unit\n\e[31m   |\e[0m           \
    \                                 Required: List[(Long, Long)]\n\e[31m20 |\e[0m\
    \        \e[34m// Fill up this function body\e[0m\n\e[31m21 |\e[0m        \e[34m//\
    \ 'lst' is a nested list, similar to matrix,\e[0m\n\e[31m22 |\e[0m        \e[34m//\
    \ however, unlike matrices, each row may contain a different number of columns.\e\
    [0m\n\e[31m23 |\e[0m        \e[34m// 'x' is an integer.\e[0m\n\e[31m24 |\e[0m\
    \        \e[34m// You have to find integers x in the list,\e[0m\n\e[31m25 |\e\
    [0m        \e[34m// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\e\
    [0m\n\e[31m26 |\e[0m        \e[34m// each tuple is a coordinate - (row, columns),\
    \ starting with 0.\e[0m\n\e[31m27 |\e[0m        \e[34m// Sort coordinates initially\
    \ by rows in ascending order.\e[0m\n\e[31m28 |\e[0m        \e[34m// Also, sort\
    \ coordinates of the row by columns in descending order.\e[0m\n\e[31m29 |\e[0m\
    \        \e[34m// If x is not found in the list, return empty list.\e[0m\n\e[31m30\
    \ |\e[0m        \e[34m// If the list is empty, return empty list.\e[0m\n\e[31m31\
    \ |\e[0m        \e[34m// If the list is not empty, but contains empty rows,\e\
    [0m\n\e[31m32 |\e[0m        \e[34m// return empty list.\e[0m\n\e[31m33 |\e[0m\
    \        \e[34m// If the list is not empty, and contains non-empty rows,\e[0m\n\
    \e[31m34 |\e[0m        \e[34m// return list of tuples.\e[0m\n\e[31m35 |\e[0m \
    \       \e[34m// If the list is not empty, and contains non-empty rows,\e[0m\n\
    \e[31m36 |\e[0m        \e[34m// and x is found in the list, return list of tuples.\e\
    [0m\n\e[31m37 |\e[0m        \e[34m// If the list is not empty, and contains non-empty\
    \ rows,\e[0m\n\e[31m38 |\e[0m        \e[34m// and x is not"
  stdout: ''
  timestamp: 1659804082
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            var row : List[Long] = lst(i)\n            for (j <- 0 until row.length)\
    \ {\n                if (row(j) == x) {\n                    result = result :+\
    \ (i.toLong, j.toLong)\n                }\n            }\n        }\n        result.sortWith((a,\
    \ b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804084
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List()\n        for (i <- 0 to lst.length - 1) {\n            for (j\
    \ <- 0 to lst(i).length - 1) {\n                if (lst(i)(j) == x) {\n      \
    \              result = result :+ (i.toLong, j.toLong)\n                }\n  \
    \          }\n        }\n        result.sortWith((a, b) => {\n            if (a._1\
    \ == b._1) {\n                a._2 > b._2\n            } else {\n            \
    \    a._1 < b._1\n            }\n        })\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804084
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List()\n        for (i <- 0 until lst.length) {\n            for (j\
    \ <- 0 until lst(i).length) {\n                if (lst(i)(j) == x) {\n       \
    \             result = (i, j) :: result\n                }\n            }\n  \
    \      }\n        result.sortWith((a, b) => a._1 < b._1 || (a._1 == b._1 && a._2\
    \ > b._2))\n    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804085
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result ::: List[Tuple2[Long, Long]]((i.toLong,\
    \ j.toLong))\n                }\n            }\n        }\n        result.sortWith((a,\
    \ b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804085
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // Fill up this function body\n\
    \        // 'lst' is a nested list, similar to matrix\n        // 'x' is an integer\n\
    \        // Return a list of tuples, [(x1, y1), (x2, y2) ...]\n        // such\
    \ that each tuple is a coordinate - (row, columns),\n        // starting with\
    \ 0.\n        // Sort coordinates initially by rows in ascending order.\n    \
    \    // Also, sort coordinates of the row by columns in descending order.\n  \
    \      // If you don't find x in the list, return empty list.\n        var result\
    \ = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n    \
    \        var row = lst(i)\n            for (j <- 0 until row.length) {\n     \
    \           if (row(j) == x) {\n                    result = result :+ (i.toLong,\
    \ j.toLong)\n                }\n            }\n        }\n        result.sortWith((a,\
    \ b) => if (a._1 < b._1) true else if (a._1 == b._1) a._2 > b._2 else false)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804084
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // Fill up this function body\n\
    \        // `lst` is a nested list, similar to matrix,\n        // however, unlike\
    \ matrices, each row may contain a different number of columns.\n        // `x`\
    \ is an integer to be found in the list.\n        // You are required to return\
    \ a list of tuples,\n        // [(x1, y1), (x2, y2) ...] such that\n        //\
    \ each tuple is a coordinate - (row, columns), starting with 0.\n        // Sort\
    \ coordinates initially by rows in ascending order.\n        // Also, sort coordinates\
    \ of the row by columns in descending order.\n        // If `x` is not found in\
    \ the list, return an empty list.\n        // If `lst` is empty, return an empty\
    \ list.\n        // Note: You are not required to handle the case\n        //\
    \ when `x` is not found in the list.\n        // You are not required to handle\
    \ the case when `lst` is empty.\n        // You are not required to handle the\
    \ case when `lst` is not a nested list.\n        // You are not required to handle\
    \ the case when `lst` is not a nested list of integers.\n        // You are not\
    \ required to handle the case when `lst` is not a nested list of integers of the\
    \ same type as `x`.\n        // You are not required to handle the case when `lst`\
    \ is not a nested list of integers of the same type as `x` and `y`.\n        //\
    \ You are not required to handle the case when `lst` is not a nested list of integers\
    \ of the same type as `x`, `y` and `z`.\n        // You are not required to handle\
    \ the case when `lst` is not a nested list of integers of the same type as `x`,\
    \ `y`, `z` and `w`.\n        // You are not required to handle the case when `lst`\
    \ is not a nested list of integers of the same type as `x`, `y`, `z`, `w` and\
    \ `v`.\n        // You are not required to handle the case when `lst` is not a\
    \ nested list of integers of the same type as `x`, `y`, `z`, `w`, `v` and `u`.\n\
    \        // You are not required to handle\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5vicakva.scala:19:78\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m    \e[33mdef\e[0m \e[36mgetRow\e\
    [0m(\e[36mlst\e[0m : \e[35mList\e[0m[\e[35mList\e[0m[\e[35mLong\e[0m]], \e[36mx\e\
    [0m : \e[35mLong\e[0m) : \e[35mList\e[0m[\e[35mTuple2\e[0m[\e[35mLong\e[0m, \e\
    [35mLong\e[0m]] = {\n\e[31m\e[31m   |\e[0m                                   \
    \                                           ^\e[0m\n\e[31m   |\e[0m          \
    \                                  Found:    Unit\n\e[31m   |\e[0m           \
    \                                 Required: List[(Long, Long)]\n\e[31m20 |\e[0m\
    \        \e[34m// Fill up this function body\e[0m\n\e[31m21 |\e[0m        \e[34m//\
    \ `lst` is a nested list, similar to matrix,\e[0m\n\e[31m22 |\e[0m        \e[34m//\
    \ however, unlike matrices, each row may contain a different number of columns.\e\
    [0m\n\e[31m23 |\e[0m        \e[34m// `x` is an integer to be found in the list.\e\
    [0m\n\e[31m24 |\e[0m        \e[34m// You are required to return a list of tuples,\e\
    [0m\n\e[31m25 |\e[0m        \e[34m// [(x1, y1), (x2, y2) ...] such that\e[0m\n\
    \e[31m26 |\e[0m        \e[34m// each tuple is a coordinate - (row, columns), starting\
    \ with 0.\e[0m\n\e[31m27 |\e[0m        \e[34m// Sort coordinates initially by\
    \ rows in ascending order.\e[0m\n\e[31m28 |\e[0m        \e[34m// Also, sort coordinates\
    \ of the row by columns in descending order.\e[0m\n\e[31m29 |\e[0m        \e[34m//\
    \ If `x` is not found in the list, return an empty list.\e[0m\n\e[31m30 |\e[0m\
    \        \e[34m// If `lst` is empty, return an empty list.\e[0m\n\e[31m31 |\e\
    [0m        \e[34m// Note: You are not required to handle the case\e[0m\n\e[31m32\
    \ |\e[0m        \e[34m// when `x` is not found in the list.\e[0m\n\e[31m33 |\e\
    [0m        \e[34m// You are not required to handle the case when `lst` is empty.\e\
    [0m\n\e[31m34 |\e[0m        \e[34m// You are not required to handle the case when\
    \ `lst` is not a nested list.\e[0m\n\e[31m35 |\e[0m        \e[34m// You are not\
    \ required to handle the case when `lst` is not a nested list of integers.\e[0m\n\
    \e[31m36 |\e[0m        \e[34m// You are not required to handle the case when `lst`\
    \ is not a nested list of intege"
  stdout: ''
  timestamp: 1659804092
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            var row : List[Long] = lst(i)\n            for (j <- 0 until row.length)\
    \ {\n                if (row(j) == x) {\n                    result = result :+\
    \ (i.toLong, j.toLong)\n                }\n            }\n        }\n        result.sortWith((a,\
    \ b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804084
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // Fill up this function body\n\
    \        // 'lst' is a list of lists, and 'x' is the integer to be found\n   \
    \     // Return a list of tuples, each tuple is a coordinate - (row, columns)\n\
    \        // Sort coordinates initially by rows in ascending order.\n        //\
    \ Also, sort coordinates of the row by columns in descending order.\n        //\
    \ If 'x' is not found in the list, return an empty list.\n        // If 'lst'\
    \ is empty, return an empty list.\n        // If 'lst' is a list of empty lists,\
    \ return an empty list.\n        // If 'lst' is a list of lists, and 'x' is found\
    \ in the list,\n        // return a list of tuples, each tuple is a coordinate\
    \ - (row, columns)\n        // Sort coordinates initially by rows in ascending\
    \ order.\n        // Also, sort coordinates of the row by columns in descending\
    \ order.\n        var result : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n\
    \        for (i <- 0 until lst.length) {\n            for (j <- 0 until lst(i).length)\
    \ {\n                if (lst(i)(j) == x) {\n                    result = result\
    \ :+ (i.toLong, j.toLong)\n                }\n            }\n        }\n     \
    \   result.sortWith((a, b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804095
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => {\n\
    \            if (a._1 == b._1) {\n                a._2 > b._2\n            } else\
    \ {\n                a._1 < b._1\n            }\n        })\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804084
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // Fill up this function body\n\
    \        // 'lst' is a nested list, which is similar to matrix,\n        // however,\
    \ unlike matrices, each row may contain a different number of columns.\n     \
    \   // 'x' is an integer.\n        // You have to find integers 'x' in the list,\n\
    \        // and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n  \
    \      // each tuple is a coordinate - (row, columns), starting with 0.\n    \
    \    // Sort coordinates initially by rows in ascending order.\n        // Also,\
    \ sort coordinates of the row by columns in descending order.\n        // If there\
    \ is no 'x' in the list, return empty list.\n        // If the list is empty,\
    \ return empty list.\n        // If the list is a list of empty lists, return\
    \ empty list.\n        // For example,\n        // >>> getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n        //\
    \ (List[Tuple2[Long, Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n\
    \        // >>> getRow((List[List[Long]]()), (1l))\n        // (List[Tuple2[Long,\
    \ Long]]())\n        // >>> getRow((List[List[Long]](List[Long](), List[Long](1l.toLong),\
    \ List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n        // (List[Tuple2[Long,\
    \ Long]]((2l, 2l)))\n        // >>> getRow((List[List[Long]](List\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpg5_wtslr.scala:19:78\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m    \e[33mdef\e[0m \e[36mgetRow\e\
    [0m(\e[36mlst\e[0m : \e[35mList\e[0m[\e[35mList\e[0m[\e[35mLong\e[0m]], \e[36mx\e\
    [0m : \e[35mLong\e[0m) : \e[35mList\e[0m[\e[35mTuple2\e[0m[\e[35mLong\e[0m, \e\
    [35mLong\e[0m]] = {\n\e[31m\e[31m   |\e[0m                                   \
    \                                           ^\e[0m\n\e[31m   |\e[0m          \
    \                                  Found:    Unit\n\e[31m   |\e[0m           \
    \                                 Required: List[(Long, Long)]\n\e[31m20 |\e[0m\
    \        \e[34m// Fill up this function body\e[0m\n\e[31m21 |\e[0m        \e[34m//\
    \ 'lst' is a nested list, which is similar to matrix,\e[0m\n\e[31m22 |\e[0m  \
    \      \e[34m// however, unlike matrices, each row may contain a different number\
    \ of columns.\e[0m\n\e[31m23 |\e[0m        \e[34m// 'x' is an integer.\e[0m\n\e\
    [31m24 |\e[0m        \e[34m// You have to find integers 'x' in the list,\e[0m\n\
    \e[31m25 |\e[0m        \e[34m// and return list of tuples, [(x1, y1), (x2, y2)\
    \ ...] such that\e[0m\n\e[31m26 |\e[0m        \e[34m// each tuple is a coordinate\
    \ - (row, columns), starting with 0.\e[0m\n\e[31m27 |\e[0m        \e[34m// Sort\
    \ coordinates initially by rows in ascending order.\e[0m\n\e[31m28 |\e[0m    \
    \    \e[34m// Also, sort coordinates of the row by columns in descending order.\e\
    [0m\n\e[31m29 |\e[0m        \e[34m// If there is no 'x' in the list, return empty\
    \ list.\e[0m\n\e[31m30 |\e[0m        \e[34m// If the list is empty, return empty\
    \ list.\e[0m\n\e[31m31 |\e[0m        \e[34m// If the list is a list of empty lists,\
    \ return empty list.\e[0m\n\e[31m32 |\e[0m        \e[34m// For example,\e[0m\n\
    \e[31m33 |\e[0m        \e[34m// >>> getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\e[0m\n\e[31m34\
    \ |\e[0m        \e[34m// (List[Tuple2[Long, Long]]((0l, 0l), (1l, 4l), (1l, 0l),\
    \ (2l, 5l), (2l, 0l)))\e[0m\n\e[31m35 |\e[0m      "
  stdout: ''
  timestamp: 1659804093
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // Fill up this function body\n\
    \        // 'lst' is a nested list, similar to matrix,\n        // 'x' is the\
    \ integer to be searched in the list\n        // Return a list of tuples, [(x1,\
    \ y1), (x2, y2) ...]\n        // such that each tuple is a coordinate - (row,\
    \ columns),\n        // starting with 0.\n        // Sort coordinates initially\
    \ by rows in ascending order.\n        // Also, sort coordinates of the row by\
    \ columns in descending order.\n        // If x is not found in the list, return\
    \ empty list.\n        // Note: You can use built-in sort function.\n        //\
    \ Example:\n        // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n        // (List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n        // >>> getRow((List[List[Long]]()),\
    \ (1l))\n        // (List[Tuple2[Long, Long]]())\n        // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \        // (List[Tuple2[Long, Long]]((2l, 2l)))\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (l\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmppj1opxa6.scala:41:4 ----------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmppj1opxa6.scala:52:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m52 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmppj1opxa6.scala:40:20 ------------------------\e[0m\e[0m\n\
    \e[31m40 |\e[0m                \e[33mif\e[0m (l\n\e[31m\e[31m   |\e[0m       \
    \             ^\e[0m\n\e[31m   |\e[0m                    Not found: l\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[33m\e[33m-- Warning: /tmp/tmppj1opxa6.scala:42:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m42 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n3 errors found\n"
  stdout: ''
  timestamp: 1659804091
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var res : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    res = res :+ (i.toLong, j.toLong)\n           \
    \     }\n            }\n        }\n        res.sortWith((a, b) => {\n        \
    \    if (a._1 < b._1) {\n                true\n            } else if (a._1 ==\
    \ b._1) {\n                a._2 > b._2\n            } else {\n               \
    \ false\n            }\n        })\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804096
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => a._1\
    \ < b._1 || (a._1 == b._1 && a._2 > b._2))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804084
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = (i, j) :: result\n                }\n\
    \            }\n        }\n        result.sortWith((a, b) => a._1 < b._1 || (a._1\
    \ == b._1 && a._2 > b._2))\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804084
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // Fill up this function body\n\
    \        // `lst` is a list of lists, where each list is a row\n        // `x`\
    \ is the number to be searched\n        // return a list of tuples, where each\
    \ tuple is a coordinate\n        // (row, column)\n        // sort the list of\
    \ tuples by rows in ascending order\n        // and then by columns in descending\
    \ order\n        // if the number is not found, return an empty list\n       \
    \ // if the list is empty, return an empty list\n        // if the list is empty,\
    \ return an empty list\n        var result = List[Tuple2[Long, Long]]()\n    \
    \    for (i <- 0 until lst.length) {\n            for (j <- 0 until lst(i).length)\
    \ {\n                if (lst(i)(j) == x) {\n                    result = result\
    \ :+ (i.toLong, j.toLong)\n                }\n            }\n        }\n     \
    \   result.sortWith((a, b) => if (a._1 == b._1) a._2 > b._2 else a._1 < b._1)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804096
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((x, y) => x._1\
    \ < y._1 || (x._1 == y._1 && x._2 > y._2))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804097
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => {\n\
    \            if (a._1 < b._1) true\n            else if (a._1 == b._1) {\n   \
    \             if (a._2 > b._2) true\n                else false\n            }\n\
    \            else false\n        })\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804097
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => (a._1\
    \ < b._1) || (a._1 == b._1 && a._2 > b._2))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804084
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith(sortByRow)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpbydl0wfa.scala:28:24 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        result.sortWith(sortByRow)\n\e[31m\e[31m   |\e\
    [0m                        ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \     Not found: sortByRow\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659804093
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => a._1\
    \ < b._1 || (a._1 == b._1 && a._2 > b._2))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804084
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            var row : List[Long] = lst(i)\n            for (j <- 0 until row.length)\
    \ {\n                if (row(j) == x) {\n                    result = result :+\
    \ (i.toLong, j.toLong)\n                }\n            }\n        }\n        result.sortWith((a,\
    \ b) => {\n            if (a._1 < b._1) {\n                true\n            }\
    \ else if (a._1 == b._1) {\n                a._2 > b._2\n            } else {\n\
    \                false\n            }\n        })\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804085
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // Fill up this function body\n\
    \        // 'lst' is a nested list, which is similar to matrix, however, unlike\
    \ matrices,\n        // each row may contain a different number of columns.\n\
    \        // 'x' is the integer to be searched in the list\n        // Return list\
    \ of tuples, [(x1, y1), (x2, y2) ...] such that\n        // each tuple is a coordinate\
    \ - (row, columns), starting with 0.\n        // Sort coordinates initially by\
    \ rows in ascending order.\n        // Also, sort coordinates of the row by columns\
    \ in descending order.\n        // If x is not found in the list, return empty\
    \ list.\n        var result = List[Tuple2[Long, Long]]()\n        var row = 0l\n\
    \        for (i <- lst) {\n            var col = 0l\n            for (j <- i)\
    \ {\n                if (j == x) {\n                    result = result :+ (row,\
    \ col)\n                }\n                col += 1\n            }\n         \
    \   row += 1\n        }\n        result.sortWith((x, y) => x._1 < y._1 || (x._1\
    \ == y._1 && x._2 > y._2))\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804097
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => {\n\
    \            if (a._1 == b._1) {\n                a._2 > b._2\n            } else\
    \ {\n                a._1 < b._1\n            }\n        })\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804084
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List()\n        for (i <- 0 until lst.length) {\n            for (j\
    \ <- 0 until lst(i).length) {\n                if (lst(i)(j) == x) {\n       \
    \             result = result :+ (i.toLong, j.toLong)\n                }\n   \
    \         }\n        }\n        result.sortWith((a, b) => a._1 < b._1 || (a._1\
    \ == b._1 && a._2 > b._2))\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804097
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => a._1\
    \ < b._1 || (a._1 == b._1 && a._2 > b._2))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804084
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => {\n\
    \            if (a._1 < b._1) {\n                true\n            } else if (a._1\
    \ == b._1) {\n                a._2 > b._2\n            } else {\n            \
    \    false\n            }\n        })\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804084
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // Fill up this function body\n\
    \        // `lst` is a nested list, similar to matrix, but unlike matrix,\n  \
    \      // each row may contain a different number of columns.\n        // `x`\
    \ is an integer to be searched in the list.\n        // Return a list of tuples,\
    \ [(x1, y1), (x2, y2) ...] such that\n        // each tuple is a coordinate -\
    \ (row, columns), starting with 0.\n        // Sort coordinates initially by rows\
    \ in ascending order.\n        // Also, sort coordinates of the row by columns\
    \ in descending order.\n        // If `x` is not found in the list, return empty\
    \ list.\n        // If `lst` is empty, return empty list.\n        // If `lst`\
    \ is a list of empty lists, return empty list.\n        // If `lst` is a list\
    \ of lists, each of which is empty, return empty list.\n        // If `lst` is\
    \ a list of lists, each of which is a list of empty lists, return empty list.\n\
    \        // If `lst` is a list of lists, each of which is a list of lists, each\
    \ of which is empty, return empty list.\n        // If `lst` is a list of lists,\
    \ each of which is a list of lists, each of which is a list of empty lists, return\
    \ empty list.\n        // If `lst` is a list of lists, each of which is a list\
    \ of lists, each of which is a list of lists, each of which is empty, return empty\
    \ list.\n        // If `lst` is a list of lists, each of which is a list of lists,\
    \ each of which is a list of lists, each of which is a list of empty lists, return\
    \ empty list.\n        // If `lst` is a list of lists, each of which is a list\
    \ of lists, each of which is a list of lists, each of which is a list of lists,\
    \ each of which is empty, return empty list.\n        // If `lst` is a list of\
    \ lists, each of which is a list of lists, each of which is a list of lists, each\
    \ of which is a list of lists, each of which is a list of empty lists, return\
    \ empty list.\n        // If `lst` is a list of lists\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsunrsf4o.scala:19:78\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m    \e[33mdef\e[0m \e[36mgetRow\e\
    [0m(\e[36mlst\e[0m : \e[35mList\e[0m[\e[35mList\e[0m[\e[35mLong\e[0m]], \e[36mx\e\
    [0m : \e[35mLong\e[0m) : \e[35mList\e[0m[\e[35mTuple2\e[0m[\e[35mLong\e[0m, \e\
    [35mLong\e[0m]] = {\n\e[31m\e[31m   |\e[0m                                   \
    \                                           ^\e[0m\n\e[31m   |\e[0m          \
    \                                  Found:    Unit\n\e[31m   |\e[0m           \
    \                                 Required: List[(Long, Long)]\n\e[31m20 |\e[0m\
    \        \e[34m// Fill up this function body\e[0m\n\e[31m21 |\e[0m        \e[34m//\
    \ `lst` is a nested list, similar to matrix, but unlike matrix,\e[0m\n\e[31m22\
    \ |\e[0m        \e[34m// each row may contain a different number of columns.\e\
    [0m\n\e[31m23 |\e[0m        \e[34m// `x` is an integer to be searched in the list.\e\
    [0m\n\e[31m24 |\e[0m        \e[34m// Return a list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\e[0m\n\e[31m25 |\e[0m        \e[34m// each tuple is a coordinate\
    \ - (row, columns), starting with 0.\e[0m\n\e[31m26 |\e[0m        \e[34m// Sort\
    \ coordinates initially by rows in ascending order.\e[0m\n\e[31m27 |\e[0m    \
    \    \e[34m// Also, sort coordinates of the row by columns in descending order.\e\
    [0m\n\e[31m28 |\e[0m        \e[34m// If `x` is not found in the list, return empty\
    \ list.\e[0m\n\e[31m29 |\e[0m        \e[34m// If `lst` is empty, return empty\
    \ list.\e[0m\n\e[31m30 |\e[0m        \e[34m// If `lst` is a list of empty lists,\
    \ return empty list.\e[0m\n\e[31m31 |\e[0m        \e[34m// If `lst` is a list\
    \ of lists, each of which is empty, return empty list.\e[0m\n\e[31m32 |\e[0m \
    \       \e[34m// If `lst` is a list of lists, each of which is a list of empty\
    \ lists, return empty list.\e[0m\n\e[31m33 |\e[0m        \e[34m// If `lst` is\
    \ a list of lists, each of which is a list of lists, each of which is empty, return\
    \ empty list.\e[0m\n\e[31m34 |\e[0m        \e[34m// If `lst` is a list of lists,\
    \ each of which is a list of lists, each of which is a list of empty lists, return\
    \ empty list.\e[0m\n\e[31m35 |\e[0m        \e[34m// If"
  stdout: ''
  timestamp: 1659804096
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // Fill up this function body\n\
    \        // 'lst' is a nested list, which is similar to matrix,\n        // however,\
    \ unlike matrices, each row may contain a different number of columns.\n     \
    \   // 'x' is an integer to be found in the list.\n        // You need to return\
    \ a list of tuples, [(x1, y1), (x2, y2) ...] such that\n        // each tuple\
    \ is a coordinate - (row, columns), starting with 0.\n        // Sort coordinates\
    \ initially by rows in ascending order.\n        // Also, sort coordinates of\
    \ the row by columns in descending order.\n        var result = List[Tuple2[Long,\
    \ Long]]()\n        for (i <- 0 until lst.length) {\n            for (j <- 0 until\
    \ lst(i).length) {\n                if (lst(i)(j) == x) {\n                  \
    \  result = result :+ (i.toLong, j.toLong)\n                }\n            }\n\
    \        }\n        result.sortWith((a, b) => a._1 < b._1 || (a._1 == b._1 &&\
    \ a._2 > b._2))\n    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804097
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => {\n\
    \            if (a._1 == b._1) {\n                a._2 > b._2\n            } else\
    \ {\n                a._1 < b._1\n            }\n        })\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804084
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // Fill up this function body\n\
    \        // 'lst' is a nested list, which is similar to matrix, however, unlike\
    \ matrices,\n        // each row may contain a different number of columns.\n\
    \        // 'x' is a given integer\n        // You have to return a list of tuples,\
    \ [(x1, y1), (x2, y2) ...] such that\n        // each tuple is a coordinate -\
    \ (row, columns), starting with 0.\n        // Sort coordinates initially by rows\
    \ in ascending order.\n        // Also, sort coordinates of the row by columns\
    \ in descending order.\n        var result = List[Tuple2[Long, Long]]()\n    \
    \    var row = 0\n        for (i <- lst) {\n            var col = 0\n        \
    \    for (j <- i) {\n                if (j == x) {\n                    result\
    \ = result :+ (row, col)\n                }\n                col += 1\n      \
    \      }\n            row += 1\n        }\n        result.sortBy(x => x._1)\n\
    \        result.sortBy(x => -x._2)\n        result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpz133wwbe.scala:45)\n\tat Problem.main(tmpz133wwbe.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659804097
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 to lst.length - 1)\
    \ {\n            var row = lst(i)\n            for (j <- 0 to row.length - 1)\
    \ {\n                if (row(j) == x) {\n                    result = result :+\
    \ (i.toLong, j.toLong)\n                }\n            }\n        }\n        result.sortWith((a,\
    \ b) => {\n            if (a._1 == b._1) {\n                a._2 > b._2\n    \
    \        } else {\n                a._1 < b._1\n            }\n        })\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804097
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // Fill up this function body\n\
    \        // 'lst' is a nested list, similar to matrix,\n        // but unlike\
    \ matrix, each row may contain a different number of columns.\n        // 'x'\
    \ is an integer, which you need to find in the list.\n        // Return list of\
    \ tuples, [(x1, y1), (x2, y2) ...] such that\n        // each tuple is a coordinate\
    \ - (row, columns), starting with 0.\n        // Sort coordinates initially by\
    \ rows in ascending order.\n        // Also, sort coordinates of the row by columns\
    \ in descending order.\n        var result = List[Tuple2[Long, Long]]()\n    \
    \    for (i <- 0 until lst.length) {\n            for (j <- 0 until lst(i).length)\
    \ {\n                if (lst(i)(j) == x) {\n                    result = result\
    \ :+ (i.toLong, j.toLong)\n                }\n            }\n        }\n     \
    \   result.sortWith((a, b) => (a._1 < b._1) || (a._1 == b._1 && a._2 > b._2))\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804097
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((x, y) => x._1\
    \ < y._1 || (x._1 == y._1 && x._2 > y._2))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804097
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => a._1\
    \ < b._1 || (a._1 == b._1 && a._2 > b._2))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804084
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var res = List[Tuple2[Long,\
    \ Long]]()\n        for (i <- 0 until lst.length) {\n            for (j <- 0 until\
    \ lst(i).length) {\n                if (lst(i)(j) == x) {\n                  \
    \  res = (i, j) :: res\n                }\n            }\n        }\n        res.sortWith((a,\
    \ b) => {\n            if (a._1 == b._1) {\n                a._2 > b._2\n    \
    \        } else {\n                a._1 < b._1\n            }\n        })\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804097
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // Fill up this function body\n\
    \        // `lst` is a list of lists, and `x` is the integer to find\n       \
    \ // Return a list of tuples, each tuple is a coordinate - (row, column)\n   \
    \     // Sort coordinates initially by rows in ascending order.\n        // Also,\
    \ sort coordinates of the row by columns in descending order.\n        // For\
    \ example, if `lst` is List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong)) and `x` is 1l, then the result should be List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l))\n        var result\
    \ = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n    \
    \        var row = lst(i)\n            for (j <- 0 until row.length) {\n     \
    \           if (row(j) == x) {\n                    result = result :+ (i.toLong,\
    \ j.toLong)\n                }\n            }\n        }\n        result.sortWith((a,\
    \ b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804097
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // Fill up this function body\n\
    \        // 'lst' is a nested list, which is similar to matrix, however, unlike\
    \ matrices,\n        // each row may contain a different number of columns.\n\
    \        // 'x' is an integer.\n        // You have to find integers 'x' in the\
    \ list,\n        // and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    \        // each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \      // Sort coordinates initially by rows in ascending order.\n        // Also,\
    \ sort coordinates of the row by columns in descending order.\n        // If you\
    \ find multiple 'x' in the same row, sort them by columns in descending order.\n\
    \        // If you find multiple 'x' in the same column, sort them by rows in\
    \ ascending order.\n        // If you find multiple 'x' in the same row and column,\
    \ sort them by rows in ascending order.\n        // If you find no 'x' in the\
    \ list, return an empty list.\n        // If you find 'x' in the list, return\
    \ a list of tuples.\n        // If you find 'x' in the list, return a list of\
    \ tuples,\n        // where each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n        // Sort coordinates initially by rows in ascending order.\n\
    \        // Also, sort coordinates of the row by columns in descending order.\n\
    \        // If you find multiple 'x' in the same row, sort them by columns in\
    \ descending order.\n        // If you find multiple 'x' in the same column, sort\
    \ them by rows in ascending order.\n        // If you find multiple 'x' in the\
    \ same row and column, sort them by rows in ascending order.\n        // If you\
    \ find no 'x' in the list, return an empty list.\n        // If you find 'x' in\
    \ the list, return a list of tuples.\n        // If you find 'x' in the list,\
    \ return a list of tuples,\n        // where each tuple is a coordinate - (row,\
    \ columns), starting with 0.\n        // Sort coordinates initially by rows in\
    \ ascending order.\n        // Also, sort coordinates of the row by columns in\
    \ descending order.\n        // If you find multiple 'x' in the same row\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp1d2k0eop.scala:19:78\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m    \e[33mdef\e[0m \e[36mgetRow\e\
    [0m(\e[36mlst\e[0m : \e[35mList\e[0m[\e[35mList\e[0m[\e[35mLong\e[0m]], \e[36mx\e\
    [0m : \e[35mLong\e[0m) : \e[35mList\e[0m[\e[35mTuple2\e[0m[\e[35mLong\e[0m, \e\
    [35mLong\e[0m]] = {\n\e[31m\e[31m   |\e[0m                                   \
    \                                           ^\e[0m\n\e[31m   |\e[0m          \
    \                                  Found:    Unit\n\e[31m   |\e[0m           \
    \                                 Required: List[(Long, Long)]\n\e[31m20 |\e[0m\
    \        \e[34m// Fill up this function body\e[0m\n\e[31m21 |\e[0m        \e[34m//\
    \ 'lst' is a nested list, which is similar to matrix, however, unlike matrices,\e\
    [0m\n\e[31m22 |\e[0m        \e[34m// each row may contain a different number of\
    \ columns.\e[0m\n\e[31m23 |\e[0m        \e[34m// 'x' is an integer.\e[0m\n\e[31m24\
    \ |\e[0m        \e[34m// You have to find integers 'x' in the list,\e[0m\n\e[31m25\
    \ |\e[0m        \e[34m// and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\e[0m\n\e[31m26 |\e[0m        \e[34m// each tuple is a coordinate - (row,\
    \ columns), starting with 0.\e[0m\n\e[31m27 |\e[0m        \e[34m// Sort coordinates\
    \ initially by rows in ascending order.\e[0m\n\e[31m28 |\e[0m        \e[34m//\
    \ Also, sort coordinates of the row by columns in descending order.\e[0m\n\e[31m29\
    \ |\e[0m        \e[34m// If you find multiple 'x' in the same row, sort them by\
    \ columns in descending order.\e[0m\n\e[31m30 |\e[0m        \e[34m// If you find\
    \ multiple 'x' in the same column, sort them by rows in ascending order.\e[0m\n\
    \e[31m31 |\e[0m        \e[34m// If you find multiple 'x' in the same row and column,\
    \ sort them by rows in ascending order.\e[0m\n\e[31m32 |\e[0m        \e[34m//\
    \ If you find no 'x' in the list, return an empty list.\e[0m\n\e[31m33 |\e[0m\
    \        \e[34m// If you find 'x' in the list, return a list of tuples.\e[0m\n\
    \e[31m34 |\e[0m        \e[34m// If you find 'x' in the list, return a list of\
    \ tuples,\e[0m\n\e[31m35 |\e[0m        \e[34m// where each tuple is a coordinate\
    \ - (row, columns), starting with 0.\e[0m\n\e[31m36 "
  stdout: ''
  timestamp: 1659804096
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // Fill up this function body\n\
    \        // `lst` is a list of lists, where each list is a row\n        // `x`\
    \ is the integer to be searched in the list\n        // Return a list of tuples,\
    \ where each tuple is a coordinate\n        // (row, column)\n        var result\
    \ = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n    \
    \        for (j <- 0 until lst(i).length) {\n                if (lst(i)(j) ==\
    \ x) {\n                    result = (i, j) :: result\n                }\n   \
    \         }\n        }\n        result.sortWith((a, b) => a._1 < b._1 || (a._1\
    \ == b._1 && a._2 > b._2))\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804098
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => a._1\
    \ < b._1 || (a._1 == b._1 && a._2 > b._2))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804084
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var res = List[Tuple2[Long,\
    \ Long]]()\n        for (i <- 0 until lst.length) {\n            for (j <- 0 until\
    \ lst(i).length) {\n                if (lst(i)(j) == x) {\n                  \
    \  res = (i, j) :: res\n                }\n            }\n        }\n        res.sortWith((a,\
    \ b) => if (a._1 == b._1) a._2 > b._2 else a._1 < b._1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804098
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => {\n\
    \            if (a._1 == b._1) {\n                a._2 > b._2\n            } else\
    \ {\n                a._1 < b._1\n            }\n        })\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804084
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // Fill up this function body\n\
    \        // 'lst' is a nested list, similar to matrix, but each row may contain\
    \ a different number of columns.\n        // 'x' is an integer to be found in\
    \ the list.\n        // Return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    \        // each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \      // Sort coordinates initially by rows in ascending order.\n        // Also,\
    \ sort coordinates of the row by columns in descending order.\n        // If x\
    \ is not found in the list, return empty list.\n        // If the list is empty,\
    \ return empty list.\n        // Constraints:\n        // 1 <= number of rows\
    \ <= 100\n        // 1 <= number of columns <= 100\n        // 1 <= x <= 1000\n\
    \        // 0 <= each element of the list <= 1000\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => {\n\
    \            if (a._1 == b._1) {\n                a._2 > b._2\n            } else\
    \ {\n                a._1 < b._1\n            }\n        })\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804097
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => a._1\
    \ < b._1 || (a._1 == b._1 && a._2 > b._2))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804084
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => {\n\
    \            if (a._1 < b._1) {\n                true\n            } else if (a._1\
    \ == b._1) {\n                a._2 > b._2\n            } else {\n            \
    \    false\n            }\n        })\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804084
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // Fill up this function body\n\
    \        // 'lst' is a list of lists, and 'x' is the integer to be found\n   \
    \     // Return a list of tuples, each tuple is a coordinate - (row, column)\n\
    \        // Sort the list of tuples initially by rows in ascending order\n   \
    \     // Also, sort coordinates of the row by columns in descending order\n  \
    \      // If there are no coordinates, return empty list\n        // If there\
    \ are no such integers in the list, return empty list\n        var result = List[Tuple2[Long,\
    \ Long]]()\n        for (i <- 0 until lst.length) {\n            for (j <- 0 until\
    \ lst(i).length) {\n                if (lst(i)(j) == x) {\n                  \
    \  result = result :+ (i.toLong, j.toLong)\n                }\n            }\n\
    \        }\n        result.sortWith((a, b) => a._1 < b._1 || (a._1 == b._1 &&\
    \ a._2 > b._2))\n    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804097
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List()\n        for (i <- 0 until lst.length) {\n            val row\
    \ = lst(i)\n            for (j <- 0 until row.length) {\n                if (row(j)\
    \ == x) {\n                    result = (i, j) :: result\n                }\n\
    \            }\n        }\n        result.sortWith((a, b) => a._1 < b._1 || (a._1\
    \ == b._1 && a._2 > b._2))\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804104
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            var row : List[Long] = lst(i)\n            for (j <- 0 until row.length)\
    \ {\n                if (row(j) == x) {\n                    result = result :+\
    \ (i.toLong, j.toLong)\n                }\n            }\n        }\n        result.sortWith((a,\
    \ b) => (a._1 < b._1) || (a._1 == b._1 && a._2 > b._2))\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804105
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            val row = lst(i)\n            for (j <- 0 until row.length) {\n \
    \               if (row(j) == x) {\n                    result = (i, j) :: result\n\
    \                }\n            }\n        }\n        result.sortWith((a, b) =>\
    \ (a._1 < b._1) || (a._1 == b._1 && a._2 > b._2))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804106
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => {\n\
    \            if (a._1 < b._1) {\n                true\n            } else if (a._1\
    \ == b._1) {\n                a._2 > b._2\n            } else {\n            \
    \    false\n            }\n        })\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804084
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List()\n        for (i <- 0 until lst.length) {\n            for (j\
    \ <- 0 until lst(i).length) {\n                if (lst(i)(j) == x) {\n       \
    \             result = (i, j) :: result\n                }\n            }\n  \
    \      }\n        result.sortWith((a, b) => (a._1 < b._1) || (a._1 == b._1 &&\
    \ a._2 > b._2))\n    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804107
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            var row : List[Long] = lst(i)\n            for (j <- 0 until row.length)\
    \ {\n                if (row(j) == x) {\n                    result = result :+\
    \ (i.toLong, j.toLong)\n                }\n            }\n        }\n        result.sortWith((a,\
    \ b) => {\n            if (a._1 == b._1) {\n                a._2 > b._2\n    \
    \        } else {\n                a._1 < b._1\n            }\n        })\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804109
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // Your code here\n      \
    \  null\n    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.NullPointerException: Cannot invoke \"scala.collection.immutable.List.equals(Object)\"\
    \ because the return value of \"Problem$.getRow(scala.collection.immutable.List,\
    \ long)\" is null\n\tat Problem$.main(tmp8h2v1l1b.scala:24)\n\tat Problem.main(tmp8h2v1l1b.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659804107
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // Fill up this function body\n\
    \        // 'lst' is a nested list, similar to matrix,\n        // 'x' is the\
    \ integer to be searched in the list\n        // Return a list of tuples, [(x1,\
    \ y1), (x2, y2) ...] such that\n        // each tuple is a coordinate - (row,\
    \ columns), starting with 0.\n        // Sort coordinates initially by rows in\
    \ ascending order.\n        // Also, sort coordinates of the row by columns in\
    \ descending order.\n        // If x is not found in the list, return empty list.\n\
    \        // If the list is empty, return empty list.\n        // Note: You can\
    \ use scala.math.Ordering.Tuple2 to sort tuples.\n        // You can use scala.math.Ordering.Long\
    \ to sort Longs.\n        // You can use scala.math.Ordering.Tuple2.on[Long, Long](_._1,\
    \ _._2) to sort tuples by rows and columns.\n        // You can use scala.math.Ordering.Long.reverse\
    \ to reverse sort Longs.\n        // You can use scala.math.Ordering.Tuple2.on[Long,\
    \ Long](_._1, _._2).reverse to reverse sort tuples by rows and columns.\n    \
    \    // You can use scala.math.Ordering.Tuple2.on[Long, Long](_._2, _._1) to sort\
    \ tuples by columns and rows.\n        // You can use scala.math.Ordering.Tuple2.on[Long,\
    \ Long](_._2, _._1).reverse to reverse sort tuples by columns and rows.\n    \
    \    // You can use scala.math.Ordering.Tuple2.on[Long, Long](_._1, _._2).reverse.on[Long,\
    \ Long](_._2, _._1) to sort tuples by rows in ascending order and columns in descending\
    \ order.\n        // You can use scala.math.Ordering.Tuple2.on[Long, Long](_._1,\
    \ _._2).reverse.on[Long, Long](_._2, _._1).reverse to reverse sort tuples by rows\
    \ in ascending order and columns in descending order.\n        // You can use\
    \ sc\n    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsa7g2627.scala:19:78\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m    \e[33mdef\e[0m \e[36mgetRow\e\
    [0m(\e[36mlst\e[0m : \e[35mList\e[0m[\e[35mList\e[0m[\e[35mLong\e[0m]], \e[36mx\e\
    [0m : \e[35mLong\e[0m) : \e[35mList\e[0m[\e[35mTuple2\e[0m[\e[35mLong\e[0m, \e\
    [35mLong\e[0m]] = {\n\e[31m\e[31m   |\e[0m                                   \
    \                                           ^\e[0m\n\e[31m   |\e[0m          \
    \                                  Found:    Unit\n\e[31m   |\e[0m           \
    \                                 Required: List[(Long, Long)]\n\e[31m20 |\e[0m\
    \        \e[34m// Fill up this function body\e[0m\n\e[31m21 |\e[0m        \e[34m//\
    \ 'lst' is a nested list, similar to matrix,\e[0m\n\e[31m22 |\e[0m        \e[34m//\
    \ 'x' is the integer to be searched in the list\e[0m\n\e[31m23 |\e[0m        \e\
    [34m// Return a list of tuples, [(x1, y1), (x2, y2) ...] such that\e[0m\n\e[31m24\
    \ |\e[0m        \e[34m// each tuple is a coordinate - (row, columns), starting\
    \ with 0.\e[0m\n\e[31m25 |\e[0m        \e[34m// Sort coordinates initially by\
    \ rows in ascending order.\e[0m\n\e[31m26 |\e[0m        \e[34m// Also, sort coordinates\
    \ of the row by columns in descending order.\e[0m\n\e[31m27 |\e[0m        \e[34m//\
    \ If x is not found in the list, return empty list.\e[0m\n\e[31m28 |\e[0m    \
    \    \e[34m// If the list is empty, return empty list.\e[0m\n\e[31m29 |\e[0m \
    \       \e[34m// Note: You can use scala.math.Ordering.Tuple2 to sort tuples.\e\
    [0m\n\e[31m30 |\e[0m        \e[34m// You can use scala.math.Ordering.Long to sort\
    \ Longs.\e[0m\n\e[31m31 |\e[0m        \e[34m// You can use scala.math.Ordering.Tuple2.on[Long,\
    \ Long](_._1, _._2) to sort tuples by rows and columns.\e[0m\n\e[31m32 |\e[0m\
    \        \e[34m// You can use scala.math.Ordering.Long.reverse to reverse sort\
    \ Longs.\e[0m\n\e[31m33 |\e[0m        \e[34m// You can use scala.math.Ordering.Tuple2.on[Long,\
    \ Long](_._1, _._2).reverse to reverse sort tuples by rows and columns.\e[0m\n\
    \e[31m34 |\e[0m        \e[34m// You can use scala.math.Ordering.Tuple2.on[Long,\
    \ Long](_._2, _._1) to sort tuples by columns and rows.\e[0m\n\e[31m35 |\e[0m\
    \        \e[34m// You can use"
  stdout: ''
  timestamp: 1659804107
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            var row : List[Long] = lst(i)\n            for (j <- 0 until row.length)\
    \ {\n                if (row(j) == x) {\n                    result = result :+\
    \ (i.toLong, j.toLong)\n                }\n            }\n        }\n        result.sortWith((a,\
    \ b) => {\n            if (a._1 < b._1) {\n                true\n            }\
    \ else if (a._1 == b._1) {\n                a._2 > b._2\n            } else {\n\
    \                false\n            }\n        })\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804085
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // Fill up this function body\n\
    \        // 'lst' is a nested list, which is similar to matrix,\n        // however,\
    \ unlike matrices, each row may contain a different number of columns.\n     \
    \   // 'x' is an integer.\n        // You have to find integers 'x' in the list,\n\
    \        // and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n  \
    \      // each tuple is a coordinate - (row, columns), starting with 0.\n    \
    \    // Sort coordinates initially by rows in ascending order.\n        // Also,\
    \ sort coordinates of the row by columns in descending order.\n        // If there\
    \ is no 'x' in the list, return an empty list.\n        // If the list is empty,\
    \ return an empty list.\n        // If the list is a list of empty lists, return\
    \ an empty list.\n        // If the list is a list of lists of empty lists, return\
    \ an empty list.\n        // If the list is a list of lists of lists of empty\
    \ lists, return an empty list.\n        // If the list is a list of lists of lists\
    \ of lists of empty lists, return an empty list.\n        // If the list is a\
    \ list of lists of lists of lists of lists of empty lists, return an empty list.\n\
    \        // If the list is a list of lists of lists of lists of lists of lists\
    \ of empty lists, return an empty list.\n        // If the list is a list of lists\
    \ of lists of lists of lists of lists of lists of empty lists, return an empty\
    \ list.\n        // If the list is a list of lists of lists of lists of lists\
    \ of lists of lists of lists of empty lists, return an empty list.\n        //\
    \ If the list is a list of lists of lists of lists of lists of lists of lists\
    \ of lists of lists of empty lists, return an empty list.\n        // If the list\
    \ is a list of lists of lists of lists of lists of lists of lists of lists of\
    \ lists of lists of empty lists, return an empty list.\n        // If the list\
    \ is a list of lists of lists of lists of lists of lists of lists of lists of\
    \ lists of lists of lists of empty lists, return an empty list.\n        // If\
    \ the list is a list of lists of lists of lists of lists of lists of lists of\
    \ lists of lists of lists\n    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnv3ltsie.scala:19:78\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m    \e[33mdef\e[0m \e[36mgetRow\e\
    [0m(\e[36mlst\e[0m : \e[35mList\e[0m[\e[35mList\e[0m[\e[35mLong\e[0m]], \e[36mx\e\
    [0m : \e[35mLong\e[0m) : \e[35mList\e[0m[\e[35mTuple2\e[0m[\e[35mLong\e[0m, \e\
    [35mLong\e[0m]] = {\n\e[31m\e[31m   |\e[0m                                   \
    \                                           ^\e[0m\n\e[31m   |\e[0m          \
    \                                  Found:    Unit\n\e[31m   |\e[0m           \
    \                                 Required: List[(Long, Long)]\n\e[31m20 |\e[0m\
    \        \e[34m// Fill up this function body\e[0m\n\e[31m21 |\e[0m        \e[34m//\
    \ 'lst' is a nested list, which is similar to matrix,\e[0m\n\e[31m22 |\e[0m  \
    \      \e[34m// however, unlike matrices, each row may contain a different number\
    \ of columns.\e[0m\n\e[31m23 |\e[0m        \e[34m// 'x' is an integer.\e[0m\n\e\
    [31m24 |\e[0m        \e[34m// You have to find integers 'x' in the list,\e[0m\n\
    \e[31m25 |\e[0m        \e[34m// and return list of tuples, [(x1, y1), (x2, y2)\
    \ ...] such that\e[0m\n\e[31m26 |\e[0m        \e[34m// each tuple is a coordinate\
    \ - (row, columns), starting with 0.\e[0m\n\e[31m27 |\e[0m        \e[34m// Sort\
    \ coordinates initially by rows in ascending order.\e[0m\n\e[31m28 |\e[0m    \
    \    \e[34m// Also, sort coordinates of the row by columns in descending order.\e\
    [0m\n\e[31m29 |\e[0m        \e[34m// If there is no 'x' in the list, return an\
    \ empty list.\e[0m\n\e[31m30 |\e[0m        \e[34m// If the list is empty, return\
    \ an empty list.\e[0m\n\e[31m31 |\e[0m        \e[34m// If the list is a list of\
    \ empty lists, return an empty list.\e[0m\n\e[31m32 |\e[0m        \e[34m// If\
    \ the list is a list of lists of empty lists, return an empty list.\e[0m\n\e[31m33\
    \ |\e[0m        \e[34m// If the list is a list of lists of lists of empty lists,\
    \ return an empty list.\e[0m\n\e[31m34 |\e[0m        \e[34m// If the list is a\
    \ list of lists of lists of lists of empty lists, return an empty list.\e[0m\n\
    \e[31m35 |\e[0m        \e[34m// If the list is a list of lists of lists of lists\
    \ of lists of empty lists, return an empty list.\e[0m\n\e[31m36 "
  stdout: ''
  timestamp: 1659804105
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // Fill up this function body\n\
    \        // 'lst' is a nested list, similar to matrix,\n        // however, unlike\
    \ matrices, each row may contain a different number of columns.\n        // 'x'\
    \ is an integer.\n        // You have to find integers x in the list,\n      \
    \  // and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n        //\
    \ each tuple is a coordinate - (row, columns), starting with 0.\n        // Sort\
    \ coordinates initially by rows in ascending order.\n        // Also, sort coordinates\
    \ of the row by columns in descending order.\n        // If x is not found in\
    \ the list, return empty list.\n        // If the list is empty, return empty\
    \ list.\n        // If the list is not empty, but all the rows are empty, return\
    \ empty list.\n        // If the list is not empty, but all the rows are empty,\
    \ return empty list.\n        // If the list is not empty, but all the rows are\
    \ empty, return empty list.\n        // If the list is not empty, but all the\
    \ rows are empty, return empty list.\n        // If the list is not empty, but\
    \ all the rows are empty, return empty list.\n        // If the list is not empty,\
    \ but all the rows are empty, return empty list.\n        // If the list is not\
    \ empty, but all the rows are empty, return empty list.\n        // If the list\
    \ is not empty, but all the rows are empty, return empty list.\n        // If\
    \ the list is not empty, but all the rows are empty, return empty list.\n    \
    \    // If the list is not empty, but all the rows are empty, return empty list.\n\
    \        // If the list is not empty, but all the rows are empty, return empty\
    \ list.\n        // If the list is not empty, but all the rows are empty, return\
    \ empty list.\n        // If the list is not empty, but all the rows are empty,\
    \ return empty list.\n        // If the list is not empty, but all the rows are\
    \ empty, return empty list.\n        // If the list is not empty, but all the\
    \ rows are empty, return empty list.\n        // If the list is not empty, but\
    \ all the rows are empty, return empty list.\n        // If the list is\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpcshp654y.scala:19:78\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m    \e[33mdef\e[0m \e[36mgetRow\e\
    [0m(\e[36mlst\e[0m : \e[35mList\e[0m[\e[35mList\e[0m[\e[35mLong\e[0m]], \e[36mx\e\
    [0m : \e[35mLong\e[0m) : \e[35mList\e[0m[\e[35mTuple2\e[0m[\e[35mLong\e[0m, \e\
    [35mLong\e[0m]] = {\n\e[31m\e[31m   |\e[0m                                   \
    \                                           ^\e[0m\n\e[31m   |\e[0m          \
    \                                  Found:    Unit\n\e[31m   |\e[0m           \
    \                                 Required: List[(Long, Long)]\n\e[31m20 |\e[0m\
    \        \e[34m// Fill up this function body\e[0m\n\e[31m21 |\e[0m        \e[34m//\
    \ 'lst' is a nested list, similar to matrix,\e[0m\n\e[31m22 |\e[0m        \e[34m//\
    \ however, unlike matrices, each row may contain a different number of columns.\e\
    [0m\n\e[31m23 |\e[0m        \e[34m// 'x' is an integer.\e[0m\n\e[31m24 |\e[0m\
    \        \e[34m// You have to find integers x in the list,\e[0m\n\e[31m25 |\e\
    [0m        \e[34m// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\e\
    [0m\n\e[31m26 |\e[0m        \e[34m// each tuple is a coordinate - (row, columns),\
    \ starting with 0.\e[0m\n\e[31m27 |\e[0m        \e[34m// Sort coordinates initially\
    \ by rows in ascending order.\e[0m\n\e[31m28 |\e[0m        \e[34m// Also, sort\
    \ coordinates of the row by columns in descending order.\e[0m\n\e[31m29 |\e[0m\
    \        \e[34m// If x is not found in the list, return empty list.\e[0m\n\e[31m30\
    \ |\e[0m        \e[34m// If the list is empty, return empty list.\e[0m\n\e[31m31\
    \ |\e[0m        \e[34m// If the list is not empty, but all the rows are empty,\
    \ return empty list.\e[0m\n\e[31m32 |\e[0m        \e[34m// If the list is not\
    \ empty, but all the rows are empty, return empty list.\e[0m\n\e[31m33 |\e[0m\
    \        \e[34m// If the list is not empty, but all the rows are empty, return\
    \ empty list.\e[0m\n\e[31m34 |\e[0m        \e[34m// If the list is not empty,\
    \ but all the rows are empty, return empty list.\e[0m\n\e[31m35 |\e[0m       \
    \ \e[34m// If the list is not empty, but all the rows are empty, return empty\
    \ list.\e[0m\n\e[31m36 |\e[0m        \e[34m// If the list is not emp"
  stdout: ''
  timestamp: 1659804109
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => {\n\
    \            if (a._1 == b._1) {\n                a._2 > b._2\n            } else\
    \ {\n                a._1 < b._1\n            }\n        })\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804084
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => a._1\
    \ < b._1 || (a._1 == b._1 && a._2 > b._2))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804084
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // Fill up this function body\n\
    \        // 'lst' is a nested list, which is similar to matrix, however, unlike\
    \ matrices,\n        // each row may contain a different number of columns.\n\
    \        // 'x' is an integer.\n        // You have to find integers 'x' in the\
    \ list,\n        // and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    \        // each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \      // Sort coordinates initially by rows in ascending order.\n        // Also,\
    \ sort coordinates of the row by columns in descending order.\n        // If you\
    \ find multiple 'x' in a row, then sort them by columns in descending order.\n\
    \        // If you find multiple 'x' in a column, then sort them by rows in ascending\
    \ order.\n        // If you find multiple 'x' in a row and column, then sort them\
    \ by rows in ascending order.\n        // If you don't find 'x' in the list, then\
    \ return empty list.\n        // If the list is empty, then return empty list.\n\
    \        // Note: You can assume that all the elements in the list are unique.\n\
    \        // Note: You can assume that all the elements in the list are positive.\n\
    \        // Note: You can assume that all the elements in the list are integers.\n\
    \        // Note: You can assume that all the elements in the list are less than\
    \ or equal to 100.\n        // Note: You can assume that all the elements in the\
    \ list are greater than or equal to 1.\n        // Note: You can assume that the\
    \ list is not null.\n        // Note: You can assume that the list is not empty.\n\
    \        // Note: You can assume that the list is not a nested list.\n       \
    \ // Note: You can assume that the list is a nested list.\n        // Note: You\
    \ can assume that the list is a 2 dimensional data.\n        // Note: You can\
    \ assume that the list is a nested list of integers.\n        // Note: You can\
    \ assume that the list is a nested list of positive integers.\n        // Note:\
    \ You can assume that the list is a nested list of unique integers.\n        //\
    \ Note: You can assume that the list is a nested list of unique positive integers.\n\
    \        // Note: You can\n    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp8buf4c4s.scala:19:78\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m    \e[33mdef\e[0m \e[36mgetRow\e\
    [0m(\e[36mlst\e[0m : \e[35mList\e[0m[\e[35mList\e[0m[\e[35mLong\e[0m]], \e[36mx\e\
    [0m : \e[35mLong\e[0m) : \e[35mList\e[0m[\e[35mTuple2\e[0m[\e[35mLong\e[0m, \e\
    [35mLong\e[0m]] = {\n\e[31m\e[31m   |\e[0m                                   \
    \                                           ^\e[0m\n\e[31m   |\e[0m          \
    \                                  Found:    Unit\n\e[31m   |\e[0m           \
    \                                 Required: List[(Long, Long)]\n\e[31m20 |\e[0m\
    \        \e[34m// Fill up this function body\e[0m\n\e[31m21 |\e[0m        \e[34m//\
    \ 'lst' is a nested list, which is similar to matrix, however, unlike matrices,\e\
    [0m\n\e[31m22 |\e[0m        \e[34m// each row may contain a different number of\
    \ columns.\e[0m\n\e[31m23 |\e[0m        \e[34m// 'x' is an integer.\e[0m\n\e[31m24\
    \ |\e[0m        \e[34m// You have to find integers 'x' in the list,\e[0m\n\e[31m25\
    \ |\e[0m        \e[34m// and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\e[0m\n\e[31m26 |\e[0m        \e[34m// each tuple is a coordinate - (row,\
    \ columns), starting with 0.\e[0m\n\e[31m27 |\e[0m        \e[34m// Sort coordinates\
    \ initially by rows in ascending order.\e[0m\n\e[31m28 |\e[0m        \e[34m//\
    \ Also, sort coordinates of the row by columns in descending order.\e[0m\n\e[31m29\
    \ |\e[0m        \e[34m// If you find multiple 'x' in a row, then sort them by\
    \ columns in descending order.\e[0m\n\e[31m30 |\e[0m        \e[34m// If you find\
    \ multiple 'x' in a column, then sort them by rows in ascending order.\e[0m\n\e\
    [31m31 |\e[0m        \e[34m// If you find multiple 'x' in a row and column, then\
    \ sort them by rows in ascending order.\e[0m\n\e[31m32 |\e[0m        \e[34m//\
    \ If you don't find 'x' in the list, then return empty list.\e[0m\n\e[31m33 |\e\
    [0m        \e[34m// If the list is empty, then return empty list.\e[0m\n\e[31m34\
    \ |\e[0m        \e[34m// Note: You can assume that all the elements in the list\
    \ are unique.\e[0m\n\e[31m35 |\e[0m        \e[34m// Note: You can assume that\
    \ all the elements in the list are positive.\e[0m\n\e[3"
  stdout: ''
  timestamp: 1659804108
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => {\n\
    \            if (a._1 < b._1) {\n                true\n            } else if (a._1\
    \ == b._1) {\n                a._2 > b._2\n            } else {\n            \
    \    false\n            }\n        })\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804084
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => a._1\
    \ < b._1 || (a._1 == b._1 && a._2 > b._2))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804084
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => {\n\
    \            if (a._1 == b._1) {\n                a._2 > b._2\n            } else\
    \ {\n                a._1 < b._1\n            }\n        })\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804084
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        val result = new ListBuffer[Tuple2[Long,\
    \ Long]]()\n        for (i <- 0 until lst.length) {\n            for (j <- 0 until\
    \ lst(i).length) {\n                if (lst(i)(j) == x) result += ((i.toLong,\
    \ j.toLong))\n            }\n        }\n        result.toList.sortWith((a, b)\
    \ => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804109
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 to lst.length - 1)\
    \ {\n            for (j <- 0 to lst(i).length - 1) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => (a._1\
    \ < b._1) || (a._1 == b._1 && a._2 > b._2))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804110
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => a._1\
    \ < b._1 || (a._1 == b._1 && a._2 > b._2))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804084
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // Fill up this function body\n\
    \        // 'lst' is a 2 dimensional list, similar to matrix,\n        // but\
    \ unlike matrix, each row may contain a different number of columns.\n       \
    \ // 'x' is an integer to be searched in the list.\n        // Return list of\
    \ tuples, [(x1, y1), (x2, y2) ...] such that\n        // each tuple is a coordinate\
    \ - (row, columns), starting with 0.\n        // Sort coordinates initially by\
    \ rows in ascending order.\n        // Also, sort coordinates of the row by columns\
    \ in descending order.\n        // If x is not found in the list, return empty\
    \ list.\n        // Note: You can use built-in sort function.\n        //    \
    \   You can use built-in zipWithIndex function.\n        //       You can use\
    \ built-in flatten function.\n        //       You can use built-in filter function.\n\
    \        //       You can use built-in map function.\n        //       You can\
    \ use built-in foldLeft function.\n        //       You can use built-in foldRight\
    \ function.\n        //       You can use built-in reverse function.\n       \
    \ //       You can use built-in zip function.\n        //       You can use built-in\
    \ unzip function.\n        //       You can use built-in flatten function.\n \
    \       //       You can use built-in max function.\n        //       You can\
    \ use built-in min function.\n        //       You can use built-in sum function.\n\
    \        //       You can use built-in product function.\n        //       You\
    \ can use built-in mkString function.\n        //       You can use built-in toString\
    \ function.\n        //       You can use built-in toList function.\n        //\
    \       You can use built-in toSet function.\n        //       You can use built-in\
    \ toMap function.\n        //       You can use built-in toSeq function.\n   \
    \     //       You can use built-in toIndexedSeq function.\n        //       You\
    \ can use built-in toBuffer function.\n        //       You can use built-in toVector\
    \ function.\n        //       You can use built-in toIterable function.\n    \
    \    //       You can use built-in toIterator function.\n        //\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpt1xbkroq.scala:19:78\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m    \e[33mdef\e[0m \e[36mgetRow\e\
    [0m(\e[36mlst\e[0m : \e[35mList\e[0m[\e[35mList\e[0m[\e[35mLong\e[0m]], \e[36mx\e\
    [0m : \e[35mLong\e[0m) : \e[35mList\e[0m[\e[35mTuple2\e[0m[\e[35mLong\e[0m, \e\
    [35mLong\e[0m]] = {\n\e[31m\e[31m   |\e[0m                                   \
    \                                           ^\e[0m\n\e[31m   |\e[0m          \
    \                                  Found:    Unit\n\e[31m   |\e[0m           \
    \                                 Required: List[(Long, Long)]\n\e[31m20 |\e[0m\
    \        \e[34m// Fill up this function body\e[0m\n\e[31m21 |\e[0m        \e[34m//\
    \ 'lst' is a 2 dimensional list, similar to matrix,\e[0m\n\e[31m22 |\e[0m    \
    \    \e[34m// but unlike matrix, each row may contain a different number of columns.\e\
    [0m\n\e[31m23 |\e[0m        \e[34m// 'x' is an integer to be searched in the list.\e\
    [0m\n\e[31m24 |\e[0m        \e[34m// Return list of tuples, [(x1, y1), (x2, y2)\
    \ ...] such that\e[0m\n\e[31m25 |\e[0m        \e[34m// each tuple is a coordinate\
    \ - (row, columns), starting with 0.\e[0m\n\e[31m26 |\e[0m        \e[34m// Sort\
    \ coordinates initially by rows in ascending order.\e[0m\n\e[31m27 |\e[0m    \
    \    \e[34m// Also, sort coordinates of the row by columns in descending order.\e\
    [0m\n\e[31m28 |\e[0m        \e[34m// If x is not found in the list, return empty\
    \ list.\e[0m\n\e[31m29 |\e[0m        \e[34m// Note: You can use built-in sort\
    \ function.\e[0m\n\e[31m30 |\e[0m        \e[34m//       You can use built-in zipWithIndex\
    \ function.\e[0m\n\e[31m31 |\e[0m        \e[34m//       You can use built-in flatten\
    \ function.\e[0m\n\e[31m32 |\e[0m        \e[34m//       You can use built-in filter\
    \ function.\e[0m\n\e[31m33 |\e[0m        \e[34m//       You can use built-in map\
    \ function.\e[0m\n\e[31m34 |\e[0m        \e[34m//       You can use built-in foldLeft\
    \ function.\e[0m\n\e[31m35 |\e[0m        \e[34m//       You can use built-in foldRight\
    \ function.\e[0m\n\e[31m36 |\e[0m        \e[34m//       You can use built-in reverse\
    \ function.\e[0m\n\e[31m37 |\e[0m        \e[34m//       You can use built-in zip\
    \ function.\e[0m\n\e[31m38 "
  stdout: ''
  timestamp: 1659804109
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // Fill up this function body\n\
    \        // 'lst' is a nested list, similar to matrix, but each row may contain\
    \ a different number of columns.\n        // 'x' is an integer to be searched\
    \ in the list.\n        // Return a list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n        // each tuple is a coordinate - (row, columns), starting with\
    \ 0.\n        // Sort coordinates initially by rows in ascending order.\n    \
    \    // Also, sort coordinates of the row by columns in descending order.\n  \
    \      // If x is not found in the list, return an empty list.\n        // If\
    \ the list is empty, return an empty list.\n        // Note:\n        // 1. You\
    \ can assume that the list is non-empty.\n        // 2. You can assume that the\
    \ list is non-null.\n        // 3. You can assume that the list is not a string.\n\
    \        // 4. You can assume that the list is not a set.\n        // 5. You can\
    \ assume that the list is not a map.\n        // 6. You can assume that the list\
    \ is not a vector.\n        // 7. You can assume that the list is not a stream.\n\
    \        // 8. You can assume that the list is not a range.\n        // 9. You\
    \ can assume that the list is not a sequence.\n        // 10. You can assume that\
    \ the list is not a collection.\n        // 11. You can assume that the list is\
    \ not an iterator.\n        // 12. You can assume that the list is not a traversable.\n\
    \        // 13. You can assume that the list is not a traversable once.\n    \
    \    // 14. You can assume that the list is not an iterable.\n        // 15. You\
    \ can assume that the list is not an iterable once.\n        // 16. You can assume\
    \ that the list is not a view.\n        // 17. You can assume that the list is\
    \ not a linear sequence.\n        // 18. You can assume that the list is not a\
    \ sequence view.\n        // 19. You can assume that the list is not a slice.\n\
    \        // 20. You can assume that the list is not a sliceable.\n        // 21.\
    \ You can assume that the list is not a linear sequence.\n        // 22.\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnms6o482.scala:19:78\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m    \e[33mdef\e[0m \e[36mgetRow\e\
    [0m(\e[36mlst\e[0m : \e[35mList\e[0m[\e[35mList\e[0m[\e[35mLong\e[0m]], \e[36mx\e\
    [0m : \e[35mLong\e[0m) : \e[35mList\e[0m[\e[35mTuple2\e[0m[\e[35mLong\e[0m, \e\
    [35mLong\e[0m]] = {\n\e[31m\e[31m   |\e[0m                                   \
    \                                           ^\e[0m\n\e[31m   |\e[0m          \
    \                                  Found:    Unit\n\e[31m   |\e[0m           \
    \                                 Required: List[(Long, Long)]\n\e[31m20 |\e[0m\
    \        \e[34m// Fill up this function body\e[0m\n\e[31m21 |\e[0m        \e[34m//\
    \ 'lst' is a nested list, similar to matrix, but each row may contain a different\
    \ number of columns.\e[0m\n\e[31m22 |\e[0m        \e[34m// 'x' is an integer to\
    \ be searched in the list.\e[0m\n\e[31m23 |\e[0m        \e[34m// Return a list\
    \ of tuples, [(x1, y1), (x2, y2) ...] such that\e[0m\n\e[31m24 |\e[0m        \e\
    [34m// each tuple is a coordinate - (row, columns), starting with 0.\e[0m\n\e\
    [31m25 |\e[0m        \e[34m// Sort coordinates initially by rows in ascending\
    \ order.\e[0m\n\e[31m26 |\e[0m        \e[34m// Also, sort coordinates of the row\
    \ by columns in descending order.\e[0m\n\e[31m27 |\e[0m        \e[34m// If x is\
    \ not found in the list, return an empty list.\e[0m\n\e[31m28 |\e[0m        \e\
    [34m// If the list is empty, return an empty list.\e[0m\n\e[31m29 |\e[0m     \
    \   \e[34m// Note:\e[0m\n\e[31m30 |\e[0m        \e[34m// 1. You can assume that\
    \ the list is non-empty.\e[0m\n\e[31m31 |\e[0m        \e[34m// 2. You can assume\
    \ that the list is non-null.\e[0m\n\e[31m32 |\e[0m        \e[34m// 3. You can\
    \ assume that the list is not a string.\e[0m\n\e[31m33 |\e[0m        \e[34m//\
    \ 4. You can assume that the list is not a set.\e[0m\n\e[31m34 |\e[0m        \e\
    [34m// 5. You can assume that the list is not a map.\e[0m\n\e[31m35 |\e[0m   \
    \     \e[34m// 6. You can assume that the list is not a vector.\e[0m\n\e[31m36\
    \ |\e[0m        \e[34m// 7. You can assume that the list is not a stream.\e[0m\n\
    \e[31m37 |\e[0m        \e[34m// 8. You can assume that the list is not a range.\e\
    [0"
  stdout: ''
  timestamp: 1659804108
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => a._1\
    \ < b._1 || (a._1 == b._1 && a._2 > b._2))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804084
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => {\n\
    \            if (a._1 < b._1) {\n                true\n            } else if (a._1\
    \ == b._1) {\n                a._2 > b._2\n            } else {\n            \
    \    false\n            }\n        })\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804084
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => {\n\
    \            if (a._1 == b._1) {\n                a._2 > b._2\n            } else\
    \ {\n                a._1 < b._1\n            }\n        })\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804084
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 to lst.length - 1)\
    \ {\n            val row = lst(i)\n            for (j <- 0 to row.length - 1)\
    \ {\n                if (row(j) == x) {\n                    result = result :+\
    \ (i.toLong, j.toLong)\n                }\n            }\n        }\n        result.sortWith((a,\
    \ b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804110
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            var row : List[Long] = lst(i)\n            for (j <- 0 until row.length)\
    \ {\n                if (row(j) == x) {\n                    result = (i, j) ::\
    \ result\n                }\n            }\n        }\n        result.sortWith((a,\
    \ b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804111
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            var row : List[Long] = lst(i)\n            for (j <- 0 until row.length)\
    \ {\n                if (row(j) == x) {\n                    result = (i, j) ::\
    \ result\n                }\n            }\n        }\n        result.sortWith((a,\
    \ b) => (a._1 < b._1 || (a._1 == b._1 && a._2 > b._2)))\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804110
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // Fill up this function body\n\
    \        // 'lst' is a nested list, which is similar to matrix,\n        // however,\
    \ unlike matrices, each row may contain a different number of columns.\n     \
    \   // 'x' is an integer to be found in the list.\n        // Return list of tuples,\
    \ [(x1, y1), (x2, y2) ...] such that\n        // each tuple is a coordinate -\
    \ (row, columns), starting with 0.\n        // Sort coordinates initially by rows\
    \ in ascending order.\n        // Also, sort coordinates of the row by columns\
    \ in descending order.\n        lst.zipWithIndex.flatMap(x => x._1.zipWithIndex.filter(y\
    \ => y._1 == x._2).map(y => (x._2, y._2))).sortBy(x => (x._1, -x._2))\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpux1iyx6l.scala:28:8\
    \ ---------------------\e[0m\e[0m\n\e[31m28 |\e[0m        lst.zipWithIndex.flatMap(\e\
    [36mx\e[0m => x._1.zipWithIndex.filter(\e[36my\e[0m => y._1 == x._2).map(\e[36my\e\
    [0m => (x._2, y._2))).sortBy(\e[36mx\e[0m => (x._1, -x._2))\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    List[(\e[1m\e[31mInt\e[0m, \e[1m\e[31mInt\e\
    [0m)]\n\e[31m   |\e[0m        Required: List[(\e[1m\e[32mLong\e[0m, \e[1m\e[32mLong\e\
    [0m)]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659804109
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // Fill up this function body\n\
    \        // 'lst' is a nested list, which is similar to matrix, however, unlike\
    \ matrices,\n        // each row may contain a different number of columns.\n\
    \        // 'x' is an integer to be searched in the list.\n        // Return list\
    \ of tuples, [(x1, y1), (x2, y2) ...] such that\n        // each tuple is a coordinate\
    \ - (row, columns), starting with 0.\n        // Sort coordinates initially by\
    \ rows in ascending order.\n        // Also, sort coordinates of the row by columns\
    \ in descending order.\n        // If 'x' is not found in the list, return empty\
    \ list.\n        // If 'lst' is empty, return empty list.\n        var result\
    \ = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n    \
    \        for (j <- 0 until lst(i).length) {\n                if (lst(i)(j) ==\
    \ x) {\n                    result = result :+ (i.toLong, j.toLong)\n        \
    \        }\n            }\n        }\n        result.sortWith((a, b) => a._1 <\
    \ b._1 || (a._1 == b._1 && a._2 > b._2))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804110
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // Fill up this function body\n\
    \        // 'lst' is a nested list, similar to matrix,\n        // however, unlike\
    \ matrices, each row may contain a different number of columns.\n        // 'x'\
    \ is an integer, which you need to find in the list.\n        // Return list of\
    \ tuples, [(x1, y1), (x2, y2) ...] such that\n        // each tuple is a coordinate\
    \ - (row, columns), starting with 0.\n        // Sort coordinates initially by\
    \ rows in ascending order.\n        // Also, sort coordinates of the row by columns\
    \ in descending order.\n        // If x is not found in the list, return empty\
    \ list.\n        // If list is empty, return empty list.\n        // If list is\
    \ None, return empty list.\n        // If x is None, return empty list.\n    \
    \    // If x is not an integer, return empty list.\n        // If list is not\
    \ a nested list, return empty list.\n        // If list is not a nested list of\
    \ integers, return empty list.\n        // If list is a nested list of integers,\
    \ but x is not found, return empty list.\n        // If list is a nested list\
    \ of integers, and x is found, return list of tuples,\n        // [(x1, y1), (x2,\
    \ y2) ...] such that each tuple is a coordinate - (row, columns),\n        //\
    \ starting with 0.\n        // Sort coordinates initially by rows in ascending\
    \ order.\n        // Also, sort coordinates of the row by columns in descending\
    \ order.\n        // If x is not found in the list, return empty list.\n     \
    \   // If list is empty, return empty list.\n        // If list is None, return\
    \ empty list.\n        // If x is None, return empty list.\n        // If x is\
    \ not an integer, return empty list.\n        // If list is not a nested list,\
    \ return empty list.\n        // If list is not a nested list of integers, return\
    \ empty list.\n        // If list is a nested list of integers, but x is not found,\
    \ return empty list.\n        // If list is a nested list of integers, and x is\
    \ found, return list of tuples,\n        // [(x1, y1), (x2, y2) ...] such that\
    \ each tuple is\n    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpr7flwpk5.scala:19:78\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m    \e[33mdef\e[0m \e[36mgetRow\e\
    [0m(\e[36mlst\e[0m : \e[35mList\e[0m[\e[35mList\e[0m[\e[35mLong\e[0m]], \e[36mx\e\
    [0m : \e[35mLong\e[0m) : \e[35mList\e[0m[\e[35mTuple2\e[0m[\e[35mLong\e[0m, \e\
    [35mLong\e[0m]] = {\n\e[31m\e[31m   |\e[0m                                   \
    \                                           ^\e[0m\n\e[31m   |\e[0m          \
    \                                  Found:    Unit\n\e[31m   |\e[0m           \
    \                                 Required: List[(Long, Long)]\n\e[31m20 |\e[0m\
    \        \e[34m// Fill up this function body\e[0m\n\e[31m21 |\e[0m        \e[34m//\
    \ 'lst' is a nested list, similar to matrix,\e[0m\n\e[31m22 |\e[0m        \e[34m//\
    \ however, unlike matrices, each row may contain a different number of columns.\e\
    [0m\n\e[31m23 |\e[0m        \e[34m// 'x' is an integer, which you need to find\
    \ in the list.\e[0m\n\e[31m24 |\e[0m        \e[34m// Return list of tuples, [(x1,\
    \ y1), (x2, y2) ...] such that\e[0m\n\e[31m25 |\e[0m        \e[34m// each tuple\
    \ is a coordinate - (row, columns), starting with 0.\e[0m\n\e[31m26 |\e[0m   \
    \     \e[34m// Sort coordinates initially by rows in ascending order.\e[0m\n\e\
    [31m27 |\e[0m        \e[34m// Also, sort coordinates of the row by columns in\
    \ descending order.\e[0m\n\e[31m28 |\e[0m        \e[34m// If x is not found in\
    \ the list, return empty list.\e[0m\n\e[31m29 |\e[0m        \e[34m// If list is\
    \ empty, return empty list.\e[0m\n\e[31m30 |\e[0m        \e[34m// If list is None,\
    \ return empty list.\e[0m\n\e[31m31 |\e[0m        \e[34m// If x is None, return\
    \ empty list.\e[0m\n\e[31m32 |\e[0m        \e[34m// If x is not an integer, return\
    \ empty list.\e[0m\n\e[31m33 |\e[0m        \e[34m// If list is not a nested list,\
    \ return empty list.\e[0m\n\e[31m34 |\e[0m        \e[34m// If list is not a nested\
    \ list of integers, return empty list.\e[0m\n\e[31m35 |\e[0m        \e[34m// If\
    \ list is a nested list of integers, but x is not found, return empty list.\e\
    [0m\n\e[31m36 |\e[0m        \e[34m// If list is a nested list of integers, and\
    \ x is found, return list of tuples,\e[0m\n\e[31m37 |\e[0m       "
  stdout: ''
  timestamp: 1659804109
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // Fill up this function body\n\
    \        // 'lst' is a nested list of integers\n        // 'x' is an integer\n\
    \        // Return a list of tuples, [(x1, y1), (x2, y2) ...] such that\n    \
    \    // each tuple is a coordinate - (row, columns), starting with 0.\n      \
    \  // Sort coordinates initially by rows in ascending order.\n        // Also,\
    \ sort coordinates of the row by columns in descending order.\n        // If there\
    \ are no coordinates, return empty list.\n        // If there are no coordinates,\
    \ return empty list.\n        var result = List[Tuple2[Long, Long]]()\n      \
    \  for (i <- 0 until lst.length) {\n            for (j <- 0 until lst(i).length)\
    \ {\n                if (lst(i)(j) == x) {\n                    result = result\
    \ :+ (i.toLong, j.toLong)\n                }\n            }\n        }\n     \
    \   result.sortWith((x, y) => x._1 < y._1 || (x._1 == y._1 && x._2 > y._2))\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804110
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // Fill up this function body\n\
    \        // 'lst' is a list of lists, where each list is a row of the matrix\n\
    \        // 'x' is the integer to be searched in the matrix\n        // You have\
    \ to return a list of tuples, where each tuple is a coordinate - (row, columns),\
    \ starting with 0.\n        // Sort coordinates initially by rows in ascending\
    \ order.\n        // Also, sort coordinates of the row by columns in descending\
    \ order.\n        // If the integer is not found in the matrix, return an empty\
    \ list.\n        // If the matrix is empty, return an empty list.\n        //\
    \ If the matrix is not empty, but the integer is not found, return an empty list.\n\
    \        // If the matrix is not empty, and the integer is found, return the list\
    \ of tuples.\n        // If the matrix is not empty, and the integer is found\
    \ multiple times, return the list of tuples.\n        // If the matrix is not\
    \ empty, and the integer is found multiple times, return the list of tuples,\n\
    \        // sorted by rows in ascending order.\n        // If the matrix is not\
    \ empty, and the integer is found multiple times, return the list of tuples,\n\
    \        // sorted by rows in ascending order, and also, sort coordinates of the\
    \ row by columns in descending order.\n        // If the matrix is not empty,\
    \ and the integer is found multiple times, return the list of tuples,\n      \
    \  // sorted by rows in ascending order, and also, sort coordinates of the row\
    \ by columns in descending order.\n        // If the matrix is not empty, and\
    \ the integer is found multiple times, return the list of tuples,\n        //\
    \ sorted by rows in ascending order, and also, sort coordinates of the row by\
    \ columns in descending order.\n        // If the matrix is not empty, and the\
    \ integer is found multiple times, return the list of tuples,\n        // sorted\
    \ by rows in ascending order, and also, sort coordinates of the row by columns\
    \ in descending order.\n        // If the matrix is not empty, and the integer\
    \ is found multiple times, return the list of tuples,\n        // sorted by rows\
    \ in ascending order, and also, sort coordinates of the row by columns in descending\
    \ order.\n        // If the matrix is not empty, and the integer is found multiple\
    \ times, return the list of tuples,\n        //\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpu9qf864v.scala:19:78\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m    \e[33mdef\e[0m \e[36mgetRow\e\
    [0m(\e[36mlst\e[0m : \e[35mList\e[0m[\e[35mList\e[0m[\e[35mLong\e[0m]], \e[36mx\e\
    [0m : \e[35mLong\e[0m) : \e[35mList\e[0m[\e[35mTuple2\e[0m[\e[35mLong\e[0m, \e\
    [35mLong\e[0m]] = {\n\e[31m\e[31m   |\e[0m                                   \
    \                                           ^\e[0m\n\e[31m   |\e[0m          \
    \                                  Found:    Unit\n\e[31m   |\e[0m           \
    \                                 Required: List[(Long, Long)]\n\e[31m20 |\e[0m\
    \        \e[34m// Fill up this function body\e[0m\n\e[31m21 |\e[0m        \e[34m//\
    \ 'lst' is a list of lists, where each list is a row of the matrix\e[0m\n\e[31m22\
    \ |\e[0m        \e[34m// 'x' is the integer to be searched in the matrix\e[0m\n\
    \e[31m23 |\e[0m        \e[34m// You have to return a list of tuples, where each\
    \ tuple is a coordinate - (row, columns), starting with 0.\e[0m\n\e[31m24 |\e\
    [0m        \e[34m// Sort coordinates initially by rows in ascending order.\e[0m\n\
    \e[31m25 |\e[0m        \e[34m// Also, sort coordinates of the row by columns in\
    \ descending order.\e[0m\n\e[31m26 |\e[0m        \e[34m// If the integer is not\
    \ found in the matrix, return an empty list.\e[0m\n\e[31m27 |\e[0m        \e[34m//\
    \ If the matrix is empty, return an empty list.\e[0m\n\e[31m28 |\e[0m        \e\
    [34m// If the matrix is not empty, but the integer is not found, return an empty\
    \ list.\e[0m\n\e[31m29 |\e[0m        \e[34m// If the matrix is not empty, and\
    \ the integer is found, return the list of tuples.\e[0m\n\e[31m30 |\e[0m     \
    \   \e[34m// If the matrix is not empty, and the integer is found multiple times,\
    \ return the list of tuples.\e[0m\n\e[31m31 |\e[0m        \e[34m// If the matrix\
    \ is not empty, and the integer is found multiple times, return the list of tuples,\e\
    [0m\n\e[31m32 |\e[0m        \e[34m// sorted by rows in ascending order.\e[0m\n\
    \e[31m33 |\e[0m        \e[34m// If the matrix is not empty, and the integer is\
    \ found multiple times, return the list of tuples,\e[0m\n\e[31m34 |\e[0m     \
    \   \e[34m// sorted by rows in ascending order, a"
  stdout: ''
  timestamp: 1659804109
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List()\n        for (i <- 0 until lst.length) {\n            for (j\
    \ <- 0 until lst(i).length) {\n                if (lst(i)(j) == x) {\n       \
    \             result = result :+ (i.toLong, j.toLong)\n                }\n   \
    \         }\n        }\n        result.sortWith((a, b) => {\n            if (a._1\
    \ < b._1) {\n                true\n            } else if (a._1 == b._1) {\n  \
    \              a._2 > b._2\n            } else {\n                false\n    \
    \        }\n        })\n    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804110
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // Fill up this function body\n\
    \        // 'lst' is a nested list, similar to matrix, but each row may contain\
    \ a different number of columns.\n        // 'x' is an integer to be searched\
    \ in the list.\n        // Return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n        // each tuple is a coordinate - (row, columns), starting with\
    \ 0.\n        // Sort coordinates initially by rows in ascending order.\n    \
    \    // Also, sort coordinates of the row by columns in descending order.\n  \
    \      var result = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length)\
    \ {\n            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = (i, j) :: result\n                }\n\
    \            }\n        }\n        result.sortWith((a, b) => {\n            if\
    \ (a._1 == b._1) {\n                a._2 > b._2\n            } else {\n      \
    \          a._1 < b._1\n            }\n        })\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804120
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // Fill up this function body\n\
    \        // 'lst' is a nested list, similar to matrix,\n        // however, unlike\
    \ matrices, each row may contain a different number of columns.\n        // 'x'\
    \ is an integer.\n        // You have to find integers x in the list,\n      \
    \  // and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n        //\
    \ each tuple is a coordinate - (row, columns), starting with 0.\n        // Sort\
    \ coordinates initially by rows in ascending order.\n        // Also, sort coordinates\
    \ of the row by columns in descending order.\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 to lst.length - 1)\
    \ {\n            var row : List[Long] = lst(i)\n            for (j <- 0 to row.length\
    \ - 1) {\n                if (row(j) == x) {\n                    result = result\
    \ :+ (i.toLong, j.toLong)\n                }\n            }\n        }\n     \
    \   result.sortWith((a, b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804119
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => {\n\
    \            if (a._1 < b._1) {\n                true\n            } else if (a._1\
    \ == b._1) {\n                a._2 > b._2\n            } else {\n            \
    \    false\n            }\n        })\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804084
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // Fill up this function body\n\
    \        // 'lst' is a nested list, similar to matrix, but each row may contain\
    \ a different number of columns.\n        // 'x' is an integer.\n        // Return\
    \ list of tuples, [(x1, y1), (x2, y2) ...] such that\n        // each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n        // Sort coordinates\
    \ initially by rows in ascending order.\n        // Also, sort coordinates of\
    \ the row by columns in descending order.\n        // If there are no coordinates,\
    \ return empty list.\n        // If there are no rows, return empty list.\n  \
    \      // If there are no columns, return empty list.\n        // If there are\
    \ no elements in the list, return empty list.\n        // If there are no elements\
    \ in the row, return empty list.\n        // If there are no elements in the column,\
    \ return empty list.\n        // If there are no elements in the matrix, return\
    \ empty list.\n        // If there are no elements in the nested list, return\
    \ empty list.\n        // If there are no elements in the nested list, return\
    \ empty list.\n        // If there are no elements in the nested list, return\
    \ empty list.\n        // If there are no elements in the nested list, return\
    \ empty list.\n        // If there are no elements in the nested list, return\
    \ empty list.\n        // If there are no elements in the nested list, return\
    \ empty list.\n        // If there are no elements in the nested list, return\
    \ empty list.\n        // If there are no elements in the nested list, return\
    \ empty list.\n        // If there are no elements in the nested list, return\
    \ empty list.\n        // If there are no elements in the nested list, return\
    \ empty list.\n        // If there are no elements in the nested list, return\
    \ empty list.\n        // If there are no elements in the nested list, return\
    \ empty list.\n        // If there are no elements in the nested list, return\
    \ empty list.\n        // If there are no elements in the nested list, return\
    \ empty list.\n        // If there are no elements in the nested list, return\
    \ empty list.\n        // If there are no elements in the nested list, return\
    \ empty list.\n        // If there are no elements in the nested list, return\
    \ empty list.\n       \n    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqw967d0v.scala:19:78\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m    \e[33mdef\e[0m \e[36mgetRow\e\
    [0m(\e[36mlst\e[0m : \e[35mList\e[0m[\e[35mList\e[0m[\e[35mLong\e[0m]], \e[36mx\e\
    [0m : \e[35mLong\e[0m) : \e[35mList\e[0m[\e[35mTuple2\e[0m[\e[35mLong\e[0m, \e\
    [35mLong\e[0m]] = {\n\e[31m\e[31m   |\e[0m                                   \
    \                                           ^\e[0m\n\e[31m   |\e[0m          \
    \                                  Found:    Unit\n\e[31m   |\e[0m           \
    \                                 Required: List[(Long, Long)]\n\e[31m20 |\e[0m\
    \        \e[34m// Fill up this function body\e[0m\n\e[31m21 |\e[0m        \e[34m//\
    \ 'lst' is a nested list, similar to matrix, but each row may contain a different\
    \ number of columns.\e[0m\n\e[31m22 |\e[0m        \e[34m// 'x' is an integer.\e\
    [0m\n\e[31m23 |\e[0m        \e[34m// Return list of tuples, [(x1, y1), (x2, y2)\
    \ ...] such that\e[0m\n\e[31m24 |\e[0m        \e[34m// each tuple is a coordinate\
    \ - (row, columns), starting with 0.\e[0m\n\e[31m25 |\e[0m        \e[34m// Sort\
    \ coordinates initially by rows in ascending order.\e[0m\n\e[31m26 |\e[0m    \
    \    \e[34m// Also, sort coordinates of the row by columns in descending order.\e\
    [0m\n\e[31m27 |\e[0m        \e[34m// If there are no coordinates, return empty\
    \ list.\e[0m\n\e[31m28 |\e[0m        \e[34m// If there are no rows, return empty\
    \ list.\e[0m\n\e[31m29 |\e[0m        \e[34m// If there are no columns, return\
    \ empty list.\e[0m\n\e[31m30 |\e[0m        \e[34m// If there are no elements in\
    \ the list, return empty list.\e[0m\n\e[31m31 |\e[0m        \e[34m// If there\
    \ are no elements in the row, return empty list.\e[0m\n\e[31m32 |\e[0m       \
    \ \e[34m// If there are no elements in the column, return empty list.\e[0m\n\e\
    [31m33 |\e[0m        \e[34m// If there are no elements in the matrix, return empty\
    \ list.\e[0m\n\e[31m34 |\e[0m        \e[34m// If there are no elements in the\
    \ nested list, return empty list.\e[0m\n\e[31m35 |\e[0m        \e[34m// If there\
    \ are no elements in the nested list, return empty list.\e[0m\n\e[31m36 |\e[0m\
    \        \e[34m// If there are no elements in the nested list, return e"
  stdout: ''
  timestamp: 1659804116
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // Fill up this function body\n\
    \        // 'lst' is a nested list, similar to matrix,\n        // however, unlike\
    \ matrices, each row may contain a different number of columns.\n        // 'x'\
    \ is an integer\n        // You have to return a list of tuples,\n        // [(x1,\
    \ y1), (x2, y2) ...] such that\n        // each tuple is a coordinate - (row,\
    \ columns), starting with 0.\n        // Sort coordinates initially by rows in\
    \ ascending order.\n        // Also, sort coordinates of the row by columns in\
    \ descending order.\n        // If there are no such coordinates, return an empty\
    \ list.\n        // If there are multiple such coordinates, return all of them.\n\
    \        // If there are no rows, return an empty list.\n        // If there are\
    \ no columns, return an empty list.\n        // If there are no elements, return\
    \ an empty list.\n        // If there are no such elements, return an empty list.\n\
    \        // If there are multiple such elements, return all of them.\n       \
    \ // If there are no such elements, return an empty list.\n        // If there\
    \ are multiple such elements, return all of them.\n        // If there are no\
    \ such elements, return an empty list.\n        // If there are multiple such\
    \ elements, return all of them.\n        // If there are no such elements, return\
    \ an empty list.\n        // If there are multiple such elements, return all of\
    \ them.\n        // If there are no such elements, return an empty list.\n   \
    \     // If there are multiple such elements, return all of them.\n        //\
    \ If there are no such elements, return an empty list.\n        // If there are\
    \ multiple such elements, return all of them.\n        // If there are no such\
    \ elements, return an empty list.\n        // If there are multiple such elements,\
    \ return all of them.\n        // If there are no such elements, return an empty\
    \ list.\n        // If there are multiple such elements, return all of them.\n\
    \        // If there are no such elements, return an empty list.\n        // If\
    \ there are multiple such elements, return all of them.\n        // If there are\
    \ no such elements, return an empty list.\n        // If there are multiple such\
    \ elements, return all of them.\n        // If there are no such\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpuy4i4vbw.scala:19:78\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m    \e[33mdef\e[0m \e[36mgetRow\e\
    [0m(\e[36mlst\e[0m : \e[35mList\e[0m[\e[35mList\e[0m[\e[35mLong\e[0m]], \e[36mx\e\
    [0m : \e[35mLong\e[0m) : \e[35mList\e[0m[\e[35mTuple2\e[0m[\e[35mLong\e[0m, \e\
    [35mLong\e[0m]] = {\n\e[31m\e[31m   |\e[0m                                   \
    \                                           ^\e[0m\n\e[31m   |\e[0m          \
    \                                  Found:    Unit\n\e[31m   |\e[0m           \
    \                                 Required: List[(Long, Long)]\n\e[31m20 |\e[0m\
    \        \e[34m// Fill up this function body\e[0m\n\e[31m21 |\e[0m        \e[34m//\
    \ 'lst' is a nested list, similar to matrix,\e[0m\n\e[31m22 |\e[0m        \e[34m//\
    \ however, unlike matrices, each row may contain a different number of columns.\e\
    [0m\n\e[31m23 |\e[0m        \e[34m// 'x' is an integer\e[0m\n\e[31m24 |\e[0m \
    \       \e[34m// You have to return a list of tuples,\e[0m\n\e[31m25 |\e[0m  \
    \      \e[34m// [(x1, y1), (x2, y2) ...] such that\e[0m\n\e[31m26 |\e[0m     \
    \   \e[34m// each tuple is a coordinate - (row, columns), starting with 0.\e[0m\n\
    \e[31m27 |\e[0m        \e[34m// Sort coordinates initially by rows in ascending\
    \ order.\e[0m\n\e[31m28 |\e[0m        \e[34m// Also, sort coordinates of the row\
    \ by columns in descending order.\e[0m\n\e[31m29 |\e[0m        \e[34m// If there\
    \ are no such coordinates, return an empty list.\e[0m\n\e[31m30 |\e[0m       \
    \ \e[34m// If there are multiple such coordinates, return all of them.\e[0m\n\e\
    [31m31 |\e[0m        \e[34m// If there are no rows, return an empty list.\e[0m\n\
    \e[31m32 |\e[0m        \e[34m// If there are no columns, return an empty list.\e\
    [0m\n\e[31m33 |\e[0m        \e[34m// If there are no elements, return an empty\
    \ list.\e[0m\n\e[31m34 |\e[0m        \e[34m// If there are no such elements, return\
    \ an empty list.\e[0m\n\e[31m35 |\e[0m        \e[34m// If there are multiple such\
    \ elements, return all of them.\e[0m\n\e[31m36 |\e[0m        \e[34m// If there\
    \ are no such elements, return an empty list.\e[0m\n\e[31m37 |\e[0m        \e\
    [34m// If there are multiple such elements, return all of them.\e[0"
  stdout: ''
  timestamp: 1659804118
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // Fill up this function body\n\
    \        // 'lst' is a nested list, similar to matrix,\n        // however, unlike\
    \ matrices, each row may contain a different number of columns.\n        // 'x'\
    \ is an integer to be searched in the nested list.\n        // Return list of\
    \ tuples, [(x1, y1), (x2, y2) ...] such that\n        // each tuple is a coordinate\
    \ - (row, columns), starting with 0.\n        // Sort coordinates initially by\
    \ rows in ascending order.\n        // Also, sort coordinates of the row by columns\
    \ in descending order.\n        // If 'x' is not found, return empty list.\n \
    \       // If 'lst' is empty, return empty list.\n        var result = List[Tuple2[Long,\
    \ Long]]()\n        for (i <- 0 until lst.length) {\n            for (j <- 0 until\
    \ lst(i).length) {\n                if (lst(i)(j) == x) {\n                  \
    \  result = (i, j) :: result\n                }\n            }\n        }\n  \
    \      result.sortWith((a, b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804121
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = (i, j) :: result\n                }\n\
    \            }\n        }\n        result.sortWith((a, b) => (a._1 < b._1) ||\
    \ (a._1 == b._1 && a._2 > b._2))\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804121
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // Fill up this function body\n\
    \        // 'lst' is a nested list, similar to matrix, but each row may contain\
    \ a different number of columns.\n        // 'x' is an integer to be found in\
    \ the list.\n        // You have to find integers x in the list, and return list\
    \ of tuples,\n        // [(x1, y1), (x2, y2) ...] such that each tuple is a coordinate\
    \ - (row, columns),\n        // starting with 0. Sort coordinates initially by\
    \ rows in ascending order.\n        // Also, sort coordinates of the row by columns\
    \ in descending order.\n        // If the list is empty, return empty list.\n\
    \        // If the list is not empty, but the integer x is not found, return empty\
    \ list.\n        // If the list is not empty, and the integer x is found, return\
    \ list of tuples.\n        // If the list is not empty, and the integer x is found\
    \ multiple times,\n        // return list of tuples, which contains all the coordinates.\n\
    \        // If the list is not empty, and the integer x is found multiple times,\n\
    \        // return list of tuples, which contains all the coordinates.\n     \
    \   // If the list is not empty, and the integer x is found multiple times,\n\
    \        // return list of tuples, which contains all the coordinates.\n     \
    \   // If the list is not empty, and the integer x is found multiple times,\n\
    \        // return list of tuples, which contains all the coordinates.\n     \
    \   // If the list is not empty, and the integer x is found multiple times,\n\
    \        // return list of tuples, which contains all the coordinates.\n     \
    \   // If the list is not empty, and the integer x is found multiple times,\n\
    \        // return list of tuples, which contains all the coordinates.\n     \
    \   // If the list is not empty, and the integer x is found multiple times,\n\
    \        // return list of tuples, which contains all the coordinates.\n     \
    \   // If the list is not empty, and the integer x is found multiple times,\n\
    \        // return list of tuples, which contains all the coordinates.\n     \
    \   // If the list is not empty, and the integer x is found multiple times,\n\
    \        // return list of tuples, which contains all the coordinates.\n     \
    \   // If the list is not empty, and the integer\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpzgxianj8.scala:19:78\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m    \e[33mdef\e[0m \e[36mgetRow\e\
    [0m(\e[36mlst\e[0m : \e[35mList\e[0m[\e[35mList\e[0m[\e[35mLong\e[0m]], \e[36mx\e\
    [0m : \e[35mLong\e[0m) : \e[35mList\e[0m[\e[35mTuple2\e[0m[\e[35mLong\e[0m, \e\
    [35mLong\e[0m]] = {\n\e[31m\e[31m   |\e[0m                                   \
    \                                           ^\e[0m\n\e[31m   |\e[0m          \
    \                                  Found:    Unit\n\e[31m   |\e[0m           \
    \                                 Required: List[(Long, Long)]\n\e[31m20 |\e[0m\
    \        \e[34m// Fill up this function body\e[0m\n\e[31m21 |\e[0m        \e[34m//\
    \ 'lst' is a nested list, similar to matrix, but each row may contain a different\
    \ number of columns.\e[0m\n\e[31m22 |\e[0m        \e[34m// 'x' is an integer to\
    \ be found in the list.\e[0m\n\e[31m23 |\e[0m        \e[34m// You have to find\
    \ integers x in the list, and return list of tuples,\e[0m\n\e[31m24 |\e[0m   \
    \     \e[34m// [(x1, y1), (x2, y2) ...] such that each tuple is a coordinate -\
    \ (row, columns),\e[0m\n\e[31m25 |\e[0m        \e[34m// starting with 0. Sort\
    \ coordinates initially by rows in ascending order.\e[0m\n\e[31m26 |\e[0m    \
    \    \e[34m// Also, sort coordinates of the row by columns in descending order.\e\
    [0m\n\e[31m27 |\e[0m        \e[34m// If the list is empty, return empty list.\e\
    [0m\n\e[31m28 |\e[0m        \e[34m// If the list is not empty, but the integer\
    \ x is not found, return empty list.\e[0m\n\e[31m29 |\e[0m        \e[34m// If\
    \ the list is not empty, and the integer x is found, return list of tuples.\e\
    [0m\n\e[31m30 |\e[0m        \e[34m// If the list is not empty, and the integer\
    \ x is found multiple times,\e[0m\n\e[31m31 |\e[0m        \e[34m// return list\
    \ of tuples, which contains all the coordinates.\e[0m\n\e[31m32 |\e[0m       \
    \ \e[34m// If the list is not empty, and the integer x is found multiple times,\e\
    [0m\n\e[31m33 |\e[0m        \e[34m// return list of tuples, which contains all\
    \ the coordinates.\e[0m\n\e[31m34 |\e[0m        \e[34m// If the list is not empty,\
    \ and the integer x is found multiple times,\e[0m\n\e[31m35 |\e[0m     "
  stdout: ''
  timestamp: 1659804118
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // Fill up this function body\n\
    \        // 'lst' is a nested list, similar to matrix, but unlike matrix,\n  \
    \      // each row may contain a different number of columns.\n        // 'x'\
    \ is an integer to be found in the list.\n        // Return list of tuples, [(x1,\
    \ y1), (x2, y2) ...] such that\n        // each tuple is a coordinate - (row,\
    \ columns), starting with 0.\n        // Sort coordinates initially by rows in\
    \ ascending order.\n        // Also, sort coordinates of the row by columns in\
    \ descending order.\n        // If x is not found in the list, return empty list.\n\
    \        // If the list is empty, return empty list.\n        // If the list is\
    \ None, return empty list.\n        // If the list is not a nested list, return\
    \ empty list.\n        // If the list is not a list of lists, return empty list.\n\
    \        // If the list is not a list of lists of integers, return empty list.\n\
    \        // If the list is not a list of lists of longs, return empty list.\n\
    \        // If the list is not a list of lists of longs, return empty list.\n\
    \        // If the list is not a list of lists of longs, return empty list.\n\
    \        // If the list is not a list of lists of longs, return empty list.\n\
    \        // If the list is not a list of lists of longs, return empty list.\n\
    \        // If the list is not a list of lists of longs, return empty list.\n\
    \        // If the list is not a list of lists of longs, return empty list.\n\
    \        // If the list is not a list of lists of longs, return empty list.\n\
    \        // If the list is not a list of lists of longs, return empty list.\n\
    \        // If the list is not a list of lists of longs, return empty list.\n\
    \        // If the list is not a list of lists of longs, return empty list.\n\
    \        // If the list is not a list of lists of longs, return empty list.\n\
    \        // If the list is not a list of lists of longs, return empty list.\n\
    \        // If the list is not a list of lists of longs, return empty list.\n\
    \        // If the list is not\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5agawc2y.scala:19:78\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m    \e[33mdef\e[0m \e[36mgetRow\e\
    [0m(\e[36mlst\e[0m : \e[35mList\e[0m[\e[35mList\e[0m[\e[35mLong\e[0m]], \e[36mx\e\
    [0m : \e[35mLong\e[0m) : \e[35mList\e[0m[\e[35mTuple2\e[0m[\e[35mLong\e[0m, \e\
    [35mLong\e[0m]] = {\n\e[31m\e[31m   |\e[0m                                   \
    \                                           ^\e[0m\n\e[31m   |\e[0m          \
    \                                  Found:    Unit\n\e[31m   |\e[0m           \
    \                                 Required: List[(Long, Long)]\n\e[31m20 |\e[0m\
    \        \e[34m// Fill up this function body\e[0m\n\e[31m21 |\e[0m        \e[34m//\
    \ 'lst' is a nested list, similar to matrix, but unlike matrix,\e[0m\n\e[31m22\
    \ |\e[0m        \e[34m// each row may contain a different number of columns.\e\
    [0m\n\e[31m23 |\e[0m        \e[34m// 'x' is an integer to be found in the list.\e\
    [0m\n\e[31m24 |\e[0m        \e[34m// Return list of tuples, [(x1, y1), (x2, y2)\
    \ ...] such that\e[0m\n\e[31m25 |\e[0m        \e[34m// each tuple is a coordinate\
    \ - (row, columns), starting with 0.\e[0m\n\e[31m26 |\e[0m        \e[34m// Sort\
    \ coordinates initially by rows in ascending order.\e[0m\n\e[31m27 |\e[0m    \
    \    \e[34m// Also, sort coordinates of the row by columns in descending order.\e\
    [0m\n\e[31m28 |\e[0m        \e[34m// If x is not found in the list, return empty\
    \ list.\e[0m\n\e[31m29 |\e[0m        \e[34m// If the list is empty, return empty\
    \ list.\e[0m\n\e[31m30 |\e[0m        \e[34m// If the list is None, return empty\
    \ list.\e[0m\n\e[31m31 |\e[0m        \e[34m// If the list is not a nested list,\
    \ return empty list.\e[0m\n\e[31m32 |\e[0m        \e[34m// If the list is not\
    \ a list of lists, return empty list.\e[0m\n\e[31m33 |\e[0m        \e[34m// If\
    \ the list is not a list of lists of integers, return empty list.\e[0m\n\e[31m34\
    \ |\e[0m        \e[34m// If the list is not a list of lists of longs, return empty\
    \ list.\e[0m\n\e[31m35 |\e[0m        \e[34m// If the list is not a list of lists\
    \ of longs, return empty list.\e[0m\n\e[31m36 |\e[0m        \e[34m// If the list\
    \ is not a list of lists of longs, return empty list.\e[0m\n\e[31"
  stdout: ''
  timestamp: 1659804120
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = (i, j) :: result\n                }\n\
    \            }\n        }\n        result.sortWith((a, b) => a._1 < b._1 || (a._1\
    \ == b._1 && a._2 > b._2))\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804084
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => a._1\
    \ < b._1 || (a._1 == b._1 && a._2 > b._2))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804084
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // Fill up this function body\n\
    \        // 'lst' is a nested list, which is similar to matrix, however, unlike\
    \ matrices,\n        // each row may contain a different number of columns.\n\
    \        // 'x' is an integer\n        // return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n        // each tuple is a coordinate - (row, columns),\
    \ starting with 0.\n        // Sort coordinates initially by rows in ascending\
    \ order.\n        // Also, sort coordinates of the row by columns in descending\
    \ order.\n        var result = List[Tuple2[Long, Long]]()\n        for (i <- 0\
    \ until lst.length) {\n            for (j <- 0 until lst(i).length) {\n      \
    \          if (lst(i)(j) == x) {\n                    result = result :+ (i.toLong,\
    \ j.toLong)\n                }\n            }\n        }\n        result.sortWith((a,\
    \ b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804121
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => {\n\
    \            if (a._1 == b._1) {\n                a._2 > b._2\n            } else\
    \ {\n                a._1 < b._1\n            }\n        })\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804084
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // Fill up this function body\n\
    \        // 'lst' is a nested list, similar to matrix,\n        // 'x' is an integer\
    \ to be found in the list\n        // Return list of tuples, [(x1, y1), (x2, y2)\
    \ ...] such that\n        // each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n        // Sort coordinates initially by rows in ascending order.\n\
    \        // Also, sort coordinates of the row by columns in descending order.\n\
    \        // If x is not found in the list, return empty list.\n        var result\
    \ = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n    \
    \        val row = lst(i)\n            for (j <- 0 until row.length) {\n     \
    \           if (row(j) == x) {\n                    result = (i, j) :: result\n\
    \                }\n            }\n        }\n        result.sortWith((a, b) =>\
    \ {\n            if (a._1 != b._1) {\n                a._1 < b._1\n          \
    \  } else {\n                a._2 > b._2\n            }\n        })\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804122
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // Fill up this function body\n\
    \        // 'lst' is a list of lists, and 'x' is the number to be searched\n \
    \       // Return a list of tuples, each tuple is a coordinate - (row, column)\n\
    \        // Sort coordinates initially by rows in ascending order\n        //\
    \ Also, sort coordinates of the row by columns in descending order\n        //\
    \ If x is not found, return an empty list\n        // If lst is empty, return\
    \ an empty list\n        var result = List[Tuple2[Long, Long]]()\n        for\
    \ (i <- 0 until lst.length) {\n            for (j <- 0 until lst(i).length) {\n\
    \                if (lst(i)(j) == x) {\n                    result = result :+\
    \ (i.toLong, j.toLong)\n                }\n            }\n        }\n        result.sortWith(_._1\
    \ < _._1).sortWith(_._2 > _._2)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpita_lo50.scala:38)\n\tat Problem.main(tmpita_lo50.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659804122
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // Fill up this function body\n\
    \        // 'lst' is a nested list, which is similar to matrix, however, unlike\
    \ matrices,\n        // each row may contain a different number of columns.\n\
    \        // 'x' is an integer\n        // You have to return a list of tuples,\
    \ [(x1, y1), (x2, y2) ...] such that\n        // each tuple is a coordinate -\
    \ (row, columns), starting with 0.\n        // Sort coordinates initially by rows\
    \ in ascending order.\n        // Also, sort coordinates of the row by columns\
    \ in descending order.\n        var result = List[Tuple2[Long, Long]]()\n    \
    \    for (i <- 0 until lst.length) {\n            for (j <- 0 until lst(i).length)\
    \ {\n                if (lst(i)(j) == x) {\n                    result = result\
    \ :+ (i.toLong, j.toLong)\n                }\n            }\n        }\n     \
    \   result.sortWith((a, b) => (a._1 < b._1) || (a._1 == b._1 && a._2 > b._2))\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804122
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // Fill up this function body\n\
    \        // 'lst' is a nested list, similar to matrix, but unlike matrix,\n  \
    \      // each row may contain a different number of columns.\n        // 'x'\
    \ is an integer to be searched in the list.\n        // Return a list of tuples,\
    \ [(x1, y1), (x2, y2) ...] such that\n        // each tuple is a coordinate -\
    \ (row, columns), starting with 0.\n        // Sort coordinates initially by rows\
    \ in ascending order.\n        // Also, sort coordinates of the row by columns\
    \ in descending order.\n        // If x is not found in the list, return an empty\
    \ list.\n        // If the list is empty, return an empty list.\n        // If\
    \ the list is empty, return an empty list.\n        // If the list is empty, return\
    \ an empty list.\n        // If the list is empty, return an empty list.\n   \
    \     // If the list is empty, return an empty list.\n        // If the list is\
    \ empty, return an empty list.\n        // If the list is empty, return an empty\
    \ list.\n        // If the list is empty, return an empty list.\n        // If\
    \ the list is empty, return an empty list.\n        // If the list is empty, return\
    \ an empty list.\n        // If the list is empty, return an empty list.\n   \
    \     // If the list is empty, return an empty list.\n        // If the list is\
    \ empty, return an empty list.\n        // If the list is empty, return an empty\
    \ list.\n        // If the list is empty, return an empty list.\n        // If\
    \ the list is empty, return an empty list.\n        // If the list is empty, return\
    \ an empty list.\n        // If the list is empty, return an empty list.\n   \
    \     // If the list is empty, return an empty list.\n        // If the list is\
    \ empty, return an empty list.\n        // If the list is empty, return an empty\
    \ list.\n        // If the list is empty, return an empty list.\n        // If\
    \ the list is empty, return an empty list.\n        // If the list is empty, return\
    \ an empty list.\n        // If the list is empty, return an empty list.\n   \
    \     // If the list is empty, return an empty list.\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpkzsmtkwz.scala:19:78\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m    \e[33mdef\e[0m \e[36mgetRow\e\
    [0m(\e[36mlst\e[0m : \e[35mList\e[0m[\e[35mList\e[0m[\e[35mLong\e[0m]], \e[36mx\e\
    [0m : \e[35mLong\e[0m) : \e[35mList\e[0m[\e[35mTuple2\e[0m[\e[35mLong\e[0m, \e\
    [35mLong\e[0m]] = {\n\e[31m\e[31m   |\e[0m                                   \
    \                                           ^\e[0m\n\e[31m   |\e[0m          \
    \                                  Found:    Unit\n\e[31m   |\e[0m           \
    \                                 Required: List[(Long, Long)]\n\e[31m20 |\e[0m\
    \        \e[34m// Fill up this function body\e[0m\n\e[31m21 |\e[0m        \e[34m//\
    \ 'lst' is a nested list, similar to matrix, but unlike matrix,\e[0m\n\e[31m22\
    \ |\e[0m        \e[34m// each row may contain a different number of columns.\e\
    [0m\n\e[31m23 |\e[0m        \e[34m// 'x' is an integer to be searched in the list.\e\
    [0m\n\e[31m24 |\e[0m        \e[34m// Return a list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\e[0m\n\e[31m25 |\e[0m        \e[34m// each tuple is a coordinate\
    \ - (row, columns), starting with 0.\e[0m\n\e[31m26 |\e[0m        \e[34m// Sort\
    \ coordinates initially by rows in ascending order.\e[0m\n\e[31m27 |\e[0m    \
    \    \e[34m// Also, sort coordinates of the row by columns in descending order.\e\
    [0m\n\e[31m28 |\e[0m        \e[34m// If x is not found in the list, return an\
    \ empty list.\e[0m\n\e[31m29 |\e[0m        \e[34m// If the list is empty, return\
    \ an empty list.\e[0m\n\e[31m30 |\e[0m        \e[34m// If the list is empty, return\
    \ an empty list.\e[0m\n\e[31m31 |\e[0m        \e[34m// If the list is empty, return\
    \ an empty list.\e[0m\n\e[31m32 |\e[0m        \e[34m// If the list is empty, return\
    \ an empty list.\e[0m\n\e[31m33 |\e[0m        \e[34m// If the list is empty, return\
    \ an empty list.\e[0m\n\e[31m34 |\e[0m        \e[34m// If the list is empty, return\
    \ an empty list.\e[0m\n\e[31m35 |\e[0m        \e[34m// If the list is empty, return\
    \ an empty list.\e[0m\n\e[31m36 |\e[0m        \e[34m// If the list is empty, return\
    \ an empty list.\e[0m\n\e[31m37 |\e[0m        \e[34m// If the list is empty, return\
    \ an empty list.\e[0m\n\e[31m38 |\e[0m  "
  stdout: ''
  timestamp: 1659804120
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => a._1\
    \ < b._1 || (a._1 == b._1 && a._2 > b._2))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804084
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => {\n\
    \            if (a._1 < b._1) {\n                true\n            } else if (a._1\
    \ == b._1) {\n                a._2 > b._2\n            } else {\n            \
    \    false\n            }\n        })\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804084
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // Fill up this function body\n\
    \        // 'lst' is a nested list, similar to matrix,\n        // 'x' is an integer\
    \ to be searched in the list\n        // Return a list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n        // each tuple is a coordinate - (row, columns),\
    \ starting with 0.\n        // Sort coordinates initially by rows in ascending\
    \ order.\n        // Also, sort coordinates of the row by columns in descending\
    \ order.\n        // If x is not found in the list, return empty list.\n     \
    \   // If the list is empty, return empty list.\n        // If the list is None,\
    \ return empty list.\n        // If the list is not a nested list, return empty\
    \ list.\n        // If the list is not a list of lists, return empty list.\n \
    \       // If the list is not a list of list of integers, return empty list.\n\
    \        // If the list is not a list of list of longs, return empty list.\n \
    \       // If the list is not a list of list of longs, return empty list.\n  \
    \      // If the list is not a list of list of longs, return empty list.\n   \
    \     // If the list is not a list of list of longs, return empty list.\n    \
    \    // If the list is not a list of list of longs, return empty list.\n     \
    \   // If the list is not a list of list of longs, return empty list.\n      \
    \  // If the list is not a list of list of longs, return empty list.\n       \
    \ // If the list is not a list of list of longs, return empty list.\n        //\
    \ If the list is not a list of list of longs, return empty list.\n        // If\
    \ the list is not a list of list of longs, return empty list.\n        // If the\
    \ list is not a list of list of longs, return empty list.\n        // If the list\
    \ is not a list of list of longs, return empty list.\n        // If the list is\
    \ not a list of list of longs, return empty list.\n        // If the list is not\
    \ a list of list of longs, return empty list.\n        // If the list is not a\
    \ list of list of longs, return empty list.\n        // If the\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpljda93fi.scala:19:78\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m    \e[33mdef\e[0m \e[36mgetRow\e\
    [0m(\e[36mlst\e[0m : \e[35mList\e[0m[\e[35mList\e[0m[\e[35mLong\e[0m]], \e[36mx\e\
    [0m : \e[35mLong\e[0m) : \e[35mList\e[0m[\e[35mTuple2\e[0m[\e[35mLong\e[0m, \e\
    [35mLong\e[0m]] = {\n\e[31m\e[31m   |\e[0m                                   \
    \                                           ^\e[0m\n\e[31m   |\e[0m          \
    \                                  Found:    Unit\n\e[31m   |\e[0m           \
    \                                 Required: List[(Long, Long)]\n\e[31m20 |\e[0m\
    \        \e[34m// Fill up this function body\e[0m\n\e[31m21 |\e[0m        \e[34m//\
    \ 'lst' is a nested list, similar to matrix,\e[0m\n\e[31m22 |\e[0m        \e[34m//\
    \ 'x' is an integer to be searched in the list\e[0m\n\e[31m23 |\e[0m        \e\
    [34m// Return a list of tuples, [(x1, y1), (x2, y2) ...] such that\e[0m\n\e[31m24\
    \ |\e[0m        \e[34m// each tuple is a coordinate - (row, columns), starting\
    \ with 0.\e[0m\n\e[31m25 |\e[0m        \e[34m// Sort coordinates initially by\
    \ rows in ascending order.\e[0m\n\e[31m26 |\e[0m        \e[34m// Also, sort coordinates\
    \ of the row by columns in descending order.\e[0m\n\e[31m27 |\e[0m        \e[34m//\
    \ If x is not found in the list, return empty list.\e[0m\n\e[31m28 |\e[0m    \
    \    \e[34m// If the list is empty, return empty list.\e[0m\n\e[31m29 |\e[0m \
    \       \e[34m// If the list is None, return empty list.\e[0m\n\e[31m30 |\e[0m\
    \        \e[34m// If the list is not a nested list, return empty list.\e[0m\n\e\
    [31m31 |\e[0m        \e[34m// If the list is not a list of lists, return empty\
    \ list.\e[0m\n\e[31m32 |\e[0m        \e[34m// If the list is not a list of list\
    \ of integers, return empty list.\e[0m\n\e[31m33 |\e[0m        \e[34m// If the\
    \ list is not a list of list of longs, return empty list.\e[0m\n\e[31m34 |\e[0m\
    \        \e[34m// If the list is not a list of list of longs, return empty list.\e\
    [0m\n\e[31m35 |\e[0m        \e[34m// If the list is not a list of list of longs,\
    \ return empty list.\e[0m\n\e[31m36 |\e[0m        \e[34m// If the list is not\
    \ a list of list of longs, return empty list.\e[0m\n\e[31m37 |\e[0"
  stdout: ''
  timestamp: 1659804121
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // Fill up this function body\n\
    \        // 'lst' is a nested list of integers\n        // 'x' is an integer\n\
    \        // Return a list of tuples, [(x1, y1), (x2, y2) ...] such that\n    \
    \    // each tuple is a coordinate - (row, columns), starting with 0.\n      \
    \  // Sort coordinates initially by rows in ascending order.\n        // Also,\
    \ sort coordinates of the row by columns in descending order.\n        // If there\
    \ are no coordinates, return empty list.\n        // If there are no coordinates,\
    \ return empty list.\n        var result : List[Tuple2[Long, Long]] = List()\n\
    \        for (i <- 0 to lst.length - 1) {\n            for (j <- 0 to lst(i).length\
    \ - 1) {\n                if (lst(i)(j) == x) {\n                    result =\
    \ (i, j) :: result\n                }\n            }\n        }\n        result.sortWith((a,\
    \ b) => (a._1 < b._1) || (a._1 == b._1 && a._2 > b._2))\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804123
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // Fill up this function body\n\
    \        // 'lst' is a nested list, which is similar to matrix,\n        // however,\
    \ unlike matrices, each row may contain a different number of columns.\n     \
    \   // 'x' is an integer.\n        // You have to find integers 'x' in the list,\n\
    \        // and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n  \
    \      // each tuple is a coordinate - (row, columns), starting with 0.\n    \
    \    // Sort coordinates initially by rows in ascending order.\n        // Also,\
    \ sort coordinates of the row by columns in descending order.\n        // If you\
    \ find no 'x' in the list, return empty list.\n        // If the list is empty,\
    \ return empty list.\n        // If the list is empty, return empty list.\n  \
    \      // If the list is empty, return empty list.\n        // If the list is\
    \ empty, return empty list.\n        // If the list is empty, return empty list.\n\
    \        // If the list is empty, return empty list.\n        // If the list is\
    \ empty, return empty list.\n        // If the list is empty, return empty list.\n\
    \        // If the list is empty, return empty list.\n        // If the list is\
    \ empty, return empty list.\n        // If the list is empty, return empty list.\n\
    \        // If the list is empty, return empty list.\n        // If the list is\
    \ empty, return empty list.\n        // If the list is empty, return empty list.\n\
    \        // If the list is empty, return empty list.\n        // If the list is\
    \ empty, return empty list.\n        // If the list is empty, return empty list.\n\
    \        // If the list is empty, return empty list.\n        // If the list is\
    \ empty, return empty list.\n        // If the list is empty, return empty list.\n\
    \        // If the list is empty, return empty list.\n        // If the list is\
    \ empty, return empty list.\n        // If the list is empty, return empty list.\n\
    \        // If the list is empty, return empty list.\n        // If the list is\
    \ empty, return empty list.\n        // If the list is empty, return empty list.\n\
    \        // If the list is empty, return empty list\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp8zrzc1y9.scala:19:78\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m    \e[33mdef\e[0m \e[36mgetRow\e\
    [0m(\e[36mlst\e[0m : \e[35mList\e[0m[\e[35mList\e[0m[\e[35mLong\e[0m]], \e[36mx\e\
    [0m : \e[35mLong\e[0m) : \e[35mList\e[0m[\e[35mTuple2\e[0m[\e[35mLong\e[0m, \e\
    [35mLong\e[0m]] = {\n\e[31m\e[31m   |\e[0m                                   \
    \                                           ^\e[0m\n\e[31m   |\e[0m          \
    \                                  Found:    Unit\n\e[31m   |\e[0m           \
    \                                 Required: List[(Long, Long)]\n\e[31m20 |\e[0m\
    \        \e[34m// Fill up this function body\e[0m\n\e[31m21 |\e[0m        \e[34m//\
    \ 'lst' is a nested list, which is similar to matrix,\e[0m\n\e[31m22 |\e[0m  \
    \      \e[34m// however, unlike matrices, each row may contain a different number\
    \ of columns.\e[0m\n\e[31m23 |\e[0m        \e[34m// 'x' is an integer.\e[0m\n\e\
    [31m24 |\e[0m        \e[34m// You have to find integers 'x' in the list,\e[0m\n\
    \e[31m25 |\e[0m        \e[34m// and return list of tuples, [(x1, y1), (x2, y2)\
    \ ...] such that\e[0m\n\e[31m26 |\e[0m        \e[34m// each tuple is a coordinate\
    \ - (row, columns), starting with 0.\e[0m\n\e[31m27 |\e[0m        \e[34m// Sort\
    \ coordinates initially by rows in ascending order.\e[0m\n\e[31m28 |\e[0m    \
    \    \e[34m// Also, sort coordinates of the row by columns in descending order.\e\
    [0m\n\e[31m29 |\e[0m        \e[34m// If you find no 'x' in the list, return empty\
    \ list.\e[0m\n\e[31m30 |\e[0m        \e[34m// If the list is empty, return empty\
    \ list.\e[0m\n\e[31m31 |\e[0m        \e[34m// If the list is empty, return empty\
    \ list.\e[0m\n\e[31m32 |\e[0m        \e[34m// If the list is empty, return empty\
    \ list.\e[0m\n\e[31m33 |\e[0m        \e[34m// If the list is empty, return empty\
    \ list.\e[0m\n\e[31m34 |\e[0m        \e[34m// If the list is empty, return empty\
    \ list.\e[0m\n\e[31m35 |\e[0m        \e[34m// If the list is empty, return empty\
    \ list.\e[0m\n\e[31m36 |\e[0m        \e[34m// If the list is empty, return empty\
    \ list.\e[0m\n\e[31m37 |\e[0m        \e[34m// If the list is empty, return empty\
    \ list.\e[0m\n\e[31m38 |\e[0m        \e[34m// If the list is empty, "
  stdout: ''
  timestamp: 1659804121
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = (i, j) :: result\n                }\n\
    \            }\n        }\n        result.sortWith((a, b) => a._1 < b._1 || (a._1\
    \ == b._1 && a._2 > b._2))\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804084
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // Fill up this function body\n\
    \        // 'lst' is a nested list, similar to matrix, however,\n        // unlike\
    \ matrices, each row may contain a different number of columns.\n        // 'x'\
    \ is an integer, which is to be found in the list.\n        // Return list of\
    \ tuples, [(x1, y1), (x2, y2) ...] such that\n        // each tuple is a coordinate\
    \ - (row, columns), starting with 0.\n        // Sort coordinates initially by\
    \ rows in ascending order.\n        // Also, sort coordinates of the row by columns\
    \ in descending order.\n        // If 'x' is not found in the list, return empty\
    \ list.\n        // If 'lst' is empty, return empty list.\n        // If 'lst'\
    \ is a list of empty lists, return empty list.\n        // If 'lst' is a list\
    \ of lists, each of which is empty, return empty list.\n        // If 'lst' is\
    \ a list of lists, each of which is a list of empty lists, return empty list.\n\
    \        // If 'lst' is a list of lists, each of which is a list of lists, each\
    \ of which is empty, return empty list.\n        // If 'lst' is a list of lists,\
    \ each of which is a list of lists, each of which is a list of empty lists, return\
    \ empty list.\n        // If 'lst' is a list of lists, each of which is a list\
    \ of lists, each of which is a list of lists, each of which is empty, return empty\
    \ list.\n        // If 'lst' is a list of lists, each of which is a list of lists,\
    \ each of which is a list of lists, each of which is a list of empty lists, return\
    \ empty list.\n        // If 'lst' is a list of lists, each of which is a list\
    \ of lists, each of which is a list of lists, each of which is a list of lists,\
    \ each of which is empty, return empty list.\n        // If 'lst' is a list of\
    \ lists, each of which is a list of lists, each of which is a list of lists, each\
    \ of which is a list of lists, each of which is a list of empty lists, return\
    \ empty list.\n        // If 'lst' is\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpn94pkcwa.scala:19:78\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m    \e[33mdef\e[0m \e[36mgetRow\e\
    [0m(\e[36mlst\e[0m : \e[35mList\e[0m[\e[35mList\e[0m[\e[35mLong\e[0m]], \e[36mx\e\
    [0m : \e[35mLong\e[0m) : \e[35mList\e[0m[\e[35mTuple2\e[0m[\e[35mLong\e[0m, \e\
    [35mLong\e[0m]] = {\n\e[31m\e[31m   |\e[0m                                   \
    \                                           ^\e[0m\n\e[31m   |\e[0m          \
    \                                  Found:    Unit\n\e[31m   |\e[0m           \
    \                                 Required: List[(Long, Long)]\n\e[31m20 |\e[0m\
    \        \e[34m// Fill up this function body\e[0m\n\e[31m21 |\e[0m        \e[34m//\
    \ 'lst' is a nested list, similar to matrix, however,\e[0m\n\e[31m22 |\e[0m  \
    \      \e[34m// unlike matrices, each row may contain a different number of columns.\e\
    [0m\n\e[31m23 |\e[0m        \e[34m// 'x' is an integer, which is to be found in\
    \ the list.\e[0m\n\e[31m24 |\e[0m        \e[34m// Return list of tuples, [(x1,\
    \ y1), (x2, y2) ...] such that\e[0m\n\e[31m25 |\e[0m        \e[34m// each tuple\
    \ is a coordinate - (row, columns), starting with 0.\e[0m\n\e[31m26 |\e[0m   \
    \     \e[34m// Sort coordinates initially by rows in ascending order.\e[0m\n\e\
    [31m27 |\e[0m        \e[34m// Also, sort coordinates of the row by columns in\
    \ descending order.\e[0m\n\e[31m28 |\e[0m        \e[34m// If 'x' is not found\
    \ in the list, return empty list.\e[0m\n\e[31m29 |\e[0m        \e[34m// If 'lst'\
    \ is empty, return empty list.\e[0m\n\e[31m30 |\e[0m        \e[34m// If 'lst'\
    \ is a list of empty lists, return empty list.\e[0m\n\e[31m31 |\e[0m        \e\
    [34m// If 'lst' is a list of lists, each of which is empty, return empty list.\e\
    [0m\n\e[31m32 |\e[0m        \e[34m// If 'lst' is a list of lists, each of which\
    \ is a list of empty lists, return empty list.\e[0m\n\e[31m33 |\e[0m        \e\
    [34m// If 'lst' is a list of lists, each of which is a list of lists, each of\
    \ which is empty, return empty list.\e[0m\n\e[31m34 |\e[0m        \e[34m// If\
    \ 'lst' is a list of lists, each of which is a list of lists, each of which is\
    \ a list of empty lists, return empty list.\e[0m\n\e[31m35 |\e[0m      "
  stdout: ''
  timestamp: 1659804121
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            var row = lst(i)\n            for (j <- 0 until row.length) {\n \
    \               if (row(j) == x) {\n                    result = result :+ (i.toLong,\
    \ j.toLong)\n                }\n            }\n        }\n        result.sortWith((a,\
    \ b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804123
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // Fill up this function body\n\
    \        // 'lst' is a nested list, similar to matrix,\n        // however, unlike\
    \ matrices, each row may contain a different number of columns.\n        // 'x'\
    \ is an integer.\n        // You have to find integers x in the list,\n      \
    \  // and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n        //\
    \ each tuple is a coordinate - (row, columns), starting with 0.\n        // Sort\
    \ coordinates initially by rows in ascending order.\n        // Also, sort coordinates\
    \ of the row by columns in descending order.\n        var result = List[Tuple2[Long,\
    \ Long]]()\n        for (i <- 0 until lst.length) {\n            for (j <- 0 until\
    \ lst(i).length) {\n                if (lst(i)(j) == x) {\n                  \
    \  result = result :+ (i.toLong, j.toLong)\n                }\n            }\n\
    \        }\n        result.sortWith((a, b) => a._1 < b._1 || (a._1 == b._1 &&\
    \ a._2 > b._2))\n    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804123
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // Fill up this function body\n\
    \        // 'lst' is a nested list, similar to matrix,\n        // 'x' is an integer\
    \ to be searched in the list\n        // Return a list of tuples, [(x1, y1), (x2,\
    \ y2) ...]\n        // such that each tuple is a coordinate - (row, columns),\n\
    \        // starting with 0.\n        // Sort coordinates initially by rows in\
    \ ascending order.\n        // Also, sort coordinates of the row by columns in\
    \ descending order.\n        // If x is not found, return empty list.\n      \
    \  // If lst is empty, return empty list.\n        // If lst is a list of empty\
    \ lists, return empty list.\n        // If lst is a list of lists, each of which\
    \ is empty, return empty list.\n        // If lst is a list of lists, each of\
    \ which contains only x, return empty list.\n        // If lst is a list of lists,\
    \ each of which contains only x, return empty list.\n        // If lst is a list\
    \ of lists, each of which contains only x, return empty list.\n        // If lst\
    \ is a list of lists, each of which contains only x, return empty list.\n    \
    \    // If lst is a list of lists, each of which contains only x, return empty\
    \ list.\n        // If lst is a list of lists, each of which contains only x,\
    \ return empty list.\n        // If lst is a list of lists, each of which contains\
    \ only x, return empty list.\n        // If lst is a list of lists, each of which\
    \ contains only x, return empty list.\n        // If lst is a list of lists, each\
    \ of which contains only x, return empty list.\n        // If lst is a list of\
    \ lists, each of which contains only x, return empty list.\n        // If lst\
    \ is a list of lists, each of which contains only x, return empty list.\n    \
    \    // If lst is a list of lists, each of which contains only x, return empty\
    \ list.\n        // If lst is a list of lists, each of which contains only x,\
    \ return empty list.\n        // If lst is a list of lists, each of which contains\
    \ only x, return empty list.\n        // If lst is a list\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnrv3cky0.scala:19:78\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m    \e[33mdef\e[0m \e[36mgetRow\e\
    [0m(\e[36mlst\e[0m : \e[35mList\e[0m[\e[35mList\e[0m[\e[35mLong\e[0m]], \e[36mx\e\
    [0m : \e[35mLong\e[0m) : \e[35mList\e[0m[\e[35mTuple2\e[0m[\e[35mLong\e[0m, \e\
    [35mLong\e[0m]] = {\n\e[31m\e[31m   |\e[0m                                   \
    \                                           ^\e[0m\n\e[31m   |\e[0m          \
    \                                  Found:    Unit\n\e[31m   |\e[0m           \
    \                                 Required: List[(Long, Long)]\n\e[31m20 |\e[0m\
    \        \e[34m// Fill up this function body\e[0m\n\e[31m21 |\e[0m        \e[34m//\
    \ 'lst' is a nested list, similar to matrix,\e[0m\n\e[31m22 |\e[0m        \e[34m//\
    \ 'x' is an integer to be searched in the list\e[0m\n\e[31m23 |\e[0m        \e\
    [34m// Return a list of tuples, [(x1, y1), (x2, y2) ...]\e[0m\n\e[31m24 |\e[0m\
    \        \e[34m// such that each tuple is a coordinate - (row, columns),\e[0m\n\
    \e[31m25 |\e[0m        \e[34m// starting with 0.\e[0m\n\e[31m26 |\e[0m       \
    \ \e[34m// Sort coordinates initially by rows in ascending order.\e[0m\n\e[31m27\
    \ |\e[0m        \e[34m// Also, sort coordinates of the row by columns in descending\
    \ order.\e[0m\n\e[31m28 |\e[0m        \e[34m// If x is not found, return empty\
    \ list.\e[0m\n\e[31m29 |\e[0m        \e[34m// If lst is empty, return empty list.\e\
    [0m\n\e[31m30 |\e[0m        \e[34m// If lst is a list of empty lists, return empty\
    \ list.\e[0m\n\e[31m31 |\e[0m        \e[34m// If lst is a list of lists, each\
    \ of which is empty, return empty list.\e[0m\n\e[31m32 |\e[0m        \e[34m//\
    \ If lst is a list of lists, each of which contains only x, return empty list.\e\
    [0m\n\e[31m33 |\e[0m        \e[34m// If lst is a list of lists, each of which\
    \ contains only x, return empty list.\e[0m\n\e[31m34 |\e[0m        \e[34m// If\
    \ lst is a list of lists, each of which contains only x, return empty list.\e\
    [0m\n\e[31m35 |\e[0m        \e[34m// If lst is a list of lists, each of which\
    \ contains only x, return empty list.\e[0m\n\e[31m36 |\e[0m        \e[34m// If\
    \ lst is a list of lists, each of which contains only x, return empt"
  stdout: ''
  timestamp: 1659804122
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // Fill up this function body\n\
    \        // 'lst' is a list of lists, each list is a row\n        // 'x' is the\
    \ number to be searched in the list\n        // Return a list of tuples, each\
    \ tuple is a coordinate - (row, column)\n        // Sort coordinates initially\
    \ by rows in ascending order.\n        // Also, sort coordinates of the row by\
    \ columns in descending order.\n        var result = List[Tuple2[Long, Long]]()\n\
    \        for (i <- 0 until lst.length) {\n            for (j <- 0 until lst(i).length)\
    \ {\n                if (lst(i)(j) == x) {\n                    result = result\
    \ :+ (i.toLong, j.toLong)\n                }\n            }\n        }\n     \
    \   result.sortWith((a, b) => {\n            if (a._1 == b._1) {\n           \
    \     a._2 > b._2\n            } else {\n                a._1 < b._1\n       \
    \     }\n        })\n    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804123
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // Fill up this function body\n\
    \        // 'lst' is a nested list, similar to matrix, but unlike matrix,\n  \
    \      // each row may contain a different number of columns.\n        // 'x'\
    \ is an integer, which is to be found in the list.\n        // Return list of\
    \ tuples, [(x1, y1), (x2, y2) ...] such that\n        // each tuple is a coordinate\
    \ - (row, columns), starting with 0.\n        // Sort coordinates initially by\
    \ rows in ascending order.\n        // Also, sort coordinates of the row by columns\
    \ in descending order.\n        // If x is not found in the list, return empty\
    \ list.\n        // If list is empty, return empty list.\n        // Note: You\
    \ can use built-in sort function, however,\n        // you can also write your\
    \ own sorting function.\n        // Note: You can use built-in sort function,\
    \ however,\n        // you can also write your own sorting function.\n       \
    \ var result : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n       \
    \ for (i <- 0 to lst.length - 1) {\n            for (j <- 0 to lst(i).length -\
    \ 1) {\n                if (lst(i)(j) == x) {\n                    result = result\
    \ :+ (i.toLong, j.toLong)\n                }\n            }\n        }\n     \
    \   result.sortWith((a, b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804123
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            val row = lst(i)\n            for (j <- 0 until row.length) {\n \
    \               if (row(j) == x) {\n                    result = (i, j) :: result\n\
    \                }\n            }\n        }\n        result.sortWith((a, b) =>\
    \ a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804124
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => a._1\
    \ < b._1 || (a._1 == b._1 && a._2 > b._2))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804084
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => a._1\
    \ < b._1 || (a._1 == b._1 && a._2 > b._2))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804084
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = (i, j) :: result\n                }\n\
    \            }\n        }\n        result.sortWith((x, y) => (x._1 < y._1) ||\
    \ (x._1 == y._1 && x._2 > y._2))\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804130
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => {\n\
    \            if (a._1 < b._1) {\n                true\n            } else if (a._1\
    \ == b._1) {\n                a._2 > b._2\n            } else {\n            \
    \    false\n            }\n        })\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804084
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // Fill up this function body\n\
    \        // 'lst' is a nested list, which is similar to matrix,\n        // however,\
    \ unlike matrices, each row may contain a different number of columns.\n     \
    \   // 'x' is an integer, which is to be found in the list.\n        // You have\
    \ to return a list of tuples, [(x1, y1), (x2, y2) ...] such that\n        // each\
    \ tuple is a coordinate - (row, columns), starting with 0.\n        // Sort coordinates\
    \ initially by rows in ascending order.\n        // Also, sort coordinates of\
    \ the row by columns in descending order.\n        // If x is not found in the\
    \ list, return empty list.\n        // If the list is empty, return empty list.\n\
    \        // If the list is None, return empty list.\n        // If the list is\
    \ not a nested list, return empty list.\n        // If the list is not a list\
    \ of lists, return empty list.\n        // If the list is not a list of list of\
    \ integers, return empty list.\n        // If the list is not a list of list of\
    \ longs, return empty list.\n        // If the list is not a list of list of longs,\
    \ return empty list.\n        // If the list is not a list of list of longs, return\
    \ empty list.\n        // If the list is not a list of list of longs, return empty\
    \ list.\n        // If the list is not a list of list of longs, return empty list.\n\
    \        // If the list is not a list of list of longs, return empty list.\n \
    \       // If the list is not a list of list of longs, return empty list.\n  \
    \      // If the list is not a list of list of longs, return empty list.\n   \
    \     // If the list is not a list of list of longs, return empty list.\n    \
    \    // If the list is not a list of list of longs, return empty list.\n     \
    \   // If the list is not a list of list of longs, return empty list.\n      \
    \  // If the list is not a list of list of longs, return empty list.\n       \
    \ // If the list is not a list of list of longs, return empty list.\n        //\
    \ If the list is not a list of list of longs, return\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpwj4_w9yp.scala:19:78\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m    \e[33mdef\e[0m \e[36mgetRow\e\
    [0m(\e[36mlst\e[0m : \e[35mList\e[0m[\e[35mList\e[0m[\e[35mLong\e[0m]], \e[36mx\e\
    [0m : \e[35mLong\e[0m) : \e[35mList\e[0m[\e[35mTuple2\e[0m[\e[35mLong\e[0m, \e\
    [35mLong\e[0m]] = {\n\e[31m\e[31m   |\e[0m                                   \
    \                                           ^\e[0m\n\e[31m   |\e[0m          \
    \                                  Found:    Unit\n\e[31m   |\e[0m           \
    \                                 Required: List[(Long, Long)]\n\e[31m20 |\e[0m\
    \        \e[34m// Fill up this function body\e[0m\n\e[31m21 |\e[0m        \e[34m//\
    \ 'lst' is a nested list, which is similar to matrix,\e[0m\n\e[31m22 |\e[0m  \
    \      \e[34m// however, unlike matrices, each row may contain a different number\
    \ of columns.\e[0m\n\e[31m23 |\e[0m        \e[34m// 'x' is an integer, which is\
    \ to be found in the list.\e[0m\n\e[31m24 |\e[0m        \e[34m// You have to return\
    \ a list of tuples, [(x1, y1), (x2, y2) ...] such that\e[0m\n\e[31m25 |\e[0m \
    \       \e[34m// each tuple is a coordinate - (row, columns), starting with 0.\e\
    [0m\n\e[31m26 |\e[0m        \e[34m// Sort coordinates initially by rows in ascending\
    \ order.\e[0m\n\e[31m27 |\e[0m        \e[34m// Also, sort coordinates of the row\
    \ by columns in descending order.\e[0m\n\e[31m28 |\e[0m        \e[34m// If x is\
    \ not found in the list, return empty list.\e[0m\n\e[31m29 |\e[0m        \e[34m//\
    \ If the list is empty, return empty list.\e[0m\n\e[31m30 |\e[0m        \e[34m//\
    \ If the list is None, return empty list.\e[0m\n\e[31m31 |\e[0m        \e[34m//\
    \ If the list is not a nested list, return empty list.\e[0m\n\e[31m32 |\e[0m \
    \       \e[34m// If the list is not a list of lists, return empty list.\e[0m\n\
    \e[31m33 |\e[0m        \e[34m// If the list is not a list of list of integers,\
    \ return empty list.\e[0m\n\e[31m34 |\e[0m        \e[34m// If the list is not\
    \ a list of list of longs, return empty list.\e[0m\n\e[31m35 |\e[0m        \e\
    [34m// If the list is not a list of list of longs, return empty list.\e[0m\n\e\
    [31m36 |\e[0m        \e[34m// If the list is not a list of list o"
  stdout: ''
  timestamp: 1659804128
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // Fill up this function body\n\
    \        // 'lst' is a nested list, which is similar to matrix, however, unlike\
    \ matrices,\n        // each row may contain a different number of columns.\n\
    \        // 'x' is an integer\n        // You have to find integers 'x' in the\
    \ list,\n        // and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    \        // each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \      // Sort coordinates initially by rows in ascending order.\n        // Also,\
    \ sort coordinates of the row by columns in descending order.\n        var result\
    \ : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0\
    \ until lst.length) {\n            for (j <- 0 until lst(i).length) {\n      \
    \          if (lst(i)(j) == x) {\n                    result = result :+ (i.toLong,\
    \ j.toLong)\n                }\n            }\n        }\n        result.sortWith(_._1\
    \ < _._1).sortWith(_._2 > _._2)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_bnichtk.scala:40)\n\tat Problem.main(tmp_bnichtk.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659804133
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = (i, j) :: result\n                }\n\
    \            }\n        }\n        result.sortWith((a, b) => a._1 < b._1 || (a._1\
    \ == b._1 && a._2 > b._2))\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804084
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => {\n\
    \            if (a._1 < b._1) {\n                true\n            } else if (a._1\
    \ == b._1) {\n                a._2 > b._2\n            } else {\n            \
    \    false\n            }\n        })\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804084
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // Fill up this function body\n\
    \        // 'lst' is a nested list, which is similar to matrix,\n        // however,\
    \ unlike matrices, each row may contain a different number of columns.\n     \
    \   // 'x' is an integer to be searched in the list.\n        // Return a list\
    \ of tuples, [(x1, y1), (x2, y2) ...] such that\n        // each tuple is a coordinate\
    \ - (row, columns), starting with 0.\n        // Sort coordinates initially by\
    \ rows in ascending order.\n        // Also, sort coordinates of the row by columns\
    \ in descending order.\n        var result = List[Tuple2[Long, Long]]()\n    \
    \    for (i <- 0 until lst.length) {\n            for (j <- 0 until lst(i).length)\
    \ {\n                if (lst(i)(j) == x) {\n                    result = result\
    \ :+ (i.toLong, j.toLong)\n                }\n            }\n        }\n     \
    \   result.sortWith((a, b) => {\n            if (a._1 < b._1) true\n         \
    \   else if (a._1 == b._1) a._2 > b._2\n            else false\n        })\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804132
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => a._1\
    \ < b._1 || (a._1 == b._1 && a._2 > b._2))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804084
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = (i, j) :: result\n                }\n\
    \            }\n        }\n        result.sortWith((a, b) => (a._1 < b._1) ||\
    \ (a._1 == b._1 && a._2 > b._2))\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804121
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => a._1\
    \ < b._1 || (a._1 == b._1 && a._2 > b._2))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804084
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var lst2 = List[Tuple2[Long,\
    \ Long]]()\n        for (i <- 0 until lst.length) {\n            for (j <- 0 until\
    \ lst(i).length) {\n                if (lst(i)(j) == x) {\n                  \
    \  lst2 = (i.toLong, j.toLong) :: lst2\n                }\n            }\n   \
    \     }\n        lst2.sortWith((t1, t2) => {\n            if (t1._1 < t2._1) true\n\
    \            else if (t1._1 == t2._1) t1._2 > t2._2\n            else false\n\
    \        })\n    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804133
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => a._1\
    \ < b._1 || (a._1 == b._1 && a._2 > b._2))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804084
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // Fill up this function body\n\
    \        // 'lst' is a list of lists, each list is a row\n        // 'x' is the\
    \ number to be searched for\n        // return a list of tuples, each tuple is\
    \ a coordinate (row, column)\n        // sort the coordinates initially by rows\
    \ in ascending order\n        // also, sort coordinates of the row by columns\
    \ in descending order\n        // if 'x' is not found, return an empty list\n\
    \        // if 'lst' is empty, return an empty list\n        // if 'lst' is not\
    \ a list of lists, return an empty list\n        // if 'x' is not a number, return\
    \ an empty list\n        // if 'lst' contains an empty list, return an empty list\n\
    \        // if 'lst' contains a list with non-numbers, return an empty list\n\
    \        // if 'lst' contains a list with non-integers, return an empty list\n\
    \        // if 'lst' contains a list with negative integers, return an empty list\n\
    \        // if 'lst' contains a list with integers greater than 2^31 - 1, return\
    \ an empty list\n        // if 'lst' contains a list with integers less than -2^31,\
    \ return an empty list\n        // if 'lst' contains a list with integers greater\
    \ than 2^63 - 1, return an empty list\n        // if 'lst' contains a list with\
    \ integers less than -2^63, return an empty list\n        // if 'lst' contains\
    \ a list with integers greater than 2^127 - 1, return an empty list\n        //\
    \ if 'lst' contains a list with integers less than -2^127, return an empty list\n\
    \        // if 'lst' contains a list with integers greater than 2^255 - 1, return\
    \ an empty list\n        // if 'lst' contains a list with integers less than -2^255,\
    \ return an empty list\n        // if 'lst' contains a list with integers greater\
    \ than 2^511 - 1, return an empty list\n        // if 'lst' contains a list with\
    \ integers less than -2^511, return an empty list\n        // if 'lst' contains\
    \ a list with integers greater than 2^1023 - 1, return an empty list\n       \
    \ // if 'lst' contains a list with\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpg37wnf_3.scala:19:78\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m    \e[33mdef\e[0m \e[36mgetRow\e\
    [0m(\e[36mlst\e[0m : \e[35mList\e[0m[\e[35mList\e[0m[\e[35mLong\e[0m]], \e[36mx\e\
    [0m : \e[35mLong\e[0m) : \e[35mList\e[0m[\e[35mTuple2\e[0m[\e[35mLong\e[0m, \e\
    [35mLong\e[0m]] = {\n\e[31m\e[31m   |\e[0m                                   \
    \                                           ^\e[0m\n\e[31m   |\e[0m          \
    \                                  Found:    Unit\n\e[31m   |\e[0m           \
    \                                 Required: List[(Long, Long)]\n\e[31m20 |\e[0m\
    \        \e[34m// Fill up this function body\e[0m\n\e[31m21 |\e[0m        \e[34m//\
    \ 'lst' is a list of lists, each list is a row\e[0m\n\e[31m22 |\e[0m        \e\
    [34m// 'x' is the number to be searched for\e[0m\n\e[31m23 |\e[0m        \e[34m//\
    \ return a list of tuples, each tuple is a coordinate (row, column)\e[0m\n\e[31m24\
    \ |\e[0m        \e[34m// sort the coordinates initially by rows in ascending order\e\
    [0m\n\e[31m25 |\e[0m        \e[34m// also, sort coordinates of the row by columns\
    \ in descending order\e[0m\n\e[31m26 |\e[0m        \e[34m// if 'x' is not found,\
    \ return an empty list\e[0m\n\e[31m27 |\e[0m        \e[34m// if 'lst' is empty,\
    \ return an empty list\e[0m\n\e[31m28 |\e[0m        \e[34m// if 'lst' is not a\
    \ list of lists, return an empty list\e[0m\n\e[31m29 |\e[0m        \e[34m// if\
    \ 'x' is not a number, return an empty list\e[0m\n\e[31m30 |\e[0m        \e[34m//\
    \ if 'lst' contains an empty list, return an empty list\e[0m\n\e[31m31 |\e[0m\
    \        \e[34m// if 'lst' contains a list with non-numbers, return an empty list\e\
    [0m\n\e[31m32 |\e[0m        \e[34m// if 'lst' contains a list with non-integers,\
    \ return an empty list\e[0m\n\e[31m33 |\e[0m        \e[34m// if 'lst' contains\
    \ a list with negative integers, return an empty list\e[0m\n\e[31m34 |\e[0m  \
    \      \e[34m// if 'lst' contains a list with integers greater than 2^31 - 1,\
    \ return an empty list\e[0m\n\e[31m35 |\e[0m        \e[34m// if 'lst' contains\
    \ a list with integers less than -2^31, return an empty list\e[0m\n\e[31m36 |\e\
    [0m        \e[34m// if 'lst' contains a list with integers "
  stdout: ''
  timestamp: 1659804131
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // Fill up this function body\n\
    \        // 'lst' is a nested list, similar to matrix, but each row may contain\
    \ a different number of columns.\n        // 'x' is an integer to be searched\
    \ in the list.\n        // Return a list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n        // each tuple is a coordinate - (row, columns), starting with\
    \ 0.\n        // Sort coordinates initially by rows in ascending order.\n    \
    \    // Also, sort coordinates of the row by columns in descending order.\n  \
    \      // If x is not found in the list, return an empty list.\n        // If\
    \ the list is empty, return an empty list.\n        var result = List[Tuple2[Long,\
    \ Long]]()\n        for (i <- 0 until lst.length) {\n            for (j <- 0 until\
    \ lst(i).length) {\n                if (lst(i)(j) == x) {\n                  \
    \  result = result :+ (i.toLong, j.toLong)\n                }\n            }\n\
    \        }\n        result.sortWith((a, b) => a._1 < b._1 || (a._1 == b._1 &&\
    \ a._2 > b._2))\n    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804134
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => {\n\
    \            if (a._1 < b._1) {\n                true\n            } else if (a._1\
    \ == b._1) {\n                a._2 > b._2\n            } else {\n            \
    \    false\n            }\n        })\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804084
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => {\n\
    \            if (a._1 == b._1) {\n                a._2 > b._2\n            } else\
    \ {\n                a._1 < b._1\n            }\n        })\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804084
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // Fill up this function body\n\
    \        // 'lst' is a list of lists, where each list is a row of a matrix\n \
    \       // 'x' is the element to be searched in the matrix\n        // Return\
    \ a list of tuples, each tuple is a coordinate of the element\n        // Sort\
    \ the list of tuples initially by rows in ascending order\n        // Also, sort\
    \ coordinates of the row by columns in descending order\n        // If the element\
    \ is not found, return an empty list\n        // If the list is empty, return\
    \ an empty list\n        var result = List[Tuple2[Long, Long]]()\n        var\
    \ row = 0\n        for (i <- lst) {\n            var col = 0\n            for\
    \ (j <- i) {\n                if (j == x) {\n                    result = result\
    \ :+ (row, col)\n                }\n                col += 1\n            }\n\
    \            row += 1\n        }\n        result.sortBy(x => (x._1, -x._2))\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804134
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => {\n\
    \            if (a._1 < b._1) {\n                true\n            } else if (a._1\
    \ == b._1) {\n                a._2 > b._2\n            } else {\n            \
    \    false\n            }\n        })\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804084
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // Fill up this function body\n\
    \        // 'lst' is a nested list, similar to matrix, but unlike matrix,\n  \
    \      // each row may contain a different number of columns.\n        // 'x'\
    \ is an integer.\n        // Return a list of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n        // each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n        // Sort coordinates initially by rows in ascending order.\n\
    \        // Also, sort coordinates of the row by columns in descending order.\n\
    \        // If x is not found, return empty list.\n        // If lst is empty,\
    \ return empty list.\n        // Note: You can use built-in sort function.\n \
    \       // Note: You can use built-in zipWithIndex function.\n        // Note:\
    \ You can use built-in flatten function.\n        // Note: You can use built-in\
    \ map function.\n        // Note: You can use built-in filter function.\n    \
    \    // Note: You can use built-in reverse function.\n        // Note: You can\
    \ use built-in toList function.\n        // Note: You can use built-in sortWith\
    \ function.\n        // Note: You can use built-in groupBy function.\n       \
    \ // Note: You can use built-in toList function.\n        // Note: You can use\
    \ built-in sortWith function.\n        // Note: You can use built-in sortWith\
    \ function.\n        // Note: You can use built-in sortWith function.\n      \
    \  // Note: You can use built-in sortWith function.\n        // Note: You can\
    \ use built-in sortWith function.\n        // Note: You can use built-in sortWith\
    \ function.\n        // Note: You can use built-in sortWith function.\n      \
    \  // Note: You can use built-in sortWith function.\n        // Note: You can\
    \ use built-in sortWith function.\n        // Note: You can use built-in sortWith\
    \ function.\n        // Note: You can use built-in sortWith function.\n      \
    \  // Note: You can use built-in sortWith function.\n        // Note: You can\
    \ use built-in sortWith function.\n        // Note: You can use built-in sortWith\
    \ function.\n        // Note\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpvqhgkwui.scala:19:78\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m    \e[33mdef\e[0m \e[36mgetRow\e\
    [0m(\e[36mlst\e[0m : \e[35mList\e[0m[\e[35mList\e[0m[\e[35mLong\e[0m]], \e[36mx\e\
    [0m : \e[35mLong\e[0m) : \e[35mList\e[0m[\e[35mTuple2\e[0m[\e[35mLong\e[0m, \e\
    [35mLong\e[0m]] = {\n\e[31m\e[31m   |\e[0m                                   \
    \                                           ^\e[0m\n\e[31m   |\e[0m          \
    \                                  Found:    Unit\n\e[31m   |\e[0m           \
    \                                 Required: List[(Long, Long)]\n\e[31m20 |\e[0m\
    \        \e[34m// Fill up this function body\e[0m\n\e[31m21 |\e[0m        \e[34m//\
    \ 'lst' is a nested list, similar to matrix, but unlike matrix,\e[0m\n\e[31m22\
    \ |\e[0m        \e[34m// each row may contain a different number of columns.\e\
    [0m\n\e[31m23 |\e[0m        \e[34m// 'x' is an integer.\e[0m\n\e[31m24 |\e[0m\
    \        \e[34m// Return a list of tuples, [(x1, y1), (x2, y2) ...] such that\e\
    [0m\n\e[31m25 |\e[0m        \e[34m// each tuple is a coordinate - (row, columns),\
    \ starting with 0.\e[0m\n\e[31m26 |\e[0m        \e[34m// Sort coordinates initially\
    \ by rows in ascending order.\e[0m\n\e[31m27 |\e[0m        \e[34m// Also, sort\
    \ coordinates of the row by columns in descending order.\e[0m\n\e[31m28 |\e[0m\
    \        \e[34m// If x is not found, return empty list.\e[0m\n\e[31m29 |\e[0m\
    \        \e[34m// If lst is empty, return empty list.\e[0m\n\e[31m30 |\e[0m  \
    \      \e[34m// Note: You can use built-in sort function.\e[0m\n\e[31m31 |\e[0m\
    \        \e[34m// Note: You can use built-in zipWithIndex function.\e[0m\n\e[31m32\
    \ |\e[0m        \e[34m// Note: You can use built-in flatten function.\e[0m\n\e\
    [31m33 |\e[0m        \e[34m// Note: You can use built-in map function.\e[0m\n\e\
    [31m34 |\e[0m        \e[34m// Note: You can use built-in filter function.\e[0m\n\
    \e[31m35 |\e[0m        \e[34m// Note: You can use built-in reverse function.\e\
    [0m\n\e[31m36 |\e[0m        \e[34m// Note: You can use built-in toList function.\e\
    [0m\n\e[31m37 |\e[0m        \e[34m// Note: You can use built-in sortWith function.\e\
    [0m\n\e[31m38 |\e[0m        \e[34m// Note: You can use built-in grou"
  stdout: ''
  timestamp: 1659804131
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = (i, j) :: result\n                }\n\
    \            }\n        }\n        result.sortWith((a, b) => {\n            if\
    \ (a._1 == b._1) {\n                a._2 > b._2\n            } else {\n      \
    \          a._1 < b._1\n            }\n        })\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804134
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => (a._1\
    \ < b._1) || (a._1 == b._1 && a._2 > b._2))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804084
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // Fill up this function body\n\
    \        // 'lst' is a nested list, which is similar to matrix, however, unlike\
    \ matrices,\n        // each row may contain a different number of columns.\n\
    \        // 'x' is an integer.\n        // You have to find integers 'x' in the\
    \ list,\n        // and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    \        // each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \      // Sort coordinates initially by rows in ascending order.\n        // Also,\
    \ sort coordinates of the row by columns in descending order.\n        var result\
    \ = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n    \
    \        for (j <- 0 until lst(i).length) {\n                if (lst(i)(j) ==\
    \ x) {\n                    result = (i.toLong, j.toLong) :: result\n        \
    \        }\n            }\n        }\n        result.sortWith((a, b) => if (a._1\
    \ == b._1) a._2 > b._2 else a._1 < b._1)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804134
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = (i, j) :: result\n                }\n\
    \            }\n        }\n        result.sortWith((a, b) => a._1 < b._1 || (a._1\
    \ == b._1 && a._2 > b._2))\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804084
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => a._1\
    \ < b._1 || (a._1 == b._1 && a._2 > b._2))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804084
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // Fill up this function body\n\
    \        // `lst` is a nested list, which is similar to matrix,\n        // however,\
    \ unlike matrices, each row may contain a different number of columns.\n     \
    \   // `x` is an integer, which you need to find in the list.\n        // Return\
    \ list of tuples, [(x1, y1), (x2, y2) ...] such that\n        // each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n        // Sort coordinates\
    \ initially by rows in ascending order.\n        // Also, sort coordinates of\
    \ the row by columns in descending order.\n        // If `x` is not found in the\
    \ list, return empty list.\n        // If `lst` is empty, return empty list.\n\
    \        // If `lst` is a list of empty lists, return empty list.\n        //\
    \ If `lst` is a list of empty lists, except one list,\n        // and `x` is not\
    \ found in that list, return empty list.\n        // If `lst` is a list of empty\
    \ lists, except one list,\n        // and `x` is found in that list, return list\
    \ of tuples,\n        // [(0, 0), (0, 1), ...] such that each tuple is a coordinate\
    \ - (row, columns),\n        // starting with 0.\n        // Sort coordinates\
    \ initially by rows in ascending order.\n        // Also, sort coordinates of\
    \ the row by columns in descending order.\n        // If `x` is found in the list,\
    \ return list of tuples,\n        // [(x1, y1), (x2, y2) ...] such that each tuple\
    \ is a coordinate - (row, columns),\n        // starting with 0.\n        // Sort\
    \ coordinates initially by rows in ascending order.\n        // Also, sort coordinates\
    \ of the row by columns in descending order.\n        // If `x` is not found in\
    \ the list, return empty list.\n        // If `lst` is empty, return empty list.\n\
    \        // If `lst` is a list of empty lists, return empty list.\n        //\
    \ If `lst` is a list of empty lists, except one list,\n        // and `x` is not\
    \ found in that list, return empty list.\n        // If `lst` is a\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5u08xmz3.scala:19:78\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m    \e[33mdef\e[0m \e[36mgetRow\e\
    [0m(\e[36mlst\e[0m : \e[35mList\e[0m[\e[35mList\e[0m[\e[35mLong\e[0m]], \e[36mx\e\
    [0m : \e[35mLong\e[0m) : \e[35mList\e[0m[\e[35mTuple2\e[0m[\e[35mLong\e[0m, \e\
    [35mLong\e[0m]] = {\n\e[31m\e[31m   |\e[0m                                   \
    \                                           ^\e[0m\n\e[31m   |\e[0m          \
    \                                  Found:    Unit\n\e[31m   |\e[0m           \
    \                                 Required: List[(Long, Long)]\n\e[31m20 |\e[0m\
    \        \e[34m// Fill up this function body\e[0m\n\e[31m21 |\e[0m        \e[34m//\
    \ `lst` is a nested list, which is similar to matrix,\e[0m\n\e[31m22 |\e[0m  \
    \      \e[34m// however, unlike matrices, each row may contain a different number\
    \ of columns.\e[0m\n\e[31m23 |\e[0m        \e[34m// `x` is an integer, which you\
    \ need to find in the list.\e[0m\n\e[31m24 |\e[0m        \e[34m// Return list\
    \ of tuples, [(x1, y1), (x2, y2) ...] such that\e[0m\n\e[31m25 |\e[0m        \e\
    [34m// each tuple is a coordinate - (row, columns), starting with 0.\e[0m\n\e\
    [31m26 |\e[0m        \e[34m// Sort coordinates initially by rows in ascending\
    \ order.\e[0m\n\e[31m27 |\e[0m        \e[34m// Also, sort coordinates of the row\
    \ by columns in descending order.\e[0m\n\e[31m28 |\e[0m        \e[34m// If `x`\
    \ is not found in the list, return empty list.\e[0m\n\e[31m29 |\e[0m        \e\
    [34m// If `lst` is empty, return empty list.\e[0m\n\e[31m30 |\e[0m        \e[34m//\
    \ If `lst` is a list of empty lists, return empty list.\e[0m\n\e[31m31 |\e[0m\
    \        \e[34m// If `lst` is a list of empty lists, except one list,\e[0m\n\e\
    [31m32 |\e[0m        \e[34m// and `x` is not found in that list, return empty\
    \ list.\e[0m\n\e[31m33 |\e[0m        \e[34m// If `lst` is a list of empty lists,\
    \ except one list,\e[0m\n\e[31m34 |\e[0m        \e[34m// and `x` is found in that\
    \ list, return list of tuples,\e[0m\n\e[31m35 |\e[0m        \e[34m// [(0, 0),\
    \ (0, 1), ...] such that each tuple is a coordinate - (row, columns),\e[0m\n\e\
    [31m36 |\e[0m        \e[34m// starting with 0.\e[0m\n\e[31m37 |\e[0m        \e\
    [3"
  stdout: ''
  timestamp: 1659804132
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // Write your code here\n\
    \        val result = ListBuffer[Tuple2[Long, Long]]()\n        for (i <- 0 until\
    \ lst.length) {\n            for (j <- 0 until lst(i).length) {\n            \
    \    if (lst(i)(j) == x) {\n                    result += Tuple2(i.toLong, j.toLong)\n\
    \                }\n            }\n        }\n        result.toList.sortWith((a,\
    \ b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804134
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => a._1\
    \ < b._1 || (a._1 == b._1 && a._2 > b._2))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804084
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => {\n\
    \            if (a._1 == b._1) {\n                a._2 > b._2\n            } else\
    \ {\n                a._1 < b._1\n            }\n        })\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804084
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // Fill up this function body\n\
    \        // 'lst' is a list of lists, each list is a row\n        // 'x' is the\
    \ number to be searched in the list\n        // Return a list of tuples, each\
    \ tuple is a coordinate - (row, columns)\n        // Sort coordinates initially\
    \ by rows in ascending order.\n        // Also, sort coordinates of the row by\
    \ columns in descending order.\n        var result = List[Tuple2[Long, Long]]()\n\
    \        for (i <- 0 until lst.length) {\n            for (j <- 0 until lst(i).length)\
    \ {\n                if (lst(i)(j) == x) {\n                    result = result\
    \ :+ (i.toLong, j.toLong)\n                }\n            }\n        }\n     \
    \   result.sortWith((a, b) => (a._1 < b._1) || (a._1 == b._1 && a._2 > b._2))\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804135
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List()\n        for (i <- 0 until lst.length) {\n            for (j\
    \ <- 0 until lst(i).length) {\n                if (lst(i)(j) == x) {\n       \
    \             result = result :+ (i.toLong, j.toLong)\n                }\n   \
    \         }\n        }\n        result.sortWith((a, b) => a._1 < b._1 || (a._1\
    \ == b._1 && a._2 > b._2))\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804097
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => {\n\
    \            if (a._1 < b._1) {\n                true\n            } else if (a._1\
    \ == b._1) {\n                a._2 > b._2\n            } else {\n            \
    \    false\n            }\n        })\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804084
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => {\n\
    \            if (a._1 < b._1) {\n                true\n            } else if (a._1\
    \ == b._1) {\n                a._2 > b._2\n            } else {\n            \
    \    false\n            }\n        })\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804084
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => {\n\
    \            if (a._1 == b._1) {\n                a._2 > b._2\n            } else\
    \ {\n                a._1 < b._1\n            }\n        })\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804084
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => {\n\
    \            if (a._1 == b._1) {\n                a._2 > b._2\n            } else\
    \ {\n                a._1 < b._1\n            }\n        })\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804084
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => a._1\
    \ < b._1 || (a._1 == b._1 && a._2 > b._2))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804084
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => a._1\
    \ < b._1 || (a._1 == b._1 && a._2 > b._2))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804084
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        val result = ListBuffer[Tuple2[Long,\
    \ Long]]()\n        for (i <- 0 until lst.length) {\n            val row = lst(i)\n\
    \            for (j <- 0 until row.length) {\n                if (row(j) == x)\
    \ {\n                    result += Tuple2(i.toLong, j.toLong)\n              \
    \  }\n            }\n        }\n        result.toList.sortWith((a, b) => a._1\
    \ < b._1 || (a._1 == b._1 && a._2 > b._2))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804135
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = (i, j) :: result\n                }\n\
    \            }\n        }\n        result.sortWith((a, b) => a._1 < b._1 || (a._1\
    \ == b._1 && a._2 > b._2))\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804084
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // Fill up this function body\n\
    \        // 'lst' is a nested list, which is similar to matrix,\n        // however,\
    \ unlike matrices, each row may contain a different number of columns.\n     \
    \   // 'x' is an integer.\n        // You have to find integers 'x' in the list,\n\
    \        // and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n  \
    \      // each tuple is a coordinate - (row, columns), starting with 0.\n    \
    \    // Sort coordinates initially by rows in ascending order.\n        // Also,\
    \ sort coordinates of the row by columns in descending order.\n        val result\
    \ = new ListBuffer[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length)\
    \ {\n            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result += Tuple2(i.toLong, j.toLong)\n        \
    \        }\n            }\n        }\n        result.toList.sortWith((a, b) =>\
    \ a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804135
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => {\n\
    \            if (a._1 < b._1) {\n                true\n            } else if (a._1\
    \ == b._1) {\n                a._2 > b._2\n            } else {\n            \
    \    false\n            }\n        })\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804084
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // Fill up this function body\n\
    \        // 'lst' is a nested list, which is similar to matrix, however, unlike\
    \ matrices,\n        // each row may contain a different number of columns.\n\
    \        // 'x' is an integer\n        // You have to return a list of tuples,\
    \ [(x1, y1), (x2, y2) ...] such that\n        // each tuple is a coordinate -\
    \ (row, columns), starting with 0.\n        // Sort coordinates initially by rows\
    \ in ascending order.\n        // Also, sort coordinates of the row by columns\
    \ in descending order.\n        var result : List[Tuple2[Long, Long]] = List()\n\
    \        for (i <- 0 to lst.length - 1) {\n            for (j <- 0 to lst(i).length\
    \ - 1) {\n                if (lst(i)(j) == x) {\n                    result =\
    \ result :+ (i.toLong, j.toLong)\n                }\n            }\n        }\n\
    \        result.sortWith((a, b) => {\n            if (a._1 == b._1) {\n      \
    \          a._2 > b._2\n            } else {\n                a._1 < b._1\n  \
    \          }\n        })\n    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804135
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => {\n\
    \            if (a._1 < b._1) {\n                true\n            } else if (a._1\
    \ == b._1) {\n                a._2 > b._2\n            } else {\n            \
    \    false\n            }\n        })\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804084
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((x, y) => x._1\
    \ < y._1 || (x._1 == y._1 && x._2 > y._2))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804097
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // Fill up this function body\n\
    \        // 'lst' is a nested list, which is similar to matrix, however, unlike\
    \ matrices,\n        // each row may contain a different number of columns.\n\
    \        // 'x' is an integer to be found in the list.\n        // You have to\
    \ return a list of tuples, [(x1, y1), (x2, y2) ...] such that\n        // each\
    \ tuple is a coordinate - (row, columns), starting with 0.\n        // Sort coordinates\
    \ initially by rows in ascending order.\n        // Also, sort coordinates of\
    \ the row by columns in descending order.\n        var result = List[Tuple2[Long,\
    \ Long]]()\n        for (i <- 0 until lst.length) {\n            for (j <- 0 until\
    \ lst(i).length) {\n                if (lst(i)(j) == x) {\n                  \
    \  result = result :+ (i.toLong, j.toLong)\n                }\n            }\n\
    \        }\n        result.sortWith((a, b) => {\n            if (a._1 < b._1)\
    \ {\n                true\n            } else if (a._1 == b._1) {\n          \
    \      a._2 > b._2\n            } else {\n                false\n            }\n\
    \        })\n    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804135
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => a._1\
    \ < b._1 || (a._1 == b._1 && a._2 > b._2))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804084
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            var row = lst(i)\n            for (j <- 0 until row.length) {\n \
    \               if (row(j) == x) {\n                    result = result :+ (i.toLong,\
    \ j.toLong)\n                }\n            }\n        }\n        result.sortWith((a,\
    \ b) => {\n            if (a._1 < b._1) {\n                true\n            }\
    \ else if (a._1 == b._1) {\n                a._2 > b._2\n            } else {\n\
    \                false\n            }\n        })\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804135
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // Fill up this function body\n\
    \        // 'lst' is a nested list, similar to matrix,\n        // 'x' is the\
    \ integer to be searched in the list\n        // Return list of tuples, [(x1,\
    \ y1), (x2, y2) ...] such that\n        // each tuple is a coordinate - (row,\
    \ columns), starting with 0.\n        // Sort coordinates initially by rows in\
    \ ascending order.\n        // Also, sort coordinates of the row by columns in\
    \ descending order.\n        var result = List[Tuple2[Long, Long]]()\n       \
    \ for (i <- 0 until lst.length) {\n            for (j <- 0 until lst(i).length)\
    \ {\n                if (lst(i)(j) == x) {\n                    result = result\
    \ :+ (i.toLong, j.toLong)\n                }\n            }\n        }\n     \
    \   result.sortWith((a, b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804136
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = (i, j) :: result\n                }\n\
    \            }\n        }\n        result.sortWith((a, b) => if (a._1 == b._1)\
    \ a._2 > b._2 else a._1 < b._1)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804136
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => {\n\
    \            if (a._1 != b._1) {\n                a._1 < b._1\n            } else\
    \ {\n                a._2 > b._2\n            }\n        })\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804136
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = (i, j) :: result\n                }\n\
    \            }\n        }\n        result.sortWith((a, b) => (a._1 < b._1) ||\
    \ (a._1 == b._1 && a._2 > b._2))\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804121
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            var row : List[Long] = lst(i)\n            for (j <- 0 until row.length)\
    \ {\n                if (row(j) == x) {\n                    result = result :+\
    \ (i.toLong, j.toLong)\n                }\n            }\n        }\n        result.sortWith((a,\
    \ b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804084
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ Tuple2(i.toLong, j.toLong)\n\
    \                }\n            }\n        }\n        result.sortWith((a, b) =>\
    \ a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804136
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // Fill up this function body\n\
    \        // 'lst' is a nested list, similar to matrix,\n        // 'x' is the\
    \ integer to be searched in the list\n        // Return a list of tuples, [(x1,\
    \ y1), (x2, y2) ...]\n        // such that each tuple is a coordinate - (row,\
    \ columns),\n        // starting with 0.\n        // Sort coordinates initially\
    \ by rows in ascending order.\n        // Also, sort coordinates of the row by\
    \ columns in descending order.\n        // If x is not found in the list, return\
    \ empty list.\n        // If list is empty, return empty list.\n        // If\
    \ list is None, return empty list.\n        // If list is not a nested list, return\
    \ empty list.\n        // If list is not a list of lists, return empty list.\n\
    \        // If list is not a list of lists of integers, return empty list.\n \
    \       // If list is not a list of lists of longs, return empty list.\n     \
    \   // If list is not a list of lists of longs, return empty list.\n        //\
    \ If list is not a list of lists of longs, return empty list.\n        // If list\
    \ is not a list of lists of longs, return empty list.\n        // If list is not\
    \ a list of lists of longs, return empty list.\n        // If list is not a list\
    \ of lists of longs, return empty list.\n        // If list is not a list of lists\
    \ of longs, return empty list.\n        // If list is not a list of lists of longs,\
    \ return empty list.\n        // If list is not a list of lists of longs, return\
    \ empty list.\n        // If list is not a list of lists of longs, return empty\
    \ list.\n        // If list is not a list of lists of longs, return empty list.\n\
    \        // If list is not a list of lists of longs, return empty list.\n    \
    \    // If list is not a list of lists of longs, return empty list.\n        //\
    \ If list is not a list of lists of longs, return empty list.\n        // If list\
    \ is not a list of lists of longs, return empty list.\n        // If list is not\
    \ a list of lists of longs, return empty list.\n        //\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp426t7dmf.scala:19:78\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m    \e[33mdef\e[0m \e[36mgetRow\e\
    [0m(\e[36mlst\e[0m : \e[35mList\e[0m[\e[35mList\e[0m[\e[35mLong\e[0m]], \e[36mx\e\
    [0m : \e[35mLong\e[0m) : \e[35mList\e[0m[\e[35mTuple2\e[0m[\e[35mLong\e[0m, \e\
    [35mLong\e[0m]] = {\n\e[31m\e[31m   |\e[0m                                   \
    \                                           ^\e[0m\n\e[31m   |\e[0m          \
    \                                  Found:    Unit\n\e[31m   |\e[0m           \
    \                                 Required: List[(Long, Long)]\n\e[31m20 |\e[0m\
    \        \e[34m// Fill up this function body\e[0m\n\e[31m21 |\e[0m        \e[34m//\
    \ 'lst' is a nested list, similar to matrix,\e[0m\n\e[31m22 |\e[0m        \e[34m//\
    \ 'x' is the integer to be searched in the list\e[0m\n\e[31m23 |\e[0m        \e\
    [34m// Return a list of tuples, [(x1, y1), (x2, y2) ...]\e[0m\n\e[31m24 |\e[0m\
    \        \e[34m// such that each tuple is a coordinate - (row, columns),\e[0m\n\
    \e[31m25 |\e[0m        \e[34m// starting with 0.\e[0m\n\e[31m26 |\e[0m       \
    \ \e[34m// Sort coordinates initially by rows in ascending order.\e[0m\n\e[31m27\
    \ |\e[0m        \e[34m// Also, sort coordinates of the row by columns in descending\
    \ order.\e[0m\n\e[31m28 |\e[0m        \e[34m// If x is not found in the list,\
    \ return empty list.\e[0m\n\e[31m29 |\e[0m        \e[34m// If list is empty, return\
    \ empty list.\e[0m\n\e[31m30 |\e[0m        \e[34m// If list is None, return empty\
    \ list.\e[0m\n\e[31m31 |\e[0m        \e[34m// If list is not a nested list, return\
    \ empty list.\e[0m\n\e[31m32 |\e[0m        \e[34m// If list is not a list of lists,\
    \ return empty list.\e[0m\n\e[31m33 |\e[0m        \e[34m// If list is not a list\
    \ of lists of integers, return empty list.\e[0m\n\e[31m34 |\e[0m        \e[34m//\
    \ If list is not a list of lists of longs, return empty list.\e[0m\n\e[31m35 |\e\
    [0m        \e[34m// If list is not a list of lists of longs, return empty list.\e\
    [0m\n\e[31m36 |\e[0m        \e[34m// If list is not a list of lists of longs,\
    \ return empty list.\e[0m\n\e[31m37 |\e[0m        \e[34m// If list is not a list\
    \ of lists of longs, return empty list.\e[0m\n\e[31m38 |"
  stdout: ''
  timestamp: 1659804137
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // Fill up this function body\n\
    \        // 'lst' is a nested list, similar to matrix, however, unlike matrices,\n\
    \        // each row may contain a different number of columns.\n        // 'x'\
    \ is an integer which you need to find in the list.\n        // Return list of\
    \ tuples, [(x1, y1), (x2, y2) ...] such that\n        // each tuple is a coordinate\
    \ - (row, columns), starting with 0.\n        // Sort coordinates initially by\
    \ rows in ascending order.\n        // Also, sort coordinates of the row by columns\
    \ in descending order.\n        var result = List[Tuple2[Long, Long]]()\n    \
    \    for (i <- 0 until lst.length) {\n            for (j <- 0 until lst(i).length)\
    \ {\n                if (lst(i)(j) == x) {\n                    result = (i, j)\
    \ :: result\n                }\n            }\n        }\n        result.sortWith((a,\
    \ b) => {\n            if (a._1 == b._1) {\n                a._2 > b._2\n    \
    \        } else {\n                a._1 < b._1\n            }\n        })\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804138
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => (a._1\
    \ < b._1) || (a._1 == b._1 && a._2 > b._2))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804084
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => a._1\
    \ < b._1 || (a._1 == b._1 && a._2 > b._2))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804084
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // Fill up this function body\n\
    \        // `lst` is a 2 dimensional list, similar to matrix,\n        // but\
    \ each row may contain a different number of columns.\n        // `x` is an integer\
    \ to be found in the list.\n        // Return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n        // each tuple is a coordinate - (row, columns),\
    \ starting with 0.\n        // Sort coordinates initially by rows in ascending\
    \ order.\n        // Also, sort coordinates of the row by columns in descending\
    \ order.\n        // If `x` is not found, return empty list.\n        // If `lst`\
    \ is empty, return empty list.\n        // If `lst` is None, return empty list.\n\
    \        var result : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n\
    \        if (lst == null) {\n            return result\n        }\n        for\
    \ (i <- 0 until lst.length) {\n            for (j <- 0 until lst(i).length) {\n\
    \                if (lst(i)(j) == x) {\n                    result = result :+\
    \ (i.toLong, j.toLong)\n                }\n            }\n        }\n        result\
    \ = result.sortWith((a, b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))\n\
    \        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804138
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // Fill up this function body\n\
    \        // 'lst' is a nested list of integers\n        // 'x' is an integer\n\
    \        // Return a list of tuples, each tuple is a coordinate - (row, columns),\n\
    \        // starting with 0.\n        // Sort coordinates initially by rows in\
    \ ascending order.\n        // Also, sort coordinates of the row by columns in\
    \ descending order.\n        var result : List[Tuple2[Long, Long]] = List[Tuple2[Long,\
    \ Long]]()\n        for (i <- 0 to lst.length - 1) {\n            for (j <- 0\
    \ to lst(i).length - 1) {\n                if (lst(i)(j) == x) {\n           \
    \         result = result :+ (i.toLong, j.toLong)\n                }\n       \
    \     }\n        }\n        result.sortWith((a, b) => {\n            if (a._1\
    \ == b._1) {\n                a._2 > b._2\n            } else {\n            \
    \    a._1 < b._1\n            }\n        })\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804139
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => (a._1\
    \ < b._1) || (a._1 == b._1 && a._2 > b._2))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804084
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        val row = lst.zipWithIndex.map(x\
    \ => x._1.zipWithIndex.map(y => (x._2, y._2))).flatten.filter(x => x._2 == x._2).filter(x\
    \ => x._1 == x._1).filter(x => x._2 == x._2).filter(x => x._1 == x._1).filter(x\
    \ => x._2 == x._2).filter(x => x._1 == x._1).filter(x => x._2 == x._2).filter(x\
    \ => x._1 == x._1).filter(x => x._2 == x._2).filter(x => x._1 == x._1).filter(x\
    \ => x._2 == x._2).filter(x => x._1 == x._1).filter(x => x._2 == x._2).filter(x\
    \ => x._1 == x._1).filter(x => x._2 == x._2).filter(x => x._1 == x._1).filter(x\
    \ => x._2 == x._2).filter(x => x._1 == x._1).filter(x => x._2 == x._2).filter(x\
    \ => x._1 == x._1).filter(x => x._2 == x._2).filter(x => x._1 == x._1).filter(x\
    \ => x._2 == x._2).filter(x => x._1 == x._1).filter(x => x._2 == x._2).filter(x\
    \ => x._1 == x._1).filter(x => x._2 == x._2).filter(x => x._1 == x._1).filter(x\
    \ => x._2 == x._2).filter(x => x._1 == x._1).filter(x => x._2 == x._2).filter(x\
    \ => x._1 == x._1).filter(x => x._2 == x._2).filter(x => x._1 == x._1).filter(x\
    \ => x._2 == x._2).filter(x => x._1 == x._1).filter(x => x._2 == x._2).filter(x\
    \ => x._1 == x._1).filter(x => x._2 == x._2).filter(x\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmplmynxeth.scala:21:4 ----------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmplmynxeth.scala:20:1115 ------------------\e[0m\e[0m\n\e[31m20 |\e[0m\
    \        \e[33mval\e[0m \e[36mrow\e[0m = lst.zipWithIndex.map(\e[36mx\e[0m =>\
    \ x._1.zipWithIndex.map(\e[36my\e[0m => (x._2, y._2))).flatten.filter(\e[36mx\e\
    [0m => x._2 == x._2).filter(\e[36mx\e[0m => x._1 == x._1).filter(\e[36mx\e[0m\
    \ => x._2 == x._2).filter(\e[36mx\e[0m => x._1 == x._1).filter(\e[36mx\e[0m =>\
    \ x._2 == x._2).filter(\e[36mx\e[0m => x._1 == x._1).filter(\e[36mx\e[0m => x._2\
    \ == x._2).filter(\e[36mx\e[0m => x._1 == x._1).filter(\e[36mx\e[0m => x._2 ==\
    \ x._2).filter(\e[36mx\e[0m => x._1 == x._1).filter(\e[36mx\e[0m => x._2 == x._2).filter(\e\
    [36mx\e[0m => x._1 == x._1).filter(\e[36mx\e[0m => x._2 == x._2).filter(\e[36mx\e\
    [0m => x._1 == x._1).filter(\e[36mx\e[0m => x._2 == x._2).filter(\e[36mx\e[0m\
    \ => x._1 == x._1).filter(\e[36mx\e[0m => x._2 == x._2).filter(\e[36mx\e[0m =>\
    \ x._1 == x._1).filter(\e[36mx\e[0m => x._2 == x._2).filter(\e[36mx\e[0m => x._1\
    \ == x._1).filter(\e[36mx\e[0m => x._2 == x._2).filter(\e[36mx\e[0m => x._1 ==\
    \ x._1).filter(\e[36mx\e[0m => x._2 == x._2).filter(\e[36mx\e[0m => x._1 == x._1).filter(\e\
    [36mx\e[0m => x._2 == x._2).filter(\e[36mx\e[0m => x._1 == x._1).filter(\e[36mx\e\
    [0m => x._2 == x._2).filter(\e[36mx\e[0m => x._1 == x._1).filter(\e[36mx\e[0m\
    \ => x._2 == x._2).filter(\e[36mx\e[0m => x._1 == x._1).filter(\e[36mx\e[0m =>\
    \ x._2 == x._2).filter(\e[36mx\e[0m => x._1 == x._1).filter(\e[36mx\e[0m => x._2\
    \ == x._2).filter(\e[36mx\e[0m => x._1 == x._1).filter(\e[36mx\e[0m => x._2 ==\
    \ x._2).filter(\e[36mx\e[0m => x._1 == x._1).filter(\e[36mx\e[0m => x._2 == x._2).filter(\e\
    [36mx\e[0m => x._1 == x._1).filter(\e[36mx\e[0m => x._2 == x._2).filter(x\n\e\
    [31m\e[31m   |\e[0m                                                          \
    \                                                                            \
    \                                                                            \
    \             "
  stdout: ''
  timestamp: 1659804138
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // Fill up this function body\n\
    \        // 'lst' is a nested list, similar to matrix,\n        // 'x' is the\
    \ integer to be searched in the list\n        // Return the list of tuples, [(x1,\
    \ y1), (x2, y2) ...] such that\n        // each tuple is a coordinate - (row,\
    \ columns), starting with 0.\n        // Sort coordinates initially by rows in\
    \ ascending order.\n        // Also, sort coordinates of the row by columns in\
    \ descending order.\n        // If x is not found in the list, return empty list.\n\
    \        // If lst is empty, return empty list.\n        // If lst is not a nested\
    \ list, return empty list.\n        // If lst is a nested list, but not a list\
    \ of lists, return empty list.\n        // If lst is a list of lists, but any\
    \ of the lists is not a list,\n        // return empty list.\n        // If lst\
    \ is a list of lists, but any of the lists is not a list of\n        // integers,\
    \ return empty list.\n        // If lst is a list of lists, but any of the lists\
    \ is a list of\n        // integers, but any of the integers is not a Long, return\
    \ empty list.\n        // If lst is a list of lists, but any of the lists is a\
    \ list of\n        // integers, but any of the integers is not a Long, return\
    \ empty list.\n        // If lst is a list of lists, but any of the lists is a\
    \ list of\n        // integers, but any of the integers is not a Long, return\
    \ empty list.\n        // If lst is a list of lists, but any of the lists is a\
    \ list of\n        // integers, but any of the integers is not a Long, return\
    \ empty list.\n        // If lst is a list of lists, but any of the lists is a\
    \ list of\n        // integers, but any of the integers is not a Long, return\
    \ empty list.\n        // If lst is a list of lists, but any of the lists is a\
    \ list of\n        // integers, but any of the integers is not a Long, return\
    \ empty list.\n        // If lst is a list of lists, but any of the lists is a\
    \ list of\n        // integers, but any of the integers is\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp55ja52ax.scala:19:78\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m    \e[33mdef\e[0m \e[36mgetRow\e\
    [0m(\e[36mlst\e[0m : \e[35mList\e[0m[\e[35mList\e[0m[\e[35mLong\e[0m]], \e[36mx\e\
    [0m : \e[35mLong\e[0m) : \e[35mList\e[0m[\e[35mTuple2\e[0m[\e[35mLong\e[0m, \e\
    [35mLong\e[0m]] = {\n\e[31m\e[31m   |\e[0m                                   \
    \                                           ^\e[0m\n\e[31m   |\e[0m          \
    \                                  Found:    Unit\n\e[31m   |\e[0m           \
    \                                 Required: List[(Long, Long)]\n\e[31m20 |\e[0m\
    \        \e[34m// Fill up this function body\e[0m\n\e[31m21 |\e[0m        \e[34m//\
    \ 'lst' is a nested list, similar to matrix,\e[0m\n\e[31m22 |\e[0m        \e[34m//\
    \ 'x' is the integer to be searched in the list\e[0m\n\e[31m23 |\e[0m        \e\
    [34m// Return the list of tuples, [(x1, y1), (x2, y2) ...] such that\e[0m\n\e\
    [31m24 |\e[0m        \e[34m// each tuple is a coordinate - (row, columns), starting\
    \ with 0.\e[0m\n\e[31m25 |\e[0m        \e[34m// Sort coordinates initially by\
    \ rows in ascending order.\e[0m\n\e[31m26 |\e[0m        \e[34m// Also, sort coordinates\
    \ of the row by columns in descending order.\e[0m\n\e[31m27 |\e[0m        \e[34m//\
    \ If x is not found in the list, return empty list.\e[0m\n\e[31m28 |\e[0m    \
    \    \e[34m// If lst is empty, return empty list.\e[0m\n\e[31m29 |\e[0m      \
    \  \e[34m// If lst is not a nested list, return empty list.\e[0m\n\e[31m30 |\e\
    [0m        \e[34m// If lst is a nested list, but not a list of lists, return empty\
    \ list.\e[0m\n\e[31m31 |\e[0m        \e[34m// If lst is a list of lists, but any\
    \ of the lists is not a list,\e[0m\n\e[31m32 |\e[0m        \e[34m// return empty\
    \ list.\e[0m\n\e[31m33 |\e[0m        \e[34m// If lst is a list of lists, but any\
    \ of the lists is not a list of\e[0m\n\e[31m34 |\e[0m        \e[34m// integers,\
    \ return empty list.\e[0m\n\e[31m35 |\e[0m        \e[34m// If lst is a list of\
    \ lists, but any of the lists is a list of\e[0m\n\e[31m36 |\e[0m        \e[34m//\
    \ integers, but any of the integers is not a Long, return empty list.\e[0m\n\e\
    [31m37 |\e[0m        \e[34m// If lst is a list of lists, bu"
  stdout: ''
  timestamp: 1659804138
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => {\n\
    \            if (a._1 < b._1) {\n                true\n            } else if (a._1\
    \ == b._1) {\n                a._2 > b._2\n            } else {\n            \
    \    false\n            }\n        })\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659804084
