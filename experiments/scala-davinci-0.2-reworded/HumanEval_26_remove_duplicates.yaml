name: HumanEval_26_remove_duplicates
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // From a list of integers, remove all elements that occur more than once.\n\
  \    // Keep order of elements left the same as in the input.\n    // >>> removeDuplicates((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 2l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 3l.toLong,\
  \ 4l.toLong))\n    def removeDuplicates(numbers : List[Long]) : List[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(removeDuplicates((List[Long]())).equals((List[Long]())));\n\
  \    assert(removeDuplicates((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(removeDuplicates((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))).equals((List[Long](1l.toLong,\
  \ 4l.toLong, 5l.toLong))));\n    }\n\n}\n"
completions: ["        val map = new HashMap[Long, Int]()\n        for (number <-\
    \ numbers) {\n            if (map.contains(number)) map(number) += 1\n       \
    \     else map(number) = 1\n        }\n        val result = new ListBuffer[Long]()\n\
    \        for (number <- numbers) {\n            if (map(number) == 1) result +=\
    \ number\n        }\n        result.toList", "        val set = new HashSet[Long]\n\
    \        val result = new ListBuffer[Long]\n        for (number <- numbers) {\n\
    \            if (!set.contains(number)) {\n                set += number\n   \
    \             result += number\n            }\n        }\n        result.toList",
  "        var result = List[Long]()\n        var set = Set[Long]()\n        for (number\
    \ <- numbers) {\n            if (!set.contains(number)) {\n                result\
    \ = result :+ number\n                set = set + number\n            }\n    \
    \    }\n        result", "        val map = new HashMap[Long, Int]\n        for\
    \ (number <- numbers) {\n            if (map.contains(number)) map(number) +=\
    \ 1\n            else map(number) = 1\n        }\n        val result = new ListBuffer[Long]\n\
    \        for (number <- numbers) {\n            if (map(number) == 1) result +=\
    \ number\n        }\n        result.toList", "        val map = new HashMap[Long,\
    \ Int]\n        for (number <- numbers) {\n            if (map.contains(number))\
    \ map(number) += 1\n            else map(number) = 1\n        }\n        val result\
    \ = new ListBuffer[Long]\n        for (number <- numbers) {\n            if (map(number)\
    \ == 1) result += number\n        }\n        result.toList", '        numbers.distinct',
  "        var result = List[Long]()\n        for (number <- numbers) {\n        \
    \    if (!result.contains(number)) {\n                result = result :+ number\n\
    \            }\n        }\n        result", "        var result = List[Long]()\n\
    \        var map = Map[Long, Int]()\n        for (number <- numbers) {\n     \
    \       if (map.contains(number)) {\n                map(number) += 1\n      \
    \      } else {\n                map(number) = 1\n            }\n        }\n \
    \       for (number <- numbers) {\n            if (map(number) == 1) {\n     \
    \           result = result :+ number\n            }\n        }\n        result",
  "        var result = List[Long]()\n        var set = Set[Long]()\n        for (number\
    \ <- numbers) {\n            if (!set.contains(number)) {\n                result\
    \ = result :+ number\n                set = set + number\n            }\n    \
    \    }\n        result", "        val set = new HashSet[Long]\n        val result\
    \ = new ListBuffer[Long]\n        for (number <- numbers) {\n            if (!set.contains(number))\
    \ {\n                set += number\n                result += number\n       \
    \     }\n        }\n        result.toList", "        var result = List[Long]()\n\
    \        var set = Set[Long]()\n        for (number <- numbers) {\n          \
    \  if (!set.contains(number)) {\n                result = result :+ number\n \
    \               set = set + number\n            }\n        }\n        result",
  "        val map = new HashMap[Long, Int]()\n        for (number <- numbers) {\n\
    \            if (map.contains(number)) map(number) += 1\n            else map(number)\
    \ = 1\n        }\n        val result = new ListBuffer[Long]()\n        for (number\
    \ <- numbers) {\n            if (map(number) == 1) result += number\n        }\n\
    \        result.toList", '        numbers.foldLeft(List[Long]())((acc, x) => if
    (acc.contains(x)) acc else acc :+ x)', "        // TODO: implement this method\n\
    \        null", "        val set = new HashSet[Long]\n        val result = new\
    \ ListBuffer[Long]\n        for (n <- numbers) {\n            if (!set.contains(n))\
    \ {\n                set += n\n                result += n\n            }\n  \
    \      }\n        result.toList", "        var result = new ListBuffer[Long]()\n\
    \        var set = new HashSet[Long]()\n        for (number <- numbers) {\n  \
    \          if (!set.contains(number)) {\n                result += number\n  \
    \              set += number\n            }\n        }\n        result.toList",
  '        numbers.filter(n => numbers.count(_ == n) == 1)', "        val set = new\
    \ HashSet[Long]\n        val result = new ListBuffer[Long]\n        for (number\
    \ <- numbers) {\n            if (!set.contains(number)) {\n                set\
    \ += number\n                result += number\n            }\n        }\n    \
    \    result.toList", "        val set = new HashSet[Long]()\n        val result\
    \ = new ListBuffer[Long]()\n        for (number <- numbers) {\n            if\
    \ (!set.contains(number)) {\n                set += number\n                result\
    \ += number\n            }\n        }\n        result.toList", "        val set\
    \ = new HashSet[Long]\n        val result = new ListBuffer[Long]\n        for\
    \ (n <- numbers) {\n            if (!set.contains(n)) {\n                set +=\
    \ n\n                result += n\n            }\n        }\n        result.toList"]
stop_tokens:
- "\n    }\n"
