name: HumanEval_26_remove_duplicates
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // From a list of integers, remove all elements that occur more than once.\n\
  \    // Keep order of elements left the same as in the input.\n    // >>> removeDuplicates((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 2l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 3l.toLong,\
  \ 4l.toLong))\n    def removeDuplicates(numbers : List[Long]) : List[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(removeDuplicates((List[Long]())).equals((List[Long]())));\n\
  \    assert(removeDuplicates((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(removeDuplicates((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))).equals((List[Long](1l.toLong,\
  \ 4l.toLong, 5l.toLong))));\n    }\n\n}\n"
completions: ["        val map = new HashMap[Long, Int]()\n        for (number <-\
    \ numbers) {\n            if (map.contains(number)) map(number) += 1\n       \
    \     else map(number) = 1\n        }\n        val result = new ListBuffer[Long]()\n\
    \        for (number <- numbers) {\n            if (map(number) == 1) result +=\
    \ number\n        }\n        result.toList", "        val set = new HashSet[Long]\n\
    \        val result = new ListBuffer[Long]\n        for (number <- numbers) {\n\
    \            if (!set.contains(number)) {\n                set += number\n   \
    \             result += number\n            }\n        }\n        result.toList",
  "        var result = List[Long]()\n        var set = Set[Long]()\n        for (number\
    \ <- numbers) {\n            if (!set.contains(number)) {\n                result\
    \ = result :+ number\n                set = set + number\n            }\n    \
    \    }\n        result", "        val map = new HashMap[Long, Int]\n        for\
    \ (number <- numbers) {\n            if (map.contains(number)) map(number) +=\
    \ 1\n            else map(number) = 1\n        }\n        val result = new ListBuffer[Long]\n\
    \        for (number <- numbers) {\n            if (map(number) == 1) result +=\
    \ number\n        }\n        result.toList", "        val map = new HashMap[Long,\
    \ Int]\n        for (number <- numbers) {\n            if (map.contains(number))\
    \ map(number) += 1\n            else map(number) = 1\n        }\n        val result\
    \ = new ListBuffer[Long]\n        for (number <- numbers) {\n            if (map(number)\
    \ == 1) result += number\n        }\n        result.toList", '        numbers.distinct',
  "        var result = List[Long]()\n        for (number <- numbers) {\n        \
    \    if (!result.contains(number)) {\n                result = result :+ number\n\
    \            }\n        }\n        result", "        var result = List[Long]()\n\
    \        var map = Map[Long, Int]()\n        for (number <- numbers) {\n     \
    \       if (map.contains(number)) {\n                map(number) += 1\n      \
    \      } else {\n                map(number) = 1\n            }\n        }\n \
    \       for (number <- numbers) {\n            if (map(number) == 1) {\n     \
    \           result = result :+ number\n            }\n        }\n        result",
  "        var result = List[Long]()\n        var set = Set[Long]()\n        for (number\
    \ <- numbers) {\n            if (!set.contains(number)) {\n                result\
    \ = result :+ number\n                set = set + number\n            }\n    \
    \    }\n        result", "        val set = new HashSet[Long]\n        val result\
    \ = new ListBuffer[Long]\n        for (number <- numbers) {\n            if (!set.contains(number))\
    \ {\n                set += number\n                result += number\n       \
    \     }\n        }\n        result.toList", "        var result = List[Long]()\n\
    \        var set = Set[Long]()\n        for (number <- numbers) {\n          \
    \  if (!set.contains(number)) {\n                result = result :+ number\n \
    \               set = set + number\n            }\n        }\n        result",
  "        val map = new HashMap[Long, Int]()\n        for (number <- numbers) {\n\
    \            if (map.contains(number)) map(number) += 1\n            else map(number)\
    \ = 1\n        }\n        val result = new ListBuffer[Long]()\n        for (number\
    \ <- numbers) {\n            if (map(number) == 1) result += number\n        }\n\
    \        result.toList", '        numbers.foldLeft(List[Long]())((acc, x) => if
    (acc.contains(x)) acc else acc :+ x)', "        // TODO: implement this method\n\
    \        null", "        val set = new HashSet[Long]\n        val result = new\
    \ ListBuffer[Long]\n        for (n <- numbers) {\n            if (!set.contains(n))\
    \ {\n                set += n\n                result += n\n            }\n  \
    \      }\n        result.toList", "        var result = new ListBuffer[Long]()\n\
    \        var set = new HashSet[Long]()\n        for (number <- numbers) {\n  \
    \          if (!set.contains(number)) {\n                result += number\n  \
    \              set += number\n            }\n        }\n        result.toList",
  '        numbers.filter(n => numbers.count(_ == n) == 1)', "        val set = new\
    \ HashSet[Long]\n        val result = new ListBuffer[Long]\n        for (number\
    \ <- numbers) {\n            if (!set.contains(number)) {\n                set\
    \ += number\n                result += number\n            }\n        }\n    \
    \    result.toList", "        val set = new HashSet[Long]()\n        val result\
    \ = new ListBuffer[Long]()\n        for (number <- numbers) {\n            if\
    \ (!set.contains(number)) {\n                set += number\n                result\
    \ += number\n            }\n        }\n        result.toList", "        val set\
    \ = new HashSet[Long]\n        val result = new ListBuffer[Long]\n        for\
    \ (n <- numbers) {\n            if (!set.contains(n)) {\n                set +=\
    \ n\n                result += n\n            }\n        }\n        result.toList",
  "        var result = List[Long]()\n        var set = Set[Long]()\n        for (number\
    \ <- numbers) {\n            if (!set.contains(number)) {\n                result\
    \ = result :+ number\n                set += number\n            }\n        }\n\
    \        result", "        val set = new HashSet[Long]\n        val result = new\
    \ ListBuffer[Long]\n        for (number <- numbers) {\n            if (!set.contains(number))\
    \ {\n                set += number\n                result += number\n       \
    \     }\n        }\n        result.toList", "        var result = List[Long]()\n\
    \        var set = Set[Long]()\n        for (number <- numbers) {\n          \
    \  if (!set.contains(number)) {\n                result = result :+ number\n \
    \               set += number\n            }\n        }\n        result", "  \
    \      var result = List[Long]()\n        var set = Set[Long]()\n        for (number\
    \ <- numbers) {\n            if (!set.contains(number)) {\n                result\
    \ = result :+ number\n                set = set + number\n            }\n    \
    \    }\n        result", "        val map = new HashMap[Long, Int]\n        for\
    \ (number <- numbers) {\n            if (map.contains(number)) {\n           \
    \     map(number) += 1\n            } else {\n                map(number) = 1\n\
    \            }\n        }\n        val result = new ListBuffer[Long]\n       \
    \ for (number <- numbers) {\n            if (map(number) == 1) {\n           \
    \     result += number\n            }\n        }\n        result.toList", "  \
    \      val set = new HashSet[Long]\n        val result = new ListBuffer[Long]\n\
    \        for (n <- numbers) {\n            if (!set.contains(n)) {\n         \
    \       set += n\n                result += n\n            }\n        }\n    \
    \    result.toList", "        var result = List[Long]()\n        var map = Map[Long,\
    \ Int]()\n        for (i <- numbers) {\n            if (map.contains(i)) {\n \
    \               map(i) += 1\n            } else {\n                map(i) = 1\n\
    \            }\n        }\n        for (i <- numbers) {\n            if (map(i)\
    \ == 1) {\n                result = result :+ i\n            }\n        }\n  \
    \      result", "        val map = new HashMap[Long, Int]\n        for (number\
    \ <- numbers) {\n            if (map.contains(number)) {\n                map(number)\
    \ += 1\n            } else {\n                map(number) = 1\n            }\n\
    \        }\n        val result = new ListBuffer[Long]\n        for (number <-\
    \ numbers) {\n            if (map(number) == 1) {\n                result += number\n\
    \            }\n        }\n        result.toList", "        var result = List[Long]()\n\
    \        var set = Set[Long]()\n        for (number <- numbers) {\n          \
    \  if (!set.contains(number)) {\n                result = result :+ number\n \
    \               set = set + number\n            }\n        }\n        result",
  "        val map = new HashMap[Long, Int]\n        for (number <- numbers) {\n \
    \           if (map.contains(number)) map(number) += 1\n            else map(number)\
    \ = 1\n        }\n        numbers.filter(number => map(number) == 1)", "     \
    \   var result : List[Long] = List[Long]()\n        for (number <- numbers) {\n\
    \            if (!result.contains(number)) {\n                result = result\
    \ :+ number\n            }\n        }\n        return result", "        var result\
    \ = List[Long]()\n        var set = Set[Long]()\n        for (number <- numbers)\
    \ {\n            if (!set.contains(number)) {\n                result = result\
    \ :+ number\n                set = set + number\n            }\n        }\n  \
    \      result", "        val set = new HashSet[Long]\n        val result = new\
    \ ListBuffer[Long]\n        for (number <- numbers) {\n            if (!set.contains(number))\
    \ {\n                set += number\n                result += number\n       \
    \     }\n        }\n        result.toList", "        val map = new HashMap[Long,\
    \ Int]\n        for (number <- numbers) {\n            if (map.contains(number))\
    \ map(number) += 1\n            else map(number) = 1\n        }\n        val result\
    \ = new ListBuffer[Long]\n        for (number <- numbers) {\n            if (map(number)\
    \ == 1) result += number\n        }\n        result.toList", "        val map\
    \ = new HashMap[Long, Int]\n        for (n <- numbers) {\n            if (map.contains(n))\
    \ map(n) += 1\n            else map(n) = 1\n        }\n        numbers.filter(n\
    \ => map(n) == 1)", "        var result = List[Long]()\n        var map = Map[Long,\
    \ Int]()\n        for (number <- numbers) {\n            if (map.contains(number))\
    \ {\n                map(number) += 1\n            } else {\n                map(number)\
    \ = 1\n            }\n        }\n        for (number <- numbers) {\n         \
    \   if (map(number) == 1) {\n                result = result :+ number\n     \
    \       }\n        }\n        result", "        var result = List[Long]()\n  \
    \      var set = Set[Long]()\n        for (number <- numbers) {\n            if\
    \ (!set.contains(number)) {\n                result = result :+ number\n     \
    \           set = set + number\n            }\n        }\n        result", '        numbers.foldLeft(List[Long]())((acc,
    x) => if (acc.contains(x)) acc else acc :+ x)', "        val set = new HashSet[Long]\n\
    \        val result = new ListBuffer[Long]\n        for (number <- numbers) {\n\
    \            if (!set.contains(number)) {\n                set += number\n   \
    \             result += number\n            }\n        }\n        result.toList",
  "        val set = new HashSet[Long]\n        val result = new ListBuffer[Long]\n\
    \        for (n <- numbers) {\n            if (!set.contains(n)) {\n         \
    \       set += n\n                result += n\n            }\n        }\n    \
    \    result.toList", "        val map = new HashMap[Long, Int]\n        for (number\
    \ <- numbers) {\n            if (map.contains(number)) map(number) += 1\n    \
    \        else map(number) = 1\n        }\n        val result = new ListBuffer[Long]\n\
    \        for (number <- numbers) {\n            if (map(number) == 1) result +=\
    \ number\n        }\n        result.toList", '        numbers.distinct', '        numbers.distinct',
  "        val map = new HashMap[Long, Int]\n        for (n <- numbers) {\n      \
    \      if (map.contains(n)) map(n) += 1\n            else map(n) = 1\n       \
    \ }\n        numbers.filter(n => map(n) == 1)", "        val set = new HashSet[Long]\n\
    \        val result = new ListBuffer[Long]\n        for (number <- numbers) {\n\
    \            if (!set.contains(number)) {\n                set += number\n   \
    \             result += number\n            }\n        }\n        result.toList",
  "        numbers.foldLeft(List[Long]())((result, number) => {\n            if (result.contains(number))\
    \ result else number :: result\n        }).reverse", '        numbers.foldLeft(List[Long]())((acc,
    x) => if (acc.contains(x)) acc else acc :+ x)', "        val map = new HashMap[Long,\
    \ Int]\n        for (number <- numbers) {\n            if (map.contains(number))\
    \ map(number) += 1\n            else map(number) = 1\n        }\n        val result\
    \ = new ListBuffer[Long]\n        for (number <- numbers) {\n            if (map(number)\
    \ == 1) result += number\n        }\n        result.toList", "        var result\
    \ = List[Long]()\n        var set = Set[Long]()\n        for (number <- numbers)\
    \ {\n            if (!set.contains(number)) {\n                result = result\
    \ :+ number\n                set = set + number\n            }\n        }\n  \
    \      result", "        val map = new HashMap[Long, Int]\n        for (number\
    \ <- numbers) {\n            if (map.contains(number)) map(number) += 1\n    \
    \        else map += (number -> 1)\n        }\n        val result = new ListBuffer[Long]\n\
    \        for (number <- numbers) {\n            if (map(number) == 1) result +=\
    \ number\n        }\n        result.toList", "        val map = new HashMap[Long,\
    \ Int]\n        for (number <- numbers) {\n            if (map.contains(number))\
    \ {\n                map(number) += 1\n            } else {\n                map(number)\
    \ = 1\n            }\n        }\n        val result = new ListBuffer[Long]\n \
    \       for (number <- numbers) {\n            if (map(number) == 1) {\n     \
    \           result += number\n            }\n        }\n        result.toList",
  "        var set = Set[Long]()\n        var result = List[Long]()\n        for (number\
    \ <- numbers) {\n            if (!set.contains(number)) {\n                set\
    \ += number\n                result = number :: result\n            }\n      \
    \  }\n        result.reverse", "        var result = List[Long]()\n        var\
    \ set = Set[Long]()\n        for (number <- numbers) {\n            if (!set.contains(number))\
    \ {\n                result = result :+ number\n                set = set + number\n\
    \            }\n        }\n        result", '        numbers.distinct', "    \
    \    var result = List[Long]()\n        var hash = HashMap[Long, Boolean]()\n\
    \        for (number <- numbers) {\n            if (!hash.contains(number)) {\n\
    \                hash += (number -> true)\n                result = result :+\
    \ number\n            }\n        }\n        result", "        val map = new HashMap[Long,\
    \ Int]\n        for (number <- numbers) {\n            if (map.contains(number))\
    \ map(number) += 1\n            else map(number) = 1\n        }\n        val result\
    \ = new ListBuffer[Long]\n        for (number <- numbers) {\n            if (map(number)\
    \ == 1) result += number\n        }\n        result.toList", "        val map\
    \ = new HashMap[Long, Int]\n        for (number <- numbers) {\n            if\
    \ (map.contains(number)) map(number) += 1\n            else map(number) = 1\n\
    \        }\n        val result = new ListBuffer[Long]\n        for (number <-\
    \ numbers) {\n            if (map(number) == 1) result += number\n        }\n\
    \        result.toList", "        val map = new HashMap[Long, Int]()\n       \
    \ for (number <- numbers) {\n            if (map.contains(number)) map(number)\
    \ += 1\n            else map(number) = 1\n        }\n        val result = new\
    \ ListBuffer[Long]()\n        for (number <- numbers) {\n            if (map(number)\
    \ == 1) result += number\n        }\n        result.toList", "        val set\
    \ = new HashSet[Long]\n        val result = new ListBuffer[Long]\n        for\
    \ (number <- numbers) {\n            if (!set.contains(number)) {\n          \
    \      set += number\n                result += number\n            }\n      \
    \  }\n        result.toList", "        val map = new HashMap[Long, Int]\n    \
    \    for (number <- numbers) {\n            if (map.contains(number)) map(number)\
    \ += 1\n            else map(number) = 1\n        }\n        numbers.filter(number\
    \ => map(number) == 1)", '        numbers.foldLeft(List[Long]())((acc, x) => if
    (acc.contains(x)) acc else acc :+ x)', "        val set = new HashSet[Long]\n\
    \        val result = new ListBuffer[Long]\n        for (number <- numbers) {\n\
    \            if (!set.contains(number)) {\n                set += number\n   \
    \             result += number\n            }\n        }\n        result.toList",
  "        val numbersSet = numbers.toSet\n        val numbersMap = numbers.groupBy(identity).mapValues(_.size)\n\
    \        numbersSet.filter(numbersMap(_) == 1).toList", "        val set = new\
    \ HashSet[Long]\n        val result = new ListBuffer[Long]\n        for (number\
    \ <- numbers) {\n            if (!set.contains(number)) {\n                set\
    \ += number\n                result += number\n            }\n        }\n    \
    \    result.toList", "        val map = new HashMap[Long, Int]\n        for (number\
    \ <- numbers) {\n            if (map.contains(number)) map(number) += 1\n    \
    \        else map(number) = 1\n        }\n        numbers.filter(number => map(number)\
    \ == 1)", "        var result = List[Long]()\n        var set = Set[Long]()\n\
    \        for (number <- numbers) {\n            if (!set.contains(number)) {\n\
    \                result = result :+ number\n                set = set + number\n\
    \            }\n        }\n        result", "        var result = List[Long]()\n\
    \        var set = Set[Long]()\n        for (i <- numbers) {\n            if (!set.contains(i))\
    \ {\n                result = result :+ i\n                set = set + i\n   \
    \         }\n        }\n        result", "        val map = new HashMap[Long,\
    \ Int]()\n        for (number <- numbers) {\n            if (map.contains(number))\
    \ {\n                map(number) += 1\n            } else {\n                map(number)\
    \ = 1\n            }\n        }\n        numbers.filter(number => map(number)\
    \ == 1)", "        val map = new HashMap[Long, Int]\n        for (number <- numbers)\
    \ {\n            if (map.contains(number)) map(number) += 1\n            else\
    \ map(number) = 1\n        }\n        val result = new ListBuffer[Long]\n    \
    \    for (number <- numbers) {\n            if (map(number) == 1) result += number\n\
    \        }\n        result.toList", '        numbers.foldLeft(List[Long]())((acc,
    x) => if (acc.contains(x)) acc else acc :+ x)', "        val set = new HashSet[Long]\n\
    \        val result = new ListBuffer[Long]\n        for (number <- numbers) {\n\
    \            if (!set.contains(number)) {\n                set += number\n   \
    \             result += number\n            }\n        }\n        result.toList",
  '        numbers.foldLeft(List[Long]())((acc, x) => if (acc.contains(x)) acc else
    acc :+ x)', "        var result = List[Long]()\n        var set = Set[Long]()\n\
    \        for (number <- numbers) {\n            if (!set.contains(number)) {\n\
    \                result = result :+ number\n                set = set + number\n\
    \            }\n        }\n        result", "        var result = List[Long]()\n\
    \        var set = Set[Long]()\n        for (number <- numbers) {\n          \
    \  if (!set.contains(number)) {\n                result = result :+ number\n \
    \               set = set + number\n            }\n        }\n        result",
  "        var result = List[Long]()\n        var seen = Set[Long]()\n        for\
    \ (number <- numbers) {\n            if (!seen.contains(number)) {\n         \
    \       result = result :+ number\n                seen = seen + number\n    \
    \        }\n        }\n        result", "        var result = List[Long]()\n \
    \       var set = Set[Long]()\n        for (number <- numbers) {\n           \
    \ if (!set.contains(number)) {\n                result = result :+ number\n  \
    \              set = set + number\n            }\n        }\n        result",
  '        numbers.foldLeft(List[Long]())((acc, x) => if (acc.contains(x)) acc else
    acc :+ x)', "        var result = List[Long]()\n        var set = Set[Long]()\n\
    \        for (number <- numbers) {\n            if (!set.contains(number)) {\n\
    \                result = result :+ number\n                set = set + number\n\
    \            }\n        }\n        result", "        var result = List[Long]()\n\
    \        var seen = Set[Long]()\n        for (number <- numbers) {\n         \
    \   if (!seen.contains(number)) {\n                result = result :+ number\n\
    \                seen += number\n            }\n        }\n        result", " \
    \       var result = List[Long]()\n        var map = Map[Long, Int]()\n      \
    \  for (number <- numbers) {\n            if (map.contains(number)) {\n      \
    \          map(number) += 1\n            } else {\n                map(number)\
    \ = 1\n            }\n        }\n        for (number <- numbers) {\n         \
    \   if (map(number) == 1) {\n                result = result :+ number\n     \
    \       }\n        }\n        result", "        val set = new HashSet[Long]\n\
    \        val result = new ListBuffer[Long]\n        for (number <- numbers) {\n\
    \            if (!set.contains(number)) {\n                set += number\n   \
    \             result += number\n            }\n        }\n        result.toList",
  "        var result = List[Long]()\n        var set = Set[Long]()\n        for (number\
    \ <- numbers) {\n            if (!set.contains(number)) {\n                result\
    \ = result :+ number\n                set = set + number\n            }\n    \
    \    }\n        result", "        val map = new HashMap[Long, Boolean]\n     \
    \   for (number <- numbers) {\n            if (map.contains(number)) {\n     \
    \           map.put(number, false)\n            } else {\n                map.put(number,\
    \ true)\n            }\n        }\n        var result = List[Long]()\n       \
    \ for (number <- numbers) {\n            if (map.get(number).get) {\n        \
    \        result = number :: result\n            }\n        }\n        result.reverse",
  "        val map = new HashMap[Long, Int]()\n        for (number <- numbers) {\n\
    \            if (map.contains(number)) {\n                map(number) += 1\n \
    \           } else {\n                map(number) = 1\n            }\n       \
    \ }\n        val result = new ListBuffer[Long]()\n        for (number <- numbers)\
    \ {\n            if (map(number) == 1) {\n                result += number\n \
    \           }\n        }\n        result.toList", "        var result = List[Long]()\n\
    \        var seen = Set[Long]()\n        for (number <- numbers) {\n         \
    \   if (!seen.contains(number)) {\n                result = result :+ number\n\
    \                seen = seen + number\n            }\n        }\n        result",
  "        val map = new HashMap[Long, Int]\n        for (number <- numbers) {\n \
    \           if (map.contains(number)) {\n                map(number) += 1\n  \
    \          } else {\n                map(number) = 1\n            }\n        }\n\
    \        val result = new ListBuffer[Long]\n        for (number <- numbers) {\n\
    \            if (map(number) == 1) {\n                result += number\n     \
    \       }\n        }\n        result.toList", "        val map = new HashMap[Long,\
    \ Int]\n        for (number <- numbers) {\n            if (map.contains(number))\
    \ map(number) += 1\n            else map(number) = 1\n        }\n        numbers.filter(map(_)\
    \ == 1)", "        var result = List[Long]()\n        var set = Set[Long]()\n\
    \        for (number <- numbers) {\n            if (!set.contains(number)) {\n\
    \                result = result :+ number\n                set = set + number\n\
    \            }\n        }\n        result", "        val map = new HashMap[Long,\
    \ Int]\n        for (number <- numbers) {\n            if (map.contains(number))\
    \ map(number) += 1\n            else map(number) = 1\n        }\n        numbers.filter(number\
    \ => map(number) == 1)", "        val set = new HashSet[Long]()\n        val result\
    \ = new ListBuffer[Long]()\n        for (number <- numbers) {\n            if\
    \ (!set.contains(number)) {\n                set += number\n                result\
    \ += number\n            }\n        }\n        result.toList", "        val map\
    \ = new HashMap[Long, Int]\n        for (number <- numbers) {\n            if\
    \ (map.contains(number)) map(number) += 1\n            else map(number) = 1\n\
    \        }\n        val result = new ListBuffer[Long]\n        for (number <-\
    \ numbers) {\n            if (map(number) == 1) result += number\n        }\n\
    \        result.toList", "        var result = List[Long]()\n        var map =\
    \ Map[Long, Int]()\n        for (number <- numbers) {\n            if (map.contains(number))\
    \ {\n                map(number) += 1\n            } else {\n                map(number)\
    \ = 1\n            }\n        }\n        for (number <- numbers) {\n         \
    \   if (map(number) == 1) {\n                result = result :+ number\n     \
    \       }\n        }\n        result", "        var result = List[Long]()\n  \
    \      var set = Set[Long]()\n        for (number <- numbers) {\n            if\
    \ (!set.contains(number)) {\n                result = result :+ number\n     \
    \           set += number\n            }\n        }\n        result", '        numbers.foldLeft(List[Long]())((acc,
    x) => if (acc.contains(x)) acc else acc :+ x)', "        var result = List[Long]()\n\
    \        var map = Map[Long, Int]()\n        for (number <- numbers) {\n     \
    \       if (map.contains(number)) {\n                map(number) += 1\n      \
    \      } else {\n                map(number) = 1\n            }\n        }\n \
    \       for (number <- numbers) {\n            if (map(number) == 1) {\n     \
    \           result = result :+ number\n            }\n        }\n        result",
  "        var result = List[Long]()\n        var set = Set[Long]()\n        for (number\
    \ <- numbers) {\n            if (!set.contains(number)) {\n                result\
    \ = result :+ number\n                set = set + number\n            }\n    \
    \    }\n        result", "        var result = new ListBuffer[Long]()\n      \
    \  var set = new HashSet[Long]()\n        for (number <- numbers) {\n        \
    \    if (!set.contains(number)) {\n                result += number\n        \
    \        set += number\n            }\n        }\n        result.toList", "  \
    \      val map = new HashMap[Long, Long]()\n        numbers.foreach(x => {\n \
    \           if (map.contains(x)) map.put(x, map(x) + 1)\n            else map.put(x,\
    \ 1)\n        })\n        numbers.filter(x => map(x) == 1)", "        val map\
    \ = new HashMap[Long, Int]\n        for (i <- numbers) {\n            if (map.contains(i))\
    \ map(i) += 1\n            else map(i) = 1\n        }\n        val result = new\
    \ ListBuffer[Long]\n        for (i <- numbers) {\n            if (map(i) == 1)\
    \ result += i\n        }\n        result.toList", "        var result = List[Long]()\n\
    \        var set = Set[Long]()\n        for (number <- numbers) {\n          \
    \  if (!set.contains(number)) {\n                result = result :+ number\n \
    \               set = set + number\n            }\n        }\n        result",
  "        val set = new HashSet[Long]\n        val result = new ListBuffer[Long]\n\
    \        for (n <- numbers) {\n            if (!set.contains(n)) {\n         \
    \       set += n\n                result += n\n            }\n        }\n    \
    \    result.toList", "        val map = new HashMap[Long, Boolean]\n        for\
    \ (number <- numbers) {\n            if (map.contains(number)) map.put(number,\
    \ false)\n            else map.put(number, true)\n        }\n        val result\
    \ = new ListBuffer[Long]\n        for (number <- numbers) {\n            if (map.get(number).get)\
    \ result += number\n        }\n        result.toList", "        val map = new\
    \ HashMap[Long, Int]()\n        for (number <- numbers) {\n            if (map.contains(number))\
    \ {\n                map(number) += 1\n            } else {\n                map(number)\
    \ = 1\n            }\n        }\n        val result = new ListBuffer[Long]()\n\
    \        for (number <- numbers) {\n            if (map(number) == 1) {\n    \
    \            result += number\n            }\n        }\n        result.toList",
  "        var result = List[Long]()\n        var set = Set[Long]()\n        for (number\
    \ <- numbers) {\n            if (!set.contains(number)) {\n                result\
    \ = result :+ number\n                set = set + number\n            }\n    \
    \    }\n        result", "        val set = new HashSet[Long]\n        val result\
    \ = new ListBuffer[Long]\n        for (number <- numbers) {\n            if (!set.contains(number))\
    \ {\n                set += number\n                result += number\n       \
    \     }\n        }\n        result.toList", "        var result = List[Long]()\n\
    \        var map = Map[Long, Int]()\n        for (n <- numbers) {\n          \
    \  if (map.contains(n)) map(n) += 1\n            else map(n) = 1\n        }\n\
    \        for (n <- numbers) {\n            if (map(n) == 1) result = result :+\
    \ n\n        }\n        result", "        val set = new HashSet[Long]()\n    \
    \    val result = new ListBuffer[Long]()\n        for (i <- numbers) {\n     \
    \       if (!set.contains(i)) {\n                set += i\n                result\
    \ += i\n            }\n        }\n        result.toList", "        val set = new\
    \ HashSet[Long]\n        val result = new ListBuffer[Long]\n        for (number\
    \ <- numbers) {\n            if (!set.contains(number)) {\n                set\
    \ += number\n                result += number\n            }\n        }\n    \
    \    result.toList", "        val map = HashMap[Long, Long]()\n        for (n\
    \ <- numbers) {\n            if (map.contains(n)) {\n                map(n) +=\
    \ 1\n            } else {\n                map(n) = 1\n            }\n       \
    \ }\n        val result = ListBuffer[Long]()\n        for (n <- numbers) {\n \
    \           if (map(n) == 1) {\n                result += n\n            }\n \
    \       }\n        result.toList", "        // Fill in the code here\n       \
    \ return List[Long]()", "        val set = new HashSet[Long]\n        val result\
    \ = new ListBuffer[Long]\n        for (number <- numbers) {\n            if (!set.contains(number))\
    \ {\n                set += number\n                result += number\n       \
    \     }\n        }\n        result.toList", "        val set = new HashSet[Long]\n\
    \        val result = new ListBuffer[Long]\n        for (number <- numbers) {\n\
    \            if (!set.contains(number)) {\n                set += number\n   \
    \             result += number\n            }\n        }\n        result.toList",
  "        // Fill in the code here\n        return null", "        val map = new\
    \ HashMap[Long, Int]\n        for (number <- numbers) {\n            if (map.contains(number))\
    \ map(number) += 1\n            else map(number) = 1\n        }\n        val result\
    \ = new ListBuffer[Long]\n        for (number <- numbers) {\n            if (map(number)\
    \ == 1) result += number\n        }\n        result.toList", "        val map\
    \ = new HashMap[Long, Int]()\n        for (number <- numbers) {\n            if\
    \ (map.contains(number)) map(number) += 1\n            else map(number) = 1\n\
    \        }\n        val result = new ListBuffer[Long]()\n        for (number <-\
    \ numbers) {\n            if (map(number) == 1) result += number\n        }\n\
    \        result.toList", "        val set = new HashSet[Long]\n        val result\
    \ = new ListBuffer[Long]\n        for (number <- numbers) {\n            if (!set.contains(number))\
    \ {\n                set += number\n                result += number\n       \
    \     }\n        }\n        result.toList", "        val map = new HashMap[Long,\
    \ Int]()\n        for (number <- numbers) {\n            if (map.contains(number))\
    \ map(number) += 1\n            else map(number) = 1\n        }\n        val result\
    \ = new ListBuffer[Long]()\n        for (number <- numbers) {\n            if\
    \ (map(number) == 1) result += number\n        }\n        result.toList", "  \
    \      var result = List[Long]()\n        var set = Set[Long]()\n        for (number\
    \ <- numbers) {\n            if (!set.contains(number)) {\n                result\
    \ = result :+ number\n                set = set + number\n            }\n    \
    \    }\n        result", "        val set = new HashSet[Long]\n        val result\
    \ = new ListBuffer[Long]\n        for (number <- numbers) {\n            if (!set.contains(number))\
    \ {\n                set += number\n                result += number\n       \
    \     }\n        }\n        result.toList", "        numbers.foldLeft(List[Long]())((result,\
    \ number) => {\n            if (result.contains(number)) result else number ::\
    \ result\n        }).reverse", "        var map = new HashMap[Long, Int]()\n \
    \       for (number <- numbers) {\n            if (map.contains(number)) {\n \
    \               map(number) += 1\n            } else {\n                map(number)\
    \ = 1\n            }\n        }\n        var result = new ListBuffer[Long]()\n\
    \        for (number <- numbers) {\n            if (map(number) == 1) {\n    \
    \            result += number\n            }\n        }\n        return result.toList",
  "        val set = new HashSet[Long]()\n        val result = new ListBuffer[Long]()\n\
    \        for (number <- numbers) {\n            if (!set.contains(number)) {\n\
    \                set += number\n                result += number\n           \
    \ }\n        }\n        result.toList", "        val numbersSet = numbers.toSet\n\
    \        val numbersList = numbersSet.toList\n        numbersList", "        var\
    \ result = new ListBuffer[Long]\n        var set = new HashSet[Long]\n       \
    \ for (number <- numbers) {\n            if (!set.contains(number)) {\n      \
    \          result += number\n                set += number\n            }\n  \
    \      }\n        result.toList", "        val map = new HashMap[Long, Int]\n\
    \        for (n <- numbers) {\n            if (map.contains(n)) map(n) += 1\n\
    \            else map(n) = 1\n        }\n        val result = new ListBuffer[Long]\n\
    \        for (n <- numbers) {\n            if (map(n) == 1) result += n\n    \
    \    }\n        result.toList", "        val map = new HashMap[Long, Int]\n  \
    \      for (n <- numbers) {\n            if (map.contains(n)) map.put(n, map(n)\
    \ + 1)\n            else map.put(n, 1)\n        }\n        numbers.filter(n =>\
    \ map(n) == 1)", "        val map = new HashMap[Long, Int]\n        for (number\
    \ <- numbers) {\n            if (map.contains(number)) map(number) += 1\n    \
    \        else map(number) = 1\n        }\n        numbers.filter(number => map(number)\
    \ == 1)", "        val map = new HashMap[Long, Long]\n        for (number <- numbers)\
    \ {\n            if (map.contains(number)) map(number) += 1\n            else\
    \ map(number) = 1\n        }\n        val result = new ListBuffer[Long]\n    \
    \    for (number <- numbers) {\n            if (map(number) == 1) result += number\n\
    \        }\n        result.toList", "        var result = List[Long]()\n     \
    \   var map = Map[Long, Int]()\n        for (number <- numbers) {\n          \
    \  if (map.contains(number)) {\n                map(number) += 1\n           \
    \ } else {\n                map(number) = 1\n            }\n        }\n      \
    \  for (number <- numbers) {\n            if (map(number) == 1) {\n          \
    \      result = result :+ number\n            }\n        }\n        result", " \
    \       val map = new HashMap[Long, Long]\n        for (number <- numbers) {\n\
    \            if (map.contains(number)) {\n                map(number) += 1\n \
    \           } else {\n                map(number) = 1\n            }\n       \
    \ }\n        val result = new ListBuffer[Long]\n        for (number <- numbers)\
    \ {\n            if (map(number) == 1) {\n                result += number\n \
    \           }\n        }\n        result.toList", "        // >>> removeDuplicates((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 4l.toLong)))\n        // (List[Long](1l.toLong,\
    \ 3l.toLong, 4l.toLong))\n        // >>> removeDuplicates((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 4l.toLong, 4l.toLong)))\n        // (List[Long](1l.toLong,\
    \ 3l.toLong))\n        // >>> removeDuplicates((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 2l.toLong, 4l.toLong, 4l.toLong, 5l.toLong)))\n        // (List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))\n        // >>> removeDuplicates((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 4l.toLong, 4l.toLong, 5l.toLong, 5l.toLong)))\n\
    \        // (List[Long](1l.toLong, 3l.toLong))\n        // >>> removeDuplicates((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 4l.toLong, 4l.toLong, 5l.toLong, 5l.toLong,\
    \ 6l.toLong)))\n        // (List[Long](1l.toLong, 3l.toLong, 6l.toLong))\n   \
    \     // >>> removeDuplicates((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong,\
    \ 4l.toLong, 4l.toLong, 5l.toLong, 5l.toLong, 6l.toLong, 6l.toLong)))\n      \
    \  // (List[Long](1l.toLong, 3l.toLong))\n        // >>> removeDuplicates((List[Long](1l.toLong,\
    \ 2l.toLong, 3", "        val map = new HashMap[Long, Int]()\n        for (n <-\
    \ numbers) {\n            if (map.contains(n)) map(n) += 1\n            else map(n)\
    \ = 1\n        }\n        val result = new ListBuffer[Long]()\n        for (n\
    \ <- numbers) {\n            if (map(n) == 1) result += n\n        }\n       \
    \ result.toList", '        numbers.distinct', "        val map = new HashMap[Long,\
    \ Long]()\n        for (number <- numbers) {\n            if (map.contains(number))\
    \ {\n                map.put(number, map(number) + 1)\n            } else {\n\
    \                map.put(number, 1)\n            }\n        }\n        val result\
    \ = new ListBuffer[Long]()\n        for (number <- numbers) {\n            if\
    \ (map(number) == 1) {\n                result += number\n            }\n    \
    \    }\n        result.toList", "        // TODO: implement this method\n    \
    \    return numbers", "        val result = new ListBuffer[Long]\n        val\
    \ set = new HashSet[Long]\n        for (number <- numbers) {\n            if (!set.contains(number))\
    \ {\n                result += number\n                set += number\n       \
    \     }\n        }\n        result.toList", "        val map = new HashMap[Long,\
    \ Int]\n        for (number <- numbers) {\n            if (map.contains(number))\
    \ map(number) += 1\n            else map(number) = 1\n        }\n        val result\
    \ = new ListBuffer[Long]\n        for (number <- numbers) {\n            if (map(number)\
    \ == 1) result += number\n        }\n        result.toList", "        val map\
    \ = new HashMap[Long, Long]\n        for (number <- numbers) {\n            if\
    \ (map.contains(number)) map(number) += 1\n            else map(number) = 1\n\
    \        }\n        val result = new ListBuffer[Long]\n        for (number <-\
    \ numbers) {\n            if (map(number) == 1) result += number\n        }\n\
    \        result.toList", "        val map = new HashMap[Long, Int]()\n       \
    \ for (number <- numbers) {\n            if (map.contains(number)) {\n       \
    \         map(number) += 1\n            } else {\n                map(number)\
    \ = 1\n            }\n        }\n        val result = new ListBuffer[Long]()\n\
    \        for (number <- numbers) {\n            if (map(number) == 1) {\n    \
    \            result += number\n            }\n        }\n        result.toList",
  '        numbers.distinct', "        val map = new HashMap[Long, Int]\n        for\
    \ (number <- numbers) {\n            if (map.contains(number)) map(number) +=\
    \ 1\n            else map(number) = 1\n        }\n        numbers.filter(number\
    \ => map(number) == 1)", "        val map = new HashMap[Long, Int]\n        for\
    \ (number <- numbers) {\n            if (map.contains(number)) {\n           \
    \     map(number) += 1\n            } else {\n                map(number) = 1\n\
    \            }\n        }\n        val result = new ListBuffer[Long]\n       \
    \ for (number <- numbers) {\n            if (map(number) == 1) {\n           \
    \     result += number\n            }\n        }\n        result.toList", '        numbers.foldLeft(List[Long]())((acc,
    n) => if (acc.contains(n)) acc else n :: acc).reverse', "        val map = new\
    \ HashMap[Long, Int]\n        numbers.foreach(n => {\n            if (map.contains(n))\
    \ map(n) += 1\n            else map(n) = 1\n        })\n        numbers.filter(n\
    \ => map(n) == 1)", "        var result = List[Long]()\n        var set = Set[Long]()\n\
    \        for (number <- numbers) {\n            if (!set.contains(number)) {\n\
    \                result = result :+ number\n                set += number\n  \
    \          }\n        }\n        result", "        val m = new HashMap[Long, Int]\n\
    \        for (n <- numbers) {\n            if (m.contains(n)) m(n) += 1\n    \
    \        else m(n) = 1\n        }\n        val result = new ListBuffer[Long]\n\
    \        for (n <- numbers) {\n            if (m(n) == 1) result += n\n      \
    \  }\n        result.toList", "        val set = new HashSet[Long]()\n       \
    \ val result = new ListBuffer[Long]()\n        for (number <- numbers) {\n   \
    \         if (!set.contains(number)) {\n                set += number\n      \
    \          result += number\n            }\n        }\n        result.toList",
  "        val counts = new HashMap[Long, Int]\n        for (number <- numbers) {\n\
    \            if (counts.contains(number)) counts(number) += 1\n            else\
    \ counts(number) = 1\n        }\n        numbers.filter(counts(_) == 1)", "  \
    \      var result = List[Long]()\n        var set = Set[Long]()\n        for (number\
    \ <- numbers) {\n            if (!set.contains(number)) {\n                result\
    \ = result :+ number\n                set += number\n            }\n        }\n\
    \        result", "        val map = new HashMap[Long, Int]\n        numbers.foreach(n\
    \ => {\n            if (map.contains(n)) map(n) += 1\n            else map(n)\
    \ = 1\n        })\n        numbers.filter(n => map(n) == 1)", "        val map\
    \ = new HashMap[Long, Int]\n        for (number <- numbers) {\n            if\
    \ (map.contains(number)) {\n                map.put(number, map(number) + 1)\n\
    \            } else {\n                map.put(number, 1)\n            }\n   \
    \     }\n        val result = new ListBuffer[Long]\n        for (number <- numbers)\
    \ {\n            if (map(number) == 1) {\n                result += number\n \
    \           }\n        }\n        result.toList", "        val map = new HashMap[Long,\
    \ Int]\n        for (number <- numbers) {\n            if (map.contains(number))\
    \ {\n                map(number) += 1\n            } else {\n                map(number)\
    \ = 1\n            }\n        }\n        var result = List[Long]()\n        for\
    \ (number <- numbers) {\n            if (map(number) == 1) {\n               \
    \ result = number :: result\n            }\n        }\n        result.reverse",
  "        val map = HashMap[Long, Int]()\n        for (i <- numbers) {\n        \
    \    if (map.contains(i)) map(i) += 1\n            else map(i) = 1\n        }\n\
    \        numbers.filter(i => map(i) == 1)", "        val set = new HashSet[Long]\n\
    \        val result = new ListBuffer[Long]\n        for (number <- numbers) {\n\
    \            if (!set.contains(number)) {\n                set += number\n   \
    \             result += number\n            }\n        }\n        result.toList",
  '        numbers.foldLeft(List[Long]())((acc, x) => if (acc.contains(x)) acc else
    acc :+ x)', "        var result = List[Long]()\n        var set = Set[Long]()\n\
    \        for (number <- numbers) {\n            if (!set.contains(number)) {\n\
    \                result = result :+ number\n                set = set + number\n\
    \            }\n        }\n        result", "        var result = List[Long]()\n\
    \        var set = Set[Long]()\n        for (number <- numbers) {\n          \
    \  if (!set.contains(number)) {\n                result = result :+ number\n \
    \               set += number\n            }\n        }\n        result", "  \
    \      val numbersSet = numbers.toSet\n        val numbersMap = numbers.groupBy(identity).mapValues(_.size)\n\
    \        numbersSet.filter(numbersMap(_) == 1).toList", "        val map = new\
    \ HashMap[Long, Int]\n        for (n <- numbers) {\n            if (map.contains(n))\
    \ map(n) += 1\n            else map(n) = 1\n        }\n        val result = new\
    \ ListBuffer[Long]\n        for (n <- numbers) {\n            if (map(n) == 1)\
    \ result += n\n        }\n        result.toList", "        val set = new HashSet[Long]\n\
    \        val result = new ListBuffer[Long]\n        for (number <- numbers) {\n\
    \            if (!set.contains(number)) {\n                set += number\n   \
    \             result += number\n            }\n        }\n        result.toList",
  "        var map = new HashMap[Long, Int]\n        for (number <- numbers) {\n \
    \           if (map.contains(number)) map(number) += 1\n            else map(number)\
    \ = 1\n        }\n        var result = new ListBuffer[Long]\n        for (number\
    \ <- numbers) {\n            if (map(number) == 1) result += number\n        }\n\
    \        result.toList", "        val set = new HashSet[Long]()\n        val result\
    \ = new ListBuffer[Long]()\n        for (number <- numbers) {\n            if\
    \ (!set.contains(number)) {\n                set += number\n                result\
    \ += number\n            }\n        }\n        result.toList", "        // TODO:\
    \ Implement this method\n        return List[Long]()", "        val set = new\
    \ HashSet[Long]\n        val result = new ListBuffer[Long]\n        for (number\
    \ <- numbers) {\n            if (!set.contains(number)) {\n                set\
    \ += number\n                result += number\n            }\n        }\n    \
    \    result.toList", "        var set = Set[Long]()\n        var result = List[Long]()\n\
    \        for (number <- numbers) {\n            if (!set.contains(number)) {\n\
    \                set += number\n                result = number :: result\n  \
    \          }\n        }\n        result.reverse", "        var result = List[Long]()\n\
    \        var set = Set[Long]()\n        for (number <- numbers) {\n          \
    \  if (!set.contains(number)) {\n                result = result :+ number\n \
    \               set = set + number\n            }\n        }\n        result",
  "        var result = List[Long]()\n        var set = Set[Long]()\n        for (number\
    \ <- numbers) {\n            if (!set.contains(number)) {\n                result\
    \ = result :+ number\n                set = set + number\n            }\n    \
    \    }\n        result", "        var set = Set[Long]()\n        var result =\
    \ List[Long]()\n        for (number <- numbers) {\n            if (!set.contains(number))\
    \ {\n                set += number\n                result = number :: result\n\
    \            }\n        }\n        result.reverse", "        var result = List[Long]()\n\
    \        var set = Set[Long]()\n        for (number <- numbers) {\n          \
    \  if (!set.contains(number)) {\n                result = result :+ number\n \
    \               set = set + number\n            }\n        }\n        result",
  '        numbers.distinct', '        numbers.foldLeft(List[Long]())((acc, x) =>
    if (acc.contains(x)) acc else acc :+ x)', "        val map = new HashMap[Long,\
    \ Boolean]\n        for (number <- numbers) {\n            if (map.contains(number))\
    \ map.put(number, false)\n            else map.put(number, true)\n        }\n\
    \        val result = new ListBuffer[Long]\n        for (number <- numbers) if\
    \ (map(number)) result += number\n        result.toList", "        val set = new\
    \ HashSet[Long]\n        val result = new ListBuffer[Long]\n        for (number\
    \ <- numbers) {\n            if (!set.contains(number)) {\n                set\
    \ += number\n                result += number\n            }\n        }\n    \
    \    result.toList", "        val set = new HashSet[Long]\n        val result\
    \ = new ListBuffer[Long]\n        for (number <- numbers) {\n            if (!set.contains(number))\
    \ {\n                set += number\n                result += number\n       \
    \     }\n        }\n        result.toList", "        val set = new HashSet[Long]\n\
    \        val result = new ListBuffer[Long]\n        for (number <- numbers) {\n\
    \            if (!set.contains(number)) {\n                set += number\n   \
    \             result += number\n            }\n        }\n        result.toList",
  "        val map = new HashMap[Long, Boolean]\n        for (number <- numbers) {\n\
    \            if (map.contains(number)) map(number) = true\n            else map(number)\
    \ = false\n        }\n        val result = new ListBuffer[Long]\n        for (number\
    \ <- numbers) {\n            if (!map(number)) result += number\n        }\n \
    \       result.toList", "        // TODO: Implement this method\n        return\
    \ List[Long]()", "        val map = new HashMap[Long, Int]()\n        for (number\
    \ <- numbers) {\n            if (map.contains(number)) {\n                map(number)\
    \ += 1\n            } else {\n                map(number) = 1\n            }\n\
    \        }\n        val result = new ListBuffer[Long]()\n        for (number <-\
    \ numbers) {\n            if (map(number) == 1) {\n                result += number\n\
    \            }\n        }\n        result.toList", "        val set = new HashSet[Long]\n\
    \        val result = new ListBuffer[Long]\n        for (number <- numbers) {\n\
    \            if (!set.contains(number)) {\n                set += number\n   \
    \             result += number\n            }\n        }\n        result.toList",
  "        val map = new HashMap[Long, Int]\n        for (number <- numbers) {\n \
    \           if (map.contains(number)) {\n                map(number) += 1\n  \
    \          } else {\n                map(number) = 1\n            }\n        }\n\
    \        val result = new ListBuffer[Long]\n        for (number <- numbers) {\n\
    \            if (map(number) == 1) {\n                result += number\n     \
    \       }\n        }\n        result.toList", "        var result = List[Long]()\n\
    \        var set = Set[Long]()\n        for (number <- numbers) {\n          \
    \  if (!set.contains(number)) {\n                result = result :+ number\n \
    \               set = set + number\n            }\n        }\n        result",
  "        var result = List[Long]()\n        var set = Set[Long]()\n        for (number\
    \ <- numbers) {\n            if (!set.contains(number)) {\n                result\
    \ = result :+ number\n                set = set + number\n            }\n    \
    \    }\n        result", '        numbers.foldLeft(List[Long]())((acc, x) => if
    (acc.contains(x)) acc else acc :+ x)', "        val map = new HashMap[Long, Long]\n\
    \        for (number <- numbers) {\n            if (map.contains(number)) map(number)\
    \ += 1\n            else map(number) = 1\n        }\n        val result = new\
    \ ListBuffer[Long]\n        for (number <- numbers) {\n            if (map(number)\
    \ == 1) result += number\n        }\n        result.toList", "        val map\
    \ = new HashMap[Long, Int]()\n        for (number <- numbers) {\n            if\
    \ (map.contains(number)) map(number) += 1\n            else map(number) = 1\n\
    \        }\n        val result = new ListBuffer[Long]()\n        for (number <-\
    \ numbers) {\n            if (map(number) == 1) result += number\n        }\n\
    \        result.toList", '        numbers.foldLeft(List[Long]())((acc, x) => if
    (acc.contains(x)) acc else acc :+ x)', "        val map = new HashMap[Long, Int]\n\
    \        for (number <- numbers) {\n            if (map.contains(number)) map(number)\
    \ += 1\n            else map(number) = 1\n        }\n        var result = List[Long]()\n\
    \        for (number <- numbers) {\n            if (map(number) == 1) result =\
    \ number :: result\n        }\n        result.reverse", "        val map = new\
    \ HashMap[Long, Int]()\n        for (number <- numbers) {\n            if (map.contains(number))\
    \ {\n                map(number) += 1\n            } else {\n                map(number)\
    \ = 1\n            }\n        }\n        val result = new ListBuffer[Long]()\n\
    \        for (number <- numbers) {\n            if (map(number) == 1) {\n    \
    \            result += number\n            }\n        }\n        result.toList",
  "        val set = new HashSet[Long]\n        val result = new ListBuffer[Long]\n\
    \        for (number <- numbers) {\n            if (!set.contains(number)) {\n\
    \                set += number\n                result += number\n           \
    \ }\n        }\n        result.toList", "        val map = HashMap[Long, Int]()\n\
    \        for (number <- numbers) {\n            if (map.contains(number)) map(number)\
    \ += 1\n            else map(number) = 1\n        }\n        val result = ListBuffer[Long]()\n\
    \        for (number <- numbers) {\n            if (map(number) == 1) result +=\
    \ number\n        }\n        result.toList", '        numbers.distinct', "   \
    \     val set = new HashSet[Long]\n        val result = new ArrayBuffer[Long]\n\
    \        for (number <- numbers) {\n            if (!set.contains(number)) {\n\
    \                set += number\n                result += number\n           \
    \ }\n        }\n        result.toList", "        val map = new HashMap[Long, Int]()\n\
    \        for (number <- numbers) {\n            if (map.contains(number)) map(number)\
    \ += 1\n            else map(number) = 1\n        }\n        var result = List[Long]()\n\
    \        for (number <- numbers) {\n            if (map(number) == 1) result =\
    \ number :: result\n        }\n        result.reverse", "        val set = new\
    \ HashSet[Long]\n        val result = new ListBuffer[Long]\n        for (number\
    \ <- numbers) {\n            if (!set.contains(number)) {\n                set\
    \ += number\n                result += number\n            }\n        }\n    \
    \    result.toList", "        val numbersSet = numbers.toSet\n        val numbersMap\
    \ = numbers.groupBy(identity).mapValues(_.size)\n        numbersSet.filter(numbersMap(_)\
    \ == 1).toList", "        var result = List[Long]()\n        var set = Set[Long]()\n\
    \        for (number <- numbers) {\n            if (!set.contains(number)) {\n\
    \                result = result :+ number\n                set = set + number\n\
    \            }\n        }\n        result", "        val set = new HashSet[Long]()\n\
    \        val result = new ListBuffer[Long]()\n        for (number <- numbers)\
    \ {\n            if (!set.contains(number)) {\n                set += number\n\
    \                result += number\n            }\n        }\n        result.toList",
  "        val map = new HashMap[Long, Int]()\n        for (number <- numbers) {\n\
    \            if (map.contains(number)) {\n                map(number) += 1\n \
    \           } else {\n                map(number) = 1\n            }\n       \
    \ }\n        val result = new ListBuffer[Long]()\n        for (number <- numbers)\
    \ {\n            if (map(number) == 1) {\n                result += number\n \
    \           }\n        }\n        result.toList", "        var result : List[Long]\
    \ = List()\n        var set : Set[Long] = Set()\n        for (number <- numbers)\
    \ {\n            if (!set.contains(number)) {\n                result = result\
    \ :+ number\n                set = set + number\n            }\n        }\n  \
    \      return result", "        var set = Set[Long]()\n        var list = List[Long]()\n\
    \        for (number <- numbers) {\n            if (!set.contains(number)) {\n\
    \                set += number\n                list = number :: list\n      \
    \      }\n        }\n        list.reverse"]
stop_tokens:
- "\n    }\n"
