name: HumanEval_119_match_parens
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // You are given a list of two strings, both strings consist of open\n    //\
  \ parentheses '(' or close parentheses ')' only.\n    // Your job is to check if\
  \ it is possible to concatenate the two strings in\n    // some order, that the\
  \ resulting string will be good.\n    // A string S is considered to be good if\
  \ and only if all parentheses in S\n    // are balanced. For example: the string\
  \ '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes'\
  \ if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n\
  \    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    //\
  \ >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst\
  \ : List[String]) : String = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
  ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
  , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
  , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
  , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
  , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\"\
  , \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\",\
  \ \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
  , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
  , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \"\
  )(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"\
  Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\"\
  )));\n    }\n\n}\n"
completions: ["        val s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1\
    \ + s2\n        val stack = new Stack[Char]\n        for (c <- s) {\n        \
    \    if (c == '(') stack.push(c)\n            else if (c == ')') {\n         \
    \       if (stack.isEmpty) return \"No\"\n                else stack.pop\n   \
    \         }\n        }\n        if (stack.isEmpty) \"Yes\" else \"No\"", "   \
    \     val s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n    \
    \    var stack = new Stack[Char]\n        for (c <- s) {\n            if (c ==\
    \ '(') stack.push(c)\n            else {\n                if (stack.isEmpty) return\
    \ \"No\"\n                else stack.pop\n            }\n        }\n        if\
    \ (stack.isEmpty) \"Yes\" else \"No\"", "        val s1 = lst(0)\n        val\
    \ s2 = lst(1)\n        val s = s1 + s2\n        val stack = new Stack[Char]\n\
    \        for (c <- s) {\n            if (c == '(') stack.push(c)\n           \
    \ else {\n                if (stack.isEmpty) return \"No\"\n                else\
    \ stack.pop\n            }\n        }\n        if (stack.isEmpty) \"Yes\" else\
    \ \"No\"", "        val s1 = lst(0)\n        val s2 = lst(1)\n        val s =\
    \ s1 + s2\n        val stack = new Stack[Char]\n        for (c <- s) {\n     \
    \       if (c == '(') {\n                stack.push(c)\n            } else {\n\
    \                if (stack.isEmpty) return \"No\"\n                stack.pop\n\
    \            }\n        }\n        if (stack.isEmpty) \"Yes\" else \"No\"", " \
    \       val s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n  \
    \      val stack = new Stack[Char]\n        for (c <- s) {\n            if (c\
    \ == '(') stack.push(c)\n            else if (c == ')') {\n                if\
    \ (stack.isEmpty) return \"No\"\n                else stack.pop\n            }\n\
    \        }\n        if (stack.isEmpty) \"Yes\" else \"No\"", "        val s1 =\
    \ lst(0)\n        val s2 = lst(1)\n        val s3 = s1 + s2\n        val s4 =\
    \ s2 + s1\n        if (isGood(s3)) \"Yes\"\n        else if (isGood(s4)) \"Yes\"\
    \n        else \"No\"", "        val s1 = lst(0)\n        val s2 = lst(1)\n  \
    \      val s = s1 + s2\n        var stack = Stack[Char]()\n        for (c <- s)\
    \ {\n            if (c == '(') stack.push(c)\n            else if (c == ')') {\n\
    \                if (stack.isEmpty) return \"No\"\n                else stack.pop\n\
    \            }\n        }\n        if (stack.isEmpty) \"Yes\" else \"No\"", " \
    \       val s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n  \
    \      val stack = Stack[Char]()\n        for (c <- s) {\n            if (c ==\
    \ '(') stack.push(c)\n            else {\n                if (stack.isEmpty) return\
    \ \"No\"\n                else stack.pop\n            }\n        }\n        if\
    \ (stack.isEmpty) \"Yes\" else \"No\"", "        val s = lst.mkString\n      \
    \  var count = 0\n        for (c <- s) {\n            if (c == '(') count += 1\n\
    \            else count -= 1\n            if (count < 0) return \"No\"\n     \
    \   }\n        if (count == 0) \"Yes\" else \"No\"", "        val s1 = lst(0)\n\
    \        val s2 = lst(1)\n        val s = s1 + s2\n        val n = s.length\n\
    \        var stack = new Stack[Char]\n        for (i <- 0 until n) {\n       \
    \     val c = s(i)\n            if (c == '(') stack.push(c)\n            else\
    \ {\n                if (stack.isEmpty) return \"No\"\n                else stack.pop\n\
    \            }\n        }\n        if (stack.isEmpty) \"Yes\" else \"No\"", " \
    \       val s1 = lst(0)\n        val s2 = lst(1)\n        val s1_left = s1.count(_\
    \ == '(')\n        val s1_right = s1.count(_ == ')')\n        val s2_left = s2.count(_\
    \ == '(')\n        val s2_right = s2.count(_ == ')')\n        if (s1_left == s1_right\
    \ && s2_left == s2_right) return \"Yes\"\n        if (s1_left == s1_right && s2_left\
    \ != s2_right) return \"No\"\n        if (s1_left != s1_right && s2_left == s2_right)\
    \ return \"No\"\n        if (s1_left != s1_right && s2_left != s2_right) {\n \
    \           val s1_diff = abs(s1_left - s1_right)\n            val s2_diff = abs(s2_left\
    \ - s2_right)\n            if (s1_diff == s2_diff) return \"Yes\"\n          \
    \  else return \"No\"\n        }\n        return \"No\"", "        def isGood(s\
    \ : String) : Boolean = {\n            var count = 0\n            for (c <- s)\
    \ {\n                if (c == '(') count += 1\n                else if (c == ')')\
    \ count -= 1\n                if (count < 0) return false\n            }\n   \
    \         return count == 0\n        }\n        if (isGood(lst(0) + lst(1))) return\
    \ \"Yes\"\n        if (isGood(lst(1) + lst(0))) return \"Yes\"\n        return\
    \ \"No\"", "        val s1 = lst(0)\n        val s2 = lst(1)\n        val s =\
    \ s1 + s2\n        var stack = new Stack[Char]\n        for (i <- 0 until s.length)\
    \ {\n            val c = s(i)\n            if (c == '(') stack.push(c)\n     \
    \       else if (c == ')') {\n                if (stack.isEmpty) return \"No\"\
    \n                else stack.pop\n            }\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"", "        val str1 = lst(0)\n        val str2 = lst(1)\n\
    \        val str = str1 + str2\n        var count = 0\n        for (c <- str)\
    \ {\n            if (c == '(') count += 1\n            else count -= 1\n     \
    \       if (count < 0) return \"No\"\n        }\n        if (count == 0) \"Yes\"\
    \ else \"No\"", "        val s1 = lst(0)\n        val s2 = lst(1)\n        def\
    \ isGood(s : String) : Boolean = {\n            var count = 0\n            for\
    \ (c <- s) {\n                if (c == '(') count += 1\n                else if\
    \ (c == ')') count -= 1\n                if (count < 0) return false\n       \
    \     }\n            return count == 0\n        }\n        if (isGood(s1 + s2))\
    \ return \"Yes\"\n        else if (isGood(s2 + s1)) return \"Yes\"\n        else\
    \ return \"No\"", "        val s1 = lst(0)\n        val s2 = lst(1)\n        val\
    \ s3 = s1 + s2\n        val s4 = s2 + s1\n        if (isGood(s3)) \"Yes\"\n  \
    \      else if (isGood(s4)) \"Yes\"\n        else \"No\"", "        val str1 =\
    \ lst(0)\n        val str2 = lst(1)\n        val str1_open = str1.count(_ == '(')\n\
    \        val str1_close = str1.count(_ == ')')\n        val str2_open = str2.count(_\
    \ == '(')\n        val str2_close = str2.count(_ == ')')\n        if (str1_open\
    \ == str1_close && str2_open == str2_close) \"Yes\"\n        else if (str1_open\
    \ == str1_close && str2_open != str2_close) \"No\"\n        else if (str1_open\
    \ != str1_close && str2_open == str2_close) \"No\"\n        else if (str1_open\
    \ != str1_close && str2_open != str2_close) {\n            if (str1_open > str1_close)\
    \ {\n                if (str1_open - str1_close == str2_open - str2_close) \"\
    Yes\"\n                else \"No\"\n            }\n            else {\n      \
    \          if (str1_close - str1_open == str2_close - str2_open) \"Yes\"\n   \
    \             else \"No\"\n            }\n        }\n        else \"No\"", " \
    \       val s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n  \
    \      val stack = new Stack[Char]\n        for (c <- s) {\n            if (c\
    \ == '(') stack.push(c)\n            else if (c == ')') {\n                if\
    \ (stack.isEmpty) return \"No\"\n                else stack.pop\n            }\n\
    \        }\n        if (stack.isEmpty) \"Yes\" else \"No\"", "        val s1 =\
    \ lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        var count\
    \ = 0\n        for (i <- 0 until s.length) {\n            if (s(i) == '(') count\
    \ += 1\n            else count -= 1\n            if (count < 0) return \"No\"\n\
    \        }\n        if (count == 0) \"Yes\" else \"No\"", "        val s = lst.reduceLeft(_\
    \ + _)\n        if (s.length % 2 == 1) return \"No\"\n        val stack = new\
    \ Stack[Char]\n        for (c <- s) {\n            if (c == '(') stack.push(c)\n\
    \            else if (stack.isEmpty) return \"No\"\n            else stack.pop\n\
    \        }\n        if (stack.isEmpty) \"Yes\" else \"No\""]
stop_tokens:
- "\n    }\n"
