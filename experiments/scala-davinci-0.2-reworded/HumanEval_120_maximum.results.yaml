language: scala
name: HumanEval_120_maximum
results:
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // You have to return a sorted list of length `k` with the maximum k\
    \ numbers in `arr`\n        // You can assume that `k` is less than or equal to\
    \ the length of `arr`\n        // You can assume that `k` is greater than 0\n\
    \        arr.sorted.takeRight(k.toInt)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793374
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // You have to return a sorted list of length `k` with the maximum k\
    \ numbers in `arr`\n        // You can assume that `k` is less than or equal to\
    \ the length of `arr`\n        // You can assume that `k` is greater than 0\n\
    \        // You can assume that `arr` is not empty\n        // You can assume\
    \ that `arr` is not null\n        // You can assume that `arr` does not contain\
    \ null\n        // You can assume that `arr` does not contain duplicates\n   \
    \     // You can assume that `arr` contains only integers\n        // You can\
    \ assume that `arr` contains only positive integers\n        // You can assume\
    \ that `arr` contains only negative integers\n        // You can assume that `arr`\
    \ contains only non-zero integers\n        // You can assume that `arr` contains\
    \ only zero\n        // You can assume that `arr` contains only non-positive integers\n\
    \        // You can assume that `arr` contains only non-negative integers\n  \
    \      // You can assume that `arr` is sorted in ascending order\n        // You\
    \ can assume that `arr` is sorted in descending order\n        // You can assume\
    \ that `arr` is not sorted\n        // You can assume that `arr` is sorted in\
    \ ascending order when `k` is equal to 1\n        // You can assume that `arr`\
    \ is sorted in descending order when `k` is equal to 1\n        // You can assume\
    \ that `arr` is sorted in ascending order when `k` is equal to the length of `arr`\n\
    \        // You can assume that `arr` is sorted in descending order when `k` is\
    \ equal to the length of `arr`\n        // You can assume that `arr` is sorted\
    \ in ascending order when `k` is equal to the length of `arr` minus 1\n      \
    \  // You can assume that `arr` is sorted in descending order when `k` is equal\
    \ to the length of `arr` minus 1\n        // You can assume that `arr` is sorted\
    \ in ascending order when `k` is equal to the length of `arr` plus 1\n       \
    \ // You can assume that `arr` is sorted in descending order when `k` is equal\
    \ to the length of `arr` plus 1\n\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphlrk1v8g.scala:19:59\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m    \e[33mdef\e[0m \e[36mmaximum\e\
    [0m(\e[36marr\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mk\e[0m : \e[35mLong\e\
    [0m) : \e[35mList\e[0m[\e[35mLong\e[0m] = {\n\e[31m\e[31m   |\e[0m           \
    \                                                ^\e[0m\n\e[31m   |\e[0m     \
    \                                               Found:    Unit\n\e[31m   |\e[0m\
    \                                                    Required: List[Long]\n\e\
    [31m20 |\e[0m        \e[34m// Fill up this function body\e[0m\n\e[31m21 |\e[0m\
    \        \e[34m// `arr` is a list of integers\e[0m\n\e[31m22 |\e[0m        \e\
    [34m// `k` is a positive integer\e[0m\n\e[31m23 |\e[0m        \e[34m// You have\
    \ to return a sorted list of length `k` with the maximum k numbers in `arr`\e\
    [0m\n\e[31m24 |\e[0m        \e[34m// You can assume that `k` is less than or equal\
    \ to the length of `arr`\e[0m\n\e[31m25 |\e[0m        \e[34m// You can assume\
    \ that `k` is greater than 0\e[0m\n\e[31m26 |\e[0m        \e[34m// You can assume\
    \ that `arr` is not empty\e[0m\n\e[31m27 |\e[0m        \e[34m// You can assume\
    \ that `arr` is not null\e[0m\n\e[31m28 |\e[0m        \e[34m// You can assume\
    \ that `arr` does not contain null\e[0m\n\e[31m29 |\e[0m        \e[34m// You can\
    \ assume that `arr` does not contain duplicates\e[0m\n\e[31m30 |\e[0m        \e\
    [34m// You can assume that `arr` contains only integers\e[0m\n\e[31m31 |\e[0m\
    \        \e[34m// You can assume that `arr` contains only positive integers\e\
    [0m\n\e[31m32 |\e[0m        \e[34m// You can assume that `arr` contains only negative\
    \ integers\e[0m\n\e[31m33 |\e[0m        \e[34m// You can assume that `arr` contains\
    \ only non-zero integers\e[0m\n\e[31m34 |\e[0m        \e[34m// You can assume\
    \ that `arr` contains only zero\e[0m\n\e[31m35 |\e[0m        \e[34m// You can\
    \ assume that `arr` contains only non-positive integers\e[0m\n\e[31m36 |\e[0m\
    \        \e[34m// You can assume that `arr` contains only non-negative integers\e\
    [0m\n\e[31m37 |\e[0m        \e[34m// You can assume that `arr` is sorted in ascending\
    \ order\e[0m\n\e[31m38 |\e[0m        \e[34m// You can assume that `"
  stdout: ''
  timestamp: 1659793373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        val heap = new PriorityQueue[Long]()(Ordering.by(-_))\n\
    \        for (i <- arr) {\n            heap.enqueue(i)\n            if (heap.size\
    \ > k) heap.dequeue\n        }\n        heap.toList.sorted\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n\
    \    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong,\
    \ -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong,\
    \ -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong,\
    \ 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong,\
    \ 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong,\
    \ 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793374
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // You have to return a sorted list of length `k` with the maximum k\
    \ numbers in `arr`\n        // You can use the function `sort` to sort a list\n\
    \        // You can use the function `take` to take the first `k` elements of\
    \ a list\n        // You can use the function `reverse` to reverse a list\n  \
    \      // You can use the function `max` to find the maximum of a list\n     \
    \   // You can use the function `min` to find the minimum of a list\n        //\
    \ You can use the function `abs` to find the absolute value of a number\n    \
    \    // You can use the function `sum` to find the sum of a list\n        // You\
    \ can use the function `product` to find the product of a list\n        // You\
    \ can use the function `contains` to check if a list contains a number\n     \
    \   // You can use the function `mkString` to convert a list to a string\n   \
    \     // You can use the function `toString` to convert a number to a string\n\
    \        // You can use the function `toLong` to convert a string to a long\n\
    \        // You can use the function `toInt` to convert a string to an integer\n\
    \        // You can use the function `toDouble` to convert a string to a double\n\
    \        // You can use the function `toFloat` to convert a string to a float\n\
    \        // You can use the function `toChar` to convert a string to a character\n\
    \        // You can use the function `toByte` to convert a string to a byte\n\
    \        // You can use the function `toShort` to convert a string to a short\n\
    \        // You can use the function `toBoolean` to convert a string to a boolean\n\
    \        // You can use the function `toList` to convert a string to a list\n\
    \        // You can use the function `toArray` to convert a string to an array\n\
    \        // You can use the function `toMap` to convert a string to a map\n  \
    \      // You can use the function `toSet` to convert a string to a set\n    \
    \    // You can use the function `toBuffer` to convert a string to a buffer\n\
    \        // You can use the function `to\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpeecv4jhj.scala:19:59\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m    \e[33mdef\e[0m \e[36mmaximum\e\
    [0m(\e[36marr\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mk\e[0m : \e[35mLong\e\
    [0m) : \e[35mList\e[0m[\e[35mLong\e[0m] = {\n\e[31m\e[31m   |\e[0m           \
    \                                                ^\e[0m\n\e[31m   |\e[0m     \
    \                                               Found:    Unit\n\e[31m   |\e[0m\
    \                                                    Required: List[Long]\n\e\
    [31m20 |\e[0m        \e[34m// Fill up this function body\e[0m\n\e[31m21 |\e[0m\
    \        \e[34m// `arr` is a list of integers\e[0m\n\e[31m22 |\e[0m        \e\
    [34m// `k` is a positive integer\e[0m\n\e[31m23 |\e[0m        \e[34m// You have\
    \ to return a sorted list of length `k` with the maximum k numbers in `arr`\e\
    [0m\n\e[31m24 |\e[0m        \e[34m// You can use the function `sort` to sort a\
    \ list\e[0m\n\e[31m25 |\e[0m        \e[34m// You can use the function `take` to\
    \ take the first `k` elements of a list\e[0m\n\e[31m26 |\e[0m        \e[34m//\
    \ You can use the function `reverse` to reverse a list\e[0m\n\e[31m27 |\e[0m \
    \       \e[34m// You can use the function `max` to find the maximum of a list\e\
    [0m\n\e[31m28 |\e[0m        \e[34m// You can use the function `min` to find the\
    \ minimum of a list\e[0m\n\e[31m29 |\e[0m        \e[34m// You can use the function\
    \ `abs` to find the absolute value of a number\e[0m\n\e[31m30 |\e[0m        \e\
    [34m// You can use the function `sum` to find the sum of a list\e[0m\n\e[31m31\
    \ |\e[0m        \e[34m// You can use the function `product` to find the product\
    \ of a list\e[0m\n\e[31m32 |\e[0m        \e[34m// You can use the function `contains`\
    \ to check if a list contains a number\e[0m\n\e[31m33 |\e[0m        \e[34m// You\
    \ can use the function `mkString` to convert a list to a string\e[0m\n\e[31m34\
    \ |\e[0m        \e[34m// You can use the function `toString` to convert a number\
    \ to a string\e[0m\n\e[31m35 |\e[0m        \e[34m// You can use the function `toLong`\
    \ to convert a string to a long\e[0m\n\e[31m36 |\e[0m        \e[34m// You can\
    \ use the function `toInt` to convert a string to an integer"
  stdout: ''
  timestamp: 1659793373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // You have to return a sorted list of length `k` with the maximum k\
    \ numbers in `arr`\n        // You can assume that `k` is less than or equal to\
    \ the length of `arr`\n        // You can assume that `k` is greater than 0\n\
    \        arr.sortWith(_ > _).take(k.toInt)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpucwkl69k.scala:29)\n\tat Problem.main(tmpucwkl69k.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793374
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // We can use a max heap to\
    \ solve this problem.\n        // We can use a max heap to solve this problem.\n\
    \        // We can use a max heap to solve this problem.\n        // We can use\
    \ a max heap to solve this problem.\n        // We can use a max heap to solve\
    \ this problem.\n        // We can use a max heap to solve this problem.\n   \
    \     // We can use a max heap to solve this problem.\n        // We can use a\
    \ max heap to solve this problem.\n        // We can use a max heap to solve this\
    \ problem.\n        // We can use a max heap to solve this problem.\n        //\
    \ We can use a max heap to solve this problem.\n        // We can use a max heap\
    \ to solve this problem.\n        // We can use a max heap to solve this problem.\n\
    \        // We can use a max heap to solve this problem.\n        // We can use\
    \ a max heap to solve this problem.\n        // We can use a max heap to solve\
    \ this problem.\n        // We can use a max heap to solve this problem.\n   \
    \     // We can use a max heap to solve this problem.\n        // We can use a\
    \ max heap to solve this problem.\n        // We can use a max heap to solve this\
    \ problem.\n        // We can use a max heap to solve this problem.\n        //\
    \ We can use a max heap to solve this problem.\n        // We can use a max heap\
    \ to solve this problem.\n        // We can use a max heap to solve this problem.\n\
    \        // We can use a max heap to solve this problem.\n        // We can use\
    \ a max heap to solve this problem.\n        // We can use a max heap to solve\
    \ this problem.\n        // We can use a max heap to solve this problem.\n   \
    \     // We can use a max heap to solve this problem.\n        // We can use a\
    \ max heap to solve this problem.\n        // We can use a max heap to solve this\
    \ problem.\n        // We can use a max heap to solve this problem.\n        //\
    \ We can use a max heap to solve this problem.\n        // We can use a max heap\
    \ to solve this problem.\n        // We can use a max heap to solve this problem.\n\
    \        // We can use a max heap to solve this problem.\n        // We can use\
    \ a max\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmph67jtx7o.scala:19:59\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m    \e[33mdef\e[0m \e[36mmaximum\e\
    [0m(\e[36marr\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mk\e[0m : \e[35mLong\e\
    [0m) : \e[35mList\e[0m[\e[35mLong\e[0m] = {\n\e[31m\e[31m   |\e[0m           \
    \                                                ^\e[0m\n\e[31m   |\e[0m     \
    \                                               Found:    Unit\n\e[31m   |\e[0m\
    \                                                    Required: List[Long]\n\e\
    [31m20 |\e[0m        \e[34m// We can use a max heap to solve this problem.\e[0m\n\
    \e[31m21 |\e[0m        \e[34m// We can use a max heap to solve this problem.\e\
    [0m\n\e[31m22 |\e[0m        \e[34m// We can use a max heap to solve this problem.\e\
    [0m\n\e[31m23 |\e[0m        \e[34m// We can use a max heap to solve this problem.\e\
    [0m\n\e[31m24 |\e[0m        \e[34m// We can use a max heap to solve this problem.\e\
    [0m\n\e[31m25 |\e[0m        \e[34m// We can use a max heap to solve this problem.\e\
    [0m\n\e[31m26 |\e[0m        \e[34m// We can use a max heap to solve this problem.\e\
    [0m\n\e[31m27 |\e[0m        \e[34m// We can use a max heap to solve this problem.\e\
    [0m\n\e[31m28 |\e[0m        \e[34m// We can use a max heap to solve this problem.\e\
    [0m\n\e[31m29 |\e[0m        \e[34m// We can use a max heap to solve this problem.\e\
    [0m\n\e[31m30 |\e[0m        \e[34m// We can use a max heap to solve this problem.\e\
    [0m\n\e[31m31 |\e[0m        \e[34m// We can use a max heap to solve this problem.\e\
    [0m\n\e[31m32 |\e[0m        \e[34m// We can use a max heap to solve this problem.\e\
    [0m\n\e[31m33 |\e[0m        \e[34m// We can use a max heap to solve this problem.\e\
    [0m\n\e[31m34 |\e[0m        \e[34m// We can use a max heap to solve this problem.\e\
    [0m\n\e[31m35 |\e[0m        \e[34m// We can use a max heap to solve this problem.\e\
    [0m\n\e[31m36 |\e[0m        \e[34m// We can use a max heap to solve this problem.\e\
    [0m\n\e[31m37 |\e[0m        \e[34m// We can use a max heap to solve this problem.\e\
    [0m\n\e[31m38 |\e[0m        \e[34m// We can use a max heap to solve this problem.\e\
    [0m\n\e[31m39 |\e[0m        \e[34m// We can use a max heap to solve thi"
  stdout: ''
  timestamp: 1659793373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // You have to return a sorted list of length `k` with the maximum k\
    \ numbers in `arr`\n        // You can assume that `k` is less than or equal to\
    \ the length of `arr`\n        // You can assume that `k` is greater than 0\n\
    \        arr.sortWith(_ > _).take(k.toInt)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpucwkl69k.scala:29)\n\tat Problem.main(tmpucwkl69k.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793374
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // Return a sorted list of length `k` with the maximum `k` numbers in\
    \ `arr`\n        arr.sorted.takeRight(k.toInt)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793374
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // return a sorted list of length `k` with the maximum `k` numbers in\
    \ `arr`\n        arr.sortWith(_ > _).take(k.toInt)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n\
    \    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong,\
    \ -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong,\
    \ -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong,\
    \ 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong,\
    \ 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong,\
    \ 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpaumru7pg.scala:27)\n\tat Problem.main(tmpaumru7pg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793374
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // 'arr' is a list of integers\n        // 'k' is a positive integer\n\
    \        // Return a sorted list of length 'k' with the maximum 'k' numbers in\
    \ 'arr'\n        arr.sorted.takeRight(k.toInt)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793374
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Define a function to get\
    \ the maximum number in the list.\n        def maximum(arr : List[Long]) : Long\
    \ = {\n            arr.max\n        }\n        // Define a function to get the\
    \ index of the maximum number in the list.\n        def maximumIndex(arr : List[Long])\
    \ : Int = {\n            arr.indexOf(arr.max)\n        }\n        // Define a\
    \ function to remove the maximum number in the list.\n        def removeMaximum(arr\
    \ : List[Long]) : List[Long] = {\n            arr.patch(maximumIndex(arr), Nil,\
    \ 1)\n        }\n        // Define a function to get the maximum k numbers in\
    \ the list.\n        def maximum(arr : List[Long], k : Long) : List[Long] = {\n\
    \            if (k == 0) {\n                Nil\n            } else {\n      \
    \          maximum(arr) :: maximum(removeMaximum(arr), k - 1)\n            }\n\
    \        }\n        // Return the result.\n        maximum(arr, k).sorted\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpip37udtt.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mdef\e[0m \e[36mmaximum\e[0m(\e[36marr\e\
    [0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mk\e[0m : \e[35mLong\e[0m) : \e[35mList\e\
    [0m[\e[35mLong\e[0m] = {\n\e[31m\e[31m   |\e[0m        ^\e[0m\n\e[31m   |\e[0mmaximum\
    \ is already defined as \e[33mmethod\e[0m \e[35mmaximum\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m34 |\e[0m            \e[33mif\e[0m (k == \e[31m0\e\
    [0m) {\n\e[31m35 |\e[0m                Nil\n\e[31m36 |\e[0m            } \e[33melse\e\
    [0m {\n\e[31m37 |\e[0m                maximum(arr) :: maximum(removeMaximum(arr),\
    \ k - \e[31m1\e[0m)\n\e[31m38 |\e[0m            }\n\e[31m39 |\e[0m        }\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpip37udtt.scala:41:16 --------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m        maximum(arr, k).sorted\n\e[31m\e[31m   |\e[0m\
    \                ^^^^^^\e[0m\n\e[31m   |\e[0m                Found:    \e[1m\e\
    [31m(\e[0mList[Long]\e[1m\e[31m,\e[0m\e[1m\e[31m \e[0m\e[1m\e[31mLong\e[0m\e[1m\e\
    [31m)\e[0m\n\e[31m   |\e[0m                Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659793373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // You have to return a sorted list of length `k` with the maximum k\
    \ numbers in `arr`\n        // You can assume that `k` is less than or equal to\
    \ the length of `arr`\n        // You can assume that `k` is greater than 0\n\
    \        arr.sorted.takeRight(k.toInt)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793374
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // We can use a heap to solve\
    \ this problem.\n        // We can use a min heap to store the k largest elements.\n\
    \        // We can use a max heap to store the k smallest elements.\n        //\
    \ We can use a min heap to store the k largest elements.\n        // We can use\
    \ a max heap to store the k smallest elements.\n        // We can use a min heap\
    \ to store the k largest elements.\n        // We can use a max heap to store\
    \ the k smallest elements.\n        // We can use a min heap to store the k largest\
    \ elements.\n        // We can use a max heap to store the k smallest elements.\n\
    \        // We can use a min heap to store the k largest elements.\n        //\
    \ We can use a max heap to store the k smallest elements.\n        // We can use\
    \ a min heap to store the k largest elements.\n        // We can use a max heap\
    \ to store the k smallest elements.\n        // We can use a min heap to store\
    \ the k largest elements.\n        // We can use a max heap to store the k smallest\
    \ elements.\n        // We can use a min heap to store the k largest elements.\n\
    \        // We can use a max heap to store the k smallest elements.\n        //\
    \ We can use a min heap to store the k largest elements.\n        // We can use\
    \ a max heap to store the k smallest elements.\n        // We can use a min heap\
    \ to store the k largest elements.\n        // We can use a max heap to store\
    \ the k smallest elements.\n        // We can use a min heap to store the k largest\
    \ elements.\n        // We can use a max heap to store the k smallest elements.\n\
    \        // We can use a min heap to store the k largest elements.\n        //\
    \ We can use a max heap to store the k smallest elements.\n        // We can use\
    \ a min heap to store the k largest elements.\n        // We can use a max heap\
    \ to store the k smallest elements.\n        // We can use a min heap to store\
    \ the k largest elements.\n        // We can use a max heap to store the k smallest\
    \ elements.\n        // We can use a min heap to store the k largest elements.\n\
    \        // We can use a max heap to store the k smallest elements.\n        //\
    \ We can use a min heap to store the k largest elements.\n        //\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmph9wqb6m2.scala:19:59\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m    \e[33mdef\e[0m \e[36mmaximum\e\
    [0m(\e[36marr\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mk\e[0m : \e[35mLong\e\
    [0m) : \e[35mList\e[0m[\e[35mLong\e[0m] = {\n\e[31m\e[31m   |\e[0m           \
    \                                                ^\e[0m\n\e[31m   |\e[0m     \
    \                                               Found:    Unit\n\e[31m   |\e[0m\
    \                                                    Required: List[Long]\n\e\
    [31m20 |\e[0m        \e[34m// We can use a heap to solve this problem.\e[0m\n\e\
    [31m21 |\e[0m        \e[34m// We can use a min heap to store the k largest elements.\e\
    [0m\n\e[31m22 |\e[0m        \e[34m// We can use a max heap to store the k smallest\
    \ elements.\e[0m\n\e[31m23 |\e[0m        \e[34m// We can use a min heap to store\
    \ the k largest elements.\e[0m\n\e[31m24 |\e[0m        \e[34m// We can use a max\
    \ heap to store the k smallest elements.\e[0m\n\e[31m25 |\e[0m        \e[34m//\
    \ We can use a min heap to store the k largest elements.\e[0m\n\e[31m26 |\e[0m\
    \        \e[34m// We can use a max heap to store the k smallest elements.\e[0m\n\
    \e[31m27 |\e[0m        \e[34m// We can use a min heap to store the k largest elements.\e\
    [0m\n\e[31m28 |\e[0m        \e[34m// We can use a max heap to store the k smallest\
    \ elements.\e[0m\n\e[31m29 |\e[0m        \e[34m// We can use a min heap to store\
    \ the k largest elements.\e[0m\n\e[31m30 |\e[0m        \e[34m// We can use a max\
    \ heap to store the k smallest elements.\e[0m\n\e[31m31 |\e[0m        \e[34m//\
    \ We can use a min heap to store the k largest elements.\e[0m\n\e[31m32 |\e[0m\
    \        \e[34m// We can use a max heap to store the k smallest elements.\e[0m\n\
    \e[31m33 |\e[0m        \e[34m// We can use a min heap to store the k largest elements.\e\
    [0m\n\e[31m34 |\e[0m        \e[34m// We can use a max heap to store the k smallest\
    \ elements.\e[0m\n\e[31m35 |\e[0m        \e[34m// We can use a min heap to store\
    \ the k largest elements.\e[0m\n\e[31m36 |\e[0m        \e[34m// We can use a max\
    \ heap to store the k smallest elements.\e[0m\n\e[31m37 |\e[0m        \e[34m//\
    \ We can use a min heap to s"
  stdout: ''
  timestamp: 1659793373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // 'return List[Long]()' in case of timeout or other internal errors\n\
    \        return List[Long]()\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpr24qhy86.scala:25)\n\tat Problem.main(tmpr24qhy86.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793374
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // return a sorted list of length `k` with the maximum `k` numbers in\
    \ `arr`\n        arr.sorted.takeRight(k.toInt)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793374
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Define a function that\
    \ returns the maximum element in a list.\n        def maximum(arr : List[Long])\
    \ : Long = {\n            // If the list is empty, return 0.\n            if (arr.isEmpty)\
    \ {\n                return 0l\n            }\n            // Otherwise, return\
    \ the maximum element in the list.\n            else {\n                return\
    \ arr.max\n            }\n        }\n        // Define a function that removes\
    \ the maximum element in a list.\n        def removeMaximum(arr : List[Long])\
    \ : List[Long] = {\n            // If the list is empty, return an empty list.\n\
    \            if (arr.isEmpty) {\n                return List[Long]()\n       \
    \     }\n            // Otherwise, remove the maximum element in the list.\n \
    \           else {\n                return arr.filter((x : Long) => x != arr.max)\n\
    \            }\n        }\n        // Define a function that returns the maximum\
    \ k elements in a list.\n        def maximum(arr : List[Long], k : Long) : List[Long]\
    \ = {\n            // If k is 0, return an empty list.\n            if (k == 0l)\
    \ {\n                return List[Long]()\n            }\n            // Otherwise,\
    \ return the maximum element in the list, followed by the maximum k - 1 elements\
    \ in the list.\n            else {\n                return maximum(arr) :: maximum(removeMaximum(arr),\
    \ k - 1l)\n            }\n        }\n        // Return the maximum k elements\
    \ in the list.\n        return maximum(arr, k)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmplsx5se2g.scala:43:12 ---------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m        \e[33mdef\e[0m \e[36mmaximum\e[0m(\e[36marr\e\
    [0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mk\e[0m : \e[35mLong\e[0m) : \e[35mList\e\
    [0m[\e[35mLong\e[0m] = {\n\e[31m\e[31m   |\e[0m        ^\e[0m\n\e[31m   |\e[0mmaximum\
    \ is already defined as \e[33mmethod\e[0m \e[35mmaximum\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m44 |\e[0m            \e[34m// If k is 0, return\
    \ an empty list.\e[0m\n\e[31m45 |\e[0m            \e[33mif\e[0m (k == \e[31m0l\e\
    [0m) {\n\e[31m46 |\e[0m                \e[33mreturn\e[0m List[\e[35mLong\e[0m]()\n\
    \e[31m47 |\e[0m            }\n\e[31m48 |\e[0m            \e[34m// Otherwise, return\
    \ the maximum element in the list, followed by the maximum k - 1 elements in the\
    \ list.\e[0m\n\e[31m49 |\e[0m            \e[33melse\e[0m {\n\e[31m50 |\e[0m  \
    \              \e[33mreturn\e[0m maximum(arr) :: maximum(removeMaximum(arr), k\
    \ - \e[31m1l\e[0m)\n\e[31m51 |\e[0m            }\n\e[31m52 |\e[0m        }\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmplsx5se2g.scala:54:23 --------------------\e\
    [0m\e[0m\n\e[31m54 |\e[0m        \e[33mreturn\e[0m maximum(arr, k)\n\e[31m\e[31m\
    \   |\e[0m                       ^^^^^^\e[0m\n\e[31m   |\e[0m                \
    \       Found:    \e[1m\e[31m(\e[0mList[Long]\e[1m\e[31m,\e[0m\e[1m\e[31m \e[0m\e\
    [1m\e[31mLong\e[0m\e[1m\e[31m)\e[0m\n\e[31m   |\e[0m                       Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659793373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // 'return List[Long]()' for Scala and 'return {}' for Java\n       \
    \ return List[Long]()\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpogje8xdb.scala:25)\n\tat Problem.main(tmpogje8xdb.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793374
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // 'arr' is a list of integers\n        // 'k' is a positive integer\n\
    \        // Return a sorted list of length 'k' with the maximum 'k' numbers in\
    \ 'arr'\n        arr.sorted.takeRight(k.toInt)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793374
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        def maximum0(arr : List[Long],\
    \ k : Long, acc : List[Long]) : List[Long] = {\n            if (k == 0) acc\n\
    \            else {\n                val max = arr.max\n                val index\
    \ = arr.indexOf(max)\n                maximum0(arr.take(index) ++ arr.drop(index\
    \ + 1), k - 1, acc :+ max)\n            }\n        }\n        maximum0(arr, k,\
    \ List[Long]())\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8poyzjd8.scala:31)\n\tat Problem.main(tmp8poyzjd8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793374
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // return a sorted list of length `k` with the maximum `k` numbers in\
    \ `arr`\n        arr.sorted.takeRight(k.toInt)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793374
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // 'return List[Long]()' in case of timeout or other internal errors\n\
    \        return List[Long]()\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpr24qhy86.scala:25)\n\tat Problem.main(tmpr24qhy86.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793374
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // You can add another function as well, if required\n        arr.sorted.takeRight(k.toInt)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793374
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // You have to return a sorted list of length `k` with the maximum k\
    \ numbers in `arr`\n        // You can assume that `k` is less than or equal to\
    \ the length of `arr`\n        // You can assume that `k` is greater than 0\n\
    \        // You can assume that `arr` is not empty\n        // You can assume\
    \ that `arr` is not null\n        // You can assume that `arr` does not contain\
    \ null elements\n        // You can assume that `arr` is not a list of strings\n\
    \        // You can assume that `arr` is not a list of characters\n        //\
    \ You can assume that `arr` is not a list of booleans\n        // You can assume\
    \ that `arr` is not a list of floats\n        // You can assume that `arr` is\
    \ not a list of doubles\n        // You can assume that `arr` is not a list of\
    \ tuples\n        // You can assume that `arr` is not a list of lists\n      \
    \  // You can assume that `arr` is not a list of sets\n        // You can assume\
    \ that `arr` is not a list of maps\n        // You can assume that `arr` is not\
    \ a list of arrays\n        // You can assume that `arr` is not a list of objects\n\
    \        // You can assume that `arr` is not a list of functions\n        // You\
    \ can assume that `arr` is not a list of classes\n        // You can assume that\
    \ `arr` is not a list of traits\n        // You can assume that `arr` is not a\
    \ list of interfaces\n        // You can assume that `arr` is not a list of enums\n\
    \        // You can assume that `arr` is not a list of structs\n        // You\
    \ can assume that `arr` is not a list of unions\n        // You can assume that\
    \ `arr` is not a list of unions\n        // You can assume that `arr` is not a\
    \ list of unions\n        // You can assume that `arr` is not a list of unions\n\
    \        // You can assume that `arr` is not a list of unions\n        // You\
    \ can assume that `arr` is not a list of unions\n        // You can assume that\
    \ `arr\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpm3bg_0cs.scala:19:59\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m    \e[33mdef\e[0m \e[36mmaximum\e\
    [0m(\e[36marr\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mk\e[0m : \e[35mLong\e\
    [0m) : \e[35mList\e[0m[\e[35mLong\e[0m] = {\n\e[31m\e[31m   |\e[0m           \
    \                                                ^\e[0m\n\e[31m   |\e[0m     \
    \                                               Found:    Unit\n\e[31m   |\e[0m\
    \                                                    Required: List[Long]\n\e\
    [31m20 |\e[0m        \e[34m// Fill up this function body\e[0m\n\e[31m21 |\e[0m\
    \        \e[34m// `arr` is a list of integers\e[0m\n\e[31m22 |\e[0m        \e\
    [34m// `k` is a positive integer\e[0m\n\e[31m23 |\e[0m        \e[34m// You have\
    \ to return a sorted list of length `k` with the maximum k numbers in `arr`\e\
    [0m\n\e[31m24 |\e[0m        \e[34m// You can assume that `k` is less than or equal\
    \ to the length of `arr`\e[0m\n\e[31m25 |\e[0m        \e[34m// You can assume\
    \ that `k` is greater than 0\e[0m\n\e[31m26 |\e[0m        \e[34m// You can assume\
    \ that `arr` is not empty\e[0m\n\e[31m27 |\e[0m        \e[34m// You can assume\
    \ that `arr` is not null\e[0m\n\e[31m28 |\e[0m        \e[34m// You can assume\
    \ that `arr` does not contain null elements\e[0m\n\e[31m29 |\e[0m        \e[34m//\
    \ You can assume that `arr` is not a list of strings\e[0m\n\e[31m30 |\e[0m   \
    \     \e[34m// You can assume that `arr` is not a list of characters\e[0m\n\e\
    [31m31 |\e[0m        \e[34m// You can assume that `arr` is not a list of booleans\e\
    [0m\n\e[31m32 |\e[0m        \e[34m// You can assume that `arr` is not a list of\
    \ floats\e[0m\n\e[31m33 |\e[0m        \e[34m// You can assume that `arr` is not\
    \ a list of doubles\e[0m\n\e[31m34 |\e[0m        \e[34m// You can assume that\
    \ `arr` is not a list of tuples\e[0m\n\e[31m35 |\e[0m        \e[34m// You can\
    \ assume that `arr` is not a list of lists\e[0m\n\e[31m36 |\e[0m        \e[34m//\
    \ You can assume that `arr` is not a list of sets\e[0m\n\e[31m37 |\e[0m      \
    \  \e[34m// You can assume that `arr` is not a list of maps\e[0m\n\e[31m38 |\e\
    [0m        \e[34m// You can assume that `arr` is not a list of arrays\e[0m\n\e\
    [31m3"
  stdout: ''
  timestamp: 1659793373
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // We can use a max heap to\
    \ solve this problem.\n        // The max heap will contain the k largest elements.\n\
    \        // We will iterate through the list and add each element to the heap.\n\
    \        // If the heap is full, we will remove the smallest element from the\
    \ heap.\n        // At the end, we will return the heap as a sorted list.\n  \
    \      // The time complexity is O(n * log(k)) and the space complexity is O(k).\n\
    \        val heap = new mutable.PriorityQueue[Long]()\n        for (elem <- arr)\
    \ {\n            heap.enqueue(elem)\n            if (heap.size > k) heap.dequeue\n\
    \        }\n        heap.toList.sorted\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpsm7v8e5e.scala:26:23 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mheap\e[0m = \e[33mnew\e\
    [0m mutable.PriorityQueue[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m          \
    \             ^^^^^^^\e[0m\n\e[31m   |\e[0m                       Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659793371
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // 'return List[Long]()' in case of timeout or error\n        return\
    \ List[Long]()\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptnwjr7rr.scala:25)\n\tat Problem.main(tmptnwjr7rr.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793374
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // We can use a heap to solve\
    \ this problem in O(n log k) time.\n        // First, we insert the first k elements\
    \ of the array into a max heap.\n        // Then, for each of the remaining elements,\
    \ we compare it to the root of the heap.\n        // If the element is greater\
    \ than the root, we replace the root with the element.\n        // Otherwise,\
    \ we ignore the element.\n        // After we have processed all of the elements,\
    \ we return the heap.\n        // This solution runs in O(n log k) time and O(k)\
    \ space.\n        val heap = new PriorityQueue[Long]()(Ordering.by(-_))\n    \
    \    for (i <- 0 until k.toInt) {\n            heap.enqueue(arr(i))\n        }\n\
    \        for (i <- k.toInt until arr.length) {\n            if (arr(i) > heap.head)\
    \ {\n                heap.dequeue\n                heap.enqueue(arr(i))\n    \
    \        }\n        }\n        heap.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxt9s7dhr.scala:43)\n\tat Problem.main(tmpxt9s7dhr.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793374
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // You have to return a sorted list of length `k` with the maximum k\
    \ numbers in `arr`\n        // You can assume that `k` is less than or equal to\
    \ the length of `arr`\n        // You can assume that `k` is greater than 0\n\
    \        // You can assume that `arr` is not empty\n        // You can assume\
    \ that `arr` is not null\n        // You can assume that `arr` does not contain\
    \ null elements\n        // You can assume that `arr` does not contain duplicates\n\
    \        // You can assume that `arr` is sorted in non-decreasing order\n    \
    \    // You can assume that `arr` contains only positive integers\n        //\
    \ You can assume that `arr` contains only integers\n        // You can assume\
    \ that `arr` contains only numbers\n        // You can assume that `arr` contains\
    \ only real numbers\n        // You can assume that `arr` contains only rational\
    \ numbers\n        // You can assume that `arr` contains only algebraic numbers\n\
    \        // You can assume that `arr` contains only complex numbers\n        //\
    \ You can assume that `arr` contains only transcendental numbers\n        // You\
    \ can assume that `arr` contains only natural numbers\n        // You can assume\
    \ that `arr` contains only integers\n        // You can assume that `arr` contains\
    \ only whole numbers\n        // You can assume that `arr` contains only non-negative\
    \ integers\n        // You can assume that `arr` contains only positive integers\n\
    \        // You can assume that `arr` contains only non-positive integers\n  \
    \      // You can assume that `arr` contains only negative integers\n        //\
    \ You can assume that `arr` contains only non-zero integers\n        // You can\
    \ assume that `arr` contains only zero\n        // You can assume that `arr` contains\
    \ only non-zero numbers\n        // You can assume that `arr` contains only zero\n\
    \        // You can assume that `arr` contains only non-zero real numbers\n  \
    \      // You can assume that `arr` contains only zero\n        // You can assume\
    \ that `arr` contains only non-zero rational numbers\n        // You can assume\
    \ that `arr` contains only zero\n        // You can assume that `arr` contains\
    \ only non-zero algebraic\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpdvn5cskx.scala:19:59\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m    \e[33mdef\e[0m \e[36mmaximum\e\
    [0m(\e[36marr\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mk\e[0m : \e[35mLong\e\
    [0m) : \e[35mList\e[0m[\e[35mLong\e[0m] = {\n\e[31m\e[31m   |\e[0m           \
    \                                                ^\e[0m\n\e[31m   |\e[0m     \
    \                                               Found:    Unit\n\e[31m   |\e[0m\
    \                                                    Required: List[Long]\n\e\
    [31m20 |\e[0m        \e[34m// Fill up this function body\e[0m\n\e[31m21 |\e[0m\
    \        \e[34m// `arr` is a list of integers\e[0m\n\e[31m22 |\e[0m        \e\
    [34m// `k` is a positive integer\e[0m\n\e[31m23 |\e[0m        \e[34m// You have\
    \ to return a sorted list of length `k` with the maximum k numbers in `arr`\e\
    [0m\n\e[31m24 |\e[0m        \e[34m// You can assume that `k` is less than or equal\
    \ to the length of `arr`\e[0m\n\e[31m25 |\e[0m        \e[34m// You can assume\
    \ that `k` is greater than 0\e[0m\n\e[31m26 |\e[0m        \e[34m// You can assume\
    \ that `arr` is not empty\e[0m\n\e[31m27 |\e[0m        \e[34m// You can assume\
    \ that `arr` is not null\e[0m\n\e[31m28 |\e[0m        \e[34m// You can assume\
    \ that `arr` does not contain null elements\e[0m\n\e[31m29 |\e[0m        \e[34m//\
    \ You can assume that `arr` does not contain duplicates\e[0m\n\e[31m30 |\e[0m\
    \        \e[34m// You can assume that `arr` is sorted in non-decreasing order\e\
    [0m\n\e[31m31 |\e[0m        \e[34m// You can assume that `arr` contains only positive\
    \ integers\e[0m\n\e[31m32 |\e[0m        \e[34m// You can assume that `arr` contains\
    \ only integers\e[0m\n\e[31m33 |\e[0m        \e[34m// You can assume that `arr`\
    \ contains only numbers\e[0m\n\e[31m34 |\e[0m        \e[34m// You can assume that\
    \ `arr` contains only real numbers\e[0m\n\e[31m35 |\e[0m        \e[34m// You can\
    \ assume that `arr` contains only rational numbers\e[0m\n\e[31m36 |\e[0m     \
    \   \e[34m// You can assume that `arr` contains only algebraic numbers\e[0m\n\e\
    [31m37 |\e[0m        \e[34m// You can assume that `arr` contains only complex\
    \ numbers\e[0m\n\e[31m38 |\e[0m        \e[34m// You can assume that "
  stdout: ''
  timestamp: 1659793373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // You have to return a sorted list of length `k` with the maximum k\
    \ numbers in `arr`\n        // You can assume that `k` is less than or equal to\
    \ the length of `arr`\n        // You can assume that `k` is greater than 0\n\
    \        arr.sorted.takeRight(k.toInt)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793374
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Given a list arr of integers\
    \ and a positive integer k, return a sorted list \n        // of length k with\
    \ the maximum k numbers in arr.\n        // Example 1:\n        // >>> maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l))\n        // (List[Long](-4l.toLong, -3l.toLong,\
    \ 5l.toLong))\n        // Example 2:\n        // >>> maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l))\n        // (List[Long](4l.toLong, 4l.toLong))\n\
    \        // Example 3:\n        // >>> maximum((List[Long](-3l.toLong, 2l.toLong,\
    \ 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n        //\
    \ (List[Long](2l.toLong))\n        // Note:\n        // 1. The length of the list\
    \ will be in the range of [1, 1000].\n        // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n        // 3. 0 <= k <= len(arr)\n      \
    \  def maximum_helper(arr : List[Long], k : Long, acc : List[Long]) : List[Long]\
    \ = {\n            if (k == 0) {\n                acc\n            } else {\n\
    \                val max = arr.max\n                val new_arr = arr.filter(x\
    \ => x != max)\n                maximum_helper(new_arr, k - 1, acc :+ max)\n \
    \           }\n        }\n        maximum_helper(arr, k, List[Long]())\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpzimqacnh.scala:47)\n\tat Problem.main(tmpzimqacnh.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793374
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // 'result' should be a list of length 'k'\n        // 'result' should\
    \ be sorted in descending order\n        // 'result' should contain the maximum\
    \ k numbers in 'arr'\n        var result : List[Long] = List[Long]()\n       \
    \ return result\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6r803w8u.scala:28)\n\tat Problem.main(tmp6r803w8u.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793377
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Given a list arr of integers\
    \ and a positive integer k, return a sorted list \n        // of length k with\
    \ the maximum k numbers in arr.\n        // Example 1:\n        // >>> maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l))\n        // (List[Long](-4l.toLong, -3l.toLong,\
    \ 5l.toLong))\n        // Example 2:\n        // >>> maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l))\n        // (List[Long](4l.toLong, 4l.toLong))\n\
    \        // Example 3:\n        // >>> maximum((List[Long](-3l.toLong, 2l.toLong,\
    \ 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n        //\
    \ (List[Long](2l.toLong))\n        // Note:\n        // 1. The length of the list\
    \ will be in the range of [1, 1000].\n        // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n        // 3. 0 <= k <= len(arr)\n      \
    \  def maximum0(arr : List[Long], k : Long, acc : List[Long]) : List[Long] = {\n\
    \            // This is a tail-recursive function.\n            if (k == 0l) {\n\
    \                acc\n            } else {\n                val (max, arr1) =\
    \ arr.foldLeft((Long.MinValue, List[Long]()))((t, e) => {\n                  \
    \  if (e > t._1) {\n                        (e, t._2 :+ e)\n                 \
    \   } else {\n                        (t._1, t._2 :+ e)\n                    }\n\
    \                })\n                maximum0(arr1.filter((e) => e != max), k\
    \ - 1l, acc :+ max)\n            }\n        }\n        maximum0(arr, k, List[Long]())\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpq3gowuso.scala:53)\n\tat Problem.main(tmpq3gowuso.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793379
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // You have to return a sorted list of length `k` with the maximum k\
    \ numbers in `arr`\n        // You can assume that `k` is less than or equal to\
    \ the length of `arr`\n        // You can assume that `k` is greater than 0\n\
    \        // You can assume that `arr` is not empty\n        // You can assume\
    \ that `arr` is not null\n        // You can assume that `arr` does not contain\
    \ null\n        // You can assume that `arr` does not contain duplicates\n   \
    \     // You can assume that `arr` is sorted in ascending order\n        // You\
    \ can assume that `arr` contains only positive integers\n        // You can assume\
    \ that `arr` contains only integers\n        // You can assume that `arr` contains\
    \ only numbers\n        // You can assume that `arr` contains only longs\n   \
    \     // You can assume that `arr` contains only longs and integers\n        //\
    \ You can assume that `arr` contains only longs, integers, and numbers\n     \
    \   // You can assume that `arr` contains only longs, integers, numbers, and null\n\
    \        // You can assume that `arr` contains only longs, integers, numbers,\
    \ null, and duplicates\n        // You can assume that `arr` contains only longs,\
    \ integers, numbers, null, duplicates, and ascending order\n        // You can\
    \ assume that `arr` contains only longs, integers, numbers, null, duplicates,\
    \ ascending order, and positive integers\n        // You can assume that `arr`\
    \ contains only longs, integers, numbers, null, duplicates, ascending order, positive\
    \ integers, and k\n        // You can assume that `arr` contains only longs, integers,\
    \ numbers, null, duplicates, ascending order, positive integers, k, and arr\n\
    \        // You can assume that `arr` contains only longs, integers, numbers,\
    \ null, duplicates, ascending order, positive integers, k, arr, and k\n      \
    \  // You can assume that `arr` contains only longs, integers, numbers, null,\
    \ duplicates, ascending order, positive integers, k, arr, k, and arr\n       \
    \ // You can assume that `arr` contains only longs, integers, numbers, null, dupl\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3fb72prw.scala:19:59\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m    \e[33mdef\e[0m \e[36mmaximum\e\
    [0m(\e[36marr\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mk\e[0m : \e[35mLong\e\
    [0m) : \e[35mList\e[0m[\e[35mLong\e[0m] = {\n\e[31m\e[31m   |\e[0m           \
    \                                                ^\e[0m\n\e[31m   |\e[0m     \
    \                                               Found:    Unit\n\e[31m   |\e[0m\
    \                                                    Required: List[Long]\n\e\
    [31m20 |\e[0m        \e[34m// Fill up this function body\e[0m\n\e[31m21 |\e[0m\
    \        \e[34m// `arr` is a list of integers\e[0m\n\e[31m22 |\e[0m        \e\
    [34m// `k` is a positive integer\e[0m\n\e[31m23 |\e[0m        \e[34m// You have\
    \ to return a sorted list of length `k` with the maximum k numbers in `arr`\e\
    [0m\n\e[31m24 |\e[0m        \e[34m// You can assume that `k` is less than or equal\
    \ to the length of `arr`\e[0m\n\e[31m25 |\e[0m        \e[34m// You can assume\
    \ that `k` is greater than 0\e[0m\n\e[31m26 |\e[0m        \e[34m// You can assume\
    \ that `arr` is not empty\e[0m\n\e[31m27 |\e[0m        \e[34m// You can assume\
    \ that `arr` is not null\e[0m\n\e[31m28 |\e[0m        \e[34m// You can assume\
    \ that `arr` does not contain null\e[0m\n\e[31m29 |\e[0m        \e[34m// You can\
    \ assume that `arr` does not contain duplicates\e[0m\n\e[31m30 |\e[0m        \e\
    [34m// You can assume that `arr` is sorted in ascending order\e[0m\n\e[31m31 |\e\
    [0m        \e[34m// You can assume that `arr` contains only positive integers\e\
    [0m\n\e[31m32 |\e[0m        \e[34m// You can assume that `arr` contains only integers\e\
    [0m\n\e[31m33 |\e[0m        \e[34m// You can assume that `arr` contains only numbers\e\
    [0m\n\e[31m34 |\e[0m        \e[34m// You can assume that `arr` contains only longs\e\
    [0m\n\e[31m35 |\e[0m        \e[34m// You can assume that `arr` contains only longs\
    \ and integers\e[0m\n\e[31m36 |\e[0m        \e[34m// You can assume that `arr`\
    \ contains only longs, integers, and numbers\e[0m\n\e[31m37 |\e[0m        \e[34m//\
    \ You can assume that `arr` contains only longs, integers, numbers, and null\e\
    [0m\n\e[31m38 |\e[0m        \e[34m// You can a"
  stdout: ''
  timestamp: 1659793378
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // 'return List[Long]()' for Scala and 'return new ArrayList<Long>()'\
    \ for Java\n        return List[Long]()\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7g5a4ppi.scala:25)\n\tat Problem.main(tmp7g5a4ppi.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793379
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // return a sorted list of length `k` with the maximum `k` numbers in\
    \ `arr`\n        arr.sorted.takeRight(k.toInt)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793374
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // 'return List[Long]()' in case of timeout or internal error\n     \
    \   return List[Long]()\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4stnr6t2.scala:25)\n\tat Problem.main(tmp4stnr6t2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793379
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Given a list arr of integers\
    \ and a positive integer k, return a sorted list \n        // of length k with\
    \ the maximum k numbers in arr.\n        // Example 1:\n        // >>> maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l))\n        // (List[Long](-4l.toLong, -3l.toLong,\
    \ 5l.toLong))\n        // Example 2:\n        // >>> maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l))\n        // (List[Long](4l.toLong, 4l.toLong))\n\
    \        // Example 3:\n        // >>> maximum((List[Long](-3l.toLong, 2l.toLong,\
    \ 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n        //\
    \ (List[Long](2l.toLong))\n        // Note:\n        // 1. The length of the list\
    \ will be in the range of [1, 1000].\n        // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n        // 3. 0 <= k <= len(arr)\n      \
    \  def maximum(arr : List[Long], k : Long) : List[Long] = {\n            val n\
    \ = arr.length\n            val m = arr.max\n            val p = arr.min\n   \
    \         val q = (m - p) / k\n            val r = (m - p) % k\n            val\
    \ s = (0l to k).map(i => (p + (q * i) + min(i, r))).toList\n            val t\
    \ = s.map(i => (arr.filter(j => (j >= i)).length)).toList\n            val u =\
    \ (0l to k).map(i => (s(i.toInt), t(i.toInt))).toList\n            val v = u.filter(i\
    \ => (i._2 >= (k - i._1 + p))).map(i => (i._1)).toList\n            val w = v.max\n\
    \            val x\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpekuyn0ej.scala:47:4 ----------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpekuyn0ej.scala:63:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m63 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmpekuyn0ej.scala:47:5 ---------------------\e[0m\e[0m\n\
    \e[31m47 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:\
    \    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpekuyn0ej.scala:62:1 ---------------------\e\
    [0m\e[0m\n\e[31m62 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:\
    \    Unit\n\e[31m   |\e[0m Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[33m\e[33m--\
    \ Warning: /tmp/tmpekuyn0ej.scala:48:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m48 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n4 errors found\n"
  stdout: ''
  timestamp: 1659793379
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // You have to return a sorted list of length `k` with the maximum k\
    \ numbers in `arr`\n        // You can assume that `k` is less than or equal to\
    \ the length of `arr`\n        // You can assume that `k` is greater than 0\n\
    \        arr.sorted.takeRight(k.toInt)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793374
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // 'return List[Long]()' for Scala and 'return new List<Long>()' for\
    \ Java\n        return List[Long]()\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp90_la350.scala:25)\n\tat Problem.main(tmp90_la350.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793379
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // You have to return a sorted list of length `k` with the maximum k\
    \ numbers in `arr`\n        // You can assume that `k` is less than or equal to\
    \ the length of `arr`\n        // You can assume that `k` is greater than 0\n\
    \        arr.sorted.takeRight(k.toInt)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793374
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        val maxHeap = new MaxHeap(arr)\n\
    \        val result = new ListBuffer[Long]\n        for (i <- 0l.toLong until\
    \ k) result += maxHeap.pop\n        result.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmphb9c1ztr.scala:20:26 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mmaxHeap\e[0m = \e[33mnew\e\
    [0m \e[35mMaxHeap\e[0m(arr)\n\e[31m\e[31m   |\e[0m                          ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                          Not found: type MaxHeap\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659793377
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // You have to return a sorted list of length `k` with the maximum k\
    \ numbers in `arr`\n        // If `k` is greater than the length of `arr`, return\
    \ `arr` sorted in descending order\n        // If `k` is 0, return an empty list\n\
    \        // The elements in the list will be in the range of [-1000, 1000]\n \
    \       // The range of the length of the list will be in the range of [1, 1000]\n\
    \        arr.sorted.takeRight(k.toInt).reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpt8x_roc3.scala:31)\n\tat Problem.main(tmpt8x_roc3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793379
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // 'return List[Long]()' in case of timeout or other internal errors\n\
    \        return List[Long]()\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpr24qhy86.scala:25)\n\tat Problem.main(tmpr24qhy86.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793374
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // You have to return a sorted list of length `k` with the maximum k\
    \ numbers in `arr`\n        // You can assume that `k` is less than or equal to\
    \ the length of `arr`\n        // You can assume that `k` is greater than 0\n\
    \        arr.sorted.takeRight(k.toInt)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793374
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Define the maximum function\
    \ as a recursive function.\n        def maximum0(arr : List[Long], k : Long, acc\
    \ : List[Long]) : List[Long] = {\n            // If the list is empty, return\
    \ the accumulator.\n            if (arr.isEmpty) acc\n            // If the accumulator\
    \ is empty, return the accumulator.\n            else if (acc.isEmpty) maximum0(arr.tail,\
    \ k, acc :+ arr.head)\n            // If the accumulator is not empty, return\
    \ the accumulator.\n            else if (acc.length == k) acc\n            //\
    \ If the accumulator is not empty, return the accumulator.\n            else if\
    \ (acc.head > arr.head) maximum0(arr.tail, k, acc)\n            // If the accumulator\
    \ is not empty, return the accumulator.\n            else maximum0(arr.tail, k,\
    \ (acc.tail :+ arr.head).sorted)\n        }\n        // Return the maximum function.\n\
    \        maximum0(arr, k, List[Long]())\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmppxh37zyb.scala:37)\n\tat Problem.main(tmppxh37zyb.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793380
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // 'arr' is a list of integers\n        // 'k' is a positive integer\n\
    \        // Return a sorted list of length 'k' with the maximum 'k' numbers in\
    \ 'arr'\n        arr.sortWith(_ > _).take(k.toInt)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n\
    \    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong,\
    \ -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong,\
    \ -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong,\
    \ 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong,\
    \ 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong,\
    \ 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5ubx70z_.scala:27)\n\tat Problem.main(tmp5ubx70z_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793380
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // 'return List[Long]()' in case of timeout or other internal errors\n\
    \        return List[Long]()\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpr24qhy86.scala:25)\n\tat Problem.main(tmpr24qhy86.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793374
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // 'passed' variable is just a placeholder for compilation\n        val\
    \ passed : Boolean = true\n        return arr\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmprljpbfcn.scala:26)\n\tat Problem.main(tmprljpbfcn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793379
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // You have to return a sorted list of length `k` with the maximum k\
    \ numbers in `arr`\n        // You can assume that `k` is less than or equal to\
    \ the length of `arr`\n        // You can assume that `k` is greater than 0\n\
    \        // You can assume that `arr` is not empty\n        val list = arr.sorted\n\
    \        list.takeRight(k.toInt)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793380
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        val sorted = arr.sorted\n\
    \        sorted.takeRight(k.toInt)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793380
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        val arrSorted = arr.sorted\n\
    \        val arrSortedReversed = arrSorted.reverse\n        arrSortedReversed.take(k.toInt)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpiinbckdt.scala:25)\n\tat Problem.main(tmpiinbckdt.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793380
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // You have to return a sorted list of length `k` with the maximum k\
    \ numbers in `arr`\n        // You can assume that `k` is less than or equal to\
    \ the length of `arr`\n        // You can assume that `k` is greater than 0\n\
    \        // You can assume that `arr` is not empty\n        // You can assume\
    \ that `arr` is not null\n        // You can assume that `arr` does not contain\
    \ null\n        // You can assume that `arr` does not contain duplicates\n   \
    \     // You can assume that `arr` is sorted in non-decreasing order\n       \
    \ // You can assume that `arr` is sorted in non-increasing order\n        // You\
    \ can assume that `arr` is sorted in increasing order\n        // You can assume\
    \ that `arr` is sorted in decreasing order\n        // You can assume that `arr`\
    \ is sorted in non-decreasing order\n        // You can assume that `arr` is sorted\
    \ in non-increasing order\n        // You can assume that `arr` is sorted in increasing\
    \ order\n        // You can assume that `arr` is sorted in decreasing order\n\
    \        // You can assume that `arr` is sorted in non-decreasing order\n    \
    \    // You can assume that `arr` is sorted in non-increasing order\n        //\
    \ You can assume that `arr` is sorted in increasing order\n        // You can\
    \ assume that `arr` is sorted in decreasing order\n        // You can assume that\
    \ `arr` is sorted in non-decreasing order\n        // You can assume that `arr`\
    \ is sorted in non-increasing order\n        // You can assume that `arr` is sorted\
    \ in increasing order\n        // You can assume that `arr` is sorted in decreasing\
    \ order\n        // You can assume that `arr` is sorted in non-decreasing order\n\
    \        // You can assume that `arr` is sorted in non-increasing order\n    \
    \    // You can assume that `arr` is sorted in increasing order\n        // You\
    \ can assume that `arr` is sorted in decreasing order\n        // You can assume\
    \ that `arr` is sorted in non-decreasing order\n        // You can assume that\
    \ `arr` is sorted in non-increasing order\n       \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n\
    \    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong,\
    \ -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong,\
    \ -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong,\
    \ 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong,\
    \ 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong,\
    \ 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpx7s7c7nw.scala:19:59\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m    \e[33mdef\e[0m \e[36mmaximum\e\
    [0m(\e[36marr\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mk\e[0m : \e[35mLong\e\
    [0m) : \e[35mList\e[0m[\e[35mLong\e[0m] = {\n\e[31m\e[31m   |\e[0m           \
    \                                                ^\e[0m\n\e[31m   |\e[0m     \
    \                                               Found:    Unit\n\e[31m   |\e[0m\
    \                                                    Required: List[Long]\n\e\
    [31m20 |\e[0m        \e[34m// Fill up this function body\e[0m\n\e[31m21 |\e[0m\
    \        \e[34m// `arr` is a list of integers\e[0m\n\e[31m22 |\e[0m        \e\
    [34m// `k` is a positive integer\e[0m\n\e[31m23 |\e[0m        \e[34m// You have\
    \ to return a sorted list of length `k` with the maximum k numbers in `arr`\e\
    [0m\n\e[31m24 |\e[0m        \e[34m// You can assume that `k` is less than or equal\
    \ to the length of `arr`\e[0m\n\e[31m25 |\e[0m        \e[34m// You can assume\
    \ that `k` is greater than 0\e[0m\n\e[31m26 |\e[0m        \e[34m// You can assume\
    \ that `arr` is not empty\e[0m\n\e[31m27 |\e[0m        \e[34m// You can assume\
    \ that `arr` is not null\e[0m\n\e[31m28 |\e[0m        \e[34m// You can assume\
    \ that `arr` does not contain null\e[0m\n\e[31m29 |\e[0m        \e[34m// You can\
    \ assume that `arr` does not contain duplicates\e[0m\n\e[31m30 |\e[0m        \e\
    [34m// You can assume that `arr` is sorted in non-decreasing order\e[0m\n\e[31m31\
    \ |\e[0m        \e[34m// You can assume that `arr` is sorted in non-increasing\
    \ order\e[0m\n\e[31m32 |\e[0m        \e[34m// You can assume that `arr` is sorted\
    \ in increasing order\e[0m\n\e[31m33 |\e[0m        \e[34m// You can assume that\
    \ `arr` is sorted in decreasing order\e[0m\n\e[31m34 |\e[0m        \e[34m// You\
    \ can assume that `arr` is sorted in non-decreasing order\e[0m\n\e[31m35 |\e[0m\
    \        \e[34m// You can assume that `arr` is sorted in non-increasing order\e\
    [0m\n\e[31m36 |\e[0m        \e[34m// You can assume that `arr` is sorted in increasing\
    \ order\e[0m\n\e[31m37 |\e[0m        \e[34m// You can assume that `arr` is sorted\
    \ in decreasing order\e[0m\n\e[31m38 |\e[0m        \e[34m// You "
  stdout: ''
  timestamp: 1659793379
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        val sorted = arr.sorted\n\
    \        val result = new ListBuffer[Long]\n        for (i <- 0 until k.toInt)\
    \ {\n            result += sorted(sorted.length - i - 1)\n        }\n        result.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptlcz92gm.scala:28)\n\tat Problem.main(tmptlcz92gm.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793380
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // We can use a max heap to\
    \ solve this problem.\n        // The max heap will have size k.\n        // We\
    \ will iterate through the list and add each element to the heap.\n        //\
    \ If the heap size is greater than k, we will pop the max element from the heap.\n\
    \        // After iterating through the list, we will have the k largest elements\
    \ in the heap.\n        // We will then pop each element from the heap and add\
    \ it to the result list.\n        // The result list will be in descending order.\n\
    \        // We will then reverse the result list to get the result in ascending\
    \ order.\n        val heap = new mutable.PriorityQueue[Long]()\n        for (i\
    \ <- arr) {\n            heap.enqueue(i)\n            if (heap.size > k) heap.dequeue\n\
    \        }\n        val result = new ListBuffer[Long]()\n        while (heap.nonEmpty)\
    \ result += heap.dequeue\n        result.toList.reverse\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n\
    \    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong,\
    \ -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong,\
    \ -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong,\
    \ 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong,\
    \ 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong,\
    \ 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmptim20f0c.scala:28:23 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mheap\e[0m = \e[33mnew\e\
    [0m mutable.PriorityQueue[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m          \
    \             ^^^^^^^\e[0m\n\e[31m   |\e[0m                       Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659793378
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        val heap = new PriorityQueue[Long]()(Ordering.by(-_))\n\
    \        for (i <- arr) {\n            heap.enqueue(i)\n            if (heap.size\
    \ > k) heap.dequeue\n        }\n        heap.toList.sorted\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n\
    \    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong,\
    \ -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong,\
    \ -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong,\
    \ 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong,\
    \ 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong,\
    \ 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793374
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Implement this function\n\
    \        return List[Long]()\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpvveo1f2w.scala:24)\n\tat Problem.main(tmpvveo1f2w.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793380
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // You have to return a sorted list of length `k` with the maximum k\
    \ numbers in `arr`\n        // You can assume that `k` is less than or equal to\
    \ the length of `arr`\n        // You can assume that `k` is greater than 0\n\
    \        arr.sorted.takeRight(k.toInt)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793374
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // 'result' should be the maximum k numbers in arr\n        // 'result'\
    \ should be sorted in descending order\n        // 'result' should be a list of\
    \ length k\n        var result : List[Long] = List[Long]()\n        return result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp92lh1gxs.scala:28)\n\tat Problem.main(tmp92lh1gxs.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793380
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // 'return List[Long]()' in case of timeout or other failure\n      \
    \  return List[Long]()\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpko6m9p8u.scala:25)\n\tat Problem.main(tmpko6m9p8u.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793380
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // return a sorted list of length `k` with the maximum `k` numbers in\
    \ `arr`\n        arr.sortWith(_ > _).take(k.toInt)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n\
    \    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong,\
    \ -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong,\
    \ -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong,\
    \ 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong,\
    \ 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong,\
    \ 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpaumru7pg.scala:27)\n\tat Problem.main(tmpaumru7pg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793374
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // You have to return a sorted list of length `k` with the maximum k\
    \ numbers in `arr`\n        // You can assume that `k` is less than or equal to\
    \ the length of `arr`\n        // You can assume that `k` is greater than 0\n\
    \        arr.sorted.takeRight(k.toInt)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793374
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // We can use a priority queue\
    \ to solve this problem.\n        // The idea is to keep the queue size at k.\n\
    \        // If the queue size is less than k, we add the element to the queue.\n\
    \        // If the queue size is k, we check if the element is greater than the\
    \ minimum element in the queue.\n        // If it is, we remove the minimum element\
    \ and add the new element.\n        // If it is not, we do nothing.\n        //\
    \ Once we have processed all the elements, we return the queue.\n        val queue\
    \ = new PriorityQueue[Long]()(Ordering.Long.reverse)\n        for (i <- arr) {\n\
    \            if (queue.size < k) queue.enqueue(i)\n            else if (i > queue.head)\
    \ {\n                queue.dequeue\n                queue.enqueue(i)\n       \
    \     }\n        }\n        queue.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpy2w0m83u.scala:41)\n\tat Problem.main(tmpy2w0m83u.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793380
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // `k` is the number of elements you need to return\n        // `arr`\
    \ is the list of integers\n        // You can create other functions as well,\
    \ if needed\n        arr.sorted.takeRight(k.toInt)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n\
    \    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong,\
    \ -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong,\
    \ -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong,\
    \ 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong,\
    \ 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong,\
    \ 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793380
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        val heap = new PriorityQueue[Long]()(Ordering.by(-_))\n\
    \        for (i <- arr) {\n            heap.enqueue(i)\n            if (heap.size\
    \ > k) heap.dequeue\n        }\n        heap.toList.sorted\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n\
    \    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong,\
    \ -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong,\
    \ -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong,\
    \ 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong,\
    \ 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong,\
    \ 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793374
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        val heap = new PriorityQueue[Long]()(Ordering.by(-_))\n\
    \        for (i <- arr) {\n            heap.enqueue(i)\n            if (heap.size\
    \ > k) heap.dequeue\n        }\n        heap.toList.sorted\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n\
    \    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong,\
    \ -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong,\
    \ -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong,\
    \ 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong,\
    \ 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong,\
    \ 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793374
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // You have to return a sorted list of length `k` with the maximum k\
    \ numbers in `arr`\n        // If `k` is greater than the length of `arr`, return\
    \ `arr` sorted in descending order\n        // If `k` is 0, return an empty list\n\
    \        // The elements in the list will be in the range of [-1000, 1000]\n \
    \       // The range of the length of list will be [1, 1000]\n        // 0 <=\
    \ k <= len(arr)\n        // return a sorted list of length `k` with the maximum\
    \ k numbers in `arr`\n        if (k == 0) {\n            return List[Long]()\n\
    \        }\n        if (k >= arr.length) {\n            return arr.sortWith(_\
    \ > _)\n        }\n        var maxHeap = new MaxHeap[Long](k)\n        for (i\
    \ <- 0 until arr.length) {\n            maxHeap.insert(arr(i))\n        }\n  \
    \      var result = List[Long]()\n        for (i <- 0 until k) {\n           \
    \ result = maxHeap.extractMax() :: result\n        }\n        return result.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmplekt_ck2.scala:36:26 ------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mvar\e[0m \e[36mmaxHeap\e[0m = \e[33mnew\e\
    [0m \e[35mMaxHeap\e[0m[\e[35mLong\e[0m](k)\n\e[31m\e[31m   |\e[0m            \
    \              ^^^^^^^\e[0m\n\e[31m   |\e[0m                          Not found:\
    \ type MaxHeap\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmplekt_ck2.scala:41:26\
    \ --------------------\e[0m\e[0m\n\e[31m41 |\e[0m        \e[33mfor\e[0m (i <-\
    \ \e[31m0\e[0m until k) {\n\e[31m\e[31m   |\e[0m                          ^\e\
    [0m\n\e[31m   |\e[0m                          Found:    (k : Long)\n\e[31m   |\e\
    [0m                          Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659793382
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // 'arr' is a list of integers\n        // 'k' is a positive integer\n\
    \        // Return a sorted list of length 'k' with the maximum 'k' numbers in\
    \ 'arr'\n        arr.sorted.takeRight(k.toInt)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793374
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // Return a sorted list of length `k` with the maximum `k` numbers in\
    \ `arr`\n        arr.sorted.takeRight(k.toInt)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793374
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // 'return List[Long]()' in case of timeout or other internal errors\n\
    \        return List[Long]()\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpr24qhy86.scala:25)\n\tat Problem.main(tmpr24qhy86.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793374
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        val heap = new Heap[Long]()\n\
    \        for (i <- arr) {\n            heap.insert(i)\n            if (heap.size\
    \ > k) heap.extractMin()\n        }\n        heap.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n\
    \    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong,\
    \ -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong,\
    \ -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong,\
    \ 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong,\
    \ 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong,\
    \ 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpupy0mmpu.scala:20:23 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mheap\e[0m = \e[33mnew\e\
    [0m \e[35mHeap\e[0m[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                \
    \       ^^^^\e[0m\n\e[31m   |\e[0m                       Not found: type Heap\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659793381
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        val heap = new PriorityQueue[Long]()(Ordering.by(-_))\n\
    \        for (i <- arr) {\n            heap.enqueue(i)\n            if (heap.size\
    \ > k) heap.dequeue\n        }\n        heap.toList.sorted\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n\
    \    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong,\
    \ -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong,\
    \ -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong,\
    \ 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong,\
    \ 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong,\
    \ 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793374
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // 'return List[Long]()' in case of timeout or other internal error\n\
    \        return List[Long]()\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmplpy9oyxj.scala:25)\n\tat Problem.main(tmplpy9oyxj.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793383
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // You have to return a sorted list of length `k` with the maximum k\
    \ numbers in `arr`\n        // You can assume that `k` is less than or equal to\
    \ the length of `arr`\n        // You can assume that `k` is greater than 0\n\
    \        arr.sortWith(_ > _).take(k.toInt)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpucwkl69k.scala:29)\n\tat Problem.main(tmpucwkl69k.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793374
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // You have to return a sorted list of length `k` with the maximum k\
    \ numbers in `arr`\n        // You can assume that `k` is less than or equal to\
    \ the length of `arr`\n        // You can assume that `k` is greater than 0\n\
    \        arr.sorted.takeRight(k.toInt)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793374
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // 'return List[Long]()' in case of timeout or internal error\n     \
    \   return List[Long]()\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4stnr6t2.scala:25)\n\tat Problem.main(tmp4stnr6t2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793379
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // You have to return a sorted list of length `k` with the maximum k\
    \ numbers in `arr`\n        arr.sortWith(_ > _).take(k.toInt)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong,\
    \ 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8489lf26.scala:27)\n\tat Problem.main(tmp8489lf26.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793384
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // We use a heap to store\
    \ the k largest elements.\n        // We use a max heap to store the k largest\
    \ elements.\n        // We use a min heap to store the k smallest elements.\n\
    \        // We use a max heap to store the k largest elements.\n        // We\
    \ use a min heap to store the k smallest elements.\n        // We use a max heap\
    \ to store the k largest elements.\n        // We use a min heap to store the\
    \ k smallest elements.\n        // We use a max heap to store the k largest elements.\n\
    \        // We use a min heap to store the k smallest elements.\n        // We\
    \ use a max heap to store the k largest elements.\n        // We use a min heap\
    \ to store the k smallest elements.\n        // We use a max heap to store the\
    \ k largest elements.\n        // We use a min heap to store the k smallest elements.\n\
    \        // We use a max heap to store the k largest elements.\n        // We\
    \ use a min heap to store the k smallest elements.\n        // We use a max heap\
    \ to store the k largest elements.\n        // We use a min heap to store the\
    \ k smallest elements.\n        // We use a max heap to store the k largest elements.\n\
    \        // We use a min heap to store the k smallest elements.\n        // We\
    \ use a max heap to store the k largest elements.\n        // We use a min heap\
    \ to store the k smallest elements.\n        // We use a max heap to store the\
    \ k largest elements.\n        // We use a min heap to store the k smallest elements.\n\
    \        // We use a max heap to store the k largest elements.\n        // We\
    \ use a min heap to store the k smallest elements.\n        // We use a max heap\
    \ to store the k largest elements.\n        // We use a min heap to store the\
    \ k smallest elements.\n        // We use a max heap to store the k largest elements.\n\
    \        // We use a min heap to store the k smallest elements.\n        // We\
    \ use a max heap to store the k largest elements.\n        // We use a min heap\
    \ to store the k smallest elements.\n        // We use a max heap to store the\
    \ k largest elements.\n        // We use a min heap to store the k smallest elements.\n\
    \        // We use a max heap to store the k largest elements.\n        //\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmplb51by9g.scala:19:59\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m    \e[33mdef\e[0m \e[36mmaximum\e\
    [0m(\e[36marr\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mk\e[0m : \e[35mLong\e\
    [0m) : \e[35mList\e[0m[\e[35mLong\e[0m] = {\n\e[31m\e[31m   |\e[0m           \
    \                                                ^\e[0m\n\e[31m   |\e[0m     \
    \                                               Found:    Unit\n\e[31m   |\e[0m\
    \                                                    Required: List[Long]\n\e\
    [31m20 |\e[0m        \e[34m// We use a heap to store the k largest elements.\e\
    [0m\n\e[31m21 |\e[0m        \e[34m// We use a max heap to store the k largest\
    \ elements.\e[0m\n\e[31m22 |\e[0m        \e[34m// We use a min heap to store the\
    \ k smallest elements.\e[0m\n\e[31m23 |\e[0m        \e[34m// We use a max heap\
    \ to store the k largest elements.\e[0m\n\e[31m24 |\e[0m        \e[34m// We use\
    \ a min heap to store the k smallest elements.\e[0m\n\e[31m25 |\e[0m        \e\
    [34m// We use a max heap to store the k largest elements.\e[0m\n\e[31m26 |\e[0m\
    \        \e[34m// We use a min heap to store the k smallest elements.\e[0m\n\e\
    [31m27 |\e[0m        \e[34m// We use a max heap to store the k largest elements.\e\
    [0m\n\e[31m28 |\e[0m        \e[34m// We use a min heap to store the k smallest\
    \ elements.\e[0m\n\e[31m29 |\e[0m        \e[34m// We use a max heap to store the\
    \ k largest elements.\e[0m\n\e[31m30 |\e[0m        \e[34m// We use a min heap\
    \ to store the k smallest elements.\e[0m\n\e[31m31 |\e[0m        \e[34m// We use\
    \ a max heap to store the k largest elements.\e[0m\n\e[31m32 |\e[0m        \e\
    [34m// We use a min heap to store the k smallest elements.\e[0m\n\e[31m33 |\e\
    [0m        \e[34m// We use a max heap to store the k largest elements.\e[0m\n\e\
    [31m34 |\e[0m        \e[34m// We use a min heap to store the k smallest elements.\e\
    [0m\n\e[31m35 |\e[0m        \e[34m// We use a max heap to store the k largest\
    \ elements.\e[0m\n\e[31m36 |\e[0m        \e[34m// We use a min heap to store the\
    \ k smallest elements.\e[0m\n\e[31m37 |\e[0m        \e[34m// We use a max heap\
    \ to store the k largest elements.\e[0m\n\e[31m38 |\e[0m        \e[34m// "
  stdout: ''
  timestamp: 1659793383
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // You have to return a sorted list of length `k` with the maximum k\
    \ numbers in `arr`\n        // You can assume that `k` is less than or equal to\
    \ the length of `arr`\n        // You can assume that `k` is greater than 0\n\
    \        arr.sorted.takeRight(k.toInt)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793374
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // 'return List[Long]()' if the result is an empty list\n        // 'return\
    \ List[Long](1l)' if the result is a list with single element '1'\n        //\
    \ 'return List[Long](1l, 2l, 3l)' if the result is a list with multiple elements\
    \ '1, 2, 3'\n        var result = List[Long]()\n        for (i <- 0 until k.toInt)\
    \ {\n            var max = -1000000000l\n            var index = -1\n        \
    \    for (j <- 0 until arr.length) {\n                if (arr(j) > max) {\n  \
    \                  max = arr(j)\n                    index = j\n             \
    \   }\n            }\n            result = result :+ max\n            arr = arr.take(index)\
    \ ++ arr.drop(index + 1)\n        }\n        return result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n\
    \    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong,\
    \ -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong,\
    \ -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong,\
    \ 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong,\
    \ 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong,\
    \ 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmpwmxz_uv6.scala:35:16 -----------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m            arr = arr.take(index) ++ arr.drop(index +\
    \ \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            Reassignment to val arr\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659793382
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // You have to return a sorted list of length `k` with the maximum k\
    \ numbers in `arr`\n        arr.sorted.takeRight(k.toInt)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n\
    \    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong,\
    \ -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong,\
    \ -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong,\
    \ 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong,\
    \ 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong,\
    \ 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793385
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // You have to return a sorted list of length `k` with the maximum k\
    \ numbers in `arr`\n        // You can assume that `k` is less than or equal to\
    \ the length of `arr`\n        // You can assume that `k` is greater than 0\n\
    \        var result = List[Long]()\n        var max = arr.max\n        var min\
    \ = arr.min\n        var max_index = arr.indexOf(max)\n        var min_index =\
    \ arr.indexOf(min)\n        var max_count = 0\n        var min_count = 0\n   \
    \     var max_arr = arr.filter(x => x == max)\n        var min_arr = arr.filter(x\
    \ => x == min)\n        var max_arr_length = max_arr.length\n        var min_arr_length\
    \ = min_arr.length\n        if (k == 1) {\n            result = List(max)\n  \
    \      } else if (k == arr.length) {\n            result = arr.sorted\n      \
    \  } else if (k == max_arr_length) {\n            result = max_arr\n        }\
    \ else if (k == min_arr_length) {\n            result = min_arr\n        } else\
    \ if (k > max_arr_length) {\n            result = max_arr\n            var temp\
    \ = arr.filter(x => x != max)\n            var temp_length = temp.length\n   \
    \         var temp_max = temp.max\n            var temp_max_index = temp.indexOf(temp_max)\n\
    \            var temp_max_count = 0\n            var temp_max_arr = temp.filter(x\
    \ => x == temp_max)\n            var temp_max_arr_length = temp_max_arr.length\n\
    \            for (i <- 0 until temp_length) {\n                if (temp(i) ==\
    \ temp_max) {\n                    temp_max_count += 1\n                }\n  \
    \          }\n            if (temp_max_count == temp_length) {\n             \
    \   result = result ++ temp\n            } else {\n                result = result\
    \ ++ temp_max_arr\n                var temp2\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpihtdcsz3.scala:64:4 ----------------------------\e\
    [0m\e[0m\n\e[31m64 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpihtdcsz3.scala:80:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m80 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmpihtdcsz3.scala:38:19 --------------------\e[0m\e[0m\n\
    \e[31m38 |\e[0m            result = List(max)\n\e[31m\e[31m   |\e[0m         \
    \   ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Found:    Unit\n\e[31m\
    \   |\e[0m            Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpihtdcsz3.scala:40:19 --------------------\e[0m\e\
    [0m\n\e[31m40 |\e[0m            result = arr.sorted\n\e[31m\e[31m   |\e[0m   \
    \         ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Found:    Unit\n\
    \e[31m   |\e[0m            Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpihtdcsz3.scala:42:19 --------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m            result = max_arr\n\e[31m\e[31m   |\e[0m \
    \           ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Found:    Unit\n\
    \e[31m   |\e[0m            Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpihtdcsz3.scala:44:19 --------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m            result = min_arr\n\e[31m\e[31m   |\e[0m \
    \           ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Found:    Unit\n\
    \e[31m   |\e[0m            Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[33m\e[33m--\
    \ Warning: /tmp/tmpihtdcsz3.scala:65:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m65 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m"
  stdout: ''
  timestamp: 1659793385
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // 'return List[Long]()' in case of timeout\n        return List[Long]()\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0g1w71sl.scala:25)\n\tat Problem.main(tmp0g1w71sl.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793385
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // You have to return a sorted list of length `k` with the maximum k\
    \ numbers in `arr`\n        // You can assume that `k` is less than or equal to\
    \ the length of `arr`\n        // You can assume that `k` is greater than 0\n\
    \        arr.sortWith(_ > _).take(k.toInt)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpucwkl69k.scala:29)\n\tat Problem.main(tmpucwkl69k.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793374
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // We can use a max heap to\
    \ solve this problem.\n        // The max heap will keep track of the k largest\
    \ elements in the list.\n        // The max heap will be initialized with the\
    \ first k elements of the list.\n        // The max heap will be updated with\
    \ the remaining elements of the list.\n        // The max heap will be converted\
    \ to a list and returned.\n        // The time complexity is O(n log k) and the\
    \ space complexity is O(k).\n        val heap = new mutable.PriorityQueue[Long]()(Ordering.by(-_))\n\
    \        for (i <- 0 until k.toInt) {\n            heap.enqueue(arr(i))\n    \
    \    }\n        for (i <- k.toInt until arr.length) {\n            if (arr(i)\
    \ > heap.head) {\n                heap.dequeue\n                heap.enqueue(arr(i))\n\
    \            }\n        }\n        heap.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq102dua2.scala:26:23 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mheap\e[0m = \e[33mnew\e\
    [0m mutable.PriorityQueue[\e[35mLong\e[0m]()(Ordering.by(-_))\n\e[31m\e[31m  \
    \ |\e[0m                       ^^^^^^^\e[0m\n\e[31m   |\e[0m                 \
    \      Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpq102dua2.scala:26:65 ------------------------\e[0m\e[0m\n\e[31m26 |\e\
    [0m        \e[33mval\e[0m \e[36mheap\e[0m = \e[33mnew\e[0m mutable.PriorityQueue[\e\
    [35mLong\e[0m]()(Ordering.by(-_))\n\e[31m\e[31m   |\e[0m                     \
    \                                            ^^\e[0m\n\e[31m   |\e[0mvalue unary_-\
    \ is not a member of Any, but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress\
    \ towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- Error: /tmp/tmpq102dua2.scala:26:68 -----------------------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mheap\e[0m = \e[33mnew\e\
    [0m mutable.PriorityQueue[\e[35mLong\e[0m]()(Ordering.by(-_))\n\e[31m\e[31m  \
    \ |\e[0m                                                                    ^\e\
    [0m\n\e[31m   |\e[0mambiguous given instances: both \e[33mobject\e[0m \e[35mBigInt\e\
    [0m in \e[33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mInt\e\
    [0m in \e[33mobject\e[0m \e[35mOrdering\e[0m match type Ordering[S] of parameter\
    \ ord of \e[33mmethod\e[0m \e[35mby\e[0m in \e[33mobject\e[0m \e[35mOrdering\e\
    [0m\n3 errors found\n"
  stdout: ''
  timestamp: 1659793385
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        val heap = new PriorityQueue[Long]()(Ordering.by(-_))\n\
    \        for (i <- arr) {\n            heap.enqueue(i)\n            if (heap.size\
    \ > k) heap.dequeue\n        }\n        heap.toList.sorted\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n\
    \    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong,\
    \ -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong,\
    \ -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong,\
    \ 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong,\
    \ 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong,\
    \ 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793374
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // You have to return a sorted list of length `k` with the maximum k\
    \ numbers in `arr`\n        // You can assume that `k` is always valid, i.e. 1\
    \ <= k <= len(arr)\n        // You can assume that `arr` is always valid, i.e.\
    \ all the elements in `arr` are positive integers\n        // You can assume that\
    \ `arr` is sorted in non-decreasing order\n        // You can assume that `arr`\
    \ has no duplicates\n        // You can assume that `arr` has at least `k` elements\n\
    \        // You can assume that `k` is always valid, i.e. 1 <= k <= len(arr)\n\
    \        // You can assume that `arr` is always valid, i.e. all the elements in\
    \ `arr` are positive integers\n        // You can assume that `arr` is sorted\
    \ in non-decreasing order\n        // You can assume that `arr` has no duplicates\n\
    \        // You can assume that `arr` has at least `k` elements\n        // You\
    \ can assume that `k` is always valid, i.e. 1 <= k <= len(arr)\n        // You\
    \ can assume that `arr` is always valid, i.e. all the elements in `arr` are positive\
    \ integers\n        // You can assume that `arr` is sorted in non-decreasing order\n\
    \        // You can assume that `arr` has no duplicates\n        // You can assume\
    \ that `arr` has at least `k` elements\n        // You can assume that `k` is\
    \ always valid, i.e. 1 <= k <= len(arr)\n        // You can assume that `arr`\
    \ is always valid, i.e. all the elements in `arr` are positive integers\n    \
    \    // You can assume that `arr` is sorted in non-decreasing order\n        //\
    \ You can assume that `arr` has no duplicates\n        // You can assume that\
    \ `arr` has at least `k` elements\n        // You can assume that `k` is always\
    \ valid, i.e. 1 <= k <= len(arr)\n        // You can assume that `arr` is always\
    \ valid, i.e\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpct4pj1xu.scala:19:59\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m    \e[33mdef\e[0m \e[36mmaximum\e\
    [0m(\e[36marr\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mk\e[0m : \e[35mLong\e\
    [0m) : \e[35mList\e[0m[\e[35mLong\e[0m] = {\n\e[31m\e[31m   |\e[0m           \
    \                                                ^\e[0m\n\e[31m   |\e[0m     \
    \                                               Found:    Unit\n\e[31m   |\e[0m\
    \                                                    Required: List[Long]\n\e\
    [31m20 |\e[0m        \e[34m// Fill up this function body\e[0m\n\e[31m21 |\e[0m\
    \        \e[34m// `arr` is a list of integers\e[0m\n\e[31m22 |\e[0m        \e\
    [34m// `k` is a positive integer\e[0m\n\e[31m23 |\e[0m        \e[34m// You have\
    \ to return a sorted list of length `k` with the maximum k numbers in `arr`\e\
    [0m\n\e[31m24 |\e[0m        \e[34m// You can assume that `k` is always valid,\
    \ i.e. 1 <= k <= len(arr)\e[0m\n\e[31m25 |\e[0m        \e[34m// You can assume\
    \ that `arr` is always valid, i.e. all the elements in `arr` are positive integers\e\
    [0m\n\e[31m26 |\e[0m        \e[34m// You can assume that `arr` is sorted in non-decreasing\
    \ order\e[0m\n\e[31m27 |\e[0m        \e[34m// You can assume that `arr` has no\
    \ duplicates\e[0m\n\e[31m28 |\e[0m        \e[34m// You can assume that `arr` has\
    \ at least `k` elements\e[0m\n\e[31m29 |\e[0m        \e[34m// You can assume that\
    \ `k` is always valid, i.e. 1 <= k <= len(arr)\e[0m\n\e[31m30 |\e[0m        \e\
    [34m// You can assume that `arr` is always valid, i.e. all the elements in `arr`\
    \ are positive integers\e[0m\n\e[31m31 |\e[0m        \e[34m// You can assume that\
    \ `arr` is sorted in non-decreasing order\e[0m\n\e[31m32 |\e[0m        \e[34m//\
    \ You can assume that `arr` has no duplicates\e[0m\n\e[31m33 |\e[0m        \e\
    [34m// You can assume that `arr` has at least `k` elements\e[0m\n\e[31m34 |\e\
    [0m        \e[34m// You can assume that `k` is always valid, i.e. 1 <= k <= len(arr)\e\
    [0m\n\e[31m35 |\e[0m        \e[34m// You can assume that `arr` is always valid,\
    \ i.e. all the elements in `arr` are positive integers\e[0m\n\e[31m36 |\e[0m \
    \       \e[34m// You can assume that `arr` is "
  stdout: ''
  timestamp: 1659793384
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // We can use a max heap to\
    \ solve this problem.\n        // The max heap will be of size k.\n        //\
    \ We will iterate through the list and add each element to the heap.\n       \
    \ // If the heap is full, we will remove the largest element from the heap and\
    \ add the new element.\n        // This will ensure that the heap will always\
    \ contain the k largest elements.\n        // After we are done iterating through\
    \ the list, we will return the heap.\n        // The heap will be sorted in descending\
    \ order.\n        // Time complexity: O(n log k)\n        // Space complexity:\
    \ O(k)\n        val heap = new mutable.PriorityQueue[Long]()(Ordering.by(-_))\n\
    \        for (i <- arr) {\n            if (heap.size < k) heap.enqueue(i)\n  \
    \          else {\n                if (i > heap.head) {\n                    heap.dequeue\n\
    \                    heap.enqueue(i)\n                }\n            }\n     \
    \   }\n        heap.toList\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp69c_2een.scala:29:23 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mheap\e[0m = \e[33mnew\e\
    [0m mutable.PriorityQueue[\e[35mLong\e[0m]()(Ordering.by(-_))\n\e[31m\e[31m  \
    \ |\e[0m                       ^^^^^^^\e[0m\n\e[31m   |\e[0m                 \
    \      Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmp69c_2een.scala:29:65 ------------------------\e[0m\e[0m\n\e[31m29 |\e\
    [0m        \e[33mval\e[0m \e[36mheap\e[0m = \e[33mnew\e[0m mutable.PriorityQueue[\e\
    [35mLong\e[0m]()(Ordering.by(-_))\n\e[31m\e[31m   |\e[0m                     \
    \                                            ^^\e[0m\n\e[31m   |\e[0mvalue unary_-\
    \ is not a member of Any, but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress\
    \ towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- Error: /tmp/tmp69c_2een.scala:29:68 -----------------------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mheap\e[0m = \e[33mnew\e\
    [0m mutable.PriorityQueue[\e[35mLong\e[0m]()(Ordering.by(-_))\n\e[31m\e[31m  \
    \ |\e[0m                                                                    ^\e\
    [0m\n\e[31m   |\e[0mambiguous given instances: both \e[33mobject\e[0m \e[35mInt\e\
    [0m in \e[33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mChar\e\
    [0m in \e[33mobject\e[0m \e[35mOrdering\e[0m match type Ordering[S] of parameter\
    \ ord of \e[33mmethod\e[0m \e[35mby\e[0m in \e[33mobject\e[0m \e[35mOrdering\e\
    [0m\n3 errors found\n"
  stdout: ''
  timestamp: 1659793386
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // We can use a max heap to\
    \ solve this problem.\n        // We can also use a min heap to solve this problem.\n\
    \        // We can also use a sorted array to solve this problem.\n        //\
    \ We can also use a sorted linked list to solve this problem.\n        // We can\
    \ also use a sorted binary search tree to solve this problem.\n        // We can\
    \ also use a sorted hash table to solve this problem.\n        // We can also\
    \ use a sorted skip list to solve this problem.\n        // We can also use a\
    \ sorted array list to solve this problem.\n        // We can also use a sorted\
    \ linked list to solve this problem.\n        // We can also use a sorted binary\
    \ search tree to solve this problem.\n        // We can also use a sorted hash\
    \ table to solve this problem.\n        // We can also use a sorted skip list\
    \ to solve this problem.\n        // We can also use a sorted array list to solve\
    \ this problem.\n        // We can also use a sorted linked list to solve this\
    \ problem.\n        // We can also use a sorted binary search tree to solve this\
    \ problem.\n        // We can also use a sorted hash table to solve this problem.\n\
    \        // We can also use a sorted skip list to solve this problem.\n      \
    \  // We can also use a sorted array list to solve this problem.\n        // We\
    \ can also use a sorted linked list to solve this problem.\n        // We can\
    \ also use a sorted binary search tree to solve this problem.\n        // We can\
    \ also use a sorted hash table to solve this problem.\n        // We can also\
    \ use a sorted skip list to solve this problem.\n        // We can also use a\
    \ sorted array list to solve this problem.\n        // We can also use a sorted\
    \ linked list to solve this problem.\n        // We can also use a sorted binary\
    \ search tree to solve this problem.\n        // We can also use a sorted hash\
    \ table to solve this problem.\n        // We can also use a sorted skip list\
    \ to solve this problem.\n        // We can also use a sorted array list to solve\
    \ this problem.\n        // We can also use a sorted linked list to solve this\
    \ problem.\n        // We can also use a sorted binary search tree to solve this\
    \ problem.\n        // We can also use a sorted hash table to solve this problem.\n\
    \        // We can also use a sorted skip list to solve this\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n\
    \    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong,\
    \ -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong,\
    \ -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong,\
    \ 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong,\
    \ 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong,\
    \ 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmptuerzt1o.scala:19:59\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m    \e[33mdef\e[0m \e[36mmaximum\e\
    [0m(\e[36marr\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mk\e[0m : \e[35mLong\e\
    [0m) : \e[35mList\e[0m[\e[35mLong\e[0m] = {\n\e[31m\e[31m   |\e[0m           \
    \                                                ^\e[0m\n\e[31m   |\e[0m     \
    \                                               Found:    Unit\n\e[31m   |\e[0m\
    \                                                    Required: List[Long]\n\e\
    [31m20 |\e[0m        \e[34m// We can use a max heap to solve this problem.\e[0m\n\
    \e[31m21 |\e[0m        \e[34m// We can also use a min heap to solve this problem.\e\
    [0m\n\e[31m22 |\e[0m        \e[34m// We can also use a sorted array to solve this\
    \ problem.\e[0m\n\e[31m23 |\e[0m        \e[34m// We can also use a sorted linked\
    \ list to solve this problem.\e[0m\n\e[31m24 |\e[0m        \e[34m// We can also\
    \ use a sorted binary search tree to solve this problem.\e[0m\n\e[31m25 |\e[0m\
    \        \e[34m// We can also use a sorted hash table to solve this problem.\e\
    [0m\n\e[31m26 |\e[0m        \e[34m// We can also use a sorted skip list to solve\
    \ this problem.\e[0m\n\e[31m27 |\e[0m        \e[34m// We can also use a sorted\
    \ array list to solve this problem.\e[0m\n\e[31m28 |\e[0m        \e[34m// We can\
    \ also use a sorted linked list to solve this problem.\e[0m\n\e[31m29 |\e[0m \
    \       \e[34m// We can also use a sorted binary search tree to solve this problem.\e\
    [0m\n\e[31m30 |\e[0m        \e[34m// We can also use a sorted hash table to solve\
    \ this problem.\e[0m\n\e[31m31 |\e[0m        \e[34m// We can also use a sorted\
    \ skip list to solve this problem.\e[0m\n\e[31m32 |\e[0m        \e[34m// We can\
    \ also use a sorted array list to solve this problem.\e[0m\n\e[31m33 |\e[0m  \
    \      \e[34m// We can also use a sorted linked list to solve this problem.\e\
    [0m\n\e[31m34 |\e[0m        \e[34m// We can also use a sorted binary search tree\
    \ to solve this problem.\e[0m\n\e[31m35 |\e[0m        \e[34m// We can also use\
    \ a sorted hash table to solve this problem.\e[0m\n\e[31m36 |\e[0m        \e[34m//\
    \ We can also use a sorted skip list to solve thi"
  stdout: ''
  timestamp: 1659793385
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // You have to return a sorted list of length `k` with the maximum k\
    \ numbers in `arr`\n        // You can assume that `k` is less than or equal to\
    \ the length of `arr`\n        // You can assume that `k` is greater than 0\n\
    \        var res = new ListBuffer[Long]()\n        var max = new ListBuffer[Long]()\n\
    \        for (i <- 0 until arr.length) {\n            if (res.length < k) {\n\
    \                res += arr(i)\n                max += arr(i)\n            } else\
    \ {\n                var min = max.min\n                if (arr(i) > min) {\n\
    \                    res -= min\n                    res += arr(i)\n         \
    \           max -= min\n                    max += arr(i)\n                }\n\
    \            }\n        }\n        res.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpr7idtq21.scala:45)\n\tat Problem.main(tmpr7idtq21.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793386
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // Return a sorted list of length `k` with the maximum `k` numbers in\
    \ `arr`\n        var result = ListBuffer[Long]()\n        var sorted = arr.sorted\n\
    \        var i = 0\n        while (i < k) {\n            result += sorted(sorted.length\
    \ - i - 1)\n            i += 1\n        }\n        result.toList\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong,\
    \ 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpcw7ji7td.scala:34)\n\tat Problem.main(tmpcw7ji7td.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793386
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // You have to return a sorted list of length `k` with the maximum k\
    \ numbers in `arr`\n        // You can assume that `k` is less than or equal to\
    \ the length of `arr`\n        // You can assume that `k` is greater than 0\n\
    \        // You can assume that `arr` is not empty\n        // You can assume\
    \ that `arr` does not contain duplicates\n        // You can assume that `arr`\
    \ is sorted in non-decreasing order\n        // You can assume that `arr` contains\
    \ only positive integers\n        // You can assume that `arr` contains only integers\n\
    \        // You can assume that `arr` contains only integers in the range [-1000,\
    \ 1000]\n        // You can assume that `arr` contains only integers in the range\
    \ [-1000, 1000]\n        // You can assume that `arr` contains only integers in\
    \ the range [-1000, 1000]\n        // You can assume that `arr` contains only\
    \ integers in the range [-1000, 1000]\n        // You can assume that `arr` contains\
    \ only integers in the range [-1000, 1000]\n        // You can assume that `arr`\
    \ contains only integers in the range [-1000, 1000]\n        // You can assume\
    \ that `arr` contains only integers in the range [-1000, 1000]\n        // You\
    \ can assume that `arr` contains only integers in the range [-1000, 1000]\n  \
    \      // You can assume that `arr` contains only integers in the range [-1000,\
    \ 1000]\n        // You can assume that `arr` contains only integers in the range\
    \ [-1000, 1000]\n        // You can assume that `arr` contains only integers in\
    \ the range [-1000, 1000]\n        // You can assume that `arr` contains only\
    \ integers in the range [-1000, 1000]\n        // You can assume that `arr` contains\
    \ only integers in the range [-1000, 1000]\n        // You can assume that `arr`\
    \ contains only integers in the range [-1000, 1000]\n        // You can assume\
    \ that `arr` contains only integers in the range [-1000, 1000]\n        // You\
    \ can assume that `arr` contains only integers in the range [-1000, 1000]\n  \
    \      // You can assume that `arr` contains only integers\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n\
    \    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong,\
    \ -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong,\
    \ -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong,\
    \ 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong,\
    \ 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong,\
    \ 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp8__rjomd.scala:19:59\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m    \e[33mdef\e[0m \e[36mmaximum\e\
    [0m(\e[36marr\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mk\e[0m : \e[35mLong\e\
    [0m) : \e[35mList\e[0m[\e[35mLong\e[0m] = {\n\e[31m\e[31m   |\e[0m           \
    \                                                ^\e[0m\n\e[31m   |\e[0m     \
    \                                               Found:    Unit\n\e[31m   |\e[0m\
    \                                                    Required: List[Long]\n\e\
    [31m20 |\e[0m        \e[34m// Fill up this function body\e[0m\n\e[31m21 |\e[0m\
    \        \e[34m// `arr` is a list of integers\e[0m\n\e[31m22 |\e[0m        \e\
    [34m// `k` is a positive integer\e[0m\n\e[31m23 |\e[0m        \e[34m// You have\
    \ to return a sorted list of length `k` with the maximum k numbers in `arr`\e\
    [0m\n\e[31m24 |\e[0m        \e[34m// You can assume that `k` is less than or equal\
    \ to the length of `arr`\e[0m\n\e[31m25 |\e[0m        \e[34m// You can assume\
    \ that `k` is greater than 0\e[0m\n\e[31m26 |\e[0m        \e[34m// You can assume\
    \ that `arr` is not empty\e[0m\n\e[31m27 |\e[0m        \e[34m// You can assume\
    \ that `arr` does not contain duplicates\e[0m\n\e[31m28 |\e[0m        \e[34m//\
    \ You can assume that `arr` is sorted in non-decreasing order\e[0m\n\e[31m29 |\e\
    [0m        \e[34m// You can assume that `arr` contains only positive integers\e\
    [0m\n\e[31m30 |\e[0m        \e[34m// You can assume that `arr` contains only integers\e\
    [0m\n\e[31m31 |\e[0m        \e[34m// You can assume that `arr` contains only integers\
    \ in the range [-1000, 1000]\e[0m\n\e[31m32 |\e[0m        \e[34m// You can assume\
    \ that `arr` contains only integers in the range [-1000, 1000]\e[0m\n\e[31m33\
    \ |\e[0m        \e[34m// You can assume that `arr` contains only integers in the\
    \ range [-1000, 1000]\e[0m\n\e[31m34 |\e[0m        \e[34m// You can assume that\
    \ `arr` contains only integers in the range [-1000, 1000]\e[0m\n\e[31m35 |\e[0m\
    \        \e[34m// You can assume that `arr` contains only integers in the range\
    \ [-1000, 1000]\e[0m\n\e[31m36 |\e[0m        \e[34m// You can assume that `arr`\
    \ contains only integers in the range [-1000, 100"
  stdout: ''
  timestamp: 1659793385
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // We can use a min heap to\
    \ solve this problem.\n        // The idea is to keep the heap size at k and always\n\
    \        // keep the minimum element in the heap.\n        // Then, the elements\
    \ in the heap will be the k largest\n        // elements in the array.\n     \
    \   // Time complexity: O(nlogk)\n        // Space complexity: O(k)\n        val\
    \ heap = new PriorityQueue[Long]()(Ordering.by(-_))\n        for (i <- arr) {\n\
    \            heap.enqueue(i)\n            if (heap.size > k) heap.dequeue\n  \
    \      }\n        heap.toList.sorted\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793386
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // `k` is the number of elements you need to return.\n        // `arr`\
    \ is the list of integers.\n        // Return a list of integers.\n        arr.sorted.takeRight(k.toInt)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793386
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // `k` is the length of the output list\n        // `arr` is the list\
    \ of integers\n        // You have to return the maximum k numbers in the list\n\
    \        arr.sortWith(_ > _).take(k.toInt)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0lsp86vt.scala:27)\n\tat Problem.main(tmp0lsp86vt.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793386
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // You have to return a sorted list of length `k` with the maximum k\
    \ numbers in `arr`\n        // You can assume that `k` is less than or equal to\
    \ the length of `arr`\n        // You can assume that `k` is greater than 0\n\
    \        val n = arr.length\n        val m = min(k, n)\n        val heap = new\
    \ PriorityQueue[Long]()(Ordering.by(-_))\n        for (i <- 0 until m) heap.enqueue(arr(i))\n\
    \        for (i <- m until n) {\n            val x = heap.dequeue\n          \
    \  if (arr(i) > x) heap.enqueue(arr(i))\n            else heap.enqueue(x)\n  \
    \      }\n        heap.dequeueAll.toList.sorted\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmprm66q735.scala:29:26\
    \ --------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mfor\e[0m (i <-\
    \ \e[31m0\e[0m until m) heap.enqueue(arr(i))\n\e[31m\e[31m   |\e[0m          \
    \                ^\e[0m\n\e[31m   |\e[0m                          Found:    (m\
    \ : Long)\n\e[31m   |\e[0m                          Required: Int\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmprm66q735.scala:32:20 --------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m            \e[33mif\e[0m (arr(i) > x) heap.enqueue(arr(i))\n\
    \e[31m\e[31m   |\e[0m                    ^\e[0m\n\e[31m   |\e[0m             \
    \       Found:    (i : Long)\n\e[31m   |\e[0m                    Required: Int\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmprm66q735.scala:32:45\
    \ --------------------\e[0m\e[0m\n\e[31m32 |\e[0m            \e[33mif\e[0m (arr(i)\
    \ > x) heap.enqueue(arr(i))\n\e[31m\e[31m   |\e[0m                           \
    \                  ^\e[0m\n\e[31m   |\e[0m                                   \
    \          Found:    (i : Long)\n\e[31m   |\e[0m                             \
    \                Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659793386
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // 'return List[Long]()' in case of timeout or internal error\n     \
    \   return List[Long]()\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4stnr6t2.scala:25)\n\tat Problem.main(tmp4stnr6t2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793379
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // You have to return a sorted list of length `k` with the maximum k\
    \ numbers in `arr`\n        // You can assume that `k` is less than or equal to\
    \ the length of `arr`\n        // You can assume that `k` is greater than 0\n\
    \        arr.sortWith(_ > _).take(k.toInt)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpucwkl69k.scala:29)\n\tat Problem.main(tmpucwkl69k.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793374
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // You have to return a sorted list of length `k` with the maximum k\
    \ numbers in `arr`\n        // You can assume that `k` is less than or equal to\
    \ the length of `arr`\n        // You can assume that `k` is greater than 0\n\
    \        // You can assume that `arr` is not empty\n        // You can assume\
    \ that `arr` is not null\n        // You can assume that `arr` does not contain\
    \ null elements\n        // You can assume that `arr` does not contain duplicate\
    \ elements\n        // You can assume that `arr` is sorted in non-decreasing order\n\
    \        // You can assume that `arr` is sorted in non-increasing order\n    \
    \    // You can assume that `arr` is sorted in increasing order\n        // You\
    \ can assume that `arr` is sorted in decreasing order\n        // You can assume\
    \ that `arr` is sorted in ascending order\n        // You can assume that `arr`\
    \ is sorted in descending order\n        // You can assume that `arr` is sorted\
    \ in non-ascending order\n        // You can assume that `arr` is sorted in non-descending\
    \ order\n        // You can assume that `arr` is sorted in non-increasing order\n\
    \        // You can assume that `arr` is sorted in non-decreasing order\n    \
    \    // You can assume that `arr` is sorted in non-decreasing order\n        //\
    \ You can assume that `arr` is sorted in non-decreasing order\n        // You\
    \ can assume that `arr` is sorted in non-decreasing order\n        // You can\
    \ assume that `arr` is sorted in non-decreasing order\n        // You can assume\
    \ that `arr` is sorted in non-decreasing order\n        // You can assume that\
    \ `arr` is sorted in non-decreasing order\n        // You can assume that `arr`\
    \ is sorted in non-decreasing order\n        // You can assume that `arr` is sorted\
    \ in non-decreasing order\n        // You can assume that `arr` is sorted in non-decreasing\
    \ order\n        // You can assume that `arr` is sorted in non-decreasing order\n\
    \        // You can assume that `arr\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp1gyjonzp.scala:19:59\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m    \e[33mdef\e[0m \e[36mmaximum\e\
    [0m(\e[36marr\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mk\e[0m : \e[35mLong\e\
    [0m) : \e[35mList\e[0m[\e[35mLong\e[0m] = {\n\e[31m\e[31m   |\e[0m           \
    \                                                ^\e[0m\n\e[31m   |\e[0m     \
    \                                               Found:    Unit\n\e[31m   |\e[0m\
    \                                                    Required: List[Long]\n\e\
    [31m20 |\e[0m        \e[34m// Fill up this function body\e[0m\n\e[31m21 |\e[0m\
    \        \e[34m// `arr` is a list of integers\e[0m\n\e[31m22 |\e[0m        \e\
    [34m// `k` is a positive integer\e[0m\n\e[31m23 |\e[0m        \e[34m// You have\
    \ to return a sorted list of length `k` with the maximum k numbers in `arr`\e\
    [0m\n\e[31m24 |\e[0m        \e[34m// You can assume that `k` is less than or equal\
    \ to the length of `arr`\e[0m\n\e[31m25 |\e[0m        \e[34m// You can assume\
    \ that `k` is greater than 0\e[0m\n\e[31m26 |\e[0m        \e[34m// You can assume\
    \ that `arr` is not empty\e[0m\n\e[31m27 |\e[0m        \e[34m// You can assume\
    \ that `arr` is not null\e[0m\n\e[31m28 |\e[0m        \e[34m// You can assume\
    \ that `arr` does not contain null elements\e[0m\n\e[31m29 |\e[0m        \e[34m//\
    \ You can assume that `arr` does not contain duplicate elements\e[0m\n\e[31m30\
    \ |\e[0m        \e[34m// You can assume that `arr` is sorted in non-decreasing\
    \ order\e[0m\n\e[31m31 |\e[0m        \e[34m// You can assume that `arr` is sorted\
    \ in non-increasing order\e[0m\n\e[31m32 |\e[0m        \e[34m// You can assume\
    \ that `arr` is sorted in increasing order\e[0m\n\e[31m33 |\e[0m        \e[34m//\
    \ You can assume that `arr` is sorted in decreasing order\e[0m\n\e[31m34 |\e[0m\
    \        \e[34m// You can assume that `arr` is sorted in ascending order\e[0m\n\
    \e[31m35 |\e[0m        \e[34m// You can assume that `arr` is sorted in descending\
    \ order\e[0m\n\e[31m36 |\e[0m        \e[34m// You can assume that `arr` is sorted\
    \ in non-ascending order\e[0m\n\e[31m37 |\e[0m        \e[34m// You can assume\
    \ that `arr` is sorted in non-descending order\e[0m\n\e[31m38 |\e[0m     "
  stdout: ''
  timestamp: 1659793386
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Given a list arr of integers\
    \ and a positive integer k, return a sorted list \n        // of length k with\
    \ the maximum k numbers in arr.\n        // Example 1:\n        // >>> maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l))\n        // (List[Long](-4l.toLong, -3l.toLong,\
    \ 5l.toLong))\n        // Example 2:\n        // >>> maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l))\n        // (List[Long](4l.toLong, 4l.toLong))\n\
    \        // Example 3:\n        // >>> maximum((List[Long](-3l.toLong, 2l.toLong,\
    \ 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n        //\
    \ (List[Long](2l.toLong))\n        // Note:\n        // 1. The length of the list\
    \ will be in the range of [1, 1000].\n        // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n        // 3. 0 <= k <= len(arr)\n      \
    \  val sorted = arr.sorted\n        sorted.takeRight(k.toInt)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong,\
    \ 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793386
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Given a list arr of integers\
    \ and a positive integer k, return a sorted list \n        // of length k with\
    \ the maximum k numbers in arr.\n        // Example 1:\n        // >>> maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l))\n        // (List[Long](-4l.toLong, -3l.toLong,\
    \ 5l.toLong))\n        // Example 2:\n        // >>> maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l))\n        // (List[Long](4l.toLong, 4l.toLong))\n\
    \        // Example 3:\n        // >>> maximum((List[Long](-3l.toLong, 2l.toLong,\
    \ 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n        //\
    \ (List[Long](2l.toLong))\n        // Note:\n        // 1. The length of the list\
    \ will be in the range of [1, 1000].\n        // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n        // 3. 0 <= k <= len(arr)\n      \
    \  def maximum0(arr : List[Long], k : Long, acc : List[Long]) : List[Long] = {\n\
    \            if (k == 0l) {\n                acc\n            } else {\n     \
    \           val (max, index) = arr.zipWithIndex.maxBy(_._1)\n                maximum0(arr.patch(index,\
    \ Nil, 1), k - 1l, acc :+ max)\n            }\n        }\n        maximum0(arr,\
    \ k, List[Long]())\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpqw9wkqhs.scala:46)\n\tat Problem.main(tmpqw9wkqhs.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793387
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        val heap = new PriorityQueue[Long]()(Ordering.by(-_))\n\
    \        for (i <- arr) {\n            heap.enqueue(i)\n            if (heap.size\
    \ > k) heap.dequeue\n        }\n        heap.toList.sorted\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n\
    \    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong,\
    \ -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong,\
    \ -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong,\
    \ 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong,\
    \ 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong,\
    \ 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793374
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // 'return List[Long]()' in case of timeout or other failure\n      \
    \  return List[Long]()\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpko6m9p8u.scala:25)\n\tat Problem.main(tmpko6m9p8u.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793380
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // 'arr' is a list of integers\n        // 'k' is a positive integer\n\
    \        // Return a sorted list of length 'k' with the maximum 'k' numbers in\
    \ 'arr'\n        arr.sorted.takeRight(k.toInt)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793374
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // We can use a priority queue\
    \ to solve this problem.\n        // The priority queue will be sorted in descending\
    \ order.\n        // We will add the first k elements of the list to the priority\
    \ queue.\n        // Then we will iterate through the rest of the list.\n    \
    \    // If the element is greater than the minimum element in the priority queue,\n\
    \        // we will remove the minimum element and add the new element.\n    \
    \    // We will repeat this process until we have iterated through the entire\
    \ list.\n        // Then we will return the priority queue.\n        val pq =\
    \ new PriorityQueue[Long]()(Ordering.Long.reverse)\n        for (i <- 0l until\
    \ k) {\n            pq.enqueue(arr(i.toInt))\n        }\n        for (i <- k until\
    \ arr.length) {\n            if (arr(i.toInt) > pq.head) {\n                pq.dequeue\n\
    \                pq.enqueue(arr(i.toInt))\n            }\n        }\n        pq.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptjbzlp7v.scala:44)\n\tat Problem.main(tmptjbzlp7v.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793387
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // 'return List[Long]()' for Scala and 'return new ArrayList<Long>()'\
    \ for Java\n        return List[Long]()\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7g5a4ppi.scala:25)\n\tat Problem.main(tmp7g5a4ppi.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793379
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // `k` is the length of the output list\n        // `arr` is the input\
    \ list\n        // return a sorted list of length `k` with the maximum k numbers\
    \ in `arr`\n        arr.sortWith(_ > _).take(k.toInt)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n\
    \    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong,\
    \ -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong,\
    \ -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong,\
    \ 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong,\
    \ 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong,\
    \ 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp20f4impa.scala:27)\n\tat Problem.main(tmp20f4impa.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793389
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // We can use a heap to solve\
    \ this problem.\n        // The heap will store the k largest elements.\n    \
    \    // If the heap is full and the next element is larger than the smallest element\
    \ in the heap,\n        // then we remove the smallest element and add the new\
    \ element.\n        // If the heap is not full, then we just add the new element.\n\
    \        // After we have iterated through the list, we return the heap.\n   \
    \     val heap = new PriorityQueue[Long]()(Ordering.by(-_))\n        for (element\
    \ <- arr) {\n            if (heap.size < k) heap.enqueue(element)\n          \
    \  else if (element > heap.head) {\n                heap.dequeue\n           \
    \     heap.enqueue(element)\n            }\n        }\n        heap.toList\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxao3boxy.scala:40)\n\tat Problem.main(tmpxao3boxy.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793389
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // You have to return a sorted list of length `k` with the maximum k\
    \ numbers in `arr`\n        // You can assume that `k` is less than or equal to\
    \ the length of `arr`\n        // You can assume that `k` is greater than 0\n\
    \        // You can assume that `arr` is not empty\n        // You can assume\
    \ that `arr` is not null\n        // You can assume that `arr` does not contain\
    \ null elements\n        // You can assume that `arr` does not contain duplicate\
    \ elements\n        // You can assume that `arr` is sorted in non-decreasing order\n\
    \        // You can assume that `arr` is sorted in non-increasing order\n    \
    \    // You can assume that `arr` is sorted in increasing order\n        // You\
    \ can assume that `arr` is sorted in decreasing order\n        // You can assume\
    \ that `arr` is sorted in ascending order\n        // You can assume that `arr`\
    \ is sorted in descending order\n        // You can assume that `arr` is sorted\
    \ in non-ascending order\n        // You can assume that `arr` is sorted in non-descending\
    \ order\n        // You can assume that `arr` is sorted in non-increasing order\n\
    \        // You can assume that `arr` is sorted in non-decreasing order\n    \
    \    // You can assume that `arr` is sorted in increasing order\n        // You\
    \ can assume that `arr` is sorted in decreasing order\n        // You can assume\
    \ that `arr` is sorted in ascending order\n        // You can assume that `arr`\
    \ is sorted in descending order\n        // You can assume that `arr` is sorted\
    \ in non-ascending order\n        // You can assume that `arr` is sorted in non-descending\
    \ order\n        // You can assume that `arr` is sorted in non-increasing order\n\
    \        // You can assume that `arr` is sorted in non-decreasing order\n    \
    \    // You can assume that `arr` is sorted in increasing order\n        // You\
    \ can assume that `arr` is sorted in decreasing order\n        // You can assume\
    \ that `arr` is sorted in ascending order\n        // You can assume that `arr`\
    \ is sorted in descending order\n        // You can assume that\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong,\
    \ 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpr9886pry.scala:19:59\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m    \e[33mdef\e[0m \e[36mmaximum\e\
    [0m(\e[36marr\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mk\e[0m : \e[35mLong\e\
    [0m) : \e[35mList\e[0m[\e[35mLong\e[0m] = {\n\e[31m\e[31m   |\e[0m           \
    \                                                ^\e[0m\n\e[31m   |\e[0m     \
    \                                               Found:    Unit\n\e[31m   |\e[0m\
    \                                                    Required: List[Long]\n\e\
    [31m20 |\e[0m        \e[34m// Fill up this function body\e[0m\n\e[31m21 |\e[0m\
    \        \e[34m// `arr` is a list of integers\e[0m\n\e[31m22 |\e[0m        \e\
    [34m// `k` is a positive integer\e[0m\n\e[31m23 |\e[0m        \e[34m// You have\
    \ to return a sorted list of length `k` with the maximum k numbers in `arr`\e\
    [0m\n\e[31m24 |\e[0m        \e[34m// You can assume that `k` is less than or equal\
    \ to the length of `arr`\e[0m\n\e[31m25 |\e[0m        \e[34m// You can assume\
    \ that `k` is greater than 0\e[0m\n\e[31m26 |\e[0m        \e[34m// You can assume\
    \ that `arr` is not empty\e[0m\n\e[31m27 |\e[0m        \e[34m// You can assume\
    \ that `arr` is not null\e[0m\n\e[31m28 |\e[0m        \e[34m// You can assume\
    \ that `arr` does not contain null elements\e[0m\n\e[31m29 |\e[0m        \e[34m//\
    \ You can assume that `arr` does not contain duplicate elements\e[0m\n\e[31m30\
    \ |\e[0m        \e[34m// You can assume that `arr` is sorted in non-decreasing\
    \ order\e[0m\n\e[31m31 |\e[0m        \e[34m// You can assume that `arr` is sorted\
    \ in non-increasing order\e[0m\n\e[31m32 |\e[0m        \e[34m// You can assume\
    \ that `arr` is sorted in increasing order\e[0m\n\e[31m33 |\e[0m        \e[34m//\
    \ You can assume that `arr` is sorted in decreasing order\e[0m\n\e[31m34 |\e[0m\
    \        \e[34m// You can assume that `arr` is sorted in ascending order\e[0m\n\
    \e[31m35 |\e[0m        \e[34m// You can assume that `arr` is sorted in descending\
    \ order\e[0m\n\e[31m36 |\e[0m        \e[34m// You can assume that `arr` is sorted\
    \ in non-ascending order\e[0m\n\e[31m37 |\e[0m        \e[34m// You can assume\
    \ that `arr` is sorted in non-descending order\e[0m\n\e[31m38 |\e[0m     "
  stdout: ''
  timestamp: 1659793389
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // 'return List[Long]()' in case of timeout or other abnormal termination\
    \ during test\n        return List[Long]()\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5u386b1u.scala:25)\n\tat Problem.main(tmp5u386b1u.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793389
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        val heap = new PriorityQueue[Long]()(Ordering.by(-_))\n\
    \        for (i <- arr) {\n            heap.enqueue(i)\n            if (heap.size\
    \ > k) heap.dequeue\n        }\n        heap.toList.sorted\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n\
    \    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong,\
    \ -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong,\
    \ -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong,\
    \ 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong,\
    \ 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong,\
    \ 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793374
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // You have to return a sorted list of length `k` with the maximum k\
    \ numbers in `arr`\n        arr.sorted.takeRight(k.toInt)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n\
    \    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong,\
    \ -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong,\
    \ -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong,\
    \ 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong,\
    \ 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong,\
    \ 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793385
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // You have to return a sorted list of length `k` with the maximum k\
    \ numbers in `arr`\n        // You can assume that `k` is less than or equal to\
    \ the length of `arr`\n        // You can assume that `k` is greater than 0\n\
    \        arr.sorted.takeRight(k.toInt)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793374
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // You have to return a sorted list of length `k` with the maximum k\
    \ numbers in `arr`\n        val sorted = arr.sorted\n        val len = arr.length\n\
    \        val result = new ListBuffer[Long]()\n        for (i <- len - k.toInt\
    \ to len - 1) {\n            result += sorted(i)\n        }\n        result.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793390
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Given a list arr of integers\
    \ and a positive integer k, return a sorted list \n        // of length k with\
    \ the maximum k numbers in arr.\n        // Example 1:\n        // >>> maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l))\n        // (List[Long](-4l.toLong, -3l.toLong,\
    \ 5l.toLong))\n        // Example 2:\n        // >>> maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l))\n        // (List[Long](4l.toLong, 4l.toLong))\n\
    \        // Example 3:\n        // >>> maximum((List[Long](-3l.toLong, 2l.toLong,\
    \ 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n        //\
    \ (List[Long](2l.toLong))\n        // Note:\n        // 1. The length of the list\
    \ will be in the range of [1, 1000].\n        // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n        // 3. 0 <= k <= len(arr)\n      \
    \  def maximum(arr : List[Long], k : Long) : List[Long] = {\n            // Given\
    \ a list arr of integers and a positive integer k, return a sorted list \n   \
    \         // of length k with the maximum k numbers in arr.\n            // Example\
    \ 1:\n            // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n            // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    \
    \        // Example 2:\n            // >>> maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l))\n            // (List[Long](4l.toLong, 4l.toLong))\n    \
    \        // Example 3:\n            // >>> maximum((List[Long](-3l.toLong, 2l.toLong,\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp81eyir6w.scala:62:0 ----------------------------\e\
    [0m\e[0m\n\e[31m62 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp81eyir6w.scala:35:63\
    \ --------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mdef\e[0m \e[36mmaximum\e\
    [0m(\e[36marr\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mk\e[0m : \e[35mLong\e\
    [0m) : \e[35mList\e[0m[\e[35mLong\e[0m] = {\n\e[31m\e[31m   |\e[0m           \
    \                                                    ^\e[0m\n\e[31m   |\e[0m \
    \                                                   Found:    Unit\n\e[31m   |\e\
    [0m                                                    Required: List[Long]\n\e\
    [31m36 |\e[0m            \e[34m// Given a list arr of integers and a positive\
    \ integer k, return a sorted list \e[0m\n\e[31m37 |\e[0m            \e[34m// of\
    \ length k with the maximum k numbers in arr.\e[0m\n\e[31m38 |\e[0m          \
    \  \e[34m// Example 1:\e[0m\n\e[31m39 |\e[0m            \e[34m// >>> maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l))\e[0m\n\e[31m40 |\e[0m            \e[34m// (List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))\e[0m\n\e[31m41 |\e[0m            \e[34m// Example 2:\e\
    [0m\n\e[31m42 |\e[0m            \e[34m// >>> maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l))\e[0m\n\e[31m43 |\e[0m            \e[34m// (List[Long](4l.toLong,\
    \ 4l.toLong))\e[0m\n\e[31m44 |\e[0m            \e[34m// Example 3:\e[0m\n\e[31m45\
    \ |\e[0m            \e[34m// >>> maximum((List[Long](-3l.toLong, 2l.toLong,\e\
    [0m\n\e[31m46 |\e[0m    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp81eyir6w.scala:61:1 ---------------------\e[0m\e[0m\n\e[31m61\
    \ |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:    Unit\n\e[31m\
    \   |\e[0m Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[33m\e[33m-- Warning: /tmp/tmp81eyir6w.scala:47:4\
    \ ----------------------------------------\e[0m\e[0m\n\e[33m47 |\e[0m    \e[33mdef\e\
    [0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e[0"
  stdout: ''
  timestamp: 1659793390
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Define the maximum function\
    \ as a recursive function\n        def maximum(arr : List[Long], k : Long, result\
    \ : List[Long]) : List[Long] = {\n            // If the list is empty, return\
    \ the result\n            if (arr.isEmpty) result\n            // If the list\
    \ is not empty, call the maximum function recursively\n            else {\n  \
    \              // If the result is empty, call the maximum function recursively\n\
    \                if (result.isEmpty) maximum(arr.tail, k, List(arr.head))\n  \
    \              // If the result is not empty, call the maximum function recursively\n\
    \                else {\n                    // If the head of the list is less\
    \ than the last element of the result, call the maximum function recursively\n\
    \                    if (arr.head < result.last) maximum(arr.tail, k, result)\n\
    \                    // If the head of the list is greater than or equal to the\
    \ last element of the result, call the maximum function recursively\n        \
    \            else {\n                        // If the length of the result is\
    \ less than k, call the maximum function recursively\n                       \
    \ if (result.length < k.toInt) maximum(arr.tail, k, result :+ arr.head)\n    \
    \                    // If the length of the result is greater than or equal to\
    \ k, call the maximum function recursively\n                        else maximum(arr.tail,\
    \ k, result.init :+ arr.head)\n                    }\n                }\n    \
    \        }\n        }\n        // Return the result of the maximum function\n\
    \        maximum(arr, k, List())\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_za9klft.scala:46)\n\tat Problem.main(tmp_za9klft.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793391
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // We can use a max heap to\
    \ solve this problem.\n        // First, we insert the first k elements into the\
    \ heap.\n        // Then, we iterate through the rest of the elements.\n     \
    \   // If the current element is greater than the root of the heap,\n        //\
    \ we remove the root and insert the current element.\n        // Finally, we return\
    \ the heap.\n        val heap = new PriorityQueue[Long]()(Ordering.by(-_))\n \
    \       for (i <- 0 until k.toInt) heap.enqueue(arr(i))\n        for (i <- k.toInt\
    \ until arr.length) {\n            if (arr(i) > heap.head) {\n               \
    \ heap.dequeue\n                heap.enqueue(arr(i))\n            }\n        }\n\
    \        heap.toList\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnryoxmq6.scala:40)\n\tat Problem.main(tmpnryoxmq6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793391
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        var result : List[Long] =\
    \ List[Long]()\n        var temp : List[Long] = List[Long]()\n        var i :\
    \ Long = 0l\n        while (i < k) {\n            var max : Long = -1000l\n  \
    \          var index : Long = 0l\n            var j : Long = 0l\n            while\
    \ (j < arr.length) {\n                if (arr(j.toInt) > max && !temp.contains(j))\
    \ {\n                    max = arr(j.toInt)\n                    index = j\n \
    \               }\n                j += 1\n            }\n            result =\
    \ result :+ max\n            temp = temp :+ index\n            i += 1\n      \
    \  }\n        return result\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmphdntxhct.scala:41)\n\tat Problem.main(tmphdntxhct.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793391
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // We use a priority queue\
    \ to store the elements of the list.\n        // The priority queue is a min-heap,\
    \ so the smallest element is at the top.\n        // We add the first k elements\
    \ to the priority queue.\n        // Then, for each element in the list, we check\
    \ if it is larger than the smallest element in the priority queue.\n        //\
    \ If it is, we remove the smallest element from the priority queue and add the\
    \ new element.\n        // When we are done, we return the priority queue.\n \
    \       val pq = new PriorityQueue[Long]()(Ordering.Long.reverse)\n        for\
    \ (i <- 0l until k) {\n            pq.enqueue(arr(i.toInt))\n        }\n     \
    \   for (i <- k until arr.length) {\n            if (arr(i.toInt) > pq.head) {\n\
    \                pq.dequeue\n                pq.enqueue(arr(i.toInt))\n      \
    \      }\n        }\n        pq.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpl58pkpom.scala:42)\n\tat Problem.main(tmpl58pkpom.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793391
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // Return a sorted list of length `k` with the maximum `k` numbers in\
    \ `arr`\n        arr.sortWith(_ > _).take(k.toInt)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n\
    \    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong,\
    \ -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong,\
    \ -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong,\
    \ 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong,\
    \ 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong,\
    \ 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmplwrq6nkc.scala:27)\n\tat Problem.main(tmplwrq6nkc.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793391
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Write your code here\n\
    \        arr.sorted.takeRight(k.toInt)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793391
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // You have to return a sorted list of length `k` with the maximum k\
    \ numbers in `arr`\n        // You can assume that `k` is less than or equal to\
    \ the length of `arr`\n        // You can assume that `k` is greater than 0\n\
    \        // You can assume that `arr` is not empty\n        // You can assume\
    \ that `arr` does not contain duplicates\n        // You can assume that `arr`\
    \ contains only positive integers\n        // You can assume that `arr` contains\
    \ only negative integers\n        // You can assume that `arr` contains only non-negative\
    \ integers\n        // You can assume that `arr` contains only non-positive integers\n\
    \        // You can assume that `arr` contains only integers\n        arr.sorted.takeRight(k.toInt)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793392
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // 'arr' is a list of integers\n        // 'k' is a positive integer\n\
    \        // Return a sorted list of length 'k' with the maximum 'k' numbers in\
    \ 'arr'\n        arr.sortWith(_ > _).take(k.toInt)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n\
    \    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong,\
    \ -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong,\
    \ -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong,\
    \ 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong,\
    \ 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong,\
    \ 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5ubx70z_.scala:27)\n\tat Problem.main(tmp5ubx70z_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793380
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        val heap = new PriorityQueue[Long]()(Ordering.by(-_))\n\
    \        for (i <- arr) {\n            heap.enqueue(i)\n            if (heap.size\
    \ > k) heap.dequeue\n        }\n        heap.toList.sorted\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n\
    \    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong,\
    \ -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong,\
    \ -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong,\
    \ 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong,\
    \ 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong,\
    \ 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793374
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // You have to return a sorted list of length `k` with the maximum k\
    \ numbers in `arr`\n        // If there are less than `k` numbers in `arr`, return\
    \ the maximum k numbers in `arr`\n        // If there are more than `k` numbers\
    \ in `arr`, return the maximum k numbers in `arr`\n        // You can assume that\
    \ `k` is always valid, 1 \u2264 k \u2264 arr.length\n        // The input array\
    \ will not be empty.\n        // The output array should be sorted in descending\
    \ order.\n        // For example,\n        // maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)) should return (List[Long](-4l.toLong, -3l.toLong,\
    \ 5l.toLong))\n        // maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)),\
    \ (2l)) should return (List[Long](4l.toLong, 4l.toLong))\n        // maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\
    \ should return (List[Long](2l.toLong))\n        arr.sortWith(_ > _).take(k.toInt)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpndawml_p.scala:36)\n\tat Problem.main(tmpndawml_p.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793391
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // We can use a heap to solve\
    \ this problem.\n        // The heap will contain the k largest elements in arr.\n\
    \        // We will iterate through arr and add each element to the heap.\n  \
    \      // If the heap contains more than k elements, we will pop the smallest\
    \ element from the heap.\n        // At the end, we will pop the elements from\
    \ the heap and return them in reverse order.\n        val heap = new PriorityQueue[Long]()\n\
    \        for (i <- arr) {\n            heap.enqueue(i)\n            if (heap.size\
    \ > k) heap.dequeue\n        }\n        val result = new ListBuffer[Long]()\n\
    \        while (heap.nonEmpty) result += heap.dequeue\n        result.reverse.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmps77l7_kj.scala:36)\n\tat Problem.main(tmps77l7_kj.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793392
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // We can use a max heap to\
    \ solve this problem.\n        // We can also use a min heap to solve this problem.\n\
    \        // We can also use a max heap to solve this problem.\n        // We can\
    \ also use a min heap to solve this problem.\n        // We can also use a max\
    \ heap to solve this problem.\n        // We can also use a min heap to solve\
    \ this problem.\n        // We can also use a max heap to solve this problem.\n\
    \        // We can also use a min heap to solve this problem.\n        // We can\
    \ also use a max heap to solve this problem.\n        // We can also use a min\
    \ heap to solve this problem.\n        // We can also use a max heap to solve\
    \ this problem.\n        // We can also use a min heap to solve this problem.\n\
    \        // We can also use a max heap to solve this problem.\n        // We can\
    \ also use a min heap to solve this problem.\n        // We can also use a max\
    \ heap to solve this problem.\n        // We can also use a min heap to solve\
    \ this problem.\n        // We can also use a max heap to solve this problem.\n\
    \        // We can also use a min heap to solve this problem.\n        // We can\
    \ also use a max heap to solve this problem.\n        // We can also use a min\
    \ heap to solve this problem.\n        // We can also use a max heap to solve\
    \ this problem.\n        // We can also use a min heap to solve this problem.\n\
    \        // We can also use a max heap to solve this problem.\n        // We can\
    \ also use a min heap to solve this problem.\n        // We can also use a max\
    \ heap to solve this problem.\n        // We can also use a min heap to solve\
    \ this problem.\n        // We can also use a max heap to solve this problem.\n\
    \        // We can also use a min heap to solve this problem.\n        // We can\
    \ also use a max heap to solve this problem.\n        // We can also use a min\
    \ heap to solve this problem.\n        // We can also use a max heap to solve\
    \ this problem.\n        // We can also use a min heap to solve this problem.\n\
    \        // We can also use a max heap to solve this problem.\n        // We can\
    \ also use a min heap to solve this problem.\n        //\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n\
    \    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong,\
    \ -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong,\
    \ -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong,\
    \ 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong,\
    \ 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong,\
    \ 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpiq_8zus7.scala:19:59\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m    \e[33mdef\e[0m \e[36mmaximum\e\
    [0m(\e[36marr\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mk\e[0m : \e[35mLong\e\
    [0m) : \e[35mList\e[0m[\e[35mLong\e[0m] = {\n\e[31m\e[31m   |\e[0m           \
    \                                                ^\e[0m\n\e[31m   |\e[0m     \
    \                                               Found:    Unit\n\e[31m   |\e[0m\
    \                                                    Required: List[Long]\n\e\
    [31m20 |\e[0m        \e[34m// We can use a max heap to solve this problem.\e[0m\n\
    \e[31m21 |\e[0m        \e[34m// We can also use a min heap to solve this problem.\e\
    [0m\n\e[31m22 |\e[0m        \e[34m// We can also use a max heap to solve this\
    \ problem.\e[0m\n\e[31m23 |\e[0m        \e[34m// We can also use a min heap to\
    \ solve this problem.\e[0m\n\e[31m24 |\e[0m        \e[34m// We can also use a\
    \ max heap to solve this problem.\e[0m\n\e[31m25 |\e[0m        \e[34m// We can\
    \ also use a min heap to solve this problem.\e[0m\n\e[31m26 |\e[0m        \e[34m//\
    \ We can also use a max heap to solve this problem.\e[0m\n\e[31m27 |\e[0m    \
    \    \e[34m// We can also use a min heap to solve this problem.\e[0m\n\e[31m28\
    \ |\e[0m        \e[34m// We can also use a max heap to solve this problem.\e[0m\n\
    \e[31m29 |\e[0m        \e[34m// We can also use a min heap to solve this problem.\e\
    [0m\n\e[31m30 |\e[0m        \e[34m// We can also use a max heap to solve this\
    \ problem.\e[0m\n\e[31m31 |\e[0m        \e[34m// We can also use a min heap to\
    \ solve this problem.\e[0m\n\e[31m32 |\e[0m        \e[34m// We can also use a\
    \ max heap to solve this problem.\e[0m\n\e[31m33 |\e[0m        \e[34m// We can\
    \ also use a min heap to solve this problem.\e[0m\n\e[31m34 |\e[0m        \e[34m//\
    \ We can also use a max heap to solve this problem.\e[0m\n\e[31m35 |\e[0m    \
    \    \e[34m// We can also use a min heap to solve this problem.\e[0m\n\e[31m36\
    \ |\e[0m        \e[34m// We can also use a max heap to solve this problem.\e[0m\n\
    \e[31m37 |\e[0m        \e[34m// We can also use a min heap to solve this problem.\e\
    [0m\n\e[31m38 |\e[0m        \e[34m// We can also use a max heap "
  stdout: ''
  timestamp: 1659793391
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        var result : List[Long] =\
    \ List[Long]()\n        var max : Long = 0\n        var max_index : Long = 0\n\
    \        for (i <- 0l.toLong to k - 1l.toLong) {\n            max = arr(0l.toInt)\n\
    \            max_index = 0l\n            for (j <- 0l.toLong to arr.length - 1l.toLong)\
    \ {\n                if (arr(j.toInt) > max) {\n                    max = arr(j.toInt)\n\
    \                    max_index = j\n                }\n            }\n       \
    \     result = result :+ max\n            arr = arr.patch(max_index.toInt, Nil,\
    \ 1)\n        }\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmpltexgeyd.scala:33:16 -----------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m            arr = arr.patch(max_index.toInt, Nil, \e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            Reassignment to val arr\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659793390
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // 'arr' is a list of integers\n        // 'k' is a positive integer\n\
    \        // Return a sorted list of length 'k' with the maximum 'k' numbers in\
    \ 'arr'\n        arr.sorted.takeRight(k.toInt)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793374
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Given a list arr of integers\
    \ and a positive integer k, return a sorted list \n        // of length k with\
    \ the maximum k numbers in arr.\n        // Example 1:\n        // >>> maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l))\n        // (List[Long](-4l.toLong, -3l.toLong,\
    \ 5l.toLong))\n        // Example 2:\n        // >>> maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l))\n        // (List[Long](4l.toLong, 4l.toLong))\n\
    \        // Example 3:\n        // >>> maximum((List[Long](-3l.toLong, 2l.toLong,\
    \ 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n        //\
    \ (List[Long](2l.toLong))\n        // Note:\n        // 1. The length of the list\
    \ will be in the range of [1, 1000].\n        // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n        // 3. 0 <= k <= len(arr)\n      \
    \  def maximum(arr : List[Long], k : Long) : List[Long] = {\n            // Given\
    \ a list arr of integers and a positive integer k, return a sorted list \n   \
    \         // of length k with the maximum k numbers in arr.\n            // Example\
    \ 1:\n            // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n            // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    \
    \        // Example 2:\n            // >>> maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l))\n            // (List[Long](4l.toLong, 4l.toLong))\n    \
    \        // Example 3:\n            // >>> maximum((List[Long](-3l.toLong, 2l.toLong,\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp81eyir6w.scala:62:0 ----------------------------\e\
    [0m\e[0m\n\e[31m62 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp81eyir6w.scala:35:63\
    \ --------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mdef\e[0m \e[36mmaximum\e\
    [0m(\e[36marr\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mk\e[0m : \e[35mLong\e\
    [0m) : \e[35mList\e[0m[\e[35mLong\e[0m] = {\n\e[31m\e[31m   |\e[0m           \
    \                                                    ^\e[0m\n\e[31m   |\e[0m \
    \                                                   Found:    Unit\n\e[31m   |\e\
    [0m                                                    Required: List[Long]\n\e\
    [31m36 |\e[0m            \e[34m// Given a list arr of integers and a positive\
    \ integer k, return a sorted list \e[0m\n\e[31m37 |\e[0m            \e[34m// of\
    \ length k with the maximum k numbers in arr.\e[0m\n\e[31m38 |\e[0m          \
    \  \e[34m// Example 1:\e[0m\n\e[31m39 |\e[0m            \e[34m// >>> maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l))\e[0m\n\e[31m40 |\e[0m            \e[34m// (List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))\e[0m\n\e[31m41 |\e[0m            \e[34m// Example 2:\e\
    [0m\n\e[31m42 |\e[0m            \e[34m// >>> maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l))\e[0m\n\e[31m43 |\e[0m            \e[34m// (List[Long](4l.toLong,\
    \ 4l.toLong))\e[0m\n\e[31m44 |\e[0m            \e[34m// Example 3:\e[0m\n\e[31m45\
    \ |\e[0m            \e[34m// >>> maximum((List[Long](-3l.toLong, 2l.toLong,\e\
    [0m\n\e[31m46 |\e[0m    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp81eyir6w.scala:61:1 ---------------------\e[0m\e[0m\n\e[31m61\
    \ |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:    Unit\n\e[31m\
    \   |\e[0m Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[33m\e[33m-- Warning: /tmp/tmp81eyir6w.scala:47:4\
    \ ----------------------------------------\e[0m\e[0m\n\e[33m47 |\e[0m    \e[33mdef\e\
    [0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e[0"
  stdout: ''
  timestamp: 1659793390
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        var result : List[Long] =\
    \ List[Long]()\n        var arr2 : List[Long] = arr\n        for (i <- 0l.toLong\
    \ to k - 1l.toLong) {\n            var max : Long = arr2.max\n            result\
    \ = result :+ max\n            arr2 = arr2.filter(x => x != max)\n        }\n\
    \        return result\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpihhjnbbo.scala:30)\n\tat Problem.main(tmpihhjnbbo.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793392
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // 'return List[Long]()' in case of timeout or internal error\n     \
    \   return List[Long]()\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4stnr6t2.scala:25)\n\tat Problem.main(tmp4stnr6t2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793379
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // We can use a max heap to\
    \ solve this problem.\n        // The max heap will have a size of k.\n      \
    \  // We will iterate through the list and add each element to the heap.\n   \
    \     // If the heap is full, we will remove the max element from the heap\n \
    \       // and add the new element.\n        // At the end of the iteration, we\
    \ will have a heap with the k largest\n        // elements in the list.\n    \
    \    // We can then iterate through the heap and add the elements to a list.\n\
    \        // This will be the sorted list of the k largest elements in the list.\n\
    \        // Time Complexity: O(n * log(k))\n        // Space Complexity: O(k)\n\
    \        val heap = new PriorityQueue[Long]()(Ordering.by(-_))\n        for (element\
    \ <- arr) {\n            if (heap.size < k) {\n                heap.enqueue(element)\n\
    \            } else {\n                if (element > heap.head) {\n          \
    \          heap.dequeue\n                    heap.enqueue(element)\n         \
    \       }\n            }\n        }\n        val result = new ListBuffer[Long]()\n\
    \        while (heap.nonEmpty) {\n            result += heap.dequeue\n       \
    \ }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.util.NoSuchElementException: queue is empty\n\tat scala.collection.mutable.PriorityQueue.head(PriorityQueue.scala:254)\n\
    \tat Problem$.maximum$$anonfun$1(tmppn8m46_i.scala:36)\n\tat scala.runtime.java8.JFunction1$mcVJ$sp.apply(JFunction1$mcVJ$sp.scala:18)\n\
    \tat scala.collection.immutable.List.foreach(List.scala:333)\n\tat Problem$.maximum(tmppn8m46_i.scala:41)\n\
    \tat Problem$.main(tmppn8m46_i.scala:59)\n\tat Problem.main(tmppn8m46_i.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793393
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // 'return List[Long]()' for the case of empty list\n        return List[Long]()\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmzolfbbf.scala:25)\n\tat Problem.main(tmpmzolfbbf.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793392
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Define a function to convert\
    \ a list of integers to a list of longs.\n        def f(arr : List[Int]) : List[Long]\
    \ = {\n            arr.map(x => x.toLong)\n        }\n        // Define a function\
    \ to convert a list of longs to a list of integers.\n        def g(arr : List[Long])\
    \ : List[Int] = {\n            arr.map(x => x.toInt)\n        }\n        // Define\
    \ a function to convert a list of integers to a list of longs.\n        def h(arr\
    \ : List[Int]) : List[Long] = {\n            arr.map(x => x.toLong)\n        }\n\
    \        // Define a function to convert a list of longs to a list of integers.\n\
    \        def i(arr : List[Long]) : List[Int] = {\n            arr.map(x => x.toInt)\n\
    \        }\n        // Define a function to convert a list of integers to a list\
    \ of longs.\n        def j(arr : List[Int]) : List[Long] = {\n            arr.map(x\
    \ => x.toLong)\n        }\n        // Define a function to convert a list of longs\
    \ to a list of integers.\n        def k(arr : List[Long]) : List[Int] = {\n  \
    \          arr.map(x => x.toInt)\n        }\n        // Define a function to convert\
    \ a list of integers to a list of longs.\n        def l(arr : List[Int]) : List[Long]\
    \ = {\n            arr.map(x => x.toLong)\n        }\n        // Define a function\
    \ to convert a list of longs to a list of integers.\n        def m(arr : List[Long])\
    \ : List[Int] = {\n            arr.map(x => x.toInt)\n        }\n        // Define\
    \ a function to convert a list of integers to a list of longs.\n        def n(arr\
    \ : List[Int]) : List[Long] = {\n            arr.map(x => x.toLong)\n        }\n\
    \        // Define a function to convert a list of longs to a list of integers.\n\
    \        def o(arr\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpt8_evexy.scala:58:4 ----------------------------\e\
    [0m\e[0m\n\e[31m58 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ':' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpt8_evexy.scala:58:5 ---------------------\e[0m\e[0m\n\e[31m58 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659793392
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // 'passed' variable is just an indicator\n        // 'passed' and 'arr'\
    \ variables are defined in the test cases.\n        // 'passed' should be replaced\
    \ by the actual test result\n        var passed : Boolean = false\n        arr\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmzgo5ipp.scala:28)\n\tat Problem.main(tmpmzgo5ipp.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793393
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // 'return List[Long]()' for Scala, 'return new ArrayList<Long>()' for\
    \ Java\n        return List[Long]()\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpj3jk0unp.scala:25)\n\tat Problem.main(tmpj3jk0unp.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793393
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // You have to return a sorted list of length `k` with the maximum k\
    \ numbers in `arr`\n        // You can assume that `k` is less than or equal to\
    \ the length of `arr`\n        // You can assume that `k` is greater than 0\n\
    \        arr.sortWith(_ > _).take(k.toInt)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpucwkl69k.scala:29)\n\tat Problem.main(tmpucwkl69k.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793374
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // We can use a max heap to\
    \ solve this problem.\n        // The max heap will contain the k largest elements.\n\
    \        // We can then iterate through the remaining elements,\n        // and\
    \ if they are larger than the root of the max heap,\n        // we can replace\
    \ the root with that element.\n        // Then we can return the max heap.\n \
    \       // This algorithm will run in O(n log k) time.\n        val heap = new\
    \ PriorityQueue[Long]()(Ordering.by(-_))\n        for (i <- 0 until k.toInt) {\n\
    \            heap.enqueue(arr(i))\n        }\n        for (i <- k.toInt until\
    \ arr.length) {\n            if (arr(i) > heap.head) {\n                heap.dequeue\n\
    \                heap.enqueue(arr(i))\n            }\n        }\n        heap.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_e_obze7.scala:43)\n\tat Problem.main(tmp_e_obze7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793395
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        val heap = new PriorityQueue[Long]()(Ordering.by(-_))\n\
    \        for (i <- arr) {\n            heap.enqueue(i)\n            if (heap.size\
    \ > k) heap.dequeue\n        }\n        heap.toList.sorted\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n\
    \    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong,\
    \ -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong,\
    \ -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong,\
    \ 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong,\
    \ 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong,\
    \ 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793374
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // We can use a min heap to\
    \ solve this problem.\n        // The heap will contain the k largest elements\
    \ of arr.\n        // We will iterate through arr, and if the current element\
    \ is larger than the smallest element in the heap,\n        // we will remove\
    \ the smallest element from the heap and add the current element to the heap.\n\
    \        // After iterating through arr, we will return the heap.\n        //\
    \ The heap will be sorted in ascending order, so we will reverse it to get the\
    \ result.\n        // Time Complexity: O(n log k)\n        // Space Complexity:\
    \ O(k)\n        var heap = new PriorityQueue[Long]()(Ordering.by(-_))\n      \
    \  for (i <- 0 until arr.length) {\n            if (heap.size < k) heap.enqueue(arr(i))\n\
    \            else if (arr(i) > heap.head) {\n                heap.dequeue\n  \
    \              heap.enqueue(arr(i))\n            }\n        }\n        heap.toList.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjlgwn8xc.scala:39)\n\tat Problem.main(tmpjlgwn8xc.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793395
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        val heap = new Heap[Long]()\n\
    \        for (i <- arr) {\n            heap.insert(i)\n            if (heap.size\
    \ > k) heap.deleteMin()\n        }\n        heap.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n\
    \    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong,\
    \ -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong,\
    \ -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong,\
    \ 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong,\
    \ 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong,\
    \ 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpa64qmxkk.scala:20:23 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mheap\e[0m = \e[33mnew\e\
    [0m \e[35mHeap\e[0m[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                \
    \       ^^^^\e[0m\n\e[31m   |\e[0m                       Not found: type Heap\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659793393
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // `for` is Scala's list comprehension\n        // `yield` is used to\
    \ build a new list\n        for (i <- arr.sorted.takeRight(k.toInt)) yield i\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793395
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // We can use a max heap to\
    \ solve this problem.\n        // The max heap will have size k, and will contain\
    \ the k largest elements.\n        // We can then extract the elements from the\
    \ heap in reverse order to get the\n        // elements in sorted order.\n   \
    \     // The time complexity is O(n log k) and the space complexity is O(k).\n\
    \        val heap = new MaxHeap[Long](k.toInt)\n        for (x <- arr) {\n   \
    \         if (heap.size < k) heap.insert(x)\n            else if (x > heap.peek)\
    \ {\n                heap.extractMax\n                heap.insert(x)\n       \
    \     }\n        }\n        heap.extractAll.reverse\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n\
    \    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong,\
    \ -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong,\
    \ -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong,\
    \ 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong,\
    \ 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong,\
    \ 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpiwz0ny4r.scala:25:23 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mheap\e[0m = \e[33mnew\e\
    [0m \e[35mMaxHeap\e[0m[\e[35mLong\e[0m](k.toInt)\n\e[31m\e[31m   |\e[0m      \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                       Not found:\
    \ type MaxHeap\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659793393
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Define a function to convert\
    \ a list of integers to a list of longs.\n        def f(arr : List[Int]) : List[Long]\
    \ = {\n            arr.map(x => x.toLong)\n        }\n        // Define a function\
    \ to convert a list of longs to a list of integers.\n        def g(arr : List[Long])\
    \ : List[Int] = {\n            arr.map(x => x.toInt)\n        }\n        // Define\
    \ a function to convert a list of integers to a list of longs.\n        def h(arr\
    \ : List[Int]) : List[Long] = {\n            arr.map(x => x.toLong)\n        }\n\
    \        // Define a function to convert a list of longs to a list of integers.\n\
    \        def i(arr : List[Long]) : List[Int] = {\n            arr.map(x => x.toInt)\n\
    \        }\n        // Define a function to convert a list of integers to a list\
    \ of longs.\n        def j(arr : List[Int]) : List[Long] = {\n            arr.map(x\
    \ => x.toLong)\n        }\n        // Define a function to convert a list of longs\
    \ to a list of integers.\n        def k(arr : List[Long]) : List[Int] = {\n  \
    \          arr.map(x => x.toInt)\n        }\n        // Define a function to convert\
    \ a list of integers to a list of longs.\n        def l(arr : List[Int]) : List[Long]\
    \ = {\n            arr.map(x => x.toLong)\n        }\n        // Define a function\
    \ to convert a list of longs to a list of integers.\n        def m(arr : List[Long])\
    \ : List[Int] = {\n            arr.map(x => x.toInt)\n        }\n        // Define\
    \ a function to convert a list of integers to a list of longs.\n        def n(arr\
    \ : List[Int]) : List[Long] = {\n            arr.map(x => x.toLong)\n        }\n\
    \        // Define a function to convert a list of longs to a list of integers.\n\
    \        def o(arr\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpt8_evexy.scala:58:4 ----------------------------\e\
    [0m\e[0m\n\e[31m58 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ':' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpt8_evexy.scala:58:5 ---------------------\e[0m\e[0m\n\e[31m58 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659793392
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Given a list arr of integers\
    \ and a positive integer k, return a sorted list \n        // of length k with\
    \ the maximum k numbers in arr.\n        // Example 1:\n        // >>> maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l))\n        // (List[Long](-4l.toLong, -3l.toLong,\
    \ 5l.toLong))\n        // Example 2:\n        // >>> maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l))\n        // (List[Long](4l.toLong, 4l.toLong))\n\
    \        // Example 3:\n        // >>> maximum((List[Long](-3l.toLong, 2l.toLong,\
    \ 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n        //\
    \ (List[Long](2l.toLong))\n        // Note:\n        // 1. The length of the list\
    \ will be in the range of [1, 1000].\n        // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n        // 3. 0 <= k <= len(arr)\n      \
    \  arr.sorted.takeRight(k.toInt)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793396
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // We will use a heap to store\
    \ the maximum k numbers.\n        // The heap will be a min-heap, so the minimum\
    \ number will be at the top.\n        // We will use the heap to store the k smallest\
    \ numbers.\n        // If we encounter a number that is larger than the top of\
    \ the heap,\n        // we will pop the top of the heap and push the new number.\n\
    \        // At the end, we will pop all the numbers from the heap and return them\
    \ in reverse order.\n        val heap = new mutable.PriorityQueue[Long]()\n  \
    \      for (x <- arr) {\n            if (heap.size < k) {\n                heap.enqueue(x)\n\
    \            } else {\n                if (x > heap.head) {\n                \
    \    heap.dequeue\n                    heap.enqueue(x)\n                }\n  \
    \          }\n        }\n        val result = new ListBuffer[Long]()\n       \
    \ while (heap.nonEmpty) {\n            result += heap.dequeue\n        }\n   \
    \     result.toList.reverse\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmprd2amj3d.scala:26:23 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mheap\e[0m = \e[33mnew\e\
    [0m mutable.PriorityQueue[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m          \
    \             ^^^^^^^\e[0m\n\e[31m   |\e[0m                       Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659793394
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // We can use a max heap to\
    \ solve this problem.\n        // The time complexity is O(n log k) and the space\
    \ complexity is O(k).\n        val heap = new mutable.PriorityQueue[Long]()\n\
    \        for (i <- arr) {\n            heap.enqueue(i)\n            if (heap.size\
    \ > k) heap.dequeue\n        }\n        heap.toList.sorted\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n\
    \    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong,\
    \ -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong,\
    \ -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong,\
    \ 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong,\
    \ 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong,\
    \ 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpnd7i_qb6.scala:22:23 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mheap\e[0m = \e[33mnew\e\
    [0m mutable.PriorityQueue[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m          \
    \             ^^^^^^^\e[0m\n\e[31m   |\e[0m                       Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659793394
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // You have to return a sorted list of length `k` with the maximum k\
    \ numbers in `arr`\n        // You can assume that `k` is less than or equal to\
    \ the length of `arr`\n        // You can assume that `k` is greater than 0\n\
    \        var list = arr.sorted\n        var result = List[Long]()\n        for\
    \ (i <- 0 to k.toInt - 1) {\n            result = result :+ list(list.length -\
    \ 1 - i)\n        }\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp60folwca.scala:34)\n\tat Problem.main(tmp60folwca.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793397
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // You have to return a sorted list of length `k` with the maximum k\
    \ numbers in `arr`\n        // You can assume that `k` is always valid, 1 \u2264\
    \ k \u2264 arr.length\n        // You can assume that `arr` is always valid, arr.length\
    \ \u2265 k\n        // You can assume that `arr` is always valid, arr.length \u2265\
    \ k\n        // You can assume that `arr` is always valid, arr.length \u2265 k\n\
    \        // You can assume that `arr` is always valid, arr.length \u2265 k\n \
    \       // You can assume that `arr` is always valid, arr.length \u2265 k\n  \
    \      // You can assume that `arr` is always valid, arr.length \u2265 k\n   \
    \     // You can assume that `arr` is always valid, arr.length \u2265 k\n    \
    \    // You can assume that `arr` is always valid, arr.length \u2265 k\n     \
    \   // You can assume that `arr` is always valid, arr.length \u2265 k\n      \
    \  // You can assume that `arr` is always valid, arr.length \u2265 k\n       \
    \ // You can assume that `arr` is always valid, arr.length \u2265 k\n        //\
    \ You can assume that `arr` is always valid, arr.length \u2265 k\n        // You\
    \ can assume that `arr` is always valid, arr.length \u2265 k\n        // You can\
    \ assume that `arr` is always valid, arr.length \u2265 k\n        // You can assume\
    \ that `arr` is always valid, arr.length \u2265 k\n        // You can assume that\
    \ `arr` is always valid, arr.length \u2265 k\n        // You can assume that `arr`\
    \ is always valid, arr.length \u2265 k\n        // You can assume that `arr` is\
    \ always valid, arr.length \u2265 k\n        // You can assume that `arr` is always\
    \ valid, arr.length \u2265 k\n        // You can assume that `arr` is always valid,\
    \ arr.length \u2265 k\n        // You can assume that `arr` is always valid, arr.length\
    \ \u2265 k\n        // You can assume that `arr` is always valid, arr.length \u2265\
    \ k\n        // You can assume that `arr` is always valid, arr.length \u2265 k\n\
    \n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpiojp9or_.scala:19:59\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m    \e[33mdef\e[0m \e[36mmaximum\e\
    [0m(\e[36marr\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mk\e[0m : \e[35mLong\e\
    [0m) : \e[35mList\e[0m[\e[35mLong\e[0m] = {\n\e[31m\e[31m   |\e[0m           \
    \                                                ^\e[0m\n\e[31m   |\e[0m     \
    \                                               Found:    Unit\n\e[31m   |\e[0m\
    \                                                    Required: List[Long]\n\e\
    [31m20 |\e[0m        \e[34m// Fill up this function body\e[0m\n\e[31m21 |\e[0m\
    \        \e[34m// `arr` is a list of integers\e[0m\n\e[31m22 |\e[0m        \e\
    [34m// `k` is a positive integer\e[0m\n\e[31m23 |\e[0m        \e[34m// You have\
    \ to return a sorted list of length `k` with the maximum k numbers in `arr`\e\
    [0m\n\e[31m24 |\e[0m        \e[34m// You can assume that `k` is always valid,\
    \ 1 \u2264 k \u2264 arr.length\e[0m\n\e[31m25 |\e[0m        \e[34m// You can assume\
    \ that `arr` is always valid, arr.length \u2265 k\e[0m\n\e[31m26 |\e[0m      \
    \  \e[34m// You can assume that `arr` is always valid, arr.length \u2265 k\e[0m\n\
    \e[31m27 |\e[0m        \e[34m// You can assume that `arr` is always valid, arr.length\
    \ \u2265 k\e[0m\n\e[31m28 |\e[0m        \e[34m// You can assume that `arr` is\
    \ always valid, arr.length \u2265 k\e[0m\n\e[31m29 |\e[0m        \e[34m// You\
    \ can assume that `arr` is always valid, arr.length \u2265 k\e[0m\n\e[31m30 |\e\
    [0m        \e[34m// You can assume that `arr` is always valid, arr.length \u2265\
    \ k\e[0m\n\e[31m31 |\e[0m        \e[34m// You can assume that `arr` is always\
    \ valid, arr.length \u2265 k\e[0m\n\e[31m32 |\e[0m        \e[34m// You can assume\
    \ that `arr` is always valid, arr.length \u2265 k\e[0m\n\e[31m33 |\e[0m      \
    \  \e[34m// You can assume that `arr` is always valid, arr.length \u2265 k\e[0m\n\
    \e[31m34 |\e[0m        \e[34m// You can assume that `arr` is always valid, arr.length\
    \ \u2265 k\e[0m\n\e[31m35 |\e[0m        \e[34m// You can assume that `arr` is\
    \ always valid, arr.length \u2265 k\e[0m\n\e[31m36 |\e[0m        \e[34m// You\
    \ can assume that `arr` is always valid, arr.length \u2265 k\e[0m\n\e[31m37 |\e\
    [0m        \e[34m// You can assume that `arr` is always"
  stdout: ''
  timestamp: 1659793397
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // `k` is the length of the output list\n        // `arr` is the input\
    \ list\n        // Return a sorted list of length `k` with the maximum k numbers\
    \ in `arr`\n        arr.sorted.takeRight(k.toInt)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793397
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // You have to return a sorted list of length `k` with the maximum k\
    \ numbers in `arr`\n        // You can assume that `k` is less than or equal to\
    \ the length of `arr`\n        // You can assume that `k` is greater than 0\n\
    \        arr.sorted.takeRight(k.toInt)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793374
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // You have to return a sorted list of length `k` with the maximum k\
    \ numbers in `arr`\n        // You can assume that `k` is less than or equal to\
    \ the length of `arr`\n        // You can assume that `k` is greater than 0\n\
    \        var result = List[Long]()\n        var max = Long.MinValue\n        var\
    \ maxIndex = 0\n        for (i <- 0 until k.toInt) {\n            for (j <- i\
    \ until arr.length) {\n                if (arr(j) > max) {\n                 \
    \   max = arr(j)\n                    maxIndex = j\n                }\n      \
    \      }\n            result = result :+ max\n            max = Long.MinValue\n\
    \            var temp = arr(i)\n            arr(i) = arr(maxIndex)\n         \
    \   arr(maxIndex) = temp\n        }\n        result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n\
    \    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong,\
    \ -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong,\
    \ -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong,\
    \ 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong,\
    \ 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong,\
    \ 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpxuvhf_4o.scala:39:12 ------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m            arr(i) = arr(maxIndex)\n\e[31m\e[31m   |\e\
    [0m            ^^^\e[0m\n\e[31m   |\e[0m  value update is not a member of List[Long]\
    \ - did you mean arr.updated?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpxuvhf_4o.scala:40:12\
    \ ------------------------\e[0m\e[0m\n\e[31m40 |\e[0m            arr(maxIndex)\
    \ = temp\n\e[31m\e[31m   |\e[0m            ^^^\e[0m\n\e[31m   |\e[0m  value update\
    \ is not a member of List[Long] - did you mean arr.updated?\n2 errors found\n"
  stdout: ''
  timestamp: 1659793397
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // We can use a heap to solve\
    \ this problem.\n        // We can use a min-heap to store the k largest elements.\n\
    \        // We can use a max-heap to store the k smallest elements.\n        //\
    \ We can use a min-heap to store the k largest elements.\n        // We can use\
    \ a max-heap to store the k smallest elements.\n        // We can use a min-heap\
    \ to store the k largest elements.\n        // We can use a max-heap to store\
    \ the k smallest elements.\n        // We can use a min-heap to store the k largest\
    \ elements.\n        // We can use a max-heap to store the k smallest elements.\n\
    \        // We can use a min-heap to store the k largest elements.\n        //\
    \ We can use a max-heap to store the k smallest elements.\n        // We can use\
    \ a min-heap to store the k largest elements.\n        // We can use a max-heap\
    \ to store the k smallest elements.\n        // We can use a min-heap to store\
    \ the k largest elements.\n        // We can use a max-heap to store the k smallest\
    \ elements.\n        // We can use a min-heap to store the k largest elements.\n\
    \        // We can use a max-heap to store the k smallest elements.\n        //\
    \ We can use a min-heap to store the k largest elements.\n        // We can use\
    \ a max-heap to store the k smallest elements.\n        // We can use a min-heap\
    \ to store the k largest elements.\n        // We can use a max-heap to store\
    \ the k smallest elements.\n        // We can use a min-heap to store the k largest\
    \ elements.\n        // We can use a max-heap to store the k smallest elements.\n\
    \        // We can use a min-heap to store the k largest elements.\n        //\
    \ We can use a max-heap to store the k smallest elements.\n        // We can use\
    \ a min-heap to store the k largest elements.\n        // We can use a max-heap\
    \ to store the k smallest elements.\n        // We can use a min-heap to store\
    \ the k largest elements.\n        // We can use a max-heap to store\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpkbjwx2sn.scala:19:59\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m    \e[33mdef\e[0m \e[36mmaximum\e\
    [0m(\e[36marr\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mk\e[0m : \e[35mLong\e\
    [0m) : \e[35mList\e[0m[\e[35mLong\e[0m] = {\n\e[31m\e[31m   |\e[0m           \
    \                                                ^\e[0m\n\e[31m   |\e[0m     \
    \                                               Found:    Unit\n\e[31m   |\e[0m\
    \                                                    Required: List[Long]\n\e\
    [31m20 |\e[0m        \e[34m// We can use a heap to solve this problem.\e[0m\n\e\
    [31m21 |\e[0m        \e[34m// We can use a min-heap to store the k largest elements.\e\
    [0m\n\e[31m22 |\e[0m        \e[34m// We can use a max-heap to store the k smallest\
    \ elements.\e[0m\n\e[31m23 |\e[0m        \e[34m// We can use a min-heap to store\
    \ the k largest elements.\e[0m\n\e[31m24 |\e[0m        \e[34m// We can use a max-heap\
    \ to store the k smallest elements.\e[0m\n\e[31m25 |\e[0m        \e[34m// We can\
    \ use a min-heap to store the k largest elements.\e[0m\n\e[31m26 |\e[0m      \
    \  \e[34m// We can use a max-heap to store the k smallest elements.\e[0m\n\e[31m27\
    \ |\e[0m        \e[34m// We can use a min-heap to store the k largest elements.\e\
    [0m\n\e[31m28 |\e[0m        \e[34m// We can use a max-heap to store the k smallest\
    \ elements.\e[0m\n\e[31m29 |\e[0m        \e[34m// We can use a min-heap to store\
    \ the k largest elements.\e[0m\n\e[31m30 |\e[0m        \e[34m// We can use a max-heap\
    \ to store the k smallest elements.\e[0m\n\e[31m31 |\e[0m        \e[34m// We can\
    \ use a min-heap to store the k largest elements.\e[0m\n\e[31m32 |\e[0m      \
    \  \e[34m// We can use a max-heap to store the k smallest elements.\e[0m\n\e[31m33\
    \ |\e[0m        \e[34m// We can use a min-heap to store the k largest elements.\e\
    [0m\n\e[31m34 |\e[0m        \e[34m// We can use a max-heap to store the k smallest\
    \ elements.\e[0m\n\e[31m35 |\e[0m        \e[34m// We can use a min-heap to store\
    \ the k largest elements.\e[0m\n\e[31m36 |\e[0m        \e[34m// We can use a max-heap\
    \ to store the k smallest elements.\e[0m\n\e[31m37 |\e[0m        \e[34m// We can\
    \ use a min-heap to s"
  stdout: ''
  timestamp: 1659793397
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // 'return List[Long]()' in case of timeout or other internal errors\n\
    \        return List[Long]()\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpr24qhy86.scala:25)\n\tat Problem.main(tmpr24qhy86.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793374
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // Return a sorted list of length `k` with the maximum `k` numbers in\
    \ `arr`\n        arr.sorted.takeRight(k.toInt)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793374
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // You have to return a sorted list of length `k` with the maximum k\
    \ numbers in `arr`\n        // You can assume that `k` is less than or equal to\
    \ the length of `arr`\n        // You can assume that `k` is greater than 0\n\
    \        // You can assume that `arr` is not empty\n        // You can assume\
    \ that `arr` is not null\n        // You can assume that `arr` does not contain\
    \ null elements\n        // You can assume that `arr` does not contain duplicate\
    \ elements\n        // You can assume that `arr` is sorted in non-decreasing order\n\
    \        // You can assume that `arr` is sorted in non-increasing order\n    \
    \    // You can assume that `arr` is sorted in increasing order\n        // You\
    \ can assume that `arr` is sorted in decreasing order\n        // You can assume\
    \ that `arr` is sorted in some order\n        // You can assume that `arr` is\
    \ not sorted in any order\n        // You can assume that `arr` is sorted in some\
    \ order\n        // You can assume that `arr` is not sorted in any order\n   \
    \     // You can assume that `arr` is sorted in some order\n        // You can\
    \ assume that `arr` is not sorted in any order\n        // You can assume that\
    \ `arr` is sorted in some order\n        // You can assume that `arr` is not sorted\
    \ in any order\n        // You can assume that `arr` is sorted in some order\n\
    \        // You can assume that `arr` is not sorted in any order\n        // You\
    \ can assume that `arr` is sorted in some order\n        // You can assume that\
    \ `arr` is not sorted in any order\n        // You can assume that `arr` is sorted\
    \ in some order\n        // You can assume that `arr` is not sorted in any order\n\
    \        // You can assume that `arr` is sorted in some order\n        // You\
    \ can assume that `arr` is not sorted in any order\n        // You can assume\
    \ that `arr` is sorted in some order\n        // You can assume that `arr` is\
    \ not sorted in any order\n        // You can assume that `arr` is sorted in some\
    \ order\n        // You can assume that\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnryoiuxa.scala:19:59\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m    \e[33mdef\e[0m \e[36mmaximum\e\
    [0m(\e[36marr\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mk\e[0m : \e[35mLong\e\
    [0m) : \e[35mList\e[0m[\e[35mLong\e[0m] = {\n\e[31m\e[31m   |\e[0m           \
    \                                                ^\e[0m\n\e[31m   |\e[0m     \
    \                                               Found:    Unit\n\e[31m   |\e[0m\
    \                                                    Required: List[Long]\n\e\
    [31m20 |\e[0m        \e[34m// Fill up this function body\e[0m\n\e[31m21 |\e[0m\
    \        \e[34m// `arr` is a list of integers\e[0m\n\e[31m22 |\e[0m        \e\
    [34m// `k` is a positive integer\e[0m\n\e[31m23 |\e[0m        \e[34m// You have\
    \ to return a sorted list of length `k` with the maximum k numbers in `arr`\e\
    [0m\n\e[31m24 |\e[0m        \e[34m// You can assume that `k` is less than or equal\
    \ to the length of `arr`\e[0m\n\e[31m25 |\e[0m        \e[34m// You can assume\
    \ that `k` is greater than 0\e[0m\n\e[31m26 |\e[0m        \e[34m// You can assume\
    \ that `arr` is not empty\e[0m\n\e[31m27 |\e[0m        \e[34m// You can assume\
    \ that `arr` is not null\e[0m\n\e[31m28 |\e[0m        \e[34m// You can assume\
    \ that `arr` does not contain null elements\e[0m\n\e[31m29 |\e[0m        \e[34m//\
    \ You can assume that `arr` does not contain duplicate elements\e[0m\n\e[31m30\
    \ |\e[0m        \e[34m// You can assume that `arr` is sorted in non-decreasing\
    \ order\e[0m\n\e[31m31 |\e[0m        \e[34m// You can assume that `arr` is sorted\
    \ in non-increasing order\e[0m\n\e[31m32 |\e[0m        \e[34m// You can assume\
    \ that `arr` is sorted in increasing order\e[0m\n\e[31m33 |\e[0m        \e[34m//\
    \ You can assume that `arr` is sorted in decreasing order\e[0m\n\e[31m34 |\e[0m\
    \        \e[34m// You can assume that `arr` is sorted in some order\e[0m\n\e[31m35\
    \ |\e[0m        \e[34m// You can assume that `arr` is not sorted in any order\e\
    [0m\n\e[31m36 |\e[0m        \e[34m// You can assume that `arr` is sorted in some\
    \ order\e[0m\n\e[31m37 |\e[0m        \e[34m// You can assume that `arr` is not\
    \ sorted in any order\e[0m\n\e[31m38 |\e[0m        \e[34m// You can assum"
  stdout: ''
  timestamp: 1659793397
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // We can use a heap to solve\
    \ this problem.\n        // We can use a min-heap to store the maximum k numbers.\n\
    \        // The heap will have size k.\n        // We insert the first k elements\
    \ into the heap.\n        // Then we iterate through the rest of the elements.\n\
    \        // If the element is greater than the minimum element in the heap, we\
    \ remove the minimum element and insert the new element.\n        // After iterating\
    \ through the list, we return the heap.\n        // Time Complexity: O(nlogk)\n\
    \        // Space Complexity: O(k)\n        val heap = new Heap[Long](k.toInt,\
    \ (a : Long, b : Long) => a < b)\n        for (i <- 0 until k.toInt) heap.insert(arr(i))\n\
    \        for (i <- k.toInt until arr.length) {\n            if (arr(i) > heap.peek())\
    \ {\n                heap.remove()\n                heap.insert(arr(i))\n    \
    \        }\n        }\n        heap.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp91_pzmic.scala:29:23 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mheap\e[0m = \e[33mnew\e\
    [0m \e[35mHeap\e[0m[\e[35mLong\e[0m](k.toInt, (\e[36ma\e[0m : \e[35mLong\e[0m,\
    \ \e[36mb\e[0m : \e[35mLong\e[0m) => a < b)\n\e[31m\e[31m   |\e[0m           \
    \            ^^^^\e[0m\n\e[31m   |\e[0m                       Not found: type\
    \ Heap\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659793396
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // You can add another function as well, if required\n        val pq\
    \ = new PriorityQueue[Long]()(Ordering.by(-_))\n        for (i <- arr) {\n   \
    \         pq.enqueue(i)\n            if (pq.size > k) pq.dequeue\n        }\n\
    \        pq.toList.sorted\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793398
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // Return a sorted list of length `k` with the maximum `k` numbers in\
    \ `arr`\n        arr.sorted.takeRight(k.toInt)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793374
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // You have to return a sorted list of length `k` with the maximum k\
    \ numbers in `arr`\n        // You can assume that `k` is less than or equal to\
    \ the length of `arr`\n        // You can assume that `k` is greater than 0\n\
    \        // You can assume that `arr` is not empty\n        // You can assume\
    \ that `arr` is not null\n        // You can assume that `arr` is not null\n \
    \       // You can assume that `arr` is not null\n        // You can assume that\
    \ `arr` is not null\n        // You can assume that `arr` is not null\n      \
    \  // You can assume that `arr` is not null\n        // You can assume that `arr`\
    \ is not null\n        // You can assume that `arr` is not null\n        // You\
    \ can assume that `arr` is not null\n        // You can assume that `arr` is not\
    \ null\n        // You can assume that `arr` is not null\n        // You can assume\
    \ that `arr` is not null\n        // You can assume that `arr` is not null\n \
    \       // You can assume that `arr` is not null\n        // You can assume that\
    \ `arr` is not null\n        // You can assume that `arr` is not null\n      \
    \  // You can assume that `arr` is not null\n        // You can assume that `arr`\
    \ is not null\n        // You can assume that `arr` is not null\n        // You\
    \ can assume that `arr` is not null\n        // You can assume that `arr` is not\
    \ null\n        // You can assume that `arr` is not null\n        // You can assume\
    \ that `arr` is not null\n        // You can assume that `arr` is not null\n \
    \       // You can assume that `arr` is not null\n        // You can assume that\
    \ `arr` is not null\n        // You can assume that `arr` is not null\n      \
    \  // You can assume that `arr` is not null\n        // You can assume that `arr`\
    \ is not null\n        // You can assume that `arr` is not null\n        // You\
    \ can assume that `arr` is not null\n        // You can assume that\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqc5l192g.scala:19:59\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m    \e[33mdef\e[0m \e[36mmaximum\e\
    [0m(\e[36marr\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mk\e[0m : \e[35mLong\e\
    [0m) : \e[35mList\e[0m[\e[35mLong\e[0m] = {\n\e[31m\e[31m   |\e[0m           \
    \                                                ^\e[0m\n\e[31m   |\e[0m     \
    \                                               Found:    Unit\n\e[31m   |\e[0m\
    \                                                    Required: List[Long]\n\e\
    [31m20 |\e[0m        \e[34m// Fill up this function body\e[0m\n\e[31m21 |\e[0m\
    \        \e[34m// `arr` is a list of integers\e[0m\n\e[31m22 |\e[0m        \e\
    [34m// `k` is a positive integer\e[0m\n\e[31m23 |\e[0m        \e[34m// You have\
    \ to return a sorted list of length `k` with the maximum k numbers in `arr`\e\
    [0m\n\e[31m24 |\e[0m        \e[34m// You can assume that `k` is less than or equal\
    \ to the length of `arr`\e[0m\n\e[31m25 |\e[0m        \e[34m// You can assume\
    \ that `k` is greater than 0\e[0m\n\e[31m26 |\e[0m        \e[34m// You can assume\
    \ that `arr` is not empty\e[0m\n\e[31m27 |\e[0m        \e[34m// You can assume\
    \ that `arr` is not null\e[0m\n\e[31m28 |\e[0m        \e[34m// You can assume\
    \ that `arr` is not null\e[0m\n\e[31m29 |\e[0m        \e[34m// You can assume\
    \ that `arr` is not null\e[0m\n\e[31m30 |\e[0m        \e[34m// You can assume\
    \ that `arr` is not null\e[0m\n\e[31m31 |\e[0m        \e[34m// You can assume\
    \ that `arr` is not null\e[0m\n\e[31m32 |\e[0m        \e[34m// You can assume\
    \ that `arr` is not null\e[0m\n\e[31m33 |\e[0m        \e[34m// You can assume\
    \ that `arr` is not null\e[0m\n\e[31m34 |\e[0m        \e[34m// You can assume\
    \ that `arr` is not null\e[0m\n\e[31m35 |\e[0m        \e[34m// You can assume\
    \ that `arr` is not null\e[0m\n\e[31m36 |\e[0m        \e[34m// You can assume\
    \ that `arr` is not null\e[0m\n\e[31m37 |\e[0m        \e[34m// You can assume\
    \ that `arr` is not null\e[0m\n\e[31m38 |\e[0m        \e[34m// You can assume\
    \ that `arr` is not null\e[0m\n\e[31m39 |\e[0m        \e[34m// You can assume\
    \ that `arr` is not null\e[0m\n\e[31m40 |\e[0m        \e[34m// You can assume\
    \ that `arr` is not null\e[0m\n\e[31m4"
  stdout: ''
  timestamp: 1659793397
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // You have to return a sorted list of length `k` with the maximum k\
    \ numbers in `arr`\n        arr.sortWith(_ > _).take(k.toInt)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong,\
    \ 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8489lf26.scala:27)\n\tat Problem.main(tmp8489lf26.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793384
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // Return a sorted list of length `k` with the maximum `k` numbers in\
    \ `arr`\n        arr.sortWith(_ > _).take(k.toInt)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n\
    \    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong,\
    \ -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong,\
    \ -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong,\
    \ 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong,\
    \ 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong,\
    \ 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmplwrq6nkc.scala:27)\n\tat Problem.main(tmplwrq6nkc.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793391
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // We will use a min-heap\
    \ to store the maximum k numbers.\n        // The heap will be initialized with\
    \ the first k numbers in the list.\n        // Then we will iterate through the\
    \ rest of the list and compare each number\n        // with the minimum number\
    \ in the heap. If the number is greater than the minimum\n        // number, we\
    \ will remove the minimum number and add the new number to the heap.\n       \
    \ // We will continue this process until we reach the end of the list.\n     \
    \   // Finally, we will return the heap as a sorted list.\n        val heap =\
    \ new mutable.PriorityQueue[Long]()(Ordering.by(-_))\n        for (i <- 0 until\
    \ k.toInt) {\n            heap.enqueue(arr(i))\n        }\n        for (i <- k.toInt\
    \ until arr.length) {\n            if (arr(i) > heap.head) {\n               \
    \ heap.dequeue\n                heap.enqueue(arr(i))\n            }\n        }\n\
    \        heap.toList.sorted\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpo4pbpo5b.scala:27:23 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mheap\e[0m = \e[33mnew\e\
    [0m mutable.PriorityQueue[\e[35mLong\e[0m]()(Ordering.by(-_))\n\e[31m\e[31m  \
    \ |\e[0m                       ^^^^^^^\e[0m\n\e[31m   |\e[0m                 \
    \      Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpo4pbpo5b.scala:27:65 ------------------------\e[0m\e[0m\n\e[31m27 |\e\
    [0m        \e[33mval\e[0m \e[36mheap\e[0m = \e[33mnew\e[0m mutable.PriorityQueue[\e\
    [35mLong\e[0m]()(Ordering.by(-_))\n\e[31m\e[31m   |\e[0m                     \
    \                                            ^^\e[0m\n\e[31m   |\e[0mvalue unary_-\
    \ is not a member of Any, but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress\
    \ towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- Error: /tmp/tmpo4pbpo5b.scala:27:68 -----------------------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mheap\e[0m = \e[33mnew\e\
    [0m mutable.PriorityQueue[\e[35mLong\e[0m]()(Ordering.by(-_))\n\e[31m\e[31m  \
    \ |\e[0m                                                                    ^\e\
    [0m\n\e[31m   |\e[0mambiguous given instances: both \e[33mobject\e[0m \e[35mInt\e\
    [0m in \e[33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mChar\e\
    [0m in \e[33mobject\e[0m \e[35mOrdering\e[0m match type Ordering[S] of parameter\
    \ ord of \e[33mmethod\e[0m \e[35mby\e[0m in \e[33mobject\e[0m \e[35mOrdering\e\
    [0m\n3 errors found\n"
  stdout: ''
  timestamp: 1659793398
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // You have to return a sorted list of length `k` with the maximum k\
    \ numbers in `arr`\n        // You can use the following functions:\n        //\
    \     - `arr.sorted`\n        //     - `arr.length`\n        //     - `arr.take`\n\
    \        //     - `arr.drop`\n        //     - `arr.slice`\n        //     - `arr.reverse`\n\
    \        //     - `arr.head`\n        //     - `arr.tail`\n        //     - `arr.init`\n\
    \        //     - `arr.last`\n        //     - `arr.max`\n        //     - `arr.min`\n\
    \        //     - `arr.sum`\n        //     - `arr.product`\n        //     -\
    \ `arr.contains`\n        //     - `arr.mkString`\n        //     - `arr.mkString(sep)`\n\
    \        //     - `arr.mkString(start, sep, end)`\n        //     - `arr.toString`\n\
    \        //     - `arr.toList`\n        //     - `arr.toArray`\n        //   \
    \  - `arr.toSet`\n        //     - `arr.toMap`\n        //     - `arr.toSeq`\n\
    \        //     - `arr.toIndexedSeq`\n        //     - `arr.toBuffer`\n      \
    \  //     - `arr.toIterable`\n        //     - `arr.toIterator`\n        //  \
    \   - `arr.toStream`\n        //     - `arr.toStream`\n        //     - `arr.toVector`\n\
    \        //     - `arr.to(LazyList)`\n        //     - `arr.to(List)`\n      \
    \  //     - `arr.to(Array)`\n        //     - `arr.to(Set)`\n        //     -\
    \ `arr.to(Map)`\n        //     - `arr.to(Seq)`\n        //     - `arr.to(IndexedSeq)`\n\
    \        //     - `arr.\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpkivn0wwy.scala:19:59\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m    \e[33mdef\e[0m \e[36mmaximum\e\
    [0m(\e[36marr\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mk\e[0m : \e[35mLong\e\
    [0m) : \e[35mList\e[0m[\e[35mLong\e[0m] = {\n\e[31m\e[31m   |\e[0m           \
    \                                                ^\e[0m\n\e[31m   |\e[0m     \
    \                                               Found:    Unit\n\e[31m   |\e[0m\
    \                                                    Required: List[Long]\n\e\
    [31m20 |\e[0m        \e[34m// Fill up this function body\e[0m\n\e[31m21 |\e[0m\
    \        \e[34m// `arr` is a list of integers\e[0m\n\e[31m22 |\e[0m        \e\
    [34m// `k` is a positive integer\e[0m\n\e[31m23 |\e[0m        \e[34m// You have\
    \ to return a sorted list of length `k` with the maximum k numbers in `arr`\e\
    [0m\n\e[31m24 |\e[0m        \e[34m// You can use the following functions:\e[0m\n\
    \e[31m25 |\e[0m        \e[34m//     - `arr.sorted`\e[0m\n\e[31m26 |\e[0m     \
    \   \e[34m//     - `arr.length`\e[0m\n\e[31m27 |\e[0m        \e[34m//     - `arr.take`\e\
    [0m\n\e[31m28 |\e[0m        \e[34m//     - `arr.drop`\e[0m\n\e[31m29 |\e[0m  \
    \      \e[34m//     - `arr.slice`\e[0m\n\e[31m30 |\e[0m        \e[34m//     -\
    \ `arr.reverse`\e[0m\n\e[31m31 |\e[0m        \e[34m//     - `arr.head`\e[0m\n\e\
    [31m32 |\e[0m        \e[34m//     - `arr.tail`\e[0m\n\e[31m33 |\e[0m        \e\
    [34m//     - `arr.init`\e[0m\n\e[31m34 |\e[0m        \e[34m//     - `arr.last`\e\
    [0m\n\e[31m35 |\e[0m        \e[34m//     - `arr.max`\e[0m\n\e[31m36 |\e[0m   \
    \     \e[34m//     - `arr.min`\e[0m\n\e[31m37 |\e[0m        \e[34m//     - `arr.sum`\e\
    [0m\n\e[31m38 |\e[0m        \e[34m//     - `arr.product`\e[0m\n\e[31m39 |\e[0m\
    \        \e[34m//     - `arr.contains`\e[0m\n\e[31m40 |\e[0m        \e[34m// \
    \    - `arr.mkString`\e[0m\n\e[31m41 |\e[0m        \e[34m//     - `arr.mkString(sep)`\e\
    [0m\n\e[31m42 |\e[0m        \e[34m//     - `arr.mkString(start, sep, end)`\e[0m\n\
    \e[31m43 |\e[0m        \e[34m//     - `arr.toString`\e[0m\n\e[31m44 |\e[0m   \
    \     \e[34m//     - `arr.toList`\e[0m\n\e[31m45 |\e[0m        \e[34m//     -\
    \ `arr.toArray`\e[0m\n\e[31m46 |\e[0m        \e[34m//     - `arr.toSet`\e[0m\n\
    \e[31m47 |\e[0m        \e["
  stdout: ''
  timestamp: 1659793397
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        val heap = new PriorityQueue[Long]()(Ordering.by(-_))\n\
    \        for (i <- arr) {\n            heap.enqueue(i)\n            if (heap.size\
    \ > k) heap.dequeue\n        }\n        heap.toList.sorted\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n\
    \    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong,\
    \ -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong,\
    \ -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong,\
    \ 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong,\
    \ 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong,\
    \ 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793374
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // Return a sorted list of length `k` with the maximum k numbers in `arr`\n\
    \        arr.sorted.takeRight(k.toInt)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793399
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        val heap = new Heap[Long]()\n\
    \        for (i <- 0 until k.toInt) heap.insert(arr(i))\n        for (i <- k.toInt\
    \ until arr.length) {\n            if (arr(i) > heap.peek) {\n               \
    \ heap.pop\n                heap.insert(arr(i))\n            }\n        }\n  \
    \      heap.toList\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp3ylqgkit.scala:20:23 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mheap\e[0m = \e[33mnew\e\
    [0m \e[35mHeap\e[0m[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                \
    \       ^^^^\e[0m\n\e[31m   |\e[0m                       Not found: type Heap\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659793397
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // You have to return a sorted list of length `k` with the maximum k\
    \ numbers in `arr`\n        arr.sortWith(_ > _).take(k.toInt)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong,\
    \ 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8489lf26.scala:27)\n\tat Problem.main(tmp8489lf26.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793384
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // We can use a max heap to\
    \ store the k largest elements.\n        // The heap will be of size k and will\
    \ store the k largest elements.\n        // We will iterate through the list and\
    \ if the current element is larger than the smallest element in the heap,\n  \
    \      // we will remove the smallest element and add the current element to the\
    \ heap.\n        // At the end, we will return the heap as a sorted list.\n  \
    \      // Time complexity: O(n log k)\n        // Space complexity: O(k)\n   \
    \     val heap = new PriorityQueue[Long]()(Ordering.by(-_))\n        for (i <-\
    \ arr) {\n            if (heap.size < k) heap.enqueue(i)\n            else if\
    \ (i > heap.head) {\n                heap.dequeue\n                heap.enqueue(i)\n\
    \            }\n        }\n        heap.toList.sorted\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n\
    \    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong,\
    \ -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong,\
    \ -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong,\
    \ 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong,\
    \ 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong,\
    \ 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.util.NoSuchElementException: queue is empty\n\tat scala.collection.mutable.PriorityQueue.head(PriorityQueue.scala:254)\n\
    \tat Problem$.maximum$$anonfun$1(tmpcprlodg6.scala:30)\n\tat scala.runtime.java8.JFunction1$mcVJ$sp.apply(JFunction1$mcVJ$sp.scala:18)\n\
    \tat scala.collection.immutable.List.foreach(List.scala:333)\n\tat Problem$.maximum(tmpcprlodg6.scala:34)\n\
    \tat Problem$.main(tmpcprlodg6.scala:48)\n\tat Problem.main(tmpcprlodg6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793399
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Define the maximum function\
    \ as requested above\n        def maximum(arr : List[Long], k : Long, acc : List[Long])\
    \ : List[Long] = {\n            if (k == 0) acc\n            else {\n        \
    \        val max = arr.max\n                maximum(arr.filter(_ != max), k -\
    \ 1, acc :+ max)\n            }\n        }\n        // Return the result of calling\
    \ maximum with the correct arguments\n        maximum(arr, k, List[Long]())\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmppkeyuhk5.scala:32)\n\tat Problem.main(tmppkeyuhk5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793399
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // You have to return a sorted list of length `k` with the maximum k\
    \ numbers in `arr`\n        // You can assume that `k` is less than or equal to\
    \ the length of `arr`\n        // You can assume that `k` is greater than 0\n\
    \        // You can assume that `arr` is not empty\n        // You can assume\
    \ that `arr` is not null\n        // You can assume that `arr` does not contain\
    \ null elements\n        // You can assume that `arr` is not a string\n      \
    \  // You can assume that `arr` is not a dictionary\n        // You can assume\
    \ that `arr` is not a set\n        // You can assume that `arr` is not a tuple\n\
    \        // You can assume that `arr` is not a range\n        // You can assume\
    \ that `arr` is not a matrix\n        // You can assume that `arr` is not a 2D\
    \ array\n        // You can assume that `arr` is not a 3D array\n        // You\
    \ can assume that `arr` is not a 4D array\n        // You can assume that `arr`\
    \ is not a 5D array\n        // You can assume that `arr` is not a 6D array\n\
    \        // You can assume that `arr` is not a 7D array\n        // You can assume\
    \ that `arr` is not a 8D array\n        // You can assume that `arr` is not a\
    \ 9D array\n        // You can assume that `arr` is not a 10D array\n        //\
    \ You can assume that `arr` is not a 11D array\n        // You can assume that\
    \ `arr` is not a 12D array\n        // You can assume that `arr` is not a 13D\
    \ array\n        // You can assume that `arr` is not a 14D array\n        // You\
    \ can assume that `arr` is not a 15D array\n        // You can assume that `arr`\
    \ is not a 16D array\n        // You can assume that `arr` is not a 17D array\n\
    \        // You can assume that `arr` is not a 18D array\n        // You can assume\
    \ that `arr` is not a 19D array\n        // You can assume that `arr`\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpy2uef61b.scala:19:59\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m    \e[33mdef\e[0m \e[36mmaximum\e\
    [0m(\e[36marr\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mk\e[0m : \e[35mLong\e\
    [0m) : \e[35mList\e[0m[\e[35mLong\e[0m] = {\n\e[31m\e[31m   |\e[0m           \
    \                                                ^\e[0m\n\e[31m   |\e[0m     \
    \                                               Found:    Unit\n\e[31m   |\e[0m\
    \                                                    Required: List[Long]\n\e\
    [31m20 |\e[0m        \e[34m// Fill up this function body\e[0m\n\e[31m21 |\e[0m\
    \        \e[34m// `arr` is a list of integers\e[0m\n\e[31m22 |\e[0m        \e\
    [34m// `k` is a positive integer\e[0m\n\e[31m23 |\e[0m        \e[34m// You have\
    \ to return a sorted list of length `k` with the maximum k numbers in `arr`\e\
    [0m\n\e[31m24 |\e[0m        \e[34m// You can assume that `k` is less than or equal\
    \ to the length of `arr`\e[0m\n\e[31m25 |\e[0m        \e[34m// You can assume\
    \ that `k` is greater than 0\e[0m\n\e[31m26 |\e[0m        \e[34m// You can assume\
    \ that `arr` is not empty\e[0m\n\e[31m27 |\e[0m        \e[34m// You can assume\
    \ that `arr` is not null\e[0m\n\e[31m28 |\e[0m        \e[34m// You can assume\
    \ that `arr` does not contain null elements\e[0m\n\e[31m29 |\e[0m        \e[34m//\
    \ You can assume that `arr` is not a string\e[0m\n\e[31m30 |\e[0m        \e[34m//\
    \ You can assume that `arr` is not a dictionary\e[0m\n\e[31m31 |\e[0m        \e\
    [34m// You can assume that `arr` is not a set\e[0m\n\e[31m32 |\e[0m        \e\
    [34m// You can assume that `arr` is not a tuple\e[0m\n\e[31m33 |\e[0m        \e\
    [34m// You can assume that `arr` is not a range\e[0m\n\e[31m34 |\e[0m        \e\
    [34m// You can assume that `arr` is not a matrix\e[0m\n\e[31m35 |\e[0m       \
    \ \e[34m// You can assume that `arr` is not a 2D array\e[0m\n\e[31m36 |\e[0m \
    \       \e[34m// You can assume that `arr` is not a 3D array\e[0m\n\e[31m37 |\e\
    [0m        \e[34m// You can assume that `arr` is not a 4D array\e[0m\n\e[31m38\
    \ |\e[0m        \e[34m// You can assume that `arr` is not a 5D array\e[0m\n\e\
    [31m39 |\e[0m        \e[34m// You can assume that `arr` is not a 6D array\e[0m\n\
    \e[31m"
  stdout: ''
  timestamp: 1659793399
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // You have to return a sorted list of length `k` with the maximum k\
    \ numbers in `arr`\n        // You can assume that `k` is less than or equal to\
    \ the length of `arr`\n        // You can assume that `k` is greater than 0\n\
    \        arr.sorted.takeRight(k.toInt)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793374
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // We can use a heap to solve\
    \ this problem.\n        // The heap will be a max heap.\n        // We will add\
    \ all elements to the heap.\n        // If the heap size is greater than k, we\
    \ will remove the max element from the heap.\n        // When we are done, we\
    \ will return the elements in the heap in reverse order.\n        val heap = new\
    \ PriorityQueue[Long]()(Ordering.Long.reverse)\n        for (i <- arr) {\n   \
    \         heap.enqueue(i)\n            if (heap.size > k) heap.dequeue\n     \
    \   }\n        heap.toList.reverse\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpur1esxu9.scala:33)\n\tat Problem.main(tmpur1esxu9.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793400
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // 'return List[Long]()' for Scala and 'return new ArrayList<Long>()'\
    \ for Java\n        return List[Long]()\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7g5a4ppi.scala:25)\n\tat Problem.main(tmp7g5a4ppi.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793379
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // We can use a priority queue\
    \ to solve this problem.\n        // We will add the first k elements to the priority\
    \ queue.\n        // Then we will iterate through the rest of the elements.\n\
    \        // If the element is greater than the minimum element in the priority\
    \ queue,\n        // we will remove the minimum element and add the new element.\n\
    \        // Then we will return the elements in the priority queue.\n        val\
    \ pq = new PriorityQueue[Long]()(Ordering.Long.reverse)\n        for (i <- 0l\
    \ until k) {\n            pq.enqueue(arr(i.toInt))\n        }\n        for (i\
    \ <- k until arr.length) {\n            if (arr(i.toInt) > pq.head) {\n      \
    \          pq.dequeue\n                pq.enqueue(arr(i.toInt))\n            }\n\
    \        }\n        pq.toList\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpaat773de.scala:42)\n\tat Problem.main(tmpaat773de.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793400
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        val heap = new PriorityQueue[Long]()(Ordering.by(-_))\n\
    \        for (i <- arr) {\n            heap.enqueue(i)\n            if (heap.size\
    \ > k) heap.dequeue\n        }\n        heap.toList.reverse\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n\
    \    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong,\
    \ -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong,\
    \ -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong,\
    \ 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong,\
    \ 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong,\
    \ 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpt1nu4guf.scala:28)\n\tat Problem.main(tmpt1nu4guf.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793400
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // return a sorted list of length `k` with the maximum `k` numbers in\
    \ `arr`\n        arr.sortWith(_ > _).take(k.toInt)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n\
    \    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong,\
    \ -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong,\
    \ -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong,\
    \ 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong,\
    \ 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong,\
    \ 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpaumru7pg.scala:27)\n\tat Problem.main(tmpaumru7pg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793374
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Given a list arr of integers\
    \ and a positive integer k, return a sorted list \n        // of length k with\
    \ the maximum k numbers in arr.\n        // Example 1:\n        // >>> maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l))\n        // (List[Long](-4l.toLong, -3l.toLong,\
    \ 5l.toLong))\n        // Example 2:\n        // >>> maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l))\n        // (List[Long](4l.toLong, 4l.toLong))\n\
    \        // Example 3:\n        // >>> maximum((List[Long](-3l.toLong, 2l.toLong,\
    \ 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n        //\
    \ (List[Long](2l.toLong))\n        // Note:\n        // 1. The length of the list\
    \ will be in the range of [1, 1000].\n        // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n        // 3. 0 <= k <= len(arr)\n      \
    \  def maximum(arr : List[Long], k : Long) : List[Long] = {\n            // Given\
    \ a list arr of integers and a positive integer k, return a sorted list \n   \
    \         // of length k with the maximum k numbers in arr.\n            // Example\
    \ 1:\n            // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n            // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    \
    \        // Example 2:\n            // >>> maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l))\n            // (List[Long](4l.toLong, 4l.toLong))\n    \
    \        // Example 3:\n            // >>> maximum((List[Long](-3l.toLong, 2l.toLong,\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp81eyir6w.scala:62:0 ----------------------------\e\
    [0m\e[0m\n\e[31m62 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp81eyir6w.scala:35:63\
    \ --------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mdef\e[0m \e[36mmaximum\e\
    [0m(\e[36marr\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mk\e[0m : \e[35mLong\e\
    [0m) : \e[35mList\e[0m[\e[35mLong\e[0m] = {\n\e[31m\e[31m   |\e[0m           \
    \                                                    ^\e[0m\n\e[31m   |\e[0m \
    \                                                   Found:    Unit\n\e[31m   |\e\
    [0m                                                    Required: List[Long]\n\e\
    [31m36 |\e[0m            \e[34m// Given a list arr of integers and a positive\
    \ integer k, return a sorted list \e[0m\n\e[31m37 |\e[0m            \e[34m// of\
    \ length k with the maximum k numbers in arr.\e[0m\n\e[31m38 |\e[0m          \
    \  \e[34m// Example 1:\e[0m\n\e[31m39 |\e[0m            \e[34m// >>> maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l))\e[0m\n\e[31m40 |\e[0m            \e[34m// (List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))\e[0m\n\e[31m41 |\e[0m            \e[34m// Example 2:\e\
    [0m\n\e[31m42 |\e[0m            \e[34m// >>> maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l))\e[0m\n\e[31m43 |\e[0m            \e[34m// (List[Long](4l.toLong,\
    \ 4l.toLong))\e[0m\n\e[31m44 |\e[0m            \e[34m// Example 3:\e[0m\n\e[31m45\
    \ |\e[0m            \e[34m// >>> maximum((List[Long](-3l.toLong, 2l.toLong,\e\
    [0m\n\e[31m46 |\e[0m    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp81eyir6w.scala:61:1 ---------------------\e[0m\e[0m\n\e[31m61\
    \ |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:    Unit\n\e[31m\
    \   |\e[0m Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[33m\e[33m-- Warning: /tmp/tmp81eyir6w.scala:47:4\
    \ ----------------------------------------\e[0m\e[0m\n\e[33m47 |\e[0m    \e[33mdef\e\
    [0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e[0"
  stdout: ''
  timestamp: 1659793390
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // You can add another function as well, if required\n        arr.sorted.takeRight(k.toInt)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793374
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // You have to return a sorted list of length `k` with the maximum k\
    \ numbers in `arr`\n        // You can assume that `k` is less than or equal to\
    \ the length of `arr`\n        // You can assume that `k` is greater than 0\n\
    \        arr.sortWith(_ > _).take(k.toInt)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpucwkl69k.scala:29)\n\tat Problem.main(tmpucwkl69k.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793374
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is the number of elements\
    \ to return\n        // You can return a list of integers\n        // You can\
    \ use the `println` function to debug\n        // Example:\n        // println(arr)\n\
    \        // println(k)\n        // println(arr.length)\n        // println(arr(0))\n\
    \        // println(arr(1))\n        // println(arr(2))\n        // println(arr(3))\n\
    \        // println(arr(4))\n        // println(arr(5))\n        // println(arr(6))\n\
    \        // println(arr(7))\n        // println(arr(8))\n        // println(arr(9))\n\
    \        // println(arr(10))\n        // println(arr(11))\n        // println(arr(12))\n\
    \        // println(arr(13))\n        // println(arr(14))\n        // println(arr(15))\n\
    \        // println(arr(16))\n        // println(arr(17))\n        // println(arr(18))\n\
    \        // println(arr(19))\n        // println(arr(20))\n        // println(arr(21))\n\
    \        // println(arr(22))\n        // println(arr(23))\n        // println(arr(24))\n\
    \        // println(arr(25))\n        // println(arr(26))\n        // println(arr(27))\n\
    \        // println(arr(28))\n        // println(arr(29))\n        // println(arr(30))\n\
    \        // println(arr(31))\n        // println(arr(32))\n        // println(arr(33))\n\
    \        // println(arr(34))\n        // println(arr(35))\n        // println(arr(36))\n\
    \        // println(arr(37))\n        // println(arr(38))\n        // println(arr(39))\n\
    \        // println(arr(40))\n        // println(arr(41))\n        // println(arr(42))\n\
    \        // println(arr(43))\n        // println(arr(44))\n        // println(arr(45))\n\
    \        // println(arr(46))\n        // println(arr\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n\
    \    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong,\
    \ -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong,\
    \ -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong,\
    \ 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong,\
    \ 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong,\
    \ 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpiwffdnjz.scala:19:59\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m    \e[33mdef\e[0m \e[36mmaximum\e\
    [0m(\e[36marr\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mk\e[0m : \e[35mLong\e\
    [0m) : \e[35mList\e[0m[\e[35mLong\e[0m] = {\n\e[31m\e[31m   |\e[0m           \
    \                                                ^\e[0m\n\e[31m   |\e[0m     \
    \                                               Found:    Unit\n\e[31m   |\e[0m\
    \                                                    Required: List[Long]\n\e\
    [31m20 |\e[0m        \e[34m// Fill up this function body\e[0m\n\e[31m21 |\e[0m\
    \        \e[34m// `arr` is a list of integers\e[0m\n\e[31m22 |\e[0m        \e\
    [34m// `k` is the number of elements to return\e[0m\n\e[31m23 |\e[0m        \e\
    [34m// You can return a list of integers\e[0m\n\e[31m24 |\e[0m        \e[34m//\
    \ You can use the `println` function to debug\e[0m\n\e[31m25 |\e[0m        \e\
    [34m// Example:\e[0m\n\e[31m26 |\e[0m        \e[34m// println(arr)\e[0m\n\e[31m27\
    \ |\e[0m        \e[34m// println(k)\e[0m\n\e[31m28 |\e[0m        \e[34m// println(arr.length)\e\
    [0m\n\e[31m29 |\e[0m        \e[34m// println(arr(0))\e[0m\n\e[31m30 |\e[0m   \
    \     \e[34m// println(arr(1))\e[0m\n\e[31m31 |\e[0m        \e[34m// println(arr(2))\e\
    [0m\n\e[31m32 |\e[0m        \e[34m// println(arr(3))\e[0m\n\e[31m33 |\e[0m   \
    \     \e[34m// println(arr(4))\e[0m\n\e[31m34 |\e[0m        \e[34m// println(arr(5))\e\
    [0m\n\e[31m35 |\e[0m        \e[34m// println(arr(6))\e[0m\n\e[31m36 |\e[0m   \
    \     \e[34m// println(arr(7))\e[0m\n\e[31m37 |\e[0m        \e[34m// println(arr(8))\e\
    [0m\n\e[31m38 |\e[0m        \e[34m// println(arr(9))\e[0m\n\e[31m39 |\e[0m   \
    \     \e[34m// println(arr(10))\e[0m\n\e[31m40 |\e[0m        \e[34m// println(arr(11))\e\
    [0m\n\e[31m41 |\e[0m        \e[34m// println(arr(12))\e[0m\n\e[31m42 |\e[0m  \
    \      \e[34m// println(arr(13))\e[0m\n\e[31m43 |\e[0m        \e[34m// println(arr(14))\e\
    [0m\n\e[31m44 |\e[0m        \e[34m// println(arr(15))\e[0m\n\e[31m45 |\e[0m  \
    \      \e[34m// println(arr(16))\e[0m\n\e[31m46 |\e[0m        \e[34m// println(arr(17))\e\
    [0m\n\e[31m47 |\e[0m        \e[34m// println(arr(18))\e[0m\n\e[31m48 |\e[0m  \
    \      \e[34m// println(arr(19))\e[0m\n\e[31m49 |\e[0m        \e[34m// pri"
  stdout: ''
  timestamp: 1659793400
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // We can use a heap to solve\
    \ this problem.\n        // We can use a min-heap to store the maximum k numbers.\n\
    \        // We can use a max-heap to store the minimum k numbers.\n        //\
    \ We can use a min-heap to store the maximum k numbers.\n        // We can use\
    \ a max-heap to store the minimum k numbers.\n        // We can use a min-heap\
    \ to store the maximum k numbers.\n        // We can use a max-heap to store the\
    \ minimum k numbers.\n        // We can use a min-heap to store the maximum k\
    \ numbers.\n        // We can use a max-heap to store the minimum k numbers.\n\
    \        // We can use a min-heap to store the maximum k numbers.\n        //\
    \ We can use a max-heap to store the minimum k numbers.\n        // We can use\
    \ a min-heap to store the maximum k numbers.\n        // We can use a max-heap\
    \ to store the minimum k numbers.\n        // We can use a min-heap to store the\
    \ maximum k numbers.\n        // We can use a max-heap to store the minimum k\
    \ numbers.\n        // We can use a min-heap to store the maximum k numbers.\n\
    \        // We can use a max-heap to store the minimum k numbers.\n        //\
    \ We can use a min-heap to store the maximum k numbers.\n        // We can use\
    \ a max-heap to store the minimum k numbers.\n        // We can use a min-heap\
    \ to store the maximum k numbers.\n        // We can use a max-heap to store the\
    \ minimum k numbers.\n        // We can use a min-heap to store the maximum k\
    \ numbers.\n        // We can use a max-heap to store the minimum k numbers.\n\
    \        // We can use a min-heap to store the maximum k numbers.\n        //\
    \ We can use a max-heap to store the minimum k numbers.\n        // We can use\
    \ a min-heap to store the maximum k numbers.\n        // We can use a max-heap\
    \ to store the minimum k numbers.\n        // We can use a min-heap to store the\
    \ maximum k numbers.\n        // We can use a max-heap to store\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong,\
    \ 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpvkx00rmg.scala:19:59\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m    \e[33mdef\e[0m \e[36mmaximum\e\
    [0m(\e[36marr\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mk\e[0m : \e[35mLong\e\
    [0m) : \e[35mList\e[0m[\e[35mLong\e[0m] = {\n\e[31m\e[31m   |\e[0m           \
    \                                                ^\e[0m\n\e[31m   |\e[0m     \
    \                                               Found:    Unit\n\e[31m   |\e[0m\
    \                                                    Required: List[Long]\n\e\
    [31m20 |\e[0m        \e[34m// We can use a heap to solve this problem.\e[0m\n\e\
    [31m21 |\e[0m        \e[34m// We can use a min-heap to store the maximum k numbers.\e\
    [0m\n\e[31m22 |\e[0m        \e[34m// We can use a max-heap to store the minimum\
    \ k numbers.\e[0m\n\e[31m23 |\e[0m        \e[34m// We can use a min-heap to store\
    \ the maximum k numbers.\e[0m\n\e[31m24 |\e[0m        \e[34m// We can use a max-heap\
    \ to store the minimum k numbers.\e[0m\n\e[31m25 |\e[0m        \e[34m// We can\
    \ use a min-heap to store the maximum k numbers.\e[0m\n\e[31m26 |\e[0m       \
    \ \e[34m// We can use a max-heap to store the minimum k numbers.\e[0m\n\e[31m27\
    \ |\e[0m        \e[34m// We can use a min-heap to store the maximum k numbers.\e\
    [0m\n\e[31m28 |\e[0m        \e[34m// We can use a max-heap to store the minimum\
    \ k numbers.\e[0m\n\e[31m29 |\e[0m        \e[34m// We can use a min-heap to store\
    \ the maximum k numbers.\e[0m\n\e[31m30 |\e[0m        \e[34m// We can use a max-heap\
    \ to store the minimum k numbers.\e[0m\n\e[31m31 |\e[0m        \e[34m// We can\
    \ use a min-heap to store the maximum k numbers.\e[0m\n\e[31m32 |\e[0m       \
    \ \e[34m// We can use a max-heap to store the minimum k numbers.\e[0m\n\e[31m33\
    \ |\e[0m        \e[34m// We can use a min-heap to store the maximum k numbers.\e\
    [0m\n\e[31m34 |\e[0m        \e[34m// We can use a max-heap to store the minimum\
    \ k numbers.\e[0m\n\e[31m35 |\e[0m        \e[34m// We can use a min-heap to store\
    \ the maximum k numbers.\e[0m\n\e[31m36 |\e[0m        \e[34m// We can use a max-heap\
    \ to store the minimum k numbers.\e[0m\n\e[31m37 |\e[0m        \e[34m// We can\
    \ use a min-heap to store the maximum k numbe"
  stdout: ''
  timestamp: 1659793400
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // You have to return a sorted list of length `k` with the maximum k\
    \ numbers in `arr`\n        arr.sorted.takeRight(k.toInt)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n\
    \    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong,\
    \ -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong,\
    \ -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong,\
    \ 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong,\
    \ 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong,\
    \ 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793385
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        arr.sortWith(_ > _).take(k.toInt)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxq0tmyg3.scala:23)\n\tat Problem.main(tmpxq0tmyg3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793401
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // You have to return a sorted list of length `k` with the maximum k\
    \ numbers in `arr`\n        arr.sorted.takeRight(k.toInt)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n\
    \    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong,\
    \ -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong,\
    \ -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong,\
    \ 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong,\
    \ 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong,\
    \ 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793385
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // We can use a max heap to\
    \ solve this problem.\n        // The max heap will store the k largest elements\
    \ in the array.\n        // We will iterate through the array, and if the current\
    \ element is larger than the smallest element in the heap,\n        // we will\
    \ remove the smallest element from the heap and add the current element to the\
    \ heap.\n        // After iterating through the array, we will return the heap.\n\
    \        val heap = new MaxHeap[Long](k.toInt)\n        for (element <- arr) {\n\
    \            if (heap.size < k) heap.insert(element)\n            else if (element\
    \ > heap.peek) {\n                heap.remove()\n                heap.insert(element)\n\
    \            }\n        }\n        heap.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmptn7psvrq.scala:25:23 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mheap\e[0m = \e[33mnew\e\
    [0m \e[35mMaxHeap\e[0m[\e[35mLong\e[0m](k.toInt)\n\e[31m\e[31m   |\e[0m      \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                       Not found:\
    \ type MaxHeap\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659793400
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Your code here\n      \
    \  return List[Long]()\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpr77qf_5j.scala:24)\n\tat Problem.main(tmpr77qf_5j.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793401
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // You have to return a sorted list of length `k` with the maximum k\
    \ numbers in `arr`\n        // You can assume that `k` is less than or equal to\
    \ the length of `arr`\n        // You can assume that `k` is greater than 0\n\
    \        val heap = new Heap[Long]\n        for (i <- arr) {\n            heap.insert(i)\n\
    \        }\n        val result = new ListBuffer[Long]\n        for (i <- 0 until\
    \ k.toInt) {\n            result += heap.extractMax\n        }\n        result.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpkntsg1m9.scala:26:23 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mheap\e[0m = \e[33mnew\e\
    [0m \e[35mHeap\e[0m[\e[35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                  \
    \     ^^^^\e[0m\n\e[31m   |\e[0m                       Not found: type Heap\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659793400
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // You have to return a sorted list of length `k` with the maximum k\
    \ numbers in `arr`\n        // You can assume that `k` is less than or equal to\
    \ the length of `arr`\n        // You can assume that `k` is greater than 0\n\
    \        arr.sorted.takeRight(k.toInt)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793374
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // Return a sorted list of length `k` with the maximum k numbers in `arr`\n\
    \        arr.sorted.takeRight(k.toInt)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793399
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // You have to return a sorted list of length `k` with the maximum k\
    \ numbers in `arr`\n        // You can assume that `k` is less than or equal to\
    \ the length of `arr`\n        // You can assume that `k` is greater than 0\n\
    \        arr.sorted.takeRight(k.toInt)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793374
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // return a sorted list of length `k` with the maximum `k` numbers in\
    \ `arr`\n        arr.sorted.takeRight(k.toInt)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793374
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // You have to return a sorted list of length `k` with the maximum k\
    \ numbers in `arr`\n        // You can assume that `k` is less than or equal to\
    \ the length of `arr`\n        // You can assume that `k` is greater than 0\n\
    \        // You can assume that `arr` is not empty\n        // You can assume\
    \ that `arr` is not null\n        // You can assume that `arr` does not contain\
    \ null\n        // You can assume that `arr` does not contain duplicates\n   \
    \     // You can assume that `arr` is sorted in descending order\n        // You\
    \ can assume that `arr` is sorted in ascending order\n        // You can assume\
    \ that `arr` is sorted in non-decreasing order\n        // You can assume that\
    \ `arr` is sorted in non-increasing order\n        // You can assume that `arr`\
    \ is sorted in random order\n        // You can assume that `arr` is sorted in\
    \ non-random order\n        // You can assume that `arr` is not sorted\n     \
    \   // You can assume that `arr` is sorted in non-ascending order\n        //\
    \ You can assume that `arr` is sorted in non-descending order\n        // You\
    \ can assume that `arr` is sorted in non-random non-ascending order\n        //\
    \ You can assume that `arr` is sorted in non-random non-descending order\n   \
    \     // You can assume that `arr` is sorted in non-random non-increasing order\n\
    \        // You can assume that `arr` is sorted in non-random non-decreasing order\n\
    \        // You can assume that `arr` is sorted in random non-ascending order\n\
    \        // You can assume that `arr` is sorted in random non-descending order\n\
    \        // You can assume that `arr` is sorted in random non-increasing order\n\
    \        // You can assume that `arr` is sorted in random non-decreasing order\n\
    \        // You can assume that `arr` is sorted in non-random non-ascending non-descending\
    \ order\n        // You can assume that `arr` is sorted in non-random non-ascending\
    \ non-increasing order\n        // You can assume that `arr` is sorted\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsckrnrd6.scala:19:59\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m    \e[33mdef\e[0m \e[36mmaximum\e\
    [0m(\e[36marr\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mk\e[0m : \e[35mLong\e\
    [0m) : \e[35mList\e[0m[\e[35mLong\e[0m] = {\n\e[31m\e[31m   |\e[0m           \
    \                                                ^\e[0m\n\e[31m   |\e[0m     \
    \                                               Found:    Unit\n\e[31m   |\e[0m\
    \                                                    Required: List[Long]\n\e\
    [31m20 |\e[0m        \e[34m// Fill up this function body\e[0m\n\e[31m21 |\e[0m\
    \        \e[34m// `arr` is a list of integers\e[0m\n\e[31m22 |\e[0m        \e\
    [34m// `k` is a positive integer\e[0m\n\e[31m23 |\e[0m        \e[34m// You have\
    \ to return a sorted list of length `k` with the maximum k numbers in `arr`\e\
    [0m\n\e[31m24 |\e[0m        \e[34m// You can assume that `k` is less than or equal\
    \ to the length of `arr`\e[0m\n\e[31m25 |\e[0m        \e[34m// You can assume\
    \ that `k` is greater than 0\e[0m\n\e[31m26 |\e[0m        \e[34m// You can assume\
    \ that `arr` is not empty\e[0m\n\e[31m27 |\e[0m        \e[34m// You can assume\
    \ that `arr` is not null\e[0m\n\e[31m28 |\e[0m        \e[34m// You can assume\
    \ that `arr` does not contain null\e[0m\n\e[31m29 |\e[0m        \e[34m// You can\
    \ assume that `arr` does not contain duplicates\e[0m\n\e[31m30 |\e[0m        \e\
    [34m// You can assume that `arr` is sorted in descending order\e[0m\n\e[31m31\
    \ |\e[0m        \e[34m// You can assume that `arr` is sorted in ascending order\e\
    [0m\n\e[31m32 |\e[0m        \e[34m// You can assume that `arr` is sorted in non-decreasing\
    \ order\e[0m\n\e[31m33 |\e[0m        \e[34m// You can assume that `arr` is sorted\
    \ in non-increasing order\e[0m\n\e[31m34 |\e[0m        \e[34m// You can assume\
    \ that `arr` is sorted in random order\e[0m\n\e[31m35 |\e[0m        \e[34m// You\
    \ can assume that `arr` is sorted in non-random order\e[0m\n\e[31m36 |\e[0m  \
    \      \e[34m// You can assume that `arr` is not sorted\e[0m\n\e[31m37 |\e[0m\
    \        \e[34m// You can assume that `arr` is sorted in non-ascending order\e\
    [0m\n\e[31m38 |\e[0m        \e[34m// You can assume that `arr` is s"
  stdout: ''
  timestamp: 1659793400
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // You have to return a sorted list of length `k` with the maximum k\
    \ numbers in `arr`\n        // You can assume that `k` is less than or equal to\
    \ the length of `arr`\n        // You can assume that `k` is greater than 0\n\
    \        val n = arr.length\n        val heap = new Heap[Long](n)\n        for\
    \ (i <- 0 until n) heap.insert(arr(i))\n        val result = new Array[Long](k.toInt)\n\
    \        for (i <- 0 until k.toInt) result(i) = heap.extractMax\n        result.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp1945vzq_.scala:27:23 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mheap\e[0m = \e[33mnew\e\
    [0m \e[35mHeap\e[0m[\e[35mLong\e[0m](n)\n\e[31m\e[31m   |\e[0m               \
    \        ^^^^\e[0m\n\e[31m   |\e[0m                       Not found: type Heap\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659793400
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // You have to return a sorted list of length `k` with the maximum k\
    \ numbers in `arr`\n        arr.sorted.takeRight(k.toInt)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n\
    \    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong,\
    \ -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong,\
    \ -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong,\
    \ 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong,\
    \ 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong,\
    \ 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793385
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // We can use a heap to solve\
    \ this problem.\n        // We can use a max heap to store the first k elements\
    \ of the list.\n        // Then, we can iterate through the rest of the list and\
    \ compare each element to the root of the heap.\n        // If the element is\
    \ greater than the root, we can remove the root and add the element to the heap.\n\
    \        // After we have iterated through the entire list, we can return the\
    \ heap.\n        // This will take O(n log k) time and O(k) space.\n        val\
    \ heap = new mutable.PriorityQueue[Long]()\n        for (i <- 0 until k.toInt)\
    \ {\n            heap.enqueue(arr(i))\n        }\n        for (i <- k.toInt until\
    \ arr.length) {\n            if (arr(i) > heap.head) {\n                heap.dequeue\n\
    \                heap.enqueue(arr(i))\n            }\n        }\n        heap.toList.sorted\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp3tnngg67.scala:26:23 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mheap\e[0m = \e[33mnew\e\
    [0m mutable.PriorityQueue[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m          \
    \             ^^^^^^^\e[0m\n\e[31m   |\e[0m                       Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659793400
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // You have to return a sorted list of length `k` with the maximum k\
    \ numbers in `arr`\n        // If `k` is greater than the length of `arr`, return\
    \ the entire list `arr` sorted\n        // If `k` is zero, return an empty list\n\
    \        // The elements in the list will be in the range of [-1000, 1000]\n \
    \       // The range of the length of the list will be in the range of [1, 1000]\n\
    \        // 0 <= k <= len(arr)\n        arr.sorted.takeRight(k.toInt)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793401
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // 'arr' is a list of integers\n        // 'k' is a positive integer\n\
    \        // Return a sorted list of length 'k' with the maximum 'k' numbers in\
    \ 'arr'\n        arr.sorted.takeRight(k.toInt)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793374
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // You have to return a sorted list of length `k` with the maximum k\
    \ numbers in `arr`\n        // You can assume that `k` is always valid, 1 \u2264\
    \ k \u2264 arr.length\n        // If there are multiple answers, return the answer\
    \ that comes first in the array.\n        // If there is no answer, return an\
    \ empty list.\n        arr.sorted.takeRight(k.toInt).reverse\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n\
    \    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong,\
    \ -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong,\
    \ -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong,\
    \ 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong,\
    \ 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong,\
    \ 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp655y4tv6.scala:30)\n\tat Problem.main(tmp655y4tv6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793401
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // Return a sorted list of length `k` with the maximum k numbers in `arr`\n\
    \        arr.sorted.takeRight(k.toInt)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793399
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers and a positive integer k, return a sorted\
    \ list \n    // of length k with the maximum k numbers in arr.\n    // Example\
    \ 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n \
    \   // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n   \
    \ // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the list will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // 'return List[Long]()' for Scala and 'return new ArrayList<Long>()'\
    \ for Java\n        return List[Long]()\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7g5a4ppi.scala:25)\n\tat Problem.main(tmp7g5a4ppi.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793379
