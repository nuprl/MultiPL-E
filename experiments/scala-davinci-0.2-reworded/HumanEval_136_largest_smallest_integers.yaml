name: HumanEval_136_largest_smallest_integers
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Create a function that returns a tuple (a, b), where 'a' is\n    // the\
  \ largest of negative integers, and 'b' is the smallest\n    // of positive integers\
  \ in a list.\n    // If there is no negative or positive integers, return them as\
  \ None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
  \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
  \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
  \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n   \
  \ // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
  \ : Tuple2[Option[Long], Option[Long]] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
  \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n\
  \    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
  \ 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None), Some(1l))));\n\
  \    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
  \ 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n    assert(largestSmallestIntegers((List[Long](4l.toLong,\
  \ 5l.toLong, 3l.toLong, 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l,\
  \ 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong, 3l.toLong, 8l.toLong,\
  \ 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l, 2l)));\n\
  \    assert(largestSmallestIntegers((List[Long]())).equals((Some(None), Some(None))));\n\
  \    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
  \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
  \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
  \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
  \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
  \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
  \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l, 1l)));\n\
  \    }\n\n}\n"
completions: ["        // Fill in the code here\n        var largestNegative = Option.empty[Long]\n\
    \        var smallestPositive = Option.empty[Long]\n        for (i <- lst) {\n\
    \            if (i < 0) {\n                if (largestNegative.isEmpty) {\n  \
    \                  largestNegative = Some(i)\n                } else {\n     \
    \               if (i > largestNegative.get) {\n                        largestNegative\
    \ = Some(i)\n                    }\n                }\n            } else if (i\
    \ > 0) {\n                if (smallestPositive.isEmpty) {\n                  \
    \  smallestPositive = Some(i)\n                } else {\n                    if\
    \ (i < smallestPositive.get) {\n                        smallestPositive = Some(i)\n\
    \                    }\n                }\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        // Fill in the code here\n        (None, None)",
  "        var largestNegative : Option[Long] = None\n        var smallestPositive\
    \ : Option[Long] = None\n        for (i <- lst) {\n            if (i < 0) {\n\
    \                if (largestNegative == None) largestNegative = Some(i)\n    \
    \            else if (i > largestNegative.get) largestNegative = Some(i)\n   \
    \         }\n            else if (i > 0) {\n                if (smallestPositive\
    \ == None) smallestPositive = Some(i)\n                else if (i < smallestPositive.get)\
    \ smallestPositive = Some(i)\n            }\n        }\n        return (largestNegative,\
    \ smallestPositive)", "        // Fill in the code here\n        var maxNeg =\
    \ None:Option[Long]\n        var minPos = None:Option[Long]\n        for (i <-\
    \ lst) {\n            if (i < 0) {\n                if (maxNeg == None) maxNeg\
    \ = Some(i)\n                else if (i > maxNeg.get) maxNeg = Some(i)\n     \
    \       }\n            else if (i > 0) {\n                if (minPos == None)\
    \ minPos = Some(i)\n                else if (i < minPos.get) minPos = Some(i)\n\
    \            }\n        }\n        return (maxNeg, minPos)", "        // Fill\
    \ in the code here\n        var neg = List[Long]()\n        var pos = List[Long]()\n\
    \        for (i <- lst) {\n            if (i < 0) neg = i :: neg\n           \
    \ else if (i > 0) pos = i :: pos\n        }\n        (if (neg.length == 0) None\
    \ else Some(neg.max), if (pos.length == 0) None else Some(pos.min))", "      \
    \  var largestNegative : Option[Long] = None\n        var smallestPositive : Option[Long]\
    \ = None\n        for (i <- lst) {\n            if (i < 0) {\n               \
    \ if (largestNegative == None) {\n                    largestNegative = Some(i)\n\
    \                } else {\n                    if (i > largestNegative.get) {\n\
    \                        largestNegative = Some(i)\n                    }\n  \
    \              }\n            } else if (i > 0) {\n                if (smallestPositive\
    \ == None) {\n                    smallestPositive = Some(i)\n               \
    \ } else {\n                    if (i < smallestPositive.get) {\n            \
    \            smallestPositive = Some(i)\n                    }\n             \
    \   }\n            }\n        }\n        return (largestNegative, smallestPositive)",
  "        // Fill in the code here\n        val neg = lst.filter(_ < 0)\n       \
    \ val pos = lst.filter(_ > 0)\n        val negMax = if (neg.isEmpty) None else\
    \ Some(neg.max)\n        val posMin = if (pos.isEmpty) None else Some(pos.min)\n\
    \        (negMax, posMin)", "        // Fill in the code here\n        var maxNeg\
    \ = None : Option[Long]\n        var minPos = None : Option[Long]\n        for\
    \ (i <- lst) {\n            if (i < 0) {\n                if (maxNeg == None)\
    \ maxNeg = Some(i)\n                else maxNeg = Some(max(maxNeg.get, i))\n \
    \           }\n            else if (i > 0) {\n                if (minPos == None)\
    \ minPos = Some(i)\n                else minPos = Some(min(minPos.get, i))\n \
    \           }\n        }\n        (maxNeg, minPos)", "        var largestNegative\
    \ : Option[Long] = None\n        var smallestPositive : Option[Long] = None\n\
    \        for (i <- lst) {\n            if (i < 0) {\n                if (largestNegative\
    \ == None) largestNegative = Some(i)\n                else if (i > largestNegative.get)\
    \ largestNegative = Some(i)\n            }\n            else if (i > 0) {\n  \
    \              if (smallestPositive == None) smallestPositive = Some(i)\n    \
    \            else if (i < smallestPositive.get) smallestPositive = Some(i)\n \
    \           }\n        }\n        (largestNegative, smallestPositive)", "    \
    \    // Fill in the code here\n        var maxNeg = Long.MinValue\n        var\
    \ minPos = Long.MaxValue\n        for (i <- lst) {\n            if (i < 0) maxNeg\
    \ = max(maxNeg, i)\n            if (i > 0) minPos = min(minPos, i)\n        }\n\
    \        if (maxNeg == Long.MinValue) (None, Some(minPos))\n        else if (minPos\
    \ == Long.MaxValue) (Some(maxNeg), None)\n        else (Some(maxNeg), Some(minPos))",
  "        var largestNegative : Option[Long] = None\n        var smallestPositive\
    \ : Option[Long] = None\n        for (i <- lst) {\n            if (i < 0) {\n\
    \                if (largestNegative == None) largestNegative = Some(i)\n    \
    \            else if (i > largestNegative.get) largestNegative = Some(i)\n   \
    \         }\n            else if (i > 0) {\n                if (smallestPositive\
    \ == None) smallestPositive = Some(i)\n                else if (i < smallestPositive.get)\
    \ smallestPositive = Some(i)\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        // Fill in the code here\n        var neg = List[Long]()\n\
    \        var pos = List[Long]()\n        for (i <- lst) {\n            if (i <\
    \ 0) neg = i :: neg\n            else if (i > 0) pos = i :: pos\n        }\n \
    \       if (neg.length == 0) (None, Some(pos.min))\n        else if (pos.length\
    \ == 0) (Some(neg.max), None)\n        else (Some(neg.max), Some(pos.min))", " \
    \       // Fill in the code here\n        var min = None:Option[Long]\n      \
    \  var max = None:Option[Long]\n        for (i <- lst) {\n            if (i >\
    \ 0) {\n                if (min == None) min = Some(i)\n                else if\
    \ (i < min.get) min = Some(i)\n            }\n            else if (i < 0) {\n\
    \                if (max == None) max = Some(i)\n                else if (i >\
    \ max.get) max = Some(i)\n            }\n        }\n        (max, min)", "   \
    \     var largestNegative : Option[Long] = None\n        var smallestPositive\
    \ : Option[Long] = None\n        for (i <- lst) {\n            if (i < 0) {\n\
    \                if (largestNegative == None) largestNegative = Some(i)\n    \
    \            else if (i > largestNegative.get) largestNegative = Some(i)\n   \
    \         }\n            else if (i > 0) {\n                if (smallestPositive\
    \ == None) smallestPositive = Some(i)\n                else if (i < smallestPositive.get)\
    \ smallestPositive = Some(i)\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        // Fill in the code here\n        (None, None)",
  "        var largestNegative : Option[Long] = None\n        var smallestPositive\
    \ : Option[Long] = None\n        for (i <- lst) {\n            if (i < 0) {\n\
    \                if (largestNegative == None) largestNegative = Some(i)\n    \
    \            else if (i > largestNegative.get) largestNegative = Some(i)\n   \
    \         }\n            else if (i > 0) {\n                if (smallestPositive\
    \ == None) smallestPositive = Some(i)\n                else if (i < smallestPositive.get)\
    \ smallestPositive = Some(i)\n            }\n        }\n        return (largestNegative,\
    \ smallestPositive)", "        // Fill in the implementation here.\n        var\
    \ largestNegative : Option[Long] = None\n        var smallestPositive : Option[Long]\
    \ = None\n        for (i <- lst) {\n            if (i < 0) {\n               \
    \ if (largestNegative == None) {\n                    largestNegative = Some(i)\n\
    \                } else {\n                    if (i > largestNegative.get) {\n\
    \                        largestNegative = Some(i)\n                    }\n  \
    \              }\n            } else if (i > 0) {\n                if (smallestPositive\
    \ == None) {\n                    smallestPositive = Some(i)\n               \
    \ } else {\n                    if (i < smallestPositive.get) {\n            \
    \            smallestPositive = Some(i)\n                    }\n             \
    \   }\n            }\n        }\n        (largestNegative, smallestPositive)",
  "        // Fill in the code here\n        var maxNeg = None:Option[Long]\n    \
    \    var minPos = None:Option[Long]\n        for (i <- lst) {\n            if\
    \ (i < 0) {\n                if (maxNeg == None) {\n                    maxNeg\
    \ = Some(i)\n                } else {\n                    maxNeg = Some(max(maxNeg.get,\
    \ i))\n                }\n            } else if (i > 0) {\n                if\
    \ (minPos == None) {\n                    minPos = Some(i)\n                }\
    \ else {\n                    minPos = Some(min(minPos.get, i))\n            \
    \    }\n            }\n        }\n        return (maxNeg, minPos)", "        //\
    \ Fill in the code here\n        (None, None)", "        // Fill in the code here\n\
    \        var maxNeg = None\n        var minPos = None\n        for (i <- lst)\
    \ {\n            if (i < 0) {\n                if (maxNeg == None) maxNeg = Some(i)\n\
    \                else if (i > maxNeg.get) maxNeg = Some(i)\n            }\n  \
    \          else if (i > 0) {\n                if (minPos == None) minPos = Some(i)\n\
    \                else if (i < minPos.get) minPos = Some(i)\n            }\n  \
    \      }\n        (maxNeg, minPos)", "        var largestNegative : Option[Long]\
    \ = None\n        var smallestPositive : Option[Long] = None\n        for (i <-\
    \ lst) {\n            if (i < 0) {\n                if (largestNegative == None)\
    \ largestNegative = Some(i)\n                else if (i > largestNegative.get)\
    \ largestNegative = Some(i)\n            }\n            else if (i > 0) {\n  \
    \              if (smallestPositive == None) smallestPositive = Some(i)\n    \
    \            else if (i < smallestPositive.get) smallestPositive = Some(i)\n \
    \           }\n        }\n        return (largestNegative, smallestPositive)",
  "        // Fill in the code here\n        (None, None)", "        var largestNegative\
    \ : Option[Long] = None\n        var smallestPositive : Option[Long] = None\n\
    \        for (i <- lst) {\n            if (i < 0) {\n                if (largestNegative\
    \ == None) largestNegative = Some(i)\n                else if (i > largestNegative.get)\
    \ largestNegative = Some(i)\n            }\n            else if (i > 0) {\n  \
    \              if (smallestPositive == None) smallestPositive = Some(i)\n    \
    \            else if (i < smallestPositive.get) smallestPositive = Some(i)\n \
    \           }\n        }\n        return (largestNegative, smallestPositive)",
  "        val lst2 = lst.filter(x => x > 0)\n        val lst3 = lst.filter(x => x\
    \ < 0)\n        val lst4 = lst.filter(x => x == 0)\n        val lst5 = lst.filter(x\
    \ => x != 0)\n        val lst6 = lst3.sortWith(_ > _)\n        val lst7 = lst2.sortWith(_\
    \ < _)\n        if (lst5.length == 0) {\n            return (None, None)\n   \
    \     }\n        if (lst2.length == 0) {\n            return (Some(lst6(0)), None)\n\
    \        }\n        if (lst3.length == 0) {\n            return (None, Some(lst7(0)))\n\
    \        }\n        return (Some(lst6(0)), Some(lst7(0)))", "        var largestNegative\
    \ : Option[Long] = None\n        var smallestPositive : Option[Long] = None\n\
    \        for (i <- lst) {\n            if (i < 0) {\n                if (largestNegative\
    \ == None) largestNegative = Some(i)\n                else if (i > largestNegative.get)\
    \ largestNegative = Some(i)\n            }\n            else if (i > 0) {\n  \
    \              if (smallestPositive == None) smallestPositive = Some(i)\n    \
    \            else if (i < smallestPositive.get) smallestPositive = Some(i)\n \
    \           }\n        }\n        return (largestNegative, smallestPositive)",
  "        // Fill in the code here\n        var largestNegative : Option[Long] =\
    \ None\n        var smallestPositive : Option[Long] = None\n        for (i <-\
    \ lst) {\n            if (i < 0) {\n                if (largestNegative == None)\
    \ {\n                    largestNegative = Some(i)\n                } else {\n\
    \                    if (i > largestNegative.get) {\n                        largestNegative\
    \ = Some(i)\n                    }\n                }\n            } else if (i\
    \ > 0) {\n                if (smallestPositive == None) {\n                  \
    \  smallestPositive = Some(i)\n                } else {\n                    if\
    \ (i < smallestPositive.get) {\n                        smallestPositive = Some(i)\n\
    \                    }\n                }\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        // Fill in the implementation here.\n        return\
    \ (None, None)", "        // Fill in the code here.\n        return (None, None)",
  "        var largestNegative : Option[Long] = None\n        var smallestPositive\
    \ : Option[Long] = None\n        for (i <- lst) {\n            if (i < 0) {\n\
    \                if (largestNegative == None) largestNegative = Some(i)\n    \
    \            else if (i > largestNegative.get) largestNegative = Some(i)\n   \
    \         }\n            else if (i > 0) {\n                if (smallestPositive\
    \ == None) smallestPositive = Some(i)\n                else if (i < smallestPositive.get)\
    \ smallestPositive = Some(i)\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        // Fill in the code here\n        var largestNegative\
    \ : Option[Long] = None\n        var smallestPositive : Option[Long] = None\n\
    \        for (i <- lst) {\n            if (i < 0) {\n                if (largestNegative\
    \ == None) {\n                    largestNegative = Some(i)\n                }\
    \ else {\n                    if (i > largestNegative.get) {\n               \
    \         largestNegative = Some(i)\n                    }\n                }\n\
    \            } else if (i > 0) {\n                if (smallestPositive == None)\
    \ {\n                    smallestPositive = Some(i)\n                } else {\n\
    \                    if (i < smallestPositive.get) {\n                       \
    \ smallestPositive = Some(i)\n                    }\n                }\n     \
    \       }\n        }\n        return (largestNegative, smallestPositive)", " \
    \       // Fill in the code here\n        val neg = lst.filter(_ < 0).sortWith(_\
    \ > _)\n        val pos = lst.filter(_ > 0).sortWith(_ < _)\n        val negMax\
    \ = if (neg.isEmpty) None else Some(neg.head)\n        val posMin = if (pos.isEmpty)\
    \ None else Some(pos.head)\n        (negMax, posMin)", "        // Fill in the\
    \ code here\n        (None, None)", "        // Fill in the code here\n      \
    \  var largestNegative : Option[Long] = None\n        var smallestPositive : Option[Long]\
    \ = None\n        for (i <- lst) {\n            if (i < 0) {\n               \
    \ if (largestNegative == None) largestNegative = Some(i)\n                else\
    \ if (i > largestNegative.get) largestNegative = Some(i)\n            }\n    \
    \        else if (i > 0) {\n                if (smallestPositive == None) smallestPositive\
    \ = Some(i)\n                else if (i < smallestPositive.get) smallestPositive\
    \ = Some(i)\n            }\n        }\n        (largestNegative, smallestPositive)",
  "        val negative = lst.filter(x => x < 0)\n        val positive = lst.filter(x\
    \ => x > 0)\n        val largestNegative = if (negative.length > 0) Some(negative.max)\
    \ else None\n        val smallestPositive = if (positive.length > 0) Some(positive.min)\
    \ else None\n        (largestNegative, smallestPositive)", "        // Fill in\
    \ the code here\n        var largestNegative : Option[Long] = None\n        var\
    \ smallestPositive : Option[Long] = None\n        for (i <- lst) {\n         \
    \   if (i < 0) {\n                if (largestNegative == None) {\n           \
    \         largestNegative = Some(i)\n                } else {\n              \
    \      largestNegative = Some(max(largestNegative.get, i))\n                }\n\
    \            } else if (i > 0) {\n                if (smallestPositive == None)\
    \ {\n                    smallestPositive = Some(i)\n                } else {\n\
    \                    smallestPositive = Some(min(smallestPositive.get, i))\n \
    \               }\n            }\n        }\n        return (largestNegative,\
    \ smallestPositive)", "        // Fill in the code here\n        return (None,\
    \ None)", "        // Fill in the code here\n        var maxNeg = Long.MinValue\n\
    \        var minPos = Long.MaxValue\n        for (i <- lst) {\n            if\
    \ (i < 0) {\n                if (i > maxNeg) maxNeg = i\n            } else if\
    \ (i > 0) {\n                if (i < minPos) minPos = i\n            }\n     \
    \   }\n        if (maxNeg == Long.MinValue) maxNeg = None\n        if (minPos\
    \ == Long.MaxValue) minPos = None\n        (maxNeg, minPos)", "        val sorted\
    \ = lst.sorted\n        val negatives = sorted.filter(x => x < 0)\n        val\
    \ positives = sorted.filter(x => x > 0)\n        val largestNegative = if (negatives.length\
    \ > 0) Some(negatives.last) else None\n        val smallestPositive = if (positives.length\
    \ > 0) Some(positives.head) else None\n        (largestNegative, smallestPositive)",
  "        // Fill in the code here\n        var maxNeg = None:Option[Long]\n    \
    \    var minPos = None:Option[Long]\n        for (i <- lst) {\n            if\
    \ (i < 0) {\n                if (maxNeg == None) {\n                    maxNeg\
    \ = Some(i)\n                } else {\n                    if (i > maxNeg.get)\
    \ {\n                        maxNeg = Some(i)\n                    }\n       \
    \         }\n            } else if (i > 0) {\n                if (minPos == None)\
    \ {\n                    minPos = Some(i)\n                } else {\n        \
    \            if (i < minPos.get) {\n                        minPos = Some(i)\n\
    \                    }\n                }\n            }\n        }\n        return\
    \ (maxNeg, minPos)", "        // Fill in the code here\n        var largestNegative\
    \ = Option.empty[Long]\n        var smallestPositive = Option.empty[Long]\n  \
    \      for (i <- lst) {\n            if (i < 0) {\n                if (largestNegative.isEmpty)\
    \ {\n                    largestNegative = Some(i)\n                } else {\n\
    \                    if (i > largestNegative.get) {\n                        largestNegative\
    \ = Some(i)\n                    }\n                }\n            } else if (i\
    \ > 0) {\n                if (smallestPositive.isEmpty) {\n                  \
    \  smallestPositive = Some(i)\n                } else {\n                    if\
    \ (i < smallestPositive.get) {\n                        smallestPositive = Some(i)\n\
    \                    }\n                }\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        var largestNegative : Option[Long] = None\n   \
    \     var smallestPositive : Option[Long] = None\n        for (i <- lst) {\n \
    \           if (i < 0) {\n                if (largestNegative == None) largestNegative\
    \ = Some(i)\n                else if (i > largestNegative.get) largestNegative\
    \ = Some(i)\n            }\n            else if (i > 0) {\n                if\
    \ (smallestPositive == None) smallestPositive = Some(i)\n                else\
    \ if (i < smallestPositive.get) smallestPositive = Some(i)\n            }\n  \
    \      }\n        (largestNegative, smallestPositive)", "        // Fill in the\
    \ code here\n        return (None, None)", "        // Fill in the code here\n\
    \        var largestNegative = None:Option[Long]\n        var smallestPositive\
    \ = None:Option[Long]\n        for (i <- lst) {\n            if (i < 0) {\n  \
    \              if (largestNegative == None) {\n                    largestNegative\
    \ = Some(i)\n                } else {\n                    if (i > largestNegative.get)\
    \ {\n                        largestNegative = Some(i)\n                    }\n\
    \                }\n            } else if (i > 0) {\n                if (smallestPositive\
    \ == None) {\n                    smallestPositive = Some(i)\n               \
    \ } else {\n                    if (i < smallestPositive.get) {\n            \
    \            smallestPositive = Some(i)\n                    }\n             \
    \   }\n            }\n        }\n        return (largestNegative, smallestPositive)",
  "        // Fill in the code here\n        return (None, None)", "        val negative\
    \ = lst.filter(x => x < 0)\n        val positive = lst.filter(x => x > 0)\n  \
    \      val largestNegative = if (negative.length > 0) Some(negative.max) else\
    \ None\n        val smallestPositive = if (positive.length > 0) Some(positive.min)\
    \ else None\n        (largestNegative, smallestPositive)", "        // Fill in\
    \ the code here\n        return (None, None)", "        val positive = lst.filter(_\
    \ > 0)\n        val negative = lst.filter(_ < 0)\n        val largestNegative\
    \ = if (negative.isEmpty) None else Some(negative.max)\n        val smallestPositive\
    \ = if (positive.isEmpty) None else Some(positive.min)\n        (largestNegative,\
    \ smallestPositive)", "        // Fill in the code here\n        var maxNeg :\
    \ Option[Long] = None\n        var minPos : Option[Long] = None\n        for (i\
    \ <- lst) {\n            if (i < 0) {\n                if (maxNeg == None) {\n\
    \                    maxNeg = Some(i)\n                } else {\n            \
    \        if (i > maxNeg.get) {\n                        maxNeg = Some(i)\n   \
    \                 }\n                }\n            } else if (i > 0) {\n    \
    \            if (minPos == None) {\n                    minPos = Some(i)\n   \
    \             } else {\n                    if (i < minPos.get) {\n          \
    \              minPos = Some(i)\n                    }\n                }\n  \
    \          }\n        }\n        (maxNeg, minPos)", "        var largestNegative\
    \ : Option[Long] = None\n        var smallestPositive : Option[Long] = None\n\
    \        for (i <- lst) {\n            if (i < 0) {\n                if (largestNegative\
    \ == None) {\n                    largestNegative = Some(i)\n                }\
    \ else {\n                    if (i > largestNegative.get) {\n               \
    \         largestNegative = Some(i)\n                    }\n                }\n\
    \            } else if (i > 0) {\n                if (smallestPositive == None)\
    \ {\n                    smallestPositive = Some(i)\n                } else {\n\
    \                    if (i < smallestPositive.get) {\n                       \
    \ smallestPositive = Some(i)\n                    }\n                }\n     \
    \       }\n        }\n        (largestNegative, smallestPositive)", "        //\
    \ Fill in the code here\n        var maxNeg = None:Option[Long]\n        var minPos\
    \ = None:Option[Long]\n        for (i <- lst) {\n            if (i < 0) {\n  \
    \              if (maxNeg == None) maxNeg = Some(i)\n                else if (i\
    \ > maxNeg.get) maxNeg = Some(i)\n            }\n            else if (i > 0) {\n\
    \                if (minPos == None) minPos = Some(i)\n                else if\
    \ (i < minPos.get) minPos = Some(i)\n            }\n        }\n        (maxNeg,\
    \ minPos)", "        var largestNegative : Option[Long] = None\n        var smallestPositive\
    \ : Option[Long] = None\n        for (i <- lst) {\n            if (i < 0) {\n\
    \                if (largestNegative == None) largestNegative = Some(i)\n    \
    \            else if (i > largestNegative.get) largestNegative = Some(i)\n   \
    \         }\n            else if (i > 0) {\n                if (smallestPositive\
    \ == None) smallestPositive = Some(i)\n                else if (i < smallestPositive.get)\
    \ smallestPositive = Some(i)\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        // Fill in the code here\n        var largestNegative\
    \ : Option[Long] = None\n        var smallestPositive : Option[Long] = None\n\
    \        for (i <- lst) {\n            if (i < 0) {\n                if (largestNegative\
    \ == None) largestNegative = Some(i)\n                else if (i > largestNegative.get)\
    \ largestNegative = Some(i)\n            }\n            else if (i > 0) {\n  \
    \              if (smallestPositive == None) smallestPositive = Some(i)\n    \
    \            else if (i < smallestPositive.get) smallestPositive = Some(i)\n \
    \           }\n        }\n        (largestNegative, smallestPositive)", "    \
    \    // Fill in the code here\n        return (None, None)", "        // Fill\
    \ in the code here\n        (None, None)", "        // Fill in the code here\n\
    \        var largestNegative = None : Option[Long]\n        var smallestPositive\
    \ = None : Option[Long]\n        for (i <- lst) {\n            if (i < 0) {\n\
    \                if (largestNegative == None) {\n                    largestNegative\
    \ = Some(i)\n                } else {\n                    if (i > largestNegative.get)\
    \ {\n                        largestNegative = Some(i)\n                    }\n\
    \                }\n            } else if (i > 0) {\n                if (smallestPositive\
    \ == None) {\n                    smallestPositive = Some(i)\n               \
    \ } else {\n                    if (i < smallestPositive.get) {\n            \
    \            smallestPositive = Some(i)\n                    }\n             \
    \   }\n            }\n        }\n        (largestNegative, smallestPositive)",
  "        // Fill in the code here\n        var maxNeg = None:Option[Long]\n    \
    \    var minPos = None:Option[Long]\n        for (i <- lst) {\n            if\
    \ (i < 0) {\n                if (maxNeg == None) maxNeg = Some(i)\n          \
    \      else if (i > maxNeg.get) maxNeg = Some(i)\n            }\n            else\
    \ if (i > 0) {\n                if (minPos == None) minPos = Some(i)\n       \
    \         else if (i < minPos.get) minPos = Some(i)\n            }\n        }\n\
    \        (maxNeg, minPos)", "        // Fill in the code here\n        var maxNeg\
    \ = Long.MinValue\n        var minPos = Long.MaxValue\n        for (i <- lst)\
    \ {\n            if (i < 0) {\n                if (i > maxNeg) maxNeg = i\n  \
    \          }\n            else if (i > 0) {\n                if (i < minPos) minPos\
    \ = i\n            }\n        }\n        if (maxNeg == Long.MinValue) maxNeg =\
    \ None\n        if (minPos == Long.MaxValue) minPos = None\n        (Some(maxNeg),\
    \ Some(minPos))", "        // Fill in the code here\n        var largestNegative\
    \ = None : Option[Long]\n        var smallestPositive = None : Option[Long]\n\
    \        for (i <- lst) {\n            if (i < 0) {\n                if (largestNegative\
    \ == None) {\n                    largestNegative = Some(i)\n                }\
    \ else {\n                    if (i > largestNegative.get) {\n               \
    \         largestNegative = Some(i)\n                    }\n                }\n\
    \            } else if (i > 0) {\n                if (smallestPositive == None)\
    \ {\n                    smallestPositive = Some(i)\n                } else {\n\
    \                    if (i < smallestPositive.get) {\n                       \
    \ smallestPositive = Some(i)\n                    }\n                }\n     \
    \       }\n        }\n        (largestNegative, smallestPositive)", "        //\
    \ Fill in the code here.\n        var largestNegative : Option[Long] = None\n\
    \        var smallestPositive : Option[Long] = None\n        for (i <- lst) {\n\
    \            if (i < 0) {\n                if (largestNegative == None) largestNegative\
    \ = Some(i)\n                else if (i > largestNegative.get) largestNegative\
    \ = Some(i)\n            }\n            else if (i > 0) {\n                if\
    \ (smallestPositive == None) smallestPositive = Some(i)\n                else\
    \ if (i < smallestPositive.get) smallestPositive = Some(i)\n            }\n  \
    \      }\n        (largestNegative, smallestPositive)", "        // Fill in the\
    \ code here\n        (None, None)", "        // Fill in the code here\n      \
    \  var maxNeg = None:Option[Long]\n        var minPos = None:Option[Long]\n  \
    \      for (i <- lst) {\n            if (i < 0) {\n                if (maxNeg\
    \ == None) maxNeg = Some(i)\n                else if (i > maxNeg.get) maxNeg =\
    \ Some(i)\n            }\n            else if (i > 0) {\n                if (minPos\
    \ == None) minPos = Some(i)\n                else if (i < minPos.get) minPos =\
    \ Some(i)\n            }\n        }\n        (maxNeg, minPos)", "        // Fill\
    \ in the code here\n        var largestNegative : Option[Long] = None\n      \
    \  var smallestPositive : Option[Long] = None\n        for (i <- lst) {\n    \
    \        if (i < 0) {\n                if (largestNegative == None) {\n      \
    \              largestNegative = Some(i)\n                } else {\n         \
    \           if (i > largestNegative.get) {\n                        largestNegative\
    \ = Some(i)\n                    }\n                }\n            } else if (i\
    \ > 0) {\n                if (smallestPositive == None) {\n                  \
    \  smallestPositive = Some(i)\n                } else {\n                    if\
    \ (i < smallestPositive.get) {\n                        smallestPositive = Some(i)\n\
    \                    }\n                }\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        // Fill in the code here\n        var maxNeg =\
    \ None:Option[Long]\n        var minPos = None:Option[Long]\n        for (i <-\
    \ lst) {\n            if (i < 0) {\n                if (maxNeg == None) {\n  \
    \                  maxNeg = Some(i)\n                } else {\n              \
    \      if (i > maxNeg.get) {\n                        maxNeg = Some(i)\n     \
    \               }\n                }\n            } else if (i > 0) {\n      \
    \          if (minPos == None) {\n                    minPos = Some(i)\n     \
    \           } else {\n                    if (i < minPos.get) {\n            \
    \            minPos = Some(i)\n                    }\n                }\n    \
    \        }\n        }\n        (maxNeg, minPos)", "        // Fill in the code\
    \ here\n        var maxNeg = None : Option[Long]\n        var minPos = None :\
    \ Option[Long]\n        for (i <- lst) {\n            if (i < 0 && (maxNeg ==\
    \ None || i > maxNeg.get)) maxNeg = Some(i)\n            if (i > 0 && (minPos\
    \ == None || i < minPos.get)) minPos = Some(i)\n        }\n        (maxNeg, minPos)",
  "        // Fill in the code here\n        var maxNeg = None:Option[Long]\n    \
    \    var minPos = None:Option[Long]\n        for (i <- lst) {\n            if\
    \ (i < 0) {\n                if (maxNeg == None) {\n                    maxNeg\
    \ = Some(i)\n                } else {\n                    if (i > maxNeg.get)\
    \ {\n                        maxNeg = Some(i)\n                    }\n       \
    \         }\n            } else if (i > 0) {\n                if (minPos == None)\
    \ {\n                    minPos = Some(i)\n                } else {\n        \
    \            if (i < minPos.get) {\n                        minPos = Some(i)\n\
    \                    }\n                }\n            }\n        }\n        (maxNeg,\
    \ minPos)", "        // Fill in the code here\n        (None, None)", "      \
    \  // Fill in the code here\n        var min = Long.MaxValue\n        var max\
    \ = Long.MinValue\n        for (i <- lst) {\n            if (i < 0) {\n      \
    \          if (i > max) max = i\n            } else {\n                if (i <\
    \ min) min = i\n            }\n        }\n        if (min == Long.MaxValue) min\
    \ = None\n        if (max == Long.MinValue) max = None\n        (Some(max), Some(min))",
  "        var largestNegative = None : Option[Long]\n        var smallestPositive\
    \ = None : Option[Long]\n        for (i <- lst) {\n            if (i < 0) {\n\
    \                if (largestNegative == None) largestNegative = Some(i)\n    \
    \            else if (i > largestNegative.get) largestNegative = Some(i)\n   \
    \         }\n            else if (i > 0) {\n                if (smallestPositive\
    \ == None) smallestPositive = Some(i)\n                else if (i < smallestPositive.get)\
    \ smallestPositive = Some(i)\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        // Fill in the code here\n        var largestNegative\
    \ = None : Option[Long]\n        var smallestPositive = None : Option[Long]\n\
    \        for (i <- lst) {\n            if (i < 0) {\n                if (largestNegative\
    \ == None) largestNegative = Some(i)\n                else if (i > largestNegative.get)\
    \ largestNegative = Some(i)\n            }\n            else if (i > 0) {\n  \
    \              if (smallestPositive == None) smallestPositive = Some(i)\n    \
    \            else if (i < smallestPositive.get) smallestPositive = Some(i)\n \
    \           }\n        }\n        (largestNegative, smallestPositive)", "    \
    \    // Fill in the code here\n        val pos = lst.filter(_ > 0)\n        val\
    \ neg = lst.filter(_ < 0)\n        val posMin = if (pos.isEmpty) None else Some(pos.min)\n\
    \        val negMax = if (neg.isEmpty) None else Some(neg.max)\n        (negMax,\
    \ posMin)", "        // Fill in the code here\n        var largestNegative = None\
    \ : Option[Long]\n        var smallestPositive = None : Option[Long]\n       \
    \ for (i <- lst) {\n            if (i < 0) {\n                if (largestNegative\
    \ == None) {\n                    largestNegative = Some(i)\n                }\
    \ else {\n                    largestNegative = Some(max(largestNegative.get,\
    \ i))\n                }\n            } else if (i > 0) {\n                if\
    \ (smallestPositive == None) {\n                    smallestPositive = Some(i)\n\
    \                } else {\n                    smallestPositive = Some(min(smallestPositive.get,\
    \ i))\n                }\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        // Fill in the code here\n        var maxNegative\
    \ = None:Option[Long]\n        var minPositive = None:Option[Long]\n        for\
    \ (i <- lst) {\n            if (i < 0) {\n                if (maxNegative == None)\
    \ {\n                    maxNegative = Some(i)\n                } else {\n   \
    \                 if (i > maxNegative.get) {\n                        maxNegative\
    \ = Some(i)\n                    }\n                }\n            } else if (i\
    \ > 0) {\n                if (minPositive == None) {\n                    minPositive\
    \ = Some(i)\n                } else {\n                    if (i < minPositive.get)\
    \ {\n                        minPositive = Some(i)\n                    }\n  \
    \              }\n            }\n        }\n        (maxNegative, minPositive)",
  "        // Fill in the code here\n        (None, None)", "        // Fill in the\
    \ code here\n        var a = None:Option[Long]\n        var b = None:Option[Long]\n\
    \        for (i <- lst) {\n            if (i < 0) {\n                if (a ==\
    \ None) {\n                    a = Some(i)\n                } else {\n       \
    \             if (i > a.get) {\n                        a = Some(i)\n        \
    \            }\n                }\n            } else {\n                if (b\
    \ == None) {\n                    b = Some(i)\n                } else {\n    \
    \                if (i < b.get) {\n                        b = Some(i)\n     \
    \               }\n                }\n            }\n        }\n        (a, b)",
  "        // Fill in the code here\n        (None, None)", "        // Fill in the\
    \ code here\n        var maxNeg = Long.MinValue\n        var minPos = Long.MaxValue\n\
    \        for (i <- lst) {\n            if (i < 0 && i > maxNeg) maxNeg = i\n \
    \           if (i > 0 && i < minPos) minPos = i\n        }\n        if (maxNeg\
    \ == Long.MinValue) (None, Some(minPos))\n        else if (minPos == Long.MaxValue)\
    \ (Some(maxNeg), None)\n        else (Some(maxNeg), Some(minPos))", "        var\
    \ largestNegative : Option[Long] = None\n        var smallestPositive : Option[Long]\
    \ = None\n        for (i <- lst) {\n            if (i < 0) {\n               \
    \ if (largestNegative == None) largestNegative = Some(i)\n                else\
    \ if (i > largestNegative.get) largestNegative = Some(i)\n            }\n    \
    \        else if (i > 0) {\n                if (smallestPositive == None) smallestPositive\
    \ = Some(i)\n                else if (i < smallestPositive.get) smallestPositive\
    \ = Some(i)\n            }\n        }\n        (largestNegative, smallestPositive)",
  "        // Fill in the code here\n        var smallest = Long.MaxValue\n      \
    \  var largest = Long.MinValue\n        for (i <- lst) {\n            if (i <\
    \ 0) {\n                if (i > largest) largest = i\n            }\n        \
    \    else if (i > 0) {\n                if (i < smallest) smallest = i\n     \
    \       }\n        }\n        if (largest == Long.MinValue) (None, Some(smallest))\n\
    \        else if (smallest == Long.MaxValue) (Some(largest), None)\n        else\
    \ (Some(largest), Some(smallest))", "        // Fill in the code here\n      \
    \  var largestNegative : Option[Long] = None\n        var smallestPositive : Option[Long]\
    \ = None\n        for (i <- lst) {\n            if (i < 0) {\n               \
    \ if (largestNegative == None) {\n                    largestNegative = Some(i)\n\
    \                } else {\n                    if (i > largestNegative.get) {\n\
    \                        largestNegative = Some(i)\n                    }\n  \
    \              }\n            } else if (i > 0) {\n                if (smallestPositive\
    \ == None) {\n                    smallestPositive = Some(i)\n               \
    \ } else {\n                    if (i < smallestPositive.get) {\n            \
    \            smallestPositive = Some(i)\n                    }\n             \
    \   }\n            }\n        }\n        return (largestNegative, smallestPositive)",
  "        // Fill in the code here\n        (None, None)", "        var largestNegative\
    \ : Option[Long] = None\n        var smallestPositive : Option[Long] = None\n\
    \        for (i <- lst) {\n            if (i < 0) {\n                if (largestNegative\
    \ == None) largestNegative = Some(i)\n                else largestNegative = Some(max(largestNegative.get,\
    \ i))\n            }\n            else if (i > 0) {\n                if (smallestPositive\
    \ == None) smallestPositive = Some(i)\n                else smallestPositive =\
    \ Some(min(smallestPositive.get, i))\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        // Fill in the code here\n        var maxNeg =\
    \ None : Option[Long]\n        var minPos = None : Option[Long]\n        for (i\
    \ <- lst) {\n            if (i < 0) {\n                if (maxNeg == None) maxNeg\
    \ = Some(i)\n                else if (i > maxNeg.get) maxNeg = Some(i)\n     \
    \       }\n            else if (i > 0) {\n                if (minPos == None)\
    \ minPos = Some(i)\n                else if (i < minPos.get) minPos = Some(i)\n\
    \            }\n        }\n        (maxNeg, minPos)", "        val negative =\
    \ lst.filter(x => x < 0).sortWith(_ > _)\n        val positive = lst.filter(x\
    \ => x > 0).sortWith(_ < _)\n        val largestNegative = if (negative.length\
    \ > 0) Some(negative(0)) else None\n        val smallestPositive = if (positive.length\
    \ > 0) Some(positive(0)) else None\n        (largestNegative, smallestPositive)",
  "        // Fill in the code here\n        var largestNegative : Option[Long] =\
    \ None\n        var smallestPositive : Option[Long] = None\n        for (i <-\
    \ lst) {\n            if (i < 0) {\n                if (largestNegative == None)\
    \ {\n                    largestNegative = Some(i)\n                } else {\n\
    \                    if (i > largestNegative.get) {\n                        largestNegative\
    \ = Some(i)\n                    }\n                }\n            } else if (i\
    \ > 0) {\n                if (smallestPositive == None) {\n                  \
    \  smallestPositive = Some(i)\n                } else {\n                    if\
    \ (i < smallestPositive.get) {\n                        smallestPositive = Some(i)\n\
    \                    }\n                }\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        // Fill in the code here\n        var largestNegative\
    \ : Option[Long] = None\n        var smallestPositive : Option[Long] = None\n\
    \        for (i <- lst) {\n            if (i < 0) {\n                if (largestNegative\
    \ == None) {\n                    largestNegative = Some(i)\n                }\
    \ else {\n                    if (i > largestNegative.get) {\n               \
    \         largestNegative = Some(i)\n                    }\n                }\n\
    \            } else if (i > 0) {\n                if (smallestPositive == None)\
    \ {\n                    smallestPositive = Some(i)\n                } else {\n\
    \                    if (i < smallestPositive.get) {\n                       \
    \ smallestPositive = Some(i)\n                    }\n                }\n     \
    \       }\n        }\n        (largestNegative, smallestPositive)", "        //\
    \ Fill in the code here\n        var largestNegative = None:Option[Long]\n   \
    \     var smallestPositive = None:Option[Long]\n        for (i <- lst) {\n   \
    \         if (i < 0) {\n                if (largestNegative == None) {\n     \
    \               largestNegative = Some(i)\n                } else {\n        \
    \            if (i > largestNegative.get) {\n                        largestNegative\
    \ = Some(i)\n                    }\n                }\n            } else if (i\
    \ > 0) {\n                if (smallestPositive == None) {\n                  \
    \  smallestPositive = Some(i)\n                } else {\n                    if\
    \ (i < smallestPositive.get) {\n                        smallestPositive = Some(i)\n\
    \                    }\n                }\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        // Fill in the function here\n        return (None,\
    \ None)", "        // Fill in the code here\n        var maxNegative = None:Option[Long]\n\
    \        var minPositive = None:Option[Long]\n        for (i <- lst) {\n     \
    \       if (i < 0) {\n                if (maxNegative == None) {\n           \
    \         maxNegative = Some(i)\n                } else {\n                  \
    \  if (i > maxNegative.get) {\n                        maxNegative = Some(i)\n\
    \                    }\n                }\n            } else if (i > 0) {\n \
    \               if (minPositive == None) {\n                    minPositive =\
    \ Some(i)\n                } else {\n                    if (i < minPositive.get)\
    \ {\n                        minPositive = Some(i)\n                    }\n  \
    \              }\n            }\n        }\n        (maxNegative, minPositive)",
  "        // Fill in the code here\n        var neg = List[Long]()\n        var pos\
    \ = List[Long]()\n        for (i <- lst) {\n            if (i < 0) neg = i ::\
    \ neg\n            else if (i > 0) pos = i :: pos\n        }\n        if (neg.isEmpty)\
    \ (None, Some(pos.min))\n        else if (pos.isEmpty) (Some(neg.max), None)\n\
    \        else (Some(neg.max), Some(pos.min))", "        // Fill in the code here\n\
    \        var largestNegative = None:Option[Long]\n        var smallestPositive\
    \ = None:Option[Long]\n        for (i <- lst) {\n            if (i < 0) {\n  \
    \              if (largestNegative == None) {\n                    largestNegative\
    \ = Some(i)\n                } else {\n                    if (i > largestNegative.get)\
    \ {\n                        largestNegative = Some(i)\n                    }\n\
    \                }\n            } else if (i > 0) {\n                if (smallestPositive\
    \ == None) {\n                    smallestPositive = Some(i)\n               \
    \ } else {\n                    if (i < smallestPositive.get) {\n            \
    \            smallestPositive = Some(i)\n                    }\n             \
    \   }\n            }\n        }\n        (largestNegative, smallestPositive)",
  "        // Fill in the code here\n        val negative = lst.filter(_ < 0)\n  \
    \      val positive = lst.filter(_ > 0)\n        val largestNegative = if (negative.isEmpty)\
    \ None else Some(negative.max)\n        val smallestPositive = if (positive.isEmpty)\
    \ None else Some(positive.min)\n        (largestNegative, smallestPositive)",
  "        // Write your code here\n        return (None, None)", "        // Fill\
    \ in the code here\n        var maxNegative = None : Option[Long]\n        var\
    \ minPositive = None : Option[Long]\n        for (i <- lst) {\n            if\
    \ (i < 0) {\n                if (maxNegative == None) maxNegative = Some(i)\n\
    \                else if (i > maxNegative.get) maxNegative = Some(i)\n       \
    \     }\n            else if (i > 0) {\n                if (minPositive == None)\
    \ minPositive = Some(i)\n                else if (i < minPositive.get) minPositive\
    \ = Some(i)\n            }\n        }\n        (maxNegative, minPositive)", " \
    \       var largestNegative : Option[Long] = None\n        var smallestPositive\
    \ : Option[Long] = None\n        for (i <- lst) {\n            if (i < 0) {\n\
    \                if (largestNegative == None) largestNegative = Some(i)\n    \
    \            else if (i > largestNegative.get) largestNegative = Some(i)\n   \
    \         }\n            else if (i > 0) {\n                if (smallestPositive\
    \ == None) smallestPositive = Some(i)\n                else if (i < smallestPositive.get)\
    \ smallestPositive = Some(i)\n            }\n        }\n        return (largestNegative,\
    \ smallestPositive)", "        var largestNegative : Option[Long] = None\n   \
    \     var smallestPositive : Option[Long] = None\n        for (i <- lst) {\n \
    \           if (i < 0 && (largestNegative == None || i > largestNegative.get))\
    \ largestNegative = Some(i)\n            if (i > 0 && (smallestPositive == None\
    \ || i < smallestPositive.get)) smallestPositive = Some(i)\n        }\n      \
    \  return (largestNegative, smallestPositive)", "        var largestNegative :\
    \ Option[Long] = None\n        var smallestPositive : Option[Long] = None\n  \
    \      for (i <- lst) {\n            if (i < 0) {\n                if (largestNegative\
    \ == None) largestNegative = Some(i)\n                else if (i > largestNegative.get)\
    \ largestNegative = Some(i)\n            }\n            else if (i > 0) {\n  \
    \              if (smallestPositive == None) smallestPositive = Some(i)\n    \
    \            else if (i < smallestPositive.get) smallestPositive = Some(i)\n \
    \           }\n        }\n        return (largestNegative, smallestPositive)",
  "        var largestNegative : Option[Long] = None\n        var smallestPositive\
    \ : Option[Long] = None\n        for (i <- lst) {\n            if (i < 0) {\n\
    \                if (largestNegative == None) largestNegative = Some(i)\n    \
    \            else largestNegative = Some(max(largestNegative.get, i))\n      \
    \      }\n            else if (i > 0) {\n                if (smallestPositive\
    \ == None) smallestPositive = Some(i)\n                else smallestPositive =\
    \ Some(min(smallestPositive.get, i))\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        // Fill in the code here\n        var maxNeg =\
    \ None:Option[Long]\n        var minPos = None:Option[Long]\n        for (i <-\
    \ lst) {\n            if (i < 0) {\n                if (maxNeg == None) {\n  \
    \                  maxNeg = Some(i)\n                } else {\n              \
    \      if (i > maxNeg.get) {\n                        maxNeg = Some(i)\n     \
    \               }\n                }\n            } else if (i > 0) {\n      \
    \          if (minPos == None) {\n                    minPos = Some(i)\n     \
    \           } else {\n                    if (i < minPos.get) {\n            \
    \            minPos = Some(i)\n                    }\n                }\n    \
    \        }\n        }\n        return (maxNeg, minPos)", "        // Fill in the\
    \ code here\n        var neg = List[Long]()\n        var pos = List[Long]()\n\
    \        for (i <- lst) {\n            if (i < 0) neg = i :: neg\n           \
    \ else if (i > 0) pos = i :: pos\n        }\n        if (neg.isEmpty) (None, Some(pos.min))\n\
    \        else if (pos.isEmpty) (Some(neg.max), None)\n        else (Some(neg.max),\
    \ Some(pos.min))", "        // Fill in the body of this function\n        val\
    \ a = lst.filter(_ < 0).maxOption\n        val b = lst.filter(_ > 0).minOption\n\
    \        (a, b)", "        var largestNegative : Option[Long] = None\n       \
    \ var smallestPositive : Option[Long] = None\n        for (i <- lst) {\n     \
    \       if (i < 0) {\n                if (largestNegative == None) {\n       \
    \             largestNegative = Some(i)\n                } else {\n          \
    \          if (i > largestNegative.get) {\n                        largestNegative\
    \ = Some(i)\n                    }\n                }\n            } else if (i\
    \ > 0) {\n                if (smallestPositive == None) {\n                  \
    \  smallestPositive = Some(i)\n                } else {\n                    if\
    \ (i < smallestPositive.get) {\n                        smallestPositive = Some(i)\n\
    \                    }\n                }\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        var largestNegative : Option[Long] = None\n   \
    \     var smallestPositive : Option[Long] = None\n        for (i <- lst) {\n \
    \           if (i < 0) {\n                if (largestNegative == None) largestNegative\
    \ = Some(i)\n                else if (i > largestNegative.get) largestNegative\
    \ = Some(i)\n            }\n            else if (i > 0) {\n                if\
    \ (smallestPositive == None) smallestPositive = Some(i)\n                else\
    \ if (i < smallestPositive.get) smallestPositive = Some(i)\n            }\n  \
    \      }\n        return (largestNegative, smallestPositive)", "        // Fill\
    \ in the code here\n        val neg = lst.filter(_ < 0)\n        val pos = lst.filter(_\
    \ > 0)\n        val negMax = if (neg.isEmpty) None else Some(neg.max)\n      \
    \  val posMin = if (pos.isEmpty) None else Some(pos.min)\n        (negMax, posMin)",
  "        if (lst.isEmpty) {\n            return (Some(None), Some(None))\n     \
    \   }\n        var maxNeg : Option[Long] = None\n        var minPos : Option[Long]\
    \ = None\n        for (i <- lst) {\n            if (i < 0) {\n               \
    \ if (maxNeg == None) {\n                    maxNeg = Some(i)\n              \
    \  } else {\n                    maxNeg = Some(max(maxNeg.get, i))\n         \
    \       }\n            } else if (i > 0) {\n                if (minPos == None)\
    \ {\n                    minPos = Some(i)\n                } else {\n        \
    \            minPos = Some(min(minPos.get, i))\n                }\n          \
    \  }\n        }\n        return (maxNeg, minPos)", "        var largestNegative\
    \ : Option[Long] = None\n        var smallestPositive : Option[Long] = None\n\
    \        for (i <- lst) {\n            if (i < 0) {\n                if (largestNegative\
    \ == None) {\n                    largestNegative = Some(i)\n                }\
    \ else {\n                    if (i > largestNegative.get) {\n               \
    \         largestNegative = Some(i)\n                    }\n                }\n\
    \            } else if (i > 0) {\n                if (smallestPositive == None)\
    \ {\n                    smallestPositive = Some(i)\n                } else {\n\
    \                    if (i < smallestPositive.get) {\n                       \
    \ smallestPositive = Some(i)\n                    }\n                }\n     \
    \       }\n        }\n        (largestNegative, smallestPositive)", "        //\
    \ Fill in the code here\n        var largestNegative = None:Option[Long]\n   \
    \     var smallestPositive = None:Option[Long]\n        for (i <- lst) {\n   \
    \         if (i < 0) {\n                if (largestNegative == None) {\n     \
    \               largestNegative = Some(i)\n                } else {\n        \
    \            if (i > largestNegative.get) {\n                        largestNegative\
    \ = Some(i)\n                    }\n                }\n            } else if (i\
    \ > 0) {\n                if (smallestPositive == None) {\n                  \
    \  smallestPositive = Some(i)\n                } else {\n                    if\
    \ (i < smallestPositive.get) {\n                        smallestPositive = Some(i)\n\
    \                    }\n                }\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        val negative = lst.filter(_ < 0)\n        val positive\
    \ = lst.filter(_ > 0)\n        val largestNegative = if (negative.isEmpty) None\
    \ else Some(negative.max)\n        val smallestPositive = if (positive.isEmpty)\
    \ None else Some(positive.min)\n        (largestNegative, smallestPositive)",
  "        // Fill in the code here\n        (None, None)", "        val negs = lst.filter(x\
    \ => x < 0)\n        val poss = lst.filter(x => x > 0)\n        val neg = if (negs.length\
    \ > 0) Some(negs.max) else None\n        val pos = if (poss.length > 0) Some(poss.min)\
    \ else None\n        (neg, pos)", "        var maxNeg = Option.empty[Long]\n \
    \       var minPos = Option.empty[Long]\n        for (i <- lst) {\n          \
    \  if (i < 0) {\n                if (maxNeg.isEmpty || i > maxNeg.get) maxNeg\
    \ = Some(i)\n            } else if (i > 0) {\n                if (minPos.isEmpty\
    \ || i < minPos.get) minPos = Some(i)\n            }\n        }\n        (maxNeg,\
    \ minPos)", "        // Fill in the code here\n        (None, None)", "      \
    \  var largestNegative : Option[Long] = None\n        var smallestPositive : Option[Long]\
    \ = None\n        for (i <- lst) {\n            if (i < 0) {\n               \
    \ if (largestNegative == None) {\n                    largestNegative = Some(i)\n\
    \                } else {\n                    if (i > largestNegative.get) {\n\
    \                        largestNegative = Some(i)\n                    }\n  \
    \              }\n            } else if (i > 0) {\n                if (smallestPositive\
    \ == None) {\n                    smallestPositive = Some(i)\n               \
    \ } else {\n                    if (i < smallestPositive.get) {\n            \
    \            smallestPositive = Some(i)\n                    }\n             \
    \   }\n            }\n        }\n        (largestNegative, smallestPositive)",
  "        var largestNegative : Option[Long] = None\n        var smallestPositive\
    \ : Option[Long] = None\n        for (i <- lst) {\n            if (i < 0) {\n\
    \                if (largestNegative == None) {\n                    largestNegative\
    \ = Some(i)\n                } else {\n                    if (i > largestNegative.get)\
    \ {\n                        largestNegative = Some(i)\n                    }\n\
    \                }\n            } else if (i > 0) {\n                if (smallestPositive\
    \ == None) {\n                    smallestPositive = Some(i)\n               \
    \ } else {\n                    if (i < smallestPositive.get) {\n            \
    \            smallestPositive = Some(i)\n                    }\n             \
    \   }\n            }\n        }\n        return (largestNegative, smallestPositive)",
  "        var largestNegative : Option[Long] = None\n        var smallestPositive\
    \ : Option[Long] = None\n        for (i <- lst) {\n            if (i < 0) {\n\
    \                if (largestNegative == None) largestNegative = Some(i)\n    \
    \            else if (i > largestNegative.get) largestNegative = Some(i)\n   \
    \         }\n            else if (i > 0) {\n                if (smallestPositive\
    \ == None) smallestPositive = Some(i)\n                else if (i < smallestPositive.get)\
    \ smallestPositive = Some(i)\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        // Fill in the code here\n        var maxNeg =\
    \ None:Option[Long]\n        var minPos = None:Option[Long]\n        for (i <-\
    \ lst) {\n            if (i < 0) {\n                if (maxNeg == None) {\n  \
    \                  maxNeg = Some(i)\n                } else {\n              \
    \      if (i > maxNeg.get) {\n                        maxNeg = Some(i)\n     \
    \               }\n                }\n            } else if (i > 0) {\n      \
    \          if (minPos == None) {\n                    minPos = Some(i)\n     \
    \           } else {\n                    if (i < minPos.get) {\n            \
    \            minPos = Some(i)\n                    }\n                }\n    \
    \        }\n        }\n        (maxNeg, minPos)", "        // Fill in the code\
    \ here\n        var maxNeg = None:Option[Long]\n        var minPos = None:Option[Long]\n\
    \        for (i <- lst) {\n            if (i < 0) {\n                if (maxNeg\
    \ == None) {\n                    maxNeg = Some(i)\n                } else {\n\
    \                    if (i > maxNeg.get) {\n                        maxNeg = Some(i)\n\
    \                    }\n                }\n            } else if (i > 0) {\n \
    \               if (minPos == None) {\n                    minPos = Some(i)\n\
    \                } else {\n                    if (i < minPos.get) {\n       \
    \                 minPos = Some(i)\n                    }\n                }\n\
    \            }\n        }\n        (maxNeg, minPos)", "        var largestNegative\
    \ : Option[Long] = None\n        var smallestPositive : Option[Long] = None\n\
    \        for (i <- lst) {\n            if (i < 0) {\n                if (largestNegative\
    \ == None) {\n                    largestNegative = Some(i)\n                }\
    \ else {\n                    if (i > largestNegative.get) {\n               \
    \         largestNegative = Some(i)\n                    }\n                }\n\
    \            } else if (i > 0) {\n                if (smallestPositive == None)\
    \ {\n                    smallestPositive = Some(i)\n                } else {\n\
    \                    if (i < smallestPositive.get) {\n                       \
    \ smallestPositive = Some(i)\n                    }\n                }\n     \
    \       }\n        }\n        (largestNegative, smallestPositive)", "        //\
    \ Fill in the code here\n        val neg = lst.filter(_ < 0)\n        val pos\
    \ = lst.filter(_ > 0)\n        val negMax = if (neg.isEmpty) None else Some(neg.max)\n\
    \        val posMin = if (pos.isEmpty) None else Some(pos.min)\n        (negMax,\
    \ posMin)", "        var largestNegative = None : Option[Long]\n        var smallestPositive\
    \ = None : Option[Long]\n        for (i <- lst) {\n            if (i < 0) {\n\
    \                if (largestNegative == None) largestNegative = Some(i)\n    \
    \            else if (i > largestNegative.get) largestNegative = Some(i)\n   \
    \         }\n            else if (i > 0) {\n                if (smallestPositive\
    \ == None) smallestPositive = Some(i)\n                else if (i < smallestPositive.get)\
    \ smallestPositive = Some(i)\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        var largestNegative : Option[Long] = None\n   \
    \     var smallestPositive : Option[Long] = None\n        for (i <- lst) {\n \
    \           if (i < 0) {\n                if (largestNegative.isEmpty) largestNegative\
    \ = Some(i)\n                else if (i > largestNegative.get) largestNegative\
    \ = Some(i)\n            }\n            else if (i > 0) {\n                if\
    \ (smallestPositive.isEmpty) smallestPositive = Some(i)\n                else\
    \ if (i < smallestPositive.get) smallestPositive = Some(i)\n            }\n  \
    \      }\n        (largestNegative, smallestPositive)", "        // Fill in the\
    \ code here\n        (None, None)", "        val neg = lst.filter(_ < 0).maxOption\n\
    \        val pos = lst.filter(_ > 0).minOption\n        (neg, pos)", "       \
    \ var largestNegative : Option[Long] = None\n        var smallestPositive : Option[Long]\
    \ = None\n        for (i <- lst) {\n            if (i < 0) {\n               \
    \ if (largestNegative == None) {\n                    largestNegative = Some(i)\n\
    \                } else {\n                    if (i > largestNegative.get) {\n\
    \                        largestNegative = Some(i)\n                    }\n  \
    \              }\n            } else if (i > 0) {\n                if (smallestPositive\
    \ == None) {\n                    smallestPositive = Some(i)\n               \
    \ } else {\n                    if (i < smallestPositive.get) {\n            \
    \            smallestPositive = Some(i)\n                    }\n             \
    \   }\n            }\n        }\n        return (largestNegative, smallestPositive)",
  "        // Fill in the code here\n        var maxNegative = None:Option[Long]\n\
    \        var minPositive = None:Option[Long]\n        for (i <- lst) {\n     \
    \       if (i < 0) {\n                if (maxNegative == None) {\n           \
    \         maxNegative = Some(i)\n                } else {\n                  \
    \  if (i > maxNegative.get) {\n                        maxNegative = Some(i)\n\
    \                    }\n                }\n            } else if (i > 0) {\n \
    \               if (minPositive == None) {\n                    minPositive =\
    \ Some(i)\n                } else {\n                    if (i < minPositive.get)\
    \ {\n                        minPositive = Some(i)\n                    }\n  \
    \              }\n            }\n        }\n        (maxNegative, minPositive)",
  "        var largestNegative : Option[Long] = None\n        var smallestPositive\
    \ : Option[Long] = None\n        for (i <- lst) {\n            if (i < 0) {\n\
    \                if (largestNegative == None) largestNegative = Some(i)\n    \
    \            else if (i > largestNegative.get) largestNegative = Some(i)\n   \
    \         }\n            else if (i > 0) {\n                if (smallestPositive\
    \ == None) smallestPositive = Some(i)\n                else if (i < smallestPositive.get)\
    \ smallestPositive = Some(i)\n            }\n        }\n        return (largestNegative,\
    \ smallestPositive)", "        // Fill in the code here\n        return (None,\
    \ None)", "        // Fill in the code here.\n        var maxNeg = Option.empty[Long]\n\
    \        var minPos = Option.empty[Long]\n        for (i <- lst) {\n         \
    \   if (i < 0) {\n                if (maxNeg.isEmpty) maxNeg = Some(i)\n     \
    \           else if (i > maxNeg.get) maxNeg = Some(i)\n            }\n       \
    \     else if (i > 0) {\n                if (minPos.isEmpty) minPos = Some(i)\n\
    \                else if (i < minPos.get) minPos = Some(i)\n            }\n  \
    \      }\n        (maxNeg, minPos)", "        // Fill in the code here\n     \
    \   var maxNeg : Option[Long] = None\n        var minPos : Option[Long] = None\n\
    \        for (i <- lst) {\n            if (i < 0) {\n                if (maxNeg\
    \ == None) maxNeg = Some(i)\n                else if (i > maxNeg.get) maxNeg =\
    \ Some(i)\n            }\n            else if (i > 0) {\n                if (minPos\
    \ == None) minPos = Some(i)\n                else if (i < minPos.get) minPos =\
    \ Some(i)\n            }\n        }\n        (maxNeg, minPos)", "        var neg\
    \ : Option[Long] = None\n        var pos : Option[Long] = None\n        for (i\
    \ <- lst) {\n            if (i < 0) {\n                if (neg == None) neg =\
    \ Some(i)\n                else if (i > neg.get) neg = Some(i)\n            }\n\
    \            else if (i > 0) {\n                if (pos == None) pos = Some(i)\n\
    \                else if (i < pos.get) pos = Some(i)\n            }\n        }\n\
    \        (neg, pos)", "        // Fill in the code here\n        (None, None)",
  "        var largestNegative : Option[Long] = None\n        var smallestPositive\
    \ : Option[Long] = None\n        for (i <- lst) {\n            if (i < 0) {\n\
    \                if (largestNegative == None) largestNegative = Some(i)\n    \
    \            else if (i > largestNegative.get) largestNegative = Some(i)\n   \
    \         }\n            else if (i > 0) {\n                if (smallestPositive\
    \ == None) smallestPositive = Some(i)\n                else if (i < smallestPositive.get)\
    \ smallestPositive = Some(i)\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        // Fill in the code here\n        var largestNegative\
    \ = None:Option[Long]\n        var smallestPositive = None:Option[Long]\n    \
    \    for (i <- lst) {\n            if (i < 0) {\n                if (largestNegative\
    \ == None) {\n                    largestNegative = Some(i)\n                }\
    \ else {\n                    if (i > largestNegative.get) {\n               \
    \         largestNegative = Some(i)\n                    }\n                }\n\
    \            } else if (i > 0) {\n                if (smallestPositive == None)\
    \ {\n                    smallestPositive = Some(i)\n                } else {\n\
    \                    if (i < smallestPositive.get) {\n                       \
    \ smallestPositive = Some(i)\n                    }\n                }\n     \
    \       }\n        }\n        (largestNegative, smallestPositive)", "        val\
    \ lst1 = lst.filter(x => x < 0)\n        val lst2 = lst.filter(x => x > 0)\n \
    \       val lst1sorted = lst1.sortWith(_ > _)\n        val lst2sorted = lst2.sortWith(_\
    \ < _)\n        val largest = if (lst1sorted.length > 0) Some(lst1sorted(0)) else\
    \ None\n        val smallest = if (lst2sorted.length > 0) Some(lst2sorted(0))\
    \ else None\n        (largest, smallest)", "        // Fill in the code here\n\
    \        var largestNegative : Option[Long] = None\n        var smallestPositive\
    \ : Option[Long] = None\n        for (i <- lst) {\n            if (i < 0) {\n\
    \                if (largestNegative == None) {\n                    largestNegative\
    \ = Some(i)\n                } else {\n                    largestNegative = Some(max(largestNegative.get,\
    \ i))\n                }\n            } else if (i > 0) {\n                if\
    \ (smallestPositive == None) {\n                    smallestPositive = Some(i)\n\
    \                } else {\n                    smallestPositive = Some(min(smallestPositive.get,\
    \ i))\n                }\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        // Fill in the code here\n        var maxNeg =\
    \ None\n        var minPos = None\n        for (i <- lst) {\n            if (i\
    \ < 0) {\n                if (maxNeg == None) maxNeg = Some(i)\n             \
    \   else if (i > maxNeg.get) maxNeg = Some(i)\n            }\n            else\
    \ if (i > 0) {\n                if (minPos == None) minPos = Some(i)\n       \
    \         else if (i < minPos.get) minPos = Some(i)\n            }\n        }\n\
    \        (maxNeg, minPos)", "        var largestNegative : Option[Long] = None\n\
    \        var smallestPositive : Option[Long] = None\n        for (i <- lst) {\n\
    \            if (i < 0) {\n                if (largestNegative == None) {\n  \
    \                  largestNegative = Some(i)\n                } else {\n     \
    \               if (i > largestNegative.get) {\n                        largestNegative\
    \ = Some(i)\n                    }\n                }\n            } else if (i\
    \ > 0) {\n                if (smallestPositive == None) {\n                  \
    \  smallestPositive = Some(i)\n                } else {\n                    if\
    \ (i < smallestPositive.get) {\n                        smallestPositive = Some(i)\n\
    \                    }\n                }\n            }\n        }\n        return\
    \ (largestNegative, smallestPositive)", "        // Fill in the code here\n  \
    \      return (None, None)", "        // Fill in the code here\n        val negs\
    \ = lst.filter(_ < 0)\n        val poss = lst.filter(_ > 0)\n        val neg =\
    \ if (negs.length > 0) Some(negs.max) else None\n        val pos = if (poss.length\
    \ > 0) Some(poss.min) else None\n        (neg, pos)", "        val negative =\
    \ lst.filter(_ < 0).sortWith(_ > _)\n        val positive = lst.filter(_ > 0).sortWith(_\
    \ < _)\n        val largestNegative = if (negative.isEmpty) None else Some(negative.head)\n\
    \        val smallestPositive = if (positive.isEmpty) None else Some(positive.head)\n\
    \        (largestNegative, smallestPositive)", "        // Your code here\n  \
    \      return (None, None)", "        // Fill in the implementation here.\n  \
    \      return (None, None)", "        // Fill in the code here\n        var largestNegative\
    \ = None : Option[Long]\n        var smallestPositive = None : Option[Long]\n\
    \        for (i <- lst) {\n            if (i < 0) {\n                if (largestNegative\
    \ == None) {\n                    largestNegative = Some(i)\n                }\
    \ else {\n                    if (i > largestNegative.get) {\n               \
    \         largestNegative = Some(i)\n                    }\n                }\n\
    \            } else if (i > 0) {\n                if (smallestPositive == None)\
    \ {\n                    smallestPositive = Some(i)\n                } else {\n\
    \                    if (i < smallestPositive.get) {\n                       \
    \ smallestPositive = Some(i)\n                    }\n                }\n     \
    \       }\n        }\n        (largestNegative, smallestPositive)", "        var\
    \ largestNegative : Option[Long] = None\n        var smallestPositive : Option[Long]\
    \ = None\n        for (x <- lst) {\n            if (x < 0) {\n               \
    \ if (largestNegative == None) {\n                    largestNegative = Some(x)\n\
    \                } else {\n                    if (x > largestNegative.get) {\n\
    \                        largestNegative = Some(x)\n                    }\n  \
    \              }\n            } else if (x > 0) {\n                if (smallestPositive\
    \ == None) {\n                    smallestPositive = Some(x)\n               \
    \ } else {\n                    if (x < smallestPositive.get) {\n            \
    \            smallestPositive = Some(x)\n                    }\n             \
    \   }\n            }\n        }\n        (largestNegative, smallestPositive)",
  "        var largestNegative : Option[Long] = None\n        var smallestPositive\
    \ : Option[Long] = None\n        for (i <- lst) {\n            if (i < 0) {\n\
    \                if (largestNegative == None) largestNegative = Some(i)\n    \
    \            else if (i > largestNegative.get) largestNegative = Some(i)\n   \
    \         }\n            else if (i > 0) {\n                if (smallestPositive\
    \ == None) smallestPositive = Some(i)\n                else if (i < smallestPositive.get)\
    \ smallestPositive = Some(i)\n            }\n        }\n        return (largestNegative,\
    \ smallestPositive)", "        // Fill in the code here\n        var maxNeg =\
    \ None:Option[Long]\n        var minPos = None:Option[Long]\n        for (i <-\
    \ lst) {\n            if (i < 0) {\n                if (maxNeg == None) {\n  \
    \                  maxNeg = Some(i)\n                } else {\n              \
    \      if (i > maxNeg.get) {\n                        maxNeg = Some(i)\n     \
    \               }\n                }\n            } else if (i > 0) {\n      \
    \          if (minPos == None) {\n                    minPos = Some(i)\n     \
    \           } else {\n                    if (i < minPos.get) {\n            \
    \            minPos = Some(i)\n                    }\n                }\n    \
    \        }\n        }\n        (maxNeg, minPos)", "        var largestNegative\
    \ : Option[Long] = None\n        var smallestPositive : Option[Long] = None\n\
    \        for (i <- lst) {\n            if (i < 0) {\n                if (largestNegative\
    \ == None) {\n                    largestNegative = Some(i)\n                }\
    \ else {\n                    if (i > largestNegative.get) {\n               \
    \         largestNegative = Some(i)\n                    }\n                }\n\
    \            } else if (i > 0) {\n                if (smallestPositive == None)\
    \ {\n                    smallestPositive = Some(i)\n                } else {\n\
    \                    if (i < smallestPositive.get) {\n                       \
    \ smallestPositive = Some(i)\n                    }\n                }\n     \
    \       }\n        }\n        return (largestNegative, smallestPositive)", " \
    \       // Fill in the code here\n        val neg = lst.filter(_ < 0)\n      \
    \  val pos = lst.filter(_ > 0)\n        val negMax = if (neg.isEmpty) None else\
    \ Some(neg.max)\n        val posMin = if (pos.isEmpty) None else Some(pos.min)\n\
    \        (negMax, posMin)", "        // Fill in the code here\n        val neg\
    \ = lst.filter(_ < 0)\n        val pos = lst.filter(_ > 0)\n        val negMax\
    \ = if (neg.isEmpty) None else Some(neg.max)\n        val posMin = if (pos.isEmpty)\
    \ None else Some(pos.min)\n        (negMax, posMin)", "        // Fill in the\
    \ implementation here.\n        var largestNegative : Option[Long] = None\n  \
    \      var smallestPositive : Option[Long] = None\n        for (i <- lst) {\n\
    \            if (i < 0) {\n                if (largestNegative == None) {\n  \
    \                  largestNegative = Some(i)\n                } else {\n     \
    \               if (i > largestNegative.get) {\n                        largestNegative\
    \ = Some(i)\n                    }\n                }\n            } else if (i\
    \ > 0) {\n                if (smallestPositive == None) {\n                  \
    \  smallestPositive = Some(i)\n                } else {\n                    if\
    \ (i < smallestPositive.get) {\n                        smallestPositive = Some(i)\n\
    \                    }\n                }\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        // Fill in the code here\n        return (None,\
    \ None)", "        var largestNegative : Option[Long] = None\n        var smallestPositive\
    \ : Option[Long] = None\n        for (i <- lst) {\n            if (i < 0) {\n\
    \                if (largestNegative == None) {\n                    largestNegative\
    \ = Some(i)\n                } else {\n                    if (i > largestNegative.get)\
    \ {\n                        largestNegative = Some(i)\n                    }\n\
    \                }\n            } else if (i > 0) {\n                if (smallestPositive\
    \ == None) {\n                    smallestPositive = Some(i)\n               \
    \ } else {\n                    if (i < smallestPositive.get) {\n            \
    \            smallestPositive = Some(i)\n                    }\n             \
    \   }\n            }\n        }\n        return (largestNegative, smallestPositive)",
  "        // Fill in the code here\n        var maxNeg : Option[Long] = None\n  \
    \      var minPos : Option[Long] = None\n        for (i <- lst) {\n          \
    \  if (i < 0) {\n                if (maxNeg == None) {\n                    maxNeg\
    \ = Some(i)\n                } else {\n                    if (i > maxNeg.get)\
    \ {\n                        maxNeg = Some(i)\n                    }\n       \
    \         }\n            } else if (i > 0) {\n                if (minPos == None)\
    \ {\n                    minPos = Some(i)\n                } else {\n        \
    \            if (i < minPos.get) {\n                        minPos = Some(i)\n\
    \                    }\n                }\n            }\n        }\n        (maxNeg,\
    \ minPos)", "        // Fill in the code here\n        return (None, None)", " \
    \       // Fill in the code here\n        return (None, None)", "        val negative\
    \ = lst.filter(_ < 0).sortWith(_ > _)\n        val positive = lst.filter(_ > 0).sortWith(_\
    \ < _)\n        val largestNegative = if (negative.length > 0) Some(negative(0))\
    \ else None\n        val smallestPositive = if (positive.length > 0) Some(positive(0))\
    \ else None\n        return (largestNegative, smallestPositive)", "        var\
    \ largestNegative : Option[Long] = None\n        var smallestPositive : Option[Long]\
    \ = None\n        for (i <- lst) {\n            if (i < 0) {\n               \
    \ if (largestNegative == None) {\n                    largestNegative = Some(i)\n\
    \                } else {\n                    if (i > largestNegative.get) {\n\
    \                        largestNegative = Some(i)\n                    }\n  \
    \              }\n            } else if (i > 0) {\n                if (smallestPositive\
    \ == None) {\n                    smallestPositive = Some(i)\n               \
    \ } else {\n                    if (i < smallestPositive.get) {\n            \
    \            smallestPositive = Some(i)\n                    }\n             \
    \   }\n            }\n        }\n        return (largestNegative, smallestPositive)",
  "        // Fill in the code here\n        var maxNeg = None:Option[Long]\n    \
    \    var minPos = None:Option[Long]\n        for (i <- lst) {\n            if\
    \ (i < 0) {\n                if (maxNeg == None) {\n                    maxNeg\
    \ = Some(i)\n                } else {\n                    if (i > maxNeg.get)\
    \ {\n                        maxNeg = Some(i)\n                    }\n       \
    \         }\n            } else if (i > 0) {\n                if (minPos == None)\
    \ {\n                    minPos = Some(i)\n                } else {\n        \
    \            if (i < minPos.get) {\n                        minPos = Some(i)\n\
    \                    }\n                }\n            }\n        }\n        (maxNeg,\
    \ minPos)", "        // Fill in the code here\n        (None, None)", "      \
    \  var largestNegative : Option[Long] = None\n        var smallestPositive : Option[Long]\
    \ = None\n        for (i <- lst) {\n            if (i < 0) {\n               \
    \ if (largestNegative == None) largestNegative = Some(i)\n                else\
    \ if (i > largestNegative.get) largestNegative = Some(i)\n            }\n    \
    \        else if (i > 0) {\n                if (smallestPositive == None) smallestPositive\
    \ = Some(i)\n                else if (i < smallestPositive.get) smallestPositive\
    \ = Some(i)\n            }\n        }\n        return (largestNegative, smallestPositive)",
  "        var largestNegative : Option[Long] = None\n        var smallestPositive\
    \ : Option[Long] = None\n        for (i <- lst) {\n            if (i < 0) {\n\
    \                if (largestNegative == None) largestNegative = Some(i)\n    \
    \            else if (i > largestNegative.get) largestNegative = Some(i)\n   \
    \         }\n            else if (i > 0) {\n                if (smallestPositive\
    \ == None) smallestPositive = Some(i)\n                else if (i < smallestPositive.get)\
    \ smallestPositive = Some(i)\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        // Fill in the code here\n        var maxNeg =\
    \ None : Option[Long]\n        var minPos = None : Option[Long]\n        for (i\
    \ <- lst) {\n            if (i < 0) {\n                if (maxNeg == None) {\n\
    \                    maxNeg = Some(i)\n                } else {\n            \
    \        if (i > maxNeg.get) {\n                        maxNeg = Some(i)\n   \
    \                 }\n                }\n            } else if (i > 0) {\n    \
    \            if (minPos == None) {\n                    minPos = Some(i)\n   \
    \             } else {\n                    if (i < minPos.get) {\n          \
    \              minPos = Some(i)\n                    }\n                }\n  \
    \          }\n        }\n        return (maxNeg, minPos)", "        var largestNegative\
    \ : Option[Long] = None\n        var smallestPositive : Option[Long] = None\n\
    \        for (i <- lst) {\n            if (i < 0) {\n                if (largestNegative\
    \ == None) largestNegative = Some(i)\n                else if (i > largestNegative.get)\
    \ largestNegative = Some(i)\n            }\n            else if (i > 0) {\n  \
    \              if (smallestPositive == None) smallestPositive = Some(i)\n    \
    \            else if (i < smallestPositive.get) smallestPositive = Some(i)\n \
    \           }\n        }\n        (largestNegative, smallestPositive)", "    \
    \    // Fill in the code here\n        var largestNegative : Option[Long] = None\n\
    \        var smallestPositive : Option[Long] = None\n        for (i <- lst) {\n\
    \            if (i < 0) {\n                if (largestNegative == None) {\n  \
    \                  largestNegative = Some(i)\n                } else {\n     \
    \               if (i > largestNegative.get) {\n                        largestNegative\
    \ = Some(i)\n                    }\n                }\n            } else if (i\
    \ > 0) {\n                if (smallestPositive == None) {\n                  \
    \  smallestPositive = Some(i)\n                } else {\n                    if\
    \ (i < smallestPositive.get) {\n                        smallestPositive = Some(i)\n\
    \                    }\n                }\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        var largestNegative : Option[Long] = None\n   \
    \     var smallestPositive : Option[Long] = None\n        for (i <- lst) {\n \
    \           if (i < 0) {\n                if (largestNegative == None) largestNegative\
    \ = Some(i)\n                else if (i > largestNegative.get) largestNegative\
    \ = Some(i)\n            }\n            else if (i > 0) {\n                if\
    \ (smallestPositive == None) smallestPositive = Some(i)\n                else\
    \ if (i < smallestPositive.get) smallestPositive = Some(i)\n            }\n  \
    \      }\n        (largestNegative, smallestPositive)", "        // Fill in the\
    \ code here\n        var maxNegative : Option[Long] = None\n        var minPositive\
    \ : Option[Long] = None\n        for (i <- lst) {\n            if (i < 0) {\n\
    \                if (maxNegative == None) maxNegative = Some(i)\n            \
    \    else if (i > maxNegative.get) maxNegative = Some(i)\n            }\n    \
    \        else if (i > 0) {\n                if (minPositive == None) minPositive\
    \ = Some(i)\n                else if (i < minPositive.get) minPositive = Some(i)\n\
    \            }\n        }\n        (maxNegative, minPositive)", "        // Fill\
    \ in the code here\n        var neg = None:Option[Long]\n        var pos = None:Option[Long]\n\
    \        for (i <- lst) {\n            if (i < 0) {\n                if (neg ==\
    \ None) neg = Some(i)\n                else if (i > neg.get) neg = Some(i)\n \
    \           }\n            else if (i > 0) {\n                if (pos == None)\
    \ pos = Some(i)\n                else if (i < pos.get) pos = Some(i)\n       \
    \     }\n        }\n        return (neg, pos)", "        // Fill in the code here\n\
    \        var maxNegative : Option[Long] = None\n        var minPositive : Option[Long]\
    \ = None\n        for (i <- lst) {\n            if (i < 0) {\n               \
    \ if (maxNegative == None) {\n                    maxNegative = Some(i)\n    \
    \            } else {\n                    if (i > maxNegative.get) {\n      \
    \                  maxNegative = Some(i)\n                    }\n            \
    \    }\n            } else if (i > 0) {\n                if (minPositive == None)\
    \ {\n                    minPositive = Some(i)\n                } else {\n   \
    \                 if (i < minPositive.get) {\n                        minPositive\
    \ = Some(i)\n                    }\n                }\n            }\n       \
    \ }\n        (maxNegative, minPositive)", "        var largestNegative : Option[Long]\
    \ = None\n        var smallestPositive : Option[Long] = None\n        for (i <-\
    \ lst) {\n            if (i < 0) {\n                if (largestNegative == None)\
    \ largestNegative = Some(i)\n                else if (i > largestNegative.get)\
    \ largestNegative = Some(i)\n            }\n            else if (i > 0) {\n  \
    \              if (smallestPositive == None) smallestPositive = Some(i)\n    \
    \            else if (i < smallestPositive.get) smallestPositive = Some(i)\n \
    \           }\n        }\n        return (largestNegative, smallestPositive)",
  "        var largestNegative = None : Option[Long]\n        var smallestPositive\
    \ = None : Option[Long]\n        for (i <- lst) {\n            if (i < 0) {\n\
    \                if (largestNegative == None) {\n                    largestNegative\
    \ = Some(i)\n                } else {\n                    if (i > largestNegative.get)\
    \ {\n                        largestNegative = Some(i)\n                    }\n\
    \                }\n            } else if (i > 0) {\n                if (smallestPositive\
    \ == None) {\n                    smallestPositive = Some(i)\n               \
    \ } else {\n                    if (i < smallestPositive.get) {\n            \
    \            smallestPositive = Some(i)\n                    }\n             \
    \   }\n            }\n        }\n        (largestNegative, smallestPositive)",
  "        var largest : Option[Long] = None\n        var smallest : Option[Long]\
    \ = None\n        for (i <- lst) {\n            if (i < 0) {\n               \
    \ if (largest == None) {\n                    largest = Some(i)\n            \
    \    } else {\n                    if (i > largest.get) {\n                  \
    \      largest = Some(i)\n                    }\n                }\n         \
    \   } else if (i > 0) {\n                if (smallest == None) {\n           \
    \         smallest = Some(i)\n                } else {\n                    if\
    \ (i < smallest.get) {\n                        smallest = Some(i)\n         \
    \           }\n                }\n            }\n        }\n        return (largest,\
    \ smallest)", "        var largestNegative : Option[Long] = None\n        var\
    \ smallestPositive : Option[Long] = None\n        for (i <- lst) {\n         \
    \   if (i < 0) {\n                if (largestNegative == None) largestNegative\
    \ = Some(i)\n                else if (i > largestNegative.get) largestNegative\
    \ = Some(i)\n            }\n            else if (i > 0) {\n                if\
    \ (smallestPositive == None) smallestPositive = Some(i)\n                else\
    \ if (i < smallestPositive.get) smallestPositive = Some(i)\n            }\n  \
    \      }\n        (largestNegative, smallestPositive)", "        // Fill in the\
    \ code here\n        var maxNeg = None : Option[Long]\n        var minPos = None\
    \ : Option[Long]\n        for (i <- lst) {\n            if (i < 0) {\n       \
    \         if (maxNeg == None) {\n                    maxNeg = Some(i)\n      \
    \          } else {\n                    if (i > maxNeg.get) {\n             \
    \           maxNeg = Some(i)\n                    }\n                }\n     \
    \       } else if (i > 0) {\n                if (minPos == None) {\n         \
    \           minPos = Some(i)\n                } else {\n                    if\
    \ (i < minPos.get) {\n                        minPos = Some(i)\n             \
    \       }\n                }\n            }\n        }\n        return (maxNeg,\
    \ minPos)", "        // Fill in the code here\n        var maxNeg = None : Option[Long]\n\
    \        var minPos = None : Option[Long]\n        for (i <- lst) {\n        \
    \    if (i < 0) {\n                if (maxNeg == None) {\n                   \
    \ maxNeg = Some(i)\n                } else {\n                    if (i > maxNeg.get)\
    \ {\n                        maxNeg = Some(i)\n                    }\n       \
    \         }\n            } else if (i > 0) {\n                if (minPos == None)\
    \ {\n                    minPos = Some(i)\n                } else {\n        \
    \            if (i < minPos.get) {\n                        minPos = Some(i)\n\
    \                    }\n                }\n            }\n        }\n        (maxNeg,\
    \ minPos)", "        val negative = lst.filter(_ < 0).sorted\n        val positive\
    \ = lst.filter(_ > 0).sorted\n        (if (negative.isEmpty) None else Some(negative.last),\
    \ if (positive.isEmpty) None else Some(positive.head))", "        // Fill in the\
    \ code here\n        var maxNeg = Option.empty[Long]\n        var minPos = Option.empty[Long]\n\
    \        for (i <- lst) {\n            if (i < 0) {\n                if (maxNeg.isEmpty)\
    \ maxNeg = Some(i)\n                else if (i > maxNeg.get) maxNeg = Some(i)\n\
    \            }\n            else if (i > 0) {\n                if (minPos.isEmpty)\
    \ minPos = Some(i)\n                else if (i < minPos.get) minPos = Some(i)\n\
    \            }\n        }\n        (maxNeg, minPos)", "        // Fill in the\
    \ code here\n        var largestNegative = None : Option[Long]\n        var smallestPositive\
    \ = None : Option[Long]\n        for (i <- lst) {\n            if (i < 0) {\n\
    \                if (largestNegative == None) largestNegative = Some(i)\n    \
    \            else if (i > largestNegative.get) largestNegative = Some(i)\n   \
    \         }\n            else if (i > 0) {\n                if (smallestPositive\
    \ == None) smallestPositive = Some(i)\n                else if (i < smallestPositive.get)\
    \ smallestPositive = Some(i)\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        // Fill in the code here\n        var largestNegative\
    \ : Option[Long] = None\n        var smallestPositive : Option[Long] = None\n\
    \        for (i <- lst) {\n            if (i < 0) {\n                if (largestNegative\
    \ == None) largestNegative = Some(i)\n                else if (i > largestNegative.get)\
    \ largestNegative = Some(i)\n            }\n            else if (i > 0) {\n  \
    \              if (smallestPositive == None) smallestPositive = Some(i)\n    \
    \            else if (i < smallestPositive.get) smallestPositive = Some(i)\n \
    \           }\n        }\n        (largestNegative, smallestPositive)", "    \
    \    // Fill in the code here\n        return (None, None)", "        // Fill\
    \ in the code here\n        val neg = lst.filter(_ < 0)\n        val pos = lst.filter(_\
    \ > 0)\n        val negMax = if (neg.isEmpty) None else Some(neg.max)\n      \
    \  val posMin = if (pos.isEmpty) None else Some(pos.min)\n        (negMax, posMin)",
  "        // Fill in the code here\n        var maxNeg = None : Option[Long]\n  \
    \      var minPos = None : Option[Long]\n        for (i <- lst) {\n          \
    \  if (i < 0) {\n                if (maxNeg == None) maxNeg = Some(i)\n      \
    \          else if (i > maxNeg.get) maxNeg = Some(i)\n            }\n        \
    \    else if (i > 0) {\n                if (minPos == None) minPos = Some(i)\n\
    \                else if (i < minPos.get) minPos = Some(i)\n            }\n  \
    \      }\n        (maxNeg, minPos)", "        var largestNegative : Option[Long]\
    \ = None\n        var smallestPositive : Option[Long] = None\n        for (i <-\
    \ lst) {\n            if (i < 0) {\n                if (largestNegative == None)\
    \ largestNegative = Some(i)\n                else if (i > largestNegative.get)\
    \ largestNegative = Some(i)\n            }\n            else if (i > 0) {\n  \
    \              if (smallestPositive == None) smallestPositive = Some(i)\n    \
    \            else if (i < smallestPositive.get) smallestPositive = Some(i)\n \
    \           }\n        }\n        (largestNegative, smallestPositive)", "    \
    \    var largestNegative : Option[Long] = None\n        var smallestPositive :\
    \ Option[Long] = None\n        for (i <- lst) {\n            if (i < 0) {\n  \
    \              if (largestNegative == None) largestNegative = Some(i)\n      \
    \          else if (i > largestNegative.get) largestNegative = Some(i)\n     \
    \       }\n            else if (i > 0) {\n                if (smallestPositive\
    \ == None) smallestPositive = Some(i)\n                else if (i < smallestPositive.get)\
    \ smallestPositive = Some(i)\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        // Fill in the implementation here.\n        return\
    \ (None, None)", "        val neg = lst.filter(x => x < 0).sortWith(_ > _)\n \
    \       val pos = lst.filter(x => x > 0).sortWith(_ < _)\n        val negMax =\
    \ if (neg.length == 0) None else Some(neg(0))\n        val posMin = if (pos.length\
    \ == 0) None else Some(pos(0))\n        (negMax, posMin)", "        var largestNegative\
    \ : Option[Long] = None\n        var smallestPositive : Option[Long] = None\n\
    \        for (i <- lst) {\n            if (i < 0) {\n                if (largestNegative\
    \ == None) largestNegative = Some(i)\n                else if (i > largestNegative.get)\
    \ largestNegative = Some(i)\n            }\n            else if (i > 0) {\n  \
    \              if (smallestPositive == None) smallestPositive = Some(i)\n    \
    \            else if (i < smallestPositive.get) smallestPositive = Some(i)\n \
    \           }\n        }\n        return (largestNegative, smallestPositive)",
  "        // Fill in the code here\n        var min = Long.MaxValue\n        var\
    \ max = Long.MinValue\n        for (i <- lst) {\n            if (i > 0 && i <\
    \ min) min = i\n            if (i < 0 && i > max) max = i\n        }\n       \
    \ if (min == Long.MaxValue) (Some(None), Some(None))\n        else if (max ==\
    \ Long.MinValue) (Some(None), Some(min))\n        else (Some(max), Some(min))",
  "        // Fill in the code here\n        var min = Long.MaxValue\n        var\
    \ max = Long.MinValue\n        for (i <- lst) {\n            if (i < 0) {\n  \
    \              if (i > max) {\n                    max = i\n                }\n\
    \            } else {\n                if (i < min) {\n                    min\
    \ = i\n                }\n            }\n        }\n        if (min == Long.MaxValue)\
    \ {\n            min = None\n        }\n        if (max == Long.MinValue) {\n\
    \            max = None\n        }\n        (max, min)", "        var largestNegative\
    \ : Option[Long] = None\n        var smallestPositive : Option[Long] = None\n\
    \        for (i <- lst) {\n            if (i < 0) {\n                if (largestNegative\
    \ == None) largestNegative = Some(i)\n                else if (i > largestNegative.get)\
    \ largestNegative = Some(i)\n            }\n            else if (i > 0) {\n  \
    \              if (smallestPositive == None) smallestPositive = Some(i)\n    \
    \            else if (i < smallestPositive.get) smallestPositive = Some(i)\n \
    \           }\n        }\n        return (largestNegative, smallestPositive)",
  "        // Fill in the code here\n        var maxNeg = None:Option[Long]\n    \
    \    var minPos = None:Option[Long]\n        for (i <- lst) {\n            if\
    \ (i < 0) {\n                if (maxNeg == None) {\n                    maxNeg\
    \ = Some(i)\n                } else {\n                    if (i > maxNeg.get)\
    \ {\n                        maxNeg = Some(i)\n                    }\n       \
    \         }\n            } else if (i > 0) {\n                if (minPos == None)\
    \ {\n                    minPos = Some(i)\n                } else {\n        \
    \            if (i < minPos.get) {\n                        minPos = Some(i)\n\
    \                    }\n                }\n            }\n        }\n        (maxNeg,\
    \ minPos)", "        var largestNegative : Option[Long] = None\n        var smallestPositive\
    \ : Option[Long] = None\n        for (i <- lst) {\n            if (i < 0) {\n\
    \                if (largestNegative == None) largestNegative = Some(i)\n    \
    \            else if (i > largestNegative.get) largestNegative = Some(i)\n   \
    \         }\n            else if (i > 0) {\n                if (smallestPositive\
    \ == None) smallestPositive = Some(i)\n                else if (i < smallestPositive.get)\
    \ smallestPositive = Some(i)\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        val negative = lst.filter(x => x < 0)\n       \
    \ val positive = lst.filter(x => x > 0)\n        val largestNegative = if (negative.isEmpty)\
    \ None else Some(negative.max)\n        val smallestPositive = if (positive.isEmpty)\
    \ None else Some(positive.min)\n        (largestNegative, smallestPositive)",
  "        // Fill in the code here\n        return (None, None)", "        var largestNegative\
    \ : Option[Long] = None\n        var smallestPositive : Option[Long] = None\n\
    \        for (i <- lst) {\n            if (i < 0) {\n                if (largestNegative\
    \ == None) largestNegative = Some(i)\n                else if (i > largestNegative.get)\
    \ largestNegative = Some(i)\n            }\n            else if (i > 0) {\n  \
    \              if (smallestPositive == None) smallestPositive = Some(i)\n    \
    \            else if (i < smallestPositive.get) smallestPositive = Some(i)\n \
    \           }\n        }\n        return (largestNegative, smallestPositive)",
  "        var largestNegative : Option[Long] = None\n        var smallestPositive\
    \ : Option[Long] = None\n        for (x <- lst) {\n            if (x < 0) {\n\
    \                if (largestNegative == None) largestNegative = Some(x)\n    \
    \            else if (x > largestNegative.get) largestNegative = Some(x)\n   \
    \         }\n            else if (x > 0) {\n                if (smallestPositive\
    \ == None) smallestPositive = Some(x)\n                else if (x < smallestPositive.get)\
    \ smallestPositive = Some(x)\n            }\n        }\n        return (largestNegative,\
    \ smallestPositive)", "        var largestNegative : Option[Long] = None\n   \
    \     var smallestPositive : Option[Long] = None\n        for (i <- lst) {\n \
    \           if (i < 0) {\n                if (largestNegative == None) {\n   \
    \                 largestNegative = Some(i)\n                } else {\n      \
    \              if (i > largestNegative.get) {\n                        largestNegative\
    \ = Some(i)\n                    }\n                }\n            } else if (i\
    \ > 0) {\n                if (smallestPositive == None) {\n                  \
    \  smallestPositive = Some(i)\n                } else {\n                    if\
    \ (i < smallestPositive.get) {\n                        smallestPositive = Some(i)\n\
    \                    }\n                }\n            }\n        }\n        return\
    \ (largestNegative, smallestPositive)", "        // Fill in the code here\n  \
    \      var largestNegative : Option[Long] = None\n        var smallestPositive\
    \ : Option[Long] = None\n        for (i <- lst) {\n            if (i < 0) {\n\
    \                if (largestNegative == None) {\n                    largestNegative\
    \ = Some(i)\n                } else {\n                    if (i > largestNegative.get)\
    \ {\n                        largestNegative = Some(i)\n                    }\n\
    \                }\n            } else if (i > 0) {\n                if (smallestPositive\
    \ == None) {\n                    smallestPositive = Some(i)\n               \
    \ } else {\n                    if (i < smallestPositive.get) {\n            \
    \            smallestPositive = Some(i)\n                    }\n             \
    \   }\n            }\n        }\n        (largestNegative, smallestPositive)",
  "        // Fill in the code here\n        var maxNeg = None:Option[Long]\n    \
    \    var minPos = None:Option[Long]\n        for (i <- lst) {\n            if\
    \ (i < 0) {\n                if (maxNeg == None) {\n                    maxNeg\
    \ = Some(i)\n                } else {\n                    if (i > maxNeg.get)\
    \ {\n                        maxNeg = Some(i)\n                    }\n       \
    \         }\n            } else if (i > 0) {\n                if (minPos == None)\
    \ {\n                    minPos = Some(i)\n                } else {\n        \
    \            if (i < minPos.get) {\n                        minPos = Some(i)\n\
    \                    }\n                }\n            }\n        }\n        return\
    \ (maxNeg, minPos)", "        var largestNegative : Option[Long] = None\n    \
    \    var smallestPositive : Option[Long] = None\n        for (i <- lst) {\n  \
    \          if (i < 0) {\n                if (largestNegative == None) largestNegative\
    \ = Some(i)\n                else if (i > largestNegative.get) largestNegative\
    \ = Some(i)\n            }\n            else if (i > 0) {\n                if\
    \ (smallestPositive == None) smallestPositive = Some(i)\n                else\
    \ if (i < smallestPositive.get) smallestPositive = Some(i)\n            }\n  \
    \      }\n        (largestNegative, smallestPositive)", "        var largestNegative\
    \ : Option[Long] = None\n        var smallestPositive : Option[Long] = None\n\
    \        for (i <- lst) {\n            if (i < 0) {\n                if (largestNegative\
    \ == None) {\n                    largestNegative = Some(i)\n                }\
    \ else {\n                    if (i > largestNegative.get) {\n               \
    \         largestNegative = Some(i)\n                    }\n                }\n\
    \            } else if (i > 0) {\n                if (smallestPositive == None)\
    \ {\n                    smallestPositive = Some(i)\n                } else {\n\
    \                    if (i < smallestPositive.get) {\n                       \
    \ smallestPositive = Some(i)\n                    }\n                }\n     \
    \       }\n        }\n        return (largestNegative, smallestPositive)", " \
    \       // Fill in the code here\n        var maxNeg = Long.MinValue\n       \
    \ var minPos = Long.MaxValue\n        for (i <- lst) {\n            if (i < 0\
    \ && i > maxNeg) maxNeg = i\n            if (i > 0 && i < minPos) minPos = i\n\
    \        }\n        if (maxNeg == Long.MinValue) maxNeg = None\n        if (minPos\
    \ == Long.MaxValue) minPos = None\n        (Some(maxNeg), Some(minPos))"]
stop_tokens:
- "\n    }\n"
