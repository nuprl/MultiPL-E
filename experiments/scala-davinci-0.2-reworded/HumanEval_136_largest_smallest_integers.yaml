name: HumanEval_136_largest_smallest_integers
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Create a function that returns a tuple (a, b), where 'a' is\n    // the\
  \ largest of negative integers, and 'b' is the smallest\n    // of positive integers\
  \ in a list.\n    // If there is no negative or positive integers, return them as\
  \ None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
  \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
  \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
  \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n   \
  \ // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
  \ : Tuple2[Option[Long], Option[Long]] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
  \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n\
  \    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
  \ 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None), Some(1l))));\n\
  \    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
  \ 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n    assert(largestSmallestIntegers((List[Long](4l.toLong,\
  \ 5l.toLong, 3l.toLong, 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l,\
  \ 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong, 3l.toLong, 8l.toLong,\
  \ 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l, 2l)));\n\
  \    assert(largestSmallestIntegers((List[Long]())).equals((Some(None), Some(None))));\n\
  \    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
  \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
  \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
  \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
  \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
  \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
  \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l, 1l)));\n\
  \    }\n\n}\n"
completions: ["        // Fill in the code here\n        var largestNegative = Option.empty[Long]\n\
    \        var smallestPositive = Option.empty[Long]\n        for (i <- lst) {\n\
    \            if (i < 0) {\n                if (largestNegative.isEmpty) {\n  \
    \                  largestNegative = Some(i)\n                } else {\n     \
    \               if (i > largestNegative.get) {\n                        largestNegative\
    \ = Some(i)\n                    }\n                }\n            } else if (i\
    \ > 0) {\n                if (smallestPositive.isEmpty) {\n                  \
    \  smallestPositive = Some(i)\n                } else {\n                    if\
    \ (i < smallestPositive.get) {\n                        smallestPositive = Some(i)\n\
    \                    }\n                }\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        // Fill in the code here\n        (None, None)",
  "        var largestNegative : Option[Long] = None\n        var smallestPositive\
    \ : Option[Long] = None\n        for (i <- lst) {\n            if (i < 0) {\n\
    \                if (largestNegative == None) largestNegative = Some(i)\n    \
    \            else if (i > largestNegative.get) largestNegative = Some(i)\n   \
    \         }\n            else if (i > 0) {\n                if (smallestPositive\
    \ == None) smallestPositive = Some(i)\n                else if (i < smallestPositive.get)\
    \ smallestPositive = Some(i)\n            }\n        }\n        return (largestNegative,\
    \ smallestPositive)", "        // Fill in the code here\n        var maxNeg =\
    \ None:Option[Long]\n        var minPos = None:Option[Long]\n        for (i <-\
    \ lst) {\n            if (i < 0) {\n                if (maxNeg == None) maxNeg\
    \ = Some(i)\n                else if (i > maxNeg.get) maxNeg = Some(i)\n     \
    \       }\n            else if (i > 0) {\n                if (minPos == None)\
    \ minPos = Some(i)\n                else if (i < minPos.get) minPos = Some(i)\n\
    \            }\n        }\n        return (maxNeg, minPos)", "        // Fill\
    \ in the code here\n        var neg = List[Long]()\n        var pos = List[Long]()\n\
    \        for (i <- lst) {\n            if (i < 0) neg = i :: neg\n           \
    \ else if (i > 0) pos = i :: pos\n        }\n        (if (neg.length == 0) None\
    \ else Some(neg.max), if (pos.length == 0) None else Some(pos.min))", "      \
    \  var largestNegative : Option[Long] = None\n        var smallestPositive : Option[Long]\
    \ = None\n        for (i <- lst) {\n            if (i < 0) {\n               \
    \ if (largestNegative == None) {\n                    largestNegative = Some(i)\n\
    \                } else {\n                    if (i > largestNegative.get) {\n\
    \                        largestNegative = Some(i)\n                    }\n  \
    \              }\n            } else if (i > 0) {\n                if (smallestPositive\
    \ == None) {\n                    smallestPositive = Some(i)\n               \
    \ } else {\n                    if (i < smallestPositive.get) {\n            \
    \            smallestPositive = Some(i)\n                    }\n             \
    \   }\n            }\n        }\n        return (largestNegative, smallestPositive)",
  "        // Fill in the code here\n        val neg = lst.filter(_ < 0)\n       \
    \ val pos = lst.filter(_ > 0)\n        val negMax = if (neg.isEmpty) None else\
    \ Some(neg.max)\n        val posMin = if (pos.isEmpty) None else Some(pos.min)\n\
    \        (negMax, posMin)", "        // Fill in the code here\n        var maxNeg\
    \ = None : Option[Long]\n        var minPos = None : Option[Long]\n        for\
    \ (i <- lst) {\n            if (i < 0) {\n                if (maxNeg == None)\
    \ maxNeg = Some(i)\n                else maxNeg = Some(max(maxNeg.get, i))\n \
    \           }\n            else if (i > 0) {\n                if (minPos == None)\
    \ minPos = Some(i)\n                else minPos = Some(min(minPos.get, i))\n \
    \           }\n        }\n        (maxNeg, minPos)", "        var largestNegative\
    \ : Option[Long] = None\n        var smallestPositive : Option[Long] = None\n\
    \        for (i <- lst) {\n            if (i < 0) {\n                if (largestNegative\
    \ == None) largestNegative = Some(i)\n                else if (i > largestNegative.get)\
    \ largestNegative = Some(i)\n            }\n            else if (i > 0) {\n  \
    \              if (smallestPositive == None) smallestPositive = Some(i)\n    \
    \            else if (i < smallestPositive.get) smallestPositive = Some(i)\n \
    \           }\n        }\n        (largestNegative, smallestPositive)", "    \
    \    // Fill in the code here\n        var maxNeg = Long.MinValue\n        var\
    \ minPos = Long.MaxValue\n        for (i <- lst) {\n            if (i < 0) maxNeg\
    \ = max(maxNeg, i)\n            if (i > 0) minPos = min(minPos, i)\n        }\n\
    \        if (maxNeg == Long.MinValue) (None, Some(minPos))\n        else if (minPos\
    \ == Long.MaxValue) (Some(maxNeg), None)\n        else (Some(maxNeg), Some(minPos))",
  "        var largestNegative : Option[Long] = None\n        var smallestPositive\
    \ : Option[Long] = None\n        for (i <- lst) {\n            if (i < 0) {\n\
    \                if (largestNegative == None) largestNegative = Some(i)\n    \
    \            else if (i > largestNegative.get) largestNegative = Some(i)\n   \
    \         }\n            else if (i > 0) {\n                if (smallestPositive\
    \ == None) smallestPositive = Some(i)\n                else if (i < smallestPositive.get)\
    \ smallestPositive = Some(i)\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        // Fill in the code here\n        var neg = List[Long]()\n\
    \        var pos = List[Long]()\n        for (i <- lst) {\n            if (i <\
    \ 0) neg = i :: neg\n            else if (i > 0) pos = i :: pos\n        }\n \
    \       if (neg.length == 0) (None, Some(pos.min))\n        else if (pos.length\
    \ == 0) (Some(neg.max), None)\n        else (Some(neg.max), Some(pos.min))", " \
    \       // Fill in the code here\n        var min = None:Option[Long]\n      \
    \  var max = None:Option[Long]\n        for (i <- lst) {\n            if (i >\
    \ 0) {\n                if (min == None) min = Some(i)\n                else if\
    \ (i < min.get) min = Some(i)\n            }\n            else if (i < 0) {\n\
    \                if (max == None) max = Some(i)\n                else if (i >\
    \ max.get) max = Some(i)\n            }\n        }\n        (max, min)", "   \
    \     var largestNegative : Option[Long] = None\n        var smallestPositive\
    \ : Option[Long] = None\n        for (i <- lst) {\n            if (i < 0) {\n\
    \                if (largestNegative == None) largestNegative = Some(i)\n    \
    \            else if (i > largestNegative.get) largestNegative = Some(i)\n   \
    \         }\n            else if (i > 0) {\n                if (smallestPositive\
    \ == None) smallestPositive = Some(i)\n                else if (i < smallestPositive.get)\
    \ smallestPositive = Some(i)\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        // Fill in the code here\n        (None, None)",
  "        var largestNegative : Option[Long] = None\n        var smallestPositive\
    \ : Option[Long] = None\n        for (i <- lst) {\n            if (i < 0) {\n\
    \                if (largestNegative == None) largestNegative = Some(i)\n    \
    \            else if (i > largestNegative.get) largestNegative = Some(i)\n   \
    \         }\n            else if (i > 0) {\n                if (smallestPositive\
    \ == None) smallestPositive = Some(i)\n                else if (i < smallestPositive.get)\
    \ smallestPositive = Some(i)\n            }\n        }\n        return (largestNegative,\
    \ smallestPositive)", "        // Fill in the implementation here.\n        var\
    \ largestNegative : Option[Long] = None\n        var smallestPositive : Option[Long]\
    \ = None\n        for (i <- lst) {\n            if (i < 0) {\n               \
    \ if (largestNegative == None) {\n                    largestNegative = Some(i)\n\
    \                } else {\n                    if (i > largestNegative.get) {\n\
    \                        largestNegative = Some(i)\n                    }\n  \
    \              }\n            } else if (i > 0) {\n                if (smallestPositive\
    \ == None) {\n                    smallestPositive = Some(i)\n               \
    \ } else {\n                    if (i < smallestPositive.get) {\n            \
    \            smallestPositive = Some(i)\n                    }\n             \
    \   }\n            }\n        }\n        (largestNegative, smallestPositive)",
  "        // Fill in the code here\n        var maxNeg = None:Option[Long]\n    \
    \    var minPos = None:Option[Long]\n        for (i <- lst) {\n            if\
    \ (i < 0) {\n                if (maxNeg == None) {\n                    maxNeg\
    \ = Some(i)\n                } else {\n                    maxNeg = Some(max(maxNeg.get,\
    \ i))\n                }\n            } else if (i > 0) {\n                if\
    \ (minPos == None) {\n                    minPos = Some(i)\n                }\
    \ else {\n                    minPos = Some(min(minPos.get, i))\n            \
    \    }\n            }\n        }\n        return (maxNeg, minPos)", "        //\
    \ Fill in the code here\n        (None, None)", "        // Fill in the code here\n\
    \        var maxNeg = None\n        var minPos = None\n        for (i <- lst)\
    \ {\n            if (i < 0) {\n                if (maxNeg == None) maxNeg = Some(i)\n\
    \                else if (i > maxNeg.get) maxNeg = Some(i)\n            }\n  \
    \          else if (i > 0) {\n                if (minPos == None) minPos = Some(i)\n\
    \                else if (i < minPos.get) minPos = Some(i)\n            }\n  \
    \      }\n        (maxNeg, minPos)"]
stop_tokens:
- "\n    }\n"
