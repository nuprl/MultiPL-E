name: HumanEval_93_encode
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Write a function that takes a message, and encodes in such a \n    // way\
  \ that it swaps case of all letters, replaces all vowels in \n    // the message\
  \ with the letter that appears 2 places ahead of that \n    // vowel in the english\
  \ alphabet. \n    // Assume only letters. \n    // Examples:\n    // >>> encode((\"\
  test\"))\n    // (\"TGST\")\n    // >>> encode((\"This is a message\"))\n    //\
  \ (\"tHKS KS C MGSSCGG\")\n    def encode(message : String) : String = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(encode((\"TEST\"\
  )).equals((\"tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\")));\n\
  \    assert(encode((\"YES\")).equals((\"ygs\")));\n    assert(encode((\"This is\
  \ a message\")).equals((\"tHKS KS C MGSSCGG\")));\n    assert(encode((\"I DoNt KnOw\
  \ WhAt tO WrItE\")).equals((\"k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"
completions: ["        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val alphabetMap2 = alphabet.zipWithIndex.map(x => (x._2 + 2) % 26 ->\
    \ x._1).toMap\n        val message2 = message.toLowerCase.map(x => if (vowels.contains(x))\
    \ alphabetMap2(alphabetMap(x)) else x)\n        message2.map(x => if (x.isUpper)\
    \ x.toLower else x.toUpper).mkString", "        val vowels = Set('a', 'e', 'i',\
    \ 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n        val encoded =\
    \ message.map(c => {\n            if (vowels.contains(c.toLower)) {\n        \
    \        val index = alphabet.indexOf(c.toLower)\n                val newIndex\
    \ = (index + 2) % alphabet.length\n                alphabet(newIndex).toUpper\n\
    \            } else {\n                c.toUpper\n            }\n        })\n\
    \        encoded.mkString", "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n\
    \        val alphabet = ('a' to 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val alphabetMap2 = alphabet.zipWithIndex.map(x => (x._2, x._1)).toMap\n\
    \        val alphabetMap3 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap4 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap5 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap6 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap7 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap8 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap9 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap10 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap11 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap12 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap13 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap14 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap15 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap16 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap17 = alphabet.zipWithIndex.map", "        val vowels =\
    \ Set('a', 'e', 'i', 'o', 'u')\n        def encodeChar(c : Char) : Char = {\n\
    \            val offset = if (vowels.contains(c.toLower)) 2 else 0\n         \
    \   val newChar = ((c.toInt + offset - 'a'.toInt) % 26 + 'a'.toInt).toChar\n \
    \           if (c.isUpper) newChar.toUpper else newChar\n        }\n        message.map(encodeChar)",
  "        val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val alphabetMapReverse = alphabetMap.map(_.swap)\n\
    \        val vowelsMapReverse = vowelsMap.map(_.swap)\n        val messageEncoded\
    \ = message.map(c => {\n            if (vowels.contains(c.toLower)) {\n      \
    \          val index = vowelsMap(c.toLower)\n                val indexNew = (index\
    \ + 2) % vowels.length\n                vowelsMapReverse(indexNew)\n         \
    \   } else if (alphabet.contains(c.toLower)) {\n                val index = alphabetMap(c.toLower)\n\
    \                val indexNew = (index + 2) % alphabet.length\n              \
    \  alphabetMapReverse(indexNew)\n            } else {\n                c\n   \
    \         }\n        })\n        messageEncoded.mkString", "        val vowels\
    \ = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n\
    \        val alphabetMap = alphabet.zipWithIndex.toMap\n        val alphabetMap2\
    \ = alphabet.zipWithIndex.map(x => (x._2, x._1)).toMap\n        val encoded =\
    \ message.map(x => if (vowels.contains(x.toLower)) alphabetMap2((alphabetMap(x.toLower)\
    \ + 2) % 26) else x)\n        encoded.map(x => if (x.isUpper) x.toLower else x.toUpper).mkString",
  "        val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val newAlphabet = alphabet.drop(2) + alphabet.take(2)\n\
    \        val newVowelsMap = vowels.zip(newAlphabet).toMap\n        message.map(c\
    \ => {\n            if (vowels.contains(c.toLower)) {\n                newVowelsMap(c.toLower.toString).toUpperCase\n\
    \            } else {\n                c.toUpper\n            }\n        })",
  "        val vowels = List('a', 'e', 'i', 'o', 'u')\n        val alphabet = 'a'\
    \ to 'z'\n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val encoded\
    \ = message.map(c => {\n            if (vowels.contains(c.toLower)) {\n      \
    \          val index = alphabetMap(c.toLower)\n                alphabet((index\
    \ + 2) % alphabet.length)\n            } else {\n                c\n         \
    \   }\n        })\n        encoded.map(c => if (c.isUpper) c.toLower else c.toUpper).mkString",
  "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a'\
    \ to 'z').toList\n        def encodeChar(c : Char) : Char = {\n            if\
    \ (vowels.contains(c)) {\n                val index = alphabet.indexOf(c)\n  \
    \              alphabet((index + 2) % alphabet.length)\n            } else {\n\
    \                c\n            }\n        }\n        message.map(c => if (c.isUpper)\
    \ c.toLower else c.toUpper).map(encodeChar).mkString", "        var result = \"\
    \"\n        for (c <- message) {\n            if (c.isUpper) result += c.toLower\n\
    \            else if (c.isLower) result += c.toUpper\n            else result\
    \ += c\n        }\n        result", "        val vowels = Set('a', 'e', 'i', 'o',\
    \ 'u')\n        val alphabet = ('a' to 'z').toList\n        val alphabetMap =\
    \ alphabet.zipWithIndex.toMap\n        val encodedAlphabet = alphabet.map(x =>\
    \ if (vowels.contains(x)) alphabet((alphabetMap(x) + 2) % alphabet.length) else\
    \ x)\n        val encodedAlphabetMap = alphabet.zip(encodedAlphabet).toMap\n \
    \       message.map(x => if (vowels.contains(x.toLower)) encodedAlphabetMap(x.toLower)\
    \ else x).map(x => if (x.isUpper) x.toLower else x.toUpper).mkString", "     \
    \   val vowels = \"aeiouAEIOU\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val alphabetMap2\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2) % alphabet.length -> x._1).toMap\n\
    \        val messageMap = message.zipWithIndex.map(x => (x._2, x._1)).toMap\n\
    \        val messageMap2 = message.zipWithIndex.map(x => (x._2, x._1)).toMap\n\
    \        messageMap.foreach(x => {\n            if (vowels.contains(x._2)) {\n\
    \                messageMap2.update(x._1, alphabetMap2(alphabetMap(x._2)))\n \
    \           } else {\n                messageMap2.update(x._1, x._2.toUpper)\n\
    \            }\n        })\n        messageMap2.toSeq.sortBy(_._1).map(_._2).mkString",
  "        val vowels = List('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a'\
    \ to 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n    \
    \    val encoded = message.map(c => {\n            if (vowels.contains(c.toLower))\
    \ {\n                val index = alphabetMap(c.toLower)\n                val newIndex\
    \ = (index + 2) % alphabet.length\n                alphabet(newIndex)\n      \
    \      } else {\n                c\n            }\n        })\n        encoded.mkString",
  "        val vowels = \"aeiouAEIOU\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val newAlphabet\
    \ = alphabet.drop(2) + alphabet.take(2)\n        val newAlphabetMap = newAlphabet.zipWithIndex.toMap\n\
    \        val newMessage = message.map(c => {\n            if (vowels.contains(c))\
    \ {\n                newAlphabet(newAlphabetMap(c))\n            } else if (alphabet.contains(c))\
    \ {\n                alphabet(alphabetMap(c))\n            } else {\n        \
    \        c\n            }\n        })\n        newMessage", "        val vowels\
    \ = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n\
    \        val alphabetMap = alphabet.zipWithIndex.toMap\n        val alphabetMap2\
    \ = alphabet.zipWithIndex.toMap.map(x => (x._2 + 2) % 26 -> x._1)\n        val\
    \ alphabetMap3 = alphabet.zipWithIndex.toMap.map(x => (x._2 + 2) % 26 -> x._1).toMap\n\
    \        message.map(x => if (vowels.contains(x.toLower)) alphabetMap3(alphabetMap(x.toLower))\
    \ else x)", "        val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val newAlphabet = \"cdefghijklmnopqrstuvwxyzab\"\n        val newMessage\
    \ = new StringBuilder\n        for (c <- message) {\n            if (vowels.contains(c.toLower))\
    \ {\n                newMessage.append(newAlphabet(alphabet.indexOf(c.toLower)))\n\
    \            } else {\n                newMessage.append(c.toLower match {\n \
    \                   case 'a' => 'A'\n                    case 'b' => 'B'\n   \
    \                 case 'c' => 'C'\n                    case 'd' => 'D'\n     \
    \               case 'e' => 'E'\n                    case 'f' => 'F'\n       \
    \             case 'g' => 'G'\n                    case 'h' => 'H'\n         \
    \           case 'i' => 'I'\n                    case 'j' => 'J'\n           \
    \         case 'k' => 'K'\n                    case 'l' => 'L'\n             \
    \       case 'm' => 'M'\n                    case 'n' => 'N'\n               \
    \     case 'o' => 'O'\n                    case 'p' => 'P'\n                 \
    \   case 'q' => 'Q'\n                    case 'r' => 'R'\n                   \
    \ case 's' => 'S'\n                    case 't' => 'T'\n                    case\
    \ 'u' => 'U'\n                    case 'v' => 'V'\n                    case 'w'\
    \ => 'W'\n                    case 'x' => 'X'\n                    case 'y' =>\
    \ 'Y'\n                    case 'z' => 'Z'\n                })\n            }\n\
    \        }\n        newMessage.toString", "        val vowels = \"aeiou\"\n  \
    \      val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabetMap\
    \ = alphabet.zipWithIndex.toMap\n        val vowelsMap = vowels.zipWithIndex.toMap\n\
    \        val alphabetMapInv = alphabetMap.map(_.swap)\n        val vowelsMapInv\
    \ = vowelsMap.map(_.swap)\n        val encoded = message.map(c => {\n        \
    \    if (c.isUpper) {\n                alphabetMapInv(alphabetMap(c.toLower) +\
    \ 2).toUpper\n            } else if (vowels.contains(c)) {\n                vowelsMapInv(vowelsMap(c)\
    \ + 2)\n            } else {\n                alphabetMapInv(alphabetMap(c) +\
    \ 2)\n            }\n        })\n        encoded", "        val vowels = List('a',\
    \ 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n        val\
    \ alphabetMap = alphabet.zipWithIndex.toMap\n        val encodedAlphabet = alphabet.map(x\
    \ => {\n            val index = alphabetMap(x)\n            val newIndex = if\
    \ (index + 2 >= alphabet.length) index + 2 - alphabet.length else index + 2\n\
    \            alphabet(newIndex)\n        })\n        val encodedAlphabetMap =\
    \ alphabet.zip(encodedAlphabet).toMap\n        message.map(x => {\n          \
    \  if (vowels.contains(x.toLower)) {\n                encodedAlphabetMap(x.toLower).toUpper\n\
    \            } else {\n                x\n            }\n        })", "      \
    \  val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val encoded = message.map(c => {\n    \
    \        val char = c.toLower\n            if (vowels.contains(char)) {\n    \
    \            val index = vowelsMap(char)\n                val newIndex = (index\
    \ + 2) % vowels.length\n                vowels(newIndex)\n            } else if\
    \ (alphabet.contains(char)) {\n                val index = alphabetMap(char)\n\
    \                val newIndex = (index + 2) % alphabet.length\n              \
    \  alphabet(newIndex)\n            } else {\n                char\n          \
    \  }\n        })\n        encoded.map(c => if (c.isUpper) c.toLower else c.toUpper).mkString",
  "        val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val encoded = for (c <- message) yield\
    \ {\n            if (c.isUpper) {\n                if (vowelsMap.contains(c.toLower))\
    \ {\n                    val index = vowelsMap(c.toLower)\n                  \
    \  val newIndex = (index + 2) % vowels.length\n                    vowels(newIndex).toUpper\n\
    \                } else {\n                    c.toLower\n                }\n\
    \            } else {\n                if (vowelsMap.contains(c)) {\n        \
    \            val index = vowelsMap(c)\n                    val newIndex = (index\
    \ + 2) % vowels.length\n                    vowels(newIndex)\n               \
    \ } else {\n                    c.toUpper\n                }\n            }\n\
    \        }\n        encoded.mkString"]
stop_tokens:
- "\n    }\n"
