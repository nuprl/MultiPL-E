name: HumanEval_93_encode
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Write a function that takes a message, and encodes in such a \n    // way\
  \ that it swaps case of all letters, replaces all vowels in \n    // the message\
  \ with the letter that appears 2 places ahead of that \n    // vowel in the english\
  \ alphabet. \n    // Assume only letters. \n    // Examples:\n    // >>> encode((\"\
  test\"))\n    // (\"TGST\")\n    // >>> encode((\"This is a message\"))\n    //\
  \ (\"tHKS KS C MGSSCGG\")\n    def encode(message : String) : String = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(encode((\"TEST\"\
  )).equals((\"tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\")));\n\
  \    assert(encode((\"YES\")).equals((\"ygs\")));\n    assert(encode((\"This is\
  \ a message\")).equals((\"tHKS KS C MGSSCGG\")));\n    assert(encode((\"I DoNt KnOw\
  \ WhAt tO WrItE\")).equals((\"k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"
completions: ["        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val alphabetMap2 = alphabet.zipWithIndex.map(x => (x._2 + 2) % 26 ->\
    \ x._1).toMap\n        val message2 = message.toLowerCase.map(x => if (vowels.contains(x))\
    \ alphabetMap2(alphabetMap(x)) else x)\n        message2.map(x => if (x.isUpper)\
    \ x.toLower else x.toUpper).mkString", "        val vowels = Set('a', 'e', 'i',\
    \ 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n        val encoded =\
    \ message.map(c => {\n            if (vowels.contains(c.toLower)) {\n        \
    \        val index = alphabet.indexOf(c.toLower)\n                val newIndex\
    \ = (index + 2) % alphabet.length\n                alphabet(newIndex).toUpper\n\
    \            } else {\n                c.toUpper\n            }\n        })\n\
    \        encoded.mkString", "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n\
    \        val alphabet = ('a' to 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val alphabetMap2 = alphabet.zipWithIndex.map(x => (x._2, x._1)).toMap\n\
    \        val alphabetMap3 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap4 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap5 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap6 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap7 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap8 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap9 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap10 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap11 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap12 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap13 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap14 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap15 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap16 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap17 = alphabet.zipWithIndex.map", "        val vowels =\
    \ Set('a', 'e', 'i', 'o', 'u')\n        def encodeChar(c : Char) : Char = {\n\
    \            val offset = if (vowels.contains(c.toLower)) 2 else 0\n         \
    \   val newChar = ((c.toInt + offset - 'a'.toInt) % 26 + 'a'.toInt).toChar\n \
    \           if (c.isUpper) newChar.toUpper else newChar\n        }\n        message.map(encodeChar)",
  "        val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val alphabetMapReverse = alphabetMap.map(_.swap)\n\
    \        val vowelsMapReverse = vowelsMap.map(_.swap)\n        val messageEncoded\
    \ = message.map(c => {\n            if (vowels.contains(c.toLower)) {\n      \
    \          val index = vowelsMap(c.toLower)\n                val indexNew = (index\
    \ + 2) % vowels.length\n                vowelsMapReverse(indexNew)\n         \
    \   } else if (alphabet.contains(c.toLower)) {\n                val index = alphabetMap(c.toLower)\n\
    \                val indexNew = (index + 2) % alphabet.length\n              \
    \  alphabetMapReverse(indexNew)\n            } else {\n                c\n   \
    \         }\n        })\n        messageEncoded.mkString", "        val vowels\
    \ = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n\
    \        val alphabetMap = alphabet.zipWithIndex.toMap\n        val alphabetMap2\
    \ = alphabet.zipWithIndex.map(x => (x._2, x._1)).toMap\n        val encoded =\
    \ message.map(x => if (vowels.contains(x.toLower)) alphabetMap2((alphabetMap(x.toLower)\
    \ + 2) % 26) else x)\n        encoded.map(x => if (x.isUpper) x.toLower else x.toUpper).mkString",
  "        val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val newAlphabet = alphabet.drop(2) + alphabet.take(2)\n\
    \        val newVowelsMap = vowels.zip(newAlphabet).toMap\n        message.map(c\
    \ => {\n            if (vowels.contains(c.toLower)) {\n                newVowelsMap(c.toLower.toString).toUpperCase\n\
    \            } else {\n                c.toUpper\n            }\n        })",
  "        val vowels = List('a', 'e', 'i', 'o', 'u')\n        val alphabet = 'a'\
    \ to 'z'\n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val encoded\
    \ = message.map(c => {\n            if (vowels.contains(c.toLower)) {\n      \
    \          val index = alphabetMap(c.toLower)\n                alphabet((index\
    \ + 2) % alphabet.length)\n            } else {\n                c\n         \
    \   }\n        })\n        encoded.map(c => if (c.isUpper) c.toLower else c.toUpper).mkString",
  "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a'\
    \ to 'z').toList\n        def encodeChar(c : Char) : Char = {\n            if\
    \ (vowels.contains(c)) {\n                val index = alphabet.indexOf(c)\n  \
    \              alphabet((index + 2) % alphabet.length)\n            } else {\n\
    \                c\n            }\n        }\n        message.map(c => if (c.isUpper)\
    \ c.toLower else c.toUpper).map(encodeChar).mkString", "        var result = \"\
    \"\n        for (c <- message) {\n            if (c.isUpper) result += c.toLower\n\
    \            else if (c.isLower) result += c.toUpper\n            else result\
    \ += c\n        }\n        result", "        val vowels = Set('a', 'e', 'i', 'o',\
    \ 'u')\n        val alphabet = ('a' to 'z').toList\n        val alphabetMap =\
    \ alphabet.zipWithIndex.toMap\n        val encodedAlphabet = alphabet.map(x =>\
    \ if (vowels.contains(x)) alphabet((alphabetMap(x) + 2) % alphabet.length) else\
    \ x)\n        val encodedAlphabetMap = alphabet.zip(encodedAlphabet).toMap\n \
    \       message.map(x => if (vowels.contains(x.toLower)) encodedAlphabetMap(x.toLower)\
    \ else x).map(x => if (x.isUpper) x.toLower else x.toUpper).mkString", "     \
    \   val vowels = \"aeiouAEIOU\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val alphabetMap2\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2) % alphabet.length -> x._1).toMap\n\
    \        val messageMap = message.zipWithIndex.map(x => (x._2, x._1)).toMap\n\
    \        val messageMap2 = message.zipWithIndex.map(x => (x._2, x._1)).toMap\n\
    \        messageMap.foreach(x => {\n            if (vowels.contains(x._2)) {\n\
    \                messageMap2.update(x._1, alphabetMap2(alphabetMap(x._2)))\n \
    \           } else {\n                messageMap2.update(x._1, x._2.toUpper)\n\
    \            }\n        })\n        messageMap2.toSeq.sortBy(_._1).map(_._2).mkString",
  "        val vowels = List('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a'\
    \ to 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n    \
    \    val encoded = message.map(c => {\n            if (vowels.contains(c.toLower))\
    \ {\n                val index = alphabetMap(c.toLower)\n                val newIndex\
    \ = (index + 2) % alphabet.length\n                alphabet(newIndex)\n      \
    \      } else {\n                c\n            }\n        })\n        encoded.mkString",
  "        val vowels = \"aeiouAEIOU\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val newAlphabet\
    \ = alphabet.drop(2) + alphabet.take(2)\n        val newAlphabetMap = newAlphabet.zipWithIndex.toMap\n\
    \        val newMessage = message.map(c => {\n            if (vowels.contains(c))\
    \ {\n                newAlphabet(newAlphabetMap(c))\n            } else if (alphabet.contains(c))\
    \ {\n                alphabet(alphabetMap(c))\n            } else {\n        \
    \        c\n            }\n        })\n        newMessage", "        val vowels\
    \ = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n\
    \        val alphabetMap = alphabet.zipWithIndex.toMap\n        val alphabetMap2\
    \ = alphabet.zipWithIndex.toMap.map(x => (x._2 + 2) % 26 -> x._1)\n        val\
    \ alphabetMap3 = alphabet.zipWithIndex.toMap.map(x => (x._2 + 2) % 26 -> x._1).toMap\n\
    \        message.map(x => if (vowels.contains(x.toLower)) alphabetMap3(alphabetMap(x.toLower))\
    \ else x)", "        val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val newAlphabet = \"cdefghijklmnopqrstuvwxyzab\"\n        val newMessage\
    \ = new StringBuilder\n        for (c <- message) {\n            if (vowels.contains(c.toLower))\
    \ {\n                newMessage.append(newAlphabet(alphabet.indexOf(c.toLower)))\n\
    \            } else {\n                newMessage.append(c.toLower match {\n \
    \                   case 'a' => 'A'\n                    case 'b' => 'B'\n   \
    \                 case 'c' => 'C'\n                    case 'd' => 'D'\n     \
    \               case 'e' => 'E'\n                    case 'f' => 'F'\n       \
    \             case 'g' => 'G'\n                    case 'h' => 'H'\n         \
    \           case 'i' => 'I'\n                    case 'j' => 'J'\n           \
    \         case 'k' => 'K'\n                    case 'l' => 'L'\n             \
    \       case 'm' => 'M'\n                    case 'n' => 'N'\n               \
    \     case 'o' => 'O'\n                    case 'p' => 'P'\n                 \
    \   case 'q' => 'Q'\n                    case 'r' => 'R'\n                   \
    \ case 's' => 'S'\n                    case 't' => 'T'\n                    case\
    \ 'u' => 'U'\n                    case 'v' => 'V'\n                    case 'w'\
    \ => 'W'\n                    case 'x' => 'X'\n                    case 'y' =>\
    \ 'Y'\n                    case 'z' => 'Z'\n                })\n            }\n\
    \        }\n        newMessage.toString", "        val vowels = \"aeiou\"\n  \
    \      val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabetMap\
    \ = alphabet.zipWithIndex.toMap\n        val vowelsMap = vowels.zipWithIndex.toMap\n\
    \        val alphabetMapInv = alphabetMap.map(_.swap)\n        val vowelsMapInv\
    \ = vowelsMap.map(_.swap)\n        val encoded = message.map(c => {\n        \
    \    if (c.isUpper) {\n                alphabetMapInv(alphabetMap(c.toLower) +\
    \ 2).toUpper\n            } else if (vowels.contains(c)) {\n                vowelsMapInv(vowelsMap(c)\
    \ + 2)\n            } else {\n                alphabetMapInv(alphabetMap(c) +\
    \ 2)\n            }\n        })\n        encoded", "        val vowels = List('a',\
    \ 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n        val\
    \ alphabetMap = alphabet.zipWithIndex.toMap\n        val encodedAlphabet = alphabet.map(x\
    \ => {\n            val index = alphabetMap(x)\n            val newIndex = if\
    \ (index + 2 >= alphabet.length) index + 2 - alphabet.length else index + 2\n\
    \            alphabet(newIndex)\n        })\n        val encodedAlphabetMap =\
    \ alphabet.zip(encodedAlphabet).toMap\n        message.map(x => {\n          \
    \  if (vowels.contains(x.toLower)) {\n                encodedAlphabetMap(x.toLower).toUpper\n\
    \            } else {\n                x\n            }\n        })", "      \
    \  val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val encoded = message.map(c => {\n    \
    \        val char = c.toLower\n            if (vowels.contains(char)) {\n    \
    \            val index = vowelsMap(char)\n                val newIndex = (index\
    \ + 2) % vowels.length\n                vowels(newIndex)\n            } else if\
    \ (alphabet.contains(char)) {\n                val index = alphabetMap(char)\n\
    \                val newIndex = (index + 2) % alphabet.length\n              \
    \  alphabet(newIndex)\n            } else {\n                char\n          \
    \  }\n        })\n        encoded.map(c => if (c.isUpper) c.toLower else c.toUpper).mkString",
  "        val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val encoded = for (c <- message) yield\
    \ {\n            if (c.isUpper) {\n                if (vowelsMap.contains(c.toLower))\
    \ {\n                    val index = vowelsMap(c.toLower)\n                  \
    \  val newIndex = (index + 2) % vowels.length\n                    vowels(newIndex).toUpper\n\
    \                } else {\n                    c.toLower\n                }\n\
    \            } else {\n                if (vowelsMap.contains(c)) {\n        \
    \            val index = vowelsMap(c)\n                    val newIndex = (index\
    \ + 2) % vowels.length\n                    vowels(newIndex)\n               \
    \ } else {\n                    c.toUpper\n                }\n            }\n\
    \        }\n        encoded.mkString", "        val vowels = \"aeiou\"\n     \
    \   val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabetMap = (alphabet\
    \ zip alphabet.tail).toMap\n        val vowelsMap = (vowels zip vowels.tail.tail).toMap\n\
    \        message.map(c => if (vowels.contains(c.toLower)) vowelsMap(c.toLower).toUpper\
    \ else alphabetMap(c.toLower).toUpper)", "        val vowels = List('a', 'e',\
    \ 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n        val alphabetMap\
    \ = alphabet.zipWithIndex.toMap\n        val alphabetMap2 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2) % 26 -> x._1).toMap\n        message.map(x => if (vowels.contains(x.toLower))\
    \ alphabetMap2(alphabetMap(x.toLower)) else x)", "        val vowels = List('a',\
    \ 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n        val\
    \ alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap = vowels.zipWithIndex.toMap\n\
    \        val messageList = message.toList\n        val encodedList = messageList.map(x\
    \ => {\n            if (vowels.contains(x.toLower)) {\n                val index\
    \ = vowelsMap(x.toLower)\n                val nextIndex = (index + 2) % vowels.length\n\
    \                val nextVowel = vowels(nextIndex)\n                if (x.isUpper)\
    \ nextVowel.toUpper else nextVowel\n            } else if (alphabet.contains(x.toLower))\
    \ {\n                val index = alphabetMap(x.toLower)\n                val nextIndex\
    \ = (index + 2) % alphabet.length\n                val nextLetter = alphabet(nextIndex)\n\
    \                if (x.isUpper) nextLetter.toUpper else nextLetter\n         \
    \   } else x\n        })\n        encodedList.mkString", "        val vowels =\
    \ \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val\
    \ alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap = vowels.zipWithIndex.toMap\n\
    \        val alphabetMap2 = alphabet.zipWithIndex.map(x => (x._2, x._1)).toMap\n\
    \        val vowelsMap2 = vowels.zipWithIndex.map(x => (x._2, x._1)).toMap\n \
    \       def encodeChar(c : Char) : Char = {\n            if (c.isUpper) {\n  \
    \              val index = alphabetMap(c.toLower)\n                alphabetMap2(index).toUpper\n\
    \            } else if (vowels.contains(c)) {\n                val index = vowelsMap(c)\n\
    \                vowelsMap2((index + 2) % 5)\n            } else {\n         \
    \       c\n            }\n        }\n        message.map(encodeChar)", "     \
    \   val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to\
    \ 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n       \
    \ val alphabetMap2 = alphabet.zipWithIndex.map(x => (x._2, x._1)).toMap\n    \
    \    val alphabetMap3 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap4 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap5 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap6 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap7 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap8 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap9 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap10 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap11 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap12 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap13 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap14 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap15 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap16 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap17 = alphabet.zipWithIndex.map", "        val vowels =\
    \ Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n \
    \       val alphabetMap = alphabet.zipWithIndex.toMap\n        val alphabetMap2\
    \ = alphabet.zipWithIndex.map { case (c, i) => (c, (i + 2) % alphabet.length)\
    \ }.toMap\n        message.map { c =>\n            if (vowels.contains(c.toLower))\
    \ {\n                alphabet(alphabetMap2(c.toLower))\n            } else if\
    \ (c.isUpper) {\n                alphabet(alphabetMap(c.toLower)).toUpper\n  \
    \          } else {\n                alphabet(alphabetMap(c))\n            }\n\
    \        }.mkString", "        val vowels = \"aeiou\"\n        val alphabet =\
    \ \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val vowelsMap = vowels.zipWithIndex.toMap\n        val encoded = message.map(c\
    \ => {\n            if (vowels.contains(c.toLower)) {\n                val index\
    \ = vowelsMap(c.toLower)\n                val newIndex = (index + 2) % vowels.length\n\
    \                vowels(newIndex).toUpper\n            } else if (alphabet.contains(c.toLower))\
    \ {\n                val index = alphabetMap(c.toLower)\n                val newIndex\
    \ = (index + 2) % alphabet.length\n                alphabet(newIndex).toUpper\n\
    \            } else {\n                c\n            }\n        })\n        encoded",
  "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a'\
    \ to 'z').toArray\n        val encoded = message.map(c => if (vowels.contains(c.toLower))\
    \ alphabet((alphabet.indexOf(c.toLower) + 2) % alphabet.length) else c)\n    \
    \    encoded.map(c => if (c.isUpper) c.toLower else c.toUpper).mkString", "  \
    \      val vowels = List('a', 'e', 'i', 'o', 'u')\n        val alphabet = 'a'\
    \ to 'z'\n        val letters = message.toLowerCase.toList\n        val encoded\
    \ = letters.map(x => if (vowels.contains(x)) alphabet((alphabet.indexOf(x) + 2)\
    \ % 26) else x)\n        encoded.map(x => if (x.isUpper) x.toLower else x.toUpper).mkString",
  "        val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        var result = \"\"\n        for (c <- message) {\n            if (vowels.contains(c.toLower))\
    \ {\n                val index = alphabet.indexOf(c.toLower)\n               \
    \ result += alphabet((index + 2) % 26)\n            } else {\n               \
    \ result += c\n            }\n        }\n        result", "        val vowels\
    \ = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n       \
    \ val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap = vowels.zipWithIndex.toMap\n\
    \        val alphabetList = alphabet.toList\n        val vowelsList = vowels.toList\n\
    \        val messageList = message.toList\n        val result = messageList.map(c\
    \ => {\n            if (vowels.contains(c.toLower)) {\n                val index\
    \ = vowelsMap(c.toLower)\n                val newIndex = (index + 2) % vowels.length\n\
    \                vowelsList(newIndex).toUpper\n            } else if (alphabet.contains(c.toLower))\
    \ {\n                val index = alphabetMap(c.toLower)\n                val newIndex\
    \ = (index + 2) % alphabet.length\n                alphabetList(newIndex).toUpper\n\
    \            } else {\n                c\n            }\n        })\n        result.mkString",
  "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a'\
    \ to 'z').toList\n        def encodeChar(c : Char) : Char = {\n            if\
    \ (vowels.contains(c)) {\n                val index = alphabet.indexOf(c)\n  \
    \              alphabet((index + 2) % alphabet.length)\n            } else if\
    \ (c.isUpper) {\n                c.toLower\n            } else {\n           \
    \     c.toUpper\n            }\n        }\n        message.map(encodeChar)", " \
    \       val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val alphabetMap2\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2) % 26 -> x._1).toMap\n        message.map(x\
    \ => if (vowels.contains(x.toLower)) alphabetMap2(alphabetMap(x.toLower)) else\
    \ x).map(x => if (x.isUpper) x.toLower else x.toUpper).mkString", "        val\
    \ vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        def encodeChar(c : Char) : Char = {\n            if (vowels.contains(c))\
    \ {\n                val index = alphabet.indexOf(c)\n                alphabet((index\
    \ + 2) % alphabet.length)\n            } else {\n                if (c.isUpper)\
    \ c.toLower else c.toUpper\n            }\n        }\n        message.map(encodeChar)",
  "        var result = \"\"\n        for (c <- message) {\n            if (c.isUpper)\
    \ result += c.toLower\n            else if (c.isLower) result += c.toUpper\n \
    \           else result += c\n        }\n        result", "        val vowels\
    \ = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = 'a' to 'z'\n        val\
    \ map = alphabet.zip(alphabet.drop(2) ++ alphabet.take(2)).toMap\n        message.map(c\
    \ => if (vowels.contains(c.toLower)) map(c.toLower) else c).map(c => if (c.isUpper)\
    \ c.toLower else c.toUpper).mkString", "        val vowels = List('a', 'e', 'i',\
    \ 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n        val alphabetMap\
    \ = alphabet.zipWithIndex.toMap\n        val encodedAlphabet = alphabet.map(x\
    \ => {\n            if (vowels.contains(x)) {\n                val index = alphabetMap(x)\n\
    \                alphabet((index + 2) % alphabet.length)\n            } else {\n\
    \                x\n            }\n        })\n        val encodedAlphabetMap\
    \ = alphabet.zip(encodedAlphabet).toMap\n        message.map(x => {\n        \
    \    val index = alphabetMap(x.toLower)\n            if (x.isUpper) {\n      \
    \          encodedAlphabet(index).toUpper\n            } else {\n            \
    \    encodedAlphabet(index)\n            }\n        })", "        val vowels =\
    \ \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val\
    \ alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap = vowels.zipWithIndex.toMap\n\
    \        val encoded = new StringBuilder\n        for (c <- message) {\n     \
    \       if (c.isUpper) {\n                encoded += c.toLower\n            }\
    \ else if (c.isLower) {\n                if (vowels.contains(c)) {\n         \
    \           val index = (vowelsMap(c) + 2) % vowels.length\n                 \
    \   encoded += vowels(index)\n                } else {\n                    encoded\
    \ += c\n                }\n            } else {\n                encoded += c\n\
    \            }\n        }\n        encoded.toString", "        var result = \"\
    \"\n        for (c <- message) {\n            if (c.isUpper) {\n             \
    \   result += c.toLower\n            } else if (c.isLower) {\n               \
    \ result += c.toUpper\n            } else {\n                result += c\n   \
    \         }\n        }\n        result", "        val vowels = Set('a', 'e', 'i',\
    \ 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n        val alphabetMap\
    \ = alphabet.zipWithIndex.toMap\n        val alphabetSize = alphabet.size\n  \
    \      def encodeChar(c : Char) : Char = {\n            val upper = c.isUpper\n\
    \            val c2 = c.toLower\n            if (vowels.contains(c2)) {\n    \
    \            val index = alphabetMap(c2)\n                val newIndex = (index\
    \ + 2) % alphabetSize\n                val newChar = alphabet(newIndex)\n    \
    \            if (upper) newChar.toUpper else newChar\n            } else {\n \
    \               if (upper) c2.toUpper else c2\n            }\n        }\n    \
    \    message.map(encodeChar)", "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n\
    \        val vowels2 = Set('c', 'f', 'j', 'n', 'r')\n        val vowels3 = Set('b',\
    \ 'd', 'h', 'l', 'p', 't', 'v', 'x', 'z')\n        val vowels4 = Set('a', 'e',\
    \ 'i', 'o', 'u')\n        val vowels5 = Set('c', 'f', 'j', 'n', 'r')\n       \
    \ val vowels6 = Set('b', 'd', 'h', 'l', 'p', 't', 'v', 'x', 'z')\n        val\
    \ vowels7 = Set('a', 'e', 'i', 'o', 'u')\n        val vowels8 = Set('c', 'f',\
    \ 'j', 'n', 'r')\n        val vowels9 = Set('b', 'd', 'h', 'l', 'p', 't', 'v',\
    \ 'x', 'z')\n        val vowels10 = Set('a', 'e', 'i', 'o', 'u')\n        val\
    \ vowels11 = Set('c', 'f', 'j', 'n', 'r')\n        val vowels12 = Set('b', 'd',\
    \ 'h', 'l', 'p', 't', 'v', 'x', 'z')\n        val vowels13 = Set('a', 'e', 'i',\
    \ 'o', 'u')\n        val vowels14 = Set('c', 'f', 'j', 'n', 'r')\n        val\
    \ vowels15 = Set('b', 'd', 'h', 'l', 'p', 't', 'v', 'x', 'z')\n        val vowels16\
    \ = Set('a', 'e', 'i', 'o', 'u')\n        val vowels17 = Set('c', 'f', 'j', 'n',\
    \ 'r')\n        val vowels18 = Set('b', 'd', 'h', 'l', 'p', 't', 'v', 'x', 'z')\n\
    \        val vowels19 = Set('a', 'e', 'i', 'o', 'u')\n        val vow", "    \
    \    val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val encoded = message.map(c => {\n    \
    \        if (vowels.contains(c.toLower)) {\n                val index = vowelsMap(c.toLower)\n\
    \                val newIndex = (index + 2) % vowels.length\n                vowels(newIndex).toUpper\n\
    \            } else {\n                if (c.isUpper) alphabet(alphabetMap(c.toLower)\
    \ + 1).toUpper\n                else alphabet(alphabetMap(c) + 1)\n          \
    \  }\n        })\n        encoded", "        def encodeChar(c : Char) : Char =\
    \ {\n            if (c.isUpper) {\n                if (c == 'Z') 'B'\n       \
    \         else if (c == 'Y') 'A'\n                else (c + 2).toChar\n      \
    \      } else {\n                if (c == 'z') 'b'\n                else if (c\
    \ == 'y') 'a'\n                else (c + 2).toChar\n            }\n        }\n\
    \        message.map(c => if (c.isLetter) encodeChar(c) else c)", "        val\
    \ vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val alphabetMap2\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2) % 26 -> x._1).toMap\n        message.map(x\
    \ => if (vowels.contains(x.toLower)) alphabetMap2(alphabetMap(x.toLower)) else\
    \ x)", "        val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val encoded = message.map(c => {\n    \
    \        if (vowels.contains(c.toLower)) {\n                val index = vowelsMap(c.toLower)\n\
    \                val nextIndex = (index + 2) % vowels.length\n               \
    \ val nextVowel = vowels(nextIndex)\n                if (c.isUpper) nextVowel.toUpper\
    \ else nextVowel\n            } else if (alphabet.contains(c.toLower)) {\n   \
    \             val index = alphabetMap(c.toLower)\n                val nextIndex\
    \ = (index + 1) % alphabet.length\n                val nextLetter = alphabet(nextIndex)\n\
    \                if (c.isUpper) nextLetter.toUpper else nextLetter\n         \
    \   } else c\n        })\n        encoded", "        val vowels = \"aeiou\"\n\
    \        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabetMap\
    \ = alphabet.zipWithIndex.toMap\n        val vowelsMap = vowels.zipWithIndex.toMap\n\
    \        val alphabetMap2 = alphabet.zipWithIndex.map(x => (x._2, x._1)).toMap\n\
    \        val vowelsMap2 = vowels.zipWithIndex.map(x => (x._2, x._1)).toMap\n \
    \       val result = new StringBuilder\n        for (c <- message) {\n       \
    \     if (vowels.contains(c.toLower)) {\n                val index = vowelsMap(c.toLower)\n\
    \                val newIndex = (index + 2) % 5\n                val newChar =\
    \ vowelsMap2(newIndex)\n                if (c.isUpper) result.append(newChar.toUpper)\n\
    \                else result.append(newChar)\n            } else {\n         \
    \       val index = alphabetMap(c.toLower)\n                val newIndex = (index\
    \ + 2) % 26\n                val newChar = alphabetMap2(newIndex)\n          \
    \      if (c.isUpper) result.append(newChar.toUpper)\n                else result.append(newChar)\n\
    \            }\n        }\n        result.toString", "        val vowels = \"\
    aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabetMap\
    \ = alphabet.zipWithIndex.toMap\n        val vowelsMap = vowels.zipWithIndex.toMap\n\
    \        val encoded = for (c <- message) yield {\n            if (vowels.contains(c.toLower))\
    \ {\n                val index = vowelsMap(c.toLower)\n                val newIndex\
    \ = (index + 2) % vowels.length\n                vowels(newIndex).toUpper\n  \
    \          } else {\n                if (c.isUpper) alphabet(alphabetMap(c.toLower)).toUpper\
    \ else alphabet(alphabetMap(c))\n            }\n        }\n        encoded.mkString",
  "        val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val map = alphabet.zipWithIndex.toMap\n        val map2 = vowels.zipWithIndex.toMap\n\
    \        val map3 = vowels.zipWithIndex.map(x => (x._2, x._1)).toMap\n       \
    \ val map4 = alphabet.zipWithIndex.map(x => (x._2, x._1)).toMap\n        val map5\
    \ = vowels.zipWithIndex.map(x => (x._2, (x._2 + 2) % 5)).toMap\n        val map6\
    \ = vowels.zipWithIndex.map(x => ((x._2 + 2) % 5, x._1)).toMap\n        val map7\
    \ = vowels.zipWithIndex.map(x => (x._2, (x._2 + 2) % 5)).toMap\n        val map8\
    \ = vowels.zipWithIndex.map(x => ((x._2 + 2) % 5, x._1)).toMap\n        val map9\
    \ = vowels.zipWithIndex.map(x => (x._2, (x._2 + 2) % 5)).toMap\n        val map10\
    \ = vowels.zipWithIndex.map(x => ((x._2 + 2) % 5, x._1)).toMap\n        val map11\
    \ = vowels.zipWithIndex.map(x => (x._2, (x._2 + 2) % 5)).toMap\n        val map12\
    \ = vowels.zipWithIndex.map(x => ((x._2 + 2) % 5, x._1)).toMap\n        val map13\
    \ = vowels.zipWithIndex.map(x => (x._2, (x._2 + 2) % 5)).toMap\n        val map14\
    \ = vowels.zipWithIndex.map(x => ((x._2 + 2) % 5, x._1)).toMap\n        val map15\
    \ = vowels.zipWithIndex.map(x => (x._2, (x._2 + 2) % 5)).toMap\n        val map16\
    \ = vowels.zipWithIndex.map(x => ((x._2 + 2) % 5, x", "        val vowels = Set('a',\
    \ 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n        val\
    \ alphabetMap = alphabet.zipWithIndex.toMap\n        val alphabetMap2 = alphabet.zipWithIndex.map(x\
    \ => (x._2, x._1)).toMap\n        val encodeMap = alphabet.zipWithIndex.map(x\
    \ => (x._1, alphabetMap2((x._2 + 2) % 26))).toMap\n        val encodeMap2 = alphabet.zipWithIndex.map(x\
    \ => (x._1, alphabetMap2((x._2 + 2) % 26))).toMap\n        val encodeMap3 = alphabet.zipWithIndex.map(x\
    \ => (x._1, alphabetMap2((x._2 + 2) % 26))).toMap\n        val encodeMap4 = alphabet.zipWithIndex.map(x\
    \ => (x._1, alphabetMap2((x._2 + 2) % 26))).toMap\n        val encodeMap5 = alphabet.zipWithIndex.map(x\
    \ => (x._1, alphabetMap2((x._2 + 2) % 26))).toMap\n        val encodeMap6 = alphabet.zipWithIndex.map(x\
    \ => (x._1, alphabetMap2((x._2 + 2) % 26))).toMap\n        val encodeMap7 = alphabet.zipWithIndex.map(x\
    \ => (x._1, alphabetMap2((x._2 + 2) % 26))).toMap\n        val encodeMap8 = alphabet.zipWithIndex.map(x\
    \ => (x._1, alphabetMap2((x._2 + 2) % 26))).toMap\n        val encodeMap9 = alphabet.zipWithIndex.map(x\
    \ => (x._1, alphabetMap2((x._2 + 2) % 26))).toMap\n        val encodeMap10 = alphabet.zipWithIndex.map(x\
    \ => (x._1, alphabetMap2((x._2 + 2) % 26))).toMap\n        val encodeMap11 = alphabet.zipWithIndex.map(x\
    \ => (x._1, alphabetMap2((x._2 + 2) % 26))).toMap\n        val encodeMap12 = alphabet.zipWithIndex.map(x\
    \ =>", "        val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val alphabetMap2 = alphabet.zipWithIndex.map(x\
    \ => (x._2, x._1)).toMap\n        val vowelsMap2 = vowels.zipWithIndex.map(x =>\
    \ (x._2, x._1)).toMap\n        val result = new StringBuilder\n        for (c\
    \ <- message) {\n            val index = alphabetMap(c.toLower)\n            if\
    \ (vowels.contains(c.toLower)) {\n                val newIndex = (index + 2) %\
    \ 26\n                result.append(vowelsMap2(newIndex).toUpper)\n          \
    \  } else {\n                val newIndex = (index + 2) % 26\n               \
    \ result.append(alphabetMap2(newIndex).toUpper)\n            }\n        }\n  \
    \      result.toString", "        val vowels = \"aeiou\"\n        val alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabet_map = alphabet.zipWithIndex.toMap\n\
    \        val vowels_map = vowels.zipWithIndex.toMap\n        val alphabet_map_inverse\
    \ = alphabet_map.map(_.swap)\n        val vowels_map_inverse = vowels_map.map(_.swap)\n\
    \        val encoded_message = message.map(x => {\n            if (vowels.contains(x.toLower))\
    \ {\n                val index = vowels_map(x.toLower)\n                val new_index\
    \ = (index + 2) % 5\n                vowels_map_inverse(new_index)\n         \
    \   } else {\n                val index = alphabet_map(x.toLower)\n          \
    \      val new_index = (index + 2) % 26\n                alphabet_map_inverse(new_index)\n\
    \            }\n        })\n        encoded_message.mkString", "        val vowels\
    \ = \"aeiouAEIOU\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val alphabetList = alphabet.toList\n  \
    \      val vowelsList = vowels.toList\n        val messageList = message.toList\n\
    \        val result = messageList.map(x => {\n            if (vowels.contains(x))\
    \ {\n                val index = vowelsMap(x)\n                val newIndex =\
    \ (index + 2) % vowelsList.length\n                vowelsList(newIndex)\n    \
    \        } else if (alphabet.contains(x)) {\n                val index = alphabetMap(x)\n\
    \                val newIndex = (index + 2) % alphabetList.length\n          \
    \      alphabetList(newIndex)\n            } else {\n                x\n     \
    \       }\n        })\n        result.mkString", "        val vowels = Set('a',\
    \ 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n        val\
    \ alphabetMap = alphabet.zipWithIndex.toMap\n        val alphabetMap2 = alphabet.zipWithIndex.map(x\
    \ => (x._2, x._1)).toMap\n        val alphabetMap3 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap4 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap5 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap6 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap7 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap8 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap9 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap10 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap11 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap12 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap13 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap14 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap15 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap16 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap17 = alphabet.zipWithIndex.map",
  "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a'\
    \ to 'z').toList\n        def encodeChar(c : Char) : Char = {\n            if\
    \ (vowels.contains(c)) {\n                val index = alphabet.indexOf(c)\n  \
    \              alphabet((index + 2) % alphabet.length)\n            } else {\n\
    \                c\n            }\n        }\n        message.map(c => if (c.isUpper)\
    \ c.toLower else c.toUpper).map(encodeChar).mkString", "        var encoded =\
    \ \"\"\n        for (c <- message) {\n            if (c.isUpper) encoded += c.toLower\n\
    \            else if (c.isLower) encoded += c.toUpper\n            else encoded\
    \ += c\n        }\n        encoded.map(c => {\n            if (\"aeiou\".contains(c))\
    \ {\n                val index = \"abcdefghijklmnopqrstuvwxyz\".indexOf(c)\n \
    \               \"cdfghjklmnpqrstvwxyzab\".charAt(index)\n            }\n    \
    \        else c\n        })", "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n\
    \        val alphabet = ('a' to 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val encodedAlphabet = alphabet.map(x => if (vowels.contains(x)) alphabet((alphabetMap(x)\
    \ + 2) % alphabet.length) else x)\n        val encodedAlphabetMap = alphabet.zip(encodedAlphabet).toMap\n\
    \        message.map(x => if (x.isUpper) encodedAlphabetMap(x.toLower).toUpper\
    \ else encodedAlphabetMap(x))", "        val vowels = Set('a', 'e', 'i', 'o',\
    \ 'u')\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        var encoded\
    \ = \"\"\n        for (c <- message) {\n            if (vowels.contains(c.toLower))\
    \ {\n                val index = alphabet.indexOf(c.toLower)\n               \
    \ encoded += alphabet((index + 2) % alphabet.length)\n            } else {\n \
    \               encoded += c\n            }\n        }\n        encoded", "  \
    \      val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a'\
    \ to 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n    \
    \    val alphabetMap2 = alphabet.zipWithIndex.map(x => (x._2, x._1)).toMap\n \
    \       def encodeChar(c : Char) : Char = {\n            if (vowels.contains(c))\
    \ {\n                val index = alphabetMap(c)\n                alphabetMap2((index\
    \ + 2) % alphabet.length)\n            } else {\n                if (c.isUpper)\
    \ c.toLower else c.toUpper\n            }\n        }\n        message.map(encodeChar)",
  "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a'\
    \ to 'z').toList\n        def encodeChar(c : Char) : Char = {\n            if\
    \ (vowels.contains(c)) {\n                val index = alphabet.indexOf(c)\n  \
    \              alphabet((index + 2) % alphabet.length)\n            } else {\n\
    \                c\n            }\n        }\n        message.map(c => if (c.isUpper)\
    \ c.toLower else c.toUpper).map(encodeChar).mkString", "        val vowels = \"\
    aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabetMap\
    \ = alphabet.zipWithIndex.toMap\n        val vowelsMap = vowels.zipWithIndex.toMap\n\
    \        val encoded = message.map(c => {\n            if (c.isUpper) c.toLower\
    \ else c\n        }).map(c => {\n            if (vowels.contains(c)) {\n     \
    \           val index = vowelsMap(c)\n                val nextIndex = (index +\
    \ 2) % vowels.length\n                vowels(nextIndex)\n            } else {\n\
    \                c\n            }\n        }).map(c => {\n            if (alphabet.contains(c))\
    \ {\n                val index = alphabetMap(c)\n                val nextIndex\
    \ = (index + 2) % alphabet.length\n                alphabet(nextIndex)\n     \
    \       } else {\n                c\n            }\n        }).map(c => {\n  \
    \          if (c.isLower) c.toUpper else c\n        })\n        encoded.mkString",
  "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a'\
    \ to 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n    \
    \    val alphabetMap2 = alphabet.zipWithIndex.map(x => (x._2, x._1)).toMap\n \
    \       def encodeChar(c : Char) : Char = {\n            if (vowels.contains(c))\
    \ {\n                val index = alphabetMap(c)\n                alphabetMap2((index\
    \ + 2) % alphabet.length)\n            } else if (c.isUpper) {\n             \
    \   c.toLower\n            } else {\n                c.toUpper\n            }\n\
    \        }\n        message.map(encodeChar).mkString", "        val vowels = \"\
    aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabet2\
    \ = alphabet + alphabet\n        val alphabet3 = alphabet2 + alphabet\n      \
    \  val alphabet4 = alphabet3 + alphabet\n        val alphabet5 = alphabet4 + alphabet\n\
    \        val alphabet6 = alphabet5 + alphabet\n        val alphabet7 = alphabet6\
    \ + alphabet\n        val alphabet8 = alphabet7 + alphabet\n        val alphabet9\
    \ = alphabet8 + alphabet\n        val alphabet10 = alphabet9 + alphabet\n    \
    \    val alphabet11 = alphabet10 + alphabet\n        val alphabet12 = alphabet11\
    \ + alphabet\n        val alphabet13 = alphabet12 + alphabet\n        val alphabet14\
    \ = alphabet13 + alphabet\n        val alphabet15 = alphabet14 + alphabet\n  \
    \      val alphabet16 = alphabet15 + alphabet\n        val alphabet17 = alphabet16\
    \ + alphabet\n        val alphabet18 = alphabet17 + alphabet\n        val alphabet19\
    \ = alphabet18 + alphabet\n        val alphabet20 = alphabet19 + alphabet\n  \
    \      val alphabet21 = alphabet20 + alphabet\n        val alphabet22 = alphabet21\
    \ + alphabet\n        val alphabet23 = alphabet22 + alphabet\n        val alphabet24\
    \ = alphabet23 + alphabet\n        val alphabet25 = alphabet24 + alphabet\n  \
    \      val alphabet26 = alphabet25 + alphabet\n        val alphabet27 = alphabet26\
    \ + alphabet\n        val alphabet28 = alphabet27 + alphabet\n        val alphabet29\
    \ = alphabet28 + alphabet\n        val alphabet30 = alphabet29 + alphabet\n  \
    \      val alphabet31 = alphabet30 + alphabet\n        val alphabet32 = alphabet31\
    \ + alphabet\n        val alphabet33 = alphabet32 + alphabet\n        val alphabet34\
    \ = alphabet33 + alphabet\n        val alphabet35 = alphabet34 + alphabet\n  \
    \      val alphabet36 = alphabet35 + alphabet\n        val alphabet37 = alphabet36\
    \ + alphabet\n        val alphabet38 = alphabet37 + alphabet\n        val alphabet39\
    \ = alphabet38 + alphabet\n        val alphabet40 = alphabet39 + alphabet\n  \
    \      val alphabet41 = alphabet40 + alphabet\n        val alphabet42 = alphabet41\
    \ + alphabet\n        val alphabet43 = alphabet42 + alphabet\n        val alphabet44\
    \ = alphabet43 + alphabet\n        val alphabet45 = alphabet44 + alphabet\n  \
    \      val alphabet46 = alphabet45 + alphabet\n        val alphabet47 = alphabet46\
    \ + alphabet\n        val alphabet48 = alphabet47 + alphabet\n        val alphabet49\
    \ = alphabet48 + alphabet\n", "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n\
    \        val alphabet = ('a' to 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val encoded = message.map(c => {\n            if (vowels.contains(c.toLower))\
    \ {\n                val index = alphabetMap(c.toLower)\n                val nextIndex\
    \ = (index + 2) % alphabet.length\n                alphabet(nextIndex)\n     \
    \       } else {\n                c\n            }\n        })\n        encoded.mkString",
  "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a'\
    \ to 'z').toArray\n        message.map(c => if (vowels.contains(c.toLower)) alphabet((alphabet.indexOf(c.toLower)\
    \ + 2) % alphabet.length) else c).map(c => if (c.isUpper) c.toLower else c.toUpper)",
  "        val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val encoded = for (c <- message) yield\
    \ {\n            if (vowels.contains(c.toLower)) {\n                val index\
    \ = vowelsMap(c.toLower)\n                val newIndex = (index + 2) % vowels.length\n\
    \                vowels(newIndex).toUpper\n            } else {\n            \
    \    val index = alphabetMap(c.toLower)\n                val newIndex = (index\
    \ + 2) % alphabet.length\n                alphabet(newIndex).toUpper\n       \
    \     }\n        }\n        encoded.mkString", "        var encoded = \"\"\n \
    \       for (c <- message) {\n            if (c.isUpper) encoded += c.toLower\n\
    \            else if (c.isLower) encoded += c.toUpper\n            else encoded\
    \ += c\n        }\n        encoded", "        val vowels = Set('a', 'e', 'i',\
    \ 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n        val alphabetMap\
    \ = alphabet.zipWithIndex.toMap\n        val alphabetMap2 = alphabet.zipWithIndex.map(x\
    \ => (x._2, x._1)).toMap\n        val messageList = message.toList\n        val\
    \ encodedList = messageList.map(x => if (vowels.contains(x.toLower)) alphabetMap2((alphabetMap(x.toLower)\
    \ + 2) % 26) else x)\n        val encodedList2 = encodedList.map(x => if (x.isUpper)\
    \ x.toLower else x.toUpper)\n        encodedList2.mkString", "        val vowels\
    \ = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = 'a' to 'z'\n        val\
    \ map = alphabet.zip(alphabet.drop(2) ++ alphabet.take(2)).toMap\n        message.map(c\
    \ => if (vowels.contains(c.toLower)) map(c.toLower) else c).map(c => if (c.isUpper)\
    \ c.toLower else c.toUpper).mkString", "        val vowels = \"aeiou\"\n     \
    \   val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val vowelsMap = vowels.zipWithIndex.toMap\n        val result = new StringBuilder\n\
    \        for (c <- message) {\n            if (c.isUpper) {\n                if\
    \ (vowels.contains(c.toLower)) {\n                    val index = vowelsMap(c.toLower)\n\
    \                    val newIndex = (index + 2) % vowels.length\n            \
    \        result += vowels(newIndex).toUpper\n                } else {\n      \
    \              result += c.toLower\n                }\n            } else {\n\
    \                if (vowels.contains(c)) {\n                    val index = vowelsMap(c)\n\
    \                    val newIndex = (index + 2) % vowels.length\n            \
    \        result += vowels(newIndex)\n                } else {\n              \
    \      result += c.toUpper\n                }\n            }\n        }\n    \
    \    result.toString", "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n  \
    \      def encodeChar(c : Char) : Char = {\n            if (vowels.contains(c))\
    \ {\n                val index = c.toInt - 'a'.toInt\n                val newIndex\
    \ = (index + 2) % 26\n                ('a'.toInt + newIndex).toChar\n        \
    \    } else {\n                c\n            }\n        }\n        message.map(c\
    \ => if (c.isUpper) c.toLower else c.toUpper).map(encodeChar).mkString", "   \
    \     val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val encoded = message.map(c => {\n    \
    \        if (vowels.contains(c.toLower)) {\n                val index = vowelsMap(c.toLower)\n\
    \                val newIndex = (index + 2) % vowels.length\n                vowels(newIndex).toUpper\n\
    \            } else {\n                if (c.isUpper) alphabet(alphabetMap(c.toLower)).toUpper\
    \ else alphabet(alphabetMap(c))\n            }\n        })\n        encoded",
  "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a'\
    \ to 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n    \
    \    val alphabetMap2 = alphabet.zipWithIndex.map(x => (x._2 + 2) % 26 -> x._1).toMap\n\
    \        message.map(x => if (vowels.contains(x.toLower)) alphabetMap2(alphabetMap(x.toLower))\
    \ else x).map(x => if (x.isUpper) x.toLower else x.toUpper).mkString", "     \
    \   val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        var result = \"\"\n        for (c <- message) {\n            if (vowels.contains(c.toLower))\
    \ {\n                val index = alphabet.indexOf(c.toLower)\n               \
    \ result += alphabet((index + 2) % alphabet.length)\n            } else {\n  \
    \              result += c\n            }\n        }\n        result", "     \
    \   val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val vowelsMap2 = vowels.zipWithIndex.map(x\
    \ => (x._1, (x._2 + 2) % 5)).toMap\n        val vowelsMap3 = vowels.zipWithIndex.map(x\
    \ => (x._1, (x._2 + 4) % 5)).toMap\n        val vowelsMap4 = vowels.zipWithIndex.map(x\
    \ => (x._1, (x._2 + 6) % 5)).toMap\n        val vowelsMap5 = vowels.zipWithIndex.map(x\
    \ => (x._1, (x._2 + 8) % 5)).toMap\n        val vowelsMap6 = vowels.zipWithIndex.map(x\
    \ => (x._1, (x._2 + 10) % 5)).toMap\n        val vowelsMap7 = vowels.zipWithIndex.map(x\
    \ => (x._1, (x._2 + 12) % 5)).toMap\n        val vowelsMap8 = vowels.zipWithIndex.map(x\
    \ => (x._1, (x._2 + 14) % 5)).toMap\n        val vowelsMap9 = vowels.zipWithIndex.map(x\
    \ => (x._1, (x._2 + 16) % 5)).toMap\n        val vowelsMap10 = vowels.zipWithIndex.map(x\
    \ => (x._1, (x._2 + 18) % 5)).toMap\n        val vowelsMap11 = vowels.zipWithIndex.map(x\
    \ => (x._1, (x._2 + 20) % 5)).toMap\n        val vowelsMap12 = vowels.zipWithIndex.map(x\
    \ => (x._1, (x._2 + 22) % 5)).toMap\n        val vowelsMap13 = vowels.zipWithIndex.map(x\
    \ => (x._1, (x._2 + 24) % 5)).toMap\n        val vowelsMap14 = vowels.zipWithIndex.map(x",
  "        val vowels = \"aeiouAEIOU\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n        val map = alphabet.zipWithIndex.toMap\n        val newMessage = message.map(c\
    \ => {\n            if (vowels.contains(c)) {\n                val index = map(c)\n\
    \                val newIndex = (index + 2) % alphabet.length\n              \
    \  alphabet(newIndex)\n            } else if (c.isUpper) {\n                c.toLower\n\
    \            } else {\n                c.toUpper\n            }\n        })\n\
    \        newMessage", "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n   \
    \     val alphabet = ('a' to 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val alphabetMapInverse = alphabetMap.map(_.swap)\n        val alphabetMapInverse2\
    \ = alphabetMapInverse.map(x => (x._1 + 2) % 26 -> x._2)\n        val alphabetMap2\
    \ = alphabetMapInverse2.map(_.swap)\n        def encodeChar(c : Char) : Char =\
    \ {\n            if (c.isUpper) c.toLower else c.toUpper\n        }\n        def\
    \ encodeVowel(c : Char) : Char = {\n            if (vowels.contains(c)) alphabetMap2(alphabetMap(c))\
    \ else c\n        }\n        message.map(encodeChar).map(encodeVowel).map(_.toUpper).mkString",
  "        val vowels = List('a', 'e', 'i', 'o', 'u')\n        val alphabet = List('a',\
    \ 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q',\
    \ 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z')\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val alphabetMap2 = alphabet.zipWithIndex.map(x => (x._2, x._1)).toMap\n\
    \        def encodeChar(c : Char) : Char = {\n            if (vowels.contains(c))\
    \ {\n                val index = alphabetMap(c)\n                alphabetMap2((index\
    \ + 2) % alphabet.length)\n            } else {\n                if (c.isUpper)\
    \ c.toLower else c.toUpper\n            }\n        }\n        message.map(encodeChar)",
  "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a'\
    \ to 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n    \
    \    val encoded = message.map(c => {\n            if (vowels.contains(c.toLower))\
    \ {\n                val index = alphabetMap(c.toLower)\n                val newIndex\
    \ = if (index + 2 > alphabet.length - 1) (index + 2) % alphabet.length else index\
    \ + 2\n                alphabet(newIndex).toString\n            } else {\n   \
    \             c.toString\n            }\n        })\n        encoded.mkString",
  "        var result = \"\"\n        for (c <- message) {\n            if (c.isUpper)\
    \ {\n                result += c.toLower\n            } else if (c.isLower) {\n\
    \                result += c.toUpper\n            } else {\n                result\
    \ += c\n            }\n        }\n        result", "        val vowels = Set('a',\
    \ 'e', 'i', 'o', 'u')\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n\
    \        val alphabet2 = alphabet.tail + alphabet.head\n        val alphabet3\
    \ = alphabet2.tail + alphabet2.head\n        val alphabet4 = alphabet3.tail +\
    \ alphabet3.head\n        val alphabet5 = alphabet4.tail + alphabet4.head\n  \
    \      val alphabet6 = alphabet5.tail + alphabet5.head\n        val alphabet7\
    \ = alphabet6.tail + alphabet6.head\n        val alphabet8 = alphabet7.tail +\
    \ alphabet7.head\n        val alphabet9 = alphabet8.tail + alphabet8.head\n  \
    \      val alphabet10 = alphabet9.tail + alphabet9.head\n        val alphabet11\
    \ = alphabet10.tail + alphabet10.head\n        val alphabet12 = alphabet11.tail\
    \ + alphabet11.head\n        val alphabet13 = alphabet12.tail + alphabet12.head\n\
    \        val alphabet14 = alphabet13.tail + alphabet13.head\n        val alphabet15\
    \ = alphabet14.tail + alphabet14.head\n        val alphabet16 = alphabet15.tail\
    \ + alphabet15.head\n        val alphabet17 = alphabet16.tail + alphabet16.head\n\
    \        val alphabet18 = alphabet17.tail + alphabet17.head\n        val alphabet19\
    \ = alphabet18.tail + alphabet18.head\n        val alphabet20 = alphabet19.tail\
    \ + alphabet19.head\n        val alphabet21 = alphabet20.tail + alphabet20.head\n\
    \        val alphabet22 = alphabet21.tail + alphabet21.head\n        val alphabet23\
    \ = alphabet22.tail + alphabet22.head\n        val alphabet24 = alphabet23.tail\
    \ + alphabet23.head\n        val alphabet25 = alphabet24.tail + alphabet24.head\n\
    \        val alphabet26 = alphabet25.tail + alphabet25.head\n        val alphabet27\
    \ = alphabet26.tail + alphabet26.head\n        val alphabet28 = alphabet27.tail\
    \ + alphabet27.head\n        val alphabet29 = alphabet28.tail + alphabet28.head\n\
    \        val alphabet30 = alphabet29.tail + alphabet29.head\n        val alphabet31\
    \ = alphabet30.tail + alphabet30.head\n        val alphabet32 = alphabet31.tail\
    \ + alphabet31.head\n        val alphabet33 =", "        val vowels = Set('a',\
    \ 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n        val\
    \ encoded = message.map(c => if (vowels.contains(c.toLower)) alphabet((alphabet.indexOf(c.toLower)\
    \ + 2) % alphabet.length) else c)\n        encoded.map(c => if (c.isUpper) c.toLower\
    \ else c.toUpper).mkString", "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n\
    \        val alphabet = ('a' to 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val encoded = message.map(c => {\n            if (vowels.contains(c.toLower))\
    \ {\n                val index = alphabetMap(c.toLower)\n                val newIndex\
    \ = (index + 2) % alphabet.length\n                alphabet(newIndex)\n      \
    \      } else {\n                c\n            }\n        })\n        encoded.map(c\
    \ => if (c.isUpper) c.toLower else c.toUpper).mkString", "        val vowels =\
    \ List('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n\
    \        val alphabetMap = alphabet.zipWithIndex.toMap\n        val newAlphabet\
    \ = alphabet.map(x => {\n            if (vowels.contains(x)) {\n             \
    \   val index = alphabetMap(x)\n                val newIndex = if (index + 2 >\
    \ alphabet.length - 1) (index + 2) % alphabet.length else index + 2\n        \
    \        alphabet(newIndex)\n            } else x\n        })\n        val newAlphabetMap\
    \ = newAlphabet.zipWithIndex.toMap\n        val newMessage = message.map(x =>\
    \ {\n            val index = alphabetMap(x.toLower)\n            val newIndex\
    \ = newAlphabetMap(x.toLower)\n            if (x.isUpper) newAlphabet(newIndex).toUpper\
    \ else newAlphabet(newIndex)\n        })\n        newMessage", "        val vowels\
    \ = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n       \
    \ val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap = vowels.zipWithIndex.toMap\n\
    \        val encoded = message.map(c => {\n            val upper = c.isUpper\n\
    \            val c2 = c.toLower\n            if (vowels.contains(c2)) {\n    \
    \            val index = vowelsMap(c2)\n                val newIndex = (index\
    \ + 2) % vowels.length\n                val newChar = vowels(newIndex)\n     \
    \           if (upper) newChar.toUpper else newChar\n            } else {\n  \
    \              val index = alphabetMap(c2)\n                val newIndex = (index\
    \ + 2) % alphabet.length\n                val newChar = alphabet(newIndex)\n \
    \               if (upper) newChar.toUpper else newChar\n            }\n     \
    \   })\n        encoded", "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n\
    \        val alphabet = ('a' to 'z').toList\n        val map = alphabet.zip(alphabet.drop(2)\
    \ ::: alphabet.take(2)).toMap\n        message.map(c => if (vowels.contains(c.toLower))\
    \ map(c.toLower) else c).map(c => if (c.isUpper) c.toLower else c.toUpper).mkString",
  "        val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = (alphabet zip alphabet.tail).toMap\n        val alphabetMap2\
    \ = (alphabet zip alphabet.tail.tail).toMap\n        val alphabetMap3 = (alphabet\
    \ zip alphabet.tail.tail.tail).toMap\n        val alphabetMap4 = (alphabet zip\
    \ alphabet.tail.tail.tail.tail).toMap\n        val alphabetMap5 = (alphabet zip\
    \ alphabet.tail.tail.tail.tail.tail).toMap\n        val alphabetMap6 = (alphabet\
    \ zip alphabet.tail.tail.tail.tail.tail.tail).toMap\n        val alphabetMap7\
    \ = (alphabet zip alphabet.tail.tail.tail.tail.tail.tail.tail).toMap\n       \
    \ val alphabetMap8 = (alphabet zip alphabet.tail.tail.tail.tail.tail.tail.tail.tail).toMap\n\
    \        val alphabetMap9 = (alphabet zip alphabet.tail.tail.tail.tail.tail.tail.tail.tail.tail).toMap\n\
    \        val alphabetMap10 = (alphabet zip alphabet.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail).toMap\n\
    \        val alphabetMap11 = (alphabet zip alphabet.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail).toMap\n\
    \        val alphabetMap12 = (alphabet zip alphabet.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail).toMap\n\
    \        val alphabetMap13 = (alphabet zip alphabet.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail).toMap\n\
    \        val alphabetMap14 = (alphabet zip alphabet.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail).toMap\n\
    \        val alphabetMap15 = (alphabet zip alphabet.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail).toMap\n\
    \        val alphabetMap16 = (alphabet zip alphabet.tail.tail", "        val vowels\
    \ = Set('a', 'e', 'i', 'o', 'u')\n        def encodeChar(c : Char) : Char = {\n\
    \            if (vowels.contains(c)) {\n                val next = c + 2\n   \
    \             if (next > 'z') {\n                    ('a' + next - 'z' - 1).toChar\n\
    \                } else {\n                    next.toChar\n                }\n\
    \            } else {\n                c\n            }\n        }\n        message.map(c\
    \ => if (c.isUpper) c.toLower else c.toUpper).map(encodeChar)", "        val vowels\
    \ = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n\
    \        val alphabetMap = alphabet.zipWithIndex.toMap\n        val alphabetSize\
    \ = alphabet.size\n        message.map(c => {\n            if (vowels.contains(c.toLower))\
    \ {\n                val index = alphabetMap(c.toLower)\n                val nextIndex\
    \ = (index + 2) % alphabetSize\n                alphabet(nextIndex).toUpper\n\
    \            } else {\n                c.toUpper\n            }\n        })",
  "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = 'a' to\
    \ 'z'\n        val alphabetMap = alphabet.zipWithIndex.toMap\n        message.map(c\
    \ => {\n            if (vowels.contains(c.toLower)) {\n                val index\
    \ = alphabetMap(c.toLower)\n                val newIndex = (index + 2) % alphabet.size\n\
    \                alphabet(newIndex).toString.toUpperCase\n            } else {\n\
    \                c.toString.toUpperCase\n            }\n        }).mkString",
  "        val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val encoded = message.map(c => {\n    \
    \        if (vowels.contains(c.toLower)) {\n                val index = vowelsMap(c.toLower)\n\
    \                val newIndex = (index + 2) % vowels.length\n                vowels(newIndex).toUpper\n\
    \            } else {\n                c.toUpper\n            }\n        })\n\
    \        encoded", "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n      \
    \  val alphabet = ('a' to 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        def encodeChar(c : Char) : Char = {\n            if (vowels.contains(c))\
    \ {\n                val index = alphabetMap(c)\n                alphabet((index\
    \ + 2) % alphabet.length)\n            } else {\n                c\n         \
    \   }\n        }\n        message.map(c => if (c.isUpper) c.toLower else c.toUpper).map(encodeChar).mkString",
  "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a'\
    \ to 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n    \
    \    val encodedAlphabet = alphabet.map(c => {\n            val index = alphabetMap(c)\n\
    \            val nextIndex = (index + 2) % alphabet.length\n            alphabet(nextIndex)\n\
    \        })\n        val encodedAlphabetMap = alphabet.zip(encodedAlphabet).toMap\n\
    \        message.map(c => {\n            if (vowels.contains(c.toLower)) {\n \
    \               encodedAlphabetMap(c.toLower)\n            } else {\n        \
    \        c\n            }\n        })", "        val vowels = Set('a', 'e', 'i',\
    \ 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n        val alphabetMap\
    \ = alphabet.zipWithIndex.toMap\n        val alphabetMap2 = alphabet.zipWithIndex.map(x\
    \ => (x._2, x._1)).toMap\n        def encodeChar(c : Char) : Char = {\n      \
    \      if (vowels.contains(c)) {\n                alphabetMap2((alphabetMap(c)\
    \ + 2) % 26)\n            } else {\n                c\n            }\n       \
    \ }\n        message.map(x => if (x.isUpper) encodeChar(x.toLower).toUpper else\
    \ encodeChar(x)).mkString", "        val vowels = List('a', 'e', 'i', 'o', 'u')\n\
    \        val alphabet = ('a' to 'z').toList\n        val alphabet2 = alphabet.drop(2)\
    \ ++ alphabet.take(2)\n        val encodeMap = (alphabet zip alphabet2).toMap\n\
    \        val encodeMap2 = (alphabet2 zip alphabet).toMap\n        val encodeMap3\
    \ = encodeMap ++ encodeMap2\n        message.map(c => if (vowels.contains(c.toLower))\
    \ encodeMap3(c.toLower) else c)", "        val vowels = \"aeiouAEIOU\"\n     \
    \   val alphabet = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\
    \        val alphabetMap = alphabet.zipWithIndex.toMap\n        val alphabetMap2\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2) % alphabet.length -> x._1).toMap\n\
    \        message.map(x => if (vowels.contains(x)) alphabetMap2(alphabetMap(x))\
    \ else x)", "        val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val alphabetMap2 = alphabet.zipWithIndex.map(x\
    \ => (x._2, x._1)).toMap\n        val vowelsMap2 = vowels.zipWithIndex.map(x =>\
    \ (x._2, x._1)).toMap\n        val result = new StringBuilder\n        for (c\
    \ <- message) {\n            if (c.isUpper) {\n                if (vowels.contains(c.toLower))\
    \ {\n                    result.append(vowelsMap2((vowelsMap(c.toLower) + 2) %\
    \ 5).toUpper)\n                } else {\n                    result.append(alphabetMap2((alphabetMap(c.toLower)\
    \ + 2) % 26).toUpper)\n                }\n            } else {\n             \
    \   if (vowels.contains(c)) {\n                    result.append(vowelsMap2((vowelsMap(c)\
    \ + 2) % 5))\n                } else {\n                    result.append(alphabetMap2((alphabetMap(c)\
    \ + 2) % 26))\n                }\n            }\n        }\n        result.toString",
  "        val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabet2 = alphabet + alphabet\n        val alphabet3 = alphabet2\
    \ + alphabet\n        val map = Map[Char, Char]()\n        for (i <- 0 until vowels.length)\
    \ {\n            map(vowels(i)) = alphabet3(alphabet.indexOf(vowels(i)) + 2)\n\
    \        }\n        message.map(c => {\n            if (vowels.contains(c.toLower))\
    \ map(c.toLower)\n            else if (c.isUpper) alphabet2(alphabet.indexOf(c.toLower)).toUpper\n\
    \            else alphabet2(alphabet.indexOf(c))\n        })", "        val vowels\
    \ = List('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n\
    \        val alphabetMap = alphabet.zipWithIndex.toMap\n        val result = new\
    \ StringBuilder\n        for (c <- message) {\n            if (vowels.contains(c.toLower))\
    \ {\n                val index = alphabetMap(c.toLower)\n                val newIndex\
    \ = (index + 2) % alphabet.length\n                val newChar = alphabet(newIndex)\n\
    \                result.append(newChar.toUpper)\n            } else {\n      \
    \          result.append(c.toUpper)\n            }\n        }\n        result.toString",
  "        val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val message_lower = message.toLowerCase\n        val message_encoded\
    \ = new StringBuilder\n        for (i <- 0 until message_lower.length) {\n   \
    \         val c = message_lower(i)\n            if (vowels.contains(c)) {\n  \
    \              val index = alphabet.indexOf(c)\n                val index_encoded\
    \ = (index + 2) % alphabet.length\n                message_encoded.append(alphabet(index_encoded))\n\
    \            } else {\n                message_encoded.append(c)\n           \
    \ }\n        }\n        message_encoded.toString", "        val vowels = Set('a',\
    \ 'e', 'i', 'o', 'u')\n        val alphabet = 'a' to 'z'\n        val alphabetMap\
    \ = alphabet.zipWithIndex.toMap\n        val alphabetMap2 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2) % 26 -> x._1).toMap\n        message.map(x => if (vowels.contains(x.toLower))\
    \ alphabetMap2(alphabetMap(x.toLower)) else x)", "        val vowels = \"aeiou\"\
    \n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabetMap\
    \ = alphabet.zipWithIndex.toMap\n        val vowelsMap = vowels.zipWithIndex.toMap\n\
    \        val encoded = message.map(c => {\n            if (vowels.contains(c.toLower))\
    \ {\n                val index = vowelsMap(c.toLower)\n                val newIndex\
    \ = (index + 2) % vowels.length\n                val newChar = vowels(newIndex)\n\
    \                if (c.isUpper) newChar.toUpper else newChar\n            } else\
    \ {\n                val index = alphabetMap(c.toLower)\n                val newIndex\
    \ = (index + 2) % alphabet.length\n                val newChar = alphabet(newIndex)\n\
    \                if (c.isUpper) newChar.toUpper else newChar\n            }\n\
    \        })\n        encoded", "        val vowels = \"aeiou\"\n        val alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\"\n        val encoded = message.map(c => {\n\
    \            if (vowels.contains(c.toLower)) {\n                val index = alphabet.indexOf(c.toLower)\n\
    \                alphabet((index + 2) % alphabet.length)\n            } else {\n\
    \                c\n            }\n        })\n        encoded.map(c => if (c.isUpper)\
    \ c.toLower else c.toUpper).mkString", "        val vowels = Set('a', 'e', 'i',\
    \ 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n        val alphabetMap\
    \ = alphabet.zipWithIndex.toMap\n        message.map(c => {\n            if (vowels.contains(c.toLower))\
    \ {\n                val index = alphabetMap(c.toLower)\n                val newIndex\
    \ = (index + 2) % alphabet.length\n                alphabet(newIndex)\n      \
    \      } else if (c.isUpper) {\n                c.toLower\n            } else\
    \ {\n                c.toUpper\n            }\n        })", "        val vowels\
    \ = List('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n\
    \        val alphabetMap = alphabet.zipWithIndex.toMap\n        val encodedAlphabet\
    \ = alphabet.map(x => if (vowels.contains(x)) alphabet((alphabetMap(x) + 2) %\
    \ 26) else x)\n        val alphabetMapEncoded = alphabet.zip(encodedAlphabet).toMap\n\
    \        message.map(x => if (x.isUpper) alphabetMapEncoded(x.toLower).toUpper\
    \ else alphabetMapEncoded(x))", "        val vowels = Set('a', 'e', 'i', 'o',\
    \ 'u')\n        val alphabet = 'a' to 'z'\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val alphabetMap2 = alphabet.zipWithIndex.map(x => (x._2 + 2) % 26 ->\
    \ x._1).toMap\n        message.map(x => if (vowels.contains(x.toLower)) alphabetMap2(alphabetMap(x.toLower))\
    \ else x).map(x => if (x.isUpper) x.toLower else x.toUpper).mkString", "     \
    \   val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val encoded = message.map(c => {\n    \
    \        if (vowels.contains(c.toLower)) {\n                val index = vowelsMap(c.toLower)\n\
    \                val newIndex = (index + 2) % vowels.length\n                vowels(newIndex).toUpper\n\
    \            } else {\n                c.toUpper\n            }\n        })\n\
    \        encoded", "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n      \
    \  val alphabet = ('a' to 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val alphabetSize = alphabet.size\n        val encodeMap = vowels.map(v\
    \ => (v, alphabet((alphabetMap(v) + 2) % alphabetSize))).toMap\n        message.map(c\
    \ => if (vowels.contains(c.toLower)) encodeMap(c.toLower) else c)", "        val\
    \ vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n\
    \        val alphabetMap = alphabet.zipWithIndex.toMap\n        val alphabetMap2\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2) % 26 -> x._1).toMap\n        message.map(x\
    \ => if (vowels.contains(x.toLower)) alphabetMap2(alphabetMap(x.toLower)) else\
    \ x).map(x => if (x.isUpper) x.toLower else x.toUpper).mkString", "        val\
    \ vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n\
    \        val map = alphabet.zipWithIndex.toMap\n        val encodeMap = vowels.zipWithIndex.map(x\
    \ => (x._1, vowels((x._2 + 2) % vowels.length))).toMap\n        message.map(x\
    \ => if (vowels.contains(x.toLower)) encodeMap(x.toLower) else if (x.isUpper)\
    \ alphabet((map(x.toLower) + alphabet.length / 2) % alphabet.length).toUpper else\
    \ alphabet((map(x) + alphabet.length / 2) % alphabet.length)).mkString", "   \
    \     val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to\
    \ 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n       \
    \ val alphabetMap2 = alphabet.zipWithIndex.map(x => (x._2, x._1)).toMap\n    \
    \    val messageList = message.toList\n        val encodedList = messageList.map(x\
    \ => {\n            if (vowels.contains(x)) {\n                val index = alphabetMap(x)\n\
    \                alphabetMap2((index + 2) % 26)\n            } else {\n      \
    \          x\n            }\n        })\n        encodedList.mkString", "    \
    \    val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val encoded = message.map(c => {\n    \
    \        if (vowels.contains(c.toLower)) {\n                val index = vowelsMap(c.toLower)\n\
    \                val newIndex = (index + 2) % vowels.length\n                vowels(newIndex).toUpper\n\
    \            } else {\n                if (c.isUpper) alphabet(alphabetMap(c.toLower)).toUpper\n\
    \                else alphabet(alphabetMap(c.toLower))\n            }\n      \
    \  })\n        encoded", "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n\
    \        val alphabet = ('a' to 'z').toList\n        val alphabet2 = alphabet.map(x\
    \ => if (x == 'z') 'a' else alphabet(alphabet.indexOf(x) + 1))\n        val alphabet3\
    \ = alphabet2.map(x => if (x == 'z') 'a' else alphabet2(alphabet2.indexOf(x) +\
    \ 1))\n        val alphabetMap = alphabet.zip(alphabet2).toMap\n        val alphabetMap2\
    \ = alphabet.zip(alphabet3).toMap\n        message.map(x => if (vowels.contains(x))\
    \ alphabetMap2(x) else alphabetMap(x)).map(x => if (x.isUpper) x.toLower else\
    \ x.toUpper).mkString", "        val vowels = \"aeiou\"\n        val alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val vowelsMap = vowels.zipWithIndex.toMap\n        val encoded = message.map(c\
    \ => {\n            if (vowels.contains(c.toLower)) {\n                val index\
    \ = vowelsMap(c.toLower)\n                val newIndex = (index + 2) % vowels.length\n\
    \                vowels(newIndex).toUpper\n            } else if (alphabet.contains(c.toLower))\
    \ {\n                val index = alphabetMap(c.toLower)\n                val newIndex\
    \ = (index + 2) % alphabet.length\n                alphabet(newIndex).toUpper\n\
    \            } else {\n                c\n            }\n        })\n        encoded",
  "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a'\
    \ to 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n    \
    \    val encodedAlphabet = alphabet.map(x => if (vowels.contains(x)) alphabet((alphabetMap(x)\
    \ + 2) % alphabet.length) else x)\n        val alphabetMapEncoded = encodedAlphabet.zipWithIndex.toMap\n\
    \        message.map(x => if (alphabet.contains(x.toLower)) encodedAlphabet(x.toLower)\
    \ else x)", "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet\
    \ = ('a' to 'z').toList\n        def encodeChar(c : Char) : Char = {\n       \
    \     if (vowels.contains(c)) {\n                val index = alphabet.indexOf(c)\n\
    \                alphabet((index + 2) % alphabet.length)\n            } else {\n\
    \                c\n            }\n        }\n        message.map(c => if (c.isUpper)\
    \ c.toLower else c.toUpper).map(encodeChar).mkString", "        val vowels = Set('a',\
    \ 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n        def\
    \ encodeChar(c : Char) : Char = {\n            if (vowels.contains(c)) {\n   \
    \             val index = alphabet.indexOf(c)\n                alphabet((index\
    \ + 2) % alphabet.length)\n            } else {\n                c\n         \
    \   }\n        }\n        message.map(c => if (c.isUpper) c.toLower else c.toUpper).map(encodeChar)",
  "        val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val map = Map(\n            'a' -> 'c',\n            'e' -> 'g',\n \
    \           'i' -> 'k',\n            'o' -> 'q',\n            'u' -> 'y'\n   \
    \     )\n        message.map(c => if (vowels.contains(c)) map(c) else c).map(c\
    \ => if (c.isUpper) c.toLower else c.toUpper).mkString", "        val vowels =\
    \ \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        var\
    \ result = \"\"\n        for (c <- message) {\n            if (vowels.contains(c.toLower))\
    \ {\n                val index = alphabet.indexOf(c.toLower)\n               \
    \ val newIndex = (index + 2) % 26\n                result += alphabet(newIndex).toUpper\n\
    \            } else {\n                result += c.toUpper\n            }\n  \
    \      }\n        result", "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n\
    \        val alphabet = ('a' to 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val alphabetMap2 = alphabet.zipWithIndex.map(x => (x._2, x._1)).toMap\n\
    \        val alphabetMap3 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap4 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap5 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap6 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap7 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap8 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap9 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap10 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap11 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap12 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap13 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap14 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap15 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap16 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap17 = alphabet.zipWithIndex.map", "        val vowels =\
    \ \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val\
    \ alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap = vowels.zipWithIndex.toMap\n\
    \        val encoded = message.map(c => {\n            if (vowels.contains(c.toLower))\
    \ {\n                val index = vowelsMap(c.toLower)\n                val nextIndex\
    \ = (index + 2) % vowels.length\n                vowels(nextIndex).toUpper\n \
    \           } else {\n                c.toUpper\n            }\n        })\n \
    \       encoded", "        val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        var encoded = \"\"\n        for (c <- message) {\n            if (vowels.contains(c.toLower))\
    \ {\n                val index = alphabet.indexOf(c.toLower)\n               \
    \ val newIndex = (index + 2) % alphabet.length\n                encoded += alphabet(newIndex).toUpper\n\
    \            } else {\n                encoded += c.toUpper\n            }\n \
    \       }\n        encoded", "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n\
    \        val alphabet = ('a' to 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val alphabetMap2 = alphabet.zipWithIndex.map(x => (x._2, x._1)).toMap\n\
    \        def encodeChar(c : Char) : Char = {\n            if (vowels.contains(c))\
    \ {\n                val index = alphabetMap(c)\n                alphabetMap2((index\
    \ + 2) % alphabet.length)\n            } else {\n                if (c.isUpper)\
    \ c.toLower else c.toUpper\n            }\n        }\n        message.map(encodeChar).mkString",
  "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        def encodeChar(c : Char)\
    \ : Char = {\n            if (vowels.contains(c)) {\n                val index\
    \ = c - 'a'\n                val newIndex = (index + 2) % 26\n               \
    \ ('a' + newIndex).toChar\n            } else {\n                c\n         \
    \   }\n        }\n        message.map(c => if (c.isUpper) c.toLower else c.toUpper).map(encodeChar)",
  "        val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val alphabetArray = alphabet.toArray\n\
    \        val vowelsArray = vowels.toArray\n        val messageArray = message.toArray\n\
    \        for (i <- 0 until messageArray.length) {\n            if (vowelsMap.contains(messageArray(i)))\
    \ {\n                messageArray(i) = vowelsArray((vowelsMap(messageArray(i))\
    \ + 2) % vowelsArray.length)\n            } else if (alphabetMap.contains(messageArray(i)))\
    \ {\n                messageArray(i) = alphabetArray((alphabetMap(messageArray(i))\
    \ + 2) % alphabetArray.length)\n            }\n        }\n        messageArray.mkString",
  "        val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val alphabetArray = alphabet.toArray\n\
    \        val vowelsArray = vowels.toArray\n        val messageArray = message.toArray\n\
    \        for (i <- 0 until messageArray.length) {\n            if (vowelsMap.contains(messageArray(i)))\
    \ {\n                val index = vowelsMap(messageArray(i))\n                messageArray(i)\
    \ = vowelsArray((index + 2) % vowelsArray.length)\n            } else if (alphabetMap.contains(messageArray(i)))\
    \ {\n                val index = alphabetMap(messageArray(i))\n              \
    \  messageArray(i) = alphabetArray((index + 2) % alphabetArray.length)\n     \
    \       }\n        }\n        messageArray.mkString", "        var result = \"\
    \"\n        for (c <- message) {\n            if (c.isUpper) {\n             \
    \   result += c.toLower\n            } else if (c.isLower) {\n               \
    \ result += c.toUpper\n            } else {\n                result += c\n   \
    \         }\n        }\n        result", "        val vowels = List('a', 'e',\
    \ 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n        val alphabetMap\
    \ = alphabet.zipWithIndex.toMap\n        val encoded = message.map(c => {\n  \
    \          if (vowels.contains(c.toLower)) {\n                val index = alphabetMap(c.toLower)\n\
    \                val newIndex = if (index + 2 >= alphabet.length) index + 2 -\
    \ alphabet.length else index + 2\n                alphabet(newIndex)\n       \
    \     } else if (c.isUpper) c.toLower else c.toUpper\n        })\n        encoded.mkString",
  "        val vowels = \"AEIOU\"\n        val alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val encoded = message.map(c => {\n    \
    \        if (vowels.contains(c.toUpper)) {\n                val index = (vowelsMap(c.toUpper)\
    \ + 2) % vowels.length\n                vowels(index)\n            } else if (alphabet.contains(c.toUpper))\
    \ {\n                val index = (alphabetMap(c.toUpper) + 2) % alphabet.length\n\
    \                alphabet(index)\n            } else {\n                c\n  \
    \          }\n        })\n        encoded.map(c => if (c.isUpper) c.toLower else\
    \ c.toUpper).mkString", "        val vowels = Array('a', 'e', 'i', 'o', 'u')\n\
    \        var encoded = \"\"\n        for (c <- message) {\n            if (vowels.contains(c.toLower))\
    \ {\n                encoded += (c.toLower + 2).toChar\n            } else {\n\
    \                encoded += c.toUpper\n            }\n        }\n        encoded",
  "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a'\
    \ to 'z').toList\n        val encodeMap = Map('a' -> 'c', 'e' -> 'g', 'i' -> 'k',\
    \ 'o' -> 'q', 'u' -> 'y')\n        message.map(c => if (vowels.contains(c.toLower))\
    \ encodeMap(c.toLower) else c).map(c => if (c.isUpper) c.toLower else c.toUpper)",
  "        val vowels = List('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a'\
    \ to 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n    \
    \    val alphabetMap2 = alphabet.zipWithIndex.map(x => (x._2, x._1)).toMap\n \
    \       val messageList = message.toList\n        val encodedList = messageList.map(x\
    \ => {\n            if (vowels.contains(x)) {\n                val index = alphabetMap(x)\n\
    \                alphabetMap2((index + 2) % 26)\n            } else if (x.isUpper)\
    \ {\n                x.toLower\n            } else {\n                x.toUpper\n\
    \            }\n        })\n        encodedList.mkString", "        val vowels\
    \ = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n       \
    \ var result = \"\"\n        for (c <- message) {\n            if (vowels.contains(c.toLower))\
    \ {\n                val index = alphabet.indexOf(c.toLower)\n               \
    \ result += alphabet((index + 2) % 26)\n            } else {\n               \
    \ result += c\n            }\n        }\n        result", "        val vowels\
    \ = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n\
    \        def encodeChar(c : Char) : Char = {\n            if (vowels.contains(c))\
    \ {\n                val index = alphabet.indexOf(c)\n                alphabet((index\
    \ + 2) % alphabet.length)\n            } else {\n                c\n         \
    \   }\n        }\n        message.map(c => if (c.isUpper) c.toLower else c.toUpper).map(encodeChar)",
  "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a'\
    \ to 'z').toList\n        val encodeMap = alphabet.zip(alphabet.drop(2) ::: alphabet.take(2)).toMap\n\
    \        message.map(c => if (vowels.contains(c.toLower)) encodeMap(c.toLower)\
    \ else c)", "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet\
    \ = ('a' to 'z').toList\n        def encodeChar(c : Char) : Char = {\n       \
    \     if (vowels.contains(c)) {\n                val index = alphabet.indexOf(c)\n\
    \                alphabet((index + 2) % alphabet.length)\n            } else {\n\
    \                c\n            }\n        }\n        message.map(c => if (c.isUpper)\
    \ c.toLower else c.toUpper).map(encodeChar).mkString", "        val vowels = Set('a',\
    \ 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n        val\
    \ alphabetMap = alphabet.zipWithIndex.toMap\n        val alphabetMap2 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2) % 26 -> x._1).toMap\n        message.map(x => if (vowels.contains(x.toLower))\
    \ alphabetMap2(alphabetMap(x.toLower)) else x).map(x => if (x.isUpper) x.toLower\
    \ else x.toUpper).mkString", "        val vowels = \"aeiou\"\n        val alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabet2 = alphabet + alphabet\n\
    \        val map = Map[Char, Char]()\n        for (i <- 0 until vowels.length)\
    \ {\n            map(vowels(i)) = alphabet2(alphabet.indexOf(vowels(i)) + 2)\n\
    \        }\n        message.map(c => if (vowels.contains(c.toLower)) map(c.toLower)\
    \ else c)", "        val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val encoded = message.map(c => {\n    \
    \        if (vowels.contains(c.toLower)) {\n                val index = vowelsMap(c.toLower)\n\
    \                val newIndex = (index + 2) % vowels.length\n                vowels(newIndex).toUpper\n\
    \            } else {\n                c.toUpper\n            }\n        })\n\
    \        encoded", "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n      \
    \  val alphabet = ('a' to 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val alphabetMap2 = alphabet.zipWithIndex.map(x => (x._2, x._1)).toMap\n\
    \        def encodeChar(c : Char) : Char = {\n            if (vowels.contains(c))\
    \ {\n                alphabetMap2((alphabetMap(c) + 2) % 26)\n            } else\
    \ {\n                c\n            }\n        }\n        message.toLowerCase.map(encodeChar).map(x\
    \ => if (x.isUpper) x.toLower else x.toUpper).mkString", "        val vowels =\
    \ Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = 'a' to 'z'\n        val\
    \ alphabetMap = alphabet.zipWithIndex.toMap\n        val alphabetMap2 = alphabet.zipWithIndex.map(x\
    \ => (x._2, x._1)).toMap\n        val encodeMap = alphabet.zipWithIndex.map(x\
    \ => (x._1, alphabetMap2((x._2 + 2) % 26))).toMap\n        val encodeMap2 = alphabet.zipWithIndex.map(x\
    \ => (x._1, alphabetMap2((x._2 + 2) % 26))).toMap\n        val encodeMap3 = alphabet.zipWithIndex.map(x\
    \ => (x._1, alphabetMap2((x._2 + 2) % 26))).toMap\n        val encodeMap4 = alphabet.zipWithIndex.map(x\
    \ => (x._1, alphabetMap2((x._2 + 2) % 26))).toMap\n        val encodeMap5 = alphabet.zipWithIndex.map(x\
    \ => (x._1, alphabetMap2((x._2 + 2) % 26))).toMap\n        val encodeMap6 = alphabet.zipWithIndex.map(x\
    \ => (x._1, alphabetMap2((x._2 + 2) % 26))).toMap\n        val encodeMap7 = alphabet.zipWithIndex.map(x\
    \ => (x._1, alphabetMap2((x._2 + 2) % 26))).toMap\n        val encodeMap8 = alphabet.zipWithIndex.map(x\
    \ => (x._1, alphabetMap2((x._2 + 2) % 26))).toMap\n        val encodeMap9 = alphabet.zipWithIndex.map(x\
    \ => (x._1, alphabetMap2((x._2 + 2) % 26))).toMap\n        val encodeMap10 = alphabet.zipWithIndex.map(x\
    \ => (x._1, alphabetMap2((x._2 + 2) % 26))).toMap\n        val encodeMap11 = alphabet.zipWithIndex.map(x\
    \ => (x._1, alphabetMap2((x._2 + 2) % 26))).toMap\n        val encodeMap12 = alphabet.zipWithIndex.map(x\
    \ => (x", "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet\
    \ = 'a' to 'z'\n        val alphabetMap = alphabet.zipWithIndex.toMap\n      \
    \  val alphabetMap2 = alphabet.zipWithIndex.map(x => (x._2 + 2) % 26 -> x._1).toMap\n\
    \        message.map(x => if (vowels.contains(x.toLower)) alphabetMap2(alphabetMap(x.toLower))\
    \ else x)", "        val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val encoded = message.toLowerCase.map(c\
    \ => {\n            if (vowels.contains(c)) {\n                val index = vowelsMap(c)\n\
    \                val nextIndex = (index + 2) % vowels.length\n               \
    \ vowels(nextIndex)\n            } else {\n                val index = alphabetMap(c)\n\
    \                val nextIndex = (index + 2) % alphabet.length\n             \
    \   alphabet(nextIndex)\n            }\n        })\n        encoded.map(c => if\
    \ (c.isUpper) c.toLower else c.toUpper).mkString", "        val vowels = List('a',\
    \ 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n        val\
    \ alphabetMap = alphabet.zipWithIndex.toMap\n        val alphabetMap2 = alphabet.zipWithIndex.map(x\
    \ => (x._2, x._1)).toMap\n        val encoded = message.map(x => {\n         \
    \   if (vowels.contains(x.toLower)) {\n                val index = alphabetMap(x.toLower)\n\
    \                val newIndex = (index + 2) % 26\n                alphabetMap2(newIndex).toUpper\n\
    \            } else {\n                x.toUpper\n            }\n        })\n\
    \        encoded", "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n      \
    \  val alphabet = ('a' to 'z').toList\n        val encoded = message.map(c =>\
    \ {\n            if (vowels.contains(c.toLower)) {\n                val index\
    \ = alphabet.indexOf(c.toLower)\n                val next = if (index + 2 > alphabet.length\
    \ - 1) alphabet(index + 2 - alphabet.length) else alphabet(index + 2)\n      \
    \          if (c.isUpper) next.toUpper else next\n            } else {\n     \
    \           if (c.isUpper) c.toLower else c.toUpper\n            }\n        })\n\
    \        encoded.mkString", "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n\
    \        val alphabet = ('a' to 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val encodedAlphabet = alphabet.map(x => if (vowels.contains(x)) alphabet((alphabetMap(x)\
    \ + 2) % alphabet.length) else x)\n        val encodedAlphabetMap = alphabet.zip(encodedAlphabet).toMap\n\
    \        message.map(x => if (vowels.contains(x.toLower)) encodedAlphabetMap(x.toLower)\
    \ else x)", "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet\
    \ = ('a' to 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val alphabetMap2 = alphabet.zipWithIndex.map(x => (x._2, x._1)).toMap\n\
    \        val encodeMap = vowels.map(x => (x, alphabetMap2((alphabetMap(x) + 2)\
    \ % 26))).toMap\n        message.map(x => if (vowels.contains(x.toLower)) encodeMap(x.toLower)\
    \ else x).map(x => if (x.isUpper) x.toLower else x.toUpper).mkString", "     \
    \   val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val vowelsMap = Map('a' -> 'c', 'e' -> 'g', 'i' -> 'k', 'o' -> 'q',\
    \ 'u' -> 'y')\n        val alphabetMap = Map('a' -> 'A', 'b' -> 'B', 'c' -> 'C',\
    \ 'd' -> 'D', 'e' -> 'E', 'f' -> 'F', 'g' -> 'G', 'h' -> 'H', 'i' -> 'I', 'j'\
    \ -> 'J', 'k' -> 'K', 'l' -> 'L', 'm' -> 'M', 'n' -> 'N', 'o' -> 'O', 'p' -> 'P',\
    \ 'q' -> 'Q', 'r' -> 'R', 's' -> 'S', 't' -> 'T', 'u' -> 'U', 'v' -> 'V', 'w'\
    \ -> 'W', 'x' -> 'X', 'y' -> 'Y', 'z' -> 'Z')\n        val messageArray = message.toCharArray\n\
    \        for (i <- 0 until messageArray.length) {\n            if (vowels.contains(messageArray(i)))\
    \ {\n                messageArray(i) = vowelsMap(messageArray(i))\n          \
    \  } else if (alphabet.contains(messageArray(i))) {\n                messageArray(i)\
    \ = alphabetMap(messageArray(i))\n            }\n        }\n        return messageArray.mkString",
  "        val vowels = \"aeiouAEIOU\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val alphabetMap2\
    \ = alphabet.zipWithIndex.map(x => (x._2, x._1)).toMap\n        val vowelMap =\
    \ vowels.zipWithIndex.toMap\n        val vowelMap2 = vowels.zipWithIndex.map(x\
    \ => (x._2, x._1)).toMap\n        val encoded = message.map(x => if (vowels.contains(x))\
    \ alphabetMap2((alphabetMap(x) + 2) % alphabet.length) else x)\n        encoded.map(x\
    \ => if (alphabet.contains(x)) alphabetMap2((alphabetMap(x) + alphabet.length\
    \ / 2) % alphabet.length) else x)", "        val vowels = List(\"a\", \"e\", \"\
    i\", \"o\", \"u\")\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n  \
    \      val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelMap = vowels.zipWithIndex.toMap\n\
    \        val encoded = message.map(c => {\n            if (vowels.contains(c.toString.toLowerCase))\
    \ {\n                val index = vowelMap(c.toString.toLowerCase)\n          \
    \      val newIndex = (index + 2) % 5\n                vowels(newIndex)\n    \
    \        } else if (alphabet.contains(c.toString.toLowerCase)) {\n           \
    \     val index = alphabetMap(c.toString.toLowerCase)\n                val newIndex\
    \ = (index + 2) % 26\n                alphabet(newIndex)\n            } else {\n\
    \                c\n            }\n        })\n        encoded.mkString", "  \
    \      val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabet2 = alphabet + alphabet\n        val alphabet3 = alphabet2\
    \ + alphabet\n        val alphabet4 = alphabet3 + alphabet\n        val alphabet5\
    \ = alphabet4 + alphabet\n        val alphabet6 = alphabet5 + alphabet\n     \
    \   val alphabet7 = alphabet6 + alphabet\n        val alphabet8 = alphabet7 +\
    \ alphabet\n        val alphabet9 = alphabet8 + alphabet\n        val alphabet10\
    \ = alphabet9 + alphabet\n        val alphabet11 = alphabet10 + alphabet\n   \
    \     val alphabet12 = alphabet11 + alphabet\n        val alphabet13 = alphabet12\
    \ + alphabet\n        val alphabet14 = alphabet13 + alphabet\n        val alphabet15\
    \ = alphabet14 + alphabet\n        val alphabet16 = alphabet15 + alphabet\n  \
    \      val alphabet17 = alphabet16 + alphabet\n        val alphabet18 = alphabet17\
    \ + alphabet\n        val alphabet19 = alphabet18 + alphabet\n        val alphabet20\
    \ = alphabet19 + alphabet\n        val alphabet21 = alphabet20 + alphabet\n  \
    \      val alphabet22 = alphabet21 + alphabet\n        val alphabet23 = alphabet22\
    \ + alphabet\n        val alphabet24 = alphabet23 + alphabet\n        val alphabet25\
    \ = alphabet24 + alphabet\n        val alphabet26 = alphabet25 + alphabet\n  \
    \      val alphabet27 = alphabet26 + alphabet\n        val alphabet28 = alphabet27\
    \ + alphabet\n        val alphabet29 = alphabet28 + alphabet\n        val alphabet30\
    \ = alphabet29 + alphabet\n        val alphabet31 = alphabet30 + alphabet\n  \
    \      val alphabet32 = alphabet31 + alphabet\n        val alphabet33 = alphabet32\
    \ + alphabet\n        val alphabet34 = alphabet33 + alphabet\n        val alphabet35\
    \ = alphabet34 + alphabet\n        val alphabet36 = alphabet35 + alphabet\n  \
    \      val alphabet37 = alphabet36 + alphabet\n        val alphabet38 = alphabet37\
    \ + alphabet\n        val alphabet39 = alphabet38 + alphabet\n        val alphabet40\
    \ = alphabet39 + alphabet\n        val alphabet41 = alphabet40 + alphabet\n  \
    \      val alphabet42 = alphabet41 + alphabet\n        val alphabet43 = alphabet42\
    \ + alphabet\n        val alphabet44 = alphabet43 + alphabet\n        val alphabet45\
    \ = alphabet44 + alphabet\n        val alphabet46 = alphabet45 + alphabet\n  \
    \      val alphabet47 = alphabet46 + alphabet\n        val alphabet48 = alphabet47\
    \ + alphabet\n        val alphabet49 = alphabet48 + alphabet\n", "        val\
    \ vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toArray\n\
    \        val alphabet2 = ('c' to 'z').toArray ++ ('a' to 'b').toArray\n      \
    \  val map = (alphabet zip alphabet2).toMap\n        message.map(c => if (vowels.contains(c.toLower))\
    \ map(c.toLower) else c).map(c => if (c.isUpper) c.toLower else c.toUpper).mkString",
  "        val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val alphabetArray = alphabet.toArray\n\
    \        val vowelsArray = vowels.toArray\n        val messageArray = message.toArray\n\
    \        for (i <- 0 until messageArray.length) {\n            if (vowels.contains(messageArray(i)))\
    \ {\n                val index = vowelsMap(messageArray(i))\n                messageArray(i)\
    \ = vowelsArray((index + 2) % vowelsArray.length)\n            } else if (alphabet.contains(messageArray(i)))\
    \ {\n                val index = alphabetMap(messageArray(i))\n              \
    \  messageArray(i) = alphabetArray((index + 2) % alphabetArray.length)\n     \
    \       }\n        }\n        return messageArray.mkString", "        val vowels\
    \ = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n       \
    \ val alphabet2 = alphabet + alphabet\n        val alphabet3 = alphabet2 + alphabet\n\
    \        val alphabet4 = alphabet3 + alphabet\n        val alphabet5 = alphabet4\
    \ + alphabet\n        val alphabet6 = alphabet5 + alphabet\n        val alphabet7\
    \ = alphabet6 + alphabet\n        val alphabet8 = alphabet7 + alphabet\n     \
    \   val alphabet9 = alphabet8 + alphabet\n        val alphabet10 = alphabet9 +\
    \ alphabet\n        val alphabet11 = alphabet10 + alphabet\n        val alphabet12\
    \ = alphabet11 + alphabet\n        val alphabet13 = alphabet12 + alphabet\n  \
    \      val alphabet14 = alphabet13 + alphabet\n        val alphabet15 = alphabet14\
    \ + alphabet\n        val alphabet16 = alphabet15 + alphabet\n        val alphabet17\
    \ = alphabet16 + alphabet\n        val alphabet18 = alphabet17 + alphabet\n  \
    \      val alphabet19 = alphabet18 + alphabet\n        val alphabet20 = alphabet19\
    \ + alphabet\n        val alphabet21 = alphabet20 + alphabet\n        val alphabet22\
    \ = alphabet21 + alphabet\n        val alphabet23 = alphabet22 + alphabet\n  \
    \      val alphabet24 = alphabet23 + alphabet\n        val alphabet25 = alphabet24\
    \ + alphabet\n        val alphabet26 = alphabet25 + alphabet\n        val alphabet27\
    \ = alphabet26 + alphabet\n        val alphabet28 = alphabet27 + alphabet\n  \
    \      val alphabet29 = alphabet28 + alphabet\n        val alphabet30 = alphabet29\
    \ + alphabet\n        val alphabet31 = alphabet30 + alphabet\n        val alphabet32\
    \ = alphabet31 + alphabet\n        val alphabet33 = alphabet32 + alphabet\n  \
    \      val alphabet34 = alphabet33 + alphabet\n        val alphabet35 = alphabet34\
    \ + alphabet\n        val alphabet36 = alphabet35 + alphabet\n        val alphabet37\
    \ = alphabet36 + alphabet\n        val alphabet38 = alphabet37 + alphabet\n  \
    \      val alphabet39 = alphabet38 + alphabet\n        val alphabet40 = alphabet39\
    \ + alphabet\n        val alphabet41 = alphabet40 + alphabet\n        val alphabet42\
    \ = alphabet41 + alphabet\n        val alphabet43 = alphabet42 + alphabet\n  \
    \      val alphabet44 = alphabet43 + alphabet\n        val alphabet45 = alphabet44\
    \ + alphabet\n        val alphabet46 = alphabet45 + alphabet\n        val alphabet47\
    \ = alphabet46 + alphabet\n        val alphabet48 = alphabet47 + alphabet\n  \
    \      val alphabet49 = alphabet48 + alphabet\n", "        val vowels = Set('a',\
    \ 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n        val\
    \ alphabetMap = alphabet.zipWithIndex.toMap\n        val alphabetMap2 = alphabet.zipWithIndex.map(x\
    \ => (x._2, x._1)).toMap\n        val alphabetMap3 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap4 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap5 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap6 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap7 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap8 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap9 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap10 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap11 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap12 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap13 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap14 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap15 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap16 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap17 = alphabet.zipWithIndex.map",
  "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = 'a' to\
    \ 'z'\n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val alphabetMapInv\
    \ = alphabetMap.map(_.swap)\n        val encodeMap = alphabetMap.map(x => if (vowels.contains(x._1))\
    \ (x._1, alphabetMapInv((x._2 + 2) % 26)) else (x._1, x._1))\n        message.map(x\
    \ => if (x.isUpper) encodeMap(x.toLower).toUpper else encodeMap(x))", "      \
    \  val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val map = Map[Char, Char]()\n        for (i <- 0 until alphabet.length)\
    \ {\n            val c = alphabet(i)\n            val c2 = if (i + 2 < alphabet.length)\
    \ alphabet(i + 2) else alphabet(i + 2 - alphabet.length)\n            map += (c\
    \ -> c2)\n        }\n        val sb = new StringBuilder\n        for (c <- message)\
    \ {\n            if (vowels.contains(c)) sb.append(map(c))\n            else if\
    \ (c.isUpper) sb.append(c.toLower)\n            else sb.append(c.toUpper)\n  \
    \      }\n        sb.toString", "        val vowels = Set('a', 'e', 'i', 'o',\
    \ 'u')\n        val alphabet = ('a' to 'z').toList\n        val alphabetMap =\
    \ alphabet.zipWithIndex.toMap\n        val alphabetMap2 = alphabet.zipWithIndex.map(x\
    \ => (x._2, x._1)).toMap\n        val messageList = message.toList\n        val\
    \ encodedList = messageList.map(x => if (vowels.contains(x.toLower)) alphabetMap2((alphabetMap(x.toLower)\
    \ + 2) % 26) else x)\n        val encodedList2 = encodedList.map(x => if (x.isUpper)\
    \ x.toLower else x.toUpper)\n        encodedList2.mkString", "        val vowels\
    \ = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n       \
    \ val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap = vowels.zipWithIndex.toMap\n\
    \        val encoded = message.map(c => {\n            if (vowels.contains(c.toLower))\
    \ {\n                val index = vowelsMap(c.toLower)\n                val newIndex\
    \ = (index + 2) % vowels.length\n                vowels(newIndex).toUpper\n  \
    \          } else if (alphabet.contains(c.toLower)) {\n                val index\
    \ = alphabetMap(c.toLower)\n                val newIndex = (index + 2) % alphabet.length\n\
    \                alphabet(newIndex).toUpper\n            } else {\n          \
    \      c\n            }\n        })\n        encoded", "        val vowels = \"\
    aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabetMap\
    \ = alphabet.zipWithIndex.toMap\n        val vowelsMap = vowels.zipWithIndex.toMap\n\
    \        val encoded = message.map(c => {\n            if (vowels.contains(c.toLower))\
    \ {\n                val index = vowelsMap(c.toLower)\n                val newIndex\
    \ = (index + 2) % vowels.length\n                vowels(newIndex).toUpper\n  \
    \          } else if (alphabet.contains(c.toLower)) {\n                val index\
    \ = alphabetMap(c.toLower)\n                val newIndex = (index + 2) % alphabet.length\n\
    \                alphabet(newIndex).toUpper\n            } else {\n          \
    \      c\n            }\n        })\n        encoded", "        val vowels = \"\
    aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabetMap\
    \ = alphabet.zipWithIndex.toMap\n        val vowelsMap = vowels.zipWithIndex.toMap\n\
    \        val encoded = message.map(x => {\n            if (vowels.contains(x.toLower))\
    \ {\n                val index = vowelsMap(x.toLower)\n                val newIndex\
    \ = (index + 2) % vowels.length\n                vowels(newIndex).toUpper\n  \
    \          } else {\n                if (x.isUpper) alphabet(alphabetMap(x.toLower)).toUpper\
    \ else alphabet(alphabetMap(x))\n            }\n        })\n        encoded",
  "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a'\
    \ to 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n    \
    \    val alphabetMap2 = alphabet.zipWithIndex.map(x => (x._2, x._1)).toMap\n \
    \       val alphabetMap3 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap4 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap5 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap6 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap7 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap8 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap9 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap10 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap11 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap12 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap13 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap14 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap15 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap16 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap17 = alphabet.zipWithIndex.map", "        val vowels =\
    \ Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        def encodeChar(c : Char) : Char = {\n            if (vowels.contains(c))\
    \ {\n                val index = alphabet.indexOf(c)\n                alphabet((index\
    \ + 2) % alphabet.length)\n            } else {\n                c\n         \
    \   }\n        }\n        message.map(c => if (c.isUpper) c.toLower else c.toUpper).map(encodeChar)",
  "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a'\
    \ to 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n    \
    \    def encodeChar(c : Char) : Char = {\n            if (vowels.contains(c))\
    \ {\n                val index = alphabetMap(c)\n                alphabet((index\
    \ + 2) % alphabet.length)\n            } else if (c.isUpper) {\n             \
    \   c.toLower\n            } else {\n                c.toUpper\n            }\n\
    \        }\n        message.map(encodeChar)", "        val vowels = \"aeiou\"\n\
    \        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabetMap\
    \ = alphabet.zipWithIndex.toMap\n        val vowelsMap = vowels.zipWithIndex.toMap\n\
    \        val encoded = message.map(x => {\n            val index = alphabetMap(x.toLower)\n\
    \            if (vowels.contains(x.toLower)) {\n                val vowelIndex\
    \ = vowelsMap(x.toLower)\n                val newVowelIndex = (vowelIndex + 2)\
    \ % vowels.length\n                val newVowel = vowels(newVowelIndex)\n    \
    \            if (x.isUpper) newVowel.toUpper else newVowel\n            } else\
    \ {\n                if (x.isUpper) alphabet(index).toUpper else alphabet(index)\n\
    \            }\n        })\n        encoded", "        val vowels = \"aeiou\"\n\
    \        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabetMap\
    \ = alphabet.zipWithIndex.toMap\n        val vowelsMap = vowels.zipWithIndex.toMap\n\
    \        val result = new StringBuilder\n        for (c <- message) {\n      \
    \      if (vowels.contains(c.toLower)) {\n                val index = vowelsMap(c.toLower)\n\
    \                val newIndex = (index + 2) % vowels.length\n                result.append(vowels(newIndex).toUpper)\n\
    \            } else {\n                val index = alphabetMap(c.toLower)\n  \
    \              val newIndex = (index + 2) % alphabet.length\n                result.append(alphabet(newIndex).toUpper)\n\
    \            }\n        }\n        result.toString", "        val vowels = Set('a',\
    \ 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n        def\
    \ encodeChar(c : Char) : Char = {\n            if (vowels.contains(c)) {\n   \
    \             val index = alphabet.indexOf(c)\n                alphabet((index\
    \ + 2) % alphabet.length)\n            } else {\n                c\n         \
    \   }\n        }\n        message.map(c => if (c.isUpper) c.toLower else c.toUpper).map(encodeChar).mkString",
  "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val encoded =\
    \ message.map(c => {\n            if (vowels.contains(c.toLower)) {\n        \
    \        val index = alphabetMap(c.toLower)\n                alphabet((index +\
    \ 2) % alphabet.length)\n            } else {\n                c\n           \
    \ }\n        })\n        encoded.toUpperCase", "        val vowels = \"aeiou\"\
    \n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabetMap\
    \ = alphabet.zipWithIndex.toMap\n        val vowelsMap = vowels.zipWithIndex.toMap\n\
    \        val encoded = message.map(c => {\n            if (vowels.contains(c.toLower))\
    \ {\n                val index = vowelsMap(c.toLower)\n                val newIndex\
    \ = (index + 2) % vowels.length\n                vowels(newIndex).toUpper\n  \
    \          } else {\n                c.toUpper\n            }\n        })\n  \
    \      encoded", "        var result = \"\"\n        for (c <- message) {\n  \
    \          if (c.isUpper) {\n                result += c.toLower\n           \
    \ } else if (c.isLower) {\n                result += c.toUpper\n            }\
    \ else {\n                result += c\n            }\n        }\n        result",
  "        val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val result = new StringBuilder\n      \
    \  for (c <- message) {\n            if (c.isUpper) {\n                result\
    \ += c.toLower\n            } else if (c.isLower) {\n                if (vowelsMap.contains(c))\
    \ {\n                    val index = (vowelsMap(c) + 2) % vowels.length\n    \
    \                result += vowels(index)\n                } else {\n         \
    \           result += c\n                }\n            } else {\n           \
    \     result += c\n            }\n        }\n        result.toString", "     \
    \   val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to\
    \ 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n       \
    \ val encoded = message.map(c => {\n            if (c.isUpper) c.toLower else\
    \ c\n        }).map(c => {\n            if (vowels.contains(c)) {\n          \
    \      val index = alphabetMap(c)\n                alphabet((index + 2) % alphabet.length)\n\
    \            } else {\n                c\n            }\n        }).map(c => {\n\
    \            if (c.isLower) c.toUpper else c\n        })\n        encoded.mkString",
  "        val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val encoded = message.map(c => {\n    \
    \        if (vowels.contains(c.toLower)) {\n                val index = vowelsMap(c.toLower)\n\
    \                val newIndex = (index + 2) % vowels.length\n                vowels(newIndex).toUpper\n\
    \            } else if (alphabet.contains(c.toLower)) {\n                val index\
    \ = alphabetMap(c.toLower)\n                val newIndex = (index + 2) % alphabet.length\n\
    \                alphabet(newIndex).toUpper\n            } else {\n          \
    \      c\n            }\n        })\n        encoded", "        val vowels = List('a',\
    \ 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n        val\
    \ encodeMap = vowels.zip(vowels.map(x => alphabet((alphabet.indexOf(x) + 2) %\
    \ 26))).toMap\n        message.map(x => if (vowels.contains(x.toLower)) encodeMap(x.toLower)\
    \ else x).map(x => if (x.isUpper) x.toLower else x.toUpper).mkString", "     \
    \   val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val encoded = message.map(c => {\n    \
    \        if (vowels.contains(c.toLower)) {\n                val index = vowelsMap(c.toLower)\n\
    \                val newIndex = (index + 2) % vowels.length\n                vowels(newIndex).toUpper\n\
    \            } else if (alphabet.contains(c.toLower)) {\n                val index\
    \ = alphabetMap(c.toLower)\n                val newIndex = (index + 2) % alphabet.length\n\
    \                alphabet(newIndex).toUpper\n            } else {\n          \
    \      c\n            }\n        })\n        encoded", "        val vowels = Set('a',\
    \ 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n        val\
    \ alphabetMap = alphabet.zipWithIndex.toMap\n        def encodeChar(c : Char)\
    \ : Char = {\n            if (vowels.contains(c)) {\n                val index\
    \ = alphabetMap(c)\n                alphabet((index + 2) % alphabet.length)\n\
    \            } else if (c.isUpper) {\n                c.toLower\n            }\
    \ else {\n                c.toUpper\n            }\n        }\n        message.map(encodeChar)",
  "        val vowels = \"aeiouAEIOU\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val alphabetMap2\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2) % alphabet.length -> x._1).toMap\n\
    \        message.map(x => if (vowels.contains(x)) alphabetMap2(alphabetMap(x))\
    \ else x)", "        val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val encoded = message.map(c => {\n    \
    \        if (vowels.contains(c.toLower)) {\n                val index = vowelsMap(c.toLower)\n\
    \                val newIndex = (index + 2) % vowels.length\n                vowels(newIndex).toUpper\n\
    \            } else if (alphabet.contains(c.toLower)) {\n                val index\
    \ = alphabetMap(c.toLower)\n                val newIndex = (index + 2) % alphabet.length\n\
    \                alphabet(newIndex).toUpper\n            } else {\n          \
    \      c\n            }\n        })\n        encoded", "        val vowels = Set('a',\
    \ 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n        val\
    \ alphabetMap = alphabet.zipWithIndex.toMap\n        message.map(c => {\n    \
    \        if (vowels.contains(c.toLower)) {\n                val index = alphabetMap(c.toLower)\n\
    \                val newIndex = (index + 2) % alphabet.length\n              \
    \  alphabet(newIndex)\n            } else {\n                c\n            }\n\
    \        }).map(c => if (c.isUpper) c.toLower else c.toUpper).mkString", "   \
    \     val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to\
    \ 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n       \
    \ val alphabetMap2 = alphabet.zipWithIndex.map(x => (x._2 + 2) % 26 -> x._1).toMap\n\
    \        message.map(x => if (vowels.contains(x.toLower)) alphabetMap2(alphabetMap(x.toLower))\
    \ else x)", "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet\
    \ = ('a' to 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val encodedAlphabet = alphabet.map(c => if (vowels.contains(c)) alphabet((alphabetMap(c)\
    \ + 2) % alphabet.length) else c)\n        val encodedAlphabetMap = alphabet.zip(encodedAlphabet).toMap\n\
    \        message.map(c => if (c.isUpper) encodedAlphabetMap(c.toLower).toUpper\
    \ else encodedAlphabetMap(c)).mkString", "        val vowels = \"aeiou\"\n   \
    \     val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabet2 = alphabet.tail\
    \ + alphabet.head\n        val alphabet3 = alphabet2.tail + alphabet2.head\n \
    \       val alphabet4 = alphabet3.tail + alphabet3.head\n        val alphabet5\
    \ = alphabet4.tail + alphabet4.head\n        val alphabet6 = alphabet5.tail +\
    \ alphabet5.head\n        val alphabet7 = alphabet6.tail + alphabet6.head\n  \
    \      val alphabet8 = alphabet7.tail + alphabet7.head\n        val alphabet9\
    \ = alphabet8.tail + alphabet8.head\n        val alphabet10 = alphabet9.tail +\
    \ alphabet9.head\n        val alphabet11 = alphabet10.tail + alphabet10.head\n\
    \        val alphabet12 = alphabet11.tail + alphabet11.head\n        val alphabet13\
    \ = alphabet12.tail + alphabet12.head\n        val alphabet14 = alphabet13.tail\
    \ + alphabet13.head\n        val alphabet15 = alphabet14.tail + alphabet14.head\n\
    \        val alphabet16 = alphabet15.tail + alphabet15.head\n        val alphabet17\
    \ = alphabet16.tail + alphabet16.head\n        val alphabet18 = alphabet17.tail\
    \ + alphabet17.head\n        val alphabet19 = alphabet18.tail + alphabet18.head\n\
    \        val alphabet20 = alphabet19.tail + alphabet19.head\n        val alphabet21\
    \ = alphabet20.tail + alphabet20.head\n        val alphabet22 = alphabet21.tail\
    \ + alphabet21.head\n        val alphabet23 = alphabet22.tail + alphabet22.head\n\
    \        val alphabet24 = alphabet23.tail + alphabet23.head\n        val alphabet25\
    \ = alphabet24.tail + alphabet24.head\n        val alphabet26 = alphabet25.tail\
    \ + alphabet25.head\n        val alphabet27 = alphabet26.tail + alphabet26.head\n\
    \        val alphabet28 = alphabet27.tail + alphabet27.head\n        val alphabet29\
    \ = alphabet28.tail + alphabet28.head\n        val alphabet30 = alphabet29.tail\
    \ + alphabet29.head\n        val alphabet31 = alphabet30.tail + alphabet30.head\n\
    \        val alphabet32 = alphabet31.tail + alphabet31.head\n        val alphabet33\
    \ = alphabet32.tail + alphabet32.head\n       ", "        val vowels = Set('a',\
    \ 'e', 'i', 'o', 'u')\n        val alphabet = 'a' to 'z'\n        val alphabetMap\
    \ = alphabet.zipWithIndex.toMap\n        val encoded = message.map(c => {\n  \
    \          if (vowels.contains(c.toLower)) {\n                val index = alphabetMap(c.toLower)\n\
    \                val newIndex = (index + 2) % alphabet.size\n                alphabet(newIndex).toUpper\n\
    \            } else {\n                c.toUpper\n            }\n        })\n\
    \        encoded.mkString", "        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val vowels = \"aeiou\"\n        val map = Map[Char, Char]()\n      \
    \  var i = 0\n        while (i < alphabet.length) {\n            map += (alphabet(i)\
    \ -> alphabet((i + 2) % alphabet.length))\n            i += 1\n        }\n   \
    \     var j = 0\n        while (j < vowels.length) {\n            map += (vowels(j)\
    \ -> vowels((j + 2) % vowels.length))\n            j += 1\n        }\n       \
    \ var k = 0\n        var result = \"\"\n        while (k < message.length) {\n\
    \            val c = message(k)\n            if (c.isUpper) result += map(c.toLower).toUpper\n\
    \            else result += map(c)\n            k += 1\n        }\n        result",
  "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a'\
    \ to 'z').toList\n        def encodeChar(c : Char) : Char = {\n            if\
    \ (vowels.contains(c)) {\n                val index = alphabet.indexOf(c)\n  \
    \              alphabet((index + 2) % alphabet.length)\n            } else {\n\
    \                c\n            }\n        }\n        message.map(c => if (c.isUpper)\
    \ c.toLower else c.toUpper).map(encodeChar).mkString", "        val vowels = Set('a',\
    \ 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n        val\
    \ alphabetMap = alphabet.zipWithIndex.toMap\n        val alphabetMap2 = alphabet.zipWithIndex.map(x\
    \ => (x._2, x._1)).toMap\n        val alphabetMap3 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap4 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap5 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap6 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap7 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap8 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap9 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap10 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap11 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap12 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap13 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap14 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap15 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap16 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap17 = alphabet.zipWithIndex.map",
  "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a'\
    \ to 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n    \
    \    val alphabetMap2 = alphabet.zipWithIndex.map { case (c, i) => (c, (i + 2)\
    \ % alphabet.length) }.toMap\n        message.map(c => if (vowels.contains(c.toLower))\
    \ alphabet(alphabetMap2(c.toLower)) else c).map(c => if (c.isUpper) c.toLower\
    \ else c.toUpper).mkString", "        val vowels = \"aeiou\"\n        val alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val vowelsMap = vowels.zipWithIndex.toMap\n        val alphabetMap2 =\
    \ alphabet.zipWithIndex.map(x => (x._2, x._1)).toMap\n        def encodeChar(c\
    \ : Char) : Char = {\n            if (vowels.contains(c)) {\n                val\
    \ index = vowelsMap(c)\n                alphabetMap2((index + 2) % 5)\n      \
    \      } else if (alphabet.contains(c)) {\n                alphabetMap2((alphabetMap(c)\
    \ + 13) % 26)\n            } else c\n        }\n        message.map(encodeChar)",
  "        def encodeChar(c : Char) : Char = {\n            val vowels = Set('a',\
    \ 'e', 'i', 'o', 'u')\n            if (vowels.contains(c)) {\n               \
    \ val next = c + 1\n                if (vowels.contains(next)) next + 1 else next\n\
    \            } else if (c.isUpper) c.toLower else c.toUpper\n        }\n     \
    \   message.map(encodeChar)", "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n\
    \        val alphabet = ('a' to 'z').toList\n        def encodeChar(c : Char)\
    \ : Char = {\n            if (vowels.contains(c)) {\n                val index\
    \ = alphabet.indexOf(c)\n                alphabet((index + 2) % alphabet.length)\n\
    \            } else {\n                c\n            }\n        }\n        message.map(c\
    \ => if (c.isUpper) c.toLower else c.toUpper).map(encodeChar).mkString", "   \
    \     val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to\
    \ 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n       \
    \ val alphabetMap2 = alphabet.zipWithIndex.map(x => (x._2 + 2) % 26 -> x._1).toMap\n\
    \        message.map(x => if (vowels.contains(x.toLower)) alphabetMap2(alphabetMap(x.toLower))\
    \ else x)", "        val vowels = List('a', 'e', 'i', 'o', 'u')\n        val alphabet\
    \ = ('a' to 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val encoded = message.map(c => {\n            if (vowels.contains(c.toLower))\
    \ {\n                val index = alphabetMap(c.toLower)\n                val newIndex\
    \ = (index + 2) % alphabet.length\n                val newChar = alphabet(newIndex)\n\
    \                if (c.isUpper) newChar.toUpper else newChar\n            } else\
    \ if (c.isUpper) c.toLower else c.toUpper\n        })\n        encoded", "   \
    \     val vowels = \"aeiouAEIOU\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val alphabetMap2\
    \ = alphabet.zipWithIndex.toMap.map(x => (x._2 + 2) % alphabet.length -> x._1)\n\
    \        val encoded = message.map(x => if (vowels.contains(x)) alphabetMap2(alphabetMap(x))\
    \ else x)\n        encoded.map(x => if (x.isUpper) x.toLower else x.toUpper).mkString",
  "        val vowels = List('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a'\
    \ to 'z').toList\n        val encoded = message.map(c => {\n            if (vowels.contains(c.toLower))\
    \ {\n                val index = alphabet.indexOf(c.toLower)\n               \
    \ alphabet((index + 2) % alphabet.length)\n            } else {\n            \
    \    c\n            }\n        })\n        encoded.map(c => if (c.isUpper) c.toLower\
    \ else c.toUpper).mkString", "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n\
    \        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabetMap\
    \ = alphabet.zipWithIndex.toMap\n        val alphabetMap2 = alphabet.zipWithIndex.map(x\
    \ => (x._2, x._1)).toMap\n        def encodeChar(c : Char) : Char = {\n      \
    \      if (vowels.contains(c)) {\n                val index = alphabetMap(c)\n\
    \                alphabetMap2((index + 2) % 26)\n            } else {\n      \
    \          if (c.isUpper) c.toLower else c.toUpper\n            }\n        }\n\
    \        message.map(encodeChar)", "        val vowels = Set('a', 'e', 'i', 'o',\
    \ 'u')\n        val alphabet = ('a' to 'z').toList\n        val alphabetMap =\
    \ alphabet.zipWithIndex.toMap\n        val encodeMap = alphabet.zip(alphabet.drop(2)\
    \ ++ alphabet.take(2)).toMap\n        message.map(c => if (vowels.contains(c.toLower))\
    \ encodeMap(c.toLower) else c)", "        val vowels = \"aeiou\"\n        val\
    \ alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val vowelsMap = vowels.zipWithIndex.toMap\n        val encoded = message.map(c\
    \ => {\n            if (c.isUpper) {\n                c.toLower\n            }\
    \ else if (c.isLower) {\n                if (vowels.contains(c)) {\n         \
    \           val index = vowelsMap(c)\n                    val newIndex = (index\
    \ + 2) % vowels.length\n                    vowels(newIndex).toUpper\n       \
    \         } else {\n                    c.toUpper\n                }\n       \
    \     } else {\n                c\n            }\n        })\n        encoded",
  "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val alphabetMap2\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2) % 26 -> x._1).toMap\n        message.map(x\
    \ => if (vowels.contains(x.toLower)) alphabetMap2(alphabetMap(x.toLower)) else\
    \ x)", "        val vowels = \"aeiou\"\n        val letters = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val letters2 = \"cdefghijklmnopqrstuvwxyzab\"\n        val letters3\
    \ = \"efghijklmnopqrstuvwxyzabcd\"\n        val letters4 = \"ghijklmnopqrstuvwxyzabcdef\"\
    \n        val letters5 = \"ijklmnopqrstuvwxyzabcdefgh\"\n        val letters6\
    \ = \"klmnopqrstuvwxyzabcdefghij\"\n        val letters7 = \"mnopqrstuvwxyzabcdefghijkl\"\
    \n        val letters8 = \"opqrstuvwxyzabcdefghijklmn\"\n        val letters9\
    \ = \"pqrstuvwxyzabcdefghijklmno\"\n        val letters10 = \"qrstuvwxyzabcdefghijklmnop\"\
    \n        val letters11 = \"rstuvwxyzabcdefghijklmnopq\"\n        val letters12\
    \ = \"stuvwxyzabcdefghijklmnopqr\"\n        val letters13 = \"tuvwxyzabcdefghijklmnopqrs\"\
    \n        val letters14 = \"uvwxyzabcdefghijklmnopqrst\"\n        val letters15\
    \ = \"vwxyzabcdefghijklmnopqrstu\"\n        val letters16 = \"wxyzabcdefghijklmnopqrstuv\"\
    \n        val letters17 = \"xyzabcdefghijklmnopqrstuvw\"\n        val letters18\
    \ = \"yzabcdefghijklmnopqrstuvwx\"\n        val letters19 = \"zabcdefghijklmnopqrstuvwxy\"\
    \n        var result = \"\"\n        for (i <- 0 until message.length) {\n   \
    \         if (vowels.contains(message(i))) {\n                if (message(i) ==\
    \ 'a') result += letters2(i)\n                else if (message(i) == 'e') result\
    \ += letters3(i)\n                else if (message(", "        val vowels = \"\
    aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabetMap\
    \ = alphabet.zipWithIndex.toMap\n        message.map(c => {\n            if (vowels.contains(c.toLower))\
    \ {\n                val index = alphabetMap(c.toLower)\n                val newIndex\
    \ = if (index + 2 > 25) index + 2 - 26 else index + 2\n                alphabet(newIndex).toUpper\n\
    \            } else {\n                c.toUpper\n            }\n        })",
  "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a'\
    \ to 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n    \
    \    val alphabetMapRev = alphabetMap.map(_.swap)\n        val alphabetMapRev2\
    \ = alphabetMapRev.map(x => (x._1 + 2, x._2))\n        def encodeChar(c : Char)\
    \ : Char = {\n            if (vowels.contains(c)) {\n                alphabetMapRev2(alphabetMap(c.toLower))\n\
    \            } else {\n                c\n            }\n        }\n        message.map(x\
    \ => if (x.isUpper) encodeChar(x.toLower).toUpper else encodeChar(x))"]
stop_tokens:
- "\n    }\n"
