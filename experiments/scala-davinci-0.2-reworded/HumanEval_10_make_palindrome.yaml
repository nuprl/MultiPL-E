name: HumanEval_10_make_palindrome
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Find the shortest palindrome that begins with a supplied string.\n    //\
  \ Algorithm idea is simple:\n    // - Find the longest postfix of supplied string\
  \ that is a palindrome.\n    // - Append to the end of the string reverse of a string\
  \ prefix that comes before the palindromic suffix.\n    // >>> makePalindrome((\"\
  \"))\n    // (\"\")\n    // >>> makePalindrome((\"cat\"))\n    // (\"catac\")\n\
  \    // >>> makePalindrome((\"cata\"))\n    // (\"catac\")\n    def makePalindrome(string\
  \ : String) : String = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\
  \")).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n  \
  \  assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"\
  xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"jerryrrej\"\
  )));\n    }\n\n}\n"
completions: ["        val s = string.toCharArray\n        val n = s.length\n    \
    \    val t = new Array[Int](n)\n        var i = 1; var j = 0\n        while (i\
    \ < n) {\n            if (s(i) == s(j)) {\n                t(i) = j + 1\n    \
    \            i += 1; j += 1\n            } else if (j > 0) j = t(j - 1)\n    \
    \        else {\n                t(i) = 0\n                i += 1\n          \
    \  }\n        }\n        val prefix = string.substring(0, n - t(n - 1))\n    \
    \    string + prefix.reverse", "        val n = string.length\n        val suffix\
    \ = (0 until n).map(i => string.substring(i)).filter(s => s == s.reverse).maxBy(_.length)\n\
    \        val prefix = string.substring(0, n - suffix.length)\n        prefix +\
    \ suffix + prefix.reverse", "        val reversed = string.reverse\n        val\
    \ suffix = string.zip(reversed).takeWhile(x => x._1 == x._2).map(_._1).mkString\n\
    \        val prefix = string.substring(0, string.length - suffix.length)\n   \
    \     string + prefix.reverse", "        val n = string.length\n        val suffix\
    \ = (0 until n).map(i => string.substring(i)).filter(s => s == s.reverse).maxBy(_.length)\n\
    \        val prefix = string.substring(0, n - suffix.length)\n        prefix +\
    \ suffix + prefix.reverse", "        var prefix = string\n        var suffix =\
    \ \"\"\n        while (prefix.length > 0) {\n            if (isPalindrome(prefix))\
    \ {\n                return prefix + suffix\n            }\n            suffix\
    \ = prefix.charAt(0) + suffix\n            prefix = prefix.substring(1)\n    \
    \    }\n        return prefix + suffix", "        val n = string.length\n    \
    \    val suffix = string.substring(n / 2, n)\n        val prefix = string.substring(0,\
    \ n / 2)\n        val suffixPalindrome = new StringBuilder(suffix).reverse.toString\n\
    \        if (suffix == suffixPalindrome) return string\n        val prefixPalindrome\
    \ = new StringBuilder(prefix).reverse.toString\n        val suffixPalindromePrefix\
    \ = prefixPalindrome.substring(0, prefixPalindrome.length - suffix.length)\n \
    \       return prefix + suffixPalindromePrefix + suffix", "        // Find the\
    \ longest palindromic suffix.\n        def findLongestPalindromicSuffix(string\
    \ : String) : String = {\n            def findLongestPalindromicSuffix(string\
    \ : String, index : Int) : String = {\n                if (index == string.length)\
    \ \"\"\n                else if (isPalindrome(string.substring(index))) string.substring(index)\n\
    \                else findLongestPalindromicSuffix(string, index + 1)\n      \
    \      }\n            findLongestPalindromicSuffix(string, 0)\n        }\n   \
    \     // Find the longest palindromic prefix.\n        def findLongestPalindromicPrefix(string\
    \ : String) : String = {\n            def findLongestPalindromicPrefix(string\
    \ : String, index : Int) : String = {\n                if (index == -1) \"\"\n\
    \                else if (isPalindrome(string.substring(0, index + 1))) string.substring(0,\
    \ index + 1)\n                else findLongestPalindromicPrefix(string, index\
    \ - 1)\n            }\n            findLongestPalindromicPrefix(string, string.length\
    \ - 1)\n        }\n        // Check if a string is a palindrome.\n        def\
    \ isPalindrome(string : String) : Boolean = {\n            def isPalindrome(string\
    \ : String, index : Int) : Boolean = {\n                if (index == string.length\
    \ / 2) true\n                else if (string(index) != string(string.length -\
    \ index - 1)) false\n                else isPalindrome(string, index + 1)\n  \
    \          }\n            isPalindrome(string, 0)\n        }\n        // Find\
    \ the longest palindromic suffix.\n        val longestPalindromicSuffix = findLongestPalindromicSuffix(string)\n\
    \        // Find the longest palindromic prefix.\n        val longestPalindromicPrefix\
    \ = findLongestPalindromicPrefix(string)\n        // If the longest palindromic\
    \ suffix is the whole string, then the string is already a palindrome.\n     \
    \   if (longestPalindromicSuffix == string) string", "        val n = string.length\n\
    \        val suffix = string.substring(n / 2, n)\n        val prefix = string.substring(0,\
    \ n / 2)\n        val reversedPrefix = prefix.reverse\n        val palindromeSuffix\
    \ = suffix.substring(0, suffix.indexOf(reversedPrefix) + 1)\n        val palindrome\
    \ = suffix + reversedPrefix.substring(reversedPrefix.indexOf(palindromeSuffix))\n\
    \        palindrome", "        val palindromeSuffix = string.suffixes.find(s =>\
    \ s.length > 0 && s == s.reverse).get\n        val palindromePrefix = string.substring(0,\
    \ string.length - palindromeSuffix.length)\n        palindromePrefix + palindromeSuffix\
    \ + palindromePrefix.reverse", "        val n = string.length\n        val suffix\
    \ = string.substring(n / 2, n)\n        val prefix = string.substring(0, n / 2)\n\
    \        val reverse = prefix.reverse\n        val palindrome = suffix + reverse\n\
    \        val longest = longestPalindrome(palindrome)\n        val prefixToAppend\
    \ = palindrome.substring(longest.length, palindrome.length)\n        val result\
    \ = prefixToAppend + palindrome\n        result", "        val palindromeSuffix\
    \ = string.substring(0, string.length - string.reverse.indexOf(string.reverse.intersect(string)))\n\
    \        val prefix = string.substring(palindromeSuffix.length)\n        prefix\
    \ + string", "        val n = string.length\n        val suffix = string.substring(n\
    \ / 2, n)\n        val prefix = string.substring(0, n / 2)\n        val reversePrefix\
    \ = prefix.reverse\n        val palindromeSuffix = suffix.reverse\n        if\
    \ (suffix == palindromeSuffix) return string\n        val suffixLength = suffix.length\n\
    \        for (i <- 1 to suffixLength) {\n            val suffixSubstring = suffix.substring(0,\
    \ suffixLength - i)\n            val palindromeSuffixSubstring = suffixSubstring.reverse\n\
    \            if (suffixSubstring == palindromeSuffixSubstring) return prefix +\
    \ suffixSubstring + reversePrefix\n        }\n        throw new Exception(\"Unable\
    \ to find palindrome suffix\")", "        def findLongestPalindrome(string : String)\
    \ : String = {\n            def isPalindrome(string : String) : Boolean = {\n\
    \                val length = string.length\n                for (i <- 0 until\
    \ length / 2) {\n                    if (string(i) != string(length - 1 - i))\
    \ return false\n                }\n                return true\n            }\n\
    \            for (i <- string.length to 0 by -1) {\n                val substring\
    \ = string.substring(string.length - i)\n                if (isPalindrome(substring))\
    \ return substring\n            }\n            return \"\"\n        }\n      \
    \  val palindrome = findLongestPalindrome(string)\n        val prefix = string.substring(0,\
    \ string.length - palindrome.length)\n        return string + prefix.reverse",
  "        val n = string.length\n        val s = string + \"#\" + string.reverse\n\
    \        val z = Array.fill(s.length)(0)\n        var l = 0; var r = 0\n     \
    \   for (i <- 1 until s.length) {\n            if (i > r) {\n                l\
    \ = i; r = i\n                while (r < s.length && s(r - l) == s(r)) r += 1\n\
    \                z(i) = r - l; r -= 1\n            } else {\n                val\
    \ k = i - l\n                if (z(k) < r - i + 1) z(i) = z(k)\n             \
    \   else {\n                    l = i;\n                    while (r < s.length\
    \ && s(r - l) == s(r)) r += 1\n                    z(i) = r - l; r -= 1\n    \
    \            }\n            }\n        }\n        return string + string.substring(n\
    \ - z(n + 1), n).reverse", "        val length = string.length\n        var i\
    \ = 0\n        var j = length - 1\n        var k = 0\n        while (i < j) {\n\
    \            if (string(i) == string(j)) {\n                i += 1\n         \
    \       j -= 1\n            } else {\n                i = 0\n                k\
    \ += 1\n                j = length - 1 - k\n            }\n        }\n       \
    \ val prefix = string.substring(0, length - k)\n        val suffix = string.substring(length\
    \ - k)\n        prefix + suffix.reverse", "        val n = string.length\n   \
    \     val s = string + \"#\" + string.reverse\n        val pi = new Array[Int](s.length)\n\
    \        for (i <- 1 until s.length) {\n            var j = pi(i - 1)\n      \
    \      while (j > 0 && s(i) != s(j)) j = pi(j - 1)\n            if (s(i) == s(j))\
    \ j += 1\n            pi(i) = j\n        }\n        string + string.substring(pi(s.length\
    \ - 1)).reverse", "        val n = string.length\n        if (n == 0) return \"\
    \"\n        val suffix = string.substring(n / 2, n)\n        val prefix = string.substring(0,\
    \ n / 2)\n        val reversedPrefix = prefix.reverse\n        val palindromeSuffix\
    \ = suffix + reversedPrefix\n        val palindrome = palindromeSuffix + string\n\
    \        palindrome", "        val n = string.length\n        val longestPalindromeSuffix\
    \ = (0 until n).find(i => string.substring(i) == string.substring(i).reverse).getOrElse(0)\n\
    \        string + string.substring(0, n - longestPalindromeSuffix).reverse", " \
    \       val n = string.length\n        val suffix = new Array[Int](n)\n      \
    \  var i = 0\n        var j = 1\n        while (j < n) {\n            if (string(i)\
    \ == string(j)) {\n                suffix(j) = i + 1\n                i += 1\n\
    \            } else {\n                if (i == 0) {\n                    suffix(j)\
    \ = 0\n                } else {\n                    i = suffix(i - 1)\n     \
    \               j -= 1\n                }\n            }\n            j += 1\n\
    \        }\n        val prefix = string.substring(0, n - suffix(n - 1))\n    \
    \    string + prefix.reverse", "        val n = string.length\n        val suffix\
    \ = string.substring(n / 2, n)\n        val prefix = string.substring(0, n / 2)\n\
    \        val reversedPrefix = prefix.reverse\n        val palindromeSuffix = suffix.substring(0,\
    \ suffix.indexOf(reversedPrefix))\n        val palindromePrefix = reversedPrefix.substring(reversedPrefix.indexOf(palindromeSuffix))\n\
    \        palindromePrefix + string + palindromeSuffix.reverse"]
stop_tokens:
- "\n    }\n"
