name: HumanEval_39_prime_fib
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // prime_fib returns n-th number that is a Fibonacci number and it's also prime.\n\
  \    // >>> primeFib((1l))\n    // (2l)\n    // >>> primeFib((2l))\n    // (3l)\n\
  \    // >>> primeFib((3l))\n    // (5l)\n    // >>> primeFib((4l))\n    // (13l)\n\
  \    // >>> primeFib((5l))\n    // (89l)\n    def primeFib(n : Long) : Long = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(primeFib((1l)) ==\
  \ (2l));\n    assert(primeFib((2l)) == (3l));\n    assert(primeFib((3l)) == (5l));\n\
  \    assert(primeFib((4l)) == (13l));\n    assert(primeFib((5l)) == (89l));\n  \
  \  assert(primeFib((6l)) == (233l));\n    assert(primeFib((7l)) == (1597l));\n \
  \   assert(primeFib((8l)) == (28657l));\n    assert(primeFib((9l)) == (514229l));\n\
  \    assert(primeFib((10l)) == (433494437l));\n    }\n\n}\n"
completions: ["        var fibs = new ArrayBuffer[Long]();\n        fibs += 2;\n \
    \       fibs += 3;\n        var i = 2;\n        while(i <= n) {\n            fibs\
    \ += fibs(i - 1) + fibs(i - 2);\n            i += 1;\n        }\n        return\
    \ fibs(n.toInt - 1);", "        val primes = new PrimeSet(1000000)\n        var\
    \ fib = new Fibonacci()\n        var i = 0l\n        var p = 0l\n        while\
    \ (i < n) {\n            p = fib.next\n            if (primes.contains(p)) i +=\
    \ 1\n        }\n        return p", "        var i = 1l\n        var j = 2l\n \
    \       var k = 3l\n        var count = 2l\n        while (count < n) {\n    \
    \        i = j\n            j = k\n            k = i + j\n            if (isPrime(k))\
    \ count += 1\n        }\n        return k", "        var count = 0l\n        var\
    \ i = 1l\n        while (count < n) {\n            if (isPrime(fib(i))) count\
    \ += 1\n            i += 1\n        }\n        return fib(i - 1)", "        val\
    \ primes = new PrimeSet(1000000)\n        var a = 2l\n        var b = 3l\n   \
    \     var c = 5l\n        var i = 5l\n        while (i < n) {\n            a =\
    \ b\n            b = c\n            c = a + b\n            i += 1\n        }\n\
    \        return c", "        val primes = new PrimeSet(1000000)\n        var i\
    \ = 1l\n        var fib = 1l\n        var fib_prev = 1l\n        while (i < n)\
    \ {\n            val fib_next = fib + fib_prev\n            fib_prev = fib\n \
    \           fib = fib_next\n            if (primes.contains(fib)) i += 1\n   \
    \     }\n        fib", "        def primeFib(n : Long, a : Long, b : Long, i :\
    \ Long) : Long = {\n            if (i == n) b\n            else if (b.isPrime)\
    \ primeFib(n, b, a + b, i + 1)\n            else primeFib(n, b, a + b, i)\n  \
    \      }\n        primeFib(n, 2, 3, 1)", "        def primeFibRec(n : Long, a\
    \ : Long, b : Long, c : Long) : Long = {\n            if (n == 1) a\n        \
    \    else if (n == 2) b\n            else if (n == 3) c\n            else {\n\
    \                val d = a + b + c\n                if (isPrime(d)) primeFibRec(n\
    \ - 1, b, c, d)\n                else primeFibRec(n, b, c, d)\n            }\n\
    \        }\n        primeFibRec(n, 2, 3, 5)", "        var fibs = new ArrayBuffer[Long]();\n\
    \        fibs += 2;\n        fibs += 3;\n        var i = 2;\n        while (i\
    \ <= n) {\n            var fib = fibs(i - 1) + fibs(i - 2);\n            if (fib.isPrime)\
    \ {\n                fibs += fib;\n                i += 1;\n            }\n  \
    \      }\n        return fibs(n.toInt - 1);", "        val primes = new PrimeSet(1000000)\n\
    \        var i = 0l\n        var j = 1l\n        var k = 0l\n        var count\
    \ = 0l\n        while (count < n) {\n            k = i + j\n            i = j\n\
    \            j = k\n            if (primes.isPrime(k)) count += 1\n        }\n\
    \        k", "        var fibs = new ArrayBuffer[Long]();\n        fibs += 1l;\n\
    \        fibs += 2l;\n        var i = 2l;\n        while (i < n) {\n         \
    \   fibs += fibs(i.toInt - 1) + fibs(i.toInt - 2);\n            i += 1l;\n   \
    \     }\n        var j = fibs.length - 1;\n        while (j >= 0) {\n        \
    \    if (isPrime(fibs(j.toInt))) {\n                return fibs(j.toInt);\n  \
    \          }\n            j -= 1;\n        }\n        return 0l;", "        var\
    \ fib = new Array[Long](n.toInt)\n        fib(0) = 2\n        fib(1) = 3\n   \
    \     var i = 2\n        while (i < n) {\n            fib(i) = fib(i - 1) + fib(i\
    \ - 2)\n            i += 1\n        }\n        return fib(n.toInt - 1)", "   \
    \     var i = 1l\n        var j = 2l\n        var k = 3l\n        var count =\
    \ 1l\n        while (count < n) {\n            if (isPrime(k)) {\n           \
    \     count += 1\n            }\n            val t = k\n            k = i + j\n\
    \            i = j\n            j = t\n        }\n        k", "        var fibs\
    \ = new ArrayBuffer[Long]()\n        fibs += 2\n        fibs += 3\n        var\
    \ i = 2\n        while (i <= n) {\n            val next = fibs(i - 1) + fibs(i\
    \ - 2)\n            if (isPrime(next)) {\n                fibs += next\n     \
    \           i += 1\n            }\n        }\n        fibs(n.toInt - 1)", "  \
    \      var f1 : Long = 2l\n        var f2 : Long = 3l\n        var f3 : Long =\
    \ 5l\n        var i : Long = 3l\n        while (i < n) {\n            f1 = f2\n\
    \            f2 = f3\n            f3 = f1 + f2\n            if (f3.isPrime) {\n\
    \                i += 1\n            }\n        }\n        return f3", "     \
    \   val primes = new PrimeSet(1000000)\n        var i = 1l\n        var j = 2l\n\
    \        var k = 3l\n        var count = 1l\n        while (count < n) {\n   \
    \         i = j\n            j = k\n            k = i + j\n            if (primes.contains(k))\
    \ count += 1\n        }\n        k", "        var f1 : Long = 2l\n        var\
    \ f2 : Long = 3l\n        var f3 : Long = 5l\n        var i : Long = 3l\n    \
    \    while(i < n) {\n            f1 = f2\n            f2 = f3\n            f3\
    \ = f1 + f2\n            while(f3 % 2 == 0) {\n                f3 = f1 + f2\n\
    \                f1 = f2\n                f2 = f3\n            }\n           \
    \ i = i + 1\n        }\n        return f3", "        val primes = new PrimeSet(1000000)\n\
    \        var i = 1l\n        var j = 1l\n        var k = 1l\n        while (k\
    \ < n) {\n            val t = i + j\n            if (primes.isPrime(t)) k += 1\n\
    \            i = j\n            j = t\n        }\n        j", "        var fib\
    \ = new Array[Long](n.toInt + 1)\n        fib(0) = 0\n        fib(1) = 1\n   \
    \     var i = 2\n        while (i <= n) {\n            fib(i) = fib(i - 1) + fib(i\
    \ - 2)\n            i += 1\n        }\n        var prime = new Array[Boolean](fib(n.toInt)\
    \ + 1)\n        i = 2\n        while (i <= fib(n.toInt)) {\n            prime(i)\
    \ = true\n            i += 1\n        }\n        i = 2\n        while (i <= fib(n.toInt))\
    \ {\n            if (prime(i)) {\n                var j = i * 2\n            \
    \    while (j <= fib(n.toInt)) {\n                    prime(j) = false\n     \
    \               j += i\n                }\n            }\n            i += 1\n\
    \        }\n        i = n.toInt\n        while (i >= 0) {\n            if (prime(fib(i)))\
    \ return fib(i)\n            i -= 1\n        }\n        return 0", "        val\
    \ primes = new PrimeSet(1000000)\n        var i = 1l\n        var j = 1l\n   \
    \     var k = 1l\n        var count = 0l\n        while (count < n) {\n      \
    \      val t = i + j\n            if (primes.isPrime(t)) {\n                count\
    \ += 1\n                k = t\n            }\n            i = j\n            j\
    \ = t\n        }\n        k", "        val primes = new PrimeSet(1000000)\n  \
    \      var fib = new Fibonacci()\n        var i = 0l\n        while (i < n) {\n\
    \            val f = fib.next\n            if (primes.contains(f)) i += 1\n  \
    \      }\n        fib.current", "        var fibs = new ArrayBuffer[Long]();\n\
    \        fibs += 2;\n        fibs += 3;\n        var i = 2;\n        while (i\
    \ <= n) {\n            val next = fibs(i - 1) + fibs(i - 2);\n            if (isPrime(next))\
    \ {\n                fibs += next;\n                i += 1;\n            }\n \
    \       }\n        return fibs(n.toInt - 1);", "        var fib = new Array[Long](n.toInt\
    \ + 1)\n        fib(0) = 0\n        fib(1) = 1\n        var i = 2\n        while\
    \ (i <= n) {\n            fib(i) = fib(i - 1) + fib(i - 2)\n            i += 1\n\
    \        }\n        return fib(n.toInt)", "        var fib = new Array[Long](n.toInt\
    \ + 1)\n        fib(0) = 0\n        fib(1) = 1\n        fib(2) = 2\n        var\
    \ i = 3\n        while (i <= n) {\n            fib(i) = fib(i - 1) + fib(i - 2)\n\
    \            i += 1\n        }\n        return fib(n.toInt)", "        var fibs\
    \ = new ArrayBuffer[Long]()\n        fibs += 2\n        fibs += 3\n        var\
    \ i = 2\n        while (i <= n) {\n            fibs += fibs(i - 1) + fibs(i -\
    \ 2)\n            i += 1\n        }\n        return fibs(n.toInt - 1)", "    \
    \    var a = 2l;\n        var b = 3l;\n        var c = 5l;\n        var i = 3l;\n\
    \        while (i < n) {\n            a = b;\n            b = c;\n           \
    \ c = a + b;\n            i = i + 1;\n        }\n        return c;", "       \
    \ def primeFib(n : Long, a : Long, b : Long, i : Long) : Long = {\n          \
    \  if (i == n) b\n            else if (isPrime(b)) primeFib(n, b, a + b, i + 1)\n\
    \            else primeFib(n, b, a + b, i)\n        }\n        primeFib(n, 1,\
    \ 2, 1)", "        var fib = new Fibonacci()\n        var i = 0l\n        var\
    \ p = 0l\n        while (i < n) {\n            p = fib.next\n            if (p.isPrime)\
    \ i += 1\n        }\n        return p", "        var fib = new Array[Long](n.toInt\
    \ + 1)\n        fib(0) = 0\n        fib(1) = 1\n        fib(2) = 2\n        var\
    \ i = 3\n        while (i <= n) {\n            fib(i) = fib(i - 1) + fib(i - 2)\n\
    \            i += 1\n        }\n        var result = fib(n.toInt)\n        while\
    \ (!isPrime(result)) {\n            result = fib(n.toInt - 1) + fib(n.toInt -\
    \ 2)\n            n -= 1\n        }\n        return result", "        var a =\
    \ 2l;\n        var b = 3l;\n        var c = 5l;\n        var i = 3l;\n       \
    \ while (i < n) {\n            a = b;\n            b = c;\n            c = a +\
    \ b;\n            i = i + 1;\n        }\n        return c;", "        val primes\
    \ = new PrimeSet(100000)\n        var i = 1l\n        var j = 1l\n        var\
    \ k = 1l\n        var c = 0l\n        while (c < n) {\n            val t = i +\
    \ j\n            if (primes.isPrime(t)) {\n                k = t\n           \
    \     c += 1\n            }\n            i = j\n            j = t\n        }\n\
    \        k", "        var primes = new ArrayBuffer[Long]();\n        primes +=\
    \ 2l;\n        primes += 3l;\n        var fibs = new ArrayBuffer[Long]();\n  \
    \      fibs += 1l;\n        fibs += 2l;\n        var i = 2l;\n        var j =\
    \ 2l;\n        while (j <= n) {\n            var k = primes(i.toInt - 1) + 2;\n\
    \            while (!isPrime(k)) {\n                k += 2;\n            }\n \
    \           primes += k;\n            i += 1;\n            var f = fibs(fibs.length\
    \ - 1) + fibs(fibs.length - 2);\n            while (f < k) {\n               \
    \ fibs += f;\n                f = fibs(fibs.length - 1) + fibs(fibs.length - 2);\n\
    \            }\n            if (f == k) {\n                j += 1;\n         \
    \   }\n        }\n        return fibs(fibs.length - 1);", "        var fib = new\
    \ Array[Long](n.toInt + 1)\n        fib(0) = 1\n        fib(1) = 1\n        var\
    \ i = 2\n        while (i <= n) {\n            fib(i) = fib(i - 1) + fib(i - 2)\n\
    \            i += 1\n        }\n        var primes = new Array[Boolean](fib(n.toInt).toInt\
    \ + 1)\n        i = 2\n        while (i < primes.length) {\n            primes(i)\
    \ = true\n            i += 1\n        }\n        i = 2\n        while (i < primes.length)\
    \ {\n            if (primes(i)) {\n                var j = i * 2\n           \
    \     while (j < primes.length) {\n                    primes(j) = false\n   \
    \                 j += i\n                }\n            }\n            i += 1\n\
    \        }\n        i = 0\n        while (i < fib.length) {\n            if (primes(fib(i).toInt))\
    \ {\n                return fib(i)\n            }\n            i += 1\n      \
    \  }\n        0", "        var fib = new Array[Long](n.toInt + 1)\n        fib(0)\
    \ = 0\n        fib(1) = 1\n        fib(2) = 2\n        var i = 3\n        var\
    \ count = 2\n        while (count < n) {\n            fib(i) = fib(i - 1) + fib(i\
    \ - 2)\n            if (isPrime(fib(i))) count += 1\n            i += 1\n    \
    \    }\n        fib(i - 1)", "        var i = 0l\n        var j = 1l\n       \
    \ var k = 0l\n        var count = 0l\n        while (count < n) {\n          \
    \  k = i + j\n            if (isPrime(k)) {\n                count += 1\n    \
    \        }\n            i = j\n            j = k\n        }\n        return k",
  "        var fibs = new ArrayBuffer[Long]();\n        fibs += 2;\n        fibs +=\
    \ 3;\n        var i = 2;\n        while (i <= n) {\n            fibs += fibs(i\
    \ - 1) + fibs(i - 2);\n            i += 1;\n        }\n        return fibs(n.toInt\
    \ - 1);", "        var i = 1l\n        var j = 1l\n        var k = 0l\n      \
    \  var count = 0l\n        while (count < n) {\n            k = i + j\n      \
    \      if (isPrime(k)) {\n                count += 1\n            }\n        \
    \    i = j\n            j = k\n        }\n        return k", "        val primes\
    \ = new PrimeSet(1000000)\n        var f1 = 2l\n        var f2 = 3l\n        var\
    \ f3 = 5l\n        var i = 3l\n        while (i < n) {\n            f1 = f2\n\
    \            f2 = f3\n            f3 = f1 + f2\n            i += 1\n        }\n\
    \        return f3", "        var i = 1l\n        var j = 1l\n        var k =\
    \ 1l\n        var count = 0l\n        while (count < n) {\n            k = i +\
    \ j\n            if (k.isPrime) count += 1\n            i = j\n            j =\
    \ k\n        }\n        return k", "        val primes = new PrimeSet(1000000)\n\
    \        var a = 1l\n        var b = 1l\n        var c = 2l\n        var i = 1l\n\
    \        while (i < n) {\n            a = b\n            b = c\n            c\
    \ = a + b\n            if (primes.isPrime(c)) i += 1\n        }\n        return\
    \ c", "        var i = 1l\n        var j = 1l\n        var k = 1l\n        var\
    \ count = 1l\n        while (count < n) {\n            k = i + j\n           \
    \ if (isPrime(k)) count += 1\n            i = j\n            j = k\n        }\n\
    \        k", "        val primes = new PrimeSet(100000)\n        var fib = new\
    \ Fibonacci()\n        var i = 0l\n        var p = 0l\n        while (i < n) {\n\
    \            p = fib.next\n            if (primes.contains(p)) {\n           \
    \     i += 1\n            }\n        }\n        return p", "        val primes\
    \ = new PrimeSet(1000000)\n        var fib = new Fibonacci()\n        var i =\
    \ 0l\n        var p = 0l\n        while (i < n) {\n            p = fib.next\n\
    \            if (primes.contains(p)) {\n                i += 1\n            }\n\
    \        }\n        return p", "        var i = 1l\n        var j = 1l\n     \
    \   var k = 2l\n        var count = 1l\n        while (count < n) {\n        \
    \    k = i + j\n            if (isPrime(k)) {\n                count += 1\n  \
    \          }\n            i = j\n            j = k\n        }\n        return\
    \ k", "        var fib = new Array[Long](n.toInt + 1)\n        fib(0) = 0\n  \
    \      fib(1) = 1\n        fib(2) = 2\n        var i = 3\n        while (i <=\
    \ n) {\n            fib(i) = fib(i - 1) + fib(i - 2)\n            i += 1\n   \
    \     }\n        var j = n\n        while (j >= 0) {\n            if (isPrime(fib(j.toInt)))\
    \ return fib(j.toInt)\n            j -= 1\n        }\n        return -1", "  \
    \      var i = 1l\n        var j = 1l\n        var k = 1l\n        while (k <\
    \ n) {\n            val t = i + j\n            i = j\n            j = t\n    \
    \        if (isPrime(t)) {\n                k += 1\n            }\n        }\n\
    \        return j", "        def primeFibHelper(n : Long, a : Long, b : Long,\
    \ c : Long) : Long = {\n            if (n == 0) c\n            else if (b.isPrime)\
    \ primeFibHelper(n - 1, b, a + b, b)\n            else primeFibHelper(n, b, a\
    \ + b, c)\n        }\n        primeFibHelper(n, 0, 1, 0)", "        var fib =\
    \ new Array[Long](n.toInt + 1)\n        fib(0) = 0\n        fib(1) = 1\n     \
    \   var i = 2\n        while (i <= n) {\n            fib(i) = fib(i - 1) + fib(i\
    \ - 2)\n            i += 1\n        }\n        var result = fib(n.toInt)\n   \
    \     while (!isPrime(result)) {\n            result = fib(n.toInt - 1) + fib(n.toInt\
    \ - 2)\n            n -= 1\n        }\n        return result", "        def primeFib(n\
    \ : Long, a : Long, b : Long, i : Long) : Long = {\n            if (i == n) b\n\
    \            else if (isPrime(b)) primeFib(n, b, a + b, i + 1)\n            else\
    \ primeFib(n, b, a + b, i)\n        }\n        primeFib(n, 2, 3, 1)", "      \
    \  var fib = new Array[Long](n.toInt + 1)\n        fib(0) = 0\n        fib(1)\
    \ = 1\n        fib(2) = 2\n        var i = 3\n        while (i <= n) {\n     \
    \       fib(i) = fib(i - 1) + fib(i - 2)\n            i += 1\n        }\n    \
    \    var result = fib(n.toInt)\n        while (!isPrime(result)) {\n         \
    \   result = fib(n.toInt - 1) + fib(n.toInt - 2)\n            n -= 1\n       \
    \ }\n        return result", "        val primes = new PrimeSet(1000000)\n   \
    \     var f1 = 2l\n        var f2 = 3l\n        var f3 = 5l\n        var i = 3l\n\
    \        while (i < n) {\n            f1 = f2\n            f2 = f3\n         \
    \   f3 = f1 + f2\n            i += 1\n        }\n        return f3", "       \
    \ var i = 1l\n        var j = 1l\n        var k = 1l\n        var count = 1l\n\
    \        while (count < n) {\n            k = i + j\n            if (isPrime(k))\
    \ {\n                count += 1\n            }\n            i = j\n          \
    \  j = k\n        }\n        return k", "        def primeFib(n : Long, a : Long,\
    \ b : Long, count : Long) : Long = {\n            if (count == n) b\n        \
    \    else {\n                val c = a + b\n                if (isPrime(c)) primeFib(n,\
    \ b, c, count + 1)\n                else primeFib(n, b, c, count)\n          \
    \  }\n        }\n        primeFib(n, 0, 1, 1)", "        var f1 : Long = 2l\n\
    \        var f2 : Long = 3l\n        var i : Long = 2l\n        while (i < n)\
    \ {\n            {\n                val f3 : Long = f1 + f2\n                f1\
    \ = f2\n                f2 = f3\n                if (f3.isPrime) i += 1\n    \
    \        }\n        }\n        return f2", "        var i = 1l\n        var j\
    \ = 2l\n        var k = 3l\n        var count = 2l\n        while (count < n)\
    \ {\n            i = j\n            j = k\n            k = i + j\n           \
    \ if (k.isPrime) count += 1\n        }\n        k", "        var fibs = new ArrayBuffer[Long]();\n\
    \        fibs += 2;\n        fibs += 3;\n        var i = 2;\n        while (i\
    \ <= n) {\n            var fib = fibs(i - 1) + fibs(i - 2);\n            if (isPrime(fib))\
    \ {\n                fibs += fib;\n                i += 1;\n            }\n  \
    \      }\n        return fibs(n.toInt - 1);", "        val primes = new PrimeSet(1000000)\n\
    \        var fib = new Fibonacci(1000000)\n        var count = 0l\n        var\
    \ result = 0l\n        while (count < n) {\n            result = fib.next\n  \
    \          if (primes.contains(result)) count += 1\n        }\n        result",
  "        var i = 1l\n        var j = 1l\n        var k = 1l\n        var count =\
    \ 0l\n        while (count < n) {\n            k = i + j\n            i = j\n\
    \            j = k\n            if (isPrime(k)) count += 1\n        }\n      \
    \  return k", "        var count = 0l\n        var f = 1l\n        var s = 1l\n\
    \        var t = 0l\n        while (count < n) {\n            t = f + s\n    \
    \        f = s\n            s = t\n            if (isPrime(t)) count += 1\n  \
    \      }\n        return t", "        val primes = new PrimeSet(1000000)\n   \
    \     var fib = new Fibonacci()\n        var i = 0l\n        var result = 0l\n\
    \        while (i < n) {\n            result = fib.next\n            if (primes.contains(result))\
    \ i += 1\n        }\n        return result", "        val primes = new PrimeSet(1000000)\n\
    \        var p = 2l\n        var f = 1l\n        var f1 = 1l\n        var f2 =\
    \ 1l\n        var i = 1l\n        while (i < n) {\n            f = f1 + f2\n \
    \           if (primes.isPrime(f)) {\n                p = f\n                i\
    \ += 1\n            }\n            f2 = f1\n            f1 = f\n        }\n  \
    \      return p", "        var fibs = new ArrayBuffer[Long]();\n        fibs +=\
    \ 2;\n        fibs += 3;\n        var i = 2;\n        while(i <= n) {\n      \
    \      val next = fibs(i - 1) + fibs(i - 2);\n            if(isPrime(next)) {\n\
    \                fibs += next;\n                i += 1;\n            }\n     \
    \   }\n        return fibs(n.toInt - 1);", "        val primes = new PrimeSet(1000000)\n\
    \        var i = 1l\n        var j = 1l\n        var k = 1l\n        var count\
    \ = 0l\n        while (count < n) {\n            val t = i + j\n            i\
    \ = j\n            j = t\n            if (primes.isPrime(t)) {\n             \
    \   count += 1\n                k = t\n            }\n        }\n        k", " \
    \       val fib = new Array[Long](n.toInt + 1)\n        fib(0) = 1\n        fib(1)\
    \ = 1\n        var i = 2\n        while (i <= n) {\n            fib(i) = fib(i\
    \ - 1) + fib(i - 2)\n            i += 1\n        }\n        val primes = new Array[Boolean](fib(n.toInt).toInt\
    \ + 1)\n        primes(0) = false\n        primes(1) = false\n        i = 2\n\
    \        while (i < primes.length) {\n            primes(i) = true\n         \
    \   i += 1\n        }\n        i = 2\n        while (i < primes.length) {\n  \
    \          if (primes(i)) {\n                var j = i * 2\n                while\
    \ (j < primes.length) {\n                    primes(j) = false\n             \
    \       j += i\n                }\n            }\n            i += 1\n       \
    \ }\n        i = n.toInt\n        while (i >= 0) {\n            if (primes(fib(i).toInt))\
    \ return fib(i)\n            i -= 1\n        }\n        return 0", "        var\
    \ i = 1l\n        var j = 1l\n        var k = 0l\n        var count = 0l\n   \
    \     while (count < n) {\n            k = i + j\n            if (isPrime(k))\
    \ {\n                count += 1\n            }\n            i = j\n          \
    \  j = k\n        }\n        return k", "        var i = 1l\n        var j = 1l\n\
    \        var k = 1l\n        var count = 0l\n        while (count < n) {\n   \
    \         k = i + j\n            if (isPrime(k)) {\n                count += 1\n\
    \            }\n            i = j\n            j = k\n        }\n        return\
    \ k", "        var i = 1l\n        var j = 1l\n        var k = 2l\n        var\
    \ count = 1l\n        while (count < n) {\n            k = i + j\n           \
    \ if (BigInt(k).isProbablePrime(10)) count += 1\n            i = j\n         \
    \   j = k\n        }\n        k", "        def primeFibRec(n : Long, a : Long,\
    \ b : Long, c : Long) : Long = {\n            if (n == 0) c\n            else\
    \ if (b.isPrime) primeFibRec(n - 1, b, a + b, b)\n            else primeFibRec(n,\
    \ b, a + b, c)\n        }\n        primeFibRec(n, 0, 1, 2)", "        var fibs\
    \ = new ArrayBuffer[Long]();\n        fibs += 1;\n        fibs += 2;\n       \
    \ var i = 2;\n        while (i < n) {\n            fibs += fibs(i - 1) + fibs(i\
    \ - 2);\n            i += 1;\n        }\n        return fibs(n.toInt - 1);", " \
    \       var i = 1l\n        var j = 2l\n        var k = 3l\n        var count\
    \ = 2l\n        while (count < n) {\n            i = j\n            j = k\n  \
    \          k = i + j\n            if (k.isPrime) count += 1\n        }\n     \
    \   k", "        var i = 0l\n        var j = 1l\n        var k = 0l\n        var\
    \ count = 0l\n        while (count < n) {\n            k = i + j\n           \
    \ if (isPrime(k)) {\n                count += 1\n            }\n            i\
    \ = j\n            j = k\n        }\n        return k", "        var i = 0l\n\
    \        var j = 1l\n        var k = 0l\n        var count = 0l\n        while\
    \ (count < n) {\n            k = i + j\n            if (isPrime(k)) {\n      \
    \          count += 1\n            }\n            i = j\n            j = k\n \
    \       }\n        return k", "        def primeFib0(n : Long, a : Long, b : Long,\
    \ i : Long) : Long = {\n            if (i == n) b\n            else if (isPrime(b))\
    \ primeFib0(n, b, a + b, i + 1)\n            else primeFib0(n, b, a + b, i)\n\
    \        }\n        primeFib0(n, 1, 2, 1)", "        var i = 1l\n        var j\
    \ = 2l\n        var k = 3l\n        var count = 2l\n        while (count < n)\
    \ {\n            i = j\n            j = k\n            k = i + j\n           \
    \ if (k.isPrime) count += 1\n        }\n        k", "        val primes = new\
    \ PrimeSet(1000000)\n        var fib = new Fibonacci(1000000)\n        var i =\
    \ 0l\n        var p = 0l\n        while (i < n) {\n            p = fib.next\n\
    \            if (primes.contains(p)) i += 1\n        }\n        p", "        var\
    \ i = 1l\n        var j = 1l\n        var k = 0l\n        var count = 0l\n   \
    \     while (count < n) {\n            k = i + j\n            if (isPrime(k))\
    \ {\n                count += 1\n            }\n            i = j\n          \
    \  j = k\n        }\n        return k", "        val primes = new PrimeSet(1000000)\n\
    \        var fib = new Fibonacci()\n        var i = 0l\n        var p = 0l\n \
    \       while (i < n) {\n            p = fib.next\n            if (primes.contains(p))\
    \ i += 1\n        }\n        return p", "        var a = 2l;\n        var b =\
    \ 3l;\n        var i = 2l;\n        while (i < n) {\n            val c = a + b;\n\
    \            a = b;\n            b = c;\n            if (isPrime(b)) {\n     \
    \           i += 1;\n            }\n        }\n        return b;", "        var\
    \ fib = new Array[Long](n.toInt + 1)\n        fib(0) = 0\n        fib(1) = 1\n\
    \        var i = 2\n        while (i <= n) {\n            fib(i) = fib(i - 1)\
    \ + fib(i - 2)\n            i += 1\n        }\n        var result = fib(n.toInt)\n\
    \        while (!isPrime(result)) {\n            result = fib(n.toInt - 1) + fib(n.toInt\
    \ - 2)\n            n -= 1\n        }\n        return result", "        def primeFib(a\
    \ : Long, b : Long, count : Long) : Long = {\n            if (count == n) b\n\
    \            else if (isPrime(b)) primeFib(b, a + b, count + 1)\n            else\
    \ primeFib(b, a + b, count)\n        }\n        primeFib(2, 3, 1)", "        var\
    \ f = new Array[Long](n.toInt + 1)\n        f(0) = 0\n        f(1) = 1\n     \
    \   f(2) = 2\n        var i = 3\n        while (i <= n) {\n            f(i) =\
    \ f(i - 1) + f(i - 2)\n            i += 1\n        }\n        return f(n.toInt)",
  "        var fib : Long = 1l\n        var fib_prev : Long = 1l\n        var count\
    \ : Long = 0l\n        while (count < n) {\n            val temp = fib\n     \
    \       fib += fib_prev\n            fib_prev = temp\n            if (fib.isPrime)\
    \ count += 1\n        }\n        fib", "        val primes = new PrimeSet(1000000)\n\
    \        var i = 1l\n        var j = 1l\n        var k = 1l\n        var count\
    \ = 0l\n        while (count < n) {\n            val next = i + j\n          \
    \  if (primes.isPrime(next)) {\n                count += 1\n                k\
    \ = next\n            }\n            i = j\n            j = next\n        }\n\
    \        k", "        val fib = new Fibonacci()\n        var i = 1l\n        var\
    \ p = fib.get(i)\n        while (i < n) {\n            p = fib.get(i)\n      \
    \      if (p.isPrime) {\n                i += 1\n            }\n        }\n  \
    \      return p", "        var fibs = new ArrayBuffer[Long]();\n        fibs +=\
    \ 2l;\n        fibs += 3l;\n        var i = 2l;\n        while (i < n) {\n   \
    \         fibs += fibs(i.toInt - 1) + fibs(i.toInt - 2);\n            i += 1l;\n\
    \        }\n        return fibs(n.toInt - 1);", "        var fibs = new ArrayBuffer[Long]();\n\
    \        fibs += 2;\n        fibs += 3;\n        var i = 2;\n        while (i\
    \ <= n) {\n            var fib = fibs(i - 1) + fibs(i - 2);\n            if (fib.isPrime)\
    \ {\n                fibs += fib;\n                i += 1;\n            }\n  \
    \      }\n        return fibs(n.toInt - 1);", "        var i = 1l\n        var\
    \ j = 1l\n        var k = 1l\n        var count = 1l\n        while (count < n)\
    \ {\n            k = i + j\n            if (isPrime(k)) {\n                count\
    \ += 1\n            }\n            i = j\n            j = k\n        }\n     \
    \   return k", "        def isPrime(n : Long) : Boolean = {\n            if (n\
    \ <= 1) return false\n            if (n == 2) return true\n            if (n %\
    \ 2 == 0) return false\n            val sqrtN = math.sqrt(n).toLong\n        \
    \    var i = 3l\n            while (i <= sqrtN) {\n                if (n % i ==\
    \ 0) return false\n                i += 2\n            }\n            return true\n\
    \        }\n        var fib = 1l\n        var fibPrev = 1l\n        var count\
    \ = 1l\n        while (count < n) {\n            val temp = fib\n            fib\
    \ += fibPrev\n            fibPrev = temp\n            if (isPrime(fib)) count\
    \ += 1\n        }\n        return fib", "        var f1 = 2l;\n        var f2\
    \ = 3l;\n        var f3 = 5l;\n        var i = 3l;\n        while (i < n) {\n\
    \            f1 = f2;\n            f2 = f3;\n            f3 = f1 + f2;\n     \
    \       i = i + 1;\n        }\n        return f3;", "        var i = 1l\n    \
    \    var j = 2l\n        var k = 3l\n        var c = 0l\n        while (c < n)\
    \ {\n            if (isPrime(k)) {\n                c += 1\n            }\n  \
    \          i = j\n            j = k\n            k = i + j\n        }\n      \
    \  return k", "        var fibs = new ArrayBuffer[Long]()\n        fibs += 2\n\
    \        fibs += 3\n        var i = 2\n        while (i <= n) {\n            fibs\
    \ += fibs(i - 1) + fibs(i - 2)\n            if (fibs(i) % 2 == 0) {\n        \
    \        fibs.remove(i)\n            } else {\n                i += 1\n      \
    \      }\n        }\n        return fibs(n - 1)", "        val primes = new PrimeSet(1000000)\n\
    \        var fib = new Fibonacci()\n        var i = 0l\n        var p = 0l\n \
    \       while (i < n) {\n            p = fib.next\n            if (primes.contains(p))\
    \ i += 1\n        }\n        return p", "        val primes = new PrimeSet(1000000)\n\
    \        var i = 1l\n        var j = 1l\n        var k = 1l\n        var count\
    \ = 0l\n        while (count < n) {\n            val t = i + j\n            if\
    \ (primes.isPrime(t)) {\n                count += 1\n                k = t\n \
    \           }\n            i = j\n            j = t\n        }\n        k", " \
    \       var fibs = new ArrayBuffer[Long]();\n        fibs += 2;\n        fibs\
    \ += 3;\n        var i = 2;\n        while (i <= n) {\n            val fib = fibs(i\
    \ - 1) + fibs(i - 2);\n            if (isPrime(fib)) {\n                fibs +=\
    \ fib;\n                i += 1;\n            }\n        }\n        return fibs(n.toInt\
    \ - 1);", "        var a = 2l;\n        var b = 3l;\n        var c = 5l;\n   \
    \     var i = 3l;\n        while (i < n) {\n            a = b;\n            b\
    \ = c;\n            c = a + b;\n            i = i + 1;\n        }\n        return\
    \ c;", "        def primeFib(n : Long, a : Long, b : Long, i : Long) : Long =\
    \ {\n            if (i == n) b\n            else if (isPrime(b)) primeFib(n, b,\
    \ a + b, i + 1)\n            else primeFib(n, b, a + b, i)\n        }\n      \
    \  primeFib(n, 1, 2, 1)", "        val primes = new PrimeSet(1000000)\n      \
    \  var i = 1l\n        var j = 1l\n        var k = 1l\n        var count = 0l\n\
    \        while (count < n) {\n            val fib = i + j\n            if (primes.isPrime(fib))\
    \ {\n                count += 1\n                k = fib\n            }\n    \
    \        i = j\n            j = fib\n        }\n        k", "        var a = 2l;\n\
    \        var b = 3l;\n        var c = 5l;\n        var i = 3l;\n        while\
    \ (i < n) {\n            a = b;\n            b = c;\n            c = a + b;\n\
    \            i = i + 1;\n        }\n        return c;", "        var i = 1l\n\
    \        var j = 1l\n        var k = 1l\n        var count = 0l\n        while\
    \ (count < n) {\n            k = i + j\n            if (isPrime(k)) count += 1\n\
    \            i = j\n            j = k\n        }\n        return k", "       \
    \ var fibs = new ArrayBuffer[Long]();\n        fibs += 2l;\n        fibs += 3l;\n\
    \        var i = 2l;\n        var fib = 0l;\n        while (i <= n) {\n      \
    \      fib = fibs(i.toInt - 2) + fibs(i.toInt - 1);\n            if (isPrime(fib))\
    \ {\n                fibs += fib;\n                i += 1;\n            }\n  \
    \      }\n        return fib;", "        var fib = new Fibonacci()\n        var\
    \ i = 0l\n        var f = 0l\n        while (i < n) {\n            f = fib.next\n\
    \            if (f.isPrime) i += 1\n        }\n        return f", "        def\
    \ primeFib(n : Long, a : Long, b : Long, count : Long) : Long = {\n          \
    \  if (count == n) b\n            else if (isPrime(b)) primeFib(n, b, a + b, count\
    \ + 1)\n            else primeFib(n, b, a + b, count)\n        }\n        primeFib(n,\
    \ 1, 2, 1)", "        var i = 1l\n        var fib = 1l\n        var fib_prev =\
    \ 1l\n        while (i < n) {\n            val fib_next = fib + fib_prev\n   \
    \         fib_prev = fib\n            fib = fib_next\n            if (isPrime(fib))\
    \ i += 1\n        }\n        fib", "        var a = 2l;\n        var b = 3l;\n\
    \        var c = 5l;\n        var i = 3l;\n        while (i < n) {\n         \
    \   a = b;\n            b = c;\n            c = a + b;\n            i = i + 1;\n\
    \        }\n        return c;", "        var a = 2l;\n        var b = 3l;\n  \
    \      var c = 5l;\n        var i = 3l;\n        while (i < n) {\n           \
    \ a = b;\n            b = c;\n            c = a + b;\n            i = i + 1;\n\
    \        }\n        return c;", "        var fibs = new ArrayBuffer[Long]();\n\
    \        fibs += 2l;\n        fibs += 3l;\n        var i = 2l;\n        while\
    \ (i <= n) {\n            var fib = fibs(i.toInt - 1) + fibs(i.toInt - 2);\n \
    \           if (isPrime(fib)) {\n                fibs += fib;\n              \
    \  i += 1l;\n            }\n        }\n        return fibs(n.toInt - 1);", " \
    \       def primeFib(n : Long, a : Long, b : Long, c : Long) : Long = {\n    \
    \        if (n == 1) a\n            else if (n == 2) b\n            else if (n\
    \ == 3) c\n            else {\n                val d = a + b + c\n           \
    \     if (isPrime(d)) primeFib(n - 1, b, c, d)\n                else primeFib(n,\
    \ b, c, d)\n            }\n        }\n        primeFib(n, 2, 3, 5)", "       \
    \ var i = 1l\n        var j = 1l\n        var k = 0l\n        var count = 0l\n\
    \        while (count < n) {\n            k = i + j\n            if (k.isPrime)\
    \ {\n                count += 1\n            }\n            i = j\n          \
    \  j = k\n        }\n        return k", "        def primeFib(n : Long, a : Long,\
    \ b : Long, count : Long) : Long = {\n            if (count == n) b\n        \
    \    else {\n                val c = a + b\n                if (Library.isPrime(c))\
    \ primeFib(n, b, c, count + 1)\n                else primeFib(n, b, c, count)\n\
    \            }\n        }\n        primeFib(n, 1, 2, 1)", "        var fibs =\
    \ new ArrayBuffer[Long]();\n        fibs += 2l;\n        fibs += 3l;\n       \
    \ var i = 2l;\n        while (fibs.length < n) {\n            val next = fibs(i.toInt\
    \ - 1) + fibs(i.toInt - 2);\n            if (next.isPrime) {\n               \
    \ fibs += next;\n            }\n            i += 1;\n        }\n        fibs(n.toInt\
    \ - 1);", "        var cnt = 0l\n        var i = 1l\n        var fib = 1l\n  \
    \      while (cnt < n) {\n            if (isPrime(fib)) {\n                cnt\
    \ += 1\n                if (cnt == n) return fib\n            }\n            i\
    \ += 1\n            fib = fibonacci(i)\n        }\n        return fib", "    \
    \    var a = 2l;\n        var b = 3l;\n        var c = 5l;\n        var i = 3l;\n\
    \        while (i < n) {\n            a = b;\n            b = c;\n           \
    \ c = a + b;\n            i = i + 1;\n        }\n        return c;", "       \
    \ var a : Long = 2;\n        var b : Long = 3;\n        var c : Long = 5;\n  \
    \      var i : Long = 1;\n        while (i < n) {\n            a = b;\n      \
    \      b = c;\n            c = a + b;\n            while (!(isPrime(c))) {\n \
    \               a = b;\n                b = c;\n                c = a + b;\n \
    \           }\n            i = i + 1;\n        }\n        return c;", "      \
    \  var i = 1l\n        var j = 2l\n        var k = 3l\n        var c = 1l\n  \
    \      while (c < n) {\n            if (isPrime(k)) {\n                c += 1\n\
    \            }\n            i = j\n            j = k\n            k = i + j\n\
    \        }\n        return k", "        def primeFibIter(a : Long, b : Long, n\
    \ : Long, count : Long) : Long = {\n            if (count == n) b\n          \
    \  else {\n                val c = a + b\n                if (isPrime(c)) primeFibIter(b,\
    \ c, n, count + 1)\n                else primeFibIter(b, c, n, count)\n      \
    \      }\n        }\n        primeFibIter(1, 2, n, 1)", "        val primes =\
    \ new PrimeSet(1000000)\n        var i = 0l\n        var j = 1l\n        var k\
    \ = 0l\n        var count = 0l\n        while (count < n) {\n            k = i\
    \ + j\n            i = j\n            j = k\n            if (primes.isPrime(k))\
    \ count += 1\n        }\n        return k", "        var fib = new Array[Long](n.toInt\
    \ + 1)\n        fib(0) = 0\n        fib(1) = 1\n        var i = 2\n        while\
    \ (i <= n) {\n            fib(i) = fib(i - 1) + fib(i - 2)\n            i += 1\n\
    \        }\n        var primes = new Array[Boolean](fib(n.toInt).toInt + 1)\n\
    \        i = 2\n        while (i < primes.length) {\n            primes(i) = true\n\
    \            i += 1\n        }\n        i = 2\n        while (i < primes.length)\
    \ {\n            if (primes(i)) {\n                var j = i * 2\n           \
    \     while (j < primes.length) {\n                    primes(j) = false\n   \
    \                 j += i\n                }\n            }\n            i += 1\n\
    \        }\n        i = n.toInt\n        while (i >= 0) {\n            if (primes(fib(i).toInt))\
    \ return fib(i)\n            i -= 1\n        }\n        0", "        var fibs\
    \ = new ArrayBuffer[Long]();\n        fibs += 1l;\n        fibs += 2l;\n     \
    \   var i = 2l;\n        while (fibs.length < n) {\n            fibs += fibs(i.toInt\
    \ - 1) + fibs(i.toInt - 2);\n            i += 1l;\n        }\n        var primes\
    \ = new ArrayBuffer[Long]();\n        primes += 2l;\n        var j = 3l;\n   \
    \     while (primes.length < n) {\n            var isPrime = true;\n         \
    \   for (p <- primes) {\n                if (j % p == 0l) {\n                \
    \    isPrime = false;\n                    break;\n                }\n       \
    \     }\n            if (isPrime) primes += j;\n            j += 2l;\n       \
    \ }\n        var k = 0;\n        while (k < fibs.length) {\n            if (primes.contains(fibs(k)))\
    \ return fibs(k);\n            k += 1;\n        }\n        return -1l;", "   \
    \     def isPrime(n : Long) : Boolean = {\n            if (n == 1) return false\n\
    \            if (n == 2) return true\n            if (n % 2 == 0) return false\n\
    \            val sqrtN = sqrt(n).toLong\n            for (i <- 3l to sqrtN by\
    \ 2) {\n                if (n % i == 0) return false\n            }\n        \
    \    return true\n        }\n        var fib = 1l\n        var fib1 = 1l\n   \
    \     var fib2 = 1l\n        var count = 1l\n        while (count < n) {\n   \
    \         fib = fib1 + fib2\n            fib2 = fib1\n            fib1 = fib\n\
    \            if (isPrime(fib)) count += 1\n        }\n        return fib", " \
    \       var a = 2l;\n        var b = 3l;\n        var c = 5l;\n        var i =\
    \ 3l;\n        while (i <= n) {\n            a = b;\n            b = c;\n    \
    \        c = a + b;\n            if (isPrime(c)) {\n                i += 1;\n\
    \            }\n        }\n        return c;", "        var i = 1l\n        var\
    \ j = 1l\n        var k = 1l\n        var count = 1l\n        while (count < n)\
    \ {\n            k = i + j\n            if (k.isPrime) {\n                count\
    \ += 1\n            }\n            i = j\n            j = k\n        }\n     \
    \   k", "        var i = 1l\n        var j = 1l\n        var k = 1l\n        var\
    \ c = 0l\n        while (c < n) {\n            k = i + j\n            if (k.isPrime)\
    \ {\n                c += 1\n            }\n            i = j\n            j =\
    \ k\n        }\n        k", "        val primes = new PrimeSet(1000000)\n    \
    \    var i = 1l\n        var j = 1l\n        var k = 1l\n        var count = 0l\n\
    \        while (count < n) {\n            val sum = i + j\n            if (primes.isPrime(sum))\
    \ {\n                count += 1\n                k = sum\n            }\n    \
    \        i = j\n            j = sum\n        }\n        k", "        val primes\
    \ = new PrimeSet(1000000)\n        var a = 2l\n        var b = 3l\n        var\
    \ c = 5l\n        var i = 1l\n        while (i < n) {\n            a = b\n   \
    \         b = c\n            c = a + b\n            i += 1\n        }\n      \
    \  return b", "        var p = 2l\n        var f = 1l\n        var f1 = 1l\n \
    \       var f2 = 2l\n        var i = 1l\n        while (i < n) {\n           \
    \ f = f1 + f2\n            f1 = f2\n            f2 = f\n            if (f.isPrime)\
    \ {\n                p = f\n                i += 1\n            }\n        }\n\
    \        return p", "        var fibs = new ArrayBuffer[Long]();\n        fibs\
    \ += 2l;\n        fibs += 3l;\n        var i = 2l;\n        while (i < n) {\n\
    \            fibs += fibs(i.toInt - 1) + fibs(i.toInt - 2);\n            i +=\
    \ 1l;\n        }\n        fibs(n.toInt - 1);", "        var a = 2l;\n        var\
    \ b = 3l;\n        var c = 5l;\n        var i = 3l;\n        while (i < n) {\n\
    \            a = b;\n            b = c;\n            c = a + b;\n            i\
    \ = i + 1;\n        }\n        return c;", "        val primes = new PrimeSet(1000000)\n\
    \        var i = 1l\n        var j = 1l\n        var k = 2l\n        var count\
    \ = 0l\n        while (count < n) {\n            if (primes.contains(k)) {\n \
    \               count += 1\n            }\n            val t = k\n           \
    \ k = i + j\n            i = j\n            j = t\n        }\n        k", "  \
    \      val primes = new PrimeSet(1000000)\n        var count = 0l\n        var\
    \ i = 1l\n        while (count < n) {\n            if (primes.isPrime(i) && primes.isPrime(i\
    \ + 2)) {\n                count += 1\n                if (count == n) return\
    \ i\n            }\n            i += 1\n        }\n        return 0", "      \
    \  var fibs = new ArrayBuffer[Long]();\n        fibs += 2l;\n        fibs += 3l;\n\
    \        var i = 2l;\n        while (i < n) {\n            fibs += fibs(i.toInt\
    \ - 1) + fibs(i.toInt - 2);\n            i += 1l;\n        }\n        return fibs(n.toInt\
    \ - 1);", "        var fibs = new ArrayBuffer[Long]();\n        fibs += 2l;\n\
    \        fibs += 3l;\n        var i = 2l;\n        while (i <= n) {\n        \
    \    var fib = fibs(i.toInt - 1) + fibs(i.toInt - 2);\n            if (isPrime(fib))\
    \ {\n                fibs += fib;\n                i += 1l;\n            }\n \
    \       }\n        return fibs(n.toInt - 1);", "        var i = 2l;\n        var\
    \ f1 = 2l;\n        var f2 = 3l;\n        var f = 0l;\n        while (i <= n)\
    \ {\n            f = f1 + f2;\n            f1 = f2;\n            f2 = f;\n   \
    \         if (f.isPrime) i += 1;\n        }\n        return f;", "        var\
    \ primes = new ArrayBuffer[Long]()\n        primes += 2l\n        primes += 3l\n\
    \        var fibs = new ArrayBuffer[Long]()\n        fibs += 2l\n        fibs\
    \ += 3l\n        var i = 2l\n        while (primes.length < n) {\n           \
    \ i += 1\n            if (isPrime(i)) {\n                primes += i\n       \
    \         if (isFib(i, fibs)) fibs += i\n            }\n        }\n        return\
    \ fibs(n.toInt - 1)", "        var fibs = new ArrayBuffer[Long]();\n        fibs\
    \ += 2l;\n        fibs += 3l;\n        var i = 2l;\n        while (i < n) {\n\
    \            fibs += fibs(i.toInt - 1) + fibs(i.toInt - 2);\n            i +=\
    \ 1l;\n        }\n        var j = 0;\n        while (j < fibs.length) {\n    \
    \        if (isPrime(fibs(j))) {\n                return fibs(j);\n          \
    \  }\n            j += 1;\n        }\n        return 0l;", "        var fibs =\
    \ new ArrayBuffer[Long]();\n        fibs += 2l;\n        fibs += 3l;\n       \
    \ var i = 2l;\n        while (i < n) {\n            fibs += fibs(i.toInt - 1)\
    \ + fibs(i.toInt - 2);\n            i += 1l;\n        }\n        return fibs(n.toInt\
    \ - 1);", "        var i = 1l\n        var j = 1l\n        var k = 1l\n      \
    \  var count = 0l\n        while (count < n) {\n            k = i + j\n      \
    \      if (isPrime(k)) {\n                count += 1\n            }\n        \
    \    i = j\n            j = k\n        }\n        return k", "        val primes\
    \ = new PrimeSet(1000000)\n        var a = 2l\n        var b = 3l\n        var\
    \ c = 5l\n        var i = 3l\n        while (i < n) {\n            a = b\n   \
    \         b = c\n            c = a + b\n            i += 1\n        }\n      \
    \  return c", "        def primeFib(n : Long, a : Long, b : Long, i : Long) :\
    \ Long = {\n            if (i == n) b\n            else if (isPrime(b)) primeFib(n,\
    \ b, a + b, i + 1)\n            else primeFib(n, b, a + b, i)\n        }\n   \
    \     primeFib(n, 2, 3, 1)", "        var fibs = new ArrayBuffer[Long]();\n  \
    \      fibs += 2;\n        fibs += 3;\n        var i = 2;\n        var j = 0;\n\
    \        while (i <= n) {\n            val fib = fibs(j) + fibs(j + 1);\n    \
    \        if (isPrime(fib)) {\n                fibs += fib;\n                i\
    \ += 1;\n            }\n            j += 1;\n        }\n        return fibs(n.toInt\
    \ - 1);", "        var fibs = new ArrayBuffer[Long]();\n        fibs += 2;\n \
    \       fibs += 3;\n        var i = 2;\n        while (i <= n) {\n           \
    \ val next = fibs(i - 1) + fibs(i - 2);\n            if (isPrime(next)) {\n  \
    \              fibs += next;\n                i += 1;\n            }\n       \
    \ }\n        return fibs(n.toInt - 1);", "        var fib : Long = 0\n       \
    \ var fib1 : Long = 1\n        var fib2 : Long = 1\n        var count : Long =\
    \ 0\n        while (count < n) {\n            fib = fib1 + fib2\n            fib2\
    \ = fib1\n            fib1 = fib\n            if (fib.isPrime) count += 1\n  \
    \      }\n        return fib", "        var fib = new Fibonacci()\n        var\
    \ i = 0l\n        var f = 0l\n        while (i < n) {\n            f = fib.next()\n\
    \            if (f.isPrime()) i += 1\n        }\n        return f", "        var\
    \ fib = new Fibonacci()\n        var prime = new Prime()\n        var i = 0l\n\
    \        var result = 0l\n        while (i < n) {\n            result = fib.next\n\
    \            if (prime.isPrime(result)) i += 1\n        }\n        return result",
  "        var a : Long = 2l;\n        var b : Long = 3l;\n        var c : Long =\
    \ 5l;\n        var i : Long = 3l;\n        while (i < n) {\n            a = b;\n\
    \            b = c;\n            c = a + b;\n            i = i + 1l;\n       \
    \ }\n        return c;", "        var f1 : Long = 2l\n        var f2 : Long =\
    \ 3l\n        var f3 : Long = 5l\n        var i : Long = 3l\n        while (i\
    \ < n) {\n            f1 = f2\n            f2 = f3\n            f3 = f1 + f2\n\
    \            while (f3 % 2 == 0) {\n                f3 = f3 / 2\n            }\n\
    \            while (f3 % 3 == 0) {\n                f3 = f3 / 3\n            }\n\
    \            while (f3 % 5 == 0) {\n                f3 = f3 / 5\n            }\n\
    \            if (f3 != 1) {\n                i = i + 1\n            }\n      \
    \  }\n        return f3", "        var a = 2l;\n        var b = 3l;\n        var\
    \ c = 5l;\n        var i = 3l;\n        while (i < n) {\n            a = b;\n\
    \            b = c;\n            c = a + b;\n            i = i + 1;\n        }\n\
    \        return c;", "        var count = 0l\n        var i = 0l\n        while\
    \ (count < n) {\n            i += 1\n            if (isPrime(fib(i))) {\n    \
    \            count += 1\n            }\n        }\n        return fib(i)", " \
    \       def primeFib(n : Long, a : Long, b : Long, count : Long) : Long = {\n\
    \            if (count == n) b\n            else if (isPrime(b)) primeFib(n, b,\
    \ a + b, count + 1)\n            else primeFib(n, b, a + b, count)\n        }\n\
    \        primeFib(n, 1, 2, 1)", "        var f : Long = 1\n        var g : Long\
    \ = 0\n        var i : Long = 0\n        while (i < n) {\n            {\n    \
    \            val h : Long = f + g\n                f = g\n                g =\
    \ h\n                if (isPrime(g)) i += 1\n            }\n        }\n      \
    \  return g", "        var fibs = new ArrayBuffer[Long]();\n        fibs += 2;\n\
    \        fibs += 3;\n        var i = 2;\n        while (i <= n) {\n          \
    \  val fib = fibs(i - 1) + fibs(i - 2);\n            if (isPrime(fib)) {\n   \
    \             fibs += fib;\n                i += 1;\n            }\n        }\n\
    \        return fibs(n.toInt - 1);", "        def primeFib(n : Long, a : Long,\
    \ b : Long, i : Long) : Long = {\n            if (i == n) b\n            else\
    \ {\n                val c = a + b\n                if (BigInt(c).isProbablePrime(10))\
    \ primeFib(n, b, c, i + 1)\n                else primeFib(n, b, c, i)\n      \
    \      }\n        }\n        primeFib(n, 1, 2, 1)", "        var fib = new Fibonacci()\n\
    \        var prime = new Prime()\n        var i = 0l\n        var f = 0l\n   \
    \     while (i < n) {\n            f = fib.next()\n            if (prime.isPrime(f))\
    \ i += 1\n        }\n        return f", "        var f1 : Long = 2\n        var\
    \ f2 : Long = 3\n        var count : Long = 2\n        while (count < n) {\n \
    \           var f3 : Long = f1 + f2\n            f1 = f2\n            f2 = f3\n\
    \            if (f3.isPrime) {\n                count += 1\n            }\n  \
    \      }\n        return f2", "        var fib = new Array[Long](n.toInt + 1)\n\
    \        fib(0) = 1\n        fib(1) = 1\n        var i = 2\n        while (i <=\
    \ n) {\n            fib(i) = fib(i - 1) + fib(i - 2)\n            i += 1\n   \
    \     }\n        var result = fib(n.toInt)\n        while (!isPrime(result)) {\n\
    \            result = fib(n.toInt - 1) + fib(n.toInt - 2)\n            n -= 1\n\
    \        }\n        return result", "        def primeFib(n : Long, a : Long,\
    \ b : Long, c : Long) : Long = {\n            if (n == 1) a\n            else\
    \ if (n == 2) b\n            else if (n == 3) c\n            else {\n        \
    \        val d = a + b + c\n                if (isPrime(d)) primeFib(n - 1, b,\
    \ c, d)\n                else primeFib(n, b, c, d)\n            }\n        }\n\
    \        primeFib(n, 2, 3, 5)", "        var a : Long = 2l;\n        var b : Long\
    \ = 3l;\n        var c : Long = 5l;\n        var i : Long = 3l;\n        while\
    \ (i < n) {\n            a = b;\n            b = c;\n            c = a + b;\n\
    \            i = i + 1l;\n        }\n        return c;", "        var f1 : Long\
    \ = 2l\n        var f2 : Long = 3l\n        var f3 : Long = 5l\n        var i\
    \ : Long = 3l\n        while (i < n) {\n            f1 = f2\n            f2 =\
    \ f3\n            f3 = f1 + f2\n            if (f3.isPrime) {\n              \
    \  i += 1\n            }\n        }\n        return f3", "        var f1 : Long\
    \ = 2l\n        var f2 : Long = 3l\n        var f3 : Long = 5l\n        var i\
    \ : Long = 3l\n        while (i < n) {\n            f1 = f2\n            f2 =\
    \ f3\n            f3 = f1 + f2\n            while (!(f3.isPrime)) {\n        \
    \        f1 = f2\n                f2 = f3\n                f3 = f1 + f2\n    \
    \        }\n            i = i + 1\n        }\n        return f3", "        var\
    \ fib = new Fibonacci()\n        var prime = new Prime()\n        var i = 1l\n\
    \        var result = 0l\n        while (i <= n) {\n            result = fib.next\n\
    \            if (prime.isPrime(result)) {\n                i += 1\n          \
    \  }\n        }\n        return result", "        def primeFib(n : Long, a : Long,\
    \ b : Long, count : Long) : Long = {\n            if (count == n) b\n        \
    \    else if (isPrime(b)) primeFib(n, b, a + b, count + 1)\n            else primeFib(n,\
    \ b, a + b, count)\n        }\n        primeFib(n, 1, 2, 1)", "        val primes\
    \ = new PrimeSet(1000000)\n        var i = 1l\n        var j = 1l\n        var\
    \ k = 1l\n        var count = 0l\n        while (count < n) {\n            val\
    \ sum = i + j\n            if (primes.contains(sum)) {\n                count\
    \ += 1\n                k = sum\n            }\n            i = j\n          \
    \  j = sum\n        }\n        k", "        var fibs = new ArrayBuffer[Long]();\n\
    \        fibs += 2;\n        fibs += 3;\n        var i = 2;\n        while (i\
    \ <= n) {\n            val fib = fibs(i - 1) + fibs(i - 2);\n            if (isPrime(fib))\
    \ {\n                fibs += fib;\n                i += 1;\n            }\n  \
    \      }\n        return fibs(n.toInt - 1);", "        def primeFib(n : Long,\
    \ a : Long, b : Long, c : Long) : Long = {\n            if (n == 1) c\n      \
    \      else if (n == 2) b\n            else if (n == 3) a\n            else if\
    \ (isPrime(a + b)) primeFib(n - 1, b, a + b, a + b)\n            else primeFib(n,\
    \ b, a + b, c)\n        }\n        primeFib(n, 2, 3, 2)", "        var fibs =\
    \ new ArrayBuffer[Long]();\n        fibs += 2;\n        fibs += 3;\n        var\
    \ i = 2;\n        while (i <= n) {\n            var fib = fibs(i - 1) + fibs(i\
    \ - 2);\n            if (isPrime(fib)) {\n                fibs += fib;\n     \
    \           i += 1;\n            }\n        }\n        return fibs(n.toInt - 1);",
  "        val primes = new PrimeSet(1000000)\n        var i = 2l\n        var j =\
    \ 3l\n        var k = 5l\n        var count = 3l\n        while (count < n) {\n\
    \            val t = k\n            k = i + j\n            i = j\n           \
    \ j = t\n            if (primes.isPrime(k)) {\n                count += 1\n  \
    \          }\n        }\n        return k", "        def primeFib(n : Long, a\
    \ : Long, b : Long, i : Long) : Long = {\n            if (i == n) b\n        \
    \    else {\n                val c = a + b\n                if (isPrime(c)) primeFib(n,\
    \ b, c, i + 1)\n                else primeFib(n, b, c, i)\n            }\n   \
    \     }\n        primeFib(n, 0, 1, 1)", "        var fib = new Array[Long](n.toInt)\n\
    \        fib(0) = 2\n        fib(1) = 3\n        var i = 2\n        while (i <\
    \ n) {\n            fib(i) = fib(i - 1) + fib(i - 2)\n            i += 1\n   \
    \     }\n        var j = n - 1\n        while (j >= 0) {\n            if (isPrime(fib(j)))\
    \ return fib(j)\n            j -= 1\n        }\n        return 0", "        var\
    \ fibs = new ArrayBuffer[Long]();\n        fibs += 2;\n        fibs += 3;\n  \
    \      var i = 2;\n        while (i <= n) {\n            var fib = fibs(i - 1)\
    \ + fibs(i - 2);\n            if (isPrime(fib)) {\n                fibs += fib;\n\
    \                i += 1;\n            }\n        }\n        return fibs(n.toInt\
    \ - 1);", "        val primes = new PrimeSet(1000000)\n        var i = 1l\n  \
    \      var j = 1l\n        var k = 1l\n        var count = 0l\n        while (count\
    \ < n) {\n            val next = i + j\n            if (primes.isPrime(next))\
    \ {\n                count += 1\n                k = next\n            }\n   \
    \         i = j\n            j = next\n        }\n        k", "        var fib\
    \ = new Array[Long](n.toInt + 1)\n        fib(0) = 0\n        fib(1) = 1\n   \
    \     fib(2) = 2\n        var i = 3\n        while (i <= n) {\n            fib(i)\
    \ = fib(i - 1) + fib(i - 2)\n            i += 1\n        }\n        var count\
    \ = 0\n        var j = 2\n        while (count < n) {\n            if (isPrime(fib(j)))\
    \ {\n                count += 1\n            }\n            j += 1\n        }\n\
    \        return fib(j - 1)", "        var a = 2l;\n        var b = 3l;\n     \
    \   var c = 5l;\n        var i = 3l;\n        while (i < n) {\n            a =\
    \ b;\n            b = c;\n            c = a + b;\n            i = i + 1;\n   \
    \     }\n        return c;", "        def primeFib(n : Long, a : Long, b : Long,\
    \ c : Long) : Long = {\n            if (n == 1) {\n                a\n       \
    \     } else if (n == 2) {\n                b\n            } else {\n        \
    \        if (isPrime(c)) {\n                    primeFib(n - 1, b, c, a + b +\
    \ c)\n                } else {\n                    primeFib(n, a, b, c + a +\
    \ b)\n                }\n            }\n        }\n        primeFib(n, 2, 3, 5)",
  "        var fib = new Fibonacci()\n        var i = 0l\n        while (i < n) {\n\
    \            val f = fib.next()\n            if (Library.isPrime(f)) i += 1\n\
    \            if (i == n) return f\n        }\n        return 0l", "        var\
    \ a = 2l;\n        var b = 3l;\n        var c = 5l;\n        var i = 3l;\n   \
    \     while (i < n) {\n            a = b;\n            b = c;\n            c =\
    \ a + b;\n            i = i + 1;\n        }\n        return c;", "        def\
    \ primeFib(n : Long, a : Long, b : Long, count : Long) : Long = {\n          \
    \  if (count == n) b\n            else if (isPrime(b)) primeFib(n, b, a + b, count\
    \ + 1)\n            else primeFib(n, b, a + b, count)\n        }\n        primeFib(n,\
    \ 1, 2, 1)", "        val primes = new PrimeSet(100000)\n        var fib = new\
    \ Fibonacci()\n        var i = 0l\n        while (i < n) {\n            val f\
    \ = fib.next\n            if (primes.contains(f)) i += 1\n        }\n        fib.current",
  "        var a = 2l;\n        var b = 3l;\n        var c = 5l;\n        var i =\
    \ 3l;\n        while (i < n) {\n            a = b;\n            b = c;\n     \
    \       c = a + b;\n            i = i + 1;\n        }\n        return c;", " \
    \       def primeFib(n : Long, a : Long, b : Long, count : Long) : Long = {\n\
    \            if (count == n) b\n            else {\n                val c = a\
    \ + b\n                if (isPrime(c)) primeFib(n, b, c, count + 1)\n        \
    \        else primeFib(n, b, c, count)\n            }\n        }\n        primeFib(n,\
    \ 1, 2, 1)", "        var fib = new Fibonacci()\n        var prime = new Prime()\n\
    \        var i = 1l\n        var p = 0l\n        while (i <= n) {\n          \
    \  p = fib.next\n            if (prime.isPrime(p)) i += 1\n        }\n       \
    \ return p", "        var fibs = new ArrayBuffer[Long]();\n        fibs += 2l;\n\
    \        fibs += 3l;\n        var i = 2l;\n        while (i < n) {\n         \
    \   var next = fibs(i.toInt - 1) + fibs(i.toInt - 2);\n            if (isPrime(next))\
    \ {\n                fibs += next;\n                i += 1l;\n            }\n\
    \        }\n        return fibs(n.toInt - 1);", "        var count = 0l\n    \
    \    var fib = 1l\n        var fib1 = 1l\n        var fib2 = 2l\n        while\
    \ (count < n) {\n            fib = fib1 + fib2\n            fib1 = fib2\n    \
    \        fib2 = fib\n            if (fib.isPrime) {\n                count +=\
    \ 1\n            }\n        }\n        return fib", "        var fib = new Fibonacci\n\
    \        var i = 0l\n        var result = 0l\n        while (i < n) {\n      \
    \      result = fib.next\n            if (isPrime(result)) i += 1\n        }\n\
    \        return result", "        var fib = new Array[Long](n.toInt + 1)\n   \
    \     fib(0) = 1\n        fib(1) = 1\n        var i = 2\n        while (i <= n)\
    \ {\n            fib(i) = fib(i - 1) + fib(i - 2)\n            i += 1\n      \
    \  }\n        var result = fib(n.toInt)\n        while (!isPrime(result)) {\n\
    \            result += 1\n        }\n        return result", "        def primeFibHelper(n\
    \ : Long, a : Long, b : Long, count : Long) : Long = {\n            if (count\
    \ == n) b\n            else if (isPrime(b)) primeFibHelper(n, b, a + b, count\
    \ + 1)\n            else primeFibHelper(n, b, a + b, count)\n        }\n     \
    \   primeFibHelper(n, 1, 2, 1)", "        var fibs = new ArrayBuffer[Long]();\n\
    \        fibs += 2l;\n        fibs += 3l;\n        var i = 2l;\n        var j\
    \ = 0l;\n        while (i < n) {\n            val next = fibs(j.toInt) + fibs(j.toInt\
    \ + 1);\n            if (next.isPrime) {\n                fibs += next;\n    \
    \            i += 1;\n            }\n            j += 1;\n        }\n        fibs(n.toInt\
    \ - 1);", "        var fib = new Array[Long](n.toInt + 1)\n        fib(0) = 0\n\
    \        fib(1) = 1\n        var i = 2\n        while (i <= n) {\n           \
    \ fib(i) = fib(i - 1) + fib(i - 2)\n            i += 1\n        }\n        var\
    \ p = new Prime()\n        var j = 1\n        while (j <= n) {\n            if\
    \ (p.isPrime(fib(j))) {\n                j += 1\n            } else {\n      \
    \          fib(j) = 0\n            }\n        }\n        fib(n.toInt)", "    \
    \    val primes = new PrimeSet(1000000)\n        var fib = new Fibonacci()\n \
    \       var i = 0l\n        var p = 0l\n        while (i < n) {\n            p\
    \ = fib.next\n            if (primes.contains(p)) i += 1\n        }\n        return\
    \ p", "        var i = 1l\n        var j = 1l\n        var k = 1l\n        var\
    \ count = 0l\n        while (count < n) {\n            k = i + j\n           \
    \ if (isPrime(k)) {\n                count += 1\n            }\n            i\
    \ = j\n            j = k\n        }\n        return k", "        var i = 1l\n\
    \        var j = 2l\n        var k = 3l\n        var count = 2l\n        while\
    \ (count < n) {\n            i = j\n            j = k\n            k = i + j\n\
    \            if (k.isPrime) count += 1\n        }\n        k", "        var i\
    \ = 1l\n        var j = 1l\n        var k = 1l\n        var c = 0l\n        while\
    \ (c < n) {\n            k = i + j\n            if (isPrime(k)) {\n          \
    \      c += 1\n            }\n            i = j\n            j = k\n        }\n\
    \        return k", "        var i = 1l\n        var j = 1l\n        var k = 1l\n\
    \        var count = 1l\n        while (count < n) {\n            k = i + j\n\
    \            if (isPrime(k)) {\n                count += 1\n            }\n  \
    \          i = j\n            j = k\n        }\n        return k", "        val\
    \ primes = new PrimeSet(1000000)\n        var i = 1l\n        var fib = 1l\n \
    \       var fib_prev = 1l\n        while (i < n) {\n            val temp = fib\n\
    \            fib += fib_prev\n            fib_prev = temp\n            if (primes.contains(fib))\
    \ i += 1\n        }\n        fib", "        var fibs = new ArrayBuffer[Long]();\n\
    \        fibs += 2l;\n        fibs += 3l;\n        var i = 2l;\n        while\
    \ (i < n) {\n            fibs += fibs(i.toInt - 1) + fibs(i.toInt - 2);\n    \
    \        i += 1l;\n        }\n        return fibs(n.toInt - 1);", "        val\
    \ primes = new PrimeSet(1000000)\n        var fib = new Fibonacci()\n        var\
    \ i = 0l\n        var result = 0l\n        while (i < n) {\n            result\
    \ = fib.next()\n            if (primes.contains(result)) i += 1\n        }\n \
    \       return result", "        var i = 1l\n        var j = 1l\n        var k\
    \ = 1l\n        var count = 1l\n        while (count < n) {\n            k = i\
    \ + j\n            if (BigInt(k).isProbablePrime(10)) {\n                count\
    \ += 1\n            }\n            i = j\n            j = k\n        }\n     \
    \   return k", "        var fib = new Fibonacci()\n        var i = 0l\n      \
    \  var p = 0l\n        while (i < n) {\n            p = fib.next\n           \
    \ if (p.isPrime) i += 1\n        }\n        return p", "        var f1 : Long\
    \ = 2l\n        var f2 : Long = 3l\n        var f3 : Long = 5l\n        var i\
    \ : Long = 3l\n        while(i < n) {\n            f1 = f2\n            f2 = f3\n\
    \            f3 = f1 + f2\n            if(f3.isPrime) {\n                i +=\
    \ 1\n            }\n        }\n        return f3", "        var a = 2l;\n    \
    \    var b = 3l;\n        var c = 5l;\n        var i = 2l;\n        while (i <\
    \ n) {\n            a = b;\n            b = c;\n            c = a + b;\n     \
    \       while (!isPrime(c)) {\n                a = b;\n                b = c;\n\
    \                c = a + b;\n            }\n            i += 1;\n        }\n \
    \       return c;", "        var primes = new ArrayBuffer[Long]();\n        primes\
    \ += 2l;\n        primes += 3l;\n        var fibs = new ArrayBuffer[Long]();\n\
    \        fibs += 2l;\n        fibs += 3l;\n        var i = 2l;\n        while\
    \ (fibs.length < n) {\n            var j = 0;\n            while (j < primes.length\
    \ && i % primes(j) != 0) {\n                j += 1;\n            }\n         \
    \   if (j == primes.length) {\n                primes += i;\n                if\
    \ (i == fibs(fibs.length - 1) + fibs(fibs.length - 2)) {\n                   \
    \ fibs += i;\n                }\n            }\n            i += 1;\n        }\n\
    \        return fibs(fibs.length - 1);", "        def primeFibRec(n : Long, a\
    \ : Long, b : Long, count : Long) : Long = {\n            if (count == n) b\n\
    \            else if (isPrime(b)) primeFibRec(n, b, a + b, count + 1)\n      \
    \      else primeFibRec(n, b, a + b, count)\n        }\n        primeFibRec(n,\
    \ 0, 1, 1)"]
stop_tokens:
- "\n    }\n"
