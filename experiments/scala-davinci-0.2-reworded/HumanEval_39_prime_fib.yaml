name: HumanEval_39_prime_fib
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // prime_fib returns n-th number that is a Fibonacci number and it's also prime.\n\
  \    // >>> primeFib((1l))\n    // (2l)\n    // >>> primeFib((2l))\n    // (3l)\n\
  \    // >>> primeFib((3l))\n    // (5l)\n    // >>> primeFib((4l))\n    // (13l)\n\
  \    // >>> primeFib((5l))\n    // (89l)\n    def primeFib(n : Long) : Long = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(primeFib((1l)) ==\
  \ (2l));\n    assert(primeFib((2l)) == (3l));\n    assert(primeFib((3l)) == (5l));\n\
  \    assert(primeFib((4l)) == (13l));\n    assert(primeFib((5l)) == (89l));\n  \
  \  assert(primeFib((6l)) == (233l));\n    assert(primeFib((7l)) == (1597l));\n \
  \   assert(primeFib((8l)) == (28657l));\n    assert(primeFib((9l)) == (514229l));\n\
  \    assert(primeFib((10l)) == (433494437l));\n    }\n\n}\n"
completions: ["        var fibs = new ArrayBuffer[Long]();\n        fibs += 2;\n \
    \       fibs += 3;\n        var i = 2;\n        while(i <= n) {\n            fibs\
    \ += fibs(i - 1) + fibs(i - 2);\n            i += 1;\n        }\n        return\
    \ fibs(n.toInt - 1);", "        val primes = new PrimeSet(1000000)\n        var\
    \ fib = new Fibonacci()\n        var i = 0l\n        var p = 0l\n        while\
    \ (i < n) {\n            p = fib.next\n            if (primes.contains(p)) i +=\
    \ 1\n        }\n        return p", "        var i = 1l\n        var j = 2l\n \
    \       var k = 3l\n        var count = 2l\n        while (count < n) {\n    \
    \        i = j\n            j = k\n            k = i + j\n            if (isPrime(k))\
    \ count += 1\n        }\n        return k", "        var count = 0l\n        var\
    \ i = 1l\n        while (count < n) {\n            if (isPrime(fib(i))) count\
    \ += 1\n            i += 1\n        }\n        return fib(i - 1)", "        val\
    \ primes = new PrimeSet(1000000)\n        var a = 2l\n        var b = 3l\n   \
    \     var c = 5l\n        var i = 5l\n        while (i < n) {\n            a =\
    \ b\n            b = c\n            c = a + b\n            i += 1\n        }\n\
    \        return c", "        val primes = new PrimeSet(1000000)\n        var i\
    \ = 1l\n        var fib = 1l\n        var fib_prev = 1l\n        while (i < n)\
    \ {\n            val fib_next = fib + fib_prev\n            fib_prev = fib\n \
    \           fib = fib_next\n            if (primes.contains(fib)) i += 1\n   \
    \     }\n        fib", "        def primeFib(n : Long, a : Long, b : Long, i :\
    \ Long) : Long = {\n            if (i == n) b\n            else if (b.isPrime)\
    \ primeFib(n, b, a + b, i + 1)\n            else primeFib(n, b, a + b, i)\n  \
    \      }\n        primeFib(n, 2, 3, 1)", "        def primeFibRec(n : Long, a\
    \ : Long, b : Long, c : Long) : Long = {\n            if (n == 1) a\n        \
    \    else if (n == 2) b\n            else if (n == 3) c\n            else {\n\
    \                val d = a + b + c\n                if (isPrime(d)) primeFibRec(n\
    \ - 1, b, c, d)\n                else primeFibRec(n, b, c, d)\n            }\n\
    \        }\n        primeFibRec(n, 2, 3, 5)", "        var fibs = new ArrayBuffer[Long]();\n\
    \        fibs += 2;\n        fibs += 3;\n        var i = 2;\n        while (i\
    \ <= n) {\n            var fib = fibs(i - 1) + fibs(i - 2);\n            if (fib.isPrime)\
    \ {\n                fibs += fib;\n                i += 1;\n            }\n  \
    \      }\n        return fibs(n.toInt - 1);", "        val primes = new PrimeSet(1000000)\n\
    \        var i = 0l\n        var j = 1l\n        var k = 0l\n        var count\
    \ = 0l\n        while (count < n) {\n            k = i + j\n            i = j\n\
    \            j = k\n            if (primes.isPrime(k)) count += 1\n        }\n\
    \        k", "        var fibs = new ArrayBuffer[Long]();\n        fibs += 1l;\n\
    \        fibs += 2l;\n        var i = 2l;\n        while (i < n) {\n         \
    \   fibs += fibs(i.toInt - 1) + fibs(i.toInt - 2);\n            i += 1l;\n   \
    \     }\n        var j = fibs.length - 1;\n        while (j >= 0) {\n        \
    \    if (isPrime(fibs(j.toInt))) {\n                return fibs(j.toInt);\n  \
    \          }\n            j -= 1;\n        }\n        return 0l;", "        var\
    \ fib = new Array[Long](n.toInt)\n        fib(0) = 2\n        fib(1) = 3\n   \
    \     var i = 2\n        while (i < n) {\n            fib(i) = fib(i - 1) + fib(i\
    \ - 2)\n            i += 1\n        }\n        return fib(n.toInt - 1)", "   \
    \     var i = 1l\n        var j = 2l\n        var k = 3l\n        var count =\
    \ 1l\n        while (count < n) {\n            if (isPrime(k)) {\n           \
    \     count += 1\n            }\n            val t = k\n            k = i + j\n\
    \            i = j\n            j = t\n        }\n        k", "        var fibs\
    \ = new ArrayBuffer[Long]()\n        fibs += 2\n        fibs += 3\n        var\
    \ i = 2\n        while (i <= n) {\n            val next = fibs(i - 1) + fibs(i\
    \ - 2)\n            if (isPrime(next)) {\n                fibs += next\n     \
    \           i += 1\n            }\n        }\n        fibs(n.toInt - 1)", "  \
    \      var f1 : Long = 2l\n        var f2 : Long = 3l\n        var f3 : Long =\
    \ 5l\n        var i : Long = 3l\n        while (i < n) {\n            f1 = f2\n\
    \            f2 = f3\n            f3 = f1 + f2\n            if (f3.isPrime) {\n\
    \                i += 1\n            }\n        }\n        return f3", "     \
    \   val primes = new PrimeSet(1000000)\n        var i = 1l\n        var j = 2l\n\
    \        var k = 3l\n        var count = 1l\n        while (count < n) {\n   \
    \         i = j\n            j = k\n            k = i + j\n            if (primes.contains(k))\
    \ count += 1\n        }\n        k", "        var f1 : Long = 2l\n        var\
    \ f2 : Long = 3l\n        var f3 : Long = 5l\n        var i : Long = 3l\n    \
    \    while(i < n) {\n            f1 = f2\n            f2 = f3\n            f3\
    \ = f1 + f2\n            while(f3 % 2 == 0) {\n                f3 = f1 + f2\n\
    \                f1 = f2\n                f2 = f3\n            }\n           \
    \ i = i + 1\n        }\n        return f3", "        val primes = new PrimeSet(1000000)\n\
    \        var i = 1l\n        var j = 1l\n        var k = 1l\n        while (k\
    \ < n) {\n            val t = i + j\n            if (primes.isPrime(t)) k += 1\n\
    \            i = j\n            j = t\n        }\n        j", "        var fib\
    \ = new Array[Long](n.toInt + 1)\n        fib(0) = 0\n        fib(1) = 1\n   \
    \     var i = 2\n        while (i <= n) {\n            fib(i) = fib(i - 1) + fib(i\
    \ - 2)\n            i += 1\n        }\n        var prime = new Array[Boolean](fib(n.toInt)\
    \ + 1)\n        i = 2\n        while (i <= fib(n.toInt)) {\n            prime(i)\
    \ = true\n            i += 1\n        }\n        i = 2\n        while (i <= fib(n.toInt))\
    \ {\n            if (prime(i)) {\n                var j = i * 2\n            \
    \    while (j <= fib(n.toInt)) {\n                    prime(j) = false\n     \
    \               j += i\n                }\n            }\n            i += 1\n\
    \        }\n        i = n.toInt\n        while (i >= 0) {\n            if (prime(fib(i)))\
    \ return fib(i)\n            i -= 1\n        }\n        return 0", "        val\
    \ primes = new PrimeSet(1000000)\n        var i = 1l\n        var j = 1l\n   \
    \     var k = 1l\n        var count = 0l\n        while (count < n) {\n      \
    \      val t = i + j\n            if (primes.isPrime(t)) {\n                count\
    \ += 1\n                k = t\n            }\n            i = j\n            j\
    \ = t\n        }\n        k"]
stop_tokens:
- "\n    }\n"
