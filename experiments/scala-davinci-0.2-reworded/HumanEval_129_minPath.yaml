name: HumanEval_129_minPath
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Given a grid with N rows and N columns (N >= 2) and a positive integer k,\
  \ \n    // each cell of the grid contains a value. Every integer in the range [1,\
  \ N * N]\n    // inclusive appears exactly once on the cells of the grid.\n    //\
  \ You have to find the minimum path of length k in the grid. You can start\n   \
  \ // from any cell, and in each step you can move to any of the neighbor cells,\n\
  \    // in other words, you can go to cells which share an edge with you current\n\
  \    // cell.\n    // Please note that a path of length k means visiting exactly\
  \ k cells (not\n    // necessarily distinct).\n    // You CANNOT go off the grid.\n\
  \    // A path A (of length k) is considered less than a path B (of length k) if\n\
  \    // after making the ordered lists of the values on the cells that A and B go\n\
  \    // through (let's call them lst_A and lst_B), lst_A is lexicographically less\n\
  \    // than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n\
  \    // such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    //\
  \ lst_A[j] = lst_B[j].\n    // It is guaranteed that the answer is unique.\n   \
  \ // Return an ordered list of the values on the cells that the minimum path go\
  \ through.\n    // Examples:    \n    // >>> minPath((List[List[Long]](List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong), List[Long](4l.toLong, 5l.toLong, 6l.toLong), List[Long](7l.toLong,\
  \ 8l.toLong, 9l.toLong))), (3l))\n    // (List[Long](1l.toLong, 2l.toLong, 1l.toLong))\n\
  \    // >>> minPath((List[List[Long]](List[Long](5l.toLong, 9l.toLong, 3l.toLong),\
  \ List[Long](4l.toLong, 1l.toLong, 6l.toLong), List[Long](7l.toLong, 8l.toLong,\
  \ 2l.toLong))), (1l))\n    // (List[Long](1l.toLong))\n    def minPath(grid : List[List[Long]],\
  \ k : Long) : List[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(minPath((List[List[Long]](List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong), List[Long](4l.toLong, 5l.toLong, 6l.toLong), List[Long](7l.toLong,\
  \ 8l.toLong, 9l.toLong))), (3l)).equals((List[Long](1l.toLong, 2l.toLong, 1l.toLong))));\n\
  \    assert(minPath((List[List[Long]](List[Long](5l.toLong, 9l.toLong, 3l.toLong),\
  \ List[Long](4l.toLong, 1l.toLong, 6l.toLong), List[Long](7l.toLong, 8l.toLong,\
  \ 2l.toLong))), (1l)).equals((List[Long](1l.toLong))));\n    assert(minPath((List[List[Long]](List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong), List[Long](5l.toLong, 6l.toLong, 7l.toLong,\
  \ 8l.toLong), List[Long](9l.toLong, 10l.toLong, 11l.toLong, 12l.toLong), List[Long](13l.toLong,\
  \ 14l.toLong, 15l.toLong, 16l.toLong))), (4l)).equals((List[Long](1l.toLong, 2l.toLong,\
  \ 1l.toLong, 2l.toLong))));\n    assert(minPath((List[List[Long]](List[Long](6l.toLong,\
  \ 4l.toLong, 13l.toLong, 10l.toLong), List[Long](5l.toLong, 7l.toLong, 12l.toLong,\
  \ 1l.toLong), List[Long](3l.toLong, 16l.toLong, 11l.toLong, 15l.toLong), List[Long](8l.toLong,\
  \ 14l.toLong, 9l.toLong, 2l.toLong))), (7l)).equals((List[Long](1l.toLong, 10l.toLong,\
  \ 1l.toLong, 10l.toLong, 1l.toLong, 10l.toLong, 1l.toLong))));\n    assert(minPath((List[List[Long]](List[Long](8l.toLong,\
  \ 14l.toLong, 9l.toLong, 2l.toLong), List[Long](6l.toLong, 4l.toLong, 13l.toLong,\
  \ 15l.toLong), List[Long](5l.toLong, 7l.toLong, 1l.toLong, 12l.toLong), List[Long](3l.toLong,\
  \ 10l.toLong, 11l.toLong, 16l.toLong))), (5l)).equals((List[Long](1l.toLong, 7l.toLong,\
  \ 1l.toLong, 7l.toLong, 1l.toLong))));\n    assert(minPath((List[List[Long]](List[Long](11l.toLong,\
  \ 8l.toLong, 7l.toLong, 2l.toLong), List[Long](5l.toLong, 16l.toLong, 14l.toLong,\
  \ 4l.toLong), List[Long](9l.toLong, 3l.toLong, 15l.toLong, 6l.toLong), List[Long](12l.toLong,\
  \ 13l.toLong, 10l.toLong, 1l.toLong))), (9l)).equals((List[Long](1l.toLong, 6l.toLong,\
  \ 1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong, 1l.toLong))));\n\
  \    assert(minPath((List[List[Long]](List[Long](12l.toLong, 13l.toLong, 10l.toLong,\
  \ 1l.toLong), List[Long](9l.toLong, 3l.toLong, 15l.toLong, 6l.toLong), List[Long](5l.toLong,\
  \ 16l.toLong, 14l.toLong, 4l.toLong), List[Long](11l.toLong, 8l.toLong, 7l.toLong,\
  \ 2l.toLong))), (12l)).equals((List[Long](1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong,\
  \ 1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong))));\n\
  \    assert(minPath((List[List[Long]](List[Long](2l.toLong, 7l.toLong, 4l.toLong),\
  \ List[Long](3l.toLong, 1l.toLong, 5l.toLong), List[Long](6l.toLong, 8l.toLong,\
  \ 9l.toLong))), (8l)).equals((List[Long](1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong,\
  \ 1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(minPath((List[List[Long]](List[Long](6l.toLong,\
  \ 1l.toLong, 5l.toLong), List[Long](3l.toLong, 8l.toLong, 9l.toLong), List[Long](2l.toLong,\
  \ 7l.toLong, 4l.toLong))), (8l)).equals((List[Long](1l.toLong, 5l.toLong, 1l.toLong,\
  \ 5l.toLong, 1l.toLong, 5l.toLong, 1l.toLong, 5l.toLong))));\n    assert(minPath((List[List[Long]](List[Long](1l.toLong,\
  \ 2l.toLong), List[Long](3l.toLong, 4l.toLong))), (10l)).equals((List[Long](1l.toLong,\
  \ 2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong,\
  \ 2l.toLong))));\n    assert(minPath((List[List[Long]](List[Long](1l.toLong, 3l.toLong),\
  \ List[Long](3l.toLong, 2l.toLong))), (10l)).equals((List[Long](1l.toLong, 3l.toLong,\
  \ 1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
  \    }\n\n}\n"
completions: ["        // Write your code here\n        return List[Long]()", "  \
    \      // Write your code here\n        var n = grid.length\n        var m = grid(0).length\n\
    \        var dp = Array.ofDim[Long](n, m, k.toInt + 1)\n        for (i <- 0 until\
    \ n) {\n            for (j <- 0 until m) {\n                for (l <- 0 to k.toInt)\
    \ {\n                    dp(i)(j)(l) = Long.MaxValue\n                }\n    \
    \        }\n        }\n        for (i <- 0 until n) {\n            for (j <- 0\
    \ until m) {\n                dp(i)(j)(1) = grid(i)(j)\n            }\n      \
    \  }\n        for (l <- 2 to k.toInt) {\n            for (i <- 0 until n) {\n\
    \                for (j <- 0 until m) {\n                    if (i > 0) dp(i)(j)(l)\
    \ = min(dp(i)(j)(l), dp(i - 1)(j)(l - 1))\n                    if (i < n - 1)\
    \ dp(i)(j)(l) = min(dp(i)(j)(l), dp(i + 1)(j)(l - 1))\n                    if\
    \ (j > 0) dp(i)(j)(l) = min(dp(i)(j)(l), dp(i)(j - 1)(l - 1))\n              \
    \      if (j < m - 1) dp(i)(j)(l) = min(dp(i)(j)(l), dp(i)(j + 1)(l - 1))\n  \
    \              }\n            }\n        }\n        var ans = Long.MaxValue\n\
    \        var x = 0\n        var y = 0\n        for (i <- 0 until n) {\n      \
    \      for (j <- 0 until m) {\n                if (dp(i)(j)(k.toInt) < ans) {\n\
    \                    ans = dp(i)(j)(k.toInt)\n                    x = i\n    \
    \                y = j\n                }\n            }\n        }\n        var\
    \ result = List[Long]()\n        result = result :+ ans\n        for (l <- k.toInt\
    \ - 1 to 1 by -1) {\n            if (x > 0 && d", "        // Your code here\n\
    \        ???", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.fill(n, m)(List[Long]())\n        for (i <- 0 until n)\
    \ {\n            for (j <- 0 until m) {\n                if (i == 0 && j == 0)\
    \ dp(i)(j) = List(grid(i)(j))\n                else {\n                    var\
    \ min = List[Long]()\n                    if (i > 0) {\n                     \
    \   if (dp(i - 1)(j).length < k) min = dp(i - 1)(j)\n                        else\
    \ if (dp(i - 1)(j).length == k) min = if (dp(i - 1)(j) < min) dp(i - 1)(j) else\
    \ min\n                    }\n                    if (j > 0) {\n             \
    \           if (dp(i)(j - 1).length < k) min = dp(i)(j - 1)\n                \
    \        else if (dp(i)(j - 1).length == k) min = if (dp(i)(j - 1) < min) dp(i)(j\
    \ - 1) else min\n                    }\n                    if (min.length < k)\
    \ dp(i)(j) = min :+ grid(i)(j)\n                    else if (min.length == k)\
    \ dp(i)(j) = if (min :+ grid(i)(j) < dp(i)(j)) min :+ grid(i)(j) else dp(i)(j)\n\
    \                }\n            }\n        }\n        dp(n - 1)(m - 1)", "   \
    \     // Write your code here\n        return List[Long]()", "        // Write\
    \ your code here\n        // Return the ordered list of the values on the cells\
    \ that the minimum path go through.\n        val n = grid.length\n        val\
    \ m = grid(0).length\n        val dp = Array.ofDim[Long](n, m, k.toInt + 1)\n\
    \        for (i <- 0 until n; j <- 0 until m; l <- 0 to k.toInt) {\n         \
    \   dp(i)(j)(l) = Long.MaxValue\n        }\n        for (i <- 0 until n; j <-\
    \ 0 until m) {\n            dp(i)(j)(1) = grid(i)(j)\n        }\n        for (l\
    \ <- 2 to k.toInt) {\n            for (i <- 0 until n; j <- 0 until m) {\n   \
    \             if (i > 0) dp(i)(j)(l) = min(dp(i)(j)(l), dp(i - 1)(j)(l - 1))\n\
    \                if (i < n - 1) dp(i)(j)(l) = min(dp(i)(j)(l), dp(i + 1)(j)(l\
    \ - 1))\n                if (j > 0) dp(i)(j)(l) = min(dp(i)(j)(l), dp(i)(j - 1)(l\
    \ - 1))\n                if (j < m - 1) dp(i)(j)(l) = min(dp(i)(j)(l), dp(i)(j\
    \ + 1)(l - 1))\n            }\n        }\n        var min = Long.MaxValue\n  \
    \      var min_i = -1\n        var min_j = -1\n        for (i <- 0 until n; j\
    \ <- 0 until m) {\n            if (dp(i)(j)(k.toInt) < min) {\n              \
    \  min = dp(i)(j)(k.toInt)\n                min_i = i\n                min_j =\
    \ j\n            }\n        }\n        val ans = ListBuffer[Long]()\n        ans\
    \ += grid(min_i)(min_j)\n        var cur_i = min_i\n        var cur_j = min_j\n\
    \        for (l <- k.toInt -", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.fill(n, m)(List[Long]())\n        for (i <- 0 until n)\
    \ {\n            for (j <- 0 until m) {\n                dp(i)(j) = List(grid(i)(j))\n\
    \                if (i > 0 && dp(i - 1)(j).length < k && dp(i - 1)(j) < dp(i)(j))\
    \ dp(i)(j) = dp(i - 1)(j)\n                if (j > 0 && dp(i)(j - 1).length <\
    \ k && dp(i)(j - 1) < dp(i)(j)) dp(i)(j) = dp(i)(j - 1)\n            }\n     \
    \   }\n        dp(n - 1)(m - 1)", "        // Write your code here\n        //\
    \ Return the ordered list of the values on the cells that the minimum path go\
    \ through.\n        null", "        // Write your code here\n        val n = grid.length\n\
    \        val m = grid(0).length\n        val dp = Array.ofDim[Long](n, m, k.toInt\
    \ + 1)\n        for (i <- 0 until n; j <- 0 until m; l <- 0 to k.toInt) {\n  \
    \          if (l == 0) dp(i)(j)(l) = 0\n            else {\n                var\
    \ min = Long.MaxValue\n                if (i > 0) min = min min (dp(i - 1)(j)(l\
    \ - 1) + grid(i)(j))\n                if (j > 0) min = min min (dp(i)(j - 1)(l\
    \ - 1) + grid(i)(j))\n                if (i < n - 1) min = min min (dp(i + 1)(j)(l\
    \ - 1) + grid(i)(j))\n                if (j < m - 1) min = min min (dp(i)(j +\
    \ 1)(l - 1) + grid(i)(j))\n                dp(i)(j)(l) = min\n            }\n\
    \        }\n        var min = Long.MaxValue\n        var min_i = -1\n        var\
    \ min_j = -1\n        for (i <- 0 until n; j <- 0 until m) {\n            if (dp(i)(j)(k.toInt)\
    \ < min) {\n                min = dp(i)(j)(k.toInt)\n                min_i = i\n\
    \                min_j = j\n            }\n        }\n        var i = min_i\n\
    \        var j = min_j\n        var l = k.toInt\n        val result = ListBuffer[Long]()\n\
    \        while (l > 0) {\n            result += grid(i)(j)\n            l -= 1\n\
    \            if (i > 0 && dp(i - 1)(j)(l) + grid(i)(j) == dp(i)(j)(l + 1)) i -=\
    \ 1\n            else if (j > 0 && dp(i)(j - 1)(l) + grid(i)(j) == dp(i)(j)(l\
    \ + 1)) j -= 1\n            else if (i < n - 1 && d", "        val n = grid.length\n\
    \        val m = grid(0).length\n        val dp = Array.fill(n, m)(List[Long]())\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n        \
    \        dp(i)(j) = List[Long](grid(i)(j))\n                if (i > 0 && dp(i\
    \ - 1)(j).length > 0 && dp(i - 1)(j).length + 1 <= k) {\n                    val\
    \ lst = dp(i - 1)(j) :+ grid(i)(j)\n                    if (dp(i)(j).length ==\
    \ 0 || lst < dp(i)(j)) dp(i)(j) = lst\n                }\n                if (j\
    \ > 0 && dp(i)(j - 1).length > 0 && dp(i)(j - 1).length + 1 <= k) {\n        \
    \            val lst = dp(i)(j - 1) :+ grid(i)(j)\n                    if (dp(i)(j).length\
    \ == 0 || lst < dp(i)(j)) dp(i)(j) = lst\n                }\n            }\n \
    \       }\n        dp(n - 1)(m - 1)", "        // Your code here\n        return\
    \ List[Long]()", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.fill(n, m)(List[Long]())\n        for (i <- 0 until n)\
    \ {\n            for (j <- 0 until m) {\n                if (i == 0 && j == 0)\
    \ dp(i)(j) = List(grid(i)(j))\n                else if (i == 0) dp(i)(j) = (dp(i)(j\
    \ - 1) :+ grid(i)(j)).sorted\n                else if (j == 0) dp(i)(j) = (dp(i\
    \ - 1)(j) :+ grid(i)(j)).sorted\n                else dp(i)(j) = (dp(i - 1)(j)\
    \ :+ grid(i)(j)).sorted.take(k.toInt)\n                if (dp(i)(j).length > k.toInt)\
    \ dp(i)(j) = dp(i)(j).take(k.toInt)\n                if (j > 0) {\n          \
    \          val tmp = (dp(i)(j - 1) :+ grid(i)(j)).sorted\n                   \
    \ if (tmp.length > k.toInt) tmp.take(k.toInt)\n                    if (tmp < dp(i)(j))\
    \ dp(i)(j) = tmp\n                }\n            }\n        }\n        dp(n -\
    \ 1)(m - 1)", "        // Write your code here\n        var result = List[Long]()\n\
    \        var min = Long.MaxValue\n        for (i <- 0 until grid.length) {\n \
    \           for (j <- 0 until grid(i).length) {\n                val path = find(grid,\
    \ i, j, k, List[Long]())\n                if (path._1 < min) {\n             \
    \       min = path._1\n                    result = path._2\n                }\n\
    \            }\n        }\n        result", "        // Your code here\n     \
    \   return List[Long]()", "        // Write your code here\n        // Return\
    \ the ordered list of the values on the cells that the minimum path go through\n\
    \        val n = grid.length\n        val m = grid(0).length\n        val dp =\
    \ Array.ofDim[Long](n, m, k.toInt + 1)\n        val path = Array.ofDim[Int](n,\
    \ m, k.toInt + 1)\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                dp(i)(j)(1) = grid(i)(j)\n                path(i)(j)(1)\
    \ = -1\n            }\n        }\n        for (l <- 2 to k.toInt) {\n        \
    \    for (i <- 0 until n) {\n                for (j <- 0 until m) {\n        \
    \            dp(i)(j)(l) = Long.MaxValue\n                    for (x <- 0 until\
    \ n) {\n                        for (y <- 0 until m) {\n                     \
    \       if (abs(x - i) + abs(y - j) == 1) {\n                                if\
    \ (dp(x)(y)(l - 1) + grid(i)(j) < dp(i)(j)(l)) {\n                           \
    \         dp(i)(j)(l) = dp(x)(y)(l - 1) + grid(i)(j)\n                       \
    \             path(i)(j)(l) = x * m + y\n                                }\n \
    \                           }\n                        }\n                   \
    \ }\n                }\n            }\n        }\n        var min = Long.MaxValue\n\
    \        var minI = -1\n        var minJ = -1\n        for (i <- 0 until n) {\n\
    \            for (j <- 0 until m) {\n                if (dp(i)(j)(k.toInt) < min)\
    \ {\n                    min = dp(i)(j)(k.toInt)\n                    minI = i\n\
    \                    minJ = j\n                }\n            }\n        }\n \
    \       var ans = List[Long]()\n        var cur = k.toInt\n        while (cur\
    \ >= 1) {\n            ans = grid(minI)(minJ) :: ans\n            val next = path(minI)(minJ)(cur)\n\
    \           ", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.fill(n, m)(List[Long]())\n        for (i <- 0 until n)\
    \ {\n            for (j <- 0 until m) {\n                dp(i)(j) = List(grid(i)(j))\n\
    \                if (i > 0 && dp(i - 1)(j).length + 1 <= k) {\n              \
    \      if (dp(i - 1)(j).length + 1 == k) {\n                        if (dp(i -\
    \ 1)(j) < dp(i)(j)) dp(i)(j) = dp(i - 1)(j) :+ grid(i)(j)\n                  \
    \  } else {\n                        if (dp(i - 1)(j) < dp(i)(j)) dp(i)(j) = dp(i\
    \ - 1)(j) :+ grid(i)(j)\n                    }\n                }\n          \
    \      if (j > 0 && dp(i)(j - 1).length + 1 <= k) {\n                    if (dp(i)(j\
    \ - 1).length + 1 == k) {\n                        if (dp(i)(j - 1) < dp(i)(j))\
    \ dp(i)(j) = dp(i)(j - 1) :+ grid(i)(j)\n                    } else {\n      \
    \                  if (dp(i)(j - 1) < dp(i)(j)) dp(i)(j) = dp(i)(j - 1) :+ grid(i)(j)\n\
    \                    }\n                }\n            }\n        }\n        dp(n\
    \ - 1)(m - 1)", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.fill(n, m)(List[Long]())\n        for (i <- 0 until n)\
    \ {\n            for (j <- 0 until m) {\n                if (i == 0 && j == 0)\
    \ dp(i)(j) = List(grid(i)(j))\n                else {\n                    val\
    \ up = if (i > 0) dp(i - 1)(j) else List[Long]()\n                    val left\
    \ = if (j > 0) dp(i)(j - 1) else List[Long]()\n                    if (up.length\
    \ == 0 && left.length == 0) dp(i)(j) = List(grid(i)(j))\n                    else\
    \ if (up.length == 0) dp(i)(j) = grid(i)(j) :: left\n                    else\
    \ if (left.length == 0) dp(i)(j) = grid(i)(j) :: up\n                    else\
    \ if (up.length < left.length) dp(i)(j) = grid(i)(j) :: up\n                 \
    \   else if (up.length > left.length) dp(i)(j) = grid(i)(j) :: left\n        \
    \            else {\n                        val up_min = up.min\n           \
    \             val left_min = left.min\n                        if (up_min < left_min)\
    \ dp(i)(j) = grid(i)(j) :: up\n                        else if (up_min > left_min)\
    \ dp(i)(j) = grid(i)(j) :: left\n                        else dp(i)(j) = grid(i)(j)\
    \ :: (if (up < left) up else left)\n                    }\n                }\n\
    \            }\n        }\n        dp(n - 1)(m - 1).take(k.toInt)", "        //\
    \ Your code here\n        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.ofDim[Long](n, m, k.toInt + 1)\n        val path = Array.ofDim[Int](n,\
    \ m, k.toInt + 1)\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                dp(i)(j)(1) = grid(i)(j)\n                path(i)(j)(1)\
    \ = -1\n            }\n        }\n        for (l <- 2 to k.toInt) {\n        \
    \    for (i <- 0 until n) {\n                for (j <- 0 until m) {\n        \
    \            dp(i)(j)(l) = Long.MaxValue\n                    path(i)(j)(l) =\
    \ -1\n                    if (i > 0 && dp(i - 1)(j)(l - 1) < dp(i)(j)(l)) {\n\
    \                        dp(i)(j)(l) = dp(i - 1)(j)(l - 1)\n                 \
    \       path(i)(j)(l) = 0\n                    }\n                    if (i <\
    \ n - 1 && dp(i + 1)(j)(l - 1) < dp(i)(j)(l)) {\n                        dp(i)(j)(l)\
    \ = dp(i + 1)(j)(l - 1)\n                        path(i)(j)(l) = 1\n         \
    \           }\n                    if (j > 0 && dp(i)(j - 1)(l - 1) < dp(i)(j)(l))\
    \ {\n                        dp(i)(j)(l) = dp(i)(j - 1)(l - 1)\n             \
    \           path(i)(j)(l) = 2\n                    }\n                    if (j\
    \ < m - 1 && dp(i)(j + 1)(l - 1) < dp(i)(j)(l)) {\n                        dp(i)(j)(l)\
    \ = dp(i)(j + 1)(l - 1)\n                        path(i)(j)(l) = 3\n         \
    \           }\n                    dp(i)(j)(l) += grid(i)(j)\n               \
    \ }\n            }\n", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.fill(n, m)(List[Long]())\n        for (i <- 0 until n)\
    \ {\n            for (j <- 0 until m) {\n                if (i == 0 && j == 0)\
    \ dp(i)(j) = List(grid(i)(j))\n                else {\n                    val\
    \ l = if (i > 0) dp(i - 1)(j) else List[Long]()\n                    val u = if\
    \ (j > 0) dp(i)(j - 1) else List[Long]()\n                    val lu = if (i >\
    \ 0 && j > 0) dp(i - 1)(j - 1) else List[Long]()\n                    val lu_\
    \ = if (i > 0 && j > 0) dp(i - 1)(j - 1) else List[Long]()\n                 \
    \   val l_ = if (i > 0) dp(i - 1)(j) else List[Long]()\n                    val\
    \ u_ = if (j > 0) dp(i)(j - 1) else List[Long]()\n                    val lu__\
    \ = if (i > 0 && j > 0) dp(i - 1)(j - 1) else List[Long]()\n                 \
    \   val lu___ = if (i > 0 && j > 0) dp(i - 1)(j - 1) else List[Long]()\n     \
    \               if (l.length < k && u.length < k && lu.length < k) {\n       \
    \                 dp(i)(j) = List(grid(i)(j))\n                    }\n       \
    \             else if (l.length < k && u.length < k && lu.length == k) {\n   \
    \                     dp(i)(j) = List(grid(i)(j))\n                    }\n   \
    \                 else if (l.length < k && u.length == k && lu.length < k) {\n\
    \                        dp(i)(j) = List(grid(i)(j))\n                    }\n\
    \                    else if (l.length < k && u.length == k && lu.length == k)\
    \ {\n                        dp(i)(j) = List(grid(i)(j))", "        val n = grid.length\n\
    \        val m = grid(0).length\n        val dp = Array.fill(n, m)(List[Long]())\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n        \
    \        val cur = grid(i)(j)\n                if (i == 0 && j == 0) dp(i)(j)\
    \ = List(cur)\n                else if (i == 0) {\n                    val prev\
    \ = dp(i)(j - 1)\n                    if (prev.length < k) dp(i)(j) = prev :+\
    \ cur\n                    else if (prev.length == k) {\n                    \
    \    if (cur < prev.last) dp(i)(j) = prev.init :+ cur\n                      \
    \  else dp(i)(j) = prev\n                    }\n                    else dp(i)(j)\
    \ = prev\n                }\n                else if (j == 0) {\n            \
    \        val prev = dp(i - 1)(j)\n                    if (prev.length < k) dp(i)(j)\
    \ = prev :+ cur\n                    else if (prev.length == k) {\n          \
    \              if (cur < prev.last) dp(i)(j) = prev.init :+ cur\n            \
    \            else dp(i)(j) = prev\n                    }\n                   \
    \ else dp(i)(j) = prev\n                }\n                else {\n          \
    \          val prev1 = dp(i - 1)(j)\n                    val prev2 = dp(i)(j -\
    \ 1)\n                    if (prev1.length < k) {\n                        if\
    \ (prev2.length < k) {\n                            if (prev1.length < prev2.length)\
    \ dp(i)(j) = prev1 :+ cur\n                            else if (prev1.length ==\
    \ prev2.length) {\n                                if (prev1.last < prev2.last)\
    \ dp(i)(j) = prev1 :+ cur\n                                else dp(i)(j) = prev2\
    \ :+ cur\n                            }\n                            else dp(i)(j)\
    \ = prev2 :+ cur\n                        }\n                        else if (prev2.length\
    \ == k) {\n                            if (cur < prev2"]
stop_tokens:
- "\n    }\n"
