name: HumanEval_129_minPath
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Given a grid with N rows and N columns (N >= 2) and a positive integer k,\
  \ \n    // each cell of the grid contains a value. Every integer in the range [1,\
  \ N * N]\n    // inclusive appears exactly once on the cells of the grid.\n    //\
  \ You have to find the minimum path of length k in the grid. You can start\n   \
  \ // from any cell, and in each step you can move to any of the neighbor cells,\n\
  \    // in other words, you can go to cells which share an edge with you current\n\
  \    // cell.\n    // Please note that a path of length k means visiting exactly\
  \ k cells (not\n    // necessarily distinct).\n    // You CANNOT go off the grid.\n\
  \    // A path A (of length k) is considered less than a path B (of length k) if\n\
  \    // after making the ordered lists of the values on the cells that A and B go\n\
  \    // through (let's call them lst_A and lst_B), lst_A is lexicographically less\n\
  \    // than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n\
  \    // such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    //\
  \ lst_A[j] = lst_B[j].\n    // It is guaranteed that the answer is unique.\n   \
  \ // Return an ordered list of the values on the cells that the minimum path go\
  \ through.\n    // Examples:    \n    // >>> minPath((List[List[Long]](List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong), List[Long](4l.toLong, 5l.toLong, 6l.toLong), List[Long](7l.toLong,\
  \ 8l.toLong, 9l.toLong))), (3l))\n    // (List[Long](1l.toLong, 2l.toLong, 1l.toLong))\n\
  \    // >>> minPath((List[List[Long]](List[Long](5l.toLong, 9l.toLong, 3l.toLong),\
  \ List[Long](4l.toLong, 1l.toLong, 6l.toLong), List[Long](7l.toLong, 8l.toLong,\
  \ 2l.toLong))), (1l))\n    // (List[Long](1l.toLong))\n    def minPath(grid : List[List[Long]],\
  \ k : Long) : List[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(minPath((List[List[Long]](List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong), List[Long](4l.toLong, 5l.toLong, 6l.toLong), List[Long](7l.toLong,\
  \ 8l.toLong, 9l.toLong))), (3l)).equals((List[Long](1l.toLong, 2l.toLong, 1l.toLong))));\n\
  \    assert(minPath((List[List[Long]](List[Long](5l.toLong, 9l.toLong, 3l.toLong),\
  \ List[Long](4l.toLong, 1l.toLong, 6l.toLong), List[Long](7l.toLong, 8l.toLong,\
  \ 2l.toLong))), (1l)).equals((List[Long](1l.toLong))));\n    assert(minPath((List[List[Long]](List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong), List[Long](5l.toLong, 6l.toLong, 7l.toLong,\
  \ 8l.toLong), List[Long](9l.toLong, 10l.toLong, 11l.toLong, 12l.toLong), List[Long](13l.toLong,\
  \ 14l.toLong, 15l.toLong, 16l.toLong))), (4l)).equals((List[Long](1l.toLong, 2l.toLong,\
  \ 1l.toLong, 2l.toLong))));\n    assert(minPath((List[List[Long]](List[Long](6l.toLong,\
  \ 4l.toLong, 13l.toLong, 10l.toLong), List[Long](5l.toLong, 7l.toLong, 12l.toLong,\
  \ 1l.toLong), List[Long](3l.toLong, 16l.toLong, 11l.toLong, 15l.toLong), List[Long](8l.toLong,\
  \ 14l.toLong, 9l.toLong, 2l.toLong))), (7l)).equals((List[Long](1l.toLong, 10l.toLong,\
  \ 1l.toLong, 10l.toLong, 1l.toLong, 10l.toLong, 1l.toLong))));\n    assert(minPath((List[List[Long]](List[Long](8l.toLong,\
  \ 14l.toLong, 9l.toLong, 2l.toLong), List[Long](6l.toLong, 4l.toLong, 13l.toLong,\
  \ 15l.toLong), List[Long](5l.toLong, 7l.toLong, 1l.toLong, 12l.toLong), List[Long](3l.toLong,\
  \ 10l.toLong, 11l.toLong, 16l.toLong))), (5l)).equals((List[Long](1l.toLong, 7l.toLong,\
  \ 1l.toLong, 7l.toLong, 1l.toLong))));\n    assert(minPath((List[List[Long]](List[Long](11l.toLong,\
  \ 8l.toLong, 7l.toLong, 2l.toLong), List[Long](5l.toLong, 16l.toLong, 14l.toLong,\
  \ 4l.toLong), List[Long](9l.toLong, 3l.toLong, 15l.toLong, 6l.toLong), List[Long](12l.toLong,\
  \ 13l.toLong, 10l.toLong, 1l.toLong))), (9l)).equals((List[Long](1l.toLong, 6l.toLong,\
  \ 1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong, 1l.toLong))));\n\
  \    assert(minPath((List[List[Long]](List[Long](12l.toLong, 13l.toLong, 10l.toLong,\
  \ 1l.toLong), List[Long](9l.toLong, 3l.toLong, 15l.toLong, 6l.toLong), List[Long](5l.toLong,\
  \ 16l.toLong, 14l.toLong, 4l.toLong), List[Long](11l.toLong, 8l.toLong, 7l.toLong,\
  \ 2l.toLong))), (12l)).equals((List[Long](1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong,\
  \ 1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong))));\n\
  \    assert(minPath((List[List[Long]](List[Long](2l.toLong, 7l.toLong, 4l.toLong),\
  \ List[Long](3l.toLong, 1l.toLong, 5l.toLong), List[Long](6l.toLong, 8l.toLong,\
  \ 9l.toLong))), (8l)).equals((List[Long](1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong,\
  \ 1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(minPath((List[List[Long]](List[Long](6l.toLong,\
  \ 1l.toLong, 5l.toLong), List[Long](3l.toLong, 8l.toLong, 9l.toLong), List[Long](2l.toLong,\
  \ 7l.toLong, 4l.toLong))), (8l)).equals((List[Long](1l.toLong, 5l.toLong, 1l.toLong,\
  \ 5l.toLong, 1l.toLong, 5l.toLong, 1l.toLong, 5l.toLong))));\n    assert(minPath((List[List[Long]](List[Long](1l.toLong,\
  \ 2l.toLong), List[Long](3l.toLong, 4l.toLong))), (10l)).equals((List[Long](1l.toLong,\
  \ 2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong,\
  \ 2l.toLong))));\n    assert(minPath((List[List[Long]](List[Long](1l.toLong, 3l.toLong),\
  \ List[Long](3l.toLong, 2l.toLong))), (10l)).equals((List[Long](1l.toLong, 3l.toLong,\
  \ 1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
  \    }\n\n}\n"
completions: ["        // Write your code here\n        return List[Long]()", "  \
    \      // Write your code here\n        var n = grid.length\n        var m = grid(0).length\n\
    \        var dp = Array.ofDim[Long](n, m, k.toInt + 1)\n        for (i <- 0 until\
    \ n) {\n            for (j <- 0 until m) {\n                for (l <- 0 to k.toInt)\
    \ {\n                    dp(i)(j)(l) = Long.MaxValue\n                }\n    \
    \        }\n        }\n        for (i <- 0 until n) {\n            for (j <- 0\
    \ until m) {\n                dp(i)(j)(1) = grid(i)(j)\n            }\n      \
    \  }\n        for (l <- 2 to k.toInt) {\n            for (i <- 0 until n) {\n\
    \                for (j <- 0 until m) {\n                    if (i > 0) dp(i)(j)(l)\
    \ = min(dp(i)(j)(l), dp(i - 1)(j)(l - 1))\n                    if (i < n - 1)\
    \ dp(i)(j)(l) = min(dp(i)(j)(l), dp(i + 1)(j)(l - 1))\n                    if\
    \ (j > 0) dp(i)(j)(l) = min(dp(i)(j)(l), dp(i)(j - 1)(l - 1))\n              \
    \      if (j < m - 1) dp(i)(j)(l) = min(dp(i)(j)(l), dp(i)(j + 1)(l - 1))\n  \
    \              }\n            }\n        }\n        var ans = Long.MaxValue\n\
    \        var x = 0\n        var y = 0\n        for (i <- 0 until n) {\n      \
    \      for (j <- 0 until m) {\n                if (dp(i)(j)(k.toInt) < ans) {\n\
    \                    ans = dp(i)(j)(k.toInt)\n                    x = i\n    \
    \                y = j\n                }\n            }\n        }\n        var\
    \ result = List[Long]()\n        result = result :+ ans\n        for (l <- k.toInt\
    \ - 1 to 1 by -1) {\n            if (x > 0 && d", "        // Your code here\n\
    \        ???", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.fill(n, m)(List[Long]())\n        for (i <- 0 until n)\
    \ {\n            for (j <- 0 until m) {\n                if (i == 0 && j == 0)\
    \ dp(i)(j) = List(grid(i)(j))\n                else {\n                    var\
    \ min = List[Long]()\n                    if (i > 0) {\n                     \
    \   if (dp(i - 1)(j).length < k) min = dp(i - 1)(j)\n                        else\
    \ if (dp(i - 1)(j).length == k) min = if (dp(i - 1)(j) < min) dp(i - 1)(j) else\
    \ min\n                    }\n                    if (j > 0) {\n             \
    \           if (dp(i)(j - 1).length < k) min = dp(i)(j - 1)\n                \
    \        else if (dp(i)(j - 1).length == k) min = if (dp(i)(j - 1) < min) dp(i)(j\
    \ - 1) else min\n                    }\n                    if (min.length < k)\
    \ dp(i)(j) = min :+ grid(i)(j)\n                    else if (min.length == k)\
    \ dp(i)(j) = if (min :+ grid(i)(j) < dp(i)(j)) min :+ grid(i)(j) else dp(i)(j)\n\
    \                }\n            }\n        }\n        dp(n - 1)(m - 1)", "   \
    \     // Write your code here\n        return List[Long]()", "        // Write\
    \ your code here\n        // Return the ordered list of the values on the cells\
    \ that the minimum path go through.\n        val n = grid.length\n        val\
    \ m = grid(0).length\n        val dp = Array.ofDim[Long](n, m, k.toInt + 1)\n\
    \        for (i <- 0 until n; j <- 0 until m; l <- 0 to k.toInt) {\n         \
    \   dp(i)(j)(l) = Long.MaxValue\n        }\n        for (i <- 0 until n; j <-\
    \ 0 until m) {\n            dp(i)(j)(1) = grid(i)(j)\n        }\n        for (l\
    \ <- 2 to k.toInt) {\n            for (i <- 0 until n; j <- 0 until m) {\n   \
    \             if (i > 0) dp(i)(j)(l) = min(dp(i)(j)(l), dp(i - 1)(j)(l - 1))\n\
    \                if (i < n - 1) dp(i)(j)(l) = min(dp(i)(j)(l), dp(i + 1)(j)(l\
    \ - 1))\n                if (j > 0) dp(i)(j)(l) = min(dp(i)(j)(l), dp(i)(j - 1)(l\
    \ - 1))\n                if (j < m - 1) dp(i)(j)(l) = min(dp(i)(j)(l), dp(i)(j\
    \ + 1)(l - 1))\n            }\n        }\n        var min = Long.MaxValue\n  \
    \      var min_i = -1\n        var min_j = -1\n        for (i <- 0 until n; j\
    \ <- 0 until m) {\n            if (dp(i)(j)(k.toInt) < min) {\n              \
    \  min = dp(i)(j)(k.toInt)\n                min_i = i\n                min_j =\
    \ j\n            }\n        }\n        val ans = ListBuffer[Long]()\n        ans\
    \ += grid(min_i)(min_j)\n        var cur_i = min_i\n        var cur_j = min_j\n\
    \        for (l <- k.toInt -", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.fill(n, m)(List[Long]())\n        for (i <- 0 until n)\
    \ {\n            for (j <- 0 until m) {\n                dp(i)(j) = List(grid(i)(j))\n\
    \                if (i > 0 && dp(i - 1)(j).length < k && dp(i - 1)(j) < dp(i)(j))\
    \ dp(i)(j) = dp(i - 1)(j)\n                if (j > 0 && dp(i)(j - 1).length <\
    \ k && dp(i)(j - 1) < dp(i)(j)) dp(i)(j) = dp(i)(j - 1)\n            }\n     \
    \   }\n        dp(n - 1)(m - 1)", "        // Write your code here\n        //\
    \ Return the ordered list of the values on the cells that the minimum path go\
    \ through.\n        null", "        // Write your code here\n        val n = grid.length\n\
    \        val m = grid(0).length\n        val dp = Array.ofDim[Long](n, m, k.toInt\
    \ + 1)\n        for (i <- 0 until n; j <- 0 until m; l <- 0 to k.toInt) {\n  \
    \          if (l == 0) dp(i)(j)(l) = 0\n            else {\n                var\
    \ min = Long.MaxValue\n                if (i > 0) min = min min (dp(i - 1)(j)(l\
    \ - 1) + grid(i)(j))\n                if (j > 0) min = min min (dp(i)(j - 1)(l\
    \ - 1) + grid(i)(j))\n                if (i < n - 1) min = min min (dp(i + 1)(j)(l\
    \ - 1) + grid(i)(j))\n                if (j < m - 1) min = min min (dp(i)(j +\
    \ 1)(l - 1) + grid(i)(j))\n                dp(i)(j)(l) = min\n            }\n\
    \        }\n        var min = Long.MaxValue\n        var min_i = -1\n        var\
    \ min_j = -1\n        for (i <- 0 until n; j <- 0 until m) {\n            if (dp(i)(j)(k.toInt)\
    \ < min) {\n                min = dp(i)(j)(k.toInt)\n                min_i = i\n\
    \                min_j = j\n            }\n        }\n        var i = min_i\n\
    \        var j = min_j\n        var l = k.toInt\n        val result = ListBuffer[Long]()\n\
    \        while (l > 0) {\n            result += grid(i)(j)\n            l -= 1\n\
    \            if (i > 0 && dp(i - 1)(j)(l) + grid(i)(j) == dp(i)(j)(l + 1)) i -=\
    \ 1\n            else if (j > 0 && dp(i)(j - 1)(l) + grid(i)(j) == dp(i)(j)(l\
    \ + 1)) j -= 1\n            else if (i < n - 1 && d", "        val n = grid.length\n\
    \        val m = grid(0).length\n        val dp = Array.fill(n, m)(List[Long]())\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n        \
    \        dp(i)(j) = List[Long](grid(i)(j))\n                if (i > 0 && dp(i\
    \ - 1)(j).length > 0 && dp(i - 1)(j).length + 1 <= k) {\n                    val\
    \ lst = dp(i - 1)(j) :+ grid(i)(j)\n                    if (dp(i)(j).length ==\
    \ 0 || lst < dp(i)(j)) dp(i)(j) = lst\n                }\n                if (j\
    \ > 0 && dp(i)(j - 1).length > 0 && dp(i)(j - 1).length + 1 <= k) {\n        \
    \            val lst = dp(i)(j - 1) :+ grid(i)(j)\n                    if (dp(i)(j).length\
    \ == 0 || lst < dp(i)(j)) dp(i)(j) = lst\n                }\n            }\n \
    \       }\n        dp(n - 1)(m - 1)", "        // Your code here\n        return\
    \ List[Long]()", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.fill(n, m)(List[Long]())\n        for (i <- 0 until n)\
    \ {\n            for (j <- 0 until m) {\n                if (i == 0 && j == 0)\
    \ dp(i)(j) = List(grid(i)(j))\n                else if (i == 0) dp(i)(j) = (dp(i)(j\
    \ - 1) :+ grid(i)(j)).sorted\n                else if (j == 0) dp(i)(j) = (dp(i\
    \ - 1)(j) :+ grid(i)(j)).sorted\n                else dp(i)(j) = (dp(i - 1)(j)\
    \ :+ grid(i)(j)).sorted.take(k.toInt)\n                if (dp(i)(j).length > k.toInt)\
    \ dp(i)(j) = dp(i)(j).take(k.toInt)\n                if (j > 0) {\n          \
    \          val tmp = (dp(i)(j - 1) :+ grid(i)(j)).sorted\n                   \
    \ if (tmp.length > k.toInt) tmp.take(k.toInt)\n                    if (tmp < dp(i)(j))\
    \ dp(i)(j) = tmp\n                }\n            }\n        }\n        dp(n -\
    \ 1)(m - 1)", "        // Write your code here\n        var result = List[Long]()\n\
    \        var min = Long.MaxValue\n        for (i <- 0 until grid.length) {\n \
    \           for (j <- 0 until grid(i).length) {\n                val path = find(grid,\
    \ i, j, k, List[Long]())\n                if (path._1 < min) {\n             \
    \       min = path._1\n                    result = path._2\n                }\n\
    \            }\n        }\n        result", "        // Your code here\n     \
    \   return List[Long]()", "        // Write your code here\n        // Return\
    \ the ordered list of the values on the cells that the minimum path go through\n\
    \        val n = grid.length\n        val m = grid(0).length\n        val dp =\
    \ Array.ofDim[Long](n, m, k.toInt + 1)\n        val path = Array.ofDim[Int](n,\
    \ m, k.toInt + 1)\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                dp(i)(j)(1) = grid(i)(j)\n                path(i)(j)(1)\
    \ = -1\n            }\n        }\n        for (l <- 2 to k.toInt) {\n        \
    \    for (i <- 0 until n) {\n                for (j <- 0 until m) {\n        \
    \            dp(i)(j)(l) = Long.MaxValue\n                    for (x <- 0 until\
    \ n) {\n                        for (y <- 0 until m) {\n                     \
    \       if (abs(x - i) + abs(y - j) == 1) {\n                                if\
    \ (dp(x)(y)(l - 1) + grid(i)(j) < dp(i)(j)(l)) {\n                           \
    \         dp(i)(j)(l) = dp(x)(y)(l - 1) + grid(i)(j)\n                       \
    \             path(i)(j)(l) = x * m + y\n                                }\n \
    \                           }\n                        }\n                   \
    \ }\n                }\n            }\n        }\n        var min = Long.MaxValue\n\
    \        var minI = -1\n        var minJ = -1\n        for (i <- 0 until n) {\n\
    \            for (j <- 0 until m) {\n                if (dp(i)(j)(k.toInt) < min)\
    \ {\n                    min = dp(i)(j)(k.toInt)\n                    minI = i\n\
    \                    minJ = j\n                }\n            }\n        }\n \
    \       var ans = List[Long]()\n        var cur = k.toInt\n        while (cur\
    \ >= 1) {\n            ans = grid(minI)(minJ) :: ans\n            val next = path(minI)(minJ)(cur)\n\
    \           ", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.fill(n, m)(List[Long]())\n        for (i <- 0 until n)\
    \ {\n            for (j <- 0 until m) {\n                dp(i)(j) = List(grid(i)(j))\n\
    \                if (i > 0 && dp(i - 1)(j).length + 1 <= k) {\n              \
    \      if (dp(i - 1)(j).length + 1 == k) {\n                        if (dp(i -\
    \ 1)(j) < dp(i)(j)) dp(i)(j) = dp(i - 1)(j) :+ grid(i)(j)\n                  \
    \  } else {\n                        if (dp(i - 1)(j) < dp(i)(j)) dp(i)(j) = dp(i\
    \ - 1)(j) :+ grid(i)(j)\n                    }\n                }\n          \
    \      if (j > 0 && dp(i)(j - 1).length + 1 <= k) {\n                    if (dp(i)(j\
    \ - 1).length + 1 == k) {\n                        if (dp(i)(j - 1) < dp(i)(j))\
    \ dp(i)(j) = dp(i)(j - 1) :+ grid(i)(j)\n                    } else {\n      \
    \                  if (dp(i)(j - 1) < dp(i)(j)) dp(i)(j) = dp(i)(j - 1) :+ grid(i)(j)\n\
    \                    }\n                }\n            }\n        }\n        dp(n\
    \ - 1)(m - 1)", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.fill(n, m)(List[Long]())\n        for (i <- 0 until n)\
    \ {\n            for (j <- 0 until m) {\n                if (i == 0 && j == 0)\
    \ dp(i)(j) = List(grid(i)(j))\n                else {\n                    val\
    \ up = if (i > 0) dp(i - 1)(j) else List[Long]()\n                    val left\
    \ = if (j > 0) dp(i)(j - 1) else List[Long]()\n                    if (up.length\
    \ == 0 && left.length == 0) dp(i)(j) = List(grid(i)(j))\n                    else\
    \ if (up.length == 0) dp(i)(j) = grid(i)(j) :: left\n                    else\
    \ if (left.length == 0) dp(i)(j) = grid(i)(j) :: up\n                    else\
    \ if (up.length < left.length) dp(i)(j) = grid(i)(j) :: up\n                 \
    \   else if (up.length > left.length) dp(i)(j) = grid(i)(j) :: left\n        \
    \            else {\n                        val up_min = up.min\n           \
    \             val left_min = left.min\n                        if (up_min < left_min)\
    \ dp(i)(j) = grid(i)(j) :: up\n                        else if (up_min > left_min)\
    \ dp(i)(j) = grid(i)(j) :: left\n                        else dp(i)(j) = grid(i)(j)\
    \ :: (if (up < left) up else left)\n                    }\n                }\n\
    \            }\n        }\n        dp(n - 1)(m - 1).take(k.toInt)", "        //\
    \ Your code here\n        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.ofDim[Long](n, m, k.toInt + 1)\n        val path = Array.ofDim[Int](n,\
    \ m, k.toInt + 1)\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                dp(i)(j)(1) = grid(i)(j)\n                path(i)(j)(1)\
    \ = -1\n            }\n        }\n        for (l <- 2 to k.toInt) {\n        \
    \    for (i <- 0 until n) {\n                for (j <- 0 until m) {\n        \
    \            dp(i)(j)(l) = Long.MaxValue\n                    path(i)(j)(l) =\
    \ -1\n                    if (i > 0 && dp(i - 1)(j)(l - 1) < dp(i)(j)(l)) {\n\
    \                        dp(i)(j)(l) = dp(i - 1)(j)(l - 1)\n                 \
    \       path(i)(j)(l) = 0\n                    }\n                    if (i <\
    \ n - 1 && dp(i + 1)(j)(l - 1) < dp(i)(j)(l)) {\n                        dp(i)(j)(l)\
    \ = dp(i + 1)(j)(l - 1)\n                        path(i)(j)(l) = 1\n         \
    \           }\n                    if (j > 0 && dp(i)(j - 1)(l - 1) < dp(i)(j)(l))\
    \ {\n                        dp(i)(j)(l) = dp(i)(j - 1)(l - 1)\n             \
    \           path(i)(j)(l) = 2\n                    }\n                    if (j\
    \ < m - 1 && dp(i)(j + 1)(l - 1) < dp(i)(j)(l)) {\n                        dp(i)(j)(l)\
    \ = dp(i)(j + 1)(l - 1)\n                        path(i)(j)(l) = 3\n         \
    \           }\n                    dp(i)(j)(l) += grid(i)(j)\n               \
    \ }\n            }\n", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.fill(n, m)(List[Long]())\n        for (i <- 0 until n)\
    \ {\n            for (j <- 0 until m) {\n                if (i == 0 && j == 0)\
    \ dp(i)(j) = List(grid(i)(j))\n                else {\n                    val\
    \ l = if (i > 0) dp(i - 1)(j) else List[Long]()\n                    val u = if\
    \ (j > 0) dp(i)(j - 1) else List[Long]()\n                    val lu = if (i >\
    \ 0 && j > 0) dp(i - 1)(j - 1) else List[Long]()\n                    val lu_\
    \ = if (i > 0 && j > 0) dp(i - 1)(j - 1) else List[Long]()\n                 \
    \   val l_ = if (i > 0) dp(i - 1)(j) else List[Long]()\n                    val\
    \ u_ = if (j > 0) dp(i)(j - 1) else List[Long]()\n                    val lu__\
    \ = if (i > 0 && j > 0) dp(i - 1)(j - 1) else List[Long]()\n                 \
    \   val lu___ = if (i > 0 && j > 0) dp(i - 1)(j - 1) else List[Long]()\n     \
    \               if (l.length < k && u.length < k && lu.length < k) {\n       \
    \                 dp(i)(j) = List(grid(i)(j))\n                    }\n       \
    \             else if (l.length < k && u.length < k && lu.length == k) {\n   \
    \                     dp(i)(j) = List(grid(i)(j))\n                    }\n   \
    \                 else if (l.length < k && u.length == k && lu.length < k) {\n\
    \                        dp(i)(j) = List(grid(i)(j))\n                    }\n\
    \                    else if (l.length < k && u.length == k && lu.length == k)\
    \ {\n                        dp(i)(j) = List(grid(i)(j))", "        val n = grid.length\n\
    \        val m = grid(0).length\n        val dp = Array.fill(n, m)(List[Long]())\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n        \
    \        val cur = grid(i)(j)\n                if (i == 0 && j == 0) dp(i)(j)\
    \ = List(cur)\n                else if (i == 0) {\n                    val prev\
    \ = dp(i)(j - 1)\n                    if (prev.length < k) dp(i)(j) = prev :+\
    \ cur\n                    else if (prev.length == k) {\n                    \
    \    if (cur < prev.last) dp(i)(j) = prev.init :+ cur\n                      \
    \  else dp(i)(j) = prev\n                    }\n                    else dp(i)(j)\
    \ = prev\n                }\n                else if (j == 0) {\n            \
    \        val prev = dp(i - 1)(j)\n                    if (prev.length < k) dp(i)(j)\
    \ = prev :+ cur\n                    else if (prev.length == k) {\n          \
    \              if (cur < prev.last) dp(i)(j) = prev.init :+ cur\n            \
    \            else dp(i)(j) = prev\n                    }\n                   \
    \ else dp(i)(j) = prev\n                }\n                else {\n          \
    \          val prev1 = dp(i - 1)(j)\n                    val prev2 = dp(i)(j -\
    \ 1)\n                    if (prev1.length < k) {\n                        if\
    \ (prev2.length < k) {\n                            if (prev1.length < prev2.length)\
    \ dp(i)(j) = prev1 :+ cur\n                            else if (prev1.length ==\
    \ prev2.length) {\n                                if (prev1.last < prev2.last)\
    \ dp(i)(j) = prev1 :+ cur\n                                else dp(i)(j) = prev2\
    \ :+ cur\n                            }\n                            else dp(i)(j)\
    \ = prev2 :+ cur\n                        }\n                        else if (prev2.length\
    \ == k) {\n                            if (cur < prev2", "        // Your code\
    \ here\n        return List[Long]()", "        // Fill in the code here\n    \
    \    null", "        val n = grid.length\n        val m = grid(0).length\n   \
    \     val dp = Array.fill(n, m)(List[Long]())\n        for (i <- 0 until n) {\n\
    \            for (j <- 0 until m) {\n                if (i == 0 && j == 0) dp(i)(j)\
    \ = List(grid(i)(j))\n                else if (i == 0) {\n                   \
    \ dp(i)(j) = (dp(i)(j - 1) :+ grid(i)(j)).sorted\n                }\n        \
    \        else if (j == 0) {\n                    dp(i)(j) = (dp(i - 1)(j) :+ grid(i)(j)).sorted\n\
    \                }\n                else {\n                    val l1 = dp(i\
    \ - 1)(j) :+ grid(i)(j)\n                    val l2 = dp(i)(j - 1) :+ grid(i)(j)\n\
    \                    if (l1.sorted < l2.sorted) dp(i)(j) = l1.sorted\n       \
    \             else dp(i)(j) = l2.sorted\n                }\n            }\n  \
    \      }\n        dp(n - 1)(m - 1).take(k.toInt)", "        // Write your code\
    \ here\n        val n = grid.length\n        val m = grid(0).length\n        val\
    \ dp = Array.ofDim[Long](n, m, k.toInt + 1)\n        for (i <- 0 until n; j <-\
    \ 0 until m; l <- 0 to k.toInt) {\n            dp(i)(j)(l) = Long.MaxValue\n \
    \       }\n        for (i <- 0 until n; j <- 0 until m) {\n            dp(i)(j)(1)\
    \ = grid(i)(j)\n        }\n        for (l <- 2 to k.toInt) {\n            for\
    \ (i <- 0 until n; j <- 0 until m) {\n                for (x <- 0 until n; y <-\
    \ 0 until m) {\n                    if (abs(i - x) + abs(j - y) == 1) {\n    \
    \                    dp(i)(j)(l) = min(dp(i)(j)(l), dp(x)(y)(l - 1) + grid(i)(j))\n\
    \                    }\n                }\n            }\n        }\n        var\
    \ min = Long.MaxValue\n        var minx = 0\n        var miny = 0\n        for\
    \ (i <- 0 until n; j <- 0 until m) {\n            if (dp(i)(j)(k.toInt) < min)\
    \ {\n                min = dp(i)(j)(k.toInt)\n                minx = i\n     \
    \           miny = j\n            }\n        }\n        val ans = ListBuffer[Long]()\n\
    \        ans += grid(minx)(miny)\n        var l = k.toInt - 1\n        while (l\
    \ > 0) {\n            for (x <- 0 until n; y <- 0 until m) {\n               \
    \ if (abs(minx - x) + abs(miny - y) == 1 && dp(minx)(miny)(l + 1) == dp(x)(y)(l)\
    \ + grid(minx)(miny)) {\n                    ans += grid(x)(y)\n             \
    \       minx = x\n                    miny = y\n                    l -= 1\n \
    \               }\n            }\n        }\n        ans.toList", "        //\
    \ Your code here\n        return List[Long]()", "        // Your code here\n \
    \       null", "        // Your code here\n        return List[Long]()", "   \
    \     // Write your code here\n        // Return the ordered list of the values\
    \ on the cells that the minimum path go through\n        var result : List[Long]\
    \ = List[Long]()\n        var min : Long = Long.MaxValue\n        var minPath\
    \ : List[Long] = List[Long]()\n        for (i <- 0 until grid.length) {\n    \
    \        for (j <- 0 until grid(i).length) {\n                var path : List[Long]\
    \ = List[Long]()\n                var visited : Array[Array[Boolean]] = Array.ofDim[Boolean](grid.length,\
    \ grid(0).length)\n                for (x <- 0 until grid.length) {\n        \
    \            for (y <- 0 until grid(x).length) {\n                        visited(x)(y)\
    \ = false\n                    }\n                }\n                visited(i)(j)\
    \ = true\n                path = path :+ grid(i)(j)\n                dfs(grid,\
    \ i, j, k - 1, visited, path, min, minPath)\n            }\n        }\n      \
    \  return minPath", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.fill(n, m)(List[Long]())\n        for (i <- 0 until n)\
    \ {\n            for (j <- 0 until m) {\n                val v = grid(i)(j)\n\
    \                if (i == 0 && j == 0) dp(i)(j) = List(v)\n                else\
    \ if (i == 0) {\n                    if (dp(i)(j - 1).length < k) dp(i)(j) = dp(i)(j\
    \ - 1) :+ v\n                    else if (dp(i)(j - 1).length == k) dp(i)(j) =\
    \ dp(i)(j - 1)\n                    else if (dp(i)(j - 1).length > k) {\n    \
    \                    val lst = dp(i)(j - 1)\n                        val lst1\
    \ = lst.take(k.toInt - 1) :+ v\n                        if (lst1 < lst) dp(i)(j)\
    \ = lst1\n                        else dp(i)(j) = lst\n                    }\n\
    \                }\n                else if (j == 0) {\n                    if\
    \ (dp(i - 1)(j).length < k) dp(i)(j) = dp(i - 1)(j) :+ v\n                   \
    \ else if (dp(i - 1)(j).length == k) dp(i)(j) = dp(i - 1)(j)\n               \
    \     else if (dp(i - 1)(j).length > k) {\n                        val lst = dp(i\
    \ - 1)(j)\n                        val lst1 = lst.take(k.toInt - 1) :+ v\n   \
    \                     if (lst1 < lst) dp(i)(j) = lst1\n                      \
    \  else dp(i)(j) = lst\n                    }\n                }\n           \
    \     else {\n                    val lst1 = if (dp(i - 1)(j).length < k) dp(i\
    \ - 1)(j) :+ v else dp(i - 1)(j)\n                    val lst2 = if (dp(i)(j -\
    \ 1).length <", "        // Write your code here\n        var result = List[Long]()\n\
    \        var min = Long.MaxValue\n        for (i <- 0 until grid.length) {\n \
    \           for (j <- 0 until grid(i).length) {\n                var path = List[Long]()\n\
    \                var visited = Array.ofDim[Boolean](grid.length, grid(0).length)\n\
    \                dfs(grid, i, j, k, path, visited)\n                if (path.length\
    \ == k) {\n                    if (path.sum < min) {\n                       \
    \ min = path.sum\n                        result = path\n                    }\n\
    \                }\n            }\n        }\n        result", "        // Your\
    \ code here\n        null", "        // Your code here\n        return List[Long]()",
  "        // Your code here\n        return List[Long]()", "        // Write your\
    \ code here\n        // Return the list of values on the cells that the minimum\
    \ path go through\n        return List[Long]()", "        val n = grid.length\n\
    \        val m = grid(0).length\n        val dp = Array.fill(n, m)(List[Long]())\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n        \
    \        if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n                else\
    \ if (i == 0) {\n                    val l = dp(i)(j - 1)\n                  \
    \  if (l.length < k) dp(i)(j) = l :+ grid(i)(j)\n                    else if (l.length\
    \ == k) {\n                        if (l.last > grid(i)(j)) dp(i)(j) = l.init\
    \ :+ grid(i)(j)\n                        else dp(i)(j) = l\n                 \
    \   }\n                    else dp(i)(j) = l\n                }\n            \
    \    else if (j == 0) {\n                    val l = dp(i - 1)(j)\n          \
    \          if (l.length < k) dp(i)(j) = l :+ grid(i)(j)\n                    else\
    \ if (l.length == k) {\n                        if (l.last > grid(i)(j)) dp(i)(j)\
    \ = l.init :+ grid(i)(j)\n                        else dp(i)(j) = l\n        \
    \            }\n                    else dp(i)(j) = l\n                }\n   \
    \             else {\n                    val l1 = dp(i - 1)(j)\n            \
    \        val l2 = dp(i)(j - 1)\n                    if (l1.length < k) {\n   \
    \                     if (l2.length < k) {\n                            if (l1.last\
    \ < l2.last) dp(i)(j) = l1 :+ grid(i)(j)\n                            else dp(i)(j)\
    \ = l2 :+ grid(i)(j)\n                        }\n                        else\
    \ dp(i)(j) = l1 :+ grid(i)(j)\n                    }\n                    else\
    \ if (l1.length == k) {\n                        if (l2.length < k) {\n      \
    \                      if (l1.", "        val n = grid.length\n        val m =\
    \ grid(0).length\n        val dp = Array.fill(n, m)(List[Long]())\n        for\
    \ (i <- 0 until n) {\n            for (j <- 0 until m) {\n                if (i\
    \ == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n                else if (i == 0)\
    \ {\n                    val prev = dp(i)(j - 1)\n                    if (prev.length\
    \ < k) dp(i)(j) = prev :+ grid(i)(j)\n                    else if (prev.length\
    \ == k) {\n                        val prev_last = prev.last\n               \
    \         if (prev_last > grid(i)(j)) dp(i)(j) = prev.init :+ grid(i)(j)\n   \
    \                     else dp(i)(j) = prev\n                    }\n          \
    \          else dp(i)(j) = prev\n                }\n                else if (j\
    \ == 0) {\n                    val prev = dp(i - 1)(j)\n                    if\
    \ (prev.length < k) dp(i)(j) = prev :+ grid(i)(j)\n                    else if\
    \ (prev.length == k) {\n                        val prev_last = prev.last\n  \
    \                      if (prev_last > grid(i)(j)) dp(i)(j) = prev.init :+ grid(i)(j)\n\
    \                        else dp(i)(j) = prev\n                    }\n       \
    \             else dp(i)(j) = prev\n                }\n                else {\n\
    \                    val prev1 = dp(i - 1)(j)\n                    val prev2 =\
    \ dp(i)(j - 1)\n                    if (prev1.length < k && prev2.length < k)\
    \ {\n                        if (prev1.length < prev2.length) dp(i)(j) = prev1\
    \ :+ grid(i)(j)\n                        else if (prev1.length > prev2.length)\
    \ dp(i)(j) = prev2 :+ grid(i)(j)\n                        else {\n           \
    \                 val prev1_last = prev1.last\n                            val\
    \ prev2_last = prev2.last\n                            if (", "        // Your\
    \ code here\n        return List[Long]()", "        // Write your code here\n\
    \        return List[Long]()", "        // Your code here\n        return List[Long]()",
  "        // Your code here\n        null", "        val n = grid.length\n      \
    \  val dp = Array.fill(n, n)(List[Long]())\n        for (i <- 0 until n) {\n \
    \           for (j <- 0 until n) {\n                dp(i)(j) = List[Long](grid(i)(j))\n\
    \                if (i > 0 && dp(i - 1)(j).length < k) {\n                   \
    \ val lst = dp(i - 1)(j) :+ grid(i)(j)\n                    if (dp(i)(j).length\
    \ > lst.length || (dp(i)(j).length == lst.length && dp(i)(j) > lst)) dp(i)(j)\
    \ = lst\n                }\n                if (j > 0 && dp(i)(j - 1).length <\
    \ k) {\n                    val lst = dp(i)(j - 1) :+ grid(i)(j)\n           \
    \         if (dp(i)(j).length > lst.length || (dp(i)(j).length == lst.length &&\
    \ dp(i)(j) > lst)) dp(i)(j) = lst\n                }\n            }\n        }\n\
    \        dp(n - 1)(n - 1)", "        // Your code here\n        val n = grid.length\n\
    \        val m = grid(0).length\n        val dp = Array.ofDim[Long](n, m, k.toInt\
    \ + 1)\n        for (i <- 0 until n; j <- 0 until m; l <- 0 to k.toInt) {\n  \
    \          if (l == 0) dp(i)(j)(l) = 0\n            else {\n                var\
    \ min = Long.MaxValue\n                if (i > 0) min = min min (dp(i - 1)(j)(l\
    \ - 1) + grid(i)(j))\n                if (j > 0) min = min min (dp(i)(j - 1)(l\
    \ - 1) + grid(i)(j))\n                if (i < n - 1) min = min min (dp(i + 1)(j)(l\
    \ - 1) + grid(i)(j))\n                if (j < m - 1) min = min min (dp(i)(j +\
    \ 1)(l - 1) + grid(i)(j))\n                dp(i)(j)(l) = min\n            }\n\
    \        }\n        var min = Long.MaxValue\n        var x = -1\n        var y\
    \ = -1\n        for (i <- 0 until n; j <- 0 until m) {\n            if (dp(i)(j)(k.toInt)\
    \ < min) {\n                min = dp(i)(j)(k.toInt)\n                x = i\n \
    \               y = j\n            }\n        }\n        var res = List[Long]()\n\
    \        for (l <- k.toInt to 1 by -1) {\n            res = grid(x)(y) :: res\n\
    \            if (x > 0 && dp(x - 1)(y)(l - 1) + grid(x)(y) == dp(x)(y)(l)) x -=\
    \ 1\n            else if (y > 0 && dp(x)(y - 1)(l - 1) + grid(x)(y) == dp(x)(y)(l))\
    \ y -= 1\n            else if (x < n - 1 && dp(x + 1)(y)(l - 1) + grid(x)(y) ==\
    \ dp(x)(y)(l)) x", "        // Write your code here\n        var result = List[Long]()\n\
    \        var min = Long.MaxValue\n        for (i <- 0 until grid.length) {\n \
    \           for (j <- 0 until grid(i).length) {\n                var path = List[Long]()\n\
    \                path = path :+ grid(i)(j)\n                var visited = Array.ofDim[Boolean](grid.length,\
    \ grid(i).length)\n                visited(i)(j) = true\n                var queue\
    \ = Queue[(Int, Int)]()\n                queue.enqueue((i, j))\n             \
    \   while (!queue.isEmpty) {\n                    var (x, y) = queue.dequeue\n\
    \                    for (dx <- -1 to 1) {\n                        for (dy <-\
    \ -1 to 1) {\n                            if (abs(dx) + abs(dy) == 1) {\n    \
    \                            var nx = x + dx\n                               \
    \ var ny = y + dy\n                                if (nx >= 0 && nx < grid.length\
    \ && ny >= 0 && ny < grid(i).length && !visited(nx)(ny)) {\n                 \
    \                   path = path :+ grid(nx)(ny)\n                            \
    \        visited(nx)(ny) = true\n                                    queue.enqueue((nx,\
    \ ny))\n                                }\n                            }\n   \
    \                     }\n                    }\n                }\n          \
    \      if (path.length == k) {\n                    var sum = 0l\n           \
    \         for (x <- path) {\n                        sum = sum * 10 + x\n    \
    \                }\n                    if (sum < min) {\n                   \
    \     min = sum\n                        result = path\n                    }\n\
    \                }\n            }\n        }\n        return result", "      \
    \  val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(Long.MaxValue)\n        val dirs = List((-1, 0), (1, 0), (0, -1), (0, 1))\n\
    \        def dfs(x : Int, y : Int, k : Long, path : List[Long]) : Unit = {\n \
    \           if (k == 0) {\n                dp(x)(y) = path.reverse.mkString.toLong\n\
    \            } else {\n                for (dir <- dirs) {\n                 \
    \   val nx = x + dir._1\n                    val ny = y + dir._2\n           \
    \         if (nx >= 0 && nx < n && ny >= 0 && ny < m) {\n                    \
    \    dfs(nx, ny, k - 1, grid(nx)(ny) :: path)\n                    }\n       \
    \         }\n            }\n        }\n        for (i <- 0 until n; j <- 0 until\
    \ m) {\n            dfs(i, j, k, List(grid(i)(j)))\n        }\n        val ans\
    \ = dp.map(_.min).min\n        ans.toString.map(_.asDigit.toLong).toList", " \
    \       // Your code here\n        return List[Long]()", "        // Your code\
    \ here\n        return List[Long]()", "        // Write your code here\n     \
    \   // Return the ordered list of the values on the cells that the minimum path\
    \ go through\n        return List[Long]()", "        val n = grid.length\n   \
    \     val m = grid(0).length\n        val dp = Array.fill(n, m)(List[Long]())\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n        \
    \        if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n                else\
    \ if (i == 0) {\n                    val lst = dp(i)(j - 1)\n                \
    \    if (lst.length == k) dp(i)(j) = lst\n                    else {\n       \
    \                 val lst2 = lst :+ grid(i)(j)\n                        if (lst2.length\
    \ == k) dp(i)(j) = lst2\n                        else {\n                    \
    \        val lst3 = lst2.sorted\n                            if (lst3.length ==\
    \ k) dp(i)(j) = lst3\n                            else dp(i)(j) = lst3.dropRight(1)\n\
    \                        }\n                    }\n                }\n       \
    \         else if (j == 0) {\n                    val lst = dp(i - 1)(j)\n   \
    \                 if (lst.length == k) dp(i)(j) = lst\n                    else\
    \ {\n                        val lst2 = lst :+ grid(i)(j)\n                  \
    \      if (lst2.length == k) dp(i)(j) = lst2\n                        else {\n\
    \                            val lst3 = lst2.sorted\n                        \
    \    if (lst3.length == k) dp(i)(j) = lst3\n                            else dp(i)(j)\
    \ = lst3.dropRight(1)\n                        }\n                    }\n    \
    \            }\n                else {\n                    val lst = dp(i - 1)(j)\n\
    \                    val lst2 = dp(i)(j - 1)\n                    if (lst.length\
    \ == k && lst2.length == k) {\n                        if (lst < lst2) dp(i)(j)\
    \ = lst\n                        else dp(i)(j) = lst2\n                    }\n\
    \                    else if (lst.", "        // Your code here\n        null",
  "        val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(List[Long]())\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                dp(i)(j) = List(grid(i)(j))\n                if (i > 0\
    \ && dp(i - 1)(j).length < k && dp(i - 1)(j) < dp(i)(j)) dp(i)(j) = dp(i - 1)(j)\n\
    \                if (j > 0 && dp(i)(j - 1).length < k && dp(i)(j - 1) < dp(i)(j))\
    \ dp(i)(j) = dp(i)(j - 1)\n            }\n        }\n        dp(n - 1)(m - 1)",
  "        val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(List[Long]())\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n  \
    \              else if (i == 0) dp(i)(j) = (dp(i)(j - 1) :+ grid(i)(j)).sorted\n\
    \                else if (j == 0) dp(i)(j) = (dp(i - 1)(j) :+ grid(i)(j)).sorted\n\
    \                else dp(i)(j) = (dp(i - 1)(j) :+ grid(i)(j)).sorted.take(k.toInt)\n\
    \                if (j > 0) {\n                    val temp = (dp(i)(j - 1) :+\
    \ grid(i)(j)).sorted.take(k.toInt)\n                    if (temp.length == k.toInt\
    \ && temp < dp(i)(j)) dp(i)(j) = temp\n                }\n            }\n    \
    \    }\n        dp(n - 1)(m - 1)", "        // Write your code here\n        //\
    \ Return the list of values on the cells that the minimum path go through\n  \
    \      // You can add more functions as you wish\n        val n = grid.length\n\
    \        val m = grid(0).length\n        val dp = Array.ofDim[Long](n, m, k.toInt\
    \ + 1)\n        for (i <- 0 until n; j <- 0 until m; l <- 0 to k.toInt) dp(i)(j)(l)\
    \ = Long.MaxValue\n        for (i <- 0 until n; j <- 0 until m) dp(i)(j)(1) =\
    \ grid(i)(j)\n        for (l <- 2 to k.toInt) {\n            for (i <- 0 until\
    \ n; j <- 0 until m) {\n                for (x <- 0 until n; y <- 0 until m) {\n\
    \                    if (i != x || j != y) {\n                        if (abs(i\
    \ - x) + abs(j - y) == 1) {\n                            dp(i)(j)(l) = min(dp(i)(j)(l),\
    \ dp(x)(y)(l - 1) + grid(i)(j))\n                        }\n                 \
    \   }\n                }\n            }\n        }\n        var ans = Long.MaxValue\n\
    \        var x = 0\n        var y = 0\n        for (i <- 0 until n; j <- 0 until\
    \ m) {\n            if (dp(i)(j)(k.toInt) < ans) {\n                ans = dp(i)(j)(k.toInt)\n\
    \                x = i\n                y = j\n            }\n        }\n    \
    \    var l = k.toInt\n        val res = ArrayBuffer[Long]()\n        while (l\
    \ > 0) {\n            res += grid(x)(y)\n            var next = Long.MaxValue\n\
    \            for (i <- 0 until n; j <- 0 until m) {\n                if (i !=\
    \ x || j != y) {\n                    if (abs(i - x) + abs(j - y) == 1) {\n  \
    \                      if (dp(i)(j)(l - 1) + grid(x)(y) == dp(x)(y)(l)) {\n  \
    \                          next = min", "        val n = grid.length\n       \
    \ val m = grid(0).length\n        val dp = Array.fill(n, m)(List[Long]())\n  \
    \      for (i <- 0 until n) {\n            for (j <- 0 until m) {\n          \
    \      if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n                else\
    \ if (i == 0) dp(i)(j) = (dp(i)(j - 1) :+ grid(i)(j)).sorted\n               \
    \ else if (j == 0) dp(i)(j) = (dp(i - 1)(j) :+ grid(i)(j)).sorted\n          \
    \      else dp(i)(j) = (dp(i - 1)(j) :+ grid(i)(j)).sorted.take(k.toInt) ::: (dp(i)(j\
    \ - 1) :+ grid(i)(j)).sorted.take(k.toInt).sorted.take(k.toInt)\n            }\n\
    \        }\n        dp(n - 1)(m - 1).take(k.toInt)", "        val n = grid.length\n\
    \        val m = grid(0).length\n        val dp = Array.fill(n, m)(List[Long]())\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n        \
    \        if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n                else\
    \ if (i == 0) dp(i)(j) = List(grid(i)(j)) ::: dp(i)(j - 1)\n                else\
    \ if (j == 0) dp(i)(j) = List(grid(i)(j)) ::: dp(i - 1)(j)\n                else\
    \ {\n                    val a = List(grid(i)(j)) ::: dp(i)(j - 1)\n         \
    \           val b = List(grid(i)(j)) ::: dp(i - 1)(j)\n                    if\
    \ (a < b) dp(i)(j) = a\n                    else dp(i)(j) = b\n              \
    \  }\n            }\n        }\n        dp(n - 1)(m - 1).take(k.toInt)", "   \
    \     // Write your code here\n        return List[Long]()", "        // Your\
    \ code here\n        return List[Long]()", "        // Write your code here\n\
    \        val n = grid.length\n        val m = grid(0).length\n        val dp =\
    \ Array.ofDim[Long](n, m, k.toInt + 1)\n        for (i <- 0 until n; j <- 0 until\
    \ m; l <- 0 to k.toInt) {\n            if (l == 0) dp(i)(j)(l) = 0\n         \
    \   else {\n                dp(i)(j)(l) = Long.MaxValue\n                if (i\
    \ > 0) dp(i)(j)(l) = min(dp(i)(j)(l), dp(i - 1)(j)(l - 1) + grid(i)(j))\n    \
    \            if (i < n - 1) dp(i)(j)(l) = min(dp(i)(j)(l), dp(i + 1)(j)(l - 1)\
    \ + grid(i)(j))\n                if (j > 0) dp(i)(j)(l) = min(dp(i)(j)(l), dp(i)(j\
    \ - 1)(l - 1) + grid(i)(j))\n                if (j < m - 1) dp(i)(j)(l) = min(dp(i)(j)(l),\
    \ dp(i)(j + 1)(l - 1) + grid(i)(j))\n            }\n        }\n        var min\
    \ = Long.MaxValue\n        var min_i = -1\n        var min_j = -1\n        for\
    \ (i <- 0 until n; j <- 0 until m) {\n            if (dp(i)(j)(k.toInt) < min)\
    \ {\n                min = dp(i)(j)(k.toInt)\n                min_i = i\n    \
    \            min_j = j\n            }\n        }\n        val path = ListBuffer[Long]()\n\
    \        var i = min_i\n        var j = min_j\n        for (l <- k.toInt to 1\
    \ by -1) {\n            path += grid(i)(j)\n            var min = Long.MaxValue\n\
    \            var min_i = -1\n            var min_j = -1\n            if (i > 0\
    \ && dp(i - 1)(j", "        // Your code here\n        return List[Long]()", " \
    \       // Your code here\n        return List[Long]()", "        // Your code\
    \ here\n        return List[Long]()", "        val n = grid.length\n        val\
    \ m = grid(0).length\n        val dp = Array.fill(n, m)(List[Long]())\n      \
    \  for (i <- 0 until n) {\n            for (j <- 0 until m) {\n              \
    \  if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n                else if\
    \ (i == 0) dp(i)(j) = (dp(i)(j - 1) :+ grid(i)(j)).sorted\n                else\
    \ if (j == 0) dp(i)(j) = (dp(i - 1)(j) :+ grid(i)(j)).sorted\n               \
    \ else dp(i)(j) = (dp(i - 1)(j) :+ grid(i)(j)).sorted.take(k.toInt)\n        \
    \        if (j > 0) {\n                    val tmp = (dp(i)(j - 1) :+ grid(i)(j)).sorted.take(k.toInt)\n\
    \                    if (tmp.length < dp(i)(j).length || (tmp.length == dp(i)(j).length\
    \ && tmp < dp(i)(j))) dp(i)(j) = tmp\n                }\n            }\n     \
    \   }\n        dp(n - 1)(m - 1)", "        // Your code here\n        null", " \
    \       // Your code here\n        return List[Long]()", "        val n = grid.length\n\
    \        val m = grid(0).length\n        val dp = Array.fill(n, m)(List[Long]())\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n        \
    \        if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n                else\
    \ if (i == 0) dp(i)(j) = (grid(i)(j) :: dp(i)(j - 1)).sorted\n               \
    \ else if (j == 0) dp(i)(j) = (grid(i)(j) :: dp(i - 1)(j)).sorted\n          \
    \      else dp(i)(j) = (grid(i)(j) :: (dp(i - 1)(j) ::: dp(i)(j - 1))).sorted.take(k.toInt)\n\
    \            }\n        }\n        dp(n - 1)(m - 1)", "        val n = grid.length\n\
    \        val m = grid(0).length\n        val dp = Array.fill(n, m)(List[Long]())\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n        \
    \        dp(i)(j) = List(grid(i)(j))\n                if (i > 0 && (dp(i - 1)(j).length\
    \ < k || (dp(i - 1)(j).length == k && dp(i - 1)(j) < dp(i)(j)))) dp(i)(j) = dp(i\
    \ - 1)(j)\n                if (j > 0 && (dp(i)(j - 1).length < k || (dp(i)(j -\
    \ 1).length == k && dp(i)(j - 1) < dp(i)(j)))) dp(i)(j) = dp(i)(j - 1)\n     \
    \       }\n        }\n        dp(n - 1)(m - 1)", "        // Your code here\n\
    \        null", "        // Fill in the code here\n        return List[Long]()",
  "        val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(List[Long]())\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n  \
    \              else if (i == 0) dp(i)(j) = (dp(i)(j - 1) :+ grid(i)(j)).sorted\n\
    \                else if (j == 0) dp(i)(j) = (dp(i - 1)(j) :+ grid(i)(j)).sorted\n\
    \                else dp(i)(j) = (dp(i - 1)(j) :+ grid(i)(j)).sorted.take(k.toInt)\
    \ ++ (dp(i)(j - 1) :+ grid(i)(j)).sorted.take(k.toInt)\n            }\n      \
    \  }\n        dp(n - 1)(m - 1).sorted.take(k.toInt)", "        // Write your code\
    \ here\n        // Return the list of values on the cells that the minimum path\
    \ go through\n        var result = List[Long]()\n        var min = Long.MaxValue\n\
    \        var minPath = List[Long]()\n        for (i <- 0 until grid.length) {\n\
    \            for (j <- 0 until grid(i).length) {\n                var path = List[Long]()\n\
    \                var visited = Array.ofDim[Boolean](grid.length, grid(0).length)\n\
    \                dfs(grid, i, j, k, path, visited)\n                if (path.length\
    \ == k) {\n                    if (path.sum < min) {\n                       \
    \ min = path.sum\n                        minPath = path\n                   \
    \ }\n                }\n            }\n        }\n        return minPath", " \
    \       val n = grid.length\n        val m = grid(0).length\n        val dp =\
    \ Array.fill(n, m)(List[Long]())\n        for (i <- 0 until n) {\n           \
    \ for (j <- 0 until m) {\n                dp(i)(j) = List[Long](grid(i)(j))\n\
    \                if (i > 0 && dp(i - 1)(j).length == k) {\n                  \
    \  val lst = dp(i - 1)(j) :+ grid(i)(j)\n                    if (lst < dp(i)(j))\
    \ dp(i)(j) = lst\n                }\n                if (j > 0 && dp(i)(j - 1).length\
    \ == k) {\n                    val lst = dp(i)(j - 1) :+ grid(i)(j)\n        \
    \            if (lst < dp(i)(j)) dp(i)(j) = lst\n                }\n         \
    \   }\n        }\n        dp(n - 1)(m - 1)", "        val n = grid.length\n  \
    \      val m = grid(0).length\n        val dp = Array.fill(n, m)(Long.MaxValue)\n\
    \        val dp2 = Array.fill(n, m)(List[Long]())\n        for (i <- 0 until n)\
    \ {\n            for (j <- 0 until m) {\n                if (i == 0 && j == 0)\
    \ {\n                    dp(i)(j) = grid(i)(j)\n                    dp2(i)(j)\
    \ = List(grid(i)(j))\n                }\n                else {\n            \
    \        if (i > 0 && dp(i - 1)(j) < dp(i)(j)) {\n                        dp(i)(j)\
    \ = dp(i - 1)(j)\n                        dp2(i)(j) = dp2(i - 1)(j)\n        \
    \            }\n                    if (j > 0 && dp(i)(j - 1) < dp(i)(j)) {\n\
    \                        dp(i)(j) = dp(i)(j - 1)\n                        dp2(i)(j)\
    \ = dp2(i)(j - 1)\n                    }\n                    if (i > 0 && j >\
    \ 0 && dp(i - 1)(j - 1) < dp(i)(j)) {\n                        dp(i)(j) = dp(i\
    \ - 1)(j - 1)\n                        dp2(i)(j) = dp2(i - 1)(j - 1)\n       \
    \             }\n                    dp(i)(j) += grid(i)(j)\n                \
    \    dp2(i)(j) = dp2(i)(j) :+ grid(i)(j)\n                }\n            }\n \
    \       }\n        var i = n - 1\n        var j = m - 1\n        while (k > 0)\
    \ {\n            if (i > 0 && dp(i - 1)(j) < dp(i)(j)) {\n                i -=\
    \ 1\n            }\n            else if (j > 0 && dp(i)(j - 1) < dp(i)(j)) {\n\
    \                j -= 1\n            }\n            else if (i > 0 && j > 0 &&\
    \ dp", "        // Your code here\n        null", "        val n = grid.length\n\
    \        val m = grid(0).length\n        val dp = Array.fill(n, m)(List[Long]())\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n        \
    \        if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n                else\
    \ if (i == 0) dp(i)(j) = (dp(i)(j - 1) :+ grid(i)(j)).sorted\n               \
    \ else if (j == 0) dp(i)(j) = (dp(i - 1)(j) :+ grid(i)(j)).sorted\n          \
    \      else dp(i)(j) = (dp(i - 1)(j) :+ grid(i)(j)).sorted.take(k.toInt)\n   \
    \             if (j > 0) {\n                    val temp = (dp(i)(j - 1) :+ grid(i)(j)).sorted.take(k.toInt)\n\
    \                    if (temp.length == k.toInt && temp < dp(i)(j)) dp(i)(j) =\
    \ temp\n                }\n            }\n        }\n        dp(n - 1)(m - 1)",
  "        val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(List[Long]())\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                val v = grid(i)(j)\n                if (i == 0 && j ==\
    \ 0) dp(i)(j) = List(v)\n                else if (i == 0) {\n                \
    \    val l = dp(i)(j - 1)\n                    if (l.length < k) dp(i)(j) = v\
    \ :: l\n                    else if (l.length == k) {\n                      \
    \  if (v < l.head) dp(i)(j) = v :: l.tail\n                        else dp(i)(j)\
    \ = l\n                    }\n                    else dp(i)(j) = l\n        \
    \        }\n                else if (j == 0) {\n                    val l = dp(i\
    \ - 1)(j)\n                    if (l.length < k) dp(i)(j) = v :: l\n         \
    \           else if (l.length == k) {\n                        if (v < l.head)\
    \ dp(i)(j) = v :: l.tail\n                        else dp(i)(j) = l\n        \
    \            }\n                    else dp(i)(j) = l\n                }\n   \
    \             else {\n                    val l1 = dp(i - 1)(j)\n            \
    \        val l2 = dp(i)(j - 1)\n                    if (l1.length < k && l2.length\
    \ < k) {\n                        if (l1.length < l2.length) dp(i)(j) = v :: l1\n\
    \                        else if (l1.length > l2.length) dp(i)(j) = v :: l2\n\
    \                        else {\n                            if (l1.head < l2.head)\
    \ dp(i)(j) = v :: l1\n                            else dp(i)(j) = v :: l2\n  \
    \                      }\n                    }\n                    else if (l1.length\
    \ < k) {\n                        if (l1.length < k - 1) dp(i)(j) = v :: l1\n",
  "        // Your code here\n        null", "        // Your code here\n        val\
    \ n = grid.length\n        val m = grid(0).length\n        val dp = Array.ofDim[Long](n,\
    \ m, k.toInt + 1)\n        for (i <- 0 until n; j <- 0 until m; l <- 0 to k.toInt)\
    \ {\n            dp(i)(j)(l) = Long.MaxValue\n        }\n        for (i <- 0 until\
    \ n; j <- 0 until m) {\n            dp(i)(j)(1) = grid(i)(j)\n        }\n    \
    \    for (l <- 2 to k.toInt) {\n            for (i <- 0 until n; j <- 0 until\
    \ m) {\n                for (x <- 0 until n; y <- 0 until m) {\n             \
    \       if (i == x && j == y) {\n                        dp(i)(j)(l) = min(dp(i)(j)(l),\
    \ dp(i)(j)(l - 1))\n                    } else {\n                        dp(i)(j)(l)\
    \ = min(dp(i)(j)(l), dp(x)(y)(l - 1) + grid(i)(j))\n                    }\n  \
    \              }\n            }\n        }\n        var min = Long.MaxValue\n\
    \        var minx = -1\n        var miny = -1\n        for (i <- 0 until n; j\
    \ <- 0 until m) {\n            if (dp(i)(j)(k.toInt) < min) {\n              \
    \  min = dp(i)(j)(k.toInt)\n                minx = i\n                miny = j\n\
    \            }\n        }\n        val dp2 = Array.ofDim[Long](n, m, k.toInt +\
    \ 1)\n        for (i <- 0 until n; j <- 0 until m; l <- 0 to k.toInt) {\n    \
    \        dp2(i)(j)(l) = Long.MaxValue\n        }\n        for (i <- 0 until n;\
    \ j <- 0 until m) {\n            dp2(i)(j)(1) = grid(i)(j)\n        }\n      \
    \  for (l <- 2 to k.toInt) {\n            for (i <- 0 until n; j", "        //\
    \ Write your code here\n        var result = List[Long]()\n        var min = Long.MaxValue\n\
    \        for (i <- 0 until grid.length) {\n            for (j <- 0 until grid(i).length)\
    \ {\n                var path = List[Long]()\n                var visited = Array.ofDim[Boolean](grid.length,\
    \ grid(0).length)\n                var queue = Queue[(Int, Int)]()\n         \
    \       queue.enqueue((i, j))\n                while (!queue.isEmpty) {\n    \
    \                var pos = queue.dequeue\n                    if (visited(pos._1)(pos._2))\
    \ {\n                        continue\n                    }\n               \
    \     visited(pos._1)(pos._2) = true\n                    path = path :+ grid(pos._1)(pos._2)\n\
    \                    if (path.length == k) {\n                        if (path.mkString(\"\
    \").toLong < min) {\n                            min = path.mkString(\"\").toLong\n\
    \                            result = path\n                        }\n      \
    \                  break\n                    }\n                    if (pos._1\
    \ > 0 && !visited(pos._1 - 1)(pos._2)) {\n                        queue.enqueue((pos._1\
    \ - 1, pos._2))\n                    }\n                    if (pos._1 < grid.length\
    \ - 1 && !visited(pos._1 + 1)(pos._2)) {\n                        queue.enqueue((pos._1\
    \ + 1, pos._2))\n                    }\n                    if (pos._2 > 0 &&\
    \ !visited(pos._1)(pos._2 - 1)) {\n                        queue.enqueue((pos._1,\
    \ pos._2 - 1))\n                    }\n                    if (pos._2 < grid(0).length\
    \ - 1 && !visited(pos._1)(pos._2 + 1)) {\n                        queue.enqueue((pos._1,\
    \ pos._2 + 1))\n                    }\n                }\n            }\n    \
    \    }\n        return result", "        // Your code here\n        null", " \
    \       // Your code here\n        return List[Long]()", "        // Your code\
    \ here\n        return List[Long]()", "        // Write your code here\n     \
    \   return List[Long]()", "        // Fill in the code here\n        null", " \
    \       val n = grid.length\n        val m = grid(0).length\n        val dp =\
    \ Array.fill(n, m)(List[Long]())\n        for (i <- 0 until n) {\n           \
    \ for (j <- 0 until m) {\n                if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n\
    \                else if (i == 0) {\n                    val lst = dp(i)(j - 1)\n\
    \                    if (lst.length < k) dp(i)(j) = List(grid(i)(j))\n       \
    \             else if (lst.length == k) {\n                        if (lst(0)\
    \ > grid(i)(j)) dp(i)(j) = List(grid(i)(j))\n                        else dp(i)(j)\
    \ = lst\n                    }\n                    else dp(i)(j) = lst\n    \
    \            }\n                else if (j == 0) {\n                    val lst\
    \ = dp(i - 1)(j)\n                    if (lst.length < k) dp(i)(j) = List(grid(i)(j))\n\
    \                    else if (lst.length == k) {\n                        if (lst(0)\
    \ > grid(i)(j)) dp(i)(j) = List(grid(i)(j))\n                        else dp(i)(j)\
    \ = lst\n                    }\n                    else dp(i)(j) = lst\n    \
    \            }\n                else {\n                    val lst1 = dp(i -\
    \ 1)(j)\n                    val lst2 = dp(i)(j - 1)\n                    if (lst1.length\
    \ < k && lst2.length < k) {\n                        if (lst1.length < lst2.length)\
    \ dp(i)(j) = List(grid(i)(j))\n                        else if (lst1.length >\
    \ lst2.length) dp(i)(j) = lst2\n                        else {\n             \
    \               if (lst1(0) < lst2(0)) dp(i)(j) = List(grid(i)(j))\n         \
    \                   else dp(i)(j) =", "        // Your code here\n        return\
    \ null", "        // Your code here\n        null", "        val n = grid.length\n\
    \        val m = grid(0).length\n        val dp = Array.fill(n, m)(Long.MaxValue)\n\
    \        val pq = new PriorityQueue[(Long, Int, Int)]()(Ordering.by(x => x._1))\n\
    \        pq.enqueue((0l, 0, 0))\n        while (!pq.isEmpty) {\n            val\
    \ (d, i, j) = pq.dequeue\n            if (dp(i)(j) > d) {\n                dp(i)(j)\
    \ = d\n                if (i > 0) pq.enqueue((d + grid(i - 1)(j), i - 1, j))\n\
    \                if (i < n - 1) pq.enqueue((d + grid(i + 1)(j), i + 1, j))\n \
    \               if (j > 0) pq.enqueue((d + grid(i)(j - 1), i, j - 1))\n      \
    \          if (j < m - 1) pq.enqueue((d + grid(i)(j + 1), i, j + 1))\n       \
    \     }\n        }\n        val result = new ListBuffer[Long]()\n        var i\
    \ = 0\n        var j = 0\n        var d = 0l\n        while (d < k) {\n      \
    \      result += grid(i)(j)\n            d += 1\n            if (i > 0 && dp(i\
    \ - 1)(j) < dp(i)(j)) {\n                i -= 1\n            } else if (i < n\
    \ - 1 && dp(i + 1)(j) < dp(i)(j)) {\n                i += 1\n            } else\
    \ if (j > 0 && dp(i)(j - 1) < dp(i)(j)) {\n                j -= 1\n          \
    \  } else if (j < m - 1 && dp(i)(j + 1) < dp(i)(j)) {\n                j += 1\n\
    \            }\n        }\n        result.toList", "        val n = grid.length\n\
    \        val m = grid(0).length\n        val dp = Array.fill(n, m)(List[Long]())\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n        \
    \        if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n                else\
    \ if (i == 0) {\n                    val prev = dp(i)(j - 1)\n               \
    \     if (prev.length < k) dp(i)(j) = prev :+ grid(i)(j)\n                   \
    \ else if (prev.length == k) {\n                        if (prev.last > grid(i)(j))\
    \ dp(i)(j) = prev.init :+ grid(i)(j)\n                        else dp(i)(j) =\
    \ prev\n                    }\n                    else dp(i)(j) = prev\n    \
    \            }\n                else if (j == 0) {\n                    val prev\
    \ = dp(i - 1)(j)\n                    if (prev.length < k) dp(i)(j) = prev :+\
    \ grid(i)(j)\n                    else if (prev.length == k) {\n             \
    \           if (prev.last > grid(i)(j)) dp(i)(j) = prev.init :+ grid(i)(j)\n \
    \                       else dp(i)(j) = prev\n                    }\n        \
    \            else dp(i)(j) = prev\n                }\n                else {\n\
    \                    val prev1 = dp(i - 1)(j)\n                    val prev2 =\
    \ dp(i)(j - 1)\n                    if (prev1.length < k) {\n                \
    \        if (prev2.length < k) {\n                            if (prev1.last <\
    \ prev2.last) dp(i)(j) = prev1 :+ grid(i)(j)\n                            else\
    \ dp(i)(j) = prev2 :+ grid(i)(j)\n                        }\n                \
    \        else if (prev2.length == k) {\n                            if (prev1.last\
    \ < prev2.last) dp(i)(j) = prev1 :+ grid(i)(j)\n                            else\
    \ if (prev1.last >", "        // Your code here\n        return List[Long]()",
  "        // Write your code here\n        return List[Long]()", "        val n =\
    \ grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(List[Long]())\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n  \
    \              else if (i == 0) {\n                    val prev = dp(i)(j - 1)\n\
    \                    if (prev.length < k) dp(i)(j) = prev :+ grid(i)(j)\n    \
    \                else if (prev.length == k) {\n                        if (prev.last\
    \ > grid(i)(j)) dp(i)(j) = prev.init :+ grid(i)(j)\n                        else\
    \ dp(i)(j) = prev\n                    }\n                    else dp(i)(j) =\
    \ prev\n                }\n                else if (j == 0) {\n              \
    \      val prev = dp(i - 1)(j)\n                    if (prev.length < k) dp(i)(j)\
    \ = prev :+ grid(i)(j)\n                    else if (prev.length == k) {\n   \
    \                     if (prev.last > grid(i)(j)) dp(i)(j) = prev.init :+ grid(i)(j)\n\
    \                        else dp(i)(j) = prev\n                    }\n       \
    \             else dp(i)(j) = prev\n                }\n                else {\n\
    \                    val prev1 = dp(i - 1)(j)\n                    val prev2 =\
    \ dp(i)(j - 1)\n                    if (prev1.length < k) {\n                \
    \        if (prev2.length < k) {\n                            if (prev1.last <\
    \ prev2.last) dp(i)(j) = prev1 :+ grid(i)(j)\n                            else\
    \ if (prev1.last > prev2.last) dp(i)(j) = prev2 :+ grid(i)(j)\n              \
    \              else dp(i)(j) = if (prev1.length < prev2.length) prev1 :+ grid(i)(j)\
    \ else prev2 :+ grid(i)(j)\n                        }", "        val n = grid.length\n\
    \        val m = grid(0).length\n        val dp = Array.fill(n, m)(Long.MaxValue)\n\
    \        val dp2 = Array.fill(n, m)(List[Long]())\n        for (i <- 0 until n)\
    \ {\n            for (j <- 0 until m) {\n                if (i == 0 && j == 0)\
    \ {\n                    dp(i)(j) = grid(i)(j)\n                    dp2(i)(j)\
    \ = List(grid(i)(j))\n                }\n                else {\n            \
    \        if (i > 0 && dp(i - 1)(j) < dp(i)(j)) {\n                        dp(i)(j)\
    \ = dp(i - 1)(j)\n                        dp2(i)(j) = dp2(i - 1)(j)\n        \
    \            }\n                    if (j > 0 && dp(i)(j - 1) < dp(i)(j)) {\n\
    \                        dp(i)(j) = dp(i)(j - 1)\n                        dp2(i)(j)\
    \ = dp2(i)(j - 1)\n                    }\n                    dp(i)(j) += grid(i)(j)\n\
    \                    dp2(i)(j) = dp2(i)(j) :+ grid(i)(j)\n                }\n\
    \            }\n        }\n        val ans = dp2(n - 1)(m - 1)\n        ans.take(k.toInt)",
  "        // Fill in the code here\n        null", "        // Your code here\n \
    \       null", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.fill(n, m)(List[Long]())\n        for (i <- 0 until n)\
    \ {\n            for (j <- 0 until m) {\n                if (i == 0 && j == 0)\
    \ dp(i)(j) = List(grid(i)(j))\n                else if (i == 0) {\n          \
    \          dp(i)(j) = dp(i)(j - 1)\n                    if (grid(i)(j) < dp(i)(j).head)\
    \ dp(i)(j) = List(grid(i)(j))\n                    else if (grid(i)(j) == dp(i)(j).head)\
    \ dp(i)(j) = grid(i)(j) :: dp(i)(j)\n                }\n                else if\
    \ (j == 0) {\n                    dp(i)(j) = dp(i - 1)(j)\n                  \
    \  if (grid(i)(j) < dp(i)(j).head) dp(i)(j) = List(grid(i)(j))\n             \
    \       else if (grid(i)(j) == dp(i)(j).head) dp(i)(j) = grid(i)(j) :: dp(i)(j)\n\
    \                }\n                else {\n                    dp(i)(j) = dp(i\
    \ - 1)(j)\n                    if (dp(i)(j - 1).head < dp(i)(j).head) dp(i)(j)\
    \ = dp(i)(j - 1)\n                    else if (dp(i)(j - 1).head == dp(i)(j).head)\
    \ {\n                        if (dp(i)(j - 1) < dp(i)(j)) dp(i)(j) = dp(i)(j -\
    \ 1)\n                    }\n                    if (grid(i)(j) < dp(i)(j).head)\
    \ dp(i)(j) = List(grid(i)(j))\n                    else if (grid(i)(j) == dp(i)(j).head)\
    \ dp(i)(j) = grid(i)(j) :: dp(", "        val n = grid.length\n        val m =\
    \ grid(0).length\n        val dp = Array.fill(n, m)(List[Long]())\n        for\
    \ (i <- 0 until n) {\n            for (j <- 0 until m) {\n                val\
    \ lst = List(grid(i)(j))\n                if (i > 0 && dp(i - 1)(j).length ==\
    \ k - 1) {\n                    if (dp(i - 1)(j) < lst) {\n                  \
    \      dp(i)(j) = dp(i - 1)(j) :+ grid(i)(j)\n                    } else {\n \
    \                       dp(i)(j) = lst\n                    }\n              \
    \  }\n                if (j > 0 && dp(i)(j - 1).length == k - 1) {\n         \
    \           if (dp(i)(j - 1) < lst) {\n                        dp(i)(j) = dp(i)(j\
    \ - 1) :+ grid(i)(j)\n                    } else {\n                        dp(i)(j)\
    \ = lst\n                    }\n                }\n                if (i < n -\
    \ 1 && dp(i + 1)(j).length == k - 1) {\n                    if (dp(i + 1)(j) <\
    \ lst) {\n                        dp(i)(j) = dp(i + 1)(j) :+ grid(i)(j)\n    \
    \                } else {\n                        dp(i)(j) = lst\n          \
    \          }\n                }\n                if (j < m - 1 && dp(i)(j + 1).length\
    \ == k - 1) {\n                    if (dp(i)(j + 1) < lst) {\n               \
    \         dp(i)(j) = dp(i)(j + 1) :+ grid(i)(j)\n                    } else {\n\
    \                        dp(i)(j) = lst\n                    }\n             \
    \   }\n            }\n        }\n        var ans = List[Long]()\n        for (i\
    \ <- 0 until n) {\n            for (j <- 0 until m) {\n                if (dp(i)(j).length\
    \ == k) {\n                    if (ans.length == 0) {\n                      \
    \  ans = dp(", "        // Your code here\n        List[Long]()", "        //\
    \ Your code here\n        return List[Long]()", "        // Write your code here\n\
    \        val n = grid.length\n        val m = grid(0).length\n        val dp =\
    \ Array.ofDim[Long](n, m, k.toInt + 1)\n        for (i <- 0 until n; j <- 0 until\
    \ m; l <- 0 to k.toInt) {\n            if (l == 0) dp(i)(j)(l) = 0\n         \
    \   else {\n                dp(i)(j)(l) = Long.MaxValue\n                if (i\
    \ > 0) dp(i)(j)(l) = min(dp(i)(j)(l), dp(i - 1)(j)(l - 1) + grid(i)(j))\n    \
    \            if (i < n - 1) dp(i)(j)(l) = min(dp(i)(j)(l), dp(i + 1)(j)(l - 1)\
    \ + grid(i)(j))\n                if (j > 0) dp(i)(j)(l) = min(dp(i)(j)(l), dp(i)(j\
    \ - 1)(l - 1) + grid(i)(j))\n                if (j < m - 1) dp(i)(j)(l) = min(dp(i)(j)(l),\
    \ dp(i)(j + 1)(l - 1) + grid(i)(j))\n            }\n        }\n        var min\
    \ = Long.MaxValue\n        var minI = -1\n        var minJ = -1\n        for (i\
    \ <- 0 until n; j <- 0 until m) {\n            if (dp(i)(j)(k.toInt) < min) {\n\
    \                min = dp(i)(j)(k.toInt)\n                minI = i\n         \
    \       minJ = j\n            }\n        }\n        val result = ListBuffer[Long]()\n\
    \        var i = minI\n        var j = minJ\n        var l = k.toInt\n       \
    \ while (l > 0) {\n            result += grid(i)(j)\n            l -= 1\n    \
    \        if (i > 0 && dp(i)(j)(l) == dp(i - 1)(j)(l - 1) + grid(i)(j)) {\n   \
    \             i -=", "        // Fill in the code here\n        val n = grid.length\n\
    \        val m = grid(0).length\n        val dp = Array.ofDim[Long](n, m, k.toInt\
    \ + 1)\n        for (i <- 0 until n; j <- 0 until m; l <- 0 to k.toInt) {\n  \
    \          dp(i)(j)(l) = Long.MaxValue\n        }\n        for (i <- 0 until n;\
    \ j <- 0 until m) {\n            dp(i)(j)(1) = grid(i)(j)\n        }\n       \
    \ for (l <- 2 to k.toInt) {\n            for (i <- 0 until n; j <- 0 until m)\
    \ {\n                if (i > 0) dp(i)(j)(l) = min(dp(i)(j)(l), dp(i - 1)(j)(l\
    \ - 1))\n                if (i < n - 1) dp(i)(j)(l) = min(dp(i)(j)(l), dp(i +\
    \ 1)(j)(l - 1))\n                if (j > 0) dp(i)(j)(l) = min(dp(i)(j)(l), dp(i)(j\
    \ - 1)(l - 1))\n                if (j < m - 1) dp(i)(j)(l) = min(dp(i)(j)(l),\
    \ dp(i)(j + 1)(l - 1))\n            }\n        }\n        var min = Long.MaxValue\n\
    \        var x = 0\n        var y = 0\n        for (i <- 0 until n; j <- 0 until\
    \ m) {\n            if (dp(i)(j)(k.toInt) < min) {\n                min = dp(i)(j)(k.toInt)\n\
    \                x = i\n                y = j\n            }\n        }\n    \
    \    var ans = List[Long]()\n        for (l <- k.toInt to 1 by -1) {\n       \
    \     ans = grid(x)(y) :: ans\n            if (x > 0 && dp(x)(y)(l) == dp(x -\
    \ 1)(y)(l - 1)) {\n                x -= 1\n            } else if (x < n", "  \
    \      // Write your code here\n        return List[Long]()", "        // Your\
    \ code here\n        null", "        // Fill in the code here\n        return\
    \ List[Long]()", "        // Write your code here\n        return List[Long]()",
  "        val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(List[Long]())\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n  \
    \              else if (i == 0) dp(i)(j) = (dp(i)(j - 1) :+ grid(i)(j)).sorted\n\
    \                else if (j == 0) dp(i)(j) = (dp(i - 1)(j) :+ grid(i)(j)).sorted\n\
    \                else dp(i)(j) = (dp(i - 1)(j) :+ grid(i)(j)).sorted.take(k.toInt)\n\
    \                if (dp(i)(j).length > k.toInt) dp(i)(j) = dp(i)(j).take(k.toInt)\n\
    \                if (j > 0) {\n                    val tmp = (dp(i)(j - 1) :+\
    \ grid(i)(j)).sorted\n                    if (tmp.length > k.toInt) tmp.take(k.toInt)\n\
    \                    if (tmp < dp(i)(j)) dp(i)(j) = tmp\n                }\n \
    \           }\n        }\n        dp(n - 1)(m - 1)", "        // Your code here\n\
    \        return List[Long]()", "        // Your code here\n        null", "  \
    \      // Your code here\n        return List[Long]()", "        // Your code\
    \ here\n        return List[Long]()", "        // Your code here\n        return\
    \ null", "        // Your code here\n        null", "        val n = grid.length\n\
    \        val m = grid(0).length\n        val dp = Array.fill(n, m)(List[Long]())\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n        \
    \        dp(i)(j) = List[Long](grid(i)(j))\n                if (i > 0 && dp(i\
    \ - 1)(j).length < k) {\n                    val lst = dp(i - 1)(j) :+ grid(i)(j)\n\
    \                    if (lst.length < dp(i)(j).length || (lst.length == dp(i)(j).length\
    \ && lst < dp(i)(j))) dp(i)(j) = lst\n                }\n                if (j\
    \ > 0 && dp(i)(j - 1).length < k) {\n                    val lst = dp(i)(j - 1)\
    \ :+ grid(i)(j)\n                    if (lst.length < dp(i)(j).length || (lst.length\
    \ == dp(i)(j).length && lst < dp(i)(j))) dp(i)(j) = lst\n                }\n \
    \           }\n        }\n        dp(n - 1)(m - 1)", "        // Fill in the code\
    \ here\n        null", "        var n = grid.length\n        var m = grid(0).length\n\
    \        var dp = Array.ofDim[Long](n, m, k.toInt + 1)\n        for (i <- 0 until\
    \ n) {\n            for (j <- 0 until m) {\n                for (l <- 0 to k.toInt)\
    \ {\n                    dp(i)(j)(l) = Long.MaxValue\n                }\n    \
    \        }\n        }\n        for (i <- 0 until n) {\n            for (j <- 0\
    \ until m) {\n                dp(i)(j)(1) = grid(i)(j)\n            }\n      \
    \  }\n        for (l <- 2 to k.toInt) {\n            for (i <- 0 until n) {\n\
    \                for (j <- 0 until m) {\n                    if (i > 0) dp(i)(j)(l)\
    \ = min(dp(i)(j)(l), dp(i - 1)(j)(l - 1))\n                    if (i < n - 1)\
    \ dp(i)(j)(l) = min(dp(i)(j)(l), dp(i + 1)(j)(l - 1))\n                    if\
    \ (j > 0) dp(i)(j)(l) = min(dp(i)(j)(l), dp(i)(j - 1)(l - 1))\n              \
    \      if (j < m - 1) dp(i)(j)(l) = min(dp(i)(j)(l), dp(i)(j + 1)(l - 1))\n  \
    \              }\n            }\n        }\n        var ans = Long.MaxValue\n\
    \        var x = -1\n        var y = -1\n        for (i <- 0 until n) {\n    \
    \        for (j <- 0 until m) {\n                if (dp(i)(j)(k.toInt) < ans)\
    \ {\n                    ans = dp(i)(j)(k.toInt)\n                    x = i\n\
    \                    y = j\n                }\n            }\n        }\n    \
    \    var res = List[Long]()\n        res = res :+ ans\n        var cur = k.toInt\
    \ - 1\n        while (cur > 0) {\n            if (x > 0 && dp(x)(", "        //\
    \ Write your code here\n        var result = List[Long]()\n        var min = Long.MaxValue\n\
    \        for (i <- 0 until grid.length) {\n            for (j <- 0 until grid(i).length)\
    \ {\n                var temp = List[Long]()\n                temp = temp :+ grid(i)(j)\n\
    \                var visited = Array.ofDim[Boolean](grid.length, grid(i).length)\n\
    \                visited(i)(j) = true\n                dfs(grid, i, j, k - 1,\
    \ temp, visited, result, min)\n            }\n        }\n        result", "  \
    \      val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(List[Long]())\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n  \
    \              else if (i == 0) dp(i)(j) = (dp(i)(j - 1) :+ grid(i)(j)).sorted\n\
    \                else if (j == 0) dp(i)(j) = (dp(i - 1)(j) :+ grid(i)(j)).sorted\n\
    \                else dp(i)(j) = (dp(i - 1)(j) :+ grid(i)(j)).sorted.take(k.toInt)\n\
    \                if (j > 0) {\n                    val temp = (dp(i)(j - 1) :+\
    \ grid(i)(j)).sorted.take(k.toInt)\n                    if (temp.length == k.toInt\
    \ && temp < dp(i)(j)) dp(i)(j) = temp\n                }\n            }\n    \
    \    }\n        dp(n - 1)(m - 1)", "        // Your code here\n        return\
    \ List[Long]()", "        // Your code here\n        null", "        // Your code\
    \ here\n        return List[Long]()", "        // Fill in the code here\n    \
    \    return null", "        // Write your code here\n        val n = grid.length\n\
    \        val m = grid(0).length\n        val dp = Array.ofDim[Long](n, m, k.toInt\
    \ + 1)\n        for (i <- 0 until n; j <- 0 until m; l <- 0 to k.toInt) {\n  \
    \          if (l == 0) dp(i)(j)(l) = 0\n            else {\n                dp(i)(j)(l)\
    \ = Long.MaxValue\n                if (i > 0) dp(i)(j)(l) = min(dp(i)(j)(l), dp(i\
    \ - 1)(j)(l - 1) + grid(i)(j))\n                if (i < n - 1) dp(i)(j)(l) = min(dp(i)(j)(l),\
    \ dp(i + 1)(j)(l - 1) + grid(i)(j))\n                if (j > 0) dp(i)(j)(l) =\
    \ min(dp(i)(j)(l), dp(i)(j - 1)(l - 1) + grid(i)(j))\n                if (j <\
    \ m - 1) dp(i)(j)(l) = min(dp(i)(j)(l), dp(i)(j + 1)(l - 1) + grid(i)(j))\n  \
    \          }\n        }\n        var min = Long.MaxValue\n        var minI = -1\n\
    \        var minJ = -1\n        for (i <- 0 until n; j <- 0 until m) {\n     \
    \       if (dp(i)(j)(k.toInt) < min) {\n                min = dp(i)(j)(k.toInt)\n\
    \                minI = i\n                minJ = j\n            }\n        }\n\
    \        val path = new ListBuffer[Long]\n        var i = minI\n        var j\
    \ = minJ\n        var l = k.toInt\n        while (l > 0) {\n            path +=\
    \ grid(i)(j)\n            l -= 1\n            if (i > 0 && dp(i)(j)(l) == dp(i\
    \ - 1)(j)(l - 1) + grid(i)(j)) i -= 1\n           ", "        // Your code here\n\
    \        return List[Long]()", "        // Write your code here\n        return\
    \ null", "        // Write your code here\n        val n = grid.length\n     \
    \   val m = grid(0).length\n        val dp = Array.ofDim[Long](n, m, k.toInt +\
    \ 1)\n        for (i <- 0 until n; j <- 0 until m; l <- 0 to k.toInt) {\n    \
    \        dp(i)(j)(l) = Long.MaxValue\n        }\n        for (i <- 0 until n;\
    \ j <- 0 until m) {\n            dp(i)(j)(1) = grid(i)(j)\n        }\n       \
    \ for (l <- 2 to k.toInt) {\n            for (i <- 0 until n; j <- 0 until m)\
    \ {\n                for (x <- -1 to 1; y <- -1 to 1) {\n                    if\
    \ (x == 0 && y == 0) {\n                        dp(i)(j)(l) = min(dp(i)(j)(l),\
    \ dp(i)(j)(l - 1))\n                    } else if (i + x >= 0 && i + x < n &&\
    \ j + y >= 0 && j + y < m) {\n                        dp(i)(j)(l) = min(dp(i)(j)(l),\
    \ dp(i + x)(j + y)(l - 1))\n                    }\n                }\n       \
    \         dp(i)(j)(l) += grid(i)(j)\n            }\n        }\n        var min\
    \ = Long.MaxValue\n        var min_i = -1\n        var min_j = -1\n        for\
    \ (i <- 0 until n; j <- 0 until m) {\n            if (dp(i)(j)(k.toInt) < min)\
    \ {\n                min = dp(i)(j)(k.toInt)\n                min_i = i\n    \
    \            min_j = j\n            }\n        }\n        var ans = List[Long]()\n\
    \        for (l <- k.toInt to 1 by -1) {\n            ans = grid(min_i)(min_j)\
    \ :: ans\n            var min_x = -1\n            var min_y = -1\n           \
    \ for (x <- -1 to 1; y <- -1 to 1) {\n                if (x == 0", "        //\
    \ Write your code here\n        val n = grid.length\n        val dp = Array.fill(n,\
    \ n)(List[Long]())\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ n) {\n                dp(i)(j) = List(grid(i)(j))\n            }\n        }\n\
    \        for (i <- 1 until n) {\n            for (j <- 0 until n) {\n        \
    \        dp(i)(j) = min(dp(i - 1)(j), dp(i)(j))\n            }\n        }\n  \
    \      for (i <- 0 until n) {\n            for (j <- 1 until n) {\n          \
    \      dp(i)(j) = min(dp(i)(j - 1), dp(i)(j))\n            }\n        }\n    \
    \    for (i <- 1 until n) {\n            for (j <- n - 2 to 0 by -1) {\n     \
    \           dp(i)(j) = min(dp(i - 1)(j), dp(i)(j))\n            }\n        }\n\
    \        for (i <- 0 until n) {\n            for (j <- n - 2 to 0 by -1) {\n \
    \               dp(i)(j) = min(dp(i)(j + 1), dp(i)(j))\n            }\n      \
    \  }\n        var ans = List[Long]()\n        for (i <- 0 until n) {\n       \
    \     for (j <- 0 until n) {\n                if (dp(i)(j).length == k) {\n  \
    \                  ans = min(ans, dp(i)(j))\n                }\n            }\n\
    \        }\n        ans", "        // Your code here\n        return List[Long]()",
  "        // Write your code here\n        return List[Long]()", "        val n =\
    \ grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(Long.MaxValue)\n        val dirs = List((0, 1), (0, -1), (1, 0), (-1, 0))\n\
    \        def dfs(i : Int, j : Int, k : Long, path : List[Long]) : Unit = {\n \
    \           if (i < 0 || i >= n || j < 0 || j >= m) return\n            if (dp(i)(j)\
    \ <= path.sum) return\n            if (k == 0) {\n                dp(i)(j) = path.sum\n\
    \                return\n            }\n            for (dir <- dirs) {\n    \
    \            val x = i + dir._1\n                val y = j + dir._2\n        \
    \        dfs(x, y, k - 1, grid(i)(j) :: path)\n            }\n        }\n    \
    \    for (i <- 0 until n; j <- 0 until m) {\n            dfs(i, j, k, List())\n\
    \        }\n        var min = Long.MaxValue\n        var ans = List[Long]()\n\
    \        for (i <- 0 until n; j <- 0 until m) {\n            if (dp(i)(j) < min)\
    \ {\n                min = dp(i)(j)\n                ans = List(grid(i)(j))\n\
    \            } else if (dp(i)(j) == min) {\n                ans = grid(i)(j) ::\
    \ ans\n            }\n        }\n        ans.sorted", "        // Your code here\n\
    \        null", "        // Fill in the code here\n        return List[Long]()",
  "        // Fill in the code here\n        return List[Long]()", "        // Your\
    \ code here\n        return List[Long]()", "        // Write your code here\n\
    \        val n = grid.length\n        val m = grid(0).length\n        val dp =\
    \ Array.ofDim[Long](n, m, k.toInt + 1)\n        for (i <- 0 until n; j <- 0 until\
    \ m; l <- 0 to k.toInt) {\n            dp(i)(j)(l) = Long.MaxValue\n        }\n\
    \        for (i <- 0 until n; j <- 0 until m) {\n            dp(i)(j)(1) = grid(i)(j)\n\
    \        }\n        for (l <- 2 to k.toInt) {\n            for (i <- 0 until n;\
    \ j <- 0 until m) {\n                for (di <- -1 to 1; dj <- -1 to 1) {\n  \
    \                  if (di * di + dj * dj == 1) {\n                        val\
    \ ii = i + di\n                        val jj = j + dj\n                     \
    \   if (ii >= 0 && ii < n && jj >= 0 && jj < m) {\n                          \
    \  dp(i)(j)(l) = min(dp(i)(j)(l), dp(ii)(jj)(l - 1) + grid(i)(j))\n          \
    \              }\n                    }\n                }\n            }\n  \
    \      }\n        var ans = Long.MaxValue\n        var x = 0\n        var y =\
    \ 0\n        for (i <- 0 until n; j <- 0 until m) {\n            if (dp(i)(j)(k.toInt)\
    \ < ans) {\n                ans = dp(i)(j)(k.toInt)\n                x = i\n \
    \               y = j\n            }\n        }\n        val path = ListBuffer[Long]()\n\
    \        path += grid(x)(y)\n        var l = k.toInt - 1\n        while (l > 0)\
    \ {\n            for (di <- -1 to 1; dj <- -1 to 1) {\n                if (di\
    \ * di + dj * dj == 1) {\n                    val ii = x + di\n              \
    \      val jj = y + dj\n                    if (ii >= 0 && ii < n && jj >= 0 &&\
    \ jj < m) {\n                        if (dp(ii)(jj)(l) + grid(", "        val\
    \ n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(List[Long]())\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                dp(i)(j) = List[Long](grid(i)(j))\n                if\
    \ (i > 0 && dp(i - 1)(j).length > 0 && (dp(i - 1)(j).length < dp(i)(j).length\
    \ || (dp(i - 1)(j).length == dp(i)(j).length && dp(i - 1)(j) < dp(i)(j)))) dp(i)(j)\
    \ = dp(i - 1)(j)\n                if (j > 0 && dp(i)(j - 1).length > 0 && (dp(i)(j\
    \ - 1).length < dp(i)(j).length || (dp(i)(j - 1).length == dp(i)(j).length &&\
    \ dp(i)(j - 1) < dp(i)(j)))) dp(i)(j) = dp(i)(j - 1)\n            }\n        }\n\
    \        var ans = List[Long]()\n        for (i <- 0 until n) {\n            for\
    \ (j <- 0 until m) {\n                if (dp(i)(j).length > 0 && (ans.length <\
    \ dp(i)(j).length || (ans.length == dp(i)(j).length && ans < dp(i)(j)))) ans =\
    \ dp(i)(j)\n            }\n        }\n        ans", "        // Fill in the code\
    \ here\n        null", "        // Fill in the code here\n        var result =\
    \ List[Long]()\n        var min = Long.MaxValue\n        var minPath = List[Long]()\n\
    \        var minPaths = List[List[Long]]()\n        var minPaths2 = List[List[Long]]()\n\
    \        var minPaths3 = List[List[Long]]()\n        var minPaths4 = List[List[Long]]()\n\
    \        var minPaths5 = List[List[Long]]()\n        var minPaths6 = List[List[Long]]()\n\
    \        var minPaths7 = List[List[Long]]()\n        var minPaths8 = List[List[Long]]()\n\
    \        var minPaths9 = List[List[Long]]()\n        var minPaths10 = List[List[Long]]()\n\
    \        var minPaths11 = List[List[Long]]()\n        var minPaths12 = List[List[Long]]()\n\
    \        var minPaths13 = List[List[Long]]()\n        var minPaths14 = List[List[Long]]()\n\
    \        var minPaths15 = List[List[Long]]()\n        var minPaths16 = List[List[Long]]()\n\
    \        var minPaths17 = List[List[Long]]()\n        var minPaths18 = List[List[Long]]()\n\
    \        var minPaths19 = List[List[Long]]()\n        var minPaths20 = List[List[Long]]()\n\
    \        var minPaths21 = List[List[Long]]()\n        var minPaths22 = List[List[Long]]()\n\
    \        var minPaths23 = List[List[Long]]()\n        var minPaths24 = List[List[Long]]()\n\
    \        var minPaths25 = List[List[Long]]()\n        var minPaths26 = List[List[Long]]()\n\
    \        var minPaths27 = List[List[Long]]()\n        var minPaths28 = List[List[Long]]()\n\
    \        var minPaths29 = List[List[Long]]()\n        var minPaths30 = List[List[Long]]()\n\
    \        var minPaths31 = List[List[Long]]()\n        var minPaths32 = List[",
  "        val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(List[Long]())\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                dp(i)(j) = List(grid(i)(j))\n                if (i > 0\
    \ && dp(i - 1)(j).length < k && dp(i - 1)(j) < dp(i)(j)) dp(i)(j) = dp(i - 1)(j)\n\
    \                if (j > 0 && dp(i)(j - 1).length < k && dp(i)(j - 1) < dp(i)(j))\
    \ dp(i)(j) = dp(i)(j - 1)\n            }\n        }\n        dp(n - 1)(m - 1)",
  "        val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(List[Long]())\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                val lst = List[Long](grid(i)(j))\n                dp(i)(j)\
    \ = lst\n                if (i > 0 && dp(i - 1)(j).length > 0) {\n           \
    \         val lst2 = dp(i - 1)(j) :+ grid(i)(j)\n                    if (lst2.length\
    \ <= k && (dp(i)(j).length == 0 || lst2 < dp(i)(j))) dp(i)(j) = lst2\n       \
    \         }\n                if (j > 0 && dp(i)(j - 1).length > 0) {\n       \
    \             val lst2 = dp(i)(j - 1) :+ grid(i)(j)\n                    if (lst2.length\
    \ <= k && (dp(i)(j).length == 0 || lst2 < dp(i)(j))) dp(i)(j) = lst2\n       \
    \         }\n            }\n        }\n        dp(n - 1)(m - 1)", "        //\
    \ Write your code here\n        // Return the list of values on the cells that\
    \ the minimum path go through\n        // You can add more functions as you wish\n\
    \        // Remember to use the keyword \"return\"\n        return List[Long]()",
  "        // Your code here\n        return List[Long]()", "        // Write your\
    \ code here\n        // Return the ordered list of the values on the cells that\
    \ the minimum path go through.\n        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.ofDim[Long](n, m, k.toInt + 1)\n        for (i <- 0 until\
    \ n; j <- 0 until m; l <- 0 to k.toInt) dp(i)(j)(l) = Long.MaxValue\n        for\
    \ (i <- 0 until n; j <- 0 until m) dp(i)(j)(1) = grid(i)(j)\n        for (l <-\
    \ 2 to k.toInt) {\n            for (i <- 0 until n; j <- 0 until m) {\n      \
    \          if (i > 0) dp(i)(j)(l) = min(dp(i)(j)(l), dp(i - 1)(j)(l - 1))\n  \
    \              if (i < n - 1) dp(i)(j)(l) = min(dp(i)(j)(l), dp(i + 1)(j)(l -\
    \ 1))\n                if (j > 0) dp(i)(j)(l) = min(dp(i)(j)(l), dp(i)(j - 1)(l\
    \ - 1))\n                if (j < m - 1) dp(i)(j)(l) = min(dp(i)(j)(l), dp(i)(j\
    \ + 1)(l - 1))\n            }\n        }\n        var min = Long.MaxValue\n  \
    \      var min_i = -1\n        var min_j = -1\n        for (i <- 0 until n; j\
    \ <- 0 until m) {\n            if (dp(i)(j)(k.toInt) < min) {\n              \
    \  min = dp(i)(j)(k.toInt)\n                min_i = i\n                min_j =\
    \ j\n            }\n        }\n        val result = ListBuffer[Long]()\n     \
    \   result += grid(min_i)(min_j)\n        var cur_i = min_i\n        var cur_j\
    \ = min_j\n        for (l <- k.toInt - 1 to 1 by -1) {\n            if (", " \
    \       // Write your code here\n        return List[Long]()", "        // Write\
    \ your code here\n        // Return the ordered list of the values on the cells\
    \ that the minimum path go through.\n        List[Long]()", "        // Write\
    \ your code here\n        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.ofDim[Long](n, m, k.toInt + 1)\n        for (i <- 0 until\
    \ n; j <- 0 until m; l <- 0 to k.toInt) dp(i)(j)(l) = -1\n        def f(i : Int,\
    \ j : Int, l : Int) : Long = {\n            if (l == 0) return grid(i)(j)\n  \
    \          if (dp(i)(j)(l) != -1) return dp(i)(j)(l)\n            var min = Long.MaxValue\n\
    \            if (i > 0) min = min min (f(i - 1, j, l - 1) + grid(i)(j))\n    \
    \        if (i < n - 1) min = min min (f(i + 1, j, l - 1) + grid(i)(j))\n    \
    \        if (j > 0) min = min min (f(i, j - 1, l - 1) + grid(i)(j))\n        \
    \    if (j < m - 1) min = min min (f(i, j + 1, l - 1) + grid(i)(j))\n        \
    \    dp(i)(j)(l) = min\n            return min\n        }\n        var min = Long.MaxValue\n\
    \        var x = 0\n        var y = 0\n        for (i <- 0 until n; j <- 0 until\
    \ m) {\n            val v = f(i, j, k.toInt)\n            if (v < min) {\n   \
    \             min = v\n                x = i\n                y = j\n        \
    \    }\n        }\n        var ans = List[Long]()\n        ans = ans :+ grid(x)(y)\n\
    \        var l = k.toInt - 1\n        while (l > 0) {\n            if (x > 0 &&\
    \ dp(x)(y)(l) == dp(x - 1)(y)(l - 1) + grid(x)(y)) {\n                x -= 1\n\
    \                ans = ans :+ grid(x)(y)\n                l -= 1\n           \
    \ } else if (x < n - 1 && dp", "        val n = grid.length\n        val dp =\
    \ Array.fill(n, n)(List[Long]())\n        for (i <- 0 until n) {\n           \
    \ for (j <- 0 until n) {\n                dp(i)(j) = List[Long](grid(i)(j))\n\
    \                if (i > 0 && dp(i - 1)(j).length + 1 <= k && (dp(i - 1)(j).length\
    \ + 1 < dp(i)(j).length || dp(i - 1)(j) < dp(i)(j))) dp(i)(j) = dp(i - 1)(j) :+\
    \ grid(i)(j)\n                if (j > 0 && dp(i)(j - 1).length + 1 <= k && (dp(i)(j\
    \ - 1).length + 1 < dp(i)(j).length || dp(i)(j - 1) < dp(i)(j))) dp(i)(j) = dp(i)(j\
    \ - 1) :+ grid(i)(j)\n            }\n        }\n        dp(n - 1)(n - 1)", " \
    \       val n = grid.length\n        val m = grid(0).length\n        val dp =\
    \ Array.fill(n, m)(List[Long]())\n        for (i <- 0 until n) {\n           \
    \ for (j <- 0 until m) {\n                if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n\
    \                else if (i == 0) {\n                    if (dp(i)(j - 1).length\
    \ < k) dp(i)(j) = dp(i)(j - 1) :+ grid(i)(j)\n                    else if (dp(i)(j\
    \ - 1).length == k) {\n                        if (dp(i)(j - 1).last < grid(i)(j))\
    \ dp(i)(j) = dp(i)(j - 1)\n                        else dp(i)(j) = dp(i)(j - 1).init\
    \ :+ grid(i)(j)\n                    }\n                    else dp(i)(j) = dp(i)(j\
    \ - 1)\n                }\n                else if (j == 0) {\n              \
    \      if (dp(i - 1)(j).length < k) dp(i)(j) = dp(i - 1)(j) :+ grid(i)(j)\n  \
    \                  else if (dp(i - 1)(j).length == k) {\n                    \
    \    if (dp(i - 1)(j).last < grid(i)(j)) dp(i)(j) = dp(i - 1)(j)\n           \
    \             else dp(i)(j) = dp(i - 1)(j).init :+ grid(i)(j)\n              \
    \      }\n                    else dp(i)(j) = dp(i - 1)(j)\n                }\n\
    \                else {\n                    if (dp(i - 1)(j).length < k) {\n\
    \                        if (dp(i)(j - 1).length < k) {\n                    \
    \        if (dp(i - 1)(j).last < dp(i)(j - 1).last) dp(i)(j) = dp(i - 1)(j) :+\
    \ grid(i)(j)\n                            else dp(i)(j) = dp", "        // Write\
    \ your code here\n        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.ofDim[Long](n, m, k.toInt + 1)\n        for (i <- 0 until\
    \ n; j <- 0 until m; l <- 0 to k.toInt) {\n            dp(i)(j)(l) = Long.MaxValue\n\
    \        }\n        for (i <- 0 until n; j <- 0 until m) {\n            dp(i)(j)(1)\
    \ = grid(i)(j)\n        }\n        for (l <- 2 to k.toInt) {\n            for\
    \ (i <- 0 until n; j <- 0 until m) {\n                if (i > 0) dp(i)(j)(l) =\
    \ min(dp(i)(j)(l), dp(i - 1)(j)(l - 1))\n                if (i < n - 1) dp(i)(j)(l)\
    \ = min(dp(i)(j)(l), dp(i + 1)(j)(l - 1))\n                if (j > 0) dp(i)(j)(l)\
    \ = min(dp(i)(j)(l), dp(i)(j - 1)(l - 1))\n                if (j < m - 1) dp(i)(j)(l)\
    \ = min(dp(i)(j)(l), dp(i)(j + 1)(l - 1))\n            }\n        }\n        var\
    \ min = Long.MaxValue\n        var min_i = -1\n        var min_j = -1\n      \
    \  for (i <- 0 until n; j <- 0 until m) {\n            if (dp(i)(j)(k.toInt) <\
    \ min) {\n                min = dp(i)(j)(k.toInt)\n                min_i = i\n\
    \                min_j = j\n            }\n        }\n        var result = List[Long]()\n\
    \        var i = min_i\n        var j = min_j\n        var l = k.toInt\n     \
    \   while (l > 0) {\n            result = grid(i)(j) :: result\n            l\
    \ -= 1\n            if (i > 0 && dp(i)(j)(", "        // Fill in the code here\n\
    \        var n = grid.length\n        var m = grid(0).length\n        var dp =\
    \ Array.ofDim[Long](n, m, k.toInt + 1)\n        for (i <- 0 until n) {\n     \
    \       for (j <- 0 until m) {\n                dp(i)(j)(1) = grid(i)(j)\n   \
    \         }\n        }\n        for (i <- 0 until n) {\n            for (j <-\
    \ 0 until m) {\n                for (l <- 2 to k.toInt) {\n                  \
    \  dp(i)(j)(l) = Long.MaxValue\n                    if (i > 0) dp(i)(j)(l) = min(dp(i)(j)(l),\
    \ dp(i - 1)(j)(l - 1))\n                    if (i < n - 1) dp(i)(j)(l) = min(dp(i)(j)(l),\
    \ dp(i + 1)(j)(l - 1))\n                    if (j > 0) dp(i)(j)(l) = min(dp(i)(j)(l),\
    \ dp(i)(j - 1)(l - 1))\n                    if (j < m - 1) dp(i)(j)(l) = min(dp(i)(j)(l),\
    \ dp(i)(j + 1)(l - 1))\n                    dp(i)(j)(l) += grid(i)(j)\n      \
    \          }\n            }\n        }\n        var ans = Long.MaxValue\n    \
    \    var x = 0\n        var y = 0\n        for (i <- 0 until n) {\n          \
    \  for (j <- 0 until m) {\n                if (dp(i)(j)(k.toInt) < ans) {\n  \
    \                  ans = dp(i)(j)(k.toInt)\n                    x = i\n      \
    \              y = j\n                }\n            }\n        }\n        var\
    \ res = List[Long]()\n        for (i <- 1 to k.toInt) {\n            res = grid(x)(y)\
    \ :: res\n            var nx = x\n            var ny = y\n            if (x >\
    \ 0 && dp(x - 1)(y)(k.toInt -", "        val n = grid.length\n        val m =\
    \ grid(0).length\n        val dp = Array.fill(n, m)(List[Long]())\n        for\
    \ (i <- 0 until n) {\n            for (j <- 0 until m) {\n                if (i\
    \ == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n                else if (i == 0)\
    \ {\n                    dp(i)(j) = dp(i)(j - 1) :+ grid(i)(j)\n             \
    \       if (dp(i)(j - 1).length > k) dp(i)(j) = dp(i)(j - 1)\n               \
    \ }\n                else if (j == 0) {\n                    dp(i)(j) = dp(i -\
    \ 1)(j) :+ grid(i)(j)\n                    if (dp(i - 1)(j).length > k) dp(i)(j)\
    \ = dp(i - 1)(j)\n                }\n                else {\n                \
    \    dp(i)(j) = dp(i - 1)(j) :+ grid(i)(j)\n                    if (dp(i - 1)(j).length\
    \ > k) dp(i)(j) = dp(i - 1)(j)\n                    if (dp(i)(j - 1).length <\
    \ dp(i)(j).length) dp(i)(j) = dp(i)(j - 1) :+ grid(i)(j)\n                   \
    \ if (dp(i)(j - 1).length == dp(i)(j).length) {\n                        if (dp(i)(j\
    \ - 1) < dp(i)(j)) dp(i)(j) = dp(i)(j - 1) :+ grid(i)(j)\n                   \
    \ }\n                }\n            }\n        }\n        dp(n - 1)(m - 1)", " \
    \       // Your code here\n        return List[Long]()", "        val n = grid.length\n\
    \        val m = grid(0).length\n        val dp = Array.fill(n, m)(List[Long]())\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n        \
    \        if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n                else\
    \ if (i == 0) {\n                    if (dp(i)(j - 1).length < k) dp(i)(j) = dp(i)(j\
    \ - 1) :+ grid(i)(j)\n                    else if (dp(i)(j - 1).length == k) {\n\
    \                        if (dp(i)(j - 1).last > grid(i)(j)) dp(i)(j) = dp(i)(j\
    \ - 1).init :+ grid(i)(j)\n                        else dp(i)(j) = dp(i)(j - 1)\n\
    \                    }\n                    else dp(i)(j) = dp(i)(j - 1)\n   \
    \             }\n                else if (j == 0) {\n                    if (dp(i\
    \ - 1)(j).length < k) dp(i)(j) = dp(i - 1)(j) :+ grid(i)(j)\n                \
    \    else if (dp(i - 1)(j).length == k) {\n                        if (dp(i -\
    \ 1)(j).last > grid(i)(j)) dp(i)(j) = dp(i - 1)(j).init :+ grid(i)(j)\n      \
    \                  else dp(i)(j) = dp(i - 1)(j)\n                    }\n     \
    \               else dp(i)(j) = dp(i - 1)(j)\n                }\n            \
    \    else {\n                    if (dp(i - 1)(j).length < k) {\n            \
    \            if (dp(i)(j - 1).length < k) {\n                            if (dp(i\
    \ - 1)(j).last < dp(i)(j - 1).last) dp(i)(j) = dp(i - 1)(j) :+ grid(i)(j)\n  \
    \                          else dp(i)(j) = dp", "        val n = grid.length\n\
    \        val m = grid(0).length\n        val dp = Array.fill(n, m)(List[Long]())\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n        \
    \        if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n                else\
    \ if (i == 0) {\n                    val lst = dp(i)(j - 1)\n                \
    \    if (lst.length < k) dp(i)(j) = lst :+ grid(i)(j)\n                    else\
    \ if (lst.length == k) {\n                        if (lst.last > grid(i)(j)) dp(i)(j)\
    \ = lst.init :+ grid(i)(j)\n                        else dp(i)(j) = lst\n    \
    \                }\n                    else dp(i)(j) = lst\n                }\n\
    \                else if (j == 0) {\n                    val lst = dp(i - 1)(j)\n\
    \                    if (lst.length < k) dp(i)(j) = lst :+ grid(i)(j)\n      \
    \              else if (lst.length == k) {\n                        if (lst.last\
    \ > grid(i)(j)) dp(i)(j) = lst.init :+ grid(i)(j)\n                        else\
    \ dp(i)(j) = lst\n                    }\n                    else dp(i)(j) = lst\n\
    \                }\n                else {\n                    val lst1 = dp(i\
    \ - 1)(j)\n                    val lst2 = dp(i)(j - 1)\n                    if\
    \ (lst1.length < k) {\n                        if (lst2.length < k) {\n      \
    \                      if (lst1.last > lst2.last) dp(i)(j) = lst1 :+ grid(i)(j)\n\
    \                            else dp(i)(j) = lst2 :+ grid(i)(j)\n            \
    \            }\n                        else if (lst2.length == k) {\n       \
    \                     if (lst1.last > lst2.last) dp", "        // Write your code\
    \ here\n        val n = grid.length\n        val m = grid(0).length\n        val\
    \ dp = Array.ofDim[Long](n, m, k.toInt + 1)\n        for (i <- 0 until n; j <-\
    \ 0 until m; l <- 0 to k.toInt) {\n            if (l == 0) dp(i)(j)(l) = 0\n \
    \           else {\n                dp(i)(j)(l) = Long.MaxValue\n            \
    \    if (i > 0) dp(i)(j)(l) = min(dp(i)(j)(l), dp(i - 1)(j)(l - 1) + grid(i)(j))\n\
    \                if (i < n - 1) dp(i)(j)(l) = min(dp(i)(j)(l), dp(i + 1)(j)(l\
    \ - 1) + grid(i)(j))\n                if (j > 0) dp(i)(j)(l) = min(dp(i)(j)(l),\
    \ dp(i)(j - 1)(l - 1) + grid(i)(j))\n                if (j < m - 1) dp(i)(j)(l)\
    \ = min(dp(i)(j)(l), dp(i)(j + 1)(l - 1) + grid(i)(j))\n            }\n      \
    \  }\n        var min = Long.MaxValue\n        var minI = -1\n        var minJ\
    \ = -1\n        for (i <- 0 until n; j <- 0 until m) {\n            if (dp(i)(j)(k.toInt)\
    \ < min) {\n                min = dp(i)(j)(k.toInt)\n                minI = i\n\
    \                minJ = j\n            }\n        }\n        val res = new ListBuffer[Long]\n\
    \        var i = minI\n        var j = minJ\n        var l = k.toInt\n       \
    \ while (l > 0) {\n            res += grid(i)(j)\n            l -= 1\n       \
    \     if (i > 0 && dp(i)(j)(l) == dp(i - 1)(j)(l - 1) + grid(i)(j)) i -= 1\n \
    \          ", "        // Write your code here\n        // Return the ordered\
    \ list of the values on the cells that the minimum path go through.\n        List[Long]()",
  "        val n = grid.length\n        val dp = Array.fill(n, n)(List[Long]())\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until n) {\n        \
    \        dp(i)(j) = List[Long](grid(i)(j))\n                if (i > 0 && dp(i\
    \ - 1)(j).length > 0 && dp(i - 1)(j).length + 1 <= k) {\n                    val\
    \ lst = dp(i - 1)(j) :+ grid(i)(j)\n                    if (dp(i)(j).length ==\
    \ 0 || lst < dp(i)(j)) dp(i)(j) = lst\n                }\n                if (j\
    \ > 0 && dp(i)(j - 1).length > 0 && dp(i)(j - 1).length + 1 <= k) {\n        \
    \            val lst = dp(i)(j - 1) :+ grid(i)(j)\n                    if (dp(i)(j).length\
    \ == 0 || lst < dp(i)(j)) dp(i)(j) = lst\n                }\n            }\n \
    \       }\n        dp(n - 1)(n - 1)", "        // Your code here\n        return\
    \ List[Long]()", "        // Write your code here\n        var n = grid.length\n\
    \        var m = grid(0).length\n        var dp = Array.ofDim[Long](n, m, k.toInt\
    \ + 1)\n        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n \
    \               for (l <- 0 to k.toInt) {\n                    dp(i)(j)(l) = Long.MaxValue\n\
    \                }\n            }\n        }\n        for (i <- 0 until n) {\n\
    \            for (j <- 0 until m) {\n                dp(i)(j)(1) = grid(i)(j)\n\
    \            }\n        }\n        for (l <- 2 to k.toInt) {\n            for\
    \ (i <- 0 until n) {\n                for (j <- 0 until m) {\n               \
    \     if (i > 0) dp(i)(j)(l) = min(dp(i)(j)(l), dp(i - 1)(j)(l - 1))\n       \
    \             if (i < n - 1) dp(i)(j)(l) = min(dp(i)(j)(l), dp(i + 1)(j)(l - 1))\n\
    \                    if (j > 0) dp(i)(j)(l) = min(dp(i)(j)(l), dp(i)(j - 1)(l\
    \ - 1))\n                    if (j < m - 1) dp(i)(j)(l) = min(dp(i)(j)(l), dp(i)(j\
    \ + 1)(l - 1))\n                }\n            }\n        }\n        var min =\
    \ Long.MaxValue\n        var minI = -1\n        var minJ = -1\n        for (i\
    \ <- 0 until n) {\n            for (j <- 0 until m) {\n                if (dp(i)(j)(k.toInt)\
    \ < min) {\n                    min = dp(i)(j)(k.toInt)\n                    minI\
    \ = i\n                    minJ = j\n                }\n            }\n      \
    \  }\n        var result = List[Long]()\n        result = result :+ grid(minI)(minJ)\n\
    \        var curI = minI\n        var curJ = min", "        // Write your code\
    \ here\n        val n = grid.length\n        val m = grid(0).length\n        val\
    \ dp = Array.ofDim[Long](n, m, k.toInt + 1)\n        for (i <- 0 until n; j <-\
    \ 0 until m; l <- 0 to k.toInt) {\n            if (l == 0) dp(i)(j)(l) = 0\n \
    \           else {\n                dp(i)(j)(l) = Long.MaxValue\n            \
    \    if (i > 0) dp(i)(j)(l) = min(dp(i)(j)(l), dp(i - 1)(j)(l - 1) + grid(i)(j))\n\
    \                if (i < n - 1) dp(i)(j)(l) = min(dp(i)(j)(l), dp(i + 1)(j)(l\
    \ - 1) + grid(i)(j))\n                if (j > 0) dp(i)(j)(l) = min(dp(i)(j)(l),\
    \ dp(i)(j - 1)(l - 1) + grid(i)(j))\n                if (j < m - 1) dp(i)(j)(l)\
    \ = min(dp(i)(j)(l), dp(i)(j + 1)(l - 1) + grid(i)(j))\n            }\n      \
    \  }\n        var min = Long.MaxValue\n        var minI = -1\n        var minJ\
    \ = -1\n        for (i <- 0 until n; j <- 0 until m) {\n            if (dp(i)(j)(k.toInt)\
    \ < min) {\n                min = dp(i)(j)(k.toInt)\n                minI = i\n\
    \                minJ = j\n            }\n        }\n        val result = new\
    \ ListBuffer[Long]\n        var i = minI\n        var j = minJ\n        var l\
    \ = k.toInt\n        while (l > 0) {\n            result += grid(i)(j)\n     \
    \       l -= 1\n            if (i > 0 && dp(i)(j)(l) == dp(i - 1)(j)(l - 1) +\
    \ grid(i)(j)) {\n                i -=", "        // Your code here\n        return\
    \ List[Long]()", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.fill(n, m)(List[Long]())\n        for (i <- 0 until n)\
    \ {\n            for (j <- 0 until m) {\n                if (i == 0 && j == 0)\
    \ dp(i)(j) = List(grid(i)(j))\n                else if (i == 0) {\n          \
    \          val lst = dp(i)(j - 1)\n                    val idx = lst.indexWhere(_\
    \ > grid(i)(j))\n                    if (idx == -1) dp(i)(j) = lst :+ grid(i)(j)\n\
    \                    else dp(i)(j) = lst.take(idx) :+ grid(i)(j) ::: lst.drop(idx)\n\
    \                }\n                else if (j == 0) {\n                    val\
    \ lst = dp(i - 1)(j)\n                    val idx = lst.indexWhere(_ > grid(i)(j))\n\
    \                    if (idx == -1) dp(i)(j) = lst :+ grid(i)(j)\n           \
    \         else dp(i)(j) = lst.take(idx) :+ grid(i)(j) ::: lst.drop(idx)\n    \
    \            }\n                else {\n                    val lst1 = dp(i -\
    \ 1)(j)\n                    val lst2 = dp(i)(j - 1)\n                    val\
    \ lst = if (lst1.length < lst2.length) lst1 else lst2\n                    val\
    \ idx = lst.indexWhere(_ > grid(i)(j))\n                    if (idx == -1) dp(i)(j)\
    \ = lst :+ grid(i)(j)\n                    else dp(i)(j) = lst.take(idx) :+ grid(i)(j)\
    \ ::: lst.drop(idx)\n                }\n            }\n        }\n        dp(n\
    \ - 1)(m - 1).take(k.toInt)", "        // Your code here\n        return List[Long]()",
  "        // Your code here\n        return List[Long]()", "        // Your code\
    \ here\n        return List[Long]()", "        // Write your code here\n     \
    \   var result = List[Long]()\n        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.ofDim[Long](n, m, k.toInt + 1)\n        for (i <- 0 until\
    \ n) {\n            for (j <- 0 until m) {\n                for (l <- 0 to k.toInt)\
    \ {\n                    dp(i)(j)(l) = Long.MaxValue\n                }\n    \
    \        }\n        }\n        for (i <- 0 until n) {\n            for (j <- 0\
    \ until m) {\n                dp(i)(j)(1) = grid(i)(j)\n            }\n      \
    \  }\n        for (l <- 2 to k.toInt) {\n            for (i <- 0 until n) {\n\
    \                for (j <- 0 until m) {\n                    if (i > 0) {\n  \
    \                      dp(i)(j)(l) = min(dp(i)(j)(l), dp(i - 1)(j)(l - 1))\n \
    \                   }\n                    if (i < n - 1) {\n                \
    \        dp(i)(j)(l) = min(dp(i)(j)(l), dp(i + 1)(j)(l - 1))\n               \
    \     }\n                    if (j > 0) {\n                        dp(i)(j)(l)\
    \ = min(dp(i)(j)(l), dp(i)(j - 1)(l - 1))\n                    }\n           \
    \         if (j < m - 1) {\n                        dp(i)(j)(l) = min(dp(i)(j)(l),\
    \ dp(i)(j + 1)(l - 1))\n                    }\n                }\n           \
    \ }\n        }\n        var min = Long.MaxValue\n        for (i <- 0 until n)\
    \ {\n            for (j <- 0 until m) {\n                min = min(min, dp(i)(j)(k.toInt))\n\
    \            }\n        }\n        var i = 0\n        var j = 0\n        for (i\
    \ <- 0 until n) {\n            for (j <- 0 until m) {\n                if (dp(i)(j)(k.toInt)\
    \ == min)", "        // Your code here\n        return List[Long]()", "      \
    \  // Write your code here\n        // Return the list of values on the cells\
    \ that the minimum path go through\n        // The list must be ordered\n    \
    \    // The list must be of length k\n        // The list must be lexicographically\
    \ less than any other path of length k\n        // You can use any data structure\
    \ you want\n        // You can use any algorithm you want\n        // You can\
    \ use any programming language you want\n        // You can use any IDE you want\n\
    \        // You can use any operating system you want\n        // You can use\
    \ any computer you want\n        // You can use any internet connection you want\n\
    \        // You can use any human help you want\n        // You can use any non-human\
    \ help you want\n        // You can use any resource you want\n        // You\
    \ can use any time you want\n        // You can use any space you want\n     \
    \   // You can use any method you want\n        // You can use any approach you\
    \ want\n        // You can use any technique you want\n        // You can use\
    \ any trick you want\n        // You can use any tool you want\n        // You\
    \ can use any library you want\n        // You can use any framework you want\n\
    \        // You can use any principle you want\n        // You can use any pattern\
    \ you want\n        // You can use any idiom you want\n        // You can use\
    \ any paradigm you want\n        // You can use any heuristic you want\n     \
    \   // You can use any philosophy you want\n        // You can use any religion\
    \ you want\n        // You can use any belief you want\n        // You can use\
    \ any superstition you want\n        // You can use any magic you want\n     \
    \   // You can use any spell you want\n        // You can use any curse you want\n\
    \        // You can use any ritual you want\n        // You can use any witchcraft\
    \ you want\n        // You can use any sorcery you want\n        // You can use\
    \ any wizardry you want\n        // You can use any charm you want\n        //\
    \ You can use any incantation you want\n        // You can use any enchantment\
    \ you want\n        // You can use any voodoo you want\n        // You can use\
    \ any hoodoo you want\n        // You can use any mojo you want\n        // You\
    \ can use any juju you want\n        // You can use any witchery you want\n  \
    \      //", "        // Your code here\n        null", "        val n = grid.length\n\
    \        val m = grid(0).length\n        val dp = Array.fill(n, m)(List[Long]())\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n        \
    \        if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n                else\
    \ if (i == 0) dp(i)(j) = dp(i)(j - 1) :+ grid(i)(j)\n                else if (j\
    \ == 0) dp(i)(j) = dp(i - 1)(j) :+ grid(i)(j)\n                else {\n      \
    \              val prev = List(dp(i - 1)(j), dp(i)(j - 1), dp(i - 1)(j - 1))\n\
    \                    dp(i)(j) = prev.minBy(x => x :+ grid(i)(j))\n           \
    \     }\n            }\n        }\n        dp(n - 1)(m - 1).take(k.toInt)", " \
    \       // Your code here\n        return List[Long]()", "        // Write your\
    \ code here\n        return List[Long]()", "        // Your code here\n      \
    \  return List[Long]()", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.fill(n, m)(List[Long]())\n        for (i <- 0 until n)\
    \ {\n            for (j <- 0 until m) {\n                if (i == 0 && j == 0)\
    \ dp(i)(j) = List(grid(i)(j))\n                else if (i == 0) dp(i)(j) = (dp(i)(j\
    \ - 1) :+ grid(i)(j)).sorted\n                else if (j == 0) dp(i)(j) = (dp(i\
    \ - 1)(j) :+ grid(i)(j)).sorted\n                else dp(i)(j) = (dp(i - 1)(j)\
    \ :+ grid(i)(j)).sorted.take(k.toInt)\n                if (dp(i)(j).length > k.toInt)\
    \ dp(i)(j) = dp(i)(j).take(k.toInt)\n                if (j > 0) {\n          \
    \          val tmp = (dp(i)(j - 1) :+ grid(i)(j)).sorted\n                   \
    \ if (tmp.length > k.toInt) tmp.take(k.toInt)\n                    if (tmp < dp(i)(j))\
    \ dp(i)(j) = tmp\n                }\n            }\n        }\n        dp(n -\
    \ 1)(m - 1)", "        // Write your code here\n        val n = grid.length\n\
    \        val m = grid(0).length\n        val dp = Array.ofDim[Long](n, m, k.toInt\
    \ + 1)\n        for (i <- 0 until n; j <- 0 until m; l <- 0 to k.toInt) {\n  \
    \          dp(i)(j)(l) = Long.MaxValue\n        }\n        for (i <- 0 until n;\
    \ j <- 0 until m) {\n            dp(i)(j)(1) = grid(i)(j)\n        }\n       \
    \ for (l <- 2 to k.toInt) {\n            for (i <- 0 until n; j <- 0 until m)\
    \ {\n                for (x <- 0 until n; y <- 0 until m) {\n                \
    \    if (abs(i - x) + abs(j - y) == 1) {\n                        dp(i)(j)(l)\
    \ = min(dp(i)(j)(l), dp(x)(y)(l - 1) + grid(i)(j))\n                    }\n  \
    \              }\n            }\n        }\n        var min = Long.MaxValue\n\
    \        var minx = 0\n        var miny = 0\n        for (i <- 0 until n; j <-\
    \ 0 until m) {\n            if (dp(i)(j)(k.toInt) < min) {\n                min\
    \ = dp(i)(j)(k.toInt)\n                minx = i\n                miny = j\n  \
    \          }\n        }\n        val ans = ListBuffer[Long]()\n        ans +=\
    \ grid(minx)(miny)\n        var x = minx\n        var y = miny\n        for (l\
    \ <- k.toInt - 1 to 1 by -1) {\n            for (i <- 0 until n; j <- 0 until\
    \ m) {\n                if (abs(x - i) + abs(y - j) == 1 && dp(x)(y)(l + 1) ==\
    \ dp(i)(j)(l) + grid(x)(y)) {\n                    ans += grid(i)(j)\n       \
    \             x = i\n                    y = j\n                }\n          \
    \  }\n        }\n        ans.toList", "        // Your code here\n        return\
    \ List[Long]()", "        // Your code here\n        return List[Long]()", " \
    \       // Your code here\n        return List[Long]()", "        // Write your\
    \ code here\n        return List[Long]()", "        // Your code here\n      \
    \  null", "        // Write your code here\n        // Return the answer\n   \
    \     val n = grid.length\n        val m = grid(0).length\n        val dp = Array.ofDim[Long](n,\
    \ m, k.toInt + 1)\n        for (i <- 0 until n; j <- 0 until m; l <- 0 to k.toInt)\
    \ {\n            if (l == 0) dp(i)(j)(l) = 0\n            else {\n           \
    \     dp(i)(j)(l) = Long.MaxValue\n                if (i > 0) dp(i)(j)(l) = min(dp(i)(j)(l),\
    \ dp(i - 1)(j)(l - 1) + grid(i)(j))\n                if (i < n - 1) dp(i)(j)(l)\
    \ = min(dp(i)(j)(l), dp(i + 1)(j)(l - 1) + grid(i)(j))\n                if (j\
    \ > 0) dp(i)(j)(l) = min(dp(i)(j)(l), dp(i)(j - 1)(l - 1) + grid(i)(j))\n    \
    \            if (j < m - 1) dp(i)(j)(l) = min(dp(i)(j)(l), dp(i)(j + 1)(l - 1)\
    \ + grid(i)(j))\n            }\n        }\n        var min = Long.MaxValue\n \
    \       var minI = -1\n        var minJ = -1\n        for (i <- 0 until n; j <-\
    \ 0 until m) {\n            if (dp(i)(j)(k.toInt) < min) {\n                min\
    \ = dp(i)(j)(k.toInt)\n                minI = i\n                minJ = j\n  \
    \          }\n        }\n        val path = ArrayBuffer[Long]()\n        var i\
    \ = minI\n        var j = minJ\n        var l = k.toInt\n        while (l > 0)\
    \ {\n            path += grid(i)(j)\n            l -= 1\n            if (i > 0\
    \ && dp(i)(j)(l) == dp(i - 1)(j)(l - 1) + grid(i)(j", "        // Fill in the\
    \ code here\n        var result = List[Long]()\n        for (i <- 0 until grid.length)\
    \ {\n            for (j <- 0 until grid(i).length) {\n                var path\
    \ = List[Long]()\n                path = path :+ grid(i)(j)\n                var\
    \ pathLength = 1\n                var pathSum = grid(i)(j)\n                var\
    \ visited = Array.ofDim[Boolean](grid.length, grid(0).length)\n              \
    \  visited(i)(j) = true\n                var queue = Queue[(Int, Int)]()\n   \
    \             queue.enqueue((i, j))\n                while (!queue.isEmpty) {\n\
    \                    var (x, y) = queue.dequeue\n                    if (pathLength\
    \ == k) {\n                        if (result.isEmpty || pathSum < result.sum)\
    \ {\n                            result = path\n                        }\n  \
    \                      else if (pathSum == result.sum) {\n                   \
    \         if (path < result) {\n                                result = path\n\
    \                            }\n                        }\n                  \
    \  }\n                    else {\n                        if (x > 0 && !visited(x\
    \ - 1)(y)) {\n                            queue.enqueue((x - 1, y))\n        \
    \                    visited(x - 1)(y) = true\n                            path\
    \ = path :+ grid(x - 1)(y)\n                            pathLength += 1\n    \
    \                        pathSum += grid(x - 1)(y)\n                        }\n\
    \                        if (x < grid.length - 1 && !visited(x + 1)(y)) {\n  \
    \                          queue.enqueue((x + 1, y))\n                       \
    \     visited(x + 1)(y) = true\n                            path = path :+ grid(x\
    \ + 1)(y)\n                            pathLength += 1\n                     \
    \       pathSum += grid(x + 1)(y)\n                        }\n               \
    \         if (y > 0 && !visited(x)(y - 1)) {\n                            queue.enqueue((x,\
    \ y - 1))\n                            visited(x)(y - 1) = true\n            \
    \                path = path :+ grid(x)(y - 1)\n                            pathLength\
    \ += 1\n                            pathSum += grid(x)(y - 1)\n              \
    \          }\n                       ", "        // Fill in the code here\n  \
    \      val n = grid.length\n        val m = grid(0).length\n        val dp = Array.ofDim[Long](n,\
    \ m, k.toInt + 1)\n        val path = Array.ofDim[(Int, Int)](n, m, k.toInt +\
    \ 1)\n        for (i <- 0 until n; j <- 0 until m) {\n            dp(i)(j)(1)\
    \ = grid(i)(j)\n            path(i)(j)(1) = (i, j)\n        }\n        for (l\
    \ <- 2 to k.toInt) {\n            for (i <- 0 until n; j <- 0 until m) {\n   \
    \             dp(i)(j)(l) = Long.MaxValue\n                path(i)(j)(l) = (-1,\
    \ -1)\n                if (i > 0 && dp(i - 1)(j)(l - 1) < dp(i)(j)(l)) {\n   \
    \                 dp(i)(j)(l) = dp(i - 1)(j)(l - 1)\n                    path(i)(j)(l)\
    \ = (i - 1, j)\n                }\n                if (i < n - 1 && dp(i + 1)(j)(l\
    \ - 1) < dp(i)(j)(l)) {\n                    dp(i)(j)(l) = dp(i + 1)(j)(l - 1)\n\
    \                    path(i)(j)(l) = (i + 1, j)\n                }\n         \
    \       if (j > 0 && dp(i)(j - 1)(l - 1) < dp(i)(j)(l)) {\n                  \
    \  dp(i)(j)(l) = dp(i)(j - 1)(l - 1)\n                    path(i)(j)(l) = (i,\
    \ j - 1)\n                }\n                if (j < m - 1 && dp(i)(j + 1)(l -\
    \ 1) < dp(i)(j)(l)) {\n                    dp(i)(j)(l) = dp(i)(j + 1)(l - 1)\n\
    \                    path(i)(j)(l) = (i, j + 1)\n                }\n", "     \
    \   val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(List[Long]())\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                dp(i)(j) = List(grid(i)(j))\n                if (i > 0\
    \ && dp(i - 1)(j).length <= k && dp(i - 1)(j).length < dp(i)(j).length) dp(i)(j)\
    \ = dp(i - 1)(j)\n                if (j > 0 && dp(i)(j - 1).length <= k && dp(i)(j\
    \ - 1).length < dp(i)(j).length) dp(i)(j) = dp(i)(j - 1)\n                if (i\
    \ > 0 && j > 0 && dp(i - 1)(j - 1).length <= k && dp(i - 1)(j - 1).length < dp(i)(j).length)\
    \ dp(i)(j) = dp(i - 1)(j - 1)\n                if (i > 0 && j < m - 1 && dp(i\
    \ - 1)(j + 1).length <= k && dp(i - 1)(j + 1).length < dp(i)(j).length) dp(i)(j)\
    \ = dp(i - 1)(j + 1)\n                if (i < n - 1 && j > 0 && dp(i + 1)(j -\
    \ 1).length <= k && dp(i + 1)(j - 1).length < dp(i)(j).length) dp(i)(j) = dp(i\
    \ + 1)(j - 1)\n                if (i < n - 1 && dp(i + 1)(j).length <= k && dp(i\
    \ + 1)(j).length < dp(i)(j).length) dp(i)(j) = dp(i + 1)(j)\n                if\
    \ (i < n - 1 && j < m - 1 && dp(i + 1)(j + 1).length <= k && dp(i + 1)(j + 1).length\
    \ < dp(i)(j).", "        // Write your code here\n        // Return the list of\
    \ values on the cells that the minimum path go through\n        // You can add\
    \ more functions as you wish\n        // Note: the solution will be judged on\
    \ the correctness and the style of the code\n        val n = grid.length\n   \
    \     val m = grid(0).length\n        val dp = Array.ofDim[Long](n, m, k.toInt\
    \ + 1)\n        for (i <- 0 until n; j <- 0 until m; l <- 0 to k.toInt) {\n  \
    \          dp(i)(j)(l) = Long.MaxValue\n        }\n        for (i <- 0 until n;\
    \ j <- 0 until m) {\n            dp(i)(j)(1) = grid(i)(j)\n        }\n       \
    \ for (l <- 2 to k.toInt) {\n            for (i <- 0 until n; j <- 0 until m)\
    \ {\n                if (i > 0) dp(i)(j)(l) = min(dp(i)(j)(l), dp(i - 1)(j)(l\
    \ - 1))\n                if (i < n - 1) dp(i)(j)(l) = min(dp(i)(j)(l), dp(i +\
    \ 1)(j)(l - 1))\n                if (j > 0) dp(i)(j)(l) = min(dp(i)(j)(l), dp(i)(j\
    \ - 1)(l - 1))\n                if (j < m - 1) dp(i)(j)(l) = min(dp(i)(j)(l),\
    \ dp(i)(j + 1)(l - 1))\n            }\n        }\n        var min = Long.MaxValue\n\
    \        var min_i = -1\n        var min_j = -1\n        for (i <- 0 until n;\
    \ j <- 0 until m) {\n            if (dp(i)(j)(k.toInt) < min) {\n            \
    \    min = dp(i)(j)(k.toInt)\n                min_i = i\n                min_j\
    \ = j\n            }\n        }\n        var ans = List[Long]()\n        var i\
    \ = min_i\n        var j = min_j\n        for", "        // Your code here\n \
    \       return List[Long]()", "        // Write your code here\n        return\
    \ List[Long]()", "        // Your code here\n        return List[Long]()", " \
    \       // Write your code here\n        return List[Long]()", "        val n\
    \ = grid.length\n        val dp = Array.fill(n, n)(List[Long]())\n        for\
    \ (i <- 0 until n) {\n            for (j <- 0 until n) {\n                if (i\
    \ == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n                else {\n      \
    \              val l = if (i > 0) dp(i - 1)(j) else List[Long]()\n           \
    \         val r = if (j > 0) dp(i)(j - 1) else List[Long]()\n                \
    \    val u = if (i < n - 1) dp(i + 1)(j) else List[Long]()\n                 \
    \   val d = if (j < n - 1) dp(i)(j + 1) else List[Long]()\n                  \
    \  val lst = List(l, r, u, d).filter(_.length > 0).sortWith(lexicographicLessThan)\n\
    \                    if (lst.length > 0) dp(i)(j) = lst(0) :+ grid(i)(j)\n   \
    \                 else dp(i)(j) = List(grid(i)(j))\n                }\n      \
    \      }\n        }\n        dp(n - 1)(n - 1).take(k.toInt)", "        // Write\
    \ your code here\n        var n = grid.length\n        var m = grid(0).length\n\
    \        var dp = Array.ofDim[Long](n, m, k.toInt + 1)\n        for (i <- 0 until\
    \ n) {\n            for (j <- 0 until m) {\n                dp(i)(j)(1) = grid(i)(j)\n\
    \            }\n        }\n        for (i <- 0 until n) {\n            for (j\
    \ <- 0 until m) {\n                for (l <- 2 to k.toInt) {\n               \
    \     dp(i)(j)(l) = Long.MaxValue\n                    if (i > 0) dp(i)(j)(l)\
    \ = min(dp(i)(j)(l), dp(i - 1)(j)(l - 1))\n                    if (i < n - 1)\
    \ dp(i)(j)(l) = min(dp(i)(j)(l), dp(i + 1)(j)(l - 1))\n                    if\
    \ (j > 0) dp(i)(j)(l) = min(dp(i)(j)(l), dp(i)(j - 1)(l - 1))\n              \
    \      if (j < m - 1) dp(i)(j)(l) = min(dp(i)(j)(l), dp(i)(j + 1)(l - 1))\n  \
    \                  dp(i)(j)(l) += grid(i)(j)\n                }\n            }\n\
    \        }\n        var min = Long.MaxValue\n        var minI = -1\n        var\
    \ minJ = -1\n        for (i <- 0 until n) {\n            for (j <- 0 until m)\
    \ {\n                if (dp(i)(j)(k.toInt) < min) {\n                    min =\
    \ dp(i)(j)(k.toInt)\n                    minI = i\n                    minJ =\
    \ j\n                }\n            }\n        }\n        var result = ListBuffer[Long]()\n\
    \        result += grid(minI)(minJ)\n        var curI = minI\n        var curJ\
    \ = minJ\n        for (l <- k.toInt - 1 to 1 by -1) {\n            if (curI >\
    \ 0 &&", "        // Your code goes here\n        val n = grid.length\n      \
    \  val m = grid(0).length\n        val dp = Array.ofDim[Long](n, m, k.toInt +\
    \ 1)\n        val path = Array.ofDim[Long](n, m, k.toInt + 1)\n        for (i\
    \ <- 0 until n) {\n            for (j <- 0 until m) {\n                dp(i)(j)(1)\
    \ = grid(i)(j)\n                path(i)(j)(1) = grid(i)(j)\n            }\n  \
    \      }\n        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n\
    \                for (step <- 2 to k.toInt) {\n                    val dirs =\
    \ List((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1))\n                    var\
    \ min = Long.MaxValue\n                    var minPath = List[Long]()\n      \
    \              for (dir <- dirs) {\n                        if (dir._1 >= 0 &&\
    \ dir._1 < n && dir._2 >= 0 && dir._2 < m) {\n                            if (dp(dir._1)(dir._2)(step\
    \ - 1) < min) {\n                                min = dp(dir._1)(dir._2)(step\
    \ - 1)\n                                minPath = path(dir._1)(dir._2)(step -\
    \ 1)\n                            }\n                        }\n             \
    \       }\n                    dp(i)(j)(step) = min + grid(i)(j)\n           \
    \         path(i)(j)(step) = minPath :+ grid(i)(j)\n                }\n      \
    \      }\n        }\n        var min = Long.MaxValue\n        var minPath = List[Long]()\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n        \
    \        if (dp(i)(j)(k.toInt) < min) {\n                    min = dp(i)(j)(k.toInt)\n\
    \                    minPath = path(i)(j)(k.toInt)\n                }\n      \
    \      }\n        }\n        minPath", "        // Your code here\n        null",
  "        val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(Long.MaxValue)\n        val path = Array.fill(n, m)(List[Long]())\n     \
    \   for (i <- 0 until n) {\n            for (j <- 0 until m) {\n             \
    \   if (i == 0 && j == 0) {\n                    dp(i)(j) = grid(i)(j)\n     \
    \               path(i)(j) = List(grid(i)(j))\n                }\n           \
    \     else {\n                    if (i > 0 && dp(i - 1)(j) < dp(i)(j)) {\n  \
    \                      dp(i)(j) = dp(i - 1)(j)\n                        path(i)(j)\
    \ = path(i - 1)(j)\n                    }\n                    if (j > 0 && dp(i)(j\
    \ - 1) < dp(i)(j)) {\n                        dp(i)(j) = dp(i)(j - 1)\n      \
    \                  path(i)(j) = path(i)(j - 1)\n                    }\n      \
    \              dp(i)(j) += grid(i)(j)\n                    path(i)(j) = path(i)(j)\
    \ :+ grid(i)(j)\n                }\n            }\n        }\n        path(n -\
    \ 1)(m - 1).take(k.toInt)", "        // Write your code here\n        return List[Long]()",
  "        // Write your code here\n        return List[Long]()", "        val n =\
    \ grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(List[Long]())\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                dp(i)(j) = List(grid(i)(j))\n                if (i > 0\
    \ && dp(i - 1)(j).length < k) {\n                    val newPath = dp(i - 1)(j)\
    \ :+ grid(i)(j)\n                    if (newPath.length == k) {\n            \
    \            if (dp(i)(j).length == k) {\n                            if (newPath\
    \ < dp(i)(j)) dp(i)(j) = newPath\n                        } else dp(i)(j) = newPath\n\
    \                    } else if (newPath.length < k) dp(i)(j) = newPath\n     \
    \           }\n                if (j > 0 && dp(i)(j - 1).length < k) {\n     \
    \               val newPath = dp(i)(j - 1) :+ grid(i)(j)\n                   \
    \ if (newPath.length == k) {\n                        if (dp(i)(j).length == k)\
    \ {\n                            if (newPath < dp(i)(j)) dp(i)(j) = newPath\n\
    \                        } else dp(i)(j) = newPath\n                    } else\
    \ if (newPath.length < k) dp(i)(j) = newPath\n                }\n            }\n\
    \        }\n        dp(n - 1)(m - 1)", "        // Your code here\n        return\
    \ List[Long]()", "        // Write your code here\n        // Return the ordered\
    \ list of the values on the cells that the minimum path go through\n        val\
    \ n = grid.length\n        val m = grid(0).length\n        val dp = Array.ofDim[Long](n,\
    \ m, k.toInt + 1)\n        val path = Array.ofDim[Long](n, m, k.toInt + 1)\n \
    \       for (i <- 0 until n) {\n            for (j <- 0 until m) {\n         \
    \       dp(i)(j)(1) = grid(i)(j)\n                path(i)(j)(1) = grid(i)(j)\n\
    \            }\n        }\n        for (l <- 2 to k.toInt) {\n            for\
    \ (i <- 0 until n) {\n                for (j <- 0 until m) {\n               \
    \     dp(i)(j)(l) = Long.MaxValue\n                    for (x <- 0 until n) {\n\
    \                        for (y <- 0 until m) {\n                            if\
    \ (abs(x - i) + abs(y - j) == 1) {\n                                if (dp(x)(y)(l\
    \ - 1) < dp(i)(j)(l)) {\n                                    dp(i)(j)(l) = dp(x)(y)(l\
    \ - 1)\n                                    path(i)(j)(l) = grid(i)(j)\n     \
    \                           }\n                            }\n               \
    \         }\n                    }\n                }\n            }\n       \
    \ }\n        var min = Long.MaxValue\n        var min_i = 0\n        var min_j\
    \ = 0\n        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n  \
    \              if (dp(i)(j)(k.toInt) < min) {\n                    min = dp(i)(j)(k.toInt)\n\
    \                    min_i = i\n                    min_j = j\n              \
    \  }\n            }\n        }\n        var res = List[Long]()\n        var cur\
    \ = k.toInt\n        while (cur > 0) {\n            res = path(min_i)(min_j)(cur)\
    \ :: res\n            for (x <- 0 until n) {\n                for (y <- 0 until\
    \ m", "        // Write your code here\n        return List[Long]()", "      \
    \  val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(List[Long]())\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                val lst = List(grid(i)(j))\n                dp(i)(j) =\
    \ lst\n                if (i > 0 && lst < dp(i - 1)(j)) dp(i)(j) = lst\n     \
    \           if (j > 0 && lst < dp(i)(j - 1)) dp(i)(j) = lst\n                if\
    \ (i > 0 && j > 0 && lst < dp(i - 1)(j - 1)) dp(i)(j) = lst\n                if\
    \ (i > 0 && j < m - 1 && lst < dp(i - 1)(j + 1)) dp(i)(j) = lst\n            }\n\
    \        }\n        for (i <- 1 until n) {\n            for (j <- 1 until m) {\n\
    \                val lst = dp(i - 1)(j - 1) :+ grid(i)(j)\n                if\
    \ (lst < dp(i)(j)) dp(i)(j) = lst\n            }\n        }\n        for (i <-\
    \ 0 until n) {\n            for (j <- m - 2 to 0 by -1) {\n                val\
    \ lst = dp(i)(j + 1) :+ grid(i)(j)\n                if (lst < dp(i)(j)) dp(i)(j)\
    \ = lst\n            }\n        }\n        for (i <- n - 2 to 0 by -1) {\n   \
    \         for (j <- 0 until m) {\n                val lst = dp(i + 1)(j) :+ grid(i)(j)\n\
    \                if (lst < dp(i)(j)) dp(i)(j) = lst\n            }\n        }\n\
    \        for (i <- n - 2 to 0 by -1) {\n            for (j <- m - 2 to 0 by -1)\
    \ {\n                val lst = dp(i + 1)(j + 1) :", "        // Your code here\n\
    \        return List[Long]()", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.fill(n, m)(List[Long]())\n        for (i <- 0 until n)\
    \ {\n            for (j <- 0 until m) {\n                if (i == 0 && j == 0)\
    \ dp(i)(j) = List(grid(i)(j))\n                else if (i == 0) {\n          \
    \          val prev = dp(i)(j - 1)\n                    val cur = grid(i)(j)\n\
    \                    if (prev.length < k) dp(i)(j) = prev :+ cur\n           \
    \         else if (prev.length == k) {\n                        if (prev.last\
    \ > cur) dp(i)(j) = prev.init :+ cur\n                        else dp(i)(j) =\
    \ prev\n                    }\n                    else dp(i)(j) = prev\n    \
    \            }\n                else if (j == 0) {\n                    val prev\
    \ = dp(i - 1)(j)\n                    val cur = grid(i)(j)\n                 \
    \   if (prev.length < k) dp(i)(j) = prev :+ cur\n                    else if (prev.length\
    \ == k) {\n                        if (prev.last > cur) dp(i)(j) = prev.init :+\
    \ cur\n                        else dp(i)(j) = prev\n                    }\n \
    \                   else dp(i)(j) = prev\n                }\n                else\
    \ {\n                    val prev1 = dp(i - 1)(j)\n                    val prev2\
    \ = dp(i)(j - 1)\n                    val cur = grid(i)(j)\n                 \
    \   if (prev1.length < k && prev2.length < k) {\n                        if (prev1.last\
    \ < prev2.last) dp(i)(j) = prev1 :+ cur\n                        else dp(i)(j)\
    \ = prev2 :+ cur\n                    }\n                    else if (prev1.length\
    \ < k) {\n                        if (prev1.last < prev2.last) dp(i)(j) = prev1\
    \ :+ cur\n                        else dp(i)(j) = prev2\n                    }\n\
    \                    else if (prev2.length < k) {"]
stop_tokens:
- "\n    }\n"
