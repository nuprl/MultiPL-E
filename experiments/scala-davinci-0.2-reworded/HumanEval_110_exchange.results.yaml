language: scala
name: HumanEval_110_exchange
results:
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpiz0pkx1i.scala:22)\n\tat Problem.main(tmpiz0pkx1i.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        val lst1_odd = lst1.filter(x => x % 2 == 1)\n   \
    \     val lst2_even = lst2.filter(x => x % 2 == 0)\n        if (lst1_odd.length\
    \ <= lst2_even.length) \"YES\" else \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        null\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.NullPointerException: Cannot invoke \"String.equals(Object)\"\
    \ because the return value of \"Problem$.exchange(scala.collection.immutable.List,\
    \ scala.collection.immutable.List)\" is null\n\tat Problem$.main(tmpvos2b8_y.scala:22)\n\
    \tat Problem.main(tmpvos2b8_y.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        val lst1_even = lst1.filter(x => x % 2 == 0)\n  \
    \      val lst2_odd = lst2.filter(x => x % 2 == 1)\n        if (lst1_even.length\
    \ + lst2_odd.length >= lst1.length) \"YES\" else \"NO\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpzvkw8gq8.scala:25)\n\tat Problem.main(tmpzvkw8gq8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794235
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        if (lst1.forall(x => x % 2 == 0)) return \"YES\"\n\
    \        else if (lst2.forall(x => x % 2 == 0)) return \"YES\"\n        else {\n\
    \            var lst1_odd = lst1.filter(x => x % 2 == 1)\n            var lst2_odd\
    \ = lst2.filter(x => x % 2 == 1)\n            if (lst1_odd.length == lst2_odd.length)\
    \ return \"YES\"\n            else return \"NO\"\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        return \"\";\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6ef5h24w.scala:22)\n\tat Problem.main(tmp6ef5h24w.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        return \"\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpf1jmku_q.scala:22)\n\tat Problem.main(tmpf1jmku_q.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Fill in the code here\n        \"YES\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0qsufc46.scala:23)\n\tat Problem.main(tmp0qsufc46.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Fill in the code here\n        \"YES\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0qsufc46.scala:23)\n\tat Problem.main(tmp0qsufc46.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        val lst1_odd = lst1.filter(x => x % 2 == 1)\n   \
    \     val lst2_even = lst2.filter(x => x % 2 == 0)\n        if (lst1_odd.length\
    \ <= lst2_even.length) \"YES\" else \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        var lst1Even = lst1.filter(x => x % 2 == 0)\n   \
    \     var lst2Odd = lst2.filter(x => x % 2 != 0)\n        if (lst1Even.length\
    \ >= lst2Odd.length) \"YES\" else \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659794235
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpiz0pkx1i.scala:22)\n\tat Problem.main(tmpiz0pkx1i.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        if (lst1.exists(x => x % 2 == 1)) {\n           \
    \ if (lst2.exists(x => x % 2 == 0)) {\n                \"YES\"\n            }\
    \ else {\n                \"NO\"\n            }\n        } else {\n          \
    \  \"YES\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpz56iou6e.scala:31)\n\tat Problem.main(tmpz56iou6e.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        null\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.NullPointerException: Cannot invoke \"String.equals(Object)\"\
    \ because the return value of \"Problem$.exchange(scala.collection.immutable.List,\
    \ scala.collection.immutable.List)\" is null\n\tat Problem$.main(tmpvos2b8_y.scala:22)\n\
    \tat Problem.main(tmpvos2b8_y.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpiz0pkx1i.scala:22)\n\tat Problem.main(tmpiz0pkx1i.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        \"YES\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7m0l2vc5.scala:23)\n\tat Problem.main(tmp7m0l2vc5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        \"YES\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7m0l2vc5.scala:23)\n\tat Problem.main(tmp7m0l2vc5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        null\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.NullPointerException: Cannot invoke \"String.equals(Object)\"\
    \ because the return value of \"Problem$.exchange(scala.collection.immutable.List,\
    \ scala.collection.immutable.List)\" is null\n\tat Problem$.main(tmpvos2b8_y.scala:22)\n\
    \tat Problem.main(tmpvos2b8_y.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        val lst1_odd = lst1.filter(_ % 2 == 1)\n        val\
    \ lst2_even = lst2.filter(_ % 2 == 0)\n        if (lst1_odd.length <= lst2_even.length)\
    \ \"YES\" else \"NO\"\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        if (lst1.forall(x => x % 2 == 0)) \"YES\"\n     \
    \   else if (lst2.forall(x => x % 2 == 0)) \"YES\"\n        else {\n         \
    \   val lst1_odd = lst1.filter(x => x % 2 == 1)\n            val lst2_odd = lst2.filter(x\
    \ => x % 2 == 1)\n            if (lst1_odd.length == lst2_odd.length) \"YES\"\n\
    \            else \"NO\"\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659794235
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        val lst1_odd = lst1.filter(_ % 2 == 1)\n        val\
    \ lst2_even = lst2.filter(_ % 2 == 0)\n        if (lst1_odd.length <= lst2_even.length)\
    \ \"YES\" else \"NO\"\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your Code Here\n        \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpk4feh3jt.scala:22)\n\tat Problem.main(tmpk4feh3jt.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794235
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        return \"\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpf1jmku_q.scala:22)\n\tat Problem.main(tmpf1jmku_q.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        \"YES\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7m0l2vc5.scala:23)\n\tat Problem.main(tmp7m0l2vc5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpiz0pkx1i.scala:22)\n\tat Problem.main(tmpiz0pkx1i.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        if (lst1.forall(x => x % 2 == 0)) \"YES\"\n     \
    \   else {\n            val lst1odd = lst1.filter(x => x % 2 == 1)\n         \
    \   val lst2even = lst2.filter(x => x % 2 == 0)\n            if (lst1odd.size\
    \ <= lst2even.size) \"YES\"\n            else \"NO\"\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpiz0pkx1i.scala:22)\n\tat Problem.main(tmpiz0pkx1i.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        null\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.NullPointerException: Cannot invoke \"String.equals(Object)\"\
    \ because the return value of \"Problem$.exchange(scala.collection.immutable.List,\
    \ scala.collection.immutable.List)\" is null\n\tat Problem$.main(tmpvos2b8_y.scala:22)\n\
    \tat Problem.main(tmpvos2b8_y.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        \"YES\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7m0l2vc5.scala:23)\n\tat Problem.main(tmp7m0l2vc5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpiz0pkx1i.scala:22)\n\tat Problem.main(tmpiz0pkx1i.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your Code Here\n        return \"\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpq2tn6g75.scala:22)\n\tat Problem.main(tmpq2tn6g75.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794235
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpiz0pkx1i.scala:22)\n\tat Problem.main(tmpiz0pkx1i.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        \"YES\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7m0l2vc5.scala:23)\n\tat Problem.main(tmp7m0l2vc5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpiz0pkx1i.scala:22)\n\tat Problem.main(tmpiz0pkx1i.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpiz0pkx1i.scala:22)\n\tat Problem.main(tmpiz0pkx1i.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        if (lst1.filter(_ % 2 == 0).length == lst1.length)\
    \ \"YES\"\n        else if (lst2.filter(_ % 2 == 0).length == lst2.length) \"\
    YES\"\n        else \"NO\"\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpyut7s_i8.scala:24)\n\tat Problem.main(tmpyut7s_i8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        null\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.NullPointerException: Cannot invoke \"String.equals(Object)\"\
    \ because the return value of \"Problem$.exchange(scala.collection.immutable.List,\
    \ scala.collection.immutable.List)\" is null\n\tat Problem$.main(tmpvos2b8_y.scala:22)\n\
    \tat Problem.main(tmpvos2b8_y.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        val odd1 = lst1.filter(x => x % 2 == 1)\n       \
    \ val odd2 = lst2.filter(x => x % 2 == 1)\n        if (odd1.size == odd2.size)\
    \ \"YES\" else \"NO\"\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp9vqusio7.scala:27)\n\tat Problem.main(tmp9vqusio7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        null\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.NullPointerException: Cannot invoke \"String.equals(Object)\"\
    \ because the return value of \"Problem$.exchange(scala.collection.immutable.List,\
    \ scala.collection.immutable.List)\" is null\n\tat Problem$.main(tmpvos2b8_y.scala:22)\n\
    \tat Problem.main(tmpvos2b8_y.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Fill in the code here\n        \"YES\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0qsufc46.scala:23)\n\tat Problem.main(tmp0qsufc46.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        \"YES\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7m0l2vc5.scala:23)\n\tat Problem.main(tmp7m0l2vc5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpiz0pkx1i.scala:22)\n\tat Problem.main(tmpiz0pkx1i.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        return \"\";\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6ef5h24w.scala:22)\n\tat Problem.main(tmp6ef5h24w.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        return \"\";\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6ef5h24w.scala:22)\n\tat Problem.main(tmp6ef5h24w.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpiz0pkx1i.scala:22)\n\tat Problem.main(tmpiz0pkx1i.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpiz0pkx1i.scala:22)\n\tat Problem.main(tmpiz0pkx1i.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        var lst1Odd = List[Long]()\n        var lst2Even\
    \ = List[Long]()\n        for (i <- lst1) {\n            if (i % 2 == 1) lst1Odd\
    \ = i :: lst1Odd\n        }\n        for (i <- lst2) {\n            if (i % 2\
    \ == 0) lst2Even = i :: lst2Even\n        }\n        if (lst1Odd.length <= lst2Even.length)\
    \ \"YES\" else \"NO\"\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        var even1 = 0\n        var even2 = 0\n        for\
    \ (i <- lst1) {\n            if (i % 2 == 0) even1 += 1\n        }\n        for\
    \ (i <- lst2) {\n            if (i % 2 == 0) even2 += 1\n        }\n        if\
    \ (even1 == lst1.length || even2 == lst2.length) \"YES\" else \"NO\"\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpun9fa4zn.scala:30)\n\tat Problem.main(tmpun9fa4zn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        null\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.NullPointerException: Cannot invoke \"String.equals(Object)\"\
    \ because the return value of \"Problem$.exchange(scala.collection.immutable.List,\
    \ scala.collection.immutable.List)\" is null\n\tat Problem$.main(tmpvos2b8_y.scala:22)\n\
    \tat Problem.main(tmpvos2b8_y.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpiz0pkx1i.scala:22)\n\tat Problem.main(tmpiz0pkx1i.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        null\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.NullPointerException: Cannot invoke \"String.equals(Object)\"\
    \ because the return value of \"Problem$.exchange(scala.collection.immutable.List,\
    \ scala.collection.immutable.List)\" is null\n\tat Problem$.main(tmpvos2b8_y.scala:22)\n\
    \tat Problem.main(tmpvos2b8_y.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Fill in the code here\n        \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5akdo1hp.scala:22)\n\tat Problem.main(tmp5akdo1hp.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794235
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        null\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.NullPointerException: Cannot invoke \"String.equals(Object)\"\
    \ because the return value of \"Problem$.exchange(scala.collection.immutable.List,\
    \ scala.collection.immutable.List)\" is null\n\tat Problem$.main(tmpvos2b8_y.scala:22)\n\
    \tat Problem.main(tmpvos2b8_y.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        val lst1Even = lst1.filter(x => x % 2 == 0)\n   \
    \     val lst2Even = lst2.filter(x => x % 2 == 0)\n        if (lst1Even.length\
    \ == lst1.length) \"YES\"\n        else if (lst2Even.length == lst2.length) \"\
    YES\"\n        else if (lst1Even.length + lst2Even.length >= lst1.length) \"YES\"\
    \n        else \"NO\"\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        null\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.NullPointerException: Cannot invoke \"String.equals(Object)\"\
    \ because the return value of \"Problem$.exchange(scala.collection.immutable.List,\
    \ scala.collection.immutable.List)\" is null\n\tat Problem$.main(tmpvos2b8_y.scala:22)\n\
    \tat Problem.main(tmpvos2b8_y.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpiz0pkx1i.scala:22)\n\tat Problem.main(tmpiz0pkx1i.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpiz0pkx1i.scala:22)\n\tat Problem.main(tmpiz0pkx1i.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        val lst1Even = lst1.filter(_ % 2 == 0)\n        val\
    \ lst2Even = lst2.filter(_ % 2 == 0)\n        if (lst1Even.length == lst1.length)\
    \ \"YES\"\n        else if (lst2Even.length == lst2.length) \"YES\"\n        else\
    \ if (lst1Even.length + lst2Even.length >= lst1.length) \"YES\"\n        else\
    \ \"NO\"\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpiz0pkx1i.scala:22)\n\tat Problem.main(tmpiz0pkx1i.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        null\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.NullPointerException: Cannot invoke \"String.equals(Object)\"\
    \ because the return value of \"Problem$.exchange(scala.collection.immutable.List,\
    \ scala.collection.immutable.List)\" is null\n\tat Problem$.main(tmpvos2b8_y.scala:22)\n\
    \tat Problem.main(tmpvos2b8_y.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        null\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.NullPointerException: Cannot invoke \"String.equals(Object)\"\
    \ because the return value of \"Problem$.exchange(scala.collection.immutable.List,\
    \ scala.collection.immutable.List)\" is null\n\tat Problem$.main(tmpvos2b8_y.scala:22)\n\
    \tat Problem.main(tmpvos2b8_y.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        if (lst1.forall(_ % 2 == 0)) \"YES\"\n        else\
    \ {\n            val lst1odd = lst1.filter(_ % 2 == 1)\n            val lst2even\
    \ = lst2.filter(_ % 2 == 0)\n            if (lst1odd.size == lst2even.size) \"\
    YES\"\n            else \"NO\"\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659794255
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        return \"\";\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6ef5h24w.scala:22)\n\tat Problem.main(tmp6ef5h24w.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        var lst1_odd = List[Long]()\n        var lst2_even\
    \ = List[Long]()\n        for (i <- lst1) {\n            if (i % 2 == 1) {\n \
    \               lst1_odd = lst1_odd :+ i\n            }\n        }\n        for\
    \ (i <- lst2) {\n            if (i % 2 == 0) {\n                lst2_even = lst2_even\
    \ :+ i\n            }\n        }\n        if (lst1_odd.length <= lst2_even.length)\
    \ {\n            return \"YES\"\n        }\n        return \"NO\"\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659794255
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpiz0pkx1i.scala:22)\n\tat Problem.main(tmpiz0pkx1i.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        return \"\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpf1jmku_q.scala:22)\n\tat Problem.main(tmpf1jmku_q.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        val lst1Even = lst1.filter(x => x % 2 == 0)\n   \
    \     val lst2Even = lst2.filter(x => x % 2 == 0)\n        if (lst1Even.length\
    \ == lst1.length) \"YES\"\n        else if (lst2Even.length == lst2.length) \"\
    YES\"\n        else if (lst1Even.length + lst2Even.length >= lst1.length) \"YES\"\
    \n        else \"NO\"\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        null\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.NullPointerException: Cannot invoke \"String.equals(Object)\"\
    \ because the return value of \"Problem$.exchange(scala.collection.immutable.List,\
    \ scala.collection.immutable.List)\" is null\n\tat Problem$.main(tmpvos2b8_y.scala:22)\n\
    \tat Problem.main(tmpvos2b8_y.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your Code Here\n        null\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.NullPointerException: Cannot invoke \"String.equals(Object)\"\
    \ because the return value of \"Problem$.exchange(scala.collection.immutable.List,\
    \ scala.collection.immutable.List)\" is null\n\tat Problem$.main(tmp82o27bcl.scala:22)\n\
    \tat Problem.main(tmp82o27bcl.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794255
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        null\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.NullPointerException: Cannot invoke \"String.equals(Object)\"\
    \ because the return value of \"Problem$.exchange(scala.collection.immutable.List,\
    \ scala.collection.immutable.List)\" is null\n\tat Problem$.main(tmpvos2b8_y.scala:22)\n\
    \tat Problem.main(tmpvos2b8_y.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpiz0pkx1i.scala:22)\n\tat Problem.main(tmpiz0pkx1i.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Fill in the code here\n        var lst1_odd = List[Long]()\n        var lst2_even\
    \ = List[Long]()\n        for (i <- lst1) {\n            if (i % 2 == 1) {\n \
    \               lst1_odd = lst1_odd :+ i\n            }\n        }\n        for\
    \ (i <- lst2) {\n            if (i % 2 == 0) {\n                lst2_even = lst2_even\
    \ :+ i\n            }\n        }\n        if (lst1_odd.length <= lst2_even.length)\
    \ {\n            \"YES\"\n        } else {\n            \"NO\"\n        }\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659794255
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        null\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.NullPointerException: Cannot invoke \"String.equals(Object)\"\
    \ because the return value of \"Problem$.exchange(scala.collection.immutable.List,\
    \ scala.collection.immutable.List)\" is null\n\tat Problem$.main(tmpvos2b8_y.scala:22)\n\
    \tat Problem.main(tmpvos2b8_y.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        var evens = lst1.filter(x => x % 2 == 0)\n      \
    \  var odds = lst2.filter(x => x % 2 == 1)\n        if (evens.length == lst1.length)\
    \ {\n            return \"YES\"\n        }\n        if (odds.length == lst2.length)\
    \ {\n            return \"NO\"\n        }\n        return \"YES\"\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp3cc9nvk_.scala:31)\n\tat Problem.main(tmp3cc9nvk_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794255
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        val lst1Even = lst1.filter(_ % 2 == 0)\n        val\
    \ lst2Even = lst2.filter(_ % 2 == 0)\n        if (lst1Even.length == lst1.length)\
    \ \"YES\"\n        else if (lst2Even.length == lst2.length) \"YES\"\n        else\
    \ if (lst1Even.length + lst2Even.length >= lst1.length) \"YES\"\n        else\
    \ \"NO\"\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        null\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.NullPointerException: Cannot invoke \"String.equals(Object)\"\
    \ because the return value of \"Problem$.exchange(scala.collection.immutable.List,\
    \ scala.collection.immutable.List)\" is null\n\tat Problem$.main(tmpvos2b8_y.scala:22)\n\
    \tat Problem.main(tmpvos2b8_y.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        \"YES\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7m0l2vc5.scala:23)\n\tat Problem.main(tmp7m0l2vc5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        null\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.NullPointerException: Cannot invoke \"String.equals(Object)\"\
    \ because the return value of \"Problem$.exchange(scala.collection.immutable.List,\
    \ scala.collection.immutable.List)\" is null\n\tat Problem$.main(tmpvos2b8_y.scala:22)\n\
    \tat Problem.main(tmpvos2b8_y.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        var even1 = 0\n        var even2 = 0\n        for\
    \ (i <- lst1) {\n            if (i % 2 == 0) even1 += 1\n        }\n        for\
    \ (i <- lst2) {\n            if (i % 2 == 0) even2 += 1\n        }\n        if\
    \ (even1 + even2 >= lst1.length) \"YES\" else \"NO\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659794256
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        return \"\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpf1jmku_q.scala:22)\n\tat Problem.main(tmpf1jmku_q.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        var lst1_even = lst1.filter(x => x % 2 == 0)\n  \
    \      var lst2_odd = lst2.filter(x => x % 2 != 0)\n        if (lst1_even.length\
    \ == lst1.length) {\n            return \"YES\"\n        }\n        else if (lst1_even.length\
    \ + lst2_odd.length >= lst1.length) {\n            return \"YES\"\n        }\n\
    \        else {\n            return \"NO\"\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmph3kg2vrl.scala:33)\n\tat Problem.main(tmph3kg2vrl.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794256
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Fill in the code here\n        \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5akdo1hp.scala:22)\n\tat Problem.main(tmp5akdo1hp.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794235
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        var lst1_odd = lst1.filter(x => x % 2 == 1)\n   \
    \     var lst2_even = lst2.filter(x => x % 2 == 0)\n        if (lst1_odd.length\
    \ <= lst2_even.length) \"YES\" else \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659794255
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        val lst1Even = lst1.filter(x => x % 2 == 0)\n   \
    \     val lst2Even = lst2.filter(x => x % 2 == 0)\n        if (lst1Even.length\
    \ == lst1.length) \"YES\"\n        else if (lst2Even.length == lst2.length) \"\
    YES\"\n        else \"NO\"\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0vvkhw2i.scala:26)\n\tat Problem.main(tmp0vvkhw2i.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794255
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        \"YES\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7m0l2vc5.scala:23)\n\tat Problem.main(tmp7m0l2vc5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        val lst1_even = lst1.filter(x => x % 2 == 0)\n  \
    \      val lst2_odd = lst2.filter(x => x % 2 == 1)\n        if (lst1_even.length\
    \ >= lst1.length) \"YES\"\n        else if (lst1_even.length + lst2_odd.length\
    \ >= lst1.length) \"YES\"\n        else \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpn5f3wj7w.scala:27)\n\tat Problem.main(tmpn5f3wj7w.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794256
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        return \"\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpf1jmku_q.scala:22)\n\tat Problem.main(tmpf1jmku_q.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpiz0pkx1i.scala:22)\n\tat Problem.main(tmpiz0pkx1i.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        null\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.NullPointerException: Cannot invoke \"String.equals(Object)\"\
    \ because the return value of \"Problem$.exchange(scala.collection.immutable.List,\
    \ scala.collection.immutable.List)\" is null\n\tat Problem$.main(tmpvos2b8_y.scala:22)\n\
    \tat Problem.main(tmpvos2b8_y.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        null\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.NullPointerException: Cannot invoke \"String.equals(Object)\"\
    \ because the return value of \"Problem$.exchange(scala.collection.immutable.List,\
    \ scala.collection.immutable.List)\" is null\n\tat Problem$.main(tmpvos2b8_y.scala:22)\n\
    \tat Problem.main(tmpvos2b8_y.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        null\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.NullPointerException: Cannot invoke \"String.equals(Object)\"\
    \ because the return value of \"Problem$.exchange(scala.collection.immutable.List,\
    \ scala.collection.immutable.List)\" is null\n\tat Problem$.main(tmpvos2b8_y.scala:22)\n\
    \tat Problem.main(tmpvos2b8_y.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpiz0pkx1i.scala:22)\n\tat Problem.main(tmpiz0pkx1i.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        \"YES\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7m0l2vc5.scala:23)\n\tat Problem.main(tmp7m0l2vc5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        null\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.NullPointerException: Cannot invoke \"String.equals(Object)\"\
    \ because the return value of \"Problem$.exchange(scala.collection.immutable.List,\
    \ scala.collection.immutable.List)\" is null\n\tat Problem$.main(tmpvos2b8_y.scala:22)\n\
    \tat Problem.main(tmpvos2b8_y.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        val lst1Even = lst1.filter(_ % 2 == 0)\n        val\
    \ lst2Even = lst2.filter(_ % 2 == 0)\n        if (lst1Even.length == lst1.length)\
    \ \"YES\"\n        else if (lst2Even.length == lst2.length) \"YES\"\n        else\
    \ if (lst1Even.length + lst2Even.length >= lst1.length) \"YES\"\n        else\
    \ \"NO\"\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        var lst1Even = lst1.filter(x => x % 2 == 0)\n   \
    \     var lst2Odd = lst2.filter(x => x % 2 != 0)\n        if (lst1Even.length\
    \ >= lst2Odd.length) \"YES\" else \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659794235
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        return \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxcxyj3yz.scala:22)\n\tat Problem.main(tmpxcxyj3yz.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794255
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        null\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.NullPointerException: Cannot invoke \"String.equals(Object)\"\
    \ because the return value of \"Problem$.exchange(scala.collection.immutable.List,\
    \ scala.collection.immutable.List)\" is null\n\tat Problem$.main(tmpvos2b8_y.scala:22)\n\
    \tat Problem.main(tmpvos2b8_y.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        if (lst1.map(x => x % 2 == 0).reduce(_ && _)) \"\
    YES\"\n        else {\n            val odds = lst1.filter(x => x % 2 == 1)\n \
    \           val evens = lst2.filter(x => x % 2 == 0)\n            if (odds.length\
    \ <= evens.length) \"YES\"\n            else \"NO\"\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659794255
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpiz0pkx1i.scala:22)\n\tat Problem.main(tmpiz0pkx1i.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        if (lst1.forall(x => x % 2 == 0)) \"YES\"\n     \
    \   else {\n            val odd1 = lst1.filter(x => x % 2 == 1)\n            val\
    \ odd2 = lst2.filter(x => x % 2 == 1)\n            if (odd1.length == odd2.length)\
    \ \"YES\"\n            else \"NO\"\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp9_y6uwre.scala:31)\n\tat Problem.main(tmp9_y6uwre.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794255
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        return \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxcxyj3yz.scala:22)\n\tat Problem.main(tmpxcxyj3yz.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794255
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpiz0pkx1i.scala:22)\n\tat Problem.main(tmpiz0pkx1i.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpiz0pkx1i.scala:22)\n\tat Problem.main(tmpiz0pkx1i.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        null\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.NullPointerException: Cannot invoke \"String.equals(Object)\"\
    \ because the return value of \"Problem$.exchange(scala.collection.immutable.List,\
    \ scala.collection.immutable.List)\" is null\n\tat Problem$.main(tmpvos2b8_y.scala:22)\n\
    \tat Problem.main(tmpvos2b8_y.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpiz0pkx1i.scala:22)\n\tat Problem.main(tmpiz0pkx1i.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Write your code here\n        val lst1_odd = lst1.filter(x => x % 2 == 1)\n\
    \        val lst2_even = lst2.filter(x => x % 2 == 0)\n        if (lst1_odd.length\
    \ <= lst2_even.length) \"YES\" else \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659794256
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        return \"\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpf1jmku_q.scala:22)\n\tat Problem.main(tmpf1jmku_q.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        val lst1Even = lst1.filter(x => x % 2 == 0)\n   \
    \     val lst2Even = lst2.filter(x => x % 2 == 0)\n        if (lst1Even.length\
    \ == lst1.length) \"YES\"\n        else if (lst2Even.length == lst2.length) \"\
    YES\"\n        else \"NO\"\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0vvkhw2i.scala:26)\n\tat Problem.main(tmp0vvkhw2i.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794255
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Implement this function\n        \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpf_3it4q5.scala:22)\n\tat Problem.main(tmpf_3it4q5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794255
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        null\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.NullPointerException: Cannot invoke \"String.equals(Object)\"\
    \ because the return value of \"Problem$.exchange(scala.collection.immutable.List,\
    \ scala.collection.immutable.List)\" is null\n\tat Problem$.main(tmpvos2b8_y.scala:22)\n\
    \tat Problem.main(tmpvos2b8_y.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        return \"\";\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6ef5h24w.scala:22)\n\tat Problem.main(tmp6ef5h24w.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpiz0pkx1i.scala:22)\n\tat Problem.main(tmpiz0pkx1i.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        null\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.NullPointerException: Cannot invoke \"String.equals(Object)\"\
    \ because the return value of \"Problem$.exchange(scala.collection.immutable.List,\
    \ scala.collection.immutable.List)\" is null\n\tat Problem$.main(tmpvos2b8_y.scala:22)\n\
    \tat Problem.main(tmpvos2b8_y.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here.\n        if (lst1.filter(_ % 2 == 0).size == lst1.size) \"\
    YES\"\n        else if (lst2.filter(_ % 2 == 0).size == lst2.size) \"YES\"\n \
    \       else {\n            val lst1Odd = lst1.filter(_ % 2 == 1)\n          \
    \  val lst2Odd = lst2.filter(_ % 2 == 1)\n            if (lst1Odd.size == lst2Odd.size)\
    \ \"YES\"\n            else if (lst1Odd.size > lst2Odd.size) {\n             \
    \   val lst1OddMap = lst1Odd.groupBy(x => x).mapValues(_.size)\n             \
    \   val lst2OddMap = lst2Odd.groupBy(x => x).mapValues(_.size)\n             \
    \   val lst1OddMap2 = lst1OddMap.filter(x => lst2OddMap.contains(x._1))\n    \
    \            val lst2OddMap2 = lst2OddMap.filter(x => lst1OddMap.contains(x._1))\n\
    \                if (lst1OddMap2.size == lst2OddMap2.size) {\n               \
    \     val lst1OddMap3 = lst1OddMap2.filter(x => x._2 > lst2OddMap2(x._1))\n  \
    \                  val lst2OddMap3 = lst2OddMap2.filter(x => x._2 > lst1OddMap2(x._1))\n\
    \                    if (lst1OddMap3.size == lst2OddMap3.size) \"YES\"\n     \
    \               else \"NO\"\n                }\n                else \"NO\"\n\
    \            }\n            else {\n                val lst1OddMap = lst1Odd.groupBy(x\
    \ => x).mapValues(_.size)\n                val lst2OddMap = lst2Odd.groupBy(x\
    \ => x).mapValues(_.size)\n                val lst1OddMap2 = lst1OddMap.filter(x\
    \ => l\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp7wqy5xie.scala:42:4 ----------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp7wqy5xie.scala:54:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m54 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmp7wqy5xie.scala:41:57 ------------------------\e[0m\e[0m\n\
    \e[31m41 |\e[0m                \e[33mval\e[0m \e[36mlst1OddMap2\e[0m = lst1OddMap.filter(\e\
    [36mx\e[0m => l\n\e[31m\e[31m   |\e[0m                                       \
    \                  ^\e[0m\n\e[31m   |\e[0m                                   \
    \                      Not found: l\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp7wqy5xie.scala:53:1 ---------------------\e[0m\e[0m\n\e[31m53\
    \ |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:    Unit\n\e[31m\
    \   |\e[0m Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[33m\e[33m-- Warning: /tmp/tmp7wqy5xie.scala:43:4\
    \ ----------------------------------------\e[0m\e[0m\n\e[33m43 |\e[0m    \e[33mdef\e\
    [0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\
    \e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m   |\e[0m    Line is indented too far to\
    \ the left, or a `}` is missing\n1 warning found\n4 errors found\n"
  stdout: ''
  timestamp: 1659794255
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpiz0pkx1i.scala:22)\n\tat Problem.main(tmpiz0pkx1i.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        if (lst1.forall(x => x % 2 == 0)) return \"YES\"\n\
    \        if (lst2.forall(x => x % 2 == 0)) return \"YES\"\n        if (lst1.exists(x\
    \ => x % 2 == 0) && lst2.exists(x => x % 2 == 0)) return \"YES\"\n        \"NO\"\
    \n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptbvnies_.scala:26)\n\tat Problem.main(tmptbvnies_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794256
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        val lst1_even = lst1.filter(x => x % 2 == 0)\n  \
    \      val lst2_odd = lst2.filter(x => x % 2 == 1)\n        if (lst1_even.length\
    \ >= lst1.length) \"YES\"\n        else if (lst1_even.length + lst2_odd.length\
    \ >= lst1.length) \"YES\"\n        else \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpn5f3wj7w.scala:27)\n\tat Problem.main(tmpn5f3wj7w.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794256
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        return \"\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpf1jmku_q.scala:22)\n\tat Problem.main(tmpf1jmku_q.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpiz0pkx1i.scala:22)\n\tat Problem.main(tmpiz0pkx1i.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpiz0pkx1i.scala:22)\n\tat Problem.main(tmpiz0pkx1i.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        return \"\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpf1jmku_q.scala:22)\n\tat Problem.main(tmpf1jmku_q.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        val lst1Even = lst1.filter(_ % 2 == 0)\n        val\
    \ lst2Even = lst2.filter(_ % 2 == 0)\n        if (lst1Even.length == lst1.length)\
    \ \"YES\"\n        else if (lst2Even.length == lst2.length) \"YES\"\n        else\
    \ if (lst1Even.length + lst2Even.length >= lst1.length) \"YES\"\n        else\
    \ \"NO\"\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpiz0pkx1i.scala:22)\n\tat Problem.main(tmpiz0pkx1i.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        return \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxcxyj3yz.scala:22)\n\tat Problem.main(tmpxcxyj3yz.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794255
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        val lst1Even = lst1.filter(x => x % 2 == 0)\n   \
    \     val lst2Even = lst2.filter(x => x % 2 == 0)\n        if (lst1Even.length\
    \ == lst1.length) \"YES\"\n        else if (lst2Even.length == lst2.length) \"\
    YES\"\n        else if (lst1Even.length + lst2Even.length >= lst1.length) \"YES\"\
    \n        else \"NO\"\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        val lst1Even = lst1.filter(x => x % 2 == 0)\n   \
    \     val lst2Even = lst2.filter(x => x % 2 == 0)\n        if (lst1Even.length\
    \ >= lst1.length || lst2Even.length >= lst2.length) \"YES\"\n        else \"NO\"\
    \n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpullagdof.scala:25)\n\tat Problem.main(tmpullagdof.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794256
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        var evens = 0\n        var odds = 0\n        for\
    \ (i <- lst1) {\n            if (i % 2 == 0) evens += 1\n            else odds\
    \ += 1\n        }\n        for (i <- lst2) {\n            if (i % 2 == 0) odds\
    \ += 1\n            else evens += 1\n        }\n        if (evens == 0 || odds\
    \ == 0) \"YES\"\n        else \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpz_z6356d.scala:33)\n\tat Problem.main(tmpz_z6356d.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794256
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        null\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.NullPointerException: Cannot invoke \"String.equals(Object)\"\
    \ because the return value of \"Problem$.exchange(scala.collection.immutable.List,\
    \ scala.collection.immutable.List)\" is null\n\tat Problem$.main(tmpvos2b8_y.scala:22)\n\
    \tat Problem.main(tmpvos2b8_y.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        null\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.NullPointerException: Cannot invoke \"String.equals(Object)\"\
    \ because the return value of \"Problem$.exchange(scala.collection.immutable.List,\
    \ scala.collection.immutable.List)\" is null\n\tat Problem$.main(tmpvos2b8_y.scala:22)\n\
    \tat Problem.main(tmpvos2b8_y.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        return \"\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpf1jmku_q.scala:22)\n\tat Problem.main(tmpf1jmku_q.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        return \"\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpf1jmku_q.scala:22)\n\tat Problem.main(tmpf1jmku_q.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        var lst1Even = lst1.filter(_ % 2 == 0)\n        var\
    \ lst2Odd = lst2.filter(_ % 2 != 0)\n        if (lst1Even.length >= lst2Odd.length)\
    \ \"YES\" else \"NO\"\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659794256
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        return \"\";\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6ef5h24w.scala:22)\n\tat Problem.main(tmp6ef5h24w.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        null\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.NullPointerException: Cannot invoke \"String.equals(Object)\"\
    \ because the return value of \"Problem$.exchange(scala.collection.immutable.List,\
    \ scala.collection.immutable.List)\" is null\n\tat Problem$.main(tmpvos2b8_y.scala:22)\n\
    \tat Problem.main(tmpvos2b8_y.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpiz0pkx1i.scala:22)\n\tat Problem.main(tmpiz0pkx1i.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpiz0pkx1i.scala:22)\n\tat Problem.main(tmpiz0pkx1i.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        return \"\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpf1jmku_q.scala:22)\n\tat Problem.main(tmpf1jmku_q.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        null\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.NullPointerException: Cannot invoke \"String.equals(Object)\"\
    \ because the return value of \"Problem$.exchange(scala.collection.immutable.List,\
    \ scala.collection.immutable.List)\" is null\n\tat Problem$.main(tmpvos2b8_y.scala:22)\n\
    \tat Problem.main(tmpvos2b8_y.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        val lst1_even = lst1.filter(_ % 2 == 0)\n       \
    \ val lst2_odd = lst2.filter(_ % 2 == 1)\n        if (lst1_even.length + lst2_odd.length\
    \ >= lst1.length) \"YES\" else \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxz0kztud.scala:25)\n\tat Problem.main(tmpxz0kztud.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794256
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        val odd1 = lst1.filter(x => x % 2 == 1)\n       \
    \ val odd2 = lst2.filter(x => x % 2 == 1)\n        if (odd1.size > odd2.size)\
    \ \"NO\" else \"YES\"\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpihoi4h8g.scala:25)\n\tat Problem.main(tmpihoi4h8g.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794256
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        return \"\";\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6ef5h24w.scala:22)\n\tat Problem.main(tmp6ef5h24w.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        null\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.NullPointerException: Cannot invoke \"String.equals(Object)\"\
    \ because the return value of \"Problem$.exchange(scala.collection.immutable.List,\
    \ scala.collection.immutable.List)\" is null\n\tat Problem$.main(tmpvos2b8_y.scala:22)\n\
    \tat Problem.main(tmpvos2b8_y.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        val lst1_even = lst1.filter(x => x % 2 == 0)\n  \
    \      val lst2_odd = lst2.filter(x => x % 2 == 1)\n        if (lst1_even.length\
    \ + lst2_odd.length >= lst1.length) \"YES\" else \"NO\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpzvkw8gq8.scala:25)\n\tat Problem.main(tmpzvkw8gq8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794235
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpiz0pkx1i.scala:22)\n\tat Problem.main(tmpiz0pkx1i.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpiz0pkx1i.scala:22)\n\tat Problem.main(tmpiz0pkx1i.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        return \"\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpf1jmku_q.scala:22)\n\tat Problem.main(tmpf1jmku_q.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        null\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.NullPointerException: Cannot invoke \"String.equals(Object)\"\
    \ because the return value of \"Problem$.exchange(scala.collection.immutable.List,\
    \ scala.collection.immutable.List)\" is null\n\tat Problem$.main(tmpvos2b8_y.scala:22)\n\
    \tat Problem.main(tmpvos2b8_y.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        null\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.NullPointerException: Cannot invoke \"String.equals(Object)\"\
    \ because the return value of \"Problem$.exchange(scala.collection.immutable.List,\
    \ scala.collection.immutable.List)\" is null\n\tat Problem$.main(tmpvos2b8_y.scala:22)\n\
    \tat Problem.main(tmpvos2b8_y.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        if (lst1.filter(_ % 2 == 0).size == lst1.size) \"\
    YES\"\n        else {\n            val odd1 = lst1.filter(_ % 2 == 1)\n      \
    \      val odd2 = lst2.filter(_ % 2 == 1)\n            if (odd1.size == odd2.size)\
    \ \"YES\"\n            else \"NO\"\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptlayg6w9.scala:31)\n\tat Problem.main(tmptlayg6w9.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794256
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        if (lst1.exists(_ % 2 == 1)) {\n            if (lst2.exists(_\
    \ % 2 == 0)) {\n                return \"YES\"\n            }\n        }\n   \
    \     return \"NO\"\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpm36hz6se.scala:28)\n\tat Problem.main(tmpm36hz6se.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794265
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        var lst1_even = lst1.filter(x => x % 2 == 0)\n  \
    \      var lst2_odd = lst2.filter(x => x % 2 != 0)\n        if (lst1_even.length\
    \ == lst1.length) {\n            return \"YES\"\n        }\n        if (lst1_even.length\
    \ + lst2_odd.length >= lst1.length) {\n            return \"YES\"\n        }\n\
    \        return \"NO\"\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7ntjqwks.scala:31)\n\tat Problem.main(tmp7ntjqwks.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794265
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        if (lst1.filter(_ % 2 == 0).length == lst1.length)\
    \ \"YES\"\n        else {\n            val odd1 = lst1.filter(_ % 2 == 1)\n  \
    \          val odd2 = lst2.filter(_ % 2 == 1)\n            if (odd1.length ==\
    \ odd2.length) \"YES\"\n            else \"NO\"\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpqmztjp1l.scala:31)\n\tat Problem.main(tmpqmztjp1l.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794265
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        if (lst1.forall(x => x % 2 == 0)) \"YES\"\n     \
    \   else {\n            val odd1 = lst1.filter(x => x % 2 == 1)\n            val\
    \ odd2 = lst2.filter(x => x % 2 == 1)\n            if (odd1.length == odd2.length)\
    \ \"YES\"\n            else \"NO\"\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp9_y6uwre.scala:31)\n\tat Problem.main(tmp9_y6uwre.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794255
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        if (lst1.exists(x => x % 2 == 1)) {\n           \
    \ if (lst2.exists(x => x % 2 == 0)) {\n                \"YES\"\n            }\
    \ else {\n                \"NO\"\n            }\n        } else {\n          \
    \  \"YES\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpz56iou6e.scala:31)\n\tat Problem.main(tmpz56iou6e.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        return \"\";\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6ef5h24w.scala:22)\n\tat Problem.main(tmp6ef5h24w.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpiz0pkx1i.scala:22)\n\tat Problem.main(tmpiz0pkx1i.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        null\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.NullPointerException: Cannot invoke \"String.equals(Object)\"\
    \ because the return value of \"Problem$.exchange(scala.collection.immutable.List,\
    \ scala.collection.immutable.List)\" is null\n\tat Problem$.main(tmpvos2b8_y.scala:22)\n\
    \tat Problem.main(tmpvos2b8_y.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        null\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.NullPointerException: Cannot invoke \"String.equals(Object)\"\
    \ because the return value of \"Problem$.exchange(scala.collection.immutable.List,\
    \ scala.collection.immutable.List)\" is null\n\tat Problem$.main(tmpvos2b8_y.scala:22)\n\
    \tat Problem.main(tmpvos2b8_y.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        null\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.NullPointerException: Cannot invoke \"String.equals(Object)\"\
    \ because the return value of \"Problem$.exchange(scala.collection.immutable.List,\
    \ scala.collection.immutable.List)\" is null\n\tat Problem$.main(tmpvos2b8_y.scala:22)\n\
    \tat Problem.main(tmpvos2b8_y.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        null\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.NullPointerException: Cannot invoke \"String.equals(Object)\"\
    \ because the return value of \"Problem$.exchange(scala.collection.immutable.List,\
    \ scala.collection.immutable.List)\" is null\n\tat Problem$.main(tmpvos2b8_y.scala:22)\n\
    \tat Problem.main(tmpvos2b8_y.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpiz0pkx1i.scala:22)\n\tat Problem.main(tmpiz0pkx1i.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        return \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxcxyj3yz.scala:22)\n\tat Problem.main(tmpxcxyj3yz.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794255
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        return \"\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpf1jmku_q.scala:22)\n\tat Problem.main(tmpf1jmku_q.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        return \"\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpf1jmku_q.scala:22)\n\tat Problem.main(tmpf1jmku_q.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpiz0pkx1i.scala:22)\n\tat Problem.main(tmpiz0pkx1i.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        val lst1_even = lst1.filter(_ % 2 == 0)\n       \
    \ val lst2_odd = lst2.filter(_ % 2 == 1)\n        if (lst1_even.length + lst2_odd.length\
    \ >= lst1.length) \"YES\" else \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxz0kztud.scala:25)\n\tat Problem.main(tmpxz0kztud.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794256
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        null\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.NullPointerException: Cannot invoke \"String.equals(Object)\"\
    \ because the return value of \"Problem$.exchange(scala.collection.immutable.List,\
    \ scala.collection.immutable.List)\" is null\n\tat Problem$.main(tmpvos2b8_y.scala:22)\n\
    \tat Problem.main(tmpvos2b8_y.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        \"YES\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7m0l2vc5.scala:23)\n\tat Problem.main(tmp7m0l2vc5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        if (lst1.exists(_ % 2 == 1)) {\n            if (lst2.exists(_\
    \ % 2 == 0)) {\n                return \"YES\"\n            }\n        }\n   \
    \     return \"NO\"\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpm36hz6se.scala:28)\n\tat Problem.main(tmpm36hz6se.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794265
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        \"YES\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7m0l2vc5.scala:23)\n\tat Problem.main(tmp7m0l2vc5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        var lst1Even = lst1.filter(x => x % 2 == 0)\n   \
    \     var lst2Odd = lst2.filter(x => x % 2 != 0)\n        if (lst1Even.length\
    \ >= lst2Odd.length) {\n            return \"YES\"\n        }\n        return\
    \ \"NO\"\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659794265
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        val lst1_even = lst1.filter(x => x % 2 == 0)\n  \
    \      val lst2_odd = lst2.filter(x => x % 2 == 1)\n        if (lst1_even.length\
    \ >= lst1.length - lst2_odd.length) \"YES\" else \"NO\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmprhfekgmn.scala:25)\n\tat Problem.main(tmprhfekgmn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794265
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        var even1 = lst1.filter(_ % 2 == 0)\n        var\
    \ odd1 = lst1.filter(_ % 2 != 0)\n        var even2 = lst2.filter(_ % 2 == 0)\n\
    \        var odd2 = lst2.filter(_ % 2 != 0)\n        if (even1.length + even2.length\
    \ >= lst1.length) \"YES\" else \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659794265
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        var lst1_even = lst1.filter(x => x % 2 == 0)\n  \
    \      var lst2_odd = lst2.filter(x => x % 2 != 0)\n        if (lst1_even.length\
    \ >= lst2_odd.length) {\n            return \"YES\"\n        }\n        return\
    \ \"NO\"\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659794265
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpiz0pkx1i.scala:22)\n\tat Problem.main(tmpiz0pkx1i.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        val lst1_even = lst1.filter(_ % 2 == 0)\n       \
    \ val lst2_odd = lst2.filter(_ % 2 == 1)\n        if (lst1_even.length + lst2_odd.length\
    \ >= lst1.length) \"YES\" else \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxz0kztud.scala:25)\n\tat Problem.main(tmpxz0kztud.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794256
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        return \"\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpf1jmku_q.scala:22)\n\tat Problem.main(tmpf1jmku_q.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        if (lst1.filter(_ % 2 == 0).size == lst1.size) \"\
    YES\"\n        else if (lst2.filter(_ % 2 == 0).size == lst2.size) \"YES\"\n \
    \       else {\n            val lst1_odd = lst1.filter(_ % 2 == 1)\n         \
    \   val lst2_odd = lst2.filter(_ % 2 == 1)\n            if (lst1_odd.size == lst2_odd.size)\
    \ \"YES\"\n            else \"NO\"\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659794265
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        val lst1_odd = lst1.filter(x => x % 2 == 1)\n   \
    \     val lst2_even = lst2.filter(x => x % 2 == 0)\n        if (lst1_odd.length\
    \ <= lst2_even.length) \"YES\" else \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpiz0pkx1i.scala:22)\n\tat Problem.main(tmpiz0pkx1i.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        val lst1Even = lst1.filter(x => x % 2 == 0)\n   \
    \     val lst2Even = lst2.filter(x => x % 2 == 0)\n        if (lst1Even.length\
    \ == lst1.length) \"YES\"\n        else if (lst2Even.length == lst2.length) \"\
    YES\"\n        else if (lst1Even.length + lst2Even.length >= lst1.length) \"YES\"\
    \n        else \"NO\"\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpiz0pkx1i.scala:22)\n\tat Problem.main(tmpiz0pkx1i.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpiz0pkx1i.scala:22)\n\tat Problem.main(tmpiz0pkx1i.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpiz0pkx1i.scala:22)\n\tat Problem.main(tmpiz0pkx1i.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        var lst1_even = lst1.filter(x => x % 2 == 0)\n  \
    \      var lst2_odd = lst2.filter(x => x % 2 != 0)\n        if (lst1_even.length\
    \ == lst1.length) {\n            return \"YES\"\n        }\n        if (lst1_even.length\
    \ + lst2_odd.length >= lst1.length) {\n            return \"YES\"\n        }\n\
    \        return \"NO\"\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7ntjqwks.scala:31)\n\tat Problem.main(tmp7ntjqwks.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794265
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpiz0pkx1i.scala:22)\n\tat Problem.main(tmpiz0pkx1i.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        val lst1_even = lst1.filter(x => x % 2 == 0)\n  \
    \      val lst2_odd = lst2.filter(x => x % 2 == 1)\n        if (lst1_even.length\
    \ + lst2_odd.length >= lst1.length) \"YES\" else \"NO\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpzvkw8gq8.scala:25)\n\tat Problem.main(tmpzvkw8gq8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794235
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        null\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.NullPointerException: Cannot invoke \"String.equals(Object)\"\
    \ because the return value of \"Problem$.exchange(scala.collection.immutable.List,\
    \ scala.collection.immutable.List)\" is null\n\tat Problem$.main(tmpvos2b8_y.scala:22)\n\
    \tat Problem.main(tmpvos2b8_y.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        val lst1_even = lst1.filter(_ % 2 == 0)\n       \
    \ val lst2_odd = lst2.filter(_ % 2 == 1)\n        if (lst1_even.length + lst2_odd.length\
    \ == lst1.length) \"YES\" else \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8431ob5d.scala:27)\n\tat Problem.main(tmp8431ob5d.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794265
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        null\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.NullPointerException: Cannot invoke \"String.equals(Object)\"\
    \ because the return value of \"Problem$.exchange(scala.collection.immutable.List,\
    \ scala.collection.immutable.List)\" is null\n\tat Problem$.main(tmpvos2b8_y.scala:22)\n\
    \tat Problem.main(tmpvos2b8_y.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        null\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.NullPointerException: Cannot invoke \"String.equals(Object)\"\
    \ because the return value of \"Problem$.exchange(scala.collection.immutable.List,\
    \ scala.collection.immutable.List)\" is null\n\tat Problem$.main(tmpvos2b8_y.scala:22)\n\
    \tat Problem.main(tmpvos2b8_y.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        if (lst1.forall(x => x % 2 == 0)) {\n           \
    \ \"YES\"\n        } else {\n            val lst1odd = lst1.filter(x => x % 2\
    \ == 1)\n            val lst2even = lst2.filter(x => x % 2 == 0)\n           \
    \ if (lst1odd.length <= lst2even.length) {\n                \"YES\"\n        \
    \    } else {\n                \"NO\"\n            }\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659794265
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        return \"\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpf1jmku_q.scala:22)\n\tat Problem.main(tmpf1jmku_q.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        var lst1_even = lst1.filter(x => x % 2 == 0)\n  \
    \      var lst2_odd = lst2.filter(x => x % 2 != 0)\n        if (lst1_even.length\
    \ >= lst2_odd.length) {\n            return \"YES\"\n        }\n        return\
    \ \"NO\"\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659794265
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        var lst1_even = lst1.filter(x => x % 2 == 0)\n  \
    \      var lst2_odd = lst2.filter(x => x % 2 != 0)\n        if (lst1_even.length\
    \ >= lst2_odd.length) \"YES\" else \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659794265
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        return \"\";\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6ef5h24w.scala:22)\n\tat Problem.main(tmp6ef5h24w.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        null\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.NullPointerException: Cannot invoke \"String.equals(Object)\"\
    \ because the return value of \"Problem$.exchange(scala.collection.immutable.List,\
    \ scala.collection.immutable.List)\" is null\n\tat Problem$.main(tmpvos2b8_y.scala:22)\n\
    \tat Problem.main(tmpvos2b8_y.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Fill in the code here\n        \"YES\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0qsufc46.scala:23)\n\tat Problem.main(tmp0qsufc46.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // >>> exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)))\n    // (\"YES\")\n    // >>> exchange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))\n\
    \    // (\"NO\")\n    // It is assumed that the input lists will be non-empty.\n\
    \    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n       \
    \ // Your code here\n        \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpiz0pkx1i.scala:22)\n\tat Problem.main(tmpiz0pkx1i.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659794236
